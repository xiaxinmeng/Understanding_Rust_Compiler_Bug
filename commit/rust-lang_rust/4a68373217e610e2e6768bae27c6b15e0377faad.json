{"sha": "4a68373217e610e2e6768bae27c6b15e0377faad", "node_id": "C_kwDOAAsO6NoAKDRhNjgzNzMyMTdlNjEwZTJlNjc2OGJhZTI3YzZiMTVlMDM3N2ZhYWQ", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-09-09T20:08:06Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-10-07T12:06:16Z"}, "message": "Introduce TypeErrCtxt\n\nTypeErrCtxt optionally has a TypeckResults so that InferCtxt doesn't\nneed to.", "tree": {"sha": "166a47334b30099ffdd126726a1d4839680c0688", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/166a47334b30099ffdd126726a1d4839680c0688"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a68373217e610e2e6768bae27c6b15e0377faad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a68373217e610e2e6768bae27c6b15e0377faad", "html_url": "https://github.com/rust-lang/rust/commit/4a68373217e610e2e6768bae27c6b15e0377faad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a68373217e610e2e6768bae27c6b15e0377faad/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58546803885164d488185fb9cb9fb04fcbe64e30", "url": "https://api.github.com/repos/rust-lang/rust/commits/58546803885164d488185fb9cb9fb04fcbe64e30", "html_url": "https://github.com/rust-lang/rust/commit/58546803885164d488185fb9cb9fb04fcbe64e30"}], "stats": {"total": 1202, "additions": 634, "deletions": 568}, "files": [{"sha": "f261ff5227a94d75e3b83b8874bff715ad86955c", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> UniverseInfo<'tcx> {\n     ) {\n         match self.0 {\n             UniverseInfoInner::RelateTys { expected, found } => {\n-                let err = mbcx.infcx.report_mismatched_types(\n+                let err = mbcx.infcx.err_ctxt().report_mismatched_types(\n                     &cause,\n                     expected,\n                     found,\n@@ -449,42 +449,38 @@ fn try_extract_error_from_region_constraints<'tcx>(\n         })?;\n \n     debug!(?sub_region, \"cause = {:#?}\", cause);\n-    let nice_error = match (error_region, *sub_region) {\n-        (Some(error_region), ty::ReVar(vid)) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::SubSupConflict(\n-                vid,\n-                region_var_origin(vid),\n-                cause.clone(),\n-                error_region,\n-                cause.clone(),\n-                placeholder_region,\n-                vec![],\n-            ),\n-        ),\n-        (Some(error_region), _) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::ConcreteFailure(cause.clone(), error_region, placeholder_region),\n+    let error = match (error_region, *sub_region) {\n+        (Some(error_region), ty::ReVar(vid)) => RegionResolutionError::SubSupConflict(\n+            vid,\n+            region_var_origin(vid),\n+            cause.clone(),\n+            error_region,\n+            cause.clone(),\n+            placeholder_region,\n+            vec![],\n         ),\n+        (Some(error_region), _) => {\n+            RegionResolutionError::ConcreteFailure(cause.clone(), error_region, placeholder_region)\n+        }\n         // Note universe here is wrong...\n-        (None, ty::ReVar(vid)) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::UpperBoundUniverseConflict(\n-                vid,\n-                region_var_origin(vid),\n-                universe_of_region(vid),\n-                cause.clone(),\n-                placeholder_region,\n-            ),\n-        ),\n-        (None, _) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::ConcreteFailure(cause.clone(), sub_region, placeholder_region),\n+        (None, ty::ReVar(vid)) => RegionResolutionError::UpperBoundUniverseConflict(\n+            vid,\n+            region_var_origin(vid),\n+            universe_of_region(vid),\n+            cause.clone(),\n+            placeholder_region,\n         ),\n+        (None, _) => {\n+            RegionResolutionError::ConcreteFailure(cause.clone(), sub_region, placeholder_region)\n+        }\n     };\n-    nice_error.try_report_from_nll().or_else(|| {\n+    NiceRegionError::new(&infcx.err_ctxt(), error).try_report_from_nll().or_else(|| {\n         if let SubregionOrigin::Subtype(trace) = cause {\n-            Some(infcx.report_and_explain_type_error(*trace, TypeError::RegionsPlaceholderMismatch))\n+            Some(\n+                infcx\n+                    .err_ctxt()\n+                    .report_and_explain_type_error(*trace, TypeError::RegionsPlaceholderMismatch),\n+            )\n         } else {\n             None\n         }"}, {"sha": "15230718dc0dee21f140070050507b30338714ae", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     if let Some(lower_bound_region) = lower_bound_region {\n                         let generic_ty = type_test.generic_kind.to_ty(self.infcx.tcx);\n                         let origin = RelateParamBound(type_test_span, generic_ty, None);\n-                        self.buffer_error(self.infcx.construct_generic_bound_failure(\n+                        self.buffer_error(self.infcx.err_ctxt().construct_generic_bound_failure(\n                             self.body.source.def_id().expect_local(),\n                             type_test_span,\n                             Some(origin),\n@@ -365,7 +365,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let nice = NiceRegionError::new_from_span(self.infcx, cause.span, o, f);\n+            let infer_err = self.infcx.err_ctxt();\n+            let nice = NiceRegionError::new_from_span(&infer_err, cause.span, o, f);\n             if let Some(diag) = nice.try_report_from_nll() {\n                 self.buffer_error(diag);\n                 return;"}, {"sha": "019abd928314b48e5ea69fb38e4e3e6f8dc653fd", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::{\n     self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use crate::session_diagnostics::ConstNotUsedTraitAlias;\n@@ -299,6 +299,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                         Err(err) => {\n                             infcx\n+                                .err_ctxt()\n                                 .report_mismatched_types(\n                                     &ObligationCause::misc(instantiated_ty.span, body_id),\n                                     self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n@@ -325,7 +326,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     if errors.is_empty() {\n                         definition_ty\n                     } else {\n-                        infcx.report_fulfillment_errors(&errors, None, false);\n+                        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                         self.tcx.ty_error()\n                     }\n                 },"}, {"sha": "8c8cadcada80565013eafd6b59821125a16ca279", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeVisitable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCauseCode, SelectionContext, TraitEngine, TraitEngineExt,\n };\n@@ -775,7 +775,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         }\n                         let errors = fulfill_cx.select_all_or_error(&infcx);\n                         if !errors.is_empty() {\n-                            infcx.report_fulfillment_errors(&errors, None, false);\n+                            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                         }\n                     });\n \n@@ -837,7 +837,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                                 // as we are going to error again anyways.\n                                 tcx.infer_ctxt().enter(|infcx| {\n                                     if let Err(e) = implsrc {\n-                                        infcx.report_selection_error(\n+                                        infcx.err_ctxt().report_selection_error(\n                                             obligation.clone(),\n                                             &obligation,\n                                             &e,"}, {"sha": "b079ddde056d44e6bf9d79c71e26f1218eab28d1", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -29,7 +29,7 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n use rustc_ty_utils::representability::{self, Representability};\n \n@@ -760,7 +760,7 @@ fn check_opaque_meets_bounds<'tcx>(\n             // version.\n             let errors = ocx.select_all_or_error();\n             if !errors.is_empty() {\n-                infcx.report_fulfillment_errors(&errors, None, false);\n+                infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n             }\n             match origin {\n                 // Checked when type checking the function containing them."}, {"sha": "cf87fe3c510a421a0e09453fe3f0de769145c655", "filename": "compiler/rustc_hir_analysis/src/check/coercion.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -61,7 +61,7 @@ use rustc_span::symbol::sym;\n use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use smallvec::{smallvec, SmallVec};\n@@ -702,7 +702,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    self.report_selection_error(obligation.clone(), &obligation, &err, false);\n+                    self.err_ctxt().report_selection_error(\n+                        obligation.clone(),\n+                        &obligation,\n+                        &err,\n+                        false,\n+                    );\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later.\n@@ -1549,7 +1554,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                         }\n                     }\n                     _ => {\n-                        err = fcx.report_mismatched_types(\n+                        err = fcx.err_ctxt().report_mismatched_types(\n                             cause,\n                             expected,\n                             found,\n@@ -1629,7 +1634,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         expression: Option<&'tcx hir::Expr<'tcx>>,\n         blk_id: Option<hir::HirId>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n+        let mut err = fcx.err_ctxt().report_mismatched_types(cause, expected, found, ty_err);\n \n         let mut pointing_at_return_type = false;\n         let mut fn_output = None;"}, {"sha": "3b94f78703c30023e7a48cce81951398bb7b4041", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::ty::{\n };\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, ObligationCtxt, Reveal,\n@@ -395,7 +395,7 @@ fn compare_predicate_entailment<'tcx>(\n                 _ => {}\n             }\n \n-            infcx.note_type_err(\n+            infcx.err_ctxt().note_type_err(\n                 &mut diag,\n                 &cause,\n                 trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n@@ -415,7 +415,7 @@ fn compare_predicate_entailment<'tcx>(\n         // version.\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n         }\n \n@@ -508,7 +508,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n                     trait_m.name\n                 );\n                 let hir = tcx.hir();\n-                infcx.note_type_err(\n+                infcx.err_ctxt().note_type_err(\n                     &mut diag,\n                     &cause,\n                     hir.get_if_local(impl_m.def_id)\n@@ -530,7 +530,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n         // RPITs.\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n         }\n \n@@ -1382,7 +1382,7 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n                 }\n             });\n \n-            infcx.note_type_err(\n+            infcx.err_ctxt().note_type_err(\n                 &mut diag,\n                 &cause,\n                 trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n@@ -1401,7 +1401,7 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n         // version.\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            return Err(infcx.report_fulfillment_errors(&errors, None, false));\n+            return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None, false));\n         }\n \n         // FIXME return `ErrorReported` if region obligations error?\n@@ -1522,7 +1522,7 @@ fn compare_type_predicate_entailment<'tcx>(\n         // version.\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n         }\n \n@@ -1751,7 +1751,7 @@ pub fn check_type_bounds<'tcx>(\n         // version.\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n         }\n \n@@ -1769,6 +1769,7 @@ pub fn check_type_bounds<'tcx>(\n         let constraints = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n         for (key, value) in constraints {\n             infcx\n+                .err_ctxt()\n                 .report_mismatched_types(\n                     &ObligationCause::misc(\n                         value.hidden_type.span,"}, {"sha": "a5222c92331a9c6ebf8fc30ef9e97d884beb3264", "filename": "compiler/rustc_hir_analysis/src/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.register_predicates(obligations);\n                 None\n             }\n-            Err(e) => Some(self.report_mismatched_types(&cause, expected, actual, e)),\n+            Err(e) => Some(self.err_ctxt().report_mismatched_types(&cause, expected, actual, e)),\n         }\n     }\n \n@@ -109,7 +109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.register_predicates(obligations);\n                 None\n             }\n-            Err(e) => Some(self.report_mismatched_types(cause, expected, actual, e)),\n+            Err(e) => Some(self.err_ctxt().report_mismatched_types(cause, expected, actual, e)),\n         }\n     }\n \n@@ -153,7 +153,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr = expr.peel_drop_temps();\n         let cause = self.misc(expr.span);\n         let expr_ty = self.resolve_vars_with_obligations(checked_ty);\n-        let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e.clone());\n+        let mut err = self.err_ctxt().report_mismatched_types(&cause, expected, expr_ty, e.clone());\n \n         let is_insufficiently_polymorphic =\n             matches!(e, TypeError::RegionsInsufficientlyPolymorphic(..));"}, {"sha": "375c13d922bc7386677f182094c415cf49281019", "filename": "compiler/rustc_hir_analysis/src/check/expr.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -1649,13 +1649,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Err(_) => {\n                                         // This should never happen, since we're just subtyping the\n                                         // remaining_fields, but it's fine to emit this, I guess.\n-                                        self.report_mismatched_types(\n-                                            &cause,\n-                                            target_ty,\n-                                            fru_ty,\n-                                            FieldMisMatch(variant.name, ident.name),\n-                                        )\n-                                        .emit();\n+                                        self.err_ctxt()\n+                                            .report_mismatched_types(\n+                                                &cause,\n+                                                target_ty,\n+                                                fru_ty,\n+                                                FieldMisMatch(variant.name, ident.name),\n+                                            )\n+                                            .emit();\n                                     }\n                                 }\n                             }\n@@ -1942,7 +1943,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.set_tainted_by_errors();\n             return;\n         }\n-        let mut err = self.type_error_struct_with_diag(\n+        let mut err = self.err_ctxt().type_error_struct_with_diag(\n             field.ident.span,\n             |actual| match ty.kind() {\n                 ty::Adt(adt, ..) if adt.is_enum() => struct_span_err!("}, {"sha": "d140c3a0989900e26914cfdf5c676edc952a4979", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -32,7 +32,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n };\n@@ -615,7 +615,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !errors.is_empty() {\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut errors);\n-            self.report_fulfillment_errors(&errors, self.inh.body_id, false);\n+            self.err_ctxt().report_fulfillment_errors(&errors, self.inh.body_id, false);\n         }\n     }\n \n@@ -629,7 +629,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if !result.is_empty() {\n             mutate_fulfillment_errors(&mut result);\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut result);\n-            self.report_fulfillment_errors(&result, self.inh.body_id, fallback_has_occurred);\n+            self.err_ctxt().report_fulfillment_errors(\n+                &result,\n+                self.inh.body_id,\n+                fallback_has_occurred,\n+            );\n         }\n     }\n \n@@ -1466,7 +1470,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty\n         } else {\n             if !self.is_tainted_by_errors() {\n-                self.emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n+                self.err_ctxt()\n+                    .emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n                     .emit();\n             }\n             let err = self.tcx.ty_error();"}, {"sha": "285db90a9df55a69226cd9a1a16a63d847f808b5", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -650,7 +650,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if tys.len() == 1 {\n                         // A tuple wrap suggestion actually occurs within,\n                         // so don't do anything special here.\n-                        err = self.report_and_explain_type_error(\n+                        err = self.err_ctxt().report_and_explain_type_error(\n                             TypeTrace::types(\n                                 &self.misc(*lo),\n                                 true,\n@@ -742,7 +742,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let cause = &self.misc(provided_span);\n                 let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n                 if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308(_)) {\n-                    self.report_and_explain_type_error(trace, *e).emit();\n+                    self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n                     return true;\n                 }\n                 false\n@@ -766,7 +766,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let (provided_ty, provided_arg_span) = provided_arg_tys[*provided_idx];\n             let cause = &self.misc(provided_arg_span);\n             let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-            let mut err = self.report_and_explain_type_error(trace, *err);\n+            let mut err = self.err_ctxt().report_and_explain_type_error(trace, *err);\n             self.emit_coerce_suggestions(\n                 &mut err,\n                 &provided_args[*provided_idx],\n@@ -840,7 +840,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let cause = &self.misc(provided_span);\n                         let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n                         if let Some(e) = error {\n-                            self.note_type_err(\n+                            self.err_ctxt().note_type_err(\n                                 &mut err,\n                                 &trace.cause,\n                                 None,\n@@ -1474,7 +1474,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &mut |err| {\n                             if let Some(expected_ty) = expected.only_has_type(self) {\n                                 if !self.consider_removing_semicolon(blk, expected_ty, err) {\n-                                    self.consider_returning_binding(blk, expected_ty, err);\n+                                    self.err_ctxt().consider_returning_binding(\n+                                        blk,\n+                                        expected_ty,\n+                                        err,\n+                                    );\n                                 }\n                                 if expected_ty == self.tcx.types.bool {\n                                     // If this is caused by a missing `let` in a `while let`,"}, {"sha": "42ec2f418868d434c56d4f0b36e50deaabda5d4b", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -13,6 +13,7 @@ use crate::check::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer;\n+use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::subst::GenericArgKind;\n@@ -168,6 +169,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self.tcx.sess\n     }\n \n+    /// Creates an `TypeErrCtxt` with a reference to the in-progress\n+    /// `TypeckResults` which is used for diagnostics.\n+    /// Use [`InferCtxt::err_ctxt`] to start one without a `TypeckResults`.\n+    ///\n+    /// [`InferCtxt::err_ctxt`]: infer::InferCtxt::err_ctxt\n+    pub fn err_ctxt(&'a self) -> TypeErrCtxt<'a, 'tcx> {\n+        TypeErrCtxt { infcx: &self.infcx, typeck_results: Some(self.typeck_results.borrow()) }\n+    }\n+\n     pub fn errors_reported_since_creation(&self) -> bool {\n         self.tcx.sess.err_count() > self.err_count_on_creation\n     }"}, {"sha": "0ea150c969ec274fb437ca04563020fdee1cfa14", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // We'll later suggest `.as_ref` when noting the type error,\n         // so skip if we will suggest that instead.\n-        if self.should_suggest_as_ref(expected_ty, expr_ty).is_some() {\n+        if self.err_ctxt().should_suggest_as_ref(expected_ty, expr_ty).is_some() {\n             return false;\n         }\n \n@@ -1187,7 +1187,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n         err: &mut Diagnostic,\n     ) -> bool {\n-        if let Some((span_semi, boxed)) = self.could_remove_semicolon(blk, expected_ty) {\n+        if let Some((span_semi, boxed)) = self.err_ctxt().could_remove_semicolon(blk, expected_ty) {\n             if let StatementAsExpression::NeedsBoxing = boxed {\n                 err.span_suggestion_verbose(\n                     span_semi,"}, {"sha": "6c337e3eaba08aee221bc31de1bbdc9268ac47cd", "filename": "compiler/rustc_hir_analysis/src/check/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> Deref for Inherited<'a, 'tcx> {\n }\n \n /// A temporary returned by `Inherited::build(...)`. This is necessary\n-/// for multiple `InferCtxt` to share the same `in_progress_typeck_results`\n+/// for multiple `InferCtxt` to share the same `typeck_results`\n /// without using `Rc` or something similar.\n pub struct InheritedBuilder<'tcx> {\n     infcx: infer::InferCtxtBuilder<'tcx>,"}, {"sha": "e276c4f7d84c4ab3a2844a4fb5e9dbd34af24fc3", "filename": "compiler/rustc_hir_analysis/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n-use rustc_trait_selection::traits::error_reporting::on_unimplemented::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     FulfillmentError, Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedNote,\n@@ -855,8 +855,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             // Avoid crashing.\n                                             return (None, None);\n                                         }\n-                                        let OnUnimplementedNote { message, label, .. } =\n-                                            self.on_unimplemented_note(trait_ref, &obligation);\n+                                        let OnUnimplementedNote { message, label, .. } = self\n+                                            .err_ctxt()\n+                                            .on_unimplemented_note(trait_ref, &obligation);\n                                         (message, label)\n                                     })\n                                     .unwrap_or((None, None))"}, {"sha": "5e498a92ec20315fc44c1a46d2e88e3749f39d54", "filename": "compiler/rustc_hir_analysis/src/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -18,7 +18,7 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n use rustc_type_ir::sty::TyKind::*;\n \n@@ -512,7 +512,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         _ => None,\n                                     };\n \n-                                    self.suggest_restricting_param_bound(\n+                                    self.err_ctxt().suggest_restricting_param_bound(\n                                         &mut err,\n                                         trait_pred,\n                                         output_associated_item,\n@@ -662,7 +662,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             error.obligation.predicate.to_opt_poly_trait_pred()\n                         });\n                         for pred in predicates {\n-                            self.suggest_restricting_param_bound(\n+                            self.err_ctxt().suggest_restricting_param_bound(\n                                 &mut err,\n                                 pred,\n                                 None,"}, {"sha": "bcb7dfe9d3671c0bbfacf9560fca5254cfa77aa6", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -22,7 +22,7 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::autoderef::Autoderef;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n@@ -104,7 +104,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         f(&mut wfcx);\n         let errors = wfcx.select_all_or_error();\n         if !errors.is_empty() {\n-            infcx.report_fulfillment_errors(&errors, None, false);\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n             return;\n         }\n \n@@ -1677,7 +1677,7 @@ fn receiver_is_valid<'tcx>(\n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {\n         if let Err(err) = wfcx.equate_types(&cause, wfcx.param_env, self_ty, receiver_ty) {\n-            infcx.report_mismatched_types(&cause, self_ty, receiver_ty, err).emit();\n+            infcx.err_ctxt().report_mismatched_types(&cause, self_ty, receiver_ty, err).emit();\n         }\n         return true;\n     }\n@@ -1709,7 +1709,10 @@ fn receiver_is_valid<'tcx>(\n                 if let Err(err) =\n                     wfcx.equate_types(&cause, wfcx.param_env, self_ty, potential_self_ty)\n                 {\n-                    infcx.report_mismatched_types(&cause, self_ty, potential_self_ty, err).emit();\n+                    infcx\n+                        .err_ctxt()\n+                        .report_mismatched_types(&cause, self_ty, potential_self_ty, err)\n+                        .emit();\n                 }\n \n                 break;"}, {"sha": "c38b181523ebf7e391a5ce0b195797d7c4a72eda", "filename": "compiler/rustc_hir_analysis/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -720,6 +720,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n     fn report_error(&self, p: impl Into<ty::GenericArg<'tcx>>) {\n         if !self.tcx.sess.has_errors().is_some() {\n             self.infcx\n+                .err_ctxt()\n                 .emit_inference_failure_err(\n                     Some(self.body.id()),\n                     self.span.to_span(self.tcx),"}, {"sha": "2cc389498aff912f1e24b4223cbd2e960e3866f5", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitable};\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::misc::{can_type_implement_copy, CopyImplementationError};\n use rustc_trait_selection::traits::predicate_for_trait_def;\n use rustc_trait_selection::traits::{self, ObligationCause};\n@@ -324,7 +324,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                         }),\n                     );\n                     if !errors.is_empty() {\n-                        infcx.report_fulfillment_errors(&errors, None, false);\n+                        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                     }\n \n                     // Finally, resolve all regions.\n@@ -377,6 +377,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                            mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n             if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n                 infcx\n+                    .err_ctxt()\n                     .report_mismatched_types(\n                         &cause,\n                         mk_ptr(mt_b.ty),\n@@ -576,7 +577,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n         );\n         let errors = traits::fully_solve_obligation(&infcx, predicate);\n         if !errors.is_empty() {\n-            infcx.report_fulfillment_errors(&errors, None, false);\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n         }\n \n         // Finally, resolve all regions."}, {"sha": "9824df0c6bca55c6cfda171c95bad471a8d98d60", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -77,7 +77,7 @@ use rustc_middle::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, translate_substs, wf, ObligationCtxt};\n \n@@ -153,7 +153,7 @@ fn get_impl_substs<'tcx>(\n \n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            ocx.infcx.report_fulfillment_errors(&errors, None, false);\n+            ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n             return None;\n         }\n "}, {"sha": "4d3df5c0e525e830df7559ff7da57834fe31a1bf", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -110,7 +110,7 @@ use rustc_middle::util;\n use rustc_session::config::EntryFnType;\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use std::iter;\n@@ -146,15 +146,15 @@ fn require_same_types<'tcx>(\n         let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n             Err(err) => {\n-                infcx.report_mismatched_types(cause, expected, actual, err).emit();\n+                infcx.err_ctxt().report_mismatched_types(cause, expected, actual, err).emit();\n                 return false;\n             }\n         };\n \n         match &errors[..] {\n             [] => true,\n             errors => {\n-                infcx.report_fulfillment_errors(errors, None, false);\n+                infcx.err_ctxt().report_fulfillment_errors(errors, None, false);\n                 false\n             }\n         }\n@@ -318,7 +318,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n             ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n             let errors = ocx.select_all_or_error();\n             if !errors.is_empty() {\n-                infcx.report_fulfillment_errors(&errors, None, false);\n+                infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                 error = true;\n             }\n         });"}, {"sha": "f38d75cf770bd6e617b90ed9f16860497e201e93", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 75, "deletions": 44, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -75,7 +75,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n-use std::ops::ControlFlow;\n+use std::ops::{ControlFlow, Deref};\n use std::{cmp, fmt, iter};\n \n mod note;\n@@ -85,6 +85,31 @@ pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n \n+/// A helper for building type related errors. The `typeck_results`\n+/// field is only populated during an in-progress typeck.\n+/// Get an instance by calling `InferCtxt::err` or `FnCtxt::infer_err`.\n+pub struct TypeErrCtxt<'a, 'tcx> {\n+    pub infcx: &'a InferCtxt<'a, 'tcx>,\n+    pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n+}\n+\n+impl TypeErrCtxt<'_, '_> {\n+    /// This is just to avoid a potential footgun of accidentally\n+    /// dropping `typeck_results` by calling `InferCtxt::err_ctxt`\n+    #[deprecated(note = \"you already have a `TypeErrCtxt`\")]\n+    #[allow(unused)]\n+    pub fn err_ctxt(&self) -> ! {\n+        bug!(\"called `err_ctxt` on `TypeErrCtxt`. Try removing the call\");\n+    }\n+}\n+\n+impl<'a, 'tcx> Deref for TypeErrCtxt<'a, 'tcx> {\n+    type Target = InferCtxt<'a, 'tcx>;\n+    fn deref(&self) -> &InferCtxt<'a, 'tcx> {\n+        &self.infcx\n+    }\n+}\n+\n pub(super) fn note_and_explain_region<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     err: &mut Diagnostic,\n@@ -304,7 +329,39 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     err\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'_, 'tcx> {\n+    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Binder<'tcx, Ty<'tcx>>> {\n+        if let ty::Opaque(def_id, substs) = ty.kind() {\n+            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+            // Future::Output\n+            let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n+\n+            let bounds = self.tcx.bound_explicit_item_bounds(*def_id);\n+\n+            for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n+                let predicate = predicate.subst(self.tcx, substs);\n+                let output = predicate\n+                    .kind()\n+                    .map_bound(|kind| match kind {\n+                        ty::PredicateKind::Projection(projection_predicate)\n+                            if projection_predicate.projection_ty.item_def_id == item_def_id =>\n+                        {\n+                            projection_predicate.term.ty()\n+                        }\n+                        _ => None,\n+                    })\n+                    .transpose();\n+                if output.is_some() {\n+                    // We don't account for multiple `Future::Output = Ty` constraints.\n+                    return output;\n+                }\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub fn report_region_errors(\n         &self,\n         generic_param_scope: LocalDefId,\n@@ -578,13 +635,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 {\n                     // don't show type `_`\n                     if span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n-                    && let ty::Adt(def, substs) = ty.kind()\n-                    && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n+                        && let ty::Adt(def, substs) = ty.kind()\n+                        && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n                     {\n                         err.span_label(span, format!(\"this is an iterator with items of type `{}`\", substs.type_at(0)));\n                     } else {\n-                        err.span_label(span, format!(\"this expression has type `{}`\", ty));\n-                    }\n+                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n+                }\n                 }\n                 if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n                     && ty.is_box() && ty.boxed_ty() == found\n@@ -620,8 +677,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n                         let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n                             let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n-                            self.in_progress_typeck_results.and_then(|typeck_results| {\n-                                typeck_results.borrow().expr_ty_opt(arg_expr)\n+                            self.typeck_results.as_ref().and_then(|typeck_results| {\n+                                typeck_results.expr_ty_opt(arg_expr)\n                             })\n                         } else {\n                             bug!(\"try desugaring w/out call expr as scrutinee\");\n@@ -727,10 +784,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => {\n                 if let ObligationCauseCode::BindingObligation(_, span)\n                 | ObligationCauseCode::ExprBindingObligation(_, span, ..)\n-                    = cause.code().peel_derives()\n+                = cause.code().peel_derives()\n                     && let TypeError::RegionsPlaceholderMismatch = terr\n                 {\n-                    err.span_note(*span, \"the lifetime requirement is introduced here\");\n+                    err.span_note( * span,\n+                    \"the lifetime requirement is introduced here\");\n                 }\n             }\n         }\n@@ -1954,36 +2012,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Binder<'tcx, Ty<'tcx>>> {\n-        if let ty::Opaque(def_id, substs) = ty.kind() {\n-            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-            // Future::Output\n-            let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n-\n-            let bounds = self.tcx.bound_explicit_item_bounds(*def_id);\n-\n-            for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n-                let predicate = predicate.subst(self.tcx, substs);\n-                let output = predicate\n-                    .kind()\n-                    .map_bound(|kind| match kind {\n-                        ty::PredicateKind::Projection(projection_predicate)\n-                            if projection_predicate.projection_ty.item_def_id == item_def_id =>\n-                        {\n-                            projection_predicate.term.ty()\n-                        }\n-                        _ => None,\n-                    })\n-                    .transpose();\n-                if output.is_some() {\n-                    // We don't account for multiple `Future::Output = Ty` constraints.\n-                    return output;\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n     /// A possible error is to forget to add `.await` when using futures:\n     ///\n     /// ```compile_fail,E0308\n@@ -2431,7 +2459,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let generics = self.tcx.generics_of(generic_param_scope);\n@@ -3111,7 +3139,9 @@ impl<'tcx> InferCtxt<'_, 'tcx> {\n             _ => rustc_span::DUMMY_SP,\n         }\n     }\n+}\n \n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n     /// is enough to fix the error.\n     pub fn could_remove_semicolon(\n@@ -3128,7 +3158,7 @@ impl<'tcx> InferCtxt<'_, 'tcx> {\n         let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n             return None;\n         };\n-        let last_expr_ty = self.in_progress_typeck_results?.borrow().expr_ty_opt(*last_expr)?;\n+        let last_expr_ty = self.typeck_results.as_ref()?.expr_ty_opt(*last_expr)?;\n         let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n             _ if last_expr_ty.references_error() => return None,\n             _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n@@ -3211,8 +3241,9 @@ impl<'tcx> InferCtxt<'_, 'tcx> {\n         let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n             if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n                 && let Some(pat_ty) = self\n-                    .in_progress_typeck_results\n-                    .and_then(|typeck_results| typeck_results.borrow().node_type_opt(*hir_id))\n+                    .typeck_results\n+                    .as_ref()\n+                    .and_then(|typeck_results| typeck_results.node_type_opt(*hir_id))\n             {\n                 let pat_ty = self.resolve_vars_if_possible(pat_ty);\n                 if self.same_type_modulo_infer(pat_ty, expected_ty)"}, {"sha": "bf39892befc62a1a038de4a8945b7856de34a605", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -2,6 +2,7 @@ use crate::errors::{\n     AmbigousImpl, AmbigousReturn, AnnotationRequired, InferenceBadError, NeedTypeInfoInGenerator,\n     SourceKindMultiSuggestion, SourceKindSubdiag,\n };\n+use crate::infer::error_reporting::TypeErrCtxt;\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::InferCtxt;\n use rustc_errors::IntoDiagnostic;\n@@ -317,7 +318,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Used as a fallback in [InferCtxt::emit_inference_failure_err]\n+    /// Used as a fallback in [TypeErrCtxt::emit_inference_failure_err]\n     /// in case we weren't able to get a better error.\n     fn bad_inference_failure_err(\n         &self,\n@@ -364,7 +365,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n         }\n     }\n+}\n \n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub fn emit_inference_failure_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n@@ -376,14 +379,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let arg = self.resolve_vars_if_possible(arg);\n         let arg_data = self.extract_inference_diagnostics_data(arg, None);\n \n-        let Some(typeck_results) = self.in_progress_typeck_results else {\n+        let Some(typeck_results) = &self.typeck_results else {\n             // If we don't have any typeck results we're outside\n             // of a body, so we won't be able to get better info\n             // here.\n             return self.bad_inference_failure_err(failure_span, arg_data, error_code);\n         };\n-        let typeck_results = typeck_results.borrow();\n-        let typeck_results = &typeck_results;\n \n         let mut local_visitor = FindInferSourceVisitor::new(&self, typeck_results, arg);\n         if let Some(body_id) = body_id {\n@@ -563,7 +564,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n         }\n     }\n+}\n \n+impl<'tcx> InferCtxt<'_, 'tcx> {\n     pub fn need_type_info_err_in_generator(\n         &self,\n         kind: hir::GeneratorKind,"}, {"sha": "aaf5a7af00afaaa246e491bdc53af45ffec85163", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -1,6 +1,6 @@\n+use crate::infer::error_reporting::TypeErrCtxt;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError::*;\n-use crate::infer::InferCtxt;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::source_map::Span;\n@@ -19,34 +19,34 @@ pub use find_anon_type::find_anon_type;\n pub use static_impl_trait::{suggest_new_region_bound, HirTraitObjectVisitor, TraitObjectVisitor};\n pub use util::find_param_with_region;\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n-    pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n+impl<'cx, 'tcx> TypeErrCtxt<'cx, 'tcx> {\n+    pub fn try_report_nice_region_error(&'cx self, error: &RegionResolutionError<'tcx>) -> bool {\n         NiceRegionError::new(self, error.clone()).try_report().is_some()\n     }\n }\n \n pub struct NiceRegionError<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    cx: &'cx TypeErrCtxt<'cx, 'tcx>,\n     error: Option<RegionResolutionError<'tcx>>,\n     regions: Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)>,\n }\n \n impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>, error: RegionResolutionError<'tcx>) -> Self {\n-        Self { infcx, error: Some(error), regions: None }\n+    pub fn new(cx: &'cx TypeErrCtxt<'cx, 'tcx>, error: RegionResolutionError<'tcx>) -> Self {\n+        Self { cx, error: Some(error), regions: None }\n     }\n \n     pub fn new_from_span(\n-        infcx: &'cx InferCtxt<'cx, 'tcx>,\n+        cx: &'cx TypeErrCtxt<'cx, 'tcx>,\n         span: Span,\n         sub: ty::Region<'tcx>,\n         sup: ty::Region<'tcx>,\n     ) -> Self {\n-        Self { infcx, error: None, regions: Some((span, sub, sup)) }\n+        Self { cx, error: None, regions: Some((span, sub, sup)) }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n+        self.cx.tcx\n     }\n \n     pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {"}, {"sha": "a585168294a29994d116a835796ca451b4bfcbc3", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -226,12 +226,12 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             false\n         };\n \n-        let expected_trait_ref = self.infcx.resolve_vars_if_possible(ty::TraitRef {\n+        let expected_trait_ref = self.cx.resolve_vars_if_possible(ty::TraitRef {\n             def_id: trait_def_id,\n             substs: expected_substs,\n         });\n         let actual_trait_ref = self\n-            .infcx\n+            .cx\n             .resolve_vars_if_possible(ty::TraitRef { def_id: trait_def_id, substs: actual_substs });\n \n         // Search the expected and actual trait references to see (a)"}, {"sha": "6bb736687d6e511bb091f1ded49533429f65d264", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             tcx,\n             ctxt.param_env,\n             ctxt.assoc_item.def_id,\n-            self.infcx.resolve_vars_if_possible(ctxt.substs),\n+            self.cx.resolve_vars_if_possible(ctxt.substs),\n         ) else {\n             return false;\n         };"}, {"sha": "5d536e982ed028af28d6cb4b50e3b3f9d96b2cee", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -84,12 +84,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         let expected_highlight = HighlightBuilder::build(self.tcx(), expected);\n         let expected = self\n-            .infcx\n+            .cx\n             .extract_inference_diagnostics_data(expected.into(), Some(expected_highlight))\n             .name;\n         let found_highlight = HighlightBuilder::build(self.tcx(), found);\n         let found =\n-            self.infcx.extract_inference_diagnostics_data(found.into(), Some(found_highlight)).name;\n+            self.cx.extract_inference_diagnostics_data(found.into(), Some(found_highlight)).name;\n \n         err.span_label(sp, &format!(\"found `{}`\", found));\n         err.span_label(trait_sp, &format!(\"expected `{}`\", expected));"}, {"sha": "f1461d7010d5b41aab675347de2fa296e200c7a5", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let ret_ty = fn_ty.fn_sig(self.tcx()).output();\n             let span = hir_sig.decl.output.span();\n             let future_output = if hir_sig.header.is_async() {\n-                ret_ty.map_bound(|ty| self.infcx.get_impl_future_output_ty(ty)).transpose()\n+                ret_ty.map_bound(|ty| self.cx.get_impl_future_output_ty(ty)).transpose()\n             } else {\n                 None\n             };"}, {"sha": "a04245a23a211942856ef0a2622f8c25feff8c97", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -1,6 +1,6 @@\n use crate::errors::RegionOriginNote;\n-use crate::infer::error_reporting::note_and_explain_region;\n-use crate::infer::{self, InferCtxt, SubregionOrigin};\n+use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n+use crate::infer::{self, SubregionOrigin};\n use rustc_errors::{\n     fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n };\n@@ -10,7 +10,7 @@ use rustc_middle::ty::{self, Region};\n \n use super::ObligationCauseAsDiagArg;\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {"}, {"sha": "de017ba06c95dc5aec16aa6e23c09d81a7162a39", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 87, "deletions": 79, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -40,6 +40,7 @@ use std::cell::{Cell, Ref, RefCell};\n use std::fmt;\n \n use self::combine::CombineFields;\n+use self::error_reporting::TypeErrCtxt;\n use self::free_regions::RegionRelations;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n@@ -701,6 +702,12 @@ pub struct CombinedSnapshot<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    /// Creates a `TypeErrCtxt` for emitting various inference errors.\n+    /// During typeck, use `FnCtxt::infer_err` instead.\n+    pub fn err_ctxt(&'a self) -> TypeErrCtxt<'a, 'tcx> {\n+        TypeErrCtxt { infcx: self, typeck_results: None }\n+    }\n+\n     /// calls `tcx.try_unify_abstract_consts` after\n     /// canonicalizing the consts.\n     #[instrument(skip(self), level = \"debug\")]\n@@ -1343,32 +1350,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         errors\n     }\n-\n-    /// Process the region constraints and report any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    ///\n-    /// Make sure to call [`InferCtxt::process_registered_region_obligations`]\n-    /// first, or preferably use [`InferCtxt::check_region_obligations_and_report_errors`]\n-    /// to do both of these operations together.\n-    pub fn resolve_regions_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n-        let errors = self.resolve_regions(outlives_env);\n-\n-        if !self.is_tainted_by_errors() {\n-            // As a heuristic, just skip reporting region errors\n-            // altogether if other errors have been reported while\n-            // this infcx was in use.  This is totally hokey but\n-            // otherwise we have a hard time separating legit region\n-            // errors from silly ones.\n-            self.report_region_errors(generic_param_scope, &errors);\n-        }\n-    }\n-\n     /// Obtains (and clears) the current set of region\n     /// constraints. The inference context is still usable: further\n     /// unifications will simply add new constraints.\n@@ -1524,59 +1505,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         resolve::fully_resolve(self, value)\n     }\n \n-    // [Note-Type-error-reporting]\n-    // An invariant is that anytime the expected or actual type is Error (the special\n-    // error type, meaning that an error occurred when typechecking this expression),\n-    // this is a derived error. The error cascaded from another error (that was already\n-    // reported), so it's not useful to display it to the user.\n-    // The following methods implement this logic.\n-    // They check if either the actual or expected type is Error, and don't print the error\n-    // in this case. The typechecker should only ever report type errors involving mismatched\n-    // types using one of these methods, and should not call span_err directly for such\n-    // errors.\n-\n-    pub fn type_error_struct_with_diag<M>(\n-        &self,\n-        sp: Span,\n-        mk_diag: M,\n-        actual_ty: Ty<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>\n-    where\n-        M: FnOnce(String) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n-    {\n-        let actual_ty = self.resolve_vars_if_possible(actual_ty);\n-        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n-\n-        let mut err = mk_diag(self.ty_to_string(actual_ty));\n-\n-        // Don't report an error if actual type is `Error`.\n-        if actual_ty.references_error() {\n-            err.downgrade_to_delayed_bug();\n-        }\n-\n-        err\n-    }\n-\n-    pub fn report_mismatched_types(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n-        err: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        self.report_and_explain_type_error(TypeTrace::types(cause, true, expected, actual), err)\n-    }\n-\n-    pub fn report_mismatched_consts(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        expected: ty::Const<'tcx>,\n-        actual: ty::Const<'tcx>,\n-        err: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        self.report_and_explain_type_error(TypeTrace::consts(cause, true, expected, actual), err)\n-    }\n-\n     pub fn replace_bound_vars_with_fresh_vars<T>(\n         &self,\n         span: Span,\n@@ -1816,6 +1744,86 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    /// Process the region constraints and report any errors that\n+    /// result. After this, no more unification operations should be\n+    /// done -- or the compiler will panic -- but it is legal to use\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n+    ///\n+    /// Make sure to call [`InferCtxt::process_registered_region_obligations`]\n+    /// first, or preferably use [`InferCtxt::check_region_obligations_and_report_errors`]\n+    /// to do both of these operations together.\n+    pub fn resolve_regions_and_report_errors(\n+        &self,\n+        generic_param_scope: LocalDefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) {\n+        let errors = self.resolve_regions(outlives_env);\n+\n+        if !self.is_tainted_by_errors() {\n+            // As a heuristic, just skip reporting region errors\n+            // altogether if other errors have been reported while\n+            // this infcx was in use.  This is totally hokey but\n+            // otherwise we have a hard time separating legit region\n+            // errors from silly ones.\n+            self.report_region_errors(generic_param_scope, &errors);\n+        }\n+    }\n+\n+    // [Note-Type-error-reporting]\n+    // An invariant is that anytime the expected or actual type is Error (the special\n+    // error type, meaning that an error occurred when typechecking this expression),\n+    // this is a derived error. The error cascaded from another error (that was already\n+    // reported), so it's not useful to display it to the user.\n+    // The following methods implement this logic.\n+    // They check if either the actual or expected type is Error, and don't print the error\n+    // in this case. The typechecker should only ever report type errors involving mismatched\n+    // types using one of these methods, and should not call span_err directly for such\n+    // errors.\n+\n+    pub fn type_error_struct_with_diag<M>(\n+        &self,\n+        sp: Span,\n+        mk_diag: M,\n+        actual_ty: Ty<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>\n+    where\n+        M: FnOnce(String) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+    {\n+        let actual_ty = self.resolve_vars_if_possible(actual_ty);\n+        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n+\n+        let mut err = mk_diag(self.ty_to_string(actual_ty));\n+\n+        // Don't report an error if actual type is `Error`.\n+        if actual_ty.references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n+\n+        err\n+    }\n+\n+    pub fn report_mismatched_types(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        err: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        self.report_and_explain_type_error(TypeTrace::types(cause, true, expected, actual), err)\n+    }\n+\n+    pub fn report_mismatched_consts(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: ty::Const<'tcx>,\n+        actual: ty::Const<'tcx>,\n+        err: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        self.report_and_explain_type_error(TypeTrace::consts(cause, true, expected, actual), err)\n+    }\n+}\n+\n /// Helper for `ty_or_const_infer_var_changed` (see comment on that), currently\n /// used only for `traits::fulfill`'s list of `stalled_on` inference variables.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "53f662468e672b6d2ce0a6c5affe29b5838fc81d", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -183,7 +183,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             outlives_env.param_env,\n         );\n \n-        self.resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n+        self.err_ctxt().resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n     }\n }\n "}, {"sha": "a4b55dfa691df9a35346731228aa9a9a51d25a22", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -12,8 +12,8 @@ use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n-pub struct Sub<'combine, 'infcx, 'tcx> {\n-    fields: &'combine mut CombineFields<'infcx, 'tcx>,\n+pub struct Sub<'combine, 'a, 'tcx> {\n+    fields: &'combine mut CombineFields<'a, 'tcx>,\n     a_is_expected: bool,\n }\n "}, {"sha": "dde7527302c2057f016e7909553f32b498aa83ba", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -4,7 +4,7 @@\n // general routines.\n \n use crate::infer::{DefiningAnchor, TyCtxtInferExt};\n-use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::{\n     ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine, TraitEngineExt,\n     Unimplemented,\n@@ -69,7 +69,7 @@ pub fn codegen_select_candidate<'tcx>(\n             // `rustc_ty_utils::resolve_associated_item` doesn't return `None` post-monomorphization.\n             for err in errors {\n                 if let FulfillmentErrorCode::CodeCycle(cycle) = err.code {\n-                    infcx.report_overflow_error_cycle(&cycle);\n+                    infcx.err_ctxt().report_overflow_error_cycle(&cycle);\n                 }\n             }\n             return Err(CodegenObligationError::FulfillmentError);"}, {"sha": "09944404960af8b7f946345689ecc7112f9071b3", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 288, "deletions": 273, "changes": 561, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -22,6 +22,7 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n+use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::TypeTrace;\n use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::select::OverflowError;\n@@ -32,6 +33,8 @@ use rustc_middle::ty::{\n     self, SubtypePredicate, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeFoldable,\n     TypeVisitable,\n };\n+use rustc_session::Limit;\n+use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n@@ -41,8 +44,8 @@ use std::ops::ControlFlow;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n use crate::traits::specialize::to_pretty_impl_header;\n-use on_unimplemented::InferCtxtExt as _;\n-use suggestions::InferCtxtExt as _;\n+use on_unimplemented::TypeErrCtxtExt as _;\n+use suggestions::TypeErrCtxtExt as _;\n \n pub use rustc_infer::traits::error_reporting::*;\n \n@@ -63,6 +66,37 @@ pub struct ImplCandidate<'tcx> {\n }\n \n pub trait InferCtxtExt<'tcx> {\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)>;\n+\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n+\n+    /// Checks if the type implements one of `Fn`, `FnMut`, or `FnOnce`\n+    /// in that order, and returns the generic type corresponding to the\n+    /// argument of that trait (corresponding to the closure arguments).\n+    fn type_implements_fn_trait(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: ty::Binder<'tcx, Ty<'tcx>>,\n+        constness: ty::BoundConstness,\n+        polarity: ty::ImplPolarity,\n+    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()>;\n+}\n+\n+pub trait TypeErrCtxtExt<'tcx> {\n     fn report_fulfillment_errors(\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n@@ -78,6 +112,8 @@ pub trait InferCtxtExt<'tcx> {\n     where\n         T: fmt::Display + TypeFoldable<'tcx>;\n \n+    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic);\n+\n     fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> !;\n \n     /// The `root_obligation` parameter should be the `root_obligation` field\n@@ -90,12 +126,71 @@ pub trait InferCtxtExt<'tcx> {\n         error: &SelectionError<'tcx>,\n         fallback_has_occurred: bool,\n     );\n+}\n \n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'_, 'tcx> {\n     /// Given some node representing a fn-like thing in the HIR map,\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)>;\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)> {\n+        let sm = self.tcx.sess.source_map();\n+        let hir = self.tcx.hir();\n+        Some(match node {\n+            Node::Expr(&hir::Expr {\n+                kind: hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }),\n+                ..\n+            }) => (\n+                fn_decl_span,\n+                hir.body(body)\n+                    .params\n+                    .iter()\n+                    .map(|arg| {\n+                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n+                            *arg.pat\n+                        {\n+                            Some(ArgKind::Tuple(\n+                                Some(span),\n+                                args.iter()\n+                                    .map(|pat| {\n+                                        sm.span_to_snippet(pat.span)\n+                                            .ok()\n+                                            .map(|snippet| (snippet, \"_\".to_owned()))\n+                                    })\n+                                    .collect::<Option<Vec<_>>>()?,\n+                            ))\n+                        } else {\n+                            let name = sm.span_to_snippet(arg.pat.span).ok()?;\n+                            Some(ArgKind::Arg(name, \"_\".to_owned()))\n+                        }\n+                    })\n+                    .collect::<Option<Vec<ArgKind>>>()?,\n+            ),\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref sig, ..), .. })\n+            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(ref sig, _), .. })\n+            | Node::TraitItem(&hir::TraitItem {\n+                kind: hir::TraitItemKind::Fn(ref sig, _), ..\n+            }) => (\n+                sig.span,\n+                sig.decl\n+                    .inputs\n+                    .iter()\n+                    .map(|arg| match arg.kind {\n+                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n+                            Some(arg.span),\n+                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n+                        ),\n+                        _ => ArgKind::empty(),\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Ctor(ref variant_data) => {\n+                let span = variant_data.ctor_hir_id().map_or(DUMMY_SP, |id| hir.span(id));\n+                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n+            }\n+            _ => panic!(\"non-FnLike node found: {:?}\", node),\n+        })\n+    }\n \n     /// Reports an error when the number of arguments needed by a\n     /// trait match doesn't match the number that the expression\n@@ -107,21 +202,175 @@ pub trait InferCtxtExt<'tcx> {\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n+\n+        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n+            let arg_length = arguments.len();\n+            let distinct = matches!(other, &[ArgKind::Tuple(..)]);\n+            match (arg_length, arguments.get(0)) {\n+                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                    format!(\"a single {}-tuple as argument\", fields.len())\n+                }\n+                _ => format!(\n+                    \"{} {}argument{}\",\n+                    arg_length,\n+                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n+                    pluralize!(arg_length)\n+                ),\n+            }\n+        };\n+\n+        let expected_str = args_str(&expected_args, &found_args);\n+        let found_str = args_str(&found_args, &expected_args);\n+\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0593,\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n+        );\n+\n+        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n+\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+            // move |_| { ... }\n+            // ^^^^^^^^-- def_span\n+            //\n+            // move |_| { ... }\n+            // ^^^^^-- prefix\n+            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n+            // move |_| { ... }\n+            //      ^^^-- pipe_span\n+            let pipe_span =\n+                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n+\n+            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n+            // found arguments is empty (assume the user just wants to ignore args in this case).\n+            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n+            if found_args.is_empty() && is_closure {\n+                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n+                err.span_suggestion_verbose(\n+                    pipe_span,\n+                    &format!(\n+                        \"consider changing the closure to take and ignore the expected argument{}\",\n+                        pluralize!(expected_args.len())\n+                    ),\n+                    format!(\"|{}|\", underscores),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields\n+                        .iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n+                    err.span_suggestion_verbose(\n+                        found_span,\n+                        \"change the closure to take multiple arguments instead of a single tuple\",\n+                        format!(\"|{}|\", sugg),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..]\n+                && fields.len() == found_args.len()\n+                && is_closure\n+            {\n+                let sugg = format!(\n+                    \"|({}){}|\",\n+                    found_args\n+                        .iter()\n+                        .map(|arg| match arg {\n+                            ArgKind::Arg(name, _) => name.to_owned(),\n+                            _ => \"_\".to_owned(),\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    // add type annotations if available\n+                    if found_args.iter().any(|arg| match arg {\n+                        ArgKind::Arg(_, ty) => ty != \"_\",\n+                        _ => false,\n+                    }) {\n+                        format!(\n+                            \": ({})\",\n+                            fields\n+                                .iter()\n+                                .map(|(_, ty)| ty.to_owned())\n+                                .collect::<Vec<String>>()\n+                                .join(\", \")\n+                        )\n+                    } else {\n+                        String::new()\n+                    },\n+                );\n+                err.span_suggestion_verbose(\n+                    found_span,\n+                    \"change the closure to accept a tuple instead of individual arguments\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+\n+        err\n+    }\n \n-    /// Checks if the type implements one of `Fn`, `FnMut`, or `FnOnce`\n-    /// in that order, and returns the generic type corresponding to the\n-    /// argument of that trait (corresponding to the closure arguments).\n     fn type_implements_fn_trait(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         ty: ty::Binder<'tcx, Ty<'tcx>>,\n         constness: ty::BoundConstness,\n         polarity: ty::ImplPolarity,\n-    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()>;\n-}\n+    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()> {\n+        self.commit_if_ok(|_| {\n+            for trait_def_id in [\n+                self.tcx.lang_items().fn_trait(),\n+                self.tcx.lang_items().fn_mut_trait(),\n+                self.tcx.lang_items().fn_once_trait(),\n+            ] {\n+                let Some(trait_def_id) = trait_def_id else { continue };\n+                // Make a fresh inference variable so we can determine what the substitutions\n+                // of the trait are.\n+                let var = self.next_ty_var(TypeVariableOrigin {\n+                    span: DUMMY_SP,\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                });\n+                let substs = self.tcx.mk_substs_trait(ty.skip_binder(), &[var.into()]);\n+                let obligation = Obligation::new(\n+                    ObligationCause::dummy(),\n+                    param_env,\n+                    ty.rebind(ty::TraitPredicate {\n+                        trait_ref: ty::TraitRef::new(trait_def_id, substs),\n+                        constness,\n+                        polarity,\n+                    })\n+                    .to_predicate(self.tcx),\n+                );\n+                let mut fulfill_cx = FulfillmentContext::new_in_snapshot();\n+                fulfill_cx.register_predicate_obligation(self, obligation);\n+                if fulfill_cx.select_all_or_error(self).is_empty() {\n+                    return Ok((\n+                        ty::ClosureKind::from_def_id(self.tcx, trait_def_id)\n+                            .expect(\"expected to map DefId to ClosureKind\"),\n+                        ty.rebind(self.resolve_vars_if_possible(var)),\n+                    ));\n+                }\n+            }\n \n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+            Err(())\n+        })\n+    }\n+}\n+impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn report_fulfillment_errors(\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n@@ -251,6 +500,19 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         bug!();\n     }\n \n+    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic) {\n+        let suggested_limit = match self.tcx.recursion_limit() {\n+            Limit(0) => Limit(2),\n+            limit => limit * 2,\n+        };\n+        err.help(&format!(\n+            \"consider increasing the recursion limit by adding a \\\n+             `#![recursion_limit = \\\"{}\\\"]` attribute to your crate (`{}`)\",\n+            suggested_limit,\n+            self.tcx.crate_name(LOCAL_CRATE),\n+        ));\n+    }\n+\n     /// Reports that a cycle was detected which led to overflow and halts\n     /// compilation. This is equivalent to `report_overflow_error` except\n     /// that we can give a more helpful error message (and, in particular,\n@@ -498,7 +760,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n \n                         if let ObligationCauseCode::ObjectCastObligation(concrete_ty, obj_ty) = obligation.cause.code().peel_derives() &&\n-                           Some(trait_ref.def_id()) == self.tcx.lang_items().sized_trait() {\n+                            Some(trait_ref.def_id()) == self.tcx.lang_items().sized_trait() {\n                             self.suggest_borrowing_for_object_cast(&mut err, &root_obligation, *concrete_ty, *obj_ty);\n                         }\n \n@@ -606,11 +868,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // Try to report a help message\n                         if is_fn_trait\n                             && let Ok((implemented_kind, params)) = self.type_implements_fn_trait(\n-                                obligation.param_env,\n-                                trait_ref.self_ty(),\n-                                trait_predicate.skip_binder().constness,\n-                                trait_predicate.skip_binder().polarity,\n-                            )\n+                            obligation.param_env,\n+                            trait_ref.self_ty(),\n+                            trait_predicate.skip_binder().constness,\n+                            trait_predicate.skip_binder().polarity,\n+                        )\n                         {\n                             // If the type implements `Fn`, `FnMut`, or `FnOnce`, suppress the following\n                             // suggestion to add trait bounds for the type, since we only typically implement\n@@ -840,12 +1102,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n-                        if let Some(typeck_results) = self.in_progress_typeck_results {\n+                        if let Some(typeck_results) = &self.typeck_results {\n                             let hir_id = self\n                                 .tcx\n                                 .hir()\n                                 .local_def_id_to_hir_id(closure_def_id.expect_local());\n-                            let typeck_results = typeck_results.borrow();\n                             match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n                                 (ty::ClosureKind::FnOnce, Some((span, place))) => {\n                                     err.span_label(\n@@ -1088,250 +1349,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         err.emit();\n     }\n-\n-    /// Given some node representing a fn-like thing in the HIR map,\n-    /// returns a span and `ArgKind` information that describes the\n-    /// arguments it expects. This can be supplied to\n-    /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)> {\n-        let sm = self.tcx.sess.source_map();\n-        let hir = self.tcx.hir();\n-        Some(match node {\n-            Node::Expr(&hir::Expr {\n-                kind: hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }),\n-                ..\n-            }) => (\n-                fn_decl_span,\n-                hir.body(body)\n-                    .params\n-                    .iter()\n-                    .map(|arg| {\n-                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n-                            *arg.pat\n-                        {\n-                            Some(ArgKind::Tuple(\n-                                Some(span),\n-                                args.iter()\n-                                    .map(|pat| {\n-                                        sm.span_to_snippet(pat.span)\n-                                            .ok()\n-                                            .map(|snippet| (snippet, \"_\".to_owned()))\n-                                    })\n-                                    .collect::<Option<Vec<_>>>()?,\n-                            ))\n-                        } else {\n-                            let name = sm.span_to_snippet(arg.pat.span).ok()?;\n-                            Some(ArgKind::Arg(name, \"_\".to_owned()))\n-                        }\n-                    })\n-                    .collect::<Option<Vec<ArgKind>>>()?,\n-            ),\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref sig, ..), .. })\n-            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(ref sig, _), .. })\n-            | Node::TraitItem(&hir::TraitItem {\n-                kind: hir::TraitItemKind::Fn(ref sig, _), ..\n-            }) => (\n-                sig.span,\n-                sig.decl\n-                    .inputs\n-                    .iter()\n-                    .map(|arg| match arg.kind {\n-                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n-                            Some(arg.span),\n-                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n-                        ),\n-                        _ => ArgKind::empty(),\n-                    })\n-                    .collect::<Vec<ArgKind>>(),\n-            ),\n-            Node::Ctor(ref variant_data) => {\n-                let span = variant_data.ctor_hir_id().map_or(DUMMY_SP, |id| hir.span(id));\n-                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n-            }\n-            _ => panic!(\"non-FnLike node found: {:?}\", node),\n-        })\n-    }\n-\n-    /// Reports an error when the number of arguments needed by a\n-    /// trait match doesn't match the number that the expression\n-    /// provides.\n-    fn report_arg_count_mismatch(\n-        &self,\n-        span: Span,\n-        found_span: Option<Span>,\n-        expected_args: Vec<ArgKind>,\n-        found_args: Vec<ArgKind>,\n-        is_closure: bool,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let kind = if is_closure { \"closure\" } else { \"function\" };\n-\n-        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n-            let arg_length = arguments.len();\n-            let distinct = matches!(other, &[ArgKind::Tuple(..)]);\n-            match (arg_length, arguments.get(0)) {\n-                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n-                    format!(\"a single {}-tuple as argument\", fields.len())\n-                }\n-                _ => format!(\n-                    \"{} {}argument{}\",\n-                    arg_length,\n-                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n-                    pluralize!(arg_length)\n-                ),\n-            }\n-        };\n-\n-        let expected_str = args_str(&expected_args, &found_args);\n-        let found_str = args_str(&found_args, &expected_args);\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            span,\n-            E0593,\n-            \"{} is expected to take {}, but it takes {}\",\n-            kind,\n-            expected_str,\n-            found_str,\n-        );\n-\n-        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n-\n-        if let Some(found_span) = found_span {\n-            err.span_label(found_span, format!(\"takes {}\", found_str));\n-\n-            // move |_| { ... }\n-            // ^^^^^^^^-- def_span\n-            //\n-            // move |_| { ... }\n-            // ^^^^^-- prefix\n-            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n-            // move |_| { ... }\n-            //      ^^^-- pipe_span\n-            let pipe_span =\n-                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n-\n-            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n-            // found arguments is empty (assume the user just wants to ignore args in this case).\n-            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n-            if found_args.is_empty() && is_closure {\n-                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n-                err.span_suggestion_verbose(\n-                    pipe_span,\n-                    &format!(\n-                        \"consider changing the closure to take and ignore the expected argument{}\",\n-                        pluralize!(expected_args.len())\n-                    ),\n-                    format!(\"|{}|\", underscores),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n-                if fields.len() == expected_args.len() {\n-                    let sugg = fields\n-                        .iter()\n-                        .map(|(name, _)| name.to_owned())\n-                        .collect::<Vec<String>>()\n-                        .join(\", \");\n-                    err.span_suggestion_verbose(\n-                        found_span,\n-                        \"change the closure to take multiple arguments instead of a single tuple\",\n-                        format!(\"|{}|\", sugg),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..]\n-                && fields.len() == found_args.len()\n-                && is_closure\n-            {\n-                let sugg = format!(\n-                    \"|({}){}|\",\n-                    found_args\n-                        .iter()\n-                        .map(|arg| match arg {\n-                            ArgKind::Arg(name, _) => name.to_owned(),\n-                            _ => \"_\".to_owned(),\n-                        })\n-                        .collect::<Vec<String>>()\n-                        .join(\", \"),\n-                    // add type annotations if available\n-                    if found_args.iter().any(|arg| match arg {\n-                        ArgKind::Arg(_, ty) => ty != \"_\",\n-                        _ => false,\n-                    }) {\n-                        format!(\n-                            \": ({})\",\n-                            fields\n-                                .iter()\n-                                .map(|(_, ty)| ty.to_owned())\n-                                .collect::<Vec<String>>()\n-                                .join(\", \")\n-                        )\n-                    } else {\n-                        String::new()\n-                    },\n-                );\n-                err.span_suggestion_verbose(\n-                    found_span,\n-                    \"change the closure to accept a tuple instead of individual arguments\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-\n-        err\n-    }\n-\n-    fn type_implements_fn_trait(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: ty::Binder<'tcx, Ty<'tcx>>,\n-        constness: ty::BoundConstness,\n-        polarity: ty::ImplPolarity,\n-    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()> {\n-        self.commit_if_ok(|_| {\n-            for trait_def_id in [\n-                self.tcx.lang_items().fn_trait(),\n-                self.tcx.lang_items().fn_mut_trait(),\n-                self.tcx.lang_items().fn_once_trait(),\n-            ] {\n-                let Some(trait_def_id) = trait_def_id else { continue };\n-                // Make a fresh inference variable so we can determine what the substitutions\n-                // of the trait are.\n-                let var = self.next_ty_var(TypeVariableOrigin {\n-                    span: DUMMY_SP,\n-                    kind: TypeVariableOriginKind::MiscVariable,\n-                });\n-                let substs = self.tcx.mk_substs_trait(ty.skip_binder(), &[var.into()]);\n-                let obligation = Obligation::new(\n-                    ObligationCause::dummy(),\n-                    param_env,\n-                    ty.rebind(ty::TraitPredicate {\n-                        trait_ref: ty::TraitRef::new(trait_def_id, substs),\n-                        constness,\n-                        polarity,\n-                    })\n-                    .to_predicate(self.tcx),\n-                );\n-                let mut fulfill_cx = FulfillmentContext::new_in_snapshot();\n-                fulfill_cx.register_predicate_obligation(self, obligation);\n-                if fulfill_cx.select_all_or_error(self).is_empty() {\n-                    return Ok((\n-                        ty::ClosureKind::from_def_id(self.tcx, trait_def_id)\n-                            .expect(\"expected to map DefId to ClosureKind\"),\n-                        ty.rebind(self.resolve_vars_if_possible(var)),\n-                    ));\n-                }\n-            }\n-\n-            Err(())\n-        })\n-    }\n }\n \n-trait InferCtxtPrivExt<'hir, 'tcx> {\n+trait InferCtxtPrivExt<'tcx> {\n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n     fn error_implies(&self, cond: ty::Predicate<'tcx>, error: ty::Predicate<'tcx>) -> bool;\n@@ -1430,13 +1450,13 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n         predicate: ty::Predicate<'tcx>,\n     );\n \n-    fn maybe_suggest_unsized_generics(&self, err: &mut Diagnostic, span: Span, node: Node<'hir>);\n+    fn maybe_suggest_unsized_generics(&self, err: &mut Diagnostic, span: Span, node: Node<'tcx>);\n \n     fn maybe_indirection_for_unsized(\n         &self,\n         err: &mut Diagnostic,\n-        item: &'hir Item<'hir>,\n-        param: &'hir GenericParam<'hir>,\n+        item: &'tcx Item<'tcx>,\n+        param: &'tcx GenericParam<'tcx>,\n     ) -> bool;\n \n     fn is_recursive_obligation(\n@@ -1446,7 +1466,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     ) -> bool;\n }\n \n-impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n     fn error_implies(&self, cond: ty::Predicate<'tcx>, error: ty::Predicate<'tcx>) -> bool {\n@@ -2581,12 +2601,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip_all)]\n-    fn maybe_suggest_unsized_generics<'hir>(\n-        &self,\n-        err: &mut Diagnostic,\n-        span: Span,\n-        node: Node<'hir>,\n-    ) {\n+    fn maybe_suggest_unsized_generics(&self, err: &mut Diagnostic, span: Span, node: Node<'tcx>) {\n         let Some(generics) = node.generics() else {\n             return;\n         };\n@@ -2637,11 +2652,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         );\n     }\n \n-    fn maybe_indirection_for_unsized<'hir>(\n+    fn maybe_indirection_for_unsized(\n         &self,\n         err: &mut Diagnostic,\n-        item: &'hir Item<'hir>,\n-        param: &'hir GenericParam<'hir>,\n+        item: &Item<'tcx>,\n+        param: &GenericParam<'tcx>,\n     ) -> bool {\n         // Suggesting `T: ?Sized` is only valid in an ADT if `T` is only used in a\n         // borrow. `struct S<'a, T: ?Sized>(&'a T);` is valid, `struct S<T: ?Sized>(T);`"}, {"sha": "0f20e02d6ecc96f91b93912677a4294210e79235", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -1,7 +1,7 @@\n use super::{\n     ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n };\n-use crate::infer::InferCtxt;\n+use crate::infer::error_reporting::TypeErrCtxt;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::SubstsRef;\n@@ -11,7 +11,7 @@ use std::iter;\n \n use super::InferCtxtPrivExt;\n \n-pub trait InferCtxtExt<'tcx> {\n+pub trait TypeErrCtxtExt<'tcx> {\n     /*private*/\n     fn impl_similar_to(\n         &self,\n@@ -29,7 +29,7 @@ pub trait InferCtxtExt<'tcx> {\n     ) -> OnUnimplementedNote;\n }\n \n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn impl_similar_to(\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,"}, {"sha": "ca096d3cfc8107663ca5788e59c7deb070b34d56", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -20,6 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n+use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::hir::map;\n use rustc_middle::ty::{\n@@ -28,8 +29,6 @@ use rustc_middle::ty::{\n     ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n-use rustc_session::Limit;\n-use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n@@ -168,7 +167,7 @@ impl<'tcx, 'a> GeneratorData<'tcx, 'a> {\n }\n \n // This trait is public to expose the diagnostics methods to clippy.\n-pub trait InferCtxtExt<'tcx> {\n+pub trait TypeErrCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         err: &mut Diagnostic,\n@@ -296,8 +295,6 @@ pub trait InferCtxtExt<'tcx> {\n     ) where\n         T: fmt::Display;\n \n-    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic);\n-\n     /// Suggest to await before try: future? => future.await?\n     fn suggest_await_before_try(\n         &self,\n@@ -461,7 +458,7 @@ fn suggest_restriction<'tcx>(\n     }\n }\n \n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut Diagnostic,\n@@ -675,9 +672,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // It only make sense when suggesting dereferences for arguments\n         let ObligationCauseCode::FunctionArgumentObligation { arg_hir_id, .. } = obligation.cause.code()\n             else { return false; };\n-        let Some(typeck_results) = self.in_progress_typeck_results\n+        let Some(typeck_results) = &self.typeck_results\n             else { return false; };\n-        let typeck_results = typeck_results.borrow();\n         let hir::Node::Expr(expr) = self.tcx.hir().get(*arg_hir_id)\n             else { return false; };\n         let Some(arg_ty) = typeck_results.expr_ty_adjusted_opt(expr)\n@@ -1176,8 +1172,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 &format!(\"this call returns `{}`\", pred.self_ty()),\n                             );\n                         }\n-                        if let Some(typeck_results) =\n-                            self.in_progress_typeck_results.map(|t| t.borrow())\n+                        if let Some(typeck_results) = &self.typeck_results\n                             && let ty = typeck_results.expr_ty_adjusted(base)\n                             && let ty::FnDef(def_id, _substs) = ty.kind()\n                             && let Some(hir::Node::Item(hir::Item { ident, span, vis_span, .. })) =\n@@ -1300,8 +1295,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             && let Some(stmt) = blk.stmts.last()\n             && let hir::StmtKind::Semi(expr) = stmt.kind\n             // Only suggest this if the expression behind the semicolon implements the predicate\n-            && let Some(typeck_results) = self.in_progress_typeck_results\n-            && let Some(ty) = typeck_results.borrow().expr_ty_opt(expr)\n+            && let Some(typeck_results) = &self.typeck_results\n+            && let Some(ty) = typeck_results.expr_ty_opt(expr)\n             && self.predicate_may_hold(&self.mk_trait_obligation_with_new_self_ty(\n                 obligation.param_env, trait_pred.map_bound(|trait_pred| (trait_pred, ty))\n             ))\n@@ -1390,7 +1385,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut visitor = ReturnsVisitor::default();\n         visitor.visit_body(&body);\n \n-        let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n+        let typeck_results = self.typeck_results.as_ref().unwrap();\n         let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id).copied() else { return false; };\n \n         let ret_types = visitor\n@@ -1573,7 +1568,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // Point at all the `return`s in the function as they have failed trait bounds.\n             let mut visitor = ReturnsVisitor::default();\n             visitor.visit_body(&body);\n-            let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n+            let typeck_results = self.typeck_results.as_ref().unwrap();\n             for expr in &visitor.returns {\n                 if let Some(returned_ty) = typeck_results.node_type_opt(expr.hir_id) {\n                     let ty = self.resolve_vars_if_possible(returned_ty);\n@@ -1841,12 +1836,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let span = self.tcx.def_span(generator_did);\n \n-        let in_progress_typeck_results = self.in_progress_typeck_results.map(|t| t.borrow());\n         let generator_did_root = self.tcx.typeck_root_def_id(generator_did);\n         debug!(\n             ?generator_did,\n             ?generator_did_root,\n-            in_progress_typeck_results.hir_owner = ?in_progress_typeck_results.as_ref().map(|t| t.hir_owner),\n+            typeck_results.hir_owner = ?self.typeck_results.as_ref().map(|t| t.hir_owner),\n             ?span,\n         );\n \n@@ -1901,7 +1895,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // type-checking; otherwise, get them by performing a query.  This is needed to avoid\n         // cycles. If we can't use resolved types because the generator comes from another crate,\n         // we still provide a targeted error but without all the relevant spans.\n-        let generator_data: Option<GeneratorData<'tcx, '_>> = match &in_progress_typeck_results {\n+        let generator_data: Option<GeneratorData<'tcx, '_>> = match &self.typeck_results {\n             Some(t) if t.hir_owner.to_def_id() == generator_did_root => {\n                 Some(GeneratorData::Local(&t))\n             }\n@@ -2707,10 +2701,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if let Some(Node::Expr(expr @ hir::Expr { kind: hir::ExprKind::Block(..), .. })) =\n                     hir.find(arg_hir_id)\n                 {\n-                    let in_progress_typeck_results =\n-                        self.in_progress_typeck_results.map(|t| t.borrow());\n                     let parent_id = hir.get_parent_item(arg_hir_id);\n-                    let typeck_results: &TypeckResults<'tcx> = match &in_progress_typeck_results {\n+                    let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n                         Some(t) if t.hir_owner == parent_id => t,\n                         _ => self.tcx.typeck(parent_id.def_id),\n                     };\n@@ -2797,19 +2789,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic) {\n-        let suggested_limit = match self.tcx.recursion_limit() {\n-            Limit(0) => Limit(2),\n-            limit => limit * 2,\n-        };\n-        err.help(&format!(\n-            \"consider increasing the recursion limit by adding a \\\n-             `#![recursion_limit = \\\"{}\\\"]` attribute to your crate (`{}`)\",\n-            suggested_limit,\n-            self.tcx.crate_name(LOCAL_CRATE),\n-        ));\n-    }\n-\n     #[instrument(\n         level = \"debug\", skip(self, err), fields(trait_pred.self_ty = ?trait_pred.self_ty())\n     )]"}, {"sha": "f0346e4ae69252bb7bfd7d9773f9c5083c005c25", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -7,7 +7,7 @@ use rustc_hir as hir;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n \n-use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::error_reporting::TypeErrCtxtExt;\n \n #[derive(Clone)]\n pub enum CopyImplementationError<'tcx> {\n@@ -70,7 +70,7 @@ pub fn can_type_implement_copy<'tcx>(\n                         }\n                     }\n                     Err(errors) => {\n-                        infcx.report_fulfillment_errors(&errors, None, false);\n+                        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                     }\n                 };\n             }"}, {"sha": "02fa8747efa4172f93b559c483bab75b6b5d685c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -26,7 +26,7 @@ pub mod wf;\n use crate::errors::DumpVTableEntries;\n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n-use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::error_reporting::TypeErrCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -238,7 +238,7 @@ fn do_normalize_predicates<'tcx>(\n         let predicates = match fully_normalize(&infcx, cause, elaborated_env, predicates) {\n             Ok(predicates) => predicates,\n             Err(errors) => {\n-                let reported = infcx.report_fulfillment_errors(&errors, None, false);\n+                let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                 return Err(reported);\n             }\n         };"}, {"sha": "1913fabdc57f909e1483f618c52ca60e472237fc", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -18,7 +18,7 @@ use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::error_reporting::TypeErrCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::select::ProjectionMatchesProjection;\n use rustc_data_structures::sso::SsoHashSet;\n@@ -513,7 +513,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                                 self.param_env,\n                                 ty,\n                             );\n-                            self.selcx.infcx().report_overflow_error(&obligation, true);\n+                            self.selcx.infcx().err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let substs = substs.fold_with(self);\n@@ -569,7 +569,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                         self.param_env,\n                         ty,\n                     );\n-                    self.selcx.infcx().report_overflow_error(&obligation, true);\n+                    self.selcx.infcx().err_ctxt().report_overflow_error(&obligation, true);\n                 }\n                 debug!(\n                     ?self.depth,"}, {"sha": "5af88ffc109c9cf702b806ee52453e527299f4b0", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -5,7 +5,7 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::{needs_normalization, BoundVarReplacer, PlaceholderReplacer};\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use rustc_data_structures::sso::SsoHashMap;\n@@ -213,7 +213,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                                 self.param_env,\n                                 ty,\n                             );\n-                            self.infcx.report_overflow_error(&obligation, true);\n+                            self.infcx.err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let generic_ty = self.tcx().bound_type_of(def_id);"}, {"sha": "f9e4b8325466ed21b5af330ad6b502c9a70337b3", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -20,7 +20,7 @@ use super::{\n };\n \n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n-use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::ProjectAndUnifyResult;\n use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n@@ -1095,7 +1095,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             ErrorGuaranteed::unchecked_claim_error_was_emitted(),\n                         ));\n                     }\n-                    self.infcx.report_overflow_error(error_obligation, true);\n+                    self.infcx.err_ctxt().report_overflow_error(error_obligation, true);\n                 }\n                 TraitQueryMode::Canonical => {\n                     return Err(OverflowError::Canonical);"}, {"sha": "406c842a6d053b96c39c4ff214db41088ec844bf", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a68373217e610e2e6768bae27c6b15e0377faad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68373217e610e2e6768bae27c6b15e0377faad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=4a68373217e610e2e6768bae27c6b15e0377faad", "patch": "@@ -7,7 +7,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{EarlyBinder, Opaque, PredicateKind::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n-use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n use rustc_trait_selection::traits::{self, FulfillmentError};\n \n declare_clippy_lint! {\n@@ -90,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                         |db| {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n-                                    infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n+                                    infcx.err_ctxt().maybe_note_obligation_cause_for_async_await(db, &obligation);\n                                     if let Trait(trait_pred) = obligation.predicate.kind().skip_binder() {\n                                         db.note(&format!(\n                                             \"`{}` doesn't implement `{}`\","}]}