{"sha": "fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNDhmOWY0ZDI0M2FmZjU5YWJjNDRlOWVmOWNjY2U5ZDQzYzAxYTg=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-05T07:30:19Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-05T07:30:19Z"}, "message": "Merge #912\n\n912: Make goto definition/hover work for associated items r=matklad a=kjeremy\n\nJust functions so far. Looking for comments.\r\n\r\nFixes #911\r\nTowards #832\n\nCo-authored-by: kjeremy <kjeremy@gmail.com>\nCo-authored-by: Jeremy Kolb <kjeremy@gmail.com>", "tree": {"sha": "6f0c4e58df74819bf0793c93ca1ad7ae16d9f05c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f0c4e58df74819bf0793c93ca1ad7ae16d9f05c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8", "html_url": "https://github.com/rust-lang/rust/commit/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "bbaf750b10810c21d42710a5d12181ca73099525", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbaf750b10810c21d42710a5d12181ca73099525", "html_url": "https://github.com/rust-lang/rust/commit/bbaf750b10810c21d42710a5d12181ca73099525"}, {"sha": "ac678473b85da24fc15315054e9737347fadb55c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac678473b85da24fc15315054e9737347fadb55c", "html_url": "https://github.com/rust-lang/rust/commit/ac678473b85da24fc15315054e9737347fadb55c"}], "stats": {"total": 140, "additions": 116, "deletions": 24}, "files": [{"sha": "268d2c1104692942ad1afb77b9df2d0f25d28729", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 54, "deletions": 19, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8", "patch": "@@ -29,6 +29,7 @@ use crate::{\n     Function, StructField, Path, Name,\n     FnSignature, AdtDef,\n     HirDatabase,\n+    ImplItem,\n     type_ref::{TypeRef, Mutability},\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n     generics::GenericParams,\n@@ -54,13 +55,23 @@ pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n     Arc::new(ctx.resolve_all())\n }\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+enum ExprOrPatId {\n+    ExprId(ExprId),\n+    PatId(PatId),\n+}\n+\n+impl_froms!(ExprOrPatId: ExprId, PatId);\n+\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n     /// For each method call expr, records the function it resolves to.\n     method_resolutions: FxHashMap<ExprId, Function>,\n     /// For each field access expr, records the field it resolves to.\n     field_resolutions: FxHashMap<ExprId, StructField>,\n+    /// For each associated item record what it resolves to\n+    assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n }\n@@ -72,6 +83,12 @@ impl InferenceResult {\n     pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n         self.field_resolutions.get(&expr).map(|it| *it)\n     }\n+    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<ImplItem> {\n+        self.assoc_resolutions.get(&id.into()).map(|it| *it)\n+    }\n+    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<ImplItem> {\n+        self.assoc_resolutions.get(&id.into()).map(|it| *it)\n+    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -99,6 +116,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n     field_resolutions: FxHashMap<ExprId, StructField>,\n+    assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n@@ -110,6 +128,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         InferenceContext {\n             method_resolutions: FxHashMap::default(),\n             field_resolutions: FxHashMap::default(),\n+            assoc_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n@@ -135,6 +154,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         InferenceResult {\n             method_resolutions: self.method_resolutions,\n             field_resolutions: self.field_resolutions,\n+            assoc_resolutions: self.assoc_resolutions,\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n         }\n@@ -152,6 +172,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.field_resolutions.insert(expr, field);\n     }\n \n+    fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: ImplItem) {\n+        self.assoc_resolutions.insert(id, item);\n+    }\n+\n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n         self.type_of_pat.insert(pat, ty);\n     }\n@@ -341,7 +365,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path) -> Option<Ty> {\n+    fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n         let resolved = resolver.resolve_path_segments(self.db, &path);\n \n         let (def, remaining_index) = resolved.into_inner();\n@@ -393,34 +417,45 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             // Attempt to find an impl_item for the type which has a name matching\n             // the current segment\n             log::debug!(\"looking for path segment: {:?}\", segment);\n-            let item: crate::ModuleDef = ty.iterate_impl_items(self.db, |item| match item {\n-                crate::ImplItem::Method(func) => {\n-                    let sig = func.signature(self.db);\n-                    if segment.name == *sig.name() {\n-                        return Some(func.into());\n+            let item: crate::ModuleDef = ty.iterate_impl_items(self.db, |item| {\n+                let matching_def: Option<crate::ModuleDef> = match item {\n+                    crate::ImplItem::Method(func) => {\n+                        let sig = func.signature(self.db);\n+                        if segment.name == *sig.name() {\n+                            Some(func.into())\n+                        } else {\n+                            None\n+                        }\n                     }\n-                    None\n-                }\n \n-                crate::ImplItem::Const(konst) => {\n-                    let sig = konst.signature(self.db);\n-                    if segment.name == *sig.name() {\n-                        return Some(konst.into());\n+                    crate::ImplItem::Const(konst) => {\n+                        let sig = konst.signature(self.db);\n+                        if segment.name == *sig.name() {\n+                            Some(konst.into())\n+                        } else {\n+                            None\n+                        }\n                     }\n-                    None\n-                }\n \n-                // TODO: Resolve associated types\n-                crate::ImplItem::TypeAlias(_) => None,\n+                    // TODO: Resolve associated types\n+                    crate::ImplItem::TypeAlias(_) => None,\n+                };\n+                match matching_def {\n+                    Some(_) => {\n+                        self.write_assoc_resolution(id, item);\n+                        return matching_def;\n+                    }\n+                    None => None,\n+                }\n             })?;\n+\n             resolved = Resolution::Def(item.into());\n         }\n \n         match resolved {\n             Resolution::Def(def) => {\n                 let typable: Option<TypableDef> = def.into();\n                 let typable = typable?;\n-\n                 let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n                 let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n                 let ty = self.insert_type_vars(ty);\n@@ -572,7 +607,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Pat::Path(path) => {\n                 // TODO use correct resolver for the surrounding expression\n                 let resolver = self.resolver.clone();\n-                self.infer_path_expr(&resolver, &path).unwrap_or(Ty::Unknown)\n+                self.infer_path_expr(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n             }\n             Pat::Bind { mode, name: _name, subpat } => {\n                 let inner_ty = if let Some(subpat) = subpat {\n@@ -782,7 +817,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Path(p) => {\n                 // TODO this could be more efficient...\n                 let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n-                self.infer_path_expr(&resolver, p).unwrap_or(Ty::Unknown)\n+                self.infer_path_expr(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n             Expr::Continue => Ty::Never,\n             Expr::Break { expr } => {"}, {"sha": "364263d9bba4bb437250c8693706c87d5d818cde", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8", "patch": "@@ -47,9 +47,10 @@ pub(crate) fn reference_definition(\n     name_ref: &ast::NameRef,\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n-    if let Some(function) =\n-        hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())\n-    {\n+\n+    let function = hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax());\n+\n+    if let Some(function) = function {\n         // Check if it is a method\n         if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n             tested_by!(goto_definition_works_for_methods);\n@@ -122,9 +123,29 @@ pub(crate) fn reference_definition(\n             Some(Resolution::SelfType(_impl_block)) => {\n                 // TODO: go to the implemented type\n             }\n-            None => {}\n+            None => {\n+                // If we failed to resolve then check associated items\n+                if let Some(function) = function {\n+                    // Should we do this above and then grab path from the PathExpr?\n+                    if let Some(path_expr) =\n+                        name_ref.syntax().ancestors().find_map(ast::PathExpr::cast)\n+                    {\n+                        let infer_result = function.infer(db);\n+                        let source_map = function.body_source_map(db);\n+                        let expr = ast::Expr::cast(path_expr.syntax()).unwrap();\n+\n+                        if let Some(res) = source_map\n+                            .node_expr(expr)\n+                            .and_then(|it| infer_result.assoc_resolutions_for_expr(it.into()))\n+                        {\n+                            return Exact(NavigationTarget::from_impl_item(db, res));\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n+\n     // If that fails try the index based approach.\n     let navs = crate::symbol_index::index_resolve(db, name_ref)\n         .into_iter()"}, {"sha": "bcd052c8bc4744f0036eb6d8b7c09f9fc8305fe5", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8", "patch": "@@ -512,4 +512,26 @@ mod tests {\n         let hover = analysis.hover(position).unwrap().unwrap();\n         assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Thing\"));\n     }\n+\n+    #[test]\n+    fn test_hover_infer_associated_method_exact() {\n+        let (analysis, position) = single_file_with_position(\n+            \"\n+            struct Thing { x: u32 }\n+\n+            impl Thing {\n+                fn new() -> Thing {\n+                    Thing { x: 0 }\n+                }\n+            }\n+\n+            fn main() {\n+                let foo_test = Thing::new<|>();\n+            }\n+            \",\n+        );\n+        let hover = analysis.hover(position).unwrap().unwrap();\n+        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"fn new() -> Thing\"));\n+        assert_eq!(hover.info.is_exact(), true);\n+    }\n }"}, {"sha": "d806cb368d3cd20c4a115d8e19a7c4fe6acaf165", "filename": "crates/ra_ide_api/src/navigation_target.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs?ref=fe48f9f4d243aff59abc44e9ef9ccce9d43c01a8", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     SyntaxNode, SyntaxNodePtr, AstNode, SmolStr, TextRange, ast,\n     SyntaxKind::{self, NAME},\n };\n-use hir::{ModuleSource, FieldSource, Name};\n+use hir::{ModuleSource, FieldSource, Name, ImplItem};\n \n use crate::{FileSymbol, db::RootDatabase};\n \n@@ -174,6 +174,20 @@ impl NavigationTarget {\n         )\n     }\n \n+    pub(crate) fn from_impl_item(db: &RootDatabase, impl_item: hir::ImplItem) -> NavigationTarget {\n+        match impl_item {\n+            ImplItem::Method(f) => NavigationTarget::from_function(db, f),\n+            ImplItem::Const(c) => {\n+                let (file_id, node) = c.source(db);\n+                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            }\n+            ImplItem::TypeAlias(a) => {\n+                let (file_id, node) = a.source(db);\n+                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            }\n+        }\n+    }\n+\n     #[cfg(test)]\n     pub(crate) fn assert_match(&self, expected: &str) {\n         let actual = self.debug_render();"}]}