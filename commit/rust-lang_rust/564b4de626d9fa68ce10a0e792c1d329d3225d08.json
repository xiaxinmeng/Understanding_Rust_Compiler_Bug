{"sha": "564b4de626d9fa68ce10a0e792c1d329d3225d08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NGI0ZGU2MjZkOWZhNjhjZTEwYTBlNzkyYzFkMzI5ZDMyMjVkMDg=", "commit": {"author": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-05-09T14:06:24Z"}, "committer": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-05-11T18:01:33Z"}, "message": "use the correct attributes and add helper function", "tree": {"sha": "d9ee23051256dccb1885d89953e858c62bd648e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9ee23051256dccb1885d89953e858c62bd648e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/564b4de626d9fa68ce10a0e792c1d329d3225d08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/564b4de626d9fa68ce10a0e792c1d329d3225d08", "html_url": "https://github.com/rust-lang/rust/commit/564b4de626d9fa68ce10a0e792c1d329d3225d08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/564b4de626d9fa68ce10a0e792c1d329d3225d08/comments", "author": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acfc708b7c8c4e43379d1dad28ee3a5887d07942", "url": "https://api.github.com/repos/rust-lang/rust/commits/acfc708b7c8c4e43379d1dad28ee3a5887d07942", "html_url": "https://github.com/rust-lang/rust/commit/acfc708b7c8c4e43379d1dad28ee3a5887d07942"}], "stats": {"total": 178, "additions": 80, "deletions": 98}, "files": [{"sha": "7a2b5b26ef43791ec69eec3a5243429f04546c42", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 78, "deletions": 96, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/564b4de626d9fa68ce10a0e792c1d329d3225d08/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/564b4de626d9fa68ce10a0e792c1d329d3225d08/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=564b4de626d9fa68ce10a0e792c1d329d3225d08", "patch": "@@ -583,129 +583,111 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.infcx.predicate_may_hold(&obligation)\n     }\n \n-    /// Figures out the list of root variables (and their types) that aren't completely\n-    /// captured by the closure when `capture_disjoint_fields` is enabled and auto-traits\n-    /// differ between the root variable and the captured paths.\n-    ///\n-    /// The output list would include a root variable if:\n-    /// - It would have been captured into the closure when `capture_disjoint_fields` wasn't\n-    ///   enabled, **and**\n-    /// - It wasn't completely captured by the closure, **and**\n-    /// - One of the paths captured does not implement all the auto-traits its root variable\n-    ///   implements.\n-    fn compute_2229_migrations_for_trait(\n+    /// Returns true if migration is needed for trait for the provided var_hir_id\n+    fn need_2229_migrations_for_trait(\n         &self,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-        _closure_clause: hir::CaptureBy,\n         var_hir_id: hir::HirId,\n-    ) -> Option<FxHashSet<&str>> {\n+        check_trait: Option<DefId>,\n+    ) -> bool {\n         let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n             min_captures.and_then(|m| m.get(&var_hir_id))\n         {\n             root_var_min_capture_list\n         } else {\n-            return None;\n+            return false;\n         };\n \n         let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n-        let tcx = self.infcx.tcx;\n-\n         let cause = ObligationCause::misc(self.tcx.hir().span(var_hir_id), self.body_id);\n \n-        let clone_obligation_should_hold = tcx\n-            .lang_items()\n-            .clone_trait()\n-            .map(|clone_trait| self.ty_impls_trait(ty, &cause, clone_trait))\n-            .unwrap_or(false);\n-        let sync_obligation_should_hold = tcx\n-            .lang_items()\n-            .sync_trait()\n-            .map(|sync_trait| self.ty_impls_trait(ty, &cause, sync_trait))\n-            .unwrap_or(false);\n-        let send_obligation_should_hold = tcx\n-            .lang_items()\n-            .send_trait()\n-            .map(|send_trait| self.ty_impls_trait(ty, &cause, send_trait))\n-            .unwrap_or(false);\n-        let unpin_obligation_should_hold = tcx\n-            .lang_items()\n-            .unpin_trait()\n-            .map(|unpin_trait| self.ty_impls_trait(ty, &cause, unpin_trait))\n-            .unwrap_or(false);\n-        let unwind_safe_obligation_should_hold = tcx\n-            .lang_items()\n-            .unwind_safe_trait()\n-            .map(|unwind_safe_trait| self.ty_impls_trait(ty, &cause, unwind_safe_trait))\n-            .unwrap_or(false);\n-        let ref_unwind_safe_obligation_should_hold = tcx\n-            .lang_items()\n-            .ref_unwind_safe_trait()\n-            .map(|ref_unwind_safe_trait| self.ty_impls_trait(ty, &cause, ref_unwind_safe_trait))\n+        let obligation_should_hold = check_trait\n+            .map(|check_trait| self.ty_impls_trait(ty, &cause, check_trait))\n             .unwrap_or(false);\n \n         // Check whether catpured fields also implement the trait\n-        let mut auto_trait_reasons = FxHashSet::default();\n \n         for capture in root_var_min_capture_list.iter() {\n             let ty = capture.place.ty();\n \n-            let clone_obligation_holds_for_capture = tcx\n-                .lang_items()\n-                .clone_trait()\n-                .map(|clone_trait| self.ty_impls_trait(ty, &cause, clone_trait))\n-                .unwrap_or(false);\n-            let sync_obligation_holds_for_capture = tcx\n-                .lang_items()\n-                .sync_trait()\n-                .map(|sync_trait| self.ty_impls_trait(ty, &cause, sync_trait))\n-                .unwrap_or(false);\n-            let send_obligation_holds_for_capture = tcx\n-                .lang_items()\n-                .send_trait()\n-                .map(|send_trait| self.ty_impls_trait(ty, &cause, send_trait))\n-                .unwrap_or(false);\n-            let unpin_obligation_holds_for_capture = tcx\n-                .lang_items()\n-                .unpin_trait()\n-                .map(|unpin_trait| self.ty_impls_trait(ty, &cause, unpin_trait))\n-                .unwrap_or(false);\n-            let unwind_safe_obligation_holds_for_capture = tcx\n-                .lang_items()\n-                .unwind_safe_trait()\n-                .map(|unwind_safe| self.ty_impls_trait(ty, &cause, unwind_safe))\n-                .unwrap_or(false);\n-            let ref_unwind_safe_obligation_holds_for_capture = tcx\n-                .lang_items()\n-                .ref_unwind_safe_trait()\n-                .map(|ref_unwind_safe_trait| self.ty_impls_trait(ty, &cause, ref_unwind_safe_trait))\n+            let obligation_holds_for_capture = check_trait\n+                .map(|check_trait| self.ty_impls_trait(ty, &cause, check_trait))\n                 .unwrap_or(false);\n \n-            if !clone_obligation_holds_for_capture && clone_obligation_should_hold {\n-                auto_trait_reasons.insert(\"`Clone`\");\n+            if !obligation_holds_for_capture && obligation_should_hold {\n+                return true;\n             }\n+        }\n+        false\n+    }\n \n-            if !sync_obligation_holds_for_capture && sync_obligation_should_hold {\n-                auto_trait_reasons.insert(\"`Sync`\");\n-            }\n+    /// Figures out the list of root variables (and their types) that aren't completely\n+    /// captured by the closure when `capture_disjoint_fields` is enabled and auto-traits\n+    /// differ between the root variable and the captured paths.\n+    ///\n+    /// The output list would include a root variable if:\n+    /// - It would have been captured into the closure when `capture_disjoint_fields` wasn't\n+    ///   enabled, **and**\n+    /// - It wasn't completely captured by the closure, **and**\n+    /// - One of the paths captured does not implement all the auto-traits its root variable\n+    ///   implements.\n+    fn compute_2229_migrations_for_trait(\n+        &self,\n+        min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n+        var_hir_id: hir::HirId,\n+    ) -> Option<FxHashSet<&str>> {\n+        let tcx = self.infcx.tcx;\n \n-            if !send_obligation_holds_for_capture && send_obligation_should_hold {\n-                auto_trait_reasons.insert(\"`Send`\");\n-            }\n+        // Check whether catpured fields also implement the trait\n+        let mut auto_trait_reasons = FxHashSet::default();\n \n-            if !unpin_obligation_holds_for_capture && unpin_obligation_should_hold {\n-                auto_trait_reasons.insert(\"`Unpin`\");\n-            }\n+        if self.need_2229_migrations_for_trait(\n+            min_captures,\n+            var_hir_id,\n+            tcx.lang_items().clone_trait(),\n+        ) {\n+            auto_trait_reasons.insert(\"`Clone`\");\n+        }\n \n-            if !unwind_safe_obligation_holds_for_capture && unwind_safe_obligation_should_hold {\n-                auto_trait_reasons.insert(\"`UnwindSafe`\");\n-            }\n+        if self.need_2229_migrations_for_trait(\n+            min_captures,\n+            var_hir_id,\n+            tcx.lang_items().sync_trait(),\n+        ) {\n+            auto_trait_reasons.insert(\"`Sync`\");\n+        }\n \n-            if !ref_unwind_safe_obligation_holds_for_capture\n-                && ref_unwind_safe_obligation_should_hold\n-            {\n-                auto_trait_reasons.insert(\"`RefUnwindSafe`\");\n-            }\n+        if self.need_2229_migrations_for_trait(\n+            min_captures,\n+            var_hir_id,\n+            tcx.lang_items().send_trait(),\n+        ) {\n+            auto_trait_reasons.insert(\"`Send`\");\n+        }\n+\n+        if self.need_2229_migrations_for_trait(\n+            min_captures,\n+            var_hir_id,\n+            tcx.lang_items().unpin_trait(),\n+        ) {\n+            auto_trait_reasons.insert(\"`Unpin`\");\n+        }\n+\n+        if self.need_2229_migrations_for_trait(\n+            min_captures,\n+            var_hir_id,\n+            tcx.lang_items().unwind_safe_trait(),\n+        ) {\n+            auto_trait_reasons.insert(\"`UnwindSafe`\");\n+        }\n+\n+        if self.need_2229_migrations_for_trait(\n+            min_captures,\n+            var_hir_id,\n+            tcx.lang_items().ref_unwind_safe_trait(),\n+        ) {\n+            auto_trait_reasons.insert(\"`RefUnwindSafe`\");\n         }\n \n         if auto_trait_reasons.len() > 0 {\n@@ -796,7 +778,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - One of the paths starting at this root variable, that is not captured needs Drop **or**\n     /// - One of the paths captured does not implement all the auto-traits its root variable\n     ///   implements.\n-    /// \n+    ///\n     /// Returns a tuple containing a vector of HirIds as well as a String containing the reason\n     /// why root variables whose HirId is contained in the vector should be fully captured.\n     fn compute_2229_migrations(\n@@ -820,7 +802,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for (&var_hir_id, _) in upvars.iter() {\n             let mut need_migration = false;\n             if let Some(trait_migration_cause) =\n-                self.compute_2229_migrations_for_trait(min_captures, closure_clause, var_hir_id)\n+                self.compute_2229_migrations_for_trait(min_captures, var_hir_id)\n             {\n                 need_migration = true;\n                 auto_trait_reasons.extend(trait_migration_cause);"}, {"sha": "7114552745a02f23434a6bd04be48a9e659912f4", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/564b4de626d9fa68ce10a0e792c1d329d3225d08/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/564b4de626d9fa68ce10a0e792c1d329d3225d08/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=564b4de626d9fa68ce10a0e792c1d329d3225d08", "patch": "@@ -132,7 +132,7 @@ pub fn panic_any<M: 'static + Any + Send>(msg: M) -> ! {\n /// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n /// implemented for any closed over variables passed to `catch_unwind`.\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-#[cfg_attr(not(bootstrap), lang = \"unwind_safe\")]\n+#[cfg_attr(all(not(bootstrap), not(test)), lang = \"unwind_safe\")]\n #[rustc_on_unimplemented(\n     message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n     label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n@@ -148,7 +148,7 @@ pub auto trait UnwindSafe {}\n /// This is a \"helper marker trait\" used to provide impl blocks for the\n /// [`UnwindSafe`] trait, for more information see that documentation.\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-#[cfg_attr(not(bootstrap), lang = \"ref_unwind_safe\")]\n+#[cfg_attr(all(not(bootstrap), not(test)), lang = \"ref_unwind_safe\")]\n #[rustc_on_unimplemented(\n     message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n                transferrable across a catch_unwind boundary\","}]}