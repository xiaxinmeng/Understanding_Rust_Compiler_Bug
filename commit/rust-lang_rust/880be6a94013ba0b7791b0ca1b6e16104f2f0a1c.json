{"sha": "880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MGJlNmE5NDAxM2JhMGI3NzkxYjBjYTFiNmUxNjEwNGYyZjBhMWM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-19T10:21:57Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-19T14:57:13Z"}, "message": "Overhaul logging system in runtime\n\nSee https://github.com/graydon/rust/wiki/Logging-vision\n\nThe runtime logging categories are now treated in the same way as\nmodules in compiled code. Each domain now has a log_lvl that can be\nused to restrict the logging from that domain (will be used to allow\nlogging to be restricted to a single domain).\n\nFeatures dropped (can be brought back to life if there is interest):\n  - Logger indentation\n  - Multiple categories per log statement\n  - I possibly broke some of the color code -- it confuses me", "tree": {"sha": "ad8c673f13ec8d2d879175be1a006b08cc6d26d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad8c673f13ec8d2d879175be1a006b08cc6d26d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "html_url": "https://github.com/rust-lang/rust/commit/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6511d471bafd446026462ce0dba8ef5e2ebf462f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6511d471bafd446026462ce0dba8ef5e2ebf462f", "html_url": "https://github.com/rust-lang/rust/commit/6511d471bafd446026462ce0dba8ef5e2ebf462f"}], "stats": {"total": 1100, "additions": 463, "deletions": 637}, "files": [{"sha": "1b3ad5d45440fd88efaa6fb75541179ce2f77e26", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -2664,12 +2664,12 @@ let trans_visitor\n            nabi_rust (upcall_fixup name) args);\n \n   and trans_log_int lev (a:Ast.atom) : unit =\n-    trans_void_upcall \"upcall_log_int\" [| simm (Int64.of_int lev);\n-                                          trans_atom a |]\n+    trans_void_upcall \"upcall_log_int_rustboot\" [| simm (Int64.of_int lev);\n+                                                   trans_atom a |]\n \n   and trans_log_str lev (a:Ast.atom) : unit =\n-    trans_void_upcall \"upcall_log_str\" [| simm (Int64.of_int lev);\n-                                          trans_atom a |]\n+    trans_void_upcall \"upcall_log_str_rustboot\" [| simm (Int64.of_int lev);\n+                                                   trans_atom a |]\n \n   and trans_spawn\n       ((*initializing*)_:bool)"}, {"sha": "ab98dfe34c4cd66e1a5c410335cf6793b48384ee", "filename": "src/rt/circular_buffer.cpp", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Fcircular_buffer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Fcircular_buffer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -14,16 +14,15 @@ circular_buffer::circular_buffer(rust_dom *dom, size_t unit_sz) :\n \n     A(dom, unit_sz, \"Unit size must be larger than zero.\");\n \n-    DLOG(dom, rust_log::MEM | rust_log::COMM,\n-             \"new circular_buffer(buffer_sz=%d, unread=%d)\"\n-             \"-> circular_buffer=0x%\" PRIxPTR,\n-             _buffer_sz, _unread, this);\n+    DLOG(dom, mem, \"new circular_buffer(buffer_sz=%d, unread=%d)\"\n+         \"-> circular_buffer=0x%\" PRIxPTR,\n+         _buffer_sz, _unread, this);\n \n     A(dom, _buffer, \"Failed to allocate buffer.\");\n }\n \n circular_buffer::~circular_buffer() {\n-    DLOG(dom, rust_log::MEM, \"~circular_buffer 0x%\" PRIxPTR, this);\n+    DLOG(dom, mem, \"~circular_buffer 0x%\" PRIxPTR, this);\n     I(dom, _buffer);\n     W(dom, _unread == 0,\n       \"freeing circular_buffer with %d unread bytes\", _unread);\n@@ -79,10 +78,9 @@ circular_buffer::enqueue(void *src) {\n         grow();\n     }\n \n-    DLOG(dom, rust_log::MEM | rust_log::COMM,\n-             \"circular_buffer enqueue \"\n-             \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n-             _unread, _next, _buffer_sz, unit_sz);\n+    DLOG(dom, mem, \"circular_buffer enqueue \"\n+         \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n+         _unread, _next, _buffer_sz, unit_sz);\n \n     I(dom, _unread < _buffer_sz);\n     I(dom, _unread + unit_sz <= _buffer_sz);\n@@ -101,8 +99,7 @@ circular_buffer::enqueue(void *src) {\n     memcpy(&_buffer[dst_idx], src, unit_sz);\n     _unread += unit_sz;\n \n-    DLOG(dom, rust_log::MEM | rust_log::COMM,\n-             \"circular_buffer pushed data at index: %d\", dst_idx);\n+    DLOG(dom, mem, \"circular_buffer pushed data at index: %d\", dst_idx);\n }\n \n /**\n@@ -117,7 +114,7 @@ circular_buffer::dequeue(void *dst) {\n     I(dom, _unread <= _buffer_sz);\n     I(dom, _buffer);\n \n-    DLOG(dom, rust_log::MEM | rust_log::COMM,\n+    DLOG(dom, mem,\n              \"circular_buffer dequeue \"\n              \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n              _unread, _next, _buffer_sz, unit_sz);\n@@ -126,8 +123,7 @@ circular_buffer::dequeue(void *dst) {\n     if (dst != NULL) {\n         memcpy(dst, &_buffer[_next], unit_sz);\n     }\n-    DLOG(dom, rust_log::MEM | rust_log::COMM,\n-             \"shifted data from index %d\", _next);\n+    DLOG(dom, mem, \"shifted data from index %d\", _next);\n     _unread -= unit_sz;\n     _next += unit_sz;\n     if (_next == _buffer_sz) {\n@@ -144,8 +140,7 @@ void\n circular_buffer::grow() {\n     size_t new_buffer_sz = _buffer_sz * 2;\n     I(dom, new_buffer_sz <= MAX_CIRCULAR_BUFFER_SIZE);\n-    DLOG(dom, rust_log::MEM | rust_log::COMM,\n-             \"circular_buffer is growing to %d bytes\", new_buffer_sz);\n+    DLOG(dom, mem, \"circular_buffer is growing to %d bytes\", new_buffer_sz);\n     void *new_buffer = dom->malloc(new_buffer_sz);\n     transfer(new_buffer);\n     dom->free(_buffer);\n@@ -158,8 +153,7 @@ void\n circular_buffer::shrink() {\n     size_t new_buffer_sz = _buffer_sz / 2;\n     I(dom, initial_size() <= new_buffer_sz);\n-    DLOG(dom, rust_log::MEM | rust_log::COMM,\n-             \"circular_buffer is shrinking to %d bytes\", new_buffer_sz);\n+    DLOG(dom, mem, \"circular_buffer is shrinking to %d bytes\", new_buffer_sz);\n     void *new_buffer = dom->malloc(new_buffer_sz);\n     transfer(new_buffer);\n     dom->free(_buffer);"}, {"sha": "56c5b4d6672f7f4a24e78ef33d74fd35eb46701a", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -82,21 +82,22 @@ rust_start(uintptr_t main_fn, rust_crate const *crate, int argc,\n \n     if (crate->abi_tag != ABI_X86_RUSTBOOT_CDECL)\n         update_log_settings(crate_map, getenv(\"RUST_LOG\"));\n+    else\n+        update_log_settings(NULL, getenv(\"RUST_LOG\"));\n     rust_srv *srv = new rust_srv();\n     rust_kernel *kernel = new rust_kernel(srv);\n     kernel->start();\n     rust_handle<rust_dom> *handle = kernel->create_domain(crate, \"main\");\n     rust_dom *dom = handle->referent();\n     command_line_args *args = new (dom) command_line_args(dom, argc, argv);\n \n-    DLOG(dom, rust_log::DOM, \"startup: %d args in 0x%\" PRIxPTR,\n+    DLOG(dom, dom, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);\n     for (int i = 0; i < args->argc; i++) {\n-        DLOG(dom, rust_log::DOM,\n-            \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n+        DLOG(dom, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n-    if (dom->_log.is_tracing(rust_log::DWARF)) {\n+    if (log_rt_dwarf) {\n         rust_crate_reader create_reader(dom, crate);\n     }\n "}, {"sha": "c1aa5b5941345192b74c6238efa614f432164fa0", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 52, "deletions": 63, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -6,7 +6,7 @@\n extern \"C\" CDECL rust_str*\n last_os_error(rust_task *task) {\n     rust_dom *dom = task->dom;\n-    LOG(task, rust_log::TASK, \"last_os_error()\");\n+    LOG(task, task, \"last_os_error()\");\n \n #if defined(__WIN32__)\n     LPTSTR buf;\n@@ -91,9 +91,8 @@ extern \"C\" CDECL rust_vec*\n vec_alloc(rust_task *task, type_desc *t, type_desc *elem_t, size_t n_elts)\n {\n     rust_dom *dom = task->dom;\n-    LOG(task, rust_log::MEM | rust_log::STDLIB,\n-              \"vec_alloc %\" PRIdPTR \" elements of size %\" PRIdPTR,\n-              n_elts, elem_t->size);\n+    LOG(task, mem, \"vec_alloc %\" PRIdPTR \" elements of size %\" PRIdPTR,\n+        n_elts, elem_t->size);\n     size_t fill = n_elts * elem_t->size;\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + fill);\n     void *mem = task->malloc(alloc, t->is_stateful ? t : NULL);\n@@ -126,37 +125,34 @@ vec_len(rust_task *task, type_desc *ty, rust_vec *v)\n extern \"C\" CDECL void\n vec_len_set(rust_task *task, type_desc *ty, rust_vec *v, size_t len)\n {\n-    LOG(task, rust_log::STDLIB,\n-              \"vec_len_set(0x%\" PRIxPTR \", %\" PRIdPTR \") on vec with \"\n-              \"alloc = %\" PRIdPTR\n-              \", fill = %\" PRIdPTR\n-              \", len = %\" PRIdPTR\n-              \".  New fill is %\" PRIdPTR,\n-              v, len, v->alloc, v->fill, v->fill / ty->size, len * ty->size);\n+    LOG(task, stdlib, \"vec_len_set(0x%\" PRIxPTR \", %\" PRIdPTR \") on vec with \"\n+        \"alloc = %\" PRIdPTR\n+        \", fill = %\" PRIdPTR\n+        \", len = %\" PRIdPTR\n+        \".  New fill is %\" PRIdPTR,\n+        v, len, v->alloc, v->fill, v->fill / ty->size, len * ty->size);\n     v->fill = len * ty->size;\n }\n \n extern \"C\" CDECL void\n vec_print_debug_info(rust_task *task, type_desc *ty, rust_vec *v)\n {\n-    LOG(task, rust_log::STDLIB,\n-              \"vec_print_debug_info(0x%\" PRIxPTR \")\"\n-              \" with tydesc 0x%\" PRIxPTR\n-              \" (size = %\" PRIdPTR \", align = %\" PRIdPTR \")\"\n-              \" alloc = %\" PRIdPTR \", fill = %\" PRIdPTR \", len = %\" PRIdPTR\n-              \" , data = ...\",\n-              v,\n-              ty,\n-              ty->size,\n-              ty->align,\n-              v->alloc,\n-              v->fill,\n-              v->fill / ty->size);\n+    LOG(task, stdlib,\n+        \"vec_print_debug_info(0x%\" PRIxPTR \")\"\n+        \" with tydesc 0x%\" PRIxPTR\n+        \" (size = %\" PRIdPTR \", align = %\" PRIdPTR \")\"\n+        \" alloc = %\" PRIdPTR \", fill = %\" PRIdPTR \", len = %\" PRIdPTR\n+        \" , data = ...\",\n+        v,\n+        ty,\n+        ty->size,\n+        ty->align,\n+        v->alloc,\n+        v->fill,\n+        v->fill / ty->size);\n \n     for (size_t i = 0; i < v->fill; ++i) {\n-        LOG(task, rust_log::STDLIB,\n-                  \"  %\" PRIdPTR \":    0x%\" PRIxPTR,\n-                  i, v->data[i]);\n+        LOG(task, stdlib, \"  %\" PRIdPTR \":    0x%\" PRIxPTR, i, v->data[i]);\n     }\n }\n \n@@ -306,29 +302,27 @@ task_sleep(rust_task *task, size_t time_in_us) {\n static void\n debug_tydesc_helper(rust_task *task, type_desc *t)\n {\n-    LOG(task, rust_log::STDLIB,\n-              \"  size %\" PRIdPTR \", align %\" PRIdPTR\n-              \", stateful %\" PRIdPTR \", first_param 0x%\" PRIxPTR,\n-              t->size, t->align, t->is_stateful, t->first_param);\n+    LOG(task, stdlib, \"  size %\" PRIdPTR \", align %\" PRIdPTR\n+        \", stateful %\" PRIdPTR \", first_param 0x%\" PRIxPTR,\n+        t->size, t->align, t->is_stateful, t->first_param);\n }\n \n extern \"C\" CDECL void\n debug_tydesc(rust_task *task, type_desc *t)\n {\n-    LOG(task, rust_log::STDLIB, \"debug_tydesc\");\n+    LOG(task, stdlib, \"debug_tydesc\");\n     debug_tydesc_helper(task, t);\n }\n \n extern \"C\" CDECL void\n debug_opaque(rust_task *task, type_desc *t, uint8_t *front)\n {\n-    LOG(task, rust_log::STDLIB, \"debug_opaque\");\n+    LOG(task, stdlib, \"debug_opaque\");\n     debug_tydesc_helper(task, t);\n     // FIXME may want to actually account for alignment.  `front` may not\n     // indeed be the front byte of the passed-in argument.\n     for (uintptr_t i = 0; i < t->size; ++front, ++i) {\n-        LOG(task, rust_log::STDLIB,\n-                  \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, *front);\n+        LOG(task, stdlib, \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, *front);\n     }\n }\n \n@@ -340,15 +334,14 @@ struct rust_box : rc_base<rust_box> {\n extern \"C\" CDECL void\n debug_box(rust_task *task, type_desc *t, rust_box *box)\n {\n-    LOG(task, rust_log::STDLIB, \"debug_box(0x%\" PRIxPTR \")\", box);\n+    LOG(task, stdlib, \"debug_box(0x%\" PRIxPTR \")\", box);\n     debug_tydesc_helper(task, t);\n-    LOG(task, rust_log::STDLIB, \"  refcount %\" PRIdPTR,\n-              box->ref_count == CONST_REFCOUNT\n-              ? CONST_REFCOUNT\n-              : box->ref_count - 1);  // -1 because we ref'ed for this call\n+    LOG(task, stdlib, \"  refcount %\" PRIdPTR,\n+        box->ref_count == CONST_REFCOUNT\n+        ? CONST_REFCOUNT\n+        : box->ref_count - 1);  // -1 because we ref'ed for this call\n     for (uintptr_t i = 0; i < t->size; ++i) {\n-        LOG(task, rust_log::STDLIB,\n-                  \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, box->data[i]);\n+        LOG(task, stdlib, \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, box->data[i]);\n     }\n }\n \n@@ -360,14 +353,13 @@ struct rust_tag {\n extern \"C\" CDECL void\n debug_tag(rust_task *task, type_desc *t, rust_tag *tag)\n {\n-    LOG(task, rust_log::STDLIB, \"debug_tag\");\n+    LOG(task, stdlib, \"debug_tag\");\n     debug_tydesc_helper(task, t);\n-    LOG(task, rust_log::STDLIB,\n-              \"  discriminant %\" PRIdPTR, tag->discriminant);\n+    LOG(task, stdlib, \"  discriminant %\" PRIdPTR, tag->discriminant);\n \n     for (uintptr_t i = 0; i < t->size - sizeof(tag->discriminant); ++i)\n-        LOG(task, rust_log::STDLIB,\n-                  \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, tag->variant[i]);\n+        LOG(task, stdlib, \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i,\n+            tag->variant[i]);\n }\n \n struct rust_obj {\n@@ -379,19 +371,17 @@ extern \"C\" CDECL void\n debug_obj(rust_task *task, type_desc *t, rust_obj *obj,\n           size_t nmethods, size_t nbytes)\n {\n-    LOG(task, rust_log::STDLIB,\n-              \"debug_obj with %\" PRIdPTR \" methods\", nmethods);\n+    LOG(task, stdlib, \"debug_obj with %\" PRIdPTR \" methods\", nmethods);\n     debug_tydesc_helper(task, t);\n-    LOG(task, rust_log::STDLIB, \"  vtbl at 0x%\" PRIxPTR, obj->vtbl);\n-    LOG(task, rust_log::STDLIB, \"  body at 0x%\" PRIxPTR, obj->body);\n+    LOG(task, stdlib, \"  vtbl at 0x%\" PRIxPTR, obj->vtbl);\n+    LOG(task, stdlib, \"  body at 0x%\" PRIxPTR, obj->body);\n \n     for (uintptr_t *p = obj->vtbl; p < obj->vtbl + nmethods; ++p)\n-        LOG(task, rust_log::STDLIB, \"  vtbl word: 0x%\" PRIxPTR, *p);\n+        LOG(task, stdlib, \"  vtbl word: 0x%\" PRIxPTR, *p);\n \n     for (uintptr_t i = 0; i < nbytes; ++i)\n-        LOG(task, rust_log::STDLIB,\n-                  \"  body byte %\" PRIdPTR \": 0x%\" PRIxPTR,\n-                  i, obj->body->data[i]);\n+        LOG(task, stdlib, \"  body byte %\" PRIdPTR \": 0x%\" PRIxPTR,\n+            i, obj->body->data[i]);\n }\n \n struct rust_fn {\n@@ -402,13 +392,12 @@ struct rust_fn {\n extern \"C\" CDECL void\n debug_fn(rust_task *task, type_desc *t, rust_fn *fn)\n {\n-    LOG(task, rust_log::STDLIB, \"debug_fn\");\n+    LOG(task, stdlib, \"debug_fn\");\n     debug_tydesc_helper(task, t);\n-    LOG(task, rust_log::STDLIB, \"  thunk at 0x%\" PRIxPTR, fn->thunk);\n-    LOG(task, rust_log::STDLIB, \"  closure at 0x%\" PRIxPTR, fn->closure);\n+    LOG(task, stdlib, \"  thunk at 0x%\" PRIxPTR, fn->thunk);\n+    LOG(task, stdlib, \"  closure at 0x%\" PRIxPTR, fn->closure);\n     if (fn->closure) {\n-        LOG(task, rust_log::STDLIB, \"    refcount %\" PRIdPTR,\n-                  fn->closure->ref_count);\n+        LOG(task, stdlib, \"    refcount %\" PRIdPTR, fn->closure->ref_count);\n     }\n }\n \n@@ -418,17 +407,17 @@ debug_ptrcast(rust_task *task,\n               type_desc *to_ty,\n               void *ptr)\n {\n-    LOG(task, rust_log::STDLIB, \"debug_ptrcast from\");\n+    LOG(task, stdlib, \"debug_ptrcast from\");\n     debug_tydesc_helper(task, from_ty);\n-    LOG(task, rust_log::STDLIB, \"to\");\n+    LOG(task, stdlib, \"to\");\n     debug_tydesc_helper(task, to_ty);\n     return ptr;\n }\n \n extern \"C\" CDECL void\n debug_trap(rust_task *task, rust_str *s)\n {\n-    LOG(task, rust_log::STDLIB, \"trapping: %s\", s->data);\n+    LOG(task, stdlib, \"trapping: %s\", s->data);\n     // FIXME: x86-ism.\n     __asm__(\"int3\");\n }"}, {"sha": "fdc7f2704d315b14d849578b798f813f1ad4c3a8", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -13,15 +13,13 @@ rust_chan::rust_chan(rust_task *task,\n     if (port) {\n         associate(port);\n     }\n-    LOG(task, rust_log::MEM | rust_log::COMM,\n-              \"new rust_chan(task=0x%\" PRIxPTR\n-              \", port=0x%\" PRIxPTR \") -> chan=0x%\" PRIxPTR,\n-              (uintptr_t) task, (uintptr_t) port, (uintptr_t) this);\n+    LOG(task, comm, \"new rust_chan(task=0x%\" PRIxPTR\n+        \", port=0x%\" PRIxPTR \") -> chan=0x%\" PRIxPTR,\n+        (uintptr_t) task, (uintptr_t) port, (uintptr_t) this);\n }\n \n rust_chan::~rust_chan() {\n-    LOG(task, rust_log::MEM | rust_log::COMM,\n-              \"del rust_chan(task=0x%\" PRIxPTR \")\", (uintptr_t) this);\n+    LOG(task, comm, \"del rust_chan(task=0x%\" PRIxPTR \")\", (uintptr_t) this);\n \n     A(task->dom, is_associated() == false,\n       \"Channel must be disassociated before being freed.\");\n@@ -33,7 +31,7 @@ rust_chan::~rust_chan() {\n void rust_chan::associate(maybe_proxy<rust_port> *port) {\n     this->port = port;\n     if (port->is_proxy() == false) {\n-        LOG(task, rust_log::TASK,\n+        LOG(task, task,\n             \"associating chan: 0x%\" PRIxPTR \" with port: 0x%\" PRIxPTR,\n             this, port);\n         this->port->referent()->chans.push(this);\n@@ -51,7 +49,7 @@ void rust_chan::disassociate() {\n     A(task->dom, is_associated(), \"Channel must be associated with a port.\");\n \n     if (port->is_proxy() == false) {\n-        LOG(task, rust_log::TASK,\n+        LOG(task, task,\n             \"disassociating chan: 0x%\" PRIxPTR \" from port: 0x%\" PRIxPTR,\n             this, port->referent());\n         port->referent()->chans.swap_delete(this);\n@@ -84,7 +82,7 @@ void rust_chan::send(void *sptr) {\n     } else {\n         rust_port *target_port = port->referent();\n         if (target_port->task->blocked_on(target_port)) {\n-            DLOG(dom, rust_log::COMM, \"dequeued in rendezvous_ptr\");\n+            DLOG(dom, comm, \"dequeued in rendezvous_ptr\");\n             buffer.dequeue(target_port->task->rendezvous_ptr);\n             target_port->task->rendezvous_ptr = 0;\n             target_port->task->wakeup(target_port);"}, {"sha": "5e64a0125b345bdcec6d375d4f0f7beedb0932d7", "filename": "src/rt/rust_crate.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_crate.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_crate.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -41,8 +41,8 @@ rust_crate::mem_area::mem_area(rust_dom *dom, uintptr_t pos, size_t sz)\n     base(pos),\n     lim(pos + sz)\n {\n-  DLOG(dom, rust_log::MEM, \"new mem_area [0x%\" PRIxPTR \",0x%\" PRIxPTR \"]\",\n-           base, lim);\n+  DLOG(dom, mem, \"new mem_area [0x%\" PRIxPTR \",0x%\" PRIxPTR \"]\",\n+       base, lim);\n }\n \n rust_crate::mem_area"}, {"sha": "3fdb33b9896b2ae1c12d2764c6f85c853b5e9133", "filename": "src/rt/rust_crate_cache.cpp", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_crate_cache.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_crate_cache.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_cache.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -10,12 +10,12 @@ rust_crate_cache::lib::lib(rust_dom *dom, char const *name)\n #else\n     handle = (uintptr_t)dlopen(name, RTLD_GLOBAL|RTLD_LAZY);\n #endif\n-    DLOG(dom, rust_log::CACHE, \"loaded library '%s' as 0x%\"  PRIxPTR,\n+    DLOG(dom, cache, \"loaded library '%s' as 0x%\"  PRIxPTR,\n              name, handle);\n }\n \n rust_crate_cache::lib::~lib() {\n-    DLOG(dom, rust_log::CACHE, \"~rust_crate_cache::lib(0x%\" PRIxPTR \")\",\n+    DLOG(dom, cache, \"~rust_crate_cache::lib(0x%\" PRIxPTR \")\",\n              handle);\n     if (handle) {\n #if defined(__WIN32__)\n@@ -46,17 +46,15 @@ rust_crate_cache::c_sym::c_sym(rust_dom *dom, lib *library, char const *name)\n #else\n         val = (uintptr_t)dlsym((void*)handle, name);\n #endif\n-        DLOG(dom, rust_log::CACHE, \"resolved symbol '%s' to 0x%\"  PRIxPTR,\n+        DLOG(dom, cache, \"resolved symbol '%s' to 0x%\"  PRIxPTR,\n                  name, val);\n     } else {\n-        DLOG(dom, rust_log::CACHE | rust_log::ERR,\n-                 \"unresolved symbol '%s', null lib handle\",\n-                 name);\n+        DLOG_ERR(dom, cache, \"unresolved symbol '%s', null lib handle\", name);\n     }\n }\n \n rust_crate_cache::c_sym::~c_sym() {\n-    DLOG(dom, rust_log::CACHE,\n+    DLOG(dom, cache,\n             \"~rust_crate_cache::c_sym(0x%\" PRIxPTR \")\", val);\n     library->deref();\n }\n@@ -80,8 +78,7 @@ rust_crate_cache::rust_sym::rust_sym(rust_dom *dom,\n     typedef rust_crate_reader::die die;\n     rust_crate const *crate = (rust_crate*)crate_sym->get_val();\n     if (!crate) {\n-        DLOG(dom, rust_log::CACHE | rust_log::ERR,\n-                 \"failed to resolve symbol, null crate symbol\");\n+        DLOG_ERR(dom, cache, \"failed to resolve symbol, null crate symbol\");\n         return;\n     }\n     rust_crate_reader rdr(dom, crate);\n@@ -98,17 +95,14 @@ rust_crate_cache::rust_sym::rust_sym(rust_dom *dom,\n               && !t1.is_null()\n               && t1.find_child_by_name(crate_rel(curr_crate, *c), t2));\n              ++c, t1=t2) {\n-            DLOG(dom, rust_log::DWARF|rust_log::CACHE,\n-                    \"matched die <0x%\"  PRIxPTR\n+            DLOG(dom, dwarf, \"matched die <0x%\"  PRIxPTR\n                     \">, child '%s' = die<0x%\" PRIxPTR \">\",\n                     t1.off, crate_rel(curr_crate, *c), t2.off);\n             found_root = found_root || true;\n             if (!*(c+1) && t2.find_num_attr(DW_AT_low_pc, val)) {\n-                DLOG(dom, rust_log::DWARF|rust_log::CACHE,\n-                         \"found relative address: 0x%\"  PRIxPTR, val);\n-                DLOG(dom, rust_log::DWARF|rust_log::CACHE,\n-                         \"plus image-base 0x%\"  PRIxPTR,\n-                         crate->get_image_base());\n+                DLOG(dom, dwarf, \"found relative address: 0x%\"  PRIxPTR, val);\n+                DLOG(dom, dwarf, \"plus image-base 0x%\"  PRIxPTR,\n+                     crate->get_image_base());\n                 val += crate->get_image_base();\n                 found_leaf = true;\n                 break;\n@@ -118,15 +112,14 @@ rust_crate_cache::rust_sym::rust_sym(rust_dom *dom,\n             break;\n     }\n     if (found_leaf) {\n-        DLOG(dom, rust_log::CACHE, \"resolved symbol to 0x%\"  PRIxPTR, val);\n+        DLOG(dom, cache, \"resolved symbol to 0x%\"  PRIxPTR, val);\n     } else {\n-        DLOG(dom, rust_log::CACHE | rust_log::ERR,\n-                 \"failed to resolve symbol\");\n+        DLOG_ERR(dom, cache, \"failed to resolve symbol\");\n     }\n }\n \n rust_crate_cache::rust_sym::~rust_sym() {\n-    DLOG(dom, rust_log::CACHE,\n+    DLOG(dom, cache,\n              \"~rust_crate_cache::rust_sym(0x%\" PRIxPTR \")\", val);\n     crate_sym->deref();\n }\n@@ -155,7 +148,7 @@ rust_crate_cache::get_c_sym(size_t n, lib *library, char const *name)\n {\n     I(dom, n < crate->n_c_syms);\n     c_sym *sym = c_syms[n];\n-    DLOG(dom, rust_log::CACHE, \"cached C symbol %s = 0x%\" PRIxPTR, name, sym);\n+    DLOG(dom, cache, \"cached C symbol %s = 0x%\" PRIxPTR, name, sym);\n     if (!sym) {\n         sym = new (dom) c_sym(dom, library, name);\n         c_syms[n] = sym;\n@@ -199,10 +192,10 @@ rust_crate_cache::get_type_desc(size_t size,\n     size_t keysz = n_descs * sizeof(type_desc*);\n     HASH_FIND(hh, this->type_descs, descs, keysz, td);\n     if (td) {\n-        DLOG(dom, rust_log::CACHE, \"rust_crate_cache::get_type_desc hit\");\n+        DLOG(dom, cache, \"rust_crate_cache::get_type_desc hit\");\n         return td;\n     }\n-    DLOG(dom, rust_log::CACHE, \"rust_crate_cache::get_type_desc miss\");\n+    DLOG(dom, cache, \"rust_crate_cache::get_type_desc miss\");\n     td = (type_desc*) dom->malloc(sizeof(type_desc) + keysz);\n     if (!td)\n         return NULL;\n@@ -214,7 +207,7 @@ rust_crate_cache::get_type_desc(size_t size,\n     td->size = size;\n     td->align = align;\n     for (size_t i = 0; i < n_descs; ++i) {\n-        DLOG(dom, rust_log::CACHE,\n+        DLOG(dom, cache,\n                  \"rust_crate_cache::descs[%\" PRIdPTR \"] = 0x%\" PRIxPTR,\n                  i, descs[i]);\n         td->descs[i] = descs[i];\n@@ -251,11 +244,11 @@ rust_crate_cache::rust_crate_cache(rust_dom *dom,\n \n void\n rust_crate_cache::flush() {\n-    DLOG(dom, rust_log::CACHE, \"rust_crate_cache::flush()\");\n+    DLOG(dom, cache, \"rust_crate_cache::flush()\");\n     for (size_t i = 0; i < crate->n_rust_syms; ++i) {\n         rust_sym *s = rust_syms[i];\n         if (s) {\n-            DLOG(dom, rust_log::CACHE,\n+            DLOG(dom, cache,\n                      \"rust_crate_cache::flush() deref rust_sym %\"\n                      PRIdPTR \" (rc=%\" PRIdPTR \")\", i, s->ref_count);\n             s->deref();\n@@ -266,7 +259,7 @@ rust_crate_cache::flush() {\n     for (size_t i = 0; i < crate->n_c_syms; ++i) {\n         c_sym *s = c_syms[i];\n         if (s) {\n-            DLOG(dom, rust_log::CACHE,\n+            DLOG(dom, cache,\n                      \"rust_crate_cache::flush() deref c_sym %\"\n                      PRIdPTR \" (rc=%\" PRIdPTR \")\", i, s->ref_count);\n             s->deref();\n@@ -277,7 +270,7 @@ rust_crate_cache::flush() {\n     for (size_t i = 0; i < crate->n_libs; ++i) {\n         lib *l = libs[i];\n         if (l) {\n-            DLOG(dom, rust_log::CACHE, \"rust_crate_cache::flush() deref lib %\"\n+            DLOG(dom, cache, \"rust_crate_cache::flush() deref lib %\"\n                      PRIdPTR \" (rc=%\" PRIdPTR \")\", i, l->ref_count);\n             l->deref();\n         }\n@@ -287,8 +280,7 @@ rust_crate_cache::flush() {\n     while (type_descs) {\n         type_desc *d = type_descs;\n         HASH_DEL(type_descs, d);\n-        DLOG(dom, rust_log::MEM,\n-                 \"rust_crate_cache::flush() tydesc %\" PRIxPTR, d);\n+        DLOG(dom, mem, \"rust_crate_cache::flush() tydesc %\" PRIxPTR, d);\n         dom->free(d);\n     }\n }"}, {"sha": "9892f88f4f80c64d15292971f79227c2fd5264ff", "filename": "src/rt/rust_crate_reader.cpp", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_crate_reader.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_crate_reader.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_reader.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -92,7 +92,7 @@ rust_crate_reader::mem_reader::adv(size_t amt)\n     ok = false;\n   if (!ok)\n     return;\n-  // mem.DLOG(dom, rust_log::MEM, \"adv %d bytes\", amt);\n+  // mem.DLOG(dom, mem, \"adv %d bytes\", amt);\n   pos += amt;\n   ok &= !at_end();\n   I(mem.dom, at_end() || (mem.base <= pos && pos < mem.lim));\n@@ -120,7 +120,7 @@ rust_crate_reader::abbrev_reader::abbrev_reader\n   rust_dom *dom = mem.dom;\n   while (is_ok() && !at_end()) {\n \n-    // DLOG(dom, rust_log::DWARF, \"reading new abbrev at 0x%\" PRIxPTR,\n+    // DLOG(dom, dwarf, \"reading new abbrev at 0x%\" PRIxPTR,\n     //          tell_off());\n \n     uintptr_t idx, tag;\n@@ -133,13 +133,13 @@ rust_crate_reader::abbrev_reader::abbrev_reader\n     size_t body_off = tell_off();\n     while (is_ok() && step_attr_form_pair(attr, form));\n \n-    // DLOG(dom, rust_log::DWARF,\n+    // DLOG(dom, dwarf,\n     //         \"finished scanning attr/form pairs, pos=0x%\"\n     //         PRIxPTR \", lim=0x%\" PRIxPTR \", is_ok=%d, at_end=%d\",\n     //        pos, mem.lim, is_ok(), at_end());\n \n     if (is_ok() || at_end()) {\n-      DLOG(dom, rust_log::DWARF, \"read abbrev: %\" PRIdPTR, idx);\n+      DLOG(dom, dwarf, \"read abbrev: %\" PRIdPTR, idx);\n       I(dom, idx = abbrevs.length() + 1);\n       abbrevs.push(new (dom) abbrev(dom, body_off,\n                                     tell_off() - body_off,\n@@ -162,11 +162,11 @@ rust_crate_reader::abbrev_reader::step_attr_form_pair(uintptr_t &attr,\n {\n   attr = 0;\n   form = 0;\n-  // mem.DLOG(dom, rust_log::DWARF, \"reading attr/form pair at 0x%\" PRIxPTR,\n+  // mem.DLOG(dom, dwarf, \"reading attr/form pair at 0x%\" PRIxPTR,\n   //              tell_off());\n   get_uleb(attr);\n   get_uleb(form);\n-  // mem.DLOG(dom, rust_log::DWARF, \"attr 0x%\" PRIxPTR \", form 0x%\" PRIxPTR,\n+  // mem.DLOG(dom, dwarf, \"attr 0x%\" PRIxPTR \", form 0x%\" PRIxPTR,\n   //              attr, form);\n   return ! (attr == 0 && form == 0);\n }\n@@ -254,19 +254,17 @@ rust_crate_reader::die::die(die_reader *rdr, uintptr_t off)\n   rdr->get_uleb(ab_idx);\n   if (!ab_idx) {\n     ab = NULL;\n-    DLOG(dom, rust_log::DWARF, \"DIE <0x%\" PRIxPTR \"> (null)\", off);\n-    if (dom->get_log().is_tracing(rust_log::DWARF))\n-        dom->get_log().outdent();\n+    DLOG(dom, dwarf, \"DIE <0x%\" PRIxPTR \"> (null)\", off);\n   } else {\n     ab = rdr->abbrevs.get_abbrev(ab_idx);\n     if (!ab) {\n-        DLOG(dom, rust_log::DWARF, \"  bad abbrev number: 0x%\"\n+        DLOG(dom, dwarf, \"  bad abbrev number: 0x%\"\n                  PRIxPTR, ab_idx);\n         rdr->fail();\n     } else {\n-        DLOG(dom, rust_log::DWARF, \"DIE <0x%\" PRIxPTR \"> abbrev 0x%\"\n+        DLOG(dom, dwarf, \"DIE <0x%\" PRIxPTR \"> abbrev 0x%\"\n                  PRIxPTR, off, ab_idx);\n-        DLOG(dom, rust_log::DWARF, \"  tag 0x%x, has children: %d\",\n+        DLOG(dom, dwarf, \"  tag 0x%x, has children: %d\",\n                  ab->tag, ab->has_children);\n     }\n   }\n@@ -354,7 +352,7 @@ rust_crate_reader::die::step_attr(attr &a) const\n       break;\n \n     default:\n-      DLOG(rdr->mem.dom, rust_log::DWARF, \"  unknown dwarf form: 0x%\"\n+      DLOG(rdr->mem.dom, dwarf, \"  unknown dwarf form: 0x%\"\n                         PRIxPTR, a.form);\n       rdr->fail();\n       break;\n@@ -474,17 +472,15 @@ rust_crate_reader::die::next() const\n         while (step_attr(a)) {\n             I(dom, !(a.is_numeric() && a.is_string()));\n             if (a.is_numeric())\n-                DLOG(dom, rust_log::DWARF, \"  attr num: 0x%\"\n+                DLOG(dom, dwarf, \"  attr num: 0x%\"\n                          PRIxPTR, a.get_num(dom));\n             else if (a.is_string())\n-                DLOG(dom, rust_log::DWARF, \"  attr str: %s\",\n+                DLOG(dom, dwarf, \"  attr str: %s\",\n                          a.get_str(dom));\n             else\n-                DLOG(dom, rust_log::DWARF, \"  attr ??:\");\n+                DLOG(dom, dwarf, \"  attr ??:\");\n         }\n     }\n-    if (has_children() && dom->get_log().is_tracing(rust_log::DWARF))\n-        dom->get_log().indent();\n   }\n   return die(rdr, rdr->tell_off());\n }\n@@ -494,12 +490,12 @@ rust_crate_reader::die::next_sibling() const\n {\n   // FIXME: use DW_AT_sibling, when present.\n   if (has_children()) {\n-    // DLOG(rdr->mem.dom, rust_log::DWARF, \"+++ children of die 0x%\"\n+    // DLOG(rdr->mem.dom, dwarf, \"+++ children of die 0x%\"\n     //                   PRIxPTR, off);\n     die child = next();\n     while (!child.is_null())\n       child = child.next_sibling();\n-    // DLOG(rdr->mem.dom, rust_log::DWARF, \"--- children of die 0x%\"\n+    // DLOG(rdr->mem.dom, dwarf, \"--- children of die 0x%\"\n     //                   PRIxPTR, off);\n     return child.next();\n   } else {\n@@ -554,16 +550,16 @@ rust_crate_reader::die_reader::die_reader(rust_crate::mem_area &die_mem,\n   get(sizeof_addr);\n \n   if (is_ok()) {\n-    DLOG(dom, rust_log::DWARF, \"new root CU at 0x%\" PRIxPTR, die_mem.base);\n-    DLOG(dom, rust_log::DWARF, \"CU unit length: %\" PRId32, cu_unit_length);\n-    DLOG(dom, rust_log::DWARF, \"dwarf version: %\" PRId16, dwarf_vers);\n-    DLOG(dom, rust_log::DWARF, \"CU abbrev off: %\" PRId32, cu_abbrev_off);\n-    DLOG(dom, rust_log::DWARF, \"size of address: %\" PRId8, sizeof_addr);\n+    DLOG(dom, dwarf, \"new root CU at 0x%\" PRIxPTR, die_mem.base);\n+    DLOG(dom, dwarf, \"CU unit length: %\" PRId32, cu_unit_length);\n+    DLOG(dom, dwarf, \"dwarf version: %\" PRId16, dwarf_vers);\n+    DLOG(dom, dwarf, \"CU abbrev off: %\" PRId32, cu_abbrev_off);\n+    DLOG(dom, dwarf, \"size of address: %\" PRId8, sizeof_addr);\n     I(dom, sizeof_addr == sizeof(uintptr_t));\n     I(dom, dwarf_vers >= 2);\n     I(dom, cu_base + cu_unit_length == die_mem.lim - die_mem.base);\n   } else {\n-    DLOG(dom, rust_log::DWARF, \"failed to read root CU header\");\n+    DLOG(dom, dwarf, \"failed to read root CU header\");\n   }\n }\n \n@@ -580,9 +576,9 @@ rust_crate_reader::rust_crate_reader(rust_dom *dom,\n     die_mem(crate->get_debug_info(dom)),\n     dies(die_mem, abbrevs)\n {\n-  DLOG(dom, rust_log::MEM, \"crate_reader on crate: 0x%\" PRIxPTR, this);\n-  DLOG(dom, rust_log::MEM, \"debug_abbrev: 0x%\" PRIxPTR, abbrev_mem.base);\n-  DLOG(dom, rust_log::MEM, \"debug_info: 0x%\" PRIxPTR, die_mem.base);\n+  DLOG(dom, mem, \"crate_reader on crate: 0x%\" PRIxPTR, this);\n+  DLOG(dom, mem, \"debug_abbrev: 0x%\" PRIxPTR, abbrev_mem.base);\n+  DLOG(dom, mem, \"debug_info: 0x%\" PRIxPTR, die_mem.base);\n   // For now, perform diagnostics only.\n   dies.dump();\n }"}, {"sha": "9c4faf56490c5d17a6c4c3228e014f82b8636984", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 36, "deletions": 69, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -8,6 +8,7 @@ rust_dom::rust_dom(rust_kernel *kernel,\n     interrupt_flag(0),\n     root_crate(root_crate),\n     _log(srv, this),\n+    log_lvl(log_note),\n     srv(srv),\n     local_region(&srv->local_region),\n     synchronized_region(&srv->synchronized_region),\n@@ -34,8 +35,7 @@ rust_dom::rust_dom(rust_kernel *kernel,\n }\n \n rust_dom::~rust_dom() {\n-    DLOG(this, rust_log::MEM | rust_log::DOM,\n-         \"~rust_dom %s @0x%\" PRIxPTR, name, (uintptr_t)this);\n+    DLOG(this, dom, \"~rust_dom %s @0x%\" PRIxPTR, name, (uintptr_t)this);\n     newborn_tasks.delete_all();\n     running_tasks.delete_all();\n     blocked_tasks.delete_all();\n@@ -56,43 +56,18 @@ rust_dom::activate(rust_task *task) {\n }\n \n void\n-rust_dom::log(rust_task *task, uint32_t type_bits, char const *fmt, ...) {\n+rust_dom::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n     char buf[BUF_BYTES];\n-    if (_log.is_tracing(type_bits)) {\n-        va_list args;\n-        va_start(args, fmt);\n-        vsnprintf(buf, sizeof(buf), fmt, args);\n-        _log.trace_ln(task, type_bits, buf);\n-        va_end(args);\n-    }\n+    va_list args;\n+    va_start(args, fmt);\n+    vsnprintf(buf, sizeof(buf), fmt, args);\n+    _log.trace_ln(task, level, buf);\n+    va_end(args);\n }\n \n-void\n-rust_dom::log(uint32_t type_bits, char const *fmt, ...) {\n-    char buf[BUF_BYTES];\n-    if (_log.is_tracing(type_bits)) {\n-        va_list args;\n-        va_start(args, fmt);\n-        vsnprintf(buf, sizeof(buf), fmt, args);\n-        _log.trace_ln(NULL, type_bits, buf);\n-        va_end(args);\n-    }\n-}\n-\n-void\n-rust_dom::logptr(char const *msg, uintptr_t ptrval) {\n-    log(rust_log::MEM, \"%s 0x%\" PRIxPTR, msg, ptrval);\n-}\n-\n-template<typename T> void\n-rust_dom::logptr(char const *msg, T* ptrval) {\n-    log(rust_log::MEM, \"%s 0x%\" PRIxPTR, msg, (uintptr_t)ptrval);\n-}\n-\n-\n void\n rust_dom::fail() {\n-    log(rust_log::DOM, \"domain %s @0x%\" PRIxPTR \" root task failed\",\n+    log(NULL, log_err, \"domain %s @0x%\" PRIxPTR \" root task failed\",\n         name, this);\n     I(this, rval == 0);\n     rval = 1;\n@@ -151,7 +126,7 @@ rust_dom::free(void *mem) {\n \n void\n rust_dom::free(void *mem, memory_region::memory_region_type type) {\n-    DLOG(this, rust_log::MEM, \"rust_dom::free(0x%\" PRIxPTR \")\", mem);\n+    DLOG(this, mem, \"rust_dom::free(0x%\" PRIxPTR \")\", mem);\n     if (type == memory_region::LOCAL) {\n         local_region.free(mem);\n     } else if (type == memory_region::SYNCHRONIZED) {\n@@ -172,8 +147,7 @@ rust_dom::win32_require(LPCTSTR fn, BOOL ok) {\n                       NULL, err,\n                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                       (LPTSTR) &buf, 0, NULL );\n-        DLOG(this, rust_log::ERR, \"%s failed with error %ld: %s\",\n-             fn, err, buf);\n+        DLOG_ERR(this, dom, \"%s failed with error %ld: %s\", fn, err, buf);\n         LocalFree((HLOCAL)buf);\n         I(this, ok);\n     }\n@@ -195,7 +169,7 @@ rust_dom::reap_dead_tasks() {\n         if (task->ref_count == 0) {\n             I(this, task->tasks_waiting_to_join.is_empty());\n             dead_tasks.remove(task);\n-            DLOG(this, rust_log::TASK,\n+            DLOG(this, task,\n                 \"deleting unreferenced dead task %s @0x%\" PRIxPTR,\n                 task->name, task);\n             delete task;\n@@ -211,7 +185,7 @@ rust_dom::reap_dead_tasks() {\n void rust_dom::drain_incoming_message_queue(bool process) {\n     rust_message *message;\n     while (message_queue->dequeue(&message)) {\n-        DLOG(this, rust_log::COMM, \"<== receiving \\\"%s\\\" \" PTR,\n+        DLOG(this, comm, \"<== receiving \\\"%s\\\" \" PTR,\n             message->label, message);\n         if (process) {\n             message->process();\n@@ -244,33 +218,32 @@ rust_dom::schedule_task() {\n \n void\n rust_dom::log_state() {\n+    if (log_rt_task < log_note) return;\n+\n     if (!running_tasks.is_empty()) {\n-        log(rust_log::TASK, \"running tasks:\");\n+        log(NULL, log_note, \"running tasks:\");\n         for (size_t i = 0; i < running_tasks.length(); i++) {\n-            log(rust_log::TASK,\n-                \"\\t task: %s @0x%\" PRIxPTR\n-                \" timeout: %d\",\n+            log(NULL, log_note, \"\\t task: %s @0x%\" PRIxPTR \" timeout: %d\",\n                 running_tasks[i]->name,\n                 running_tasks[i],\n                 running_tasks[i]->yield_timer.get_timeout());\n         }\n     }\n \n     if (!blocked_tasks.is_empty()) {\n-        log(rust_log::TASK, \"blocked tasks:\");\n+        log(NULL, log_note, \"blocked tasks:\");\n         for (size_t i = 0; i < blocked_tasks.length(); i++) {\n-            log(rust_log::TASK,\n-                \"\\t task: %s @0x%\" PRIxPTR \", blocked on: 0x%\" PRIxPTR\n-                \" '%s'\",\n+            log(NULL, log_note, \"\\t task: %s @0x%\" PRIxPTR \", blocked on: 0x%\"\n+                PRIxPTR \" '%s'\",\n                 blocked_tasks[i]->name, blocked_tasks[i],\n                 blocked_tasks[i]->cond, blocked_tasks[i]->cond_name);\n         }\n     }\n \n     if (!dead_tasks.is_empty()) {\n-        log(rust_log::TASK, \"dead tasks:\");\n+        log(NULL, log_note, \"dead tasks:\");\n         for (size_t i = 0; i < dead_tasks.length(); i++) {\n-            log(rust_log::TASK, \"\\t task: %s 0x%\" PRIxPTR \", ref_count: %d\",\n+            log(NULL, log_note, \"\\t task: %s 0x%\" PRIxPTR \", ref_count: %d\",\n                 dead_tasks[i]->name, dead_tasks[i],\n                 dead_tasks[i]->ref_count);\n         }\n@@ -288,9 +261,8 @@ rust_dom::start_main_loop() {\n     // Make sure someone is watching, to pull us out of infinite loops.\n     rust_timer timer(this);\n \n-    DLOG(this, rust_log::DOM, \"started domain loop\");\n-    DLOG(this, rust_log::DOM | rust_log::MEM,\n-        \"activate glue: \" PTR \", exit glue: \" PTR,\n+    DLOG(this, dom, \"started domain loop\");\n+    DLOG(this, dom, \"activate glue: \" PTR \", exit glue: \" PTR,\n         root_crate->get_activate_glue(), root_crate->get_exit_task_glue());\n \n     while (number_of_live_tasks() > 0) {\n@@ -305,20 +277,18 @@ rust_dom::start_main_loop() {\n         // for a minimum amount of time.\n \n         if (scheduled_task == NULL) {\n-            if (_log.is_tracing(rust_log::TASK)) {\n-                log_state();\n-            }\n-            DLOG(this, rust_log::TASK,\n+            log_state();\n+            DLOG(this, task,\n                 \"all tasks are blocked, scheduler yielding ...\");\n             sync::sleep(100);\n-            DLOG(this, rust_log::TASK,\n+            DLOG(this, task,\n                 \"scheduler resuming ...\");\n             continue;\n         }\n \n         I(this, scheduled_task->running());\n \n-        DLOG(this, rust_log::TASK,\n+        DLOG(this, task,\n             \"activating task %s 0x%\" PRIxPTR\n             \", sp=0x%\" PRIxPTR\n             \", ref_count=%d\"\n@@ -333,7 +303,7 @@ rust_dom::start_main_loop() {\n \n         activate(scheduled_task);\n \n-        DLOG(this, rust_log::TASK,\n+        DLOG(this, task,\n                  \"returned from task %s @0x%\" PRIxPTR\n                  \" in state '%s', sp=0x%\" PRIxPTR,\n                  scheduled_task->name,\n@@ -348,34 +318,31 @@ rust_dom::start_main_loop() {\n         reap_dead_tasks();\n     }\n \n-    DLOG(this, rust_log::DOM,\n+    DLOG(this, dom,\n          \"terminated scheduler loop, reaping dead tasks ...\");\n \n     while (dead_tasks.length() > 0) {\n         if (message_queue->is_empty()) {\n-            DLOG(this, rust_log::DOM,\n+            DLOG(this, dom,\n                 \"waiting for %d dead tasks to become dereferenced, \"\n                 \"scheduler yielding ...\",\n                 dead_tasks.length());\n-            if (_log.is_tracing(rust_log::TASK)) {\n-                log_state();\n-            }\n+            log_state();\n             sync::yield();\n         } else {\n             drain_incoming_message_queue(true);\n         }\n         reap_dead_tasks();\n     }\n \n-    DLOG(this, rust_log::DOM, \"finished main-loop (dom.rval = %d)\", rval);\n+    DLOG(this, dom, \"finished main-loop (dom.rval = %d)\", rval);\n     return rval;\n }\n \n \n rust_crate_cache *\n rust_dom::get_cache(rust_crate const *crate) {\n-    DLOG(this, rust_log::CACHE,\n-        \"looking for crate-cache for crate 0x%\" PRIxPTR, crate);\n+    DLOG(this, cache, \"looking for crate-cache for crate 0x%\" PRIxPTR, crate);\n     rust_crate_cache *cache = NULL;\n     for (size_t i = 0; i < caches.length(); ++i) {\n         rust_crate_cache *c = caches[i];\n@@ -385,7 +352,7 @@ rust_dom::get_cache(rust_crate const *crate) {\n         }\n     }\n     if (!cache) {\n-        DLOG(this, rust_log::CACHE,\n+        DLOG(this, cache,\n             \"making new crate-cache for crate 0x%\" PRIxPTR, crate);\n         cache = new (this) rust_crate_cache(this, crate);\n         caches.push(cache);\n@@ -398,7 +365,7 @@ rust_task *\n rust_dom::create_task(rust_task *spawner, const char *name) {\n     rust_task *task =\n         new (this) rust_task (this, &newborn_tasks, spawner, name);\n-    DLOG(this, rust_log::TASK, \"created task: \" PTR \", spawner: %s, name: %s\",\n+    DLOG(this, task, \"created task: \" PTR \", spawner: %s, name: %s\",\n                         task, spawner ? spawner->name : \"null\", name);\n     newborn_tasks.append(task);\n     return task;"}, {"sha": "fa61aa7940641327ad7f8071e1f80782f897fdfb", "filename": "src/rt/rust_dom.h", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -14,6 +14,7 @@ struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n     // glue.\n     rust_crate const *root_crate;\n     rust_log _log;\n+    uint32_t log_lvl;\n     rust_srv *srv;\n     memory_region local_region;\n     memory_region synchronized_region;\n@@ -47,16 +48,12 @@ struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain.\n     rust_dom(rust_kernel *kernel,\n-        rust_message_queue *message_queue, rust_srv *srv,\n-        rust_crate const *root_crate, const char *name);\n+             rust_message_queue *message_queue, rust_srv *srv,\n+             rust_crate const *root_crate, const char *name);\n     ~rust_dom();\n     void activate(rust_task *task);\n-    void log(rust_task *task, uint32_t logbit, char const *fmt, ...);\n-    void log(uint32_t logbit, char const *fmt, ...);\n+    void log(rust_task *task, uint32_t level, char const *fmt, ...);\n     rust_log & get_log();\n-    void logptr(char const *msg, uintptr_t ptrval);\n-    template<typename T>\n-    void logptr(char const *msg, T* ptrval);\n     void fail();\n     void *malloc(size_t size);\n     void *malloc(size_t size, memory_region::memory_region_type type);\n@@ -83,7 +80,6 @@ struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n     int start_main_loop();\n \n     void log_state();\n-    static void log_all_state();\n \n     rust_task *create_task(rust_task *spawner, const char *name);\n };"}, {"sha": "2676e9b9b191471124d2beb98637249ffc9cfdce", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -48,8 +48,8 @@ extern \"C\" {\n #include \"sync/lock_free_queue.h\"\n \n class rust_dom;\n-class rust_log;\n class rust_task;\n+class rust_log;\n class rust_port;\n class rust_chan;\n struct rust_token;"}, {"sha": "e1629b4fbf33bcbec756e2c49c870de51833b200", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -1,11 +1,11 @@\n #include \"rust_internal.h\"\n \n-#define KLOG(...)                                 \\\n-  do {                                            \\\n-    if (_log.is_tracing(rust_log::KERN)) {        \\\n-        log(rust_log::KERN, __VA_ARGS__);         \\\n-    }                                             \\\n-  } while(0)\n+#define KLOG(...)                                          \\\n+  do {                                                     \\\n+      if (log_rt_kern >= log_note) {                       \\\n+          log(log_note, __VA_ARGS__);                      \\\n+      }                                                    \\\n+  } while (0)\n \n rust_kernel::rust_kernel(rust_srv *srv) :\n     _region(&srv->local_region),\n@@ -123,15 +123,13 @@ rust_kernel::is_deadlocked() {\n }\n \n void\n-rust_kernel::log(uint32_t type_bits, char const *fmt, ...) {\n+rust_kernel::log(uint32_t level, char const *fmt, ...) {\n     char buf[BUF_BYTES];\n-    if (_log.is_tracing(type_bits)) {\n-        va_list args;\n-        va_start(args, fmt);\n-        vsnprintf(buf, sizeof(buf), fmt, args);\n-        _log.trace_ln(NULL, type_bits, buf);\n-        va_end(args);\n-    }\n+    va_list args;\n+    va_start(args, fmt);\n+    vsnprintf(buf, sizeof(buf), fmt, args);\n+    _log.trace_ln(NULL, level, buf);\n+    va_end(args);\n }\n \n void"}, {"sha": "42ca469e8f18e960801728e40ad894bd28b4ccc7", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -107,7 +107,7 @@ class rust_kernel : public rust_thread {\n     void join_all_domains();\n \n     void log_all_domain_state();\n-    void log(uint32_t type_bits, char const *fmt, ...);\n+    void log(uint32_t level, char const *fmt, ...);\n     virtual ~rust_kernel();\n \n     void *malloc(size_t size);"}, {"sha": "5a2b7142d7b708c730c4bda7e97fe6135fc35830", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 65, "deletions": 115, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Logging infrastructure that aims to support multi-threading, indentation\n+ * Logging infrastructure that aims to support multi-threading,\n  * and ansi colors.\n  */\n \n@@ -9,58 +9,6 @@\n #include <stdlib.h>\n #include <string.h>\n \n-// FIXME somehow unify this with the parsing happening in rust_crate.cpp\n-static uint32_t\n-read_type_bit_mask() {\n-    uint32_t bits = rust_log::ULOG | rust_log::ERR;\n-    char *env_str = getenv(\"RUST_LOG\");\n-    if (env_str) {\n-        char *str = new char[strlen(env_str) + 2];\n-        str[0] = ',';\n-        strcpy(str + 1, env_str);\n-\n-        bits = rust_log::ULOG;\n-        bits |= strstr(str, \",err\") ? rust_log::ERR : 0;\n-        bits |= strstr(str, \",mem\") ? rust_log::MEM : 0;\n-        bits |= strstr(str, \",comm\") ? rust_log::COMM : 0;\n-        bits |= strstr(str, \",task\") ? rust_log::TASK : 0;\n-        bits |= strstr(str, \",up\") ? rust_log::UPCALL : 0;\n-        bits |= strstr(str, \",dom\") ? rust_log::DOM : 0;\n-        bits |= strstr(str, \",trace\") ? rust_log::TRACE : 0;\n-        bits |= strstr(str, \",dwarf\") ? rust_log::DWARF : 0;\n-        bits |= strstr(str, \",cache\") ? rust_log::CACHE : 0;\n-        bits |= strstr(str, \",timer\") ? rust_log::TIMER : 0;\n-        bits |= strstr(str, \",gc\") ? rust_log::GC : 0;\n-        bits |= strstr(str, \",stdlib\") ? rust_log::STDLIB : 0;\n-        bits |= strstr(str, \",special\") ? rust_log::SPECIAL : 0;\n-        bits |= strstr(str, \",kern\") ? rust_log::KERN : 0;\n-        bits |= strstr(str, \",bt\") ? rust_log::BT : 0;\n-        bits |= strstr(str, \",all\") ? rust_log::ALL : 0;\n-        bits = strstr(str, \",none\") ? 0 : bits;\n-\n-        delete[] str;\n-    }\n-    return bits;\n-}\n-\n-rust_log::ansi_color\n-get_type_color(rust_log::log_type type) {\n-    rust_log::ansi_color color = rust_log::WHITE;\n-    if (type & rust_log::ERR)\n-        color = rust_log::RED;\n-    if (type & rust_log::MEM)\n-        color = rust_log::YELLOW;\n-    if (type & rust_log::UPCALL)\n-        color = rust_log::GREEN;\n-    if (type & rust_log::COMM)\n-        color = rust_log::MAGENTA;\n-    if (type & rust_log::DOM)\n-        color = rust_log::LIGHTTEAL;\n-    if (type & rust_log::TASK)\n-        color = rust_log::LIGHTTEAL;\n-    return color;\n-}\n-\n static const char * _foreground_colors[] = { \"[37m\",\n                                              \"[31m\", \"[1;31m\",\n                                              \"[32m\", \"[1;32m\",\n@@ -78,9 +26,7 @@ static uint32_t _last_thread_id;\n rust_log::rust_log(rust_srv *srv, rust_dom *dom) :\n     _srv(srv),\n     _dom(dom),\n-    _type_bit_mask(read_type_bit_mask()),\n-    _use_colors(getenv(\"RUST_COLOR_LOG\")),\n-    _indent(0) {\n+    _use_colors(getenv(\"RUST_COLOR_LOG\")) {\n }\n \n rust_log::~rust_log() {\n@@ -141,9 +87,6 @@ rust_log::trace_ln(uint32_t thread_id, char *prefix, char *message) {\n     char buffer[BUF_BYTES] = \"\";\n     _log_lock.lock();\n     append_string(buffer, \"%-34s\", prefix);\n-    for (uint32_t i = 0; i < _indent; i++) {\n-        append_string(buffer, \"    \");\n-    }\n     append_string(buffer, \"%s\", message);\n     if (_last_thread_id != thread_id) {\n         _last_thread_id = thread_id;\n@@ -154,7 +97,7 @@ rust_log::trace_ln(uint32_t thread_id, char *prefix, char *message) {\n }\n \n void\n-rust_log::trace_ln(rust_task *task, char *message) {\n+rust_log::trace_ln(rust_task *task, uint32_t level, char *message) {\n #if defined(__WIN32__)\n     uint32_t thread_id = 0;\n #else\n@@ -178,55 +121,16 @@ rust_log::trace_ln(rust_task *task, char *message) {\n     trace_ln(thread_id, prefix, message);\n }\n \n-/**\n- * Traces a log message if the specified logging type is not filtered.\n- */\n-void\n-rust_log::trace_ln(rust_task *task, uint32_t type_bits, char *message) {\n-    trace_ln(task, get_type_color((rust_log::log_type) type_bits),\n-             type_bits, message);\n-}\n-\n-/**\n- * Traces a log message using the specified ANSI color code.\n- */\n-void\n-rust_log::trace_ln(rust_task *task, ansi_color color,\n-                   uint32_t type_bits, char *message) {\n-    if (is_tracing(type_bits)) {\n-        if (_use_colors) {\n-            char buffer[BUF_BYTES] = \"\";\n-            append_string(buffer, color, \"%s\", message);\n-            trace_ln(task, buffer);\n-        } else {\n-            trace_ln(task, message);\n-        }\n-    }\n-}\n-\n-void\n-rust_log::indent() {\n-    _indent++;\n-}\n-\n-void\n-rust_log::outdent() {\n-    _indent--;\n-}\n-\n-void\n-rust_log::reset_indent(uint32_t indent) {\n-    _indent = indent;\n-}\n+// Reading log directives and setting log level vars\n \n struct mod_entry {\n     const char* name;\n-    int* state;\n+    size_t* state;\n };\n \n struct cratemap {\n-    mod_entry* entries;\n-    cratemap* children[1];\n+    const mod_entry* entries;\n+    const cratemap* children[1];\n };\n \n struct log_directive {\n@@ -235,11 +139,12 @@ struct log_directive {\n };\n \n const size_t max_log_directives = 255;\n+const size_t max_log_level = 1;\n+const size_t default_log_level = 0;\n \n // This is a rather ugly parser for strings in the form\n-// \"crate1,crate2.mod3,crate3.x=2\". Log levels range 0=err, 1=warn, 2=info,\n-// 3=debug. Default is 1. Words without an '=X' part set the log level for\n-// that module (and submodules) to 3.\n+// \"crate1,crate2.mod3,crate3.x=1\". Log levels are 0-1 for now,\n+// eventually we'll have 0-3.\n size_t parse_logging_spec(char* spec, log_directive* dirs) {\n     size_t dir = 0;\n     while (dir < max_log_directives && *spec) {\n@@ -251,10 +156,10 @@ size_t parse_logging_spec(char* spec, log_directive* dirs) {\n                 if (start == spec) {spec++; break;}\n                 *spec = '\\0';\n                 spec++;\n-                size_t level = 3;\n+                size_t level = max_log_level;\n                 if (cur == '=') {\n                     level = *spec - '0';\n-                    if (level > 3) level = 1;\n+                    if (level > max_log_level) level = max_log_level;\n                     if (*spec) ++spec;\n                 }\n                 dirs[dir].name = start;\n@@ -267,10 +172,10 @@ size_t parse_logging_spec(char* spec, log_directive* dirs) {\n     return dir;\n }\n \n-void update_crate_map(cratemap* map, log_directive* dirs, size_t n_dirs) {\n-    // First update log levels for this crate\n-    for (mod_entry* cur = map->entries; cur->name; cur++) {\n-        size_t level = 1, longest_match = 0;\n+void update_module_map(const mod_entry* map, log_directive* dirs,\n+                       size_t n_dirs) {\n+    for (const mod_entry* cur = map; cur->name; cur++) {\n+        size_t level = default_log_level, longest_match = 0;\n         for (size_t d = 0; d < n_dirs; d++) {\n             if (strstr(cur->name, dirs[d].name) == cur->name &&\n                 strlen(dirs[d].name) > longest_match) {\n@@ -280,24 +185,69 @@ void update_crate_map(cratemap* map, log_directive* dirs, size_t n_dirs) {\n         }\n         *cur->state = level;\n     }\n+}\n \n+void update_crate_map(const cratemap* map, log_directive* dirs,\n+                      size_t n_dirs) {\n+    // First update log levels for this crate\n+    update_module_map(map->entries, dirs, n_dirs);\n     // Then recurse on linked crates\n+    // FIXME this does double work in diamond-shaped deps. could keep\n+    //   a set of visited addresses, if it turns out to be actually slow\n     for (size_t i = 0; map->children[i]; i++) {\n         update_crate_map(map->children[i], dirs, n_dirs);\n     }\n }\n \n+// These are pseudo-modules used to control logging in the runtime.\n+\n+size_t log_rt_mem;\n+size_t log_rt_comm;\n+size_t log_rt_task;\n+size_t log_rt_dom;\n+size_t log_rt_trace;\n+size_t log_rt_dwarf;\n+size_t log_rt_cache;\n+size_t log_rt_upcall;\n+size_t log_rt_timer;\n+size_t log_rt_gc;\n+size_t log_rt_stdlib;\n+size_t log_rt_kern;\n+size_t log_rt_backtrace;\n+// Used to turn logging for rustboot-compiled code on and off\n+size_t log_rustboot;\n+\n+static const mod_entry _rt_module_map[] =\n+    {{\"rt.mem\", &log_rt_mem},\n+     {\"rt.comm\", &log_rt_comm},\n+     {\"rt.task\", &log_rt_task},\n+     {\"rt.dom\", &log_rt_dom},\n+     {\"rt.trace\", &log_rt_trace},\n+     {\"rt.dwarf\", &log_rt_dwarf},\n+     {\"rt.cache\", &log_rt_cache},\n+     {\"rt.upcall\", &log_rt_upcall},\n+     {\"rt.timer\", &log_rt_timer},\n+     {\"rt.gc\", &log_rt_gc},\n+     {\"rt.stdlib\", &log_rt_stdlib},\n+     {\"rt.kern\", &log_rt_kern},\n+     {\"rt.backtrace\", &log_rt_backtrace},\n+     {\"rustboot\", &log_rustboot},\n+     {NULL, NULL}};\n+\n void update_log_settings(void* crate_map, char* settings) {\n     char* buffer = NULL;\n     log_directive dirs[256];\n-    size_t dir = 0;\n+    size_t n_dirs = 0;\n     if (settings) {\n         buffer = (char*)malloc(strlen(settings));\n         strcpy(buffer, settings);\n-        dir = parse_logging_spec(buffer, &dirs[0]);\n+        n_dirs = parse_logging_spec(buffer, &dirs[0]);\n     }\n \n-    update_crate_map((cratemap*)crate_map, &dirs[0], dir);\n+    update_module_map(_rt_module_map, &dirs[0], n_dirs);\n+    // FIXME check can be dropped when rustboot is gone\n+    if (crate_map)\n+        update_crate_map((const cratemap*)crate_map, &dirs[0], n_dirs);\n \n     free(buffer);\n }"}, {"sha": "51019a89febfe5e75ecf55c54f230607b8967fa2", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -1,28 +1,26 @@\n #ifndef RUST_LOG_H\n #define RUST_LOG_H\n \n-#define DLOG(dom, mask, ...)                         \\\n-  do {                                               \\\n-    rust_dom *_dom = dom;                            \\\n-    uint32_t _mask = mask;                           \\\n-    if ((_dom)->get_log().is_tracing(_mask)) {       \\\n-        (_dom)->log(_mask, __VA_ARGS__);             \\\n-    }                                                \\\n-  } while(0)\n-#define LOG(task, mask, ...)                         \\\n-  DLOG((task)->dom, mask, __VA_ARGS__)\n-#define LOG_I(task, mask, ...)                       \\\n-  do {                                               \\\n-    rust_task *_task = task;                         \\\n-    uint32_t _mask = mask;                           \\\n-    if ((_task)->dom->get_log().is_tracing(_mask)) { \\\n-      (_task)->dom->get_log().reset_indent(0);       \\\n-      (_task)->dom->log(_mask, __VA_ARGS__);         \\\n-      (_task)->dom->get_log().indent();              \\\n-    }                                                \\\n-  } while(0)\n-#define LOGPTR(dom, msg, ptrval)                     \\\n-  DLOG(dom, rust_log::MEM, \"%s 0x%\" PRIxPTR, msg, ptrval)\n+const uint32_t log_err = 0;\n+const uint32_t log_note = 1;\n+\n+#define LOG(task, field, ...)                                   \\\n+    DLOG_LVL(log_note, task, task->dom, field, __VA_ARGS__)\n+#define LOG_ERR(task, field, ...)                               \\\n+    DLOG_LVL(log_err, task, task->dom, field, __VA_ARGS__)\n+#define DLOG(dom, field, ...)                                   \\\n+    DLOG_LVL(log_note, NULL, dom, field, __VA_ARGS__)\n+#define DLOG_ERR(dom, field, ...)                               \\\n+    DLOG_LVL(log_err, NULL, dom, field, __VA_ARGS__)\n+#define LOGPTR(dom, msg, ptrval)                                \\\n+    DLOG_LVL(log_note, NULL, dom, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n+#define DLOG_LVL(lvl, task, dom, field, ...)                    \\\n+    do {                                                        \\\n+        rust_dom* _d_ = dom;                                    \\\n+        if (log_rt_##field >= lvl && _d_->log_lvl >= lvl) {     \\\n+            _d_->log(task, lvl, __VA_ARGS__);                   \\\n+        }                                                       \\\n+    } while (0)\n \n class rust_dom;\n class rust_task;\n@@ -49,50 +47,33 @@ class rust_log {\n         LIGHTTEAL\n     };\n \n-    enum log_type {\n-        ERR = 0x1,\n-        MEM = 0x2,\n-        COMM = 0x4,\n-        TASK = 0x8,\n-        DOM = 0x10,\n-        ULOG = 0x20,\n-        TRACE = 0x40,\n-        DWARF = 0x80,\n-        CACHE = 0x100,\n-        UPCALL = 0x200,\n-        TIMER = 0x400,\n-        GC = 0x800,\n-        STDLIB = 0x1000,\n-        SPECIAL = 0x2000,\n-        KERN = 0x4000,\n-        BT = 0x8000,\n-        ALL = 0xffffffff\n-    };\n-\n-    void indent();\n-    void outdent();\n-    void reset_indent(uint32_t indent);\n+    void trace_ln(rust_task *task, uint32_t level, char *message);\n     void trace_ln(uint32_t thread_id, char *prefix, char *message);\n-    void trace_ln(rust_task *task, uint32_t type_bits, char *message);\n-    void trace_ln(rust_task *task, ansi_color color,\n-                  uint32_t type_bits, char *message);\n     bool is_tracing(uint32_t type_bits);\n \n private:\n     rust_srv *_srv;\n     rust_dom *_dom;\n-    uint32_t _type_bit_mask;\n     bool _use_labels;\n     bool _use_colors;\n-    uint32_t _indent;\n     void trace_ln(rust_task *task, char *message);\n };\n \n-inline bool\n-rust_log::is_tracing(uint32_t type_bits) {\n-    return type_bits & _type_bit_mask;\n-}\n-\n void update_log_settings(void* crate_map, char* settings);\n \n+extern size_t log_rt_mem;\n+extern size_t log_rt_comm;\n+extern size_t log_rt_task;\n+extern size_t log_rt_dom;\n+extern size_t log_rt_trace;\n+extern size_t log_rt_dwarf;\n+extern size_t log_rt_cache;\n+extern size_t log_rt_upcall;\n+extern size_t log_rt_timer;\n+extern size_t log_rt_gc;\n+extern size_t log_rt_stdlib;\n+extern size_t log_rt_kern;\n+extern size_t log_rt_backtrace;\n+extern size_t log_rustboot;\n+\n #endif /* RUST_LOG_H */"}, {"sha": "19a1d8a367e4e81a6864e95dc32f4e830e9e5f57", "filename": "src/rt/rust_message.cpp", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -51,9 +51,6 @@ send(notification_type type, const char* label,\n     memory_region *region = &target->message_queue->region;\n     notify_message *message =\n         new (region) notify_message(region, type, label, source, target);\n-//    target->referent()->log(rust_log::COMM,\n-//                            \"==> sending \\\"%s\\\" \" PTR \" in queue \" PTR,\n-//                            label, message, &target->message_queue);\n     target->message_queue->enqueue(message);\n }\n \n@@ -99,16 +96,13 @@ send(uint8_t *buffer, size_t buffer_sz, const char* label,\n     data_message *message =\n         new (region) data_message(region, buffer, buffer_sz, label, source,\n                                   port);\n-    source->referent()->log(rust_log::COMM,\n-                            \"==> sending \\\"%s\\\"\" PTR \" in queue \" PTR,\n-                            label, message, &port->message_queue);\n+    LOG(source->referent(), comm, \"==> sending \\\"%s\\\"\" PTR \" in queue \" PTR,\n+        label, message, &port->message_queue);\n     port->message_queue->enqueue(message);\n }\n \n void data_message::process() {\n     _port->referent()->remote_channel->send(_buffer);\n-    // _target->referent()->log(rust_log::COMM,\n-    //                         \"<=== received data via message ===\");\n }\n \n void data_message::kernel_process() {"}, {"sha": "57d0b21683650a02f2a6ad29e17772478faa45b4", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -5,17 +5,16 @@ rust_port::rust_port(rust_task *task, size_t unit_sz) :\n                      maybe_proxy<rust_port>(this), task(task),\n                      unit_sz(unit_sz), writers(task->dom), chans(task->dom) {\n \n-    LOG(task, rust_log::MEM | rust_log::COMM,\n-              \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n-              PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n+    LOG(task, comm,\n+        \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n+        PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n \n     // Allocate a remote channel, for remote channel data.\n     remote_channel = new (task->dom) rust_chan(task, this, unit_sz);\n }\n \n rust_port::~rust_port() {\n-    LOG(task, rust_log::COMM | rust_log::MEM,\n-              \"~rust_port 0x%\" PRIxPTR, (uintptr_t) this);\n+    LOG(task, comm, \"~rust_port 0x%\" PRIxPTR, (uintptr_t) this);\n \n     //    log_state();\n \n@@ -25,7 +24,7 @@ rust_port::~rust_port() {\n         chan->disassociate();\n \n         if (chan->ref_count == 0) {\n-            LOG(task, rust_log::COMM,\n+            LOG(task, comm,\n                 \"chan: 0x%\" PRIxPTR \" is dormant, freeing\", chan);\n             delete chan;\n         }\n@@ -39,20 +38,20 @@ bool rust_port::receive(void *dptr) {\n         rust_chan *chan = chans[i];\n         if (chan->buffer.is_empty() == false) {\n             chan->buffer.dequeue(dptr);\n-            LOG(task, rust_log::COMM, \"<=== read data ===\");\n+            LOG(task, comm, \"<=== read data ===\");\n             return true;\n         }\n     }\n     return false;\n }\n \n void rust_port::log_state() {\n-    LOG(task, rust_log::COMM,\n+    LOG(task, comm,\n               \"rust_port: 0x%\" PRIxPTR \", associated channel(s): %d\",\n               this, chans.length());\n     for (uint32_t i = 0; i < chans.length(); i++) {\n         rust_chan *chan = chans[i];\n-        LOG(task, rust_log::COMM,\n+        LOG(task, comm,\n             \"\\tchan: 0x%\" PRIxPTR \", size: %d, remote: %s\",\n             chan,\n             chan->buffer.size(),"}, {"sha": "4573bd0180411570ed9a7d82b8d214c9771e6aa7", "filename": "src/rt/rust_srv.cpp", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_srv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_srv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_srv.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -11,11 +11,7 @@ rust_srv::rust_srv() :\n     // Nop.\n }\n \n-rust_srv::~rust_srv() {\n-//    char msg[BUF_BYTES];\n-//    snprintf(msg, sizeof(msg), \"~rust_srv %\" PRIxPTR, (uintptr_t) this);\n-//    log(msg);\n-}\n+rust_srv::~rust_srv() {}\n \n void\n rust_srv::free(void *p) {"}, {"sha": "8d7157ed77c9c23275c87e425767f40664f4426e", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 53, "deletions": 74, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -102,24 +102,23 @@ rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n \n rust_task::~rust_task()\n {\n-    DLOG(dom, rust_log::MEM|rust_log::TASK,\n-             \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n-             name, (uintptr_t)this, ref_count);\n+    DLOG(dom, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n+         name, (uintptr_t)this, ref_count);\n \n     /*\n       for (uintptr_t fp = get_fp(); fp; fp = get_previous_fp(fp)) {\n       frame_glue_fns *glue_fns = get_frame_glue_fns(fp);\n-      DLOG(dom, rust_log::MEM|rust_log::TASK,\n+      DLOG(dom, task,\n       \"~rust_task, frame fp=0x%\" PRIxPTR \", glue_fns=0x%\" PRIxPTR,\n       fp, glue_fns);\n       if (glue_fns) {\n-      DLOG(dom, rust_log::MEM|rust_log::TASK,\n+      DLOG(dom, task,\n                \"~rust_task, mark_glue=0x%\" PRIxPTR,\n                glue_fns->mark_glue);\n-      DLOG(dom, rust_log::MEM|rust_log::TASK,\n+      DLOG(dom, task,\n                \"~rust_task, drop_glue=0x%\" PRIxPTR,\n                glue_fns->drop_glue);\n-      DLOG(dom, rust_log::MEM|rust_log::TASK,\n+      DLOG(dom, task,\n                \"~rust_task, reloc_glue=0x%\" PRIxPTR,\n                glue_fns->reloc_glue);\n       }\n@@ -266,28 +265,26 @@ rust_task::grow(size_t n_frame_bytes)\n     uintptr_t old_bottom = (uintptr_t) &old_stk->data[0];\n     uintptr_t rust_sp_disp = old_top - this->rust_sp;\n     size_t ssz = old_top - old_bottom;\n-    DLOG(dom, rust_log::MEM|rust_log::TASK|rust_log::UPCALL,\n-             \"upcall_grow_task(%\" PRIdPTR\n-             \"), old size %\" PRIdPTR\n-             \" bytes (old lim: 0x%\" PRIxPTR \")\",\n-             n_frame_bytes, ssz, old_top);\n+    DLOG(dom, task, \"upcall_grow_task(%\" PRIdPTR\n+         \"), old size %\" PRIdPTR \" bytes (old lim: 0x%\" PRIxPTR \")\",\n+         n_frame_bytes, ssz, old_top);\n     ssz *= 2;\n     if (ssz < n_frame_bytes)\n         ssz = n_frame_bytes;\n     ssz = next_power_of_two(ssz);\n \n-    DLOG(dom, rust_log::MEM|rust_log::TASK, \"upcall_grow_task growing stk 0x%\"\n-             PRIxPTR \" to %d bytes\", old_stk, ssz);\n+    DLOG(dom, task, \"upcall_grow_task growing stk 0x%\"\n+         PRIxPTR \" to %d bytes\", old_stk, ssz);\n \n     stk_seg *nstk = new_stk(dom, ssz);\n     uintptr_t new_top = (uintptr_t) &nstk->data[ssz];\n     size_t n_copy = old_top - old_bottom;\n-    DLOG(dom, rust_log::MEM|rust_log::TASK,\n-             \"copying %d bytes of stack from [0x%\" PRIxPTR \", 0x%\" PRIxPTR \"]\"\n-             \" to [0x%\" PRIxPTR \", 0x%\" PRIxPTR \"]\",\n-             n_copy,\n-             old_bottom, old_bottom + n_copy,\n-             new_top - n_copy, new_top);\n+    DLOG(dom, task,\n+         \"copying %d bytes of stack from [0x%\" PRIxPTR \", 0x%\" PRIxPTR \"]\"\n+         \" to [0x%\" PRIxPTR \", 0x%\" PRIxPTR \"]\",\n+         n_copy,\n+         old_bottom, old_bottom + n_copy,\n+         new_top - n_copy, new_top);\n \n     VALGRIND_MAKE_MEM_DEFINED((void*)old_bottom, n_copy);\n     memcpy((void*)(new_top - n_copy), (void*)old_bottom, n_copy);\n@@ -296,7 +293,7 @@ rust_task::grow(size_t n_frame_bytes)\n     this->stk = nstk;\n     this->rust_sp = new_top - rust_sp_disp;\n \n-    DLOG(dom, rust_log::MEM|rust_log::TASK, \"processing relocations\");\n+    DLOG(dom, task, \"processing relocations\");\n \n     // FIXME (issue #32): this is the most ridiculously crude\n     // relocation scheme ever. Try actually, you know, writing out\n@@ -305,14 +302,13 @@ rust_task::grow(size_t n_frame_bytes)\n     for (uintptr_t* p = (uintptr_t*)(new_top - n_copy);\n          p < (uintptr_t*)new_top; ++p) {\n         if (old_bottom <= *p && *p < old_top) {\n-            //DLOG(dom, rust_log::MEM, \"relocating pointer 0x%\" PRIxPTR\n+            //DLOG(dom, mem, \"relocating pointer 0x%\" PRIxPTR\n             //        \" by %d bytes\", *p, (new_top - old_top));\n             n_relocs++;\n             *p += (new_top - old_top);\n         }\n     }\n-    DLOG(dom, rust_log::MEM|rust_log::TASK,\n-             \"processed %d relocations\", n_relocs);\n+    DLOG(dom, task, \"processed %d relocations\", n_relocs);\n     del_stk(dom, old_stk);\n     LOGPTR(dom, \"grown stk limit\", new_top);\n #endif\n@@ -342,11 +338,11 @@ rust_task::run_after_return(size_t nargs, uintptr_t glue)\n     sp = align_down(sp - nargs * sizeof(uintptr_t));\n \n     uintptr_t *retpc = ((uintptr_t *) sp) - 1;\n-    DLOG(dom, rust_log::TASK|rust_log::MEM,\n-             \"run_after_return: overwriting retpc=0x%\" PRIxPTR\n-             \" @ runtime_sp=0x%\" PRIxPTR\n-             \" with glue=0x%\" PRIxPTR,\n-             *retpc, sp, glue);\n+    DLOG(dom, task,\n+         \"run_after_return: overwriting retpc=0x%\" PRIxPTR\n+         \" @ runtime_sp=0x%\" PRIxPTR\n+         \" with glue=0x%\" PRIxPTR,\n+         *retpc, sp, glue);\n \n     // Move the current return address (which points into rust code)\n     // onto the rust stack and pretend we just called into the glue.\n@@ -363,7 +359,7 @@ rust_task::run_on_resume(uintptr_t glue)\n     // Inject glue as resume address in the suspended frame.\n     uintptr_t* rsp = (uintptr_t*) rust_sp;\n     rsp += n_callee_saves;\n-    DLOG(dom, rust_log::TASK|rust_log::MEM,\n+    DLOG(dom, task,\n              \"run_on_resume: overwriting retpc=0x%\" PRIxPTR\n              \" @ rust_sp=0x%\" PRIxPTR\n              \" with glue=0x%\" PRIxPTR,\n@@ -378,8 +374,7 @@ rust_task::yield(size_t nargs) {\n \n void\n rust_task::yield(size_t nargs, size_t time_in_us) {\n-    log(rust_log::TASK,\n-        \"task %s @0x%\" PRIxPTR \" yielding for %d us\",\n+    LOG(this, task, \"task %s @0x%\" PRIxPTR \" yielding for %d us\",\n         name, this, time_in_us);\n     yield_timer.reset(time_in_us);\n     run_after_return(nargs, dom->root_crate->get_yield_glue());\n@@ -401,48 +396,48 @@ rust_task::kill() {\n     // Note the distinction here: kill() is when you're in an upcall\n     // from task A and want to force-fail task B, you do B->kill().\n     // If you want to fail yourself you do self->fail(upcall_nargs).\n-    log(rust_log::TASK, \"killing task %s @0x%\" PRIxPTR, name, this);\n+    LOG(this, task, \"killing task %s @0x%\" PRIxPTR, name, this);\n     // Unblock the task so it can unwind.\n     unblock();\n \n     if (this == dom->root_task)\n         dom->fail();\n \n-    log(rust_log::TASK, \"preparing to unwind task: 0x%\" PRIxPTR, this);\n+    LOG(this, task, \"preparing to unwind task: 0x%\" PRIxPTR, this);\n     run_on_resume(dom->root_crate->get_unwind_glue());\n }\n \n void\n rust_task::fail(size_t nargs) {\n     // See note in ::kill() regarding who should call this.\n-    DLOG(dom, rust_log::TASK, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n+    DLOG(dom, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n     backtrace();\n     // Unblock the task so it can unwind.\n     unblock();\n     if (this == dom->root_task)\n         dom->fail();\n     run_after_return(nargs, dom->root_crate->get_unwind_glue());\n     if (supervisor) {\n-        DLOG(dom, rust_log::TASK,\n-                 \"task %s @0x%\" PRIxPTR\n-                 \" propagating failure to supervisor %s @0x%\" PRIxPTR,\n-                 name, this, supervisor->name, supervisor);\n+        DLOG(dom, task,\n+             \"task %s @0x%\" PRIxPTR\n+             \" propagating failure to supervisor %s @0x%\" PRIxPTR,\n+             name, this, supervisor->name, supervisor);\n         supervisor->kill();\n     }\n }\n \n void\n rust_task::gc(size_t nargs)\n {\n-    DLOG(dom, rust_log::TASK|rust_log::MEM,\n+    DLOG(dom, task,\n              \"task %s @0x%\" PRIxPTR \" garbage collecting\", name, this);\n     run_after_return(nargs, dom->root_crate->get_gc_glue());\n }\n \n void\n rust_task::unsupervise()\n {\n-    DLOG(dom, rust_log::TASK,\n+    DLOG(dom, task,\n              \"task %s @0x%\" PRIxPTR\n              \" disconnecting from supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n@@ -452,7 +447,7 @@ rust_task::unsupervise()\n void\n rust_task::notify_tasks_waiting_to_join() {\n     while (tasks_waiting_to_join.is_empty() == false) {\n-        log(rust_log::TASK, \"notify_tasks_waiting_to_join: %d\",\n+        LOG(this, task, \"notify_tasks_waiting_to_join: %d\",\n             tasks_waiting_to_join.size());\n         maybe_proxy<rust_task> *waiting_task = 0;\n         tasks_waiting_to_join.pop(&waiting_task);\n@@ -551,10 +546,9 @@ rust_task::malloc(size_t sz, type_desc *td)\n         return mem;\n     if (td) {\n         gc_alloc *gcm = (gc_alloc*) mem;\n-        DLOG(dom, rust_log::TASK|rust_log::MEM|rust_log::GC,\n-                 \"task %s @0x%\" PRIxPTR\n-                 \" allocated %d GC bytes = 0x%\" PRIxPTR,\n-                 name, (uintptr_t)this, sz, gcm);\n+        DLOG(dom, task, \"task %s @0x%\" PRIxPTR\n+             \" allocated %d GC bytes = 0x%\" PRIxPTR,\n+             name, (uintptr_t)this, sz, gcm);\n         memset((void*) gcm, 0, sizeof(gc_alloc));\n         link_gc(gcm);\n         gcm->ctrl_word = (uintptr_t)td;\n@@ -575,10 +569,9 @@ rust_task::realloc(void *data, size_t sz, bool is_gc)\n         unlink_gc(gcm);\n         sz += sizeof(gc_alloc);\n         gcm = (gc_alloc*) dom->realloc((void*)gcm, sz);\n-        DLOG(dom, rust_log::TASK|rust_log::MEM|rust_log::GC,\n-                 \"task %s @0x%\" PRIxPTR\n-                 \" reallocated %d GC bytes = 0x%\" PRIxPTR,\n-                 name, (uintptr_t)this, sz, gcm);\n+        DLOG(dom, task, \"task %s @0x%\" PRIxPTR\n+             \" reallocated %d GC bytes = 0x%\" PRIxPTR,\n+             name, (uintptr_t)this, sz, gcm);\n         if (!gcm)\n             return gcm;\n         link_gc(gcm);\n@@ -598,9 +591,9 @@ rust_task::free(void *p, bool is_gc)\n     if (is_gc) {\n         gc_alloc *gcm = (gc_alloc*)(((char *)p) - sizeof(gc_alloc));\n         unlink_gc(gcm);\n-        DLOG(dom, rust_log::TASK|rust_log::MEM|rust_log::GC,\n-                 \"task %s @0x%\" PRIxPTR \" freeing GC memory = 0x%\" PRIxPTR,\n-                 name, (uintptr_t)this, gcm);\n+        DLOG(dom, mem,\n+             \"task %s @0x%\" PRIxPTR \" freeing GC memory = 0x%\" PRIxPTR,\n+             name, (uintptr_t)this, gcm);\n         dom->free(gcm);\n     } else {\n         dom->free(p);\n@@ -610,7 +603,7 @@ rust_task::free(void *p, bool is_gc)\n void\n rust_task::transition(rust_task_list *src, rust_task_list *dst) {\n     I(dom, state == src);\n-    DLOG(dom, rust_log::TASK,\n+    DLOG(dom, task,\n              \"task %s \" PTR \" state change '%s' -> '%s'\",\n              name, (uintptr_t)this, src->name, dst->name);\n     src->remove(this);\n@@ -620,7 +613,7 @@ rust_task::transition(rust_task_list *src, rust_task_list *dst) {\n \n void\n rust_task::block(rust_cond *on, const char* name) {\n-    log(rust_log::TASK, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n+    LOG(this, task, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n                          (uintptr_t) on, (uintptr_t) cond);\n     A(dom, cond == NULL, \"Cannot block an already blocked task.\");\n     A(dom, on != NULL, \"Cannot block on a NULL object.\");\n@@ -633,7 +626,7 @@ rust_task::block(rust_cond *on, const char* name) {\n void\n rust_task::wakeup(rust_cond *from) {\n     A(dom, cond != NULL, \"Cannot wake up unblocked task.\");\n-    log(rust_log::TASK, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n+    LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n                         (uintptr_t) cond, (uintptr_t) from);\n     A(dom, cond == from, \"Cannot wake up blocked task on wrong condition.\");\n \n@@ -658,36 +651,22 @@ rust_crate_cache *\n rust_task::get_crate_cache(rust_crate const *curr_crate)\n {\n     if (cache && cache->crate != curr_crate) {\n-        DLOG(dom, rust_log::TASK, \"switching task crate-cache to crate 0x%\"\n-                 PRIxPTR, curr_crate);\n+        DLOG(dom, task, \"switching task crate-cache to crate 0x%\"\n+             PRIxPTR, curr_crate);\n         cache->deref();\n         cache = NULL;\n     }\n \n     if (!cache) {\n-        DLOG(dom, rust_log::TASK, \"fetching cache for current crate\");\n+        DLOG(dom, task, \"fetching cache for current crate\");\n         cache = dom->get_cache(curr_crate);\n     }\n     return cache;\n }\n \n-void\n-rust_task::log(uint32_t type_bits, char const *fmt, ...) {\n-    char buf[BUF_BYTES];\n-    if (dom->get_log().is_tracing(type_bits)) {\n-        va_list args;\n-        va_start(args, fmt);\n-        vsnprintf(buf, sizeof(buf), fmt, args);\n-        dom->get_log().trace_ln(this, type_bits, buf);\n-        va_end(args);\n-    }\n-}\n-\n void\n rust_task::backtrace() {\n-    if (!dom->get_log().is_tracing(rust_log::BT))\n-        return;\n-\n+    if (!log_rt_backtrace) return;\n #ifndef __WIN32__\n     void *call_stack[256];\n     int nframes = ::backtrace(call_stack, 256);"}, {"sha": "7d4ed22139c3b9c4cd4e2f88811de4fde0440502", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -82,8 +82,6 @@ rust_task : public maybe_proxy<rust_task>,\n     void check_active() { I(dom, dom->curr_task == this); }\n     void check_suspended() { I(dom, dom->curr_task != this); }\n \n-    void log(uint32_t type_bits, char const *fmt, ...);\n-\n     // Print a backtrace, if the \"bt\" logging option is on.\n     void backtrace();\n "}, {"sha": "bb1224afa20bf5015fee4d3959d106ec91248190", "filename": "src/rt/rust_task_list.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_task_list.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_task_list.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_list.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -7,10 +7,10 @@ rust_task_list::rust_task_list (rust_dom *dom, const char* name) :\n \n void\n rust_task_list::delete_all() {\n-    DLOG(dom, rust_log::TASK, \"deleting all %s tasks\", name);\n+    DLOG(dom, task, \"deleting all %s tasks\", name);\n     while (is_empty() == false) {\n         rust_task *task = pop_value();\n-        DLOG(dom, rust_log::TASK, \"deleting task \" PTR, task);\n+        DLOG(dom, task, \"deleting task \" PTR, task);\n         delete task;\n     }\n }"}, {"sha": "79cb1615bbc3f09fe463a0cf6ce9ff60f81e3c71", "filename": "src/rt/rust_timer.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_timer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_timer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_timer.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -30,7 +30,7 @@ timer_loop(void *ptr) {\n     // We were handed the rust_timer that owns us.\n     rust_timer *timer = (rust_timer *)ptr;\n     rust_dom *dom = timer->dom;\n-    DLOG(dom, rust_log::TIMER, \"in timer 0x%\" PRIxPTR, (uintptr_t)timer);\n+    DLOG(dom, timer, \"in timer 0x%\" PRIxPTR, (uintptr_t)timer);\n     size_t ms = TIME_SLICE_IN_MS;\n \n     while (!timer->exit_flag) {\n@@ -39,7 +39,7 @@ timer_loop(void *ptr) {\n #else\n         usleep(ms * 1000);\n #endif\n-        DLOG(dom, rust_log::TIMER, \"timer 0x%\" PRIxPTR\n+        DLOG(dom, timer, \"timer 0x%\" PRIxPTR\n         \" interrupting domain 0x%\" PRIxPTR, (uintptr_t) timer,\n                  (uintptr_t) dom);\n         dom->interrupt_flag = 1;\n@@ -54,7 +54,7 @@ timer_loop(void *ptr) {\n \n rust_timer::rust_timer(rust_dom *dom) :\n     dom(dom), exit_flag(0) {\n-    DLOG(dom, rust_log::TIMER, \"creating timer for domain 0x%\" PRIxPTR, dom);\n+    DLOG(dom, timer, \"creating timer for domain 0x%\" PRIxPTR, dom);\n #if defined(__WIN32__)\n     thread = CreateThread(NULL, 0, timer_loop, this, 0, NULL);\n     dom->win32_require(\"CreateThread\", thread != NULL);"}, {"sha": "9178aac2d305bbdc067d6528d032430cced92203", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -3,20 +3,19 @@\n // Upcalls.\n \n #ifdef __GNUC__\n-#define LOG_UPCALL_ENTRY(task)                              \\\n-    LOG_I(task, rust_log::UPCALL,                           \\\n-          \"> UPCALL %s - task: %s 0x%\" PRIxPTR              \\\n-          \" retpc: x%\" PRIxPTR                              \\\n-          \" ref_count: %d\",                                 \\\n-          __FUNCTION__,                                     \\\n-          (task)->name, (task),                             \\\n-          __builtin_return_address(0),                      \\\n-          (task->ref_count));\n+#define LOG_UPCALL_ENTRY(task)                            \\\n+    LOG(task, upcall,                                     \\\n+        \"> UPCALL %s - task: %s 0x%\" PRIxPTR              \\\n+        \" retpc: x%\" PRIxPTR                              \\\n+        \" ref_count: %d\",                                 \\\n+        __FUNCTION__,                                     \\\n+        (task)->name, (task),                             \\\n+        __builtin_return_address(0),                      \\\n+        (task->ref_count));\n #else\n-#define LOG_UPCALL_ENTRY(task)                              \\\n-    LOG_I(task, rust_log::UPCALL,                           \\\n-          \"> UPCALL task: %s @x%\" PRIxPTR,                  \\\n-          (task)->name, (task));\n+#define LOG_UPCALL_ENTRY(task)                            \\\n+    LOG(task, upcall, \"> UPCALL task: %s @x%\" PRIxPTR,    \\\n+        (task)->name, (task));\n #endif\n \n extern \"C\" CDECL char const *\n@@ -29,61 +28,78 @@ upcall_grow_task(rust_task *task, size_t n_frame_bytes) {\n }\n \n extern \"C\" CDECL\n-void upcall_log_int(rust_task *task, int32_t level, int32_t i) {\n+void upcall_log_int(rust_task *task, uint32_t level, int32_t i) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::ULOG,\n-        \"rust: %\" PRId32 \" (0x%\" PRIx32 \")\", i, i);\n+    if (task->dom->log_lvl >= level)\n+        task->dom->log(task, level, \"rust: %\" PRId32 \" (0x%\" PRIx32 \")\",\n+                       i, i);\n }\n \n extern \"C\" CDECL\n-void upcall_log_float(rust_task *task, int32_t level, float f) {\n+void upcall_log_int_rustboot(rust_task *task, uint32_t level, int32_t i) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::ULOG,\n-        \"rust: %12.12f\", f);\n+    if (task->dom->log_lvl >= level && log_rustboot >= level)\n+        task->dom->log(task, level, \"rust: %\" PRId32 \" (0x%\" PRIx32 \")\",\n+                       i, i);\n }\n \n extern \"C\" CDECL\n-void upcall_log_double(rust_task *task, int32_t level, double *f) {\n+void upcall_log_float(rust_task *task, uint32_t level, float f) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::ULOG,\n-              \"rust: %12.12f\", *f);\n+    if (task->dom->log_lvl >= level)\n+        task->dom->log(task, level, \"rust: %12.12f\", f);\n+}\n+\n+extern \"C\" CDECL\n+void upcall_log_double(rust_task *task, uint32_t level, double *f) {\n+    LOG_UPCALL_ENTRY(task);\n+    if (task->dom->log_lvl >= level)\n+        task->dom->log(task, level, \"rust: %12.12f\", *f);\n }\n \n extern \"C\" CDECL void\n-upcall_log_str(rust_task *task, int32_t level, rust_str *str) {\n+upcall_log_str_rustboot(rust_task *task, uint32_t level, rust_str *str) {\n     LOG_UPCALL_ENTRY(task);\n-    const char *c = str_buf(task, str);\n-    LOG(task, rust_log::UPCALL | rust_log::ULOG, \"rust: %s\", c);\n+    if (task->dom->log_lvl >= level && log_rustboot >= level) {\n+        const char *c = str_buf(task, str);\n+        task->dom->log(task, level, \"rust: %s\", c);\n+    }\n+}\n+\n+extern \"C\" CDECL void\n+upcall_log_str(rust_task *task, uint32_t level, rust_str *str) {\n+    LOG_UPCALL_ENTRY(task);\n+    if (task->dom->log_lvl >= level) {\n+        const char *c = str_buf(task, str);\n+        task->dom->log(task, level, \"rust: %s\", c);\n+    }\n }\n \n extern \"C\" CDECL void\n upcall_trace_word(rust_task *task, uintptr_t i) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::TRACE, \"trace: 0x%\" PRIxPTR \"\", i,\n-              i, (char) i);\n+    task->dom->log(task, 2, \"trace: 0x%\" PRIxPTR \"\", i, i, (char) i);\n }\n \n extern \"C\" CDECL void\n upcall_trace_str(rust_task *task, char const *c) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::TRACE, \"trace: %s\", c);\n+    task->dom->log(task, 2, \"trace: %s\", c);\n }\n \n extern \"C\" CDECL rust_port*\n upcall_new_port(rust_task *task, size_t unit_sz) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n-              \"upcall_new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n-              (uintptr_t) task, task->name, unit_sz);\n+    LOG(task, comm, \"upcall_new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n+        (uintptr_t) task, task->name, unit_sz);\n     return new (dom) rust_port(task, unit_sz);\n }\n \n extern \"C\" CDECL void\n upcall_del_port(rust_task *task, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n-              \"upcall del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n+    LOG(task, comm, \"upcall del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n     I(task->dom, !port->ref_count);\n     delete port;\n }\n@@ -95,10 +111,9 @@ extern \"C\" CDECL rust_chan*\n upcall_new_chan(rust_task *task, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n-              \"upcall_new_chan(\"\n-              \"task=0x%\" PRIxPTR \" (%s), port=0x%\" PRIxPTR \")\",\n-              (uintptr_t) task, task->name, port);\n+    LOG(task, comm, \"upcall_new_chan(\"\n+        \"task=0x%\" PRIxPTR \" (%s), port=0x%\" PRIxPTR \")\",\n+        (uintptr_t) task, task->name, port);\n     I(dom, port);\n     return new (dom) rust_chan(task, port, port->unit_sz);\n }\n@@ -124,8 +139,7 @@ extern \"C\" CDECL\n void upcall_del_chan(rust_task *task, rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n \n-    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n-              \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n+    LOG(task, comm, \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n \n     A(task->dom, chan->ref_count == 0,\n       \"Channel's ref count should be zero.\");\n@@ -175,7 +189,7 @@ upcall_clone_chan(rust_task *task, maybe_proxy<rust_task> *target,\n         rust_handle<rust_port> *handle =\n             task->dom->kernel->get_port_handle(port->as_referent());\n         maybe_proxy<rust_port> *proxy = new rust_proxy<rust_port> (handle);\n-        LOG(task, rust_log::MEM, \"new proxy: \" PTR, proxy);\n+        LOG(task, mem, \"new proxy: \" PTR, proxy);\n         port = proxy;\n         target_task = target->as_proxy()->handle()->referent();\n     }\n@@ -185,16 +199,16 @@ upcall_clone_chan(rust_task *task, maybe_proxy<rust_task> *target,\n extern \"C\" CDECL void\n upcall_yield(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::COMM, \"upcall yield()\");\n+    LOG(task, comm, \"upcall yield()\");\n     task->yield(1);\n }\n \n extern \"C\" CDECL void\n upcall_sleep(rust_task *task, size_t time_in_us) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::TASK, \"elapsed %d\",\n+    LOG(task, task, \"elapsed %d\",\n               task->yield_timer.get_elapsed_time());\n-    LOG(task, rust_log::UPCALL | rust_log::TASK, \"sleep %d us\", time_in_us);\n+    LOG(task, task, \"sleep %d us\", time_in_us);\n     task->yield(2, time_in_us);\n }\n \n@@ -228,17 +242,16 @@ extern \"C\" CDECL void\n upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n     LOG_UPCALL_ENTRY(task);\n     chan->send(sptr);\n-    LOG(task, rust_log::COMM, \"=== sent data ===>\");\n+    LOG(task, comm, \"=== sent data ===>\");\n }\n \n extern \"C\" CDECL void\n upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::COMM,\n-              \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n-              \", size: 0x%\" PRIxPTR \", chan_no: %d\",\n-              (uintptr_t) port, (uintptr_t) dptr, port->unit_sz,\n-              port->chans.length());\n+    LOG(task, comm, \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n+        \", size: 0x%\" PRIxPTR \", chan_no: %d\",\n+        (uintptr_t) port, (uintptr_t) dptr, port->unit_sz,\n+        port->chans.length());\n \n     if (port->receive(dptr)) {\n         return;\n@@ -248,7 +261,7 @@ upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n     // on the port. Remember the rendezvous location so that any sender\n     // task can write to it before waking up this task.\n \n-    LOG(task, rust_log::COMM, \"<=== waiting for rendezvous data ===\");\n+    LOG(task, comm, \"<=== waiting for rendezvous data ===\");\n     task->rendezvous_ptr = dptr;\n     task->block(port, \"waiting for rendezvous data\");\n     task->yield(3);\n@@ -260,8 +273,7 @@ upcall_fail(rust_task *task,\n             char const *file,\n             size_t line) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::ERR,\n-              \"upcall fail '%s', %s:%\" PRIdPTR, expr, file, line);\n+    LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR, expr, file, line);\n     task->fail(4);\n     if (getenv(\"RUST_TRAP_FAILURE\")) {\n         // FIXME: x86-ism.\n@@ -292,8 +304,7 @@ upcall_kill(rust_task *task, maybe_proxy<rust_task> *target) {\n extern \"C\" CDECL void\n upcall_exit(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::TASK,\n-              \"task ref_count: %d\", task->ref_count);\n+    LOG(task, task, \"task ref_count: %d\", task->ref_count);\n     A(task->dom, task->ref_count >= 0,\n       \"Task ref_count should not be negative on exit!\");\n     task->die();\n@@ -305,12 +316,12 @@ extern \"C\" CDECL uintptr_t\n upcall_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n     LOG_UPCALL_ENTRY(task);\n \n-    LOG(task, rust_log::UPCALL|rust_log::MEM,\n+    LOG(task, mem,\n                    \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\"\n                    \" with gc-chain head = 0x%\" PRIxPTR,\n                    nbytes, td, task->gc_alloc_chain);\n     void *p = task->malloc(nbytes, td);\n-    LOG(task, rust_log::UPCALL|rust_log::MEM,\n+    LOG(task, mem,\n                    \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n                    \") = 0x%\" PRIxPTR\n                    \" with gc-chain head = 0x%\" PRIxPTR,\n@@ -325,7 +336,7 @@ extern \"C\" CDECL void\n upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    DLOG(dom, rust_log::UPCALL|rust_log::MEM,\n+    DLOG(dom, mem,\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n              (uintptr_t)ptr, is_gc);\n     task->free(ptr, (bool) is_gc);\n@@ -339,8 +350,7 @@ upcall_mark(rust_task *task, void* ptr) {\n     if (ptr) {\n         gc_alloc *gcm = (gc_alloc*) (((char*)ptr) - sizeof(gc_alloc));\n         uintptr_t marked = (uintptr_t) gcm->mark();\n-        DLOG(dom, rust_log::UPCALL|rust_log::MEM|rust_log::GC,\n-                 \"upcall mark(0x%\" PRIxPTR \") = %\" PRIdPTR,\n+        DLOG(dom, gc, \"upcall mark(0x%\" PRIxPTR \") = %\" PRIdPTR,\n                  (uintptr_t)gcm, marked);\n         return marked;\n     }\n@@ -358,27 +368,25 @@ upcall_new_str(rust_task *task, char const *s, size_t fill) {\n         return NULL;\n     }\n     rust_str *st = new (mem) rust_str(dom, alloc, fill, (uint8_t const *) s);\n-    LOG(task, rust_log::UPCALL | rust_log::MEM,\n-              \"upcall new_str('%s', %\" PRIdPTR \") = 0x%\" PRIxPTR,\n-              s, fill, st);\n+    LOG(task, mem,\n+        \"upcall new_str('%s', %\" PRIdPTR \") = 0x%\" PRIxPTR,\n+        s, fill, st);\n     return st;\n }\n \n extern \"C\" CDECL rust_vec *\n upcall_new_vec(rust_task *task, size_t fill, type_desc *td) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    DLOG(dom, rust_log::UPCALL|rust_log::MEM,\n-             \"upcall new_vec(%\" PRIdPTR \")\",\n-             fill);\n+    DLOG(dom, mem, \"upcall new_vec(%\" PRIdPTR \")\", fill);\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + fill);\n     void *mem = task->malloc(alloc, td);\n     if (!mem) {\n         task->fail(3);\n         return NULL;\n     }\n     rust_vec *v = new (mem) rust_vec(dom, alloc, 0, NULL);\n-    LOG(task, rust_log::UPCALL | rust_log::MEM,\n+    LOG(task, mem,\n               \"upcall new_vec(%\" PRIdPTR \") = 0x%\" PRIxPTR, fill, v);\n     return v;\n }\n@@ -392,7 +400,7 @@ upcall_vec_grow(rust_task *task,\n {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    LOG(task, rust_log::UPCALL | rust_log::MEM,\n+    LOG(task, mem,\n               \"upcall vec_grow(0x%\" PRIxPTR \", %\" PRIdPTR\n               \"), alloc=%\" PRIdPTR \", fill=%\" PRIdPTR\n               \", need_copy=0x%\" PRIxPTR,\n@@ -405,12 +413,12 @@ upcall_vec_grow(rust_task *task,\n \n         // Fastest path: already large enough.\n         if (v->alloc >= alloc) {\n-            LOG(task, rust_log::UPCALL | rust_log::MEM, \"no-growth path\");\n+            LOG(task, mem, \"no-growth path\");\n             return v;\n         }\n \n         // Second-fastest path: can at least realloc.\n-        LOG(task, rust_log::UPCALL | rust_log::MEM, \"realloc path\");\n+        LOG(task, mem, \"realloc path\");\n         v = (rust_vec*) task->realloc(v, alloc, td->is_stateful);\n         if (!v) {\n             task->fail(4);\n@@ -432,7 +440,7 @@ upcall_vec_grow(rust_task *task,\n          * need_copy outparam flag to indicate to our caller (vec-copy glue)\n          * that we need the copies performed for us.\n          */\n-        LOG(task, rust_log::UPCALL | rust_log::MEM, \"new vec path\");\n+        LOG(task, mem, \"new vec path\");\n         void *mem = task->malloc(alloc, td);\n         if (!mem) {\n             task->fail(4);\n@@ -472,36 +480,32 @@ upcall_require_rust_sym(rust_task *task,\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n \n-    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n-              \"upcall require rust sym: lib #%\" PRIdPTR\n-              \" = %s, c_sym #%\" PRIdPTR\n-              \", rust_sym #%\" PRIdPTR\n-              \", curr_crate = 0x%\" PRIxPTR, lib_num, library, c_sym_num,\n-              rust_sym_num, curr_crate);\n+    LOG(task, cache, \"upcall require rust sym: lib #%\" PRIdPTR\n+        \" = %s, c_sym #%\" PRIdPTR\n+        \", rust_sym #%\" PRIdPTR\n+        \", curr_crate = 0x%\" PRIxPTR, lib_num, library, c_sym_num,\n+        rust_sym_num, curr_crate);\n     for (char const **c = crate_rel(curr_crate, path); *c; ++c) {\n-        LOG(task, rust_log::UPCALL, \" + %s\", crate_rel(curr_crate, *c));\n+        LOG(task, upcall, \" + %s\", crate_rel(curr_crate, *c));\n     }\n \n-    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n-              \"require C symbol 'rust_crate' from lib #%\" PRIdPTR, lib_num);\n+    LOG(task, cache, \"require C symbol 'rust_crate' from lib #%\" PRIdPTR,\n+        lib_num);\n     rust_crate_cache::c_sym *c =\n             fetch_c_sym(task, curr_crate, lib_num, c_sym_num, library,\n                         \"rust_crate\");\n \n-    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n-              \"require rust symbol inside crate\");\n+    LOG(task, cache, \"require rust symbol inside crate\");\n     rust_crate_cache::rust_sym *s = task->cache->get_rust_sym(rust_sym_num,\n                                                               dom,\n                                                               curr_crate, c,\n                                                               path);\n \n     uintptr_t addr = s->get_val();\n     if (addr) {\n-        LOG(task, rust_log::UPCALL | rust_log::CACHE,\n-                  \"found-or-cached addr: 0x%\" PRIxPTR, addr);\n+        LOG(task, cache, \"found-or-cached addr: 0x%\" PRIxPTR, addr);\n     } else {\n-        LOG(task, rust_log::UPCALL | rust_log::CACHE | rust_log::ERR,\n-                  \"failed to resolve symbol\");\n+        LOG_ERR(task, cache, \"failed to resolve symbol\");\n         task->fail(7);\n     }\n     return addr;\n@@ -516,23 +520,22 @@ upcall_require_c_sym(rust_task *task,\n                      char const *symbol) {\n     LOG_UPCALL_ENTRY(task);\n \n-    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n-              \"upcall require c sym: lib #%\" PRIdPTR\n-              \" = %s, c_sym #%\" PRIdPTR\n-              \" = %s\"\n-              \", curr_crate = 0x%\" PRIxPTR, lib_num, library, c_sym_num,\n-              symbol, curr_crate);\n+    LOG(task, cache, \"upcall require c sym: lib #%\" PRIdPTR\n+        \" = %s, c_sym #%\" PRIdPTR\n+        \" = %s\"\n+        \", curr_crate = 0x%\" PRIxPTR, lib_num, library, c_sym_num,\n+        symbol, curr_crate);\n \n     rust_crate_cache::c_sym *c = fetch_c_sym(task, curr_crate, lib_num,\n                                              c_sym_num, library, symbol);\n \n     uintptr_t addr = c->get_val();\n     if (addr) {\n-        LOG(task, rust_log::UPCALL | rust_log::CACHE,\n+        LOG(task, cache,\n                   \"found-or-cached addr: 0x%\" PRIxPTR, addr);\n     } else {\n-        LOG(task, rust_log::UPCALL | rust_log::CACHE | rust_log::ERR,\n-                  \"failed to resolve symbol %s in %s\", symbol, library);\n+        LOG_ERR(task, cache, \"failed to resolve symbol %s in %s\",\n+                symbol, library);\n         task->fail(6);\n     }\n     return addr;\n@@ -546,14 +549,12 @@ upcall_get_type_desc(rust_task *task,\n                      size_t n_descs,\n                      type_desc const **descs) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n-              \"upcall get_type_desc with size=%\" PRIdPTR\n-              \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\", size, align,\n-              n_descs);\n+    LOG(task, cache, \"upcall get_type_desc with size=%\" PRIdPTR\n+        \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\", size, align,\n+        n_descs);\n     rust_crate_cache *cache = task->get_crate_cache(curr_crate);\n     type_desc *td = cache->get_type_desc(size, align, n_descs, descs);\n-    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n-              \"returning tydesc 0x%\" PRIxPTR, td);\n+    LOG(task, cache, \"returning tydesc 0x%\" PRIxPTR, td);\n     return td;\n }\n \n@@ -575,7 +576,7 @@ upcall_start_task(rust_task *spawner,\n     LOG_UPCALL_ENTRY(spawner);\n \n     rust_dom *dom = spawner->dom;\n-    DLOG(dom, rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n+    DLOG(dom, task,\n              \"upcall start_task(task %s @0x%\" PRIxPTR\n              \" exit_task_glue 0x%\" PRIxPTR\n              \", spawnee 0x%\" PRIxPTR\n@@ -598,10 +599,9 @@ upcall_new_thread(rust_task *task, const char *name) {\n         kernel->create_domain(parent_dom->root_crate, name);\n     rust_handle<rust_task> *child_task_handle =\n         kernel->get_task_handle(child_dom_handle->referent()->root_task);\n-    LOG(task, rust_log::UPCALL | rust_log::MEM,\n-              \"child name: %s, child_dom_handle: \" PTR\n-              \", child_task_handle: \" PTR,\n-              name, child_dom_handle, child_task_handle);\n+    LOG(task, mem, \"child name: %s, child_dom_handle: \" PTR\n+        \", child_task_handle: \" PTR,\n+        name, child_dom_handle, child_task_handle);\n     rust_proxy<rust_task> *child_task_proxy =\n         new rust_proxy<rust_task> (child_task_handle);\n     return child_task_proxy;\n@@ -641,7 +641,7 @@ upcall_start_thread(rust_task *task,\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *parenet_dom = task->dom;\n     rust_handle<rust_task> *child_task_handle = child_task_proxy->handle();\n-    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n+    LOG(task, task,\n               \"exit_task_glue: \" PTR \", spawnee_fn \" PTR\n               \", callsz %\" PRIdPTR \")\",\n               exit_task_glue, spawnee_fn, callsz);"}, {"sha": "8e4bf26c4743999006380edf6635f0b2b848bdea", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/880be6a94013ba0b7791b0ca1b6e16104f2f0a1c/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=880be6a94013ba0b7791b0ca1b6e16104f2f0a1c", "patch": "@@ -24,18 +24,16 @@ ptr_vec<T>::ptr_vec(rust_dom *dom) :\n     data(new (dom) T*[alloc])\n {\n     I(dom, data);\n-    DLOG(dom, rust_log::MEM,\n-             \"new ptr_vec(data=0x%\" PRIxPTR \") -> 0x%\" PRIxPTR,\n-             (uintptr_t)data, (uintptr_t)this);\n+    DLOG(dom, mem, \"new ptr_vec(data=0x%\" PRIxPTR \") -> 0x%\" PRIxPTR,\n+         (uintptr_t)data, (uintptr_t)this);\n }\n \n template <typename T>\n ptr_vec<T>::~ptr_vec()\n {\n     I(dom, data);\n-    DLOG(dom, rust_log::MEM,\n-             \"~ptr_vec 0x%\" PRIxPTR \", data=0x%\" PRIxPTR,\n-             (uintptr_t)this, (uintptr_t)data);\n+    DLOG(dom, mem, \"~ptr_vec 0x%\" PRIxPTR \", data=0x%\" PRIxPTR,\n+         (uintptr_t)this, (uintptr_t)data);\n     I(dom, fill == 0);\n     dom->free(data);\n }"}]}