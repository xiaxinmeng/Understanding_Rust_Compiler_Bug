{"sha": "478cbb42b730ba4739351b72ce2aa928e78e2f81", "node_id": "C_kwDOAAsO6NoAKDQ3OGNiYjQyYjczMGJhNDczOTM1MWI3MmNlMmFhOTI4ZTc4ZTJmODE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-28T15:18:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-28T15:18:16Z"}, "message": "Auto merge of #109692 - Nilstrieb:rollup-hq65rps, r=Nilstrieb\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #91793 (socket ancillary data implementation for FreeBSD (from 13 and above).)\n - #92284 (Change advance(_back)_by to return the remainder instead of the number of processed elements)\n - #102472 (stop special-casing `'static` in evaluation)\n - #108480 (Use Rayon's TLV directly)\n - #109321 (Erase impl regions when checking for impossible to eagerly monomorphize items)\n - #109470 (Correctly substitute GAT's type used in `normalize_param_env` in `check_type_bounds`)\n - #109562 (Update ar_archive_writer to 0.1.3)\n - #109629 (remove obsolete `givens` from regionck)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "bf25c6aa92d6d0ad61724051f4404c237df72d71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf25c6aa92d6d0ad61724051f4404c237df72d71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/478cbb42b730ba4739351b72ce2aa928e78e2f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/478cbb42b730ba4739351b72ce2aa928e78e2f81", "html_url": "https://github.com/rust-lang/rust/commit/478cbb42b730ba4739351b72ce2aa928e78e2f81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/478cbb42b730ba4739351b72ce2aa928e78e2f81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "html_url": "https://github.com/rust-lang/rust/commit/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10"}, {"sha": "60ce19d848682b10543934229750cf30ef7af8a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/60ce19d848682b10543934229750cf30ef7af8a6", "html_url": "https://github.com/rust-lang/rust/commit/60ce19d848682b10543934229750cf30ef7af8a6"}], "stats": {"total": 1762, "additions": 1014, "deletions": 748}, "files": [{"sha": "f0507c873d52d415289a4607553f08daac81040c", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -106,11 +106,11 @@ checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n [[package]]\n name = \"ar_archive_writer\"\n-version = \"0.1.1\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"276881980556fdadeb88aa1ffc667e4d2e8fe72531dfabcb7a82bb3c9ea9ba31\"\n+checksum = \"b0639441fd17a3197d1cbca8dc8768cc172a63b64b4bb6c372e8f41ed0acc9bb\"\n dependencies = [\n- \"object 0.29.0\",\n+ \"object 0.30.1\",\n ]\n \n [[package]]\n@@ -2689,9 +2689,9 @@ checksum = \"ce23b50ad8242c51a442f3ff322d56b02f08852c77e4c0b4d3fd684abc89c683\"\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.9.2\"\n+version = \"1.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\n+checksum = \"bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown 0.12.3\",\n@@ -4160,21 +4160,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-rayon\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1a79f0b0b2609e2eacf9758013f50e7176cb4b29fd6436a747b14a5362c8727a\"\n+checksum = \"eb81aadc8837ca6ecebe0fe1353f15df83b3b3cc2cf7a8afd571bc22aa121710\"\n dependencies = [\n- \"autocfg\",\n- \"crossbeam-deque\",\n  \"either\",\n  \"rustc-rayon-core\",\n ]\n \n [[package]]\n name = \"rustc-rayon-core\"\n-version = \"0.4.1\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"02269144a0db9bb55cf5d4a41a5a0e95b334b0b78b08269018ca9b0250718c30\"\n+checksum = \"67668daaf00e359c126f6dcb40d652d89b458a008c8afa727a42a2d20fca0b7f\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"crossbeam-deque\","}, {"sha": "87e4ac2660579dd20595bd721021326b7a601101", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -235,9 +235,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.9.2\"\n+version = \"1.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\n+checksum = \"bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\","}, {"sha": "5dadcaaec42ce718a278a967cf4290b320d278fb", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -25,7 +25,7 @@ target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n-indexmap = \"1.9.1\"\n+indexmap = \"1.9.3\"\n libloading = { version = \"0.7.3\", optional = true }\n once_cell = \"1.10.0\"\n smallvec = \"1.8.1\""}, {"sha": "12da21dc47772bef572cc1e0f2ff4c60372dc897", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -110,7 +110,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n         // FIXME use ArArchiveBuilder on most targets again once reading thin archives is\n         // implemented\n-        if true || sess.target.arch == \"wasm32\" || sess.target.arch == \"wasm64\" {\n+        if true {\n             Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n         } else {\n             Box::new(ArArchiveBuilder::new(sess, get_llvm_object_symbols))"}, {"sha": "0b2b03da2080a72173290a19ea5e4cbb5d96e117", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -10,12 +10,12 @@ arrayvec = { version = \"0.7\", default-features = false }\n bitflags = \"1.2.1\"\n cfg-if = \"1.0\"\n ena = \"0.14.2\"\n-indexmap = { version = \"1.9.1\" }\n+indexmap = { version = \"1.9.3\" }\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n libc = \"0.2\"\n measureme = \"10.0.0\"\n-rayon-core = { version = \"0.4.0\", package = \"rustc-rayon-core\", optional = true }\n-rayon = { version = \"0.4.0\", package = \"rustc-rayon\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n+rustc-rayon = { version = \"0.5.0\", optional = true }\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc-hash = \"1.1.0\"\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n@@ -51,4 +51,4 @@ features = [\n memmap2 = \"0.2.1\"\n \n [features]\n-rustc_use_parallel_compiler = [\"indexmap/rustc-rayon\", \"rayon\", \"rayon-core\"]\n+rustc_use_parallel_compiler = [\"indexmap/rustc-rayon\", \"rustc-rayon\", \"rustc-rayon-core\"]"}, {"sha": "2d509a114ad2e2272108700e5d8bf4aa81d2a0a5", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 51, "deletions": 57, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -330,7 +330,6 @@ fn compare_method_predicate_entailment<'tcx>(\n     // lifetime parameters.\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n     infcx.process_registered_region_obligations(\n@@ -727,7 +726,6 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     // lifetime parameters.\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n     infcx\n@@ -1876,14 +1874,17 @@ pub(super) fn check_type_bounds<'tcx>(\n     impl_ty: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n+    let param_env = tcx.param_env(impl_ty.def_id);\n+    let container_id = impl_ty.container_id(tcx);\n     // Given\n     //\n     // impl<A, B> Foo<u32> for (A, B) {\n-    //     type Bar<C> =...\n+    //     type Bar<C> = Wrapper<A, B, C>\n     // }\n     //\n     // - `impl_trait_ref` would be `<(A, B) as Foo<u32>>`\n-    // - `impl_ty_substs` would be `[A, B, ^0.0]` (`^0.0` here is the bound var with db 0 and index 0)\n+    // - `normalize_impl_ty_substs` would be `[A, B, ^0.0]` (`^0.0` here is the bound var with db 0 and index 0)\n+    // - `normalize_impl_ty` would be `Wrapper<A, B, ^0.0>`\n     // - `rebased_substs` would be `[(A, B), u32, ^0.0]`, combining the substs from\n     //    the *trait* with the generic associated type parameters (as bound vars).\n     //\n@@ -1912,56 +1913,46 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Member<C: Eq> = .... That type would fail a well-formedness check that we ought to be doing\n     // elsewhere, which would check that any <T as Family>::Member<X> meets the bounds declared in\n     // the trait (notably, that X: Eq and T: Family).\n-    let defs: &ty::Generics = tcx.generics_of(impl_ty.def_id);\n-    let mut substs = smallvec::SmallVec::with_capacity(defs.count());\n-    if let Some(def_id) = defs.parent {\n-        let parent_defs = tcx.generics_of(def_id);\n-        InternalSubsts::fill_item(&mut substs, tcx, parent_defs, &mut |param, _| {\n-            tcx.mk_param_from_def(param)\n-        });\n-    }\n     let mut bound_vars: smallvec::SmallVec<[ty::BoundVariableKind; 8]> =\n-        smallvec::SmallVec::with_capacity(defs.count());\n-    InternalSubsts::fill_single(&mut substs, defs, &mut |param, _| match param.kind {\n-        GenericParamDefKind::Type { .. } => {\n-            let kind = ty::BoundTyKind::Param(param.def_id, param.name);\n-            let bound_var = ty::BoundVariableKind::Ty(kind);\n-            bound_vars.push(bound_var);\n-            tcx.mk_bound(\n-                ty::INNERMOST,\n-                ty::BoundTy { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n-            )\n-            .into()\n-        }\n-        GenericParamDefKind::Lifetime => {\n-            let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n-            let bound_var = ty::BoundVariableKind::Region(kind);\n-            bound_vars.push(bound_var);\n-            tcx.mk_re_late_bound(\n-                ty::INNERMOST,\n-                ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n-            )\n-            .into()\n-        }\n-        GenericParamDefKind::Const { .. } => {\n-            let bound_var = ty::BoundVariableKind::Const;\n-            bound_vars.push(bound_var);\n-            tcx.mk_const(\n-                ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(bound_vars.len() - 1)),\n-                tcx.type_of(param.def_id).subst_identity(),\n-            )\n-            .into()\n-        }\n-    });\n-    let bound_vars = tcx.mk_bound_variable_kinds(&bound_vars);\n-    let impl_ty_substs = tcx.mk_substs(&substs);\n-    let container_id = impl_ty.container_id(tcx);\n-\n-    let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n-    let impl_ty_value = tcx.type_of(impl_ty.def_id).subst_identity();\n-\n-    let param_env = tcx.param_env(impl_ty.def_id);\n-\n+        smallvec::SmallVec::with_capacity(tcx.generics_of(impl_ty.def_id).params.len());\n+    // Extend the impl's identity substs with late-bound GAT vars\n+    let normalize_impl_ty_substs = ty::InternalSubsts::identity_for_item(tcx, container_id)\n+        .extend_to(tcx, impl_ty.def_id, |param, _| match param.kind {\n+            GenericParamDefKind::Type { .. } => {\n+                let kind = ty::BoundTyKind::Param(param.def_id, param.name);\n+                let bound_var = ty::BoundVariableKind::Ty(kind);\n+                bound_vars.push(bound_var);\n+                tcx.mk_bound(\n+                    ty::INNERMOST,\n+                    ty::BoundTy { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n+                )\n+                .into()\n+            }\n+            GenericParamDefKind::Lifetime => {\n+                let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n+                let bound_var = ty::BoundVariableKind::Region(kind);\n+                bound_vars.push(bound_var);\n+                tcx.mk_re_late_bound(\n+                    ty::INNERMOST,\n+                    ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n+                )\n+                .into()\n+            }\n+            GenericParamDefKind::Const { .. } => {\n+                let bound_var = ty::BoundVariableKind::Const;\n+                bound_vars.push(bound_var);\n+                tcx.mk_const(\n+                    ty::ConstKind::Bound(\n+                        ty::INNERMOST,\n+                        ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    ),\n+                    tcx.type_of(param.def_id)\n+                        .no_bound_vars()\n+                        .expect(\"const parameter types cannot be generic\"),\n+                )\n+                .into()\n+            }\n+        });\n     // When checking something like\n     //\n     // trait X { type Y: PartialEq<<Self as X>::Y> }\n@@ -1971,9 +1962,13 @@ pub(super) fn check_type_bounds<'tcx>(\n     // we want <T as X>::Y to normalize to S. This is valid because we are\n     // checking the default value specifically here. Add this equality to the\n     // ParamEnv for normalization specifically.\n+    let normalize_impl_ty = tcx.type_of(impl_ty.def_id).subst(tcx, normalize_impl_ty_substs);\n+    let rebased_substs =\n+        normalize_impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n+    let bound_vars = tcx.mk_bound_variable_kinds(&bound_vars);\n     let normalize_param_env = {\n         let mut predicates = param_env.caller_bounds().iter().collect::<Vec<_>>();\n-        match impl_ty_value.kind() {\n+        match normalize_impl_ty.kind() {\n             ty::Alias(ty::Projection, proj)\n                 if proj.def_id == trait_ty.def_id && proj.substs == rebased_substs =>\n             {\n@@ -1987,7 +1982,7 @@ pub(super) fn check_type_bounds<'tcx>(\n                 ty::Binder::bind_with_vars(\n                     ty::ProjectionPredicate {\n                         projection_ty: tcx.mk_alias_ty(trait_ty.def_id, rebased_substs),\n-                        term: impl_ty_value.into(),\n+                        term: normalize_impl_ty.into(),\n                     },\n                     bound_vars,\n                 )\n@@ -2068,8 +2063,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),"}, {"sha": "d126f7beb10f733b0fd562c36d552b6d617a2ff8", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -114,8 +114,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         return;\n     }\n \n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     let _ = infcx\n         .err_ctxt()\n@@ -675,7 +674,6 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n     );\n     let region_bound_pairs = outlives_environment.region_bound_pairs();"}, {"sha": "b5bae5788f6b2d825b5b00cb4b746a1e09654924", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -179,7 +179,7 @@ fn get_impl_substs(\n     }\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n-    let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n     let _ =\n         infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {"}, {"sha": "11ff65d0c373a2a82700a5435482b2ecbe57b872", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -238,15 +238,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Note that there are two tests to check that this remains true\n         // (`regions-reassign-{match,let}-bound-pointer.rs`).\n         //\n-        // 2. Things go horribly wrong if we use subtype. The reason for\n-        // THIS is a fairly subtle case involving bound regions. See the\n-        // `givens` field in `region_constraints`, as well as the test\n+        // 2. An outdated issue related to the old HIR borrowck. See the test\n         // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n-        // for details. Short version is that we must sometimes detect\n-        // relationships between specific region variables and regions\n-        // bound in a closure signature, and that detection gets thrown\n-        // off when we substitute fresh region variables here to enable\n-        // subtyping.\n     }\n \n     /// Compute the new expected type and default binding mode from the old ones"}, {"sha": "e98f68ae5a851b05ace2f947404f37e35dc6b97f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -640,11 +640,9 @@ pub fn make_query_region_constraints<'tcx>(\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n-    let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n-        region_constraints;\n+    let RegionConstraintData { constraints, verifys, member_constraints } = region_constraints;\n \n     assert!(verifys.is_empty());\n-    assert!(givens.is_empty());\n \n     debug!(?constraints);\n "}, {"sha": "d89f63e5c53e9641b6e2a3452a915d98723dc4b2", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -43,18 +43,16 @@ pub struct TypeFreshener<'a, 'tcx> {\n     const_freshen_count: u32,\n     ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n     const_freshen_map: FxHashMap<ty::InferConst<'tcx>, ty::Const<'tcx>>,\n-    keep_static: bool,\n }\n \n impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'tcx>, keep_static: bool) -> TypeFreshener<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'tcx>) -> TypeFreshener<'a, 'tcx> {\n         TypeFreshener {\n             infcx,\n             ty_freshen_count: 0,\n             const_freshen_count: 0,\n             ty_freshen_map: Default::default(),\n             const_freshen_map: Default::default(),\n-            keep_static,\n         }\n     }\n \n@@ -121,18 +119,9 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for TypeFreshener<'a, 'tcx> {\n             | ty::ReFree(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n+            | ty::ReStatic\n             | ty::ReError(_)\n-            | ty::ReErased => {\n-                // replace all free regions with 'erased\n-                self.interner().lifetimes.re_erased\n-            }\n-            ty::ReStatic => {\n-                if self.keep_static {\n-                    r\n-                } else {\n-                    self.interner().lifetimes.re_erased\n-                }\n-            }\n+            | ty::ReErased => self.interner().lifetimes.re_erased,\n         }\n     }\n "}, {"sha": "cf657756ff534477c967f6b8ceefcf36536c42ad", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_data_structures::intern::Interned;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::PlaceholderRegion;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -132,7 +132,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         let graph = self.construct_graph();\n-        self.expand_givens(&graph);\n         self.expansion(&mut var_data);\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n@@ -164,38 +163,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn expand_givens(&mut self, graph: &RegionGraph<'_>) {\n-        // Givens are a kind of horrible hack to account for\n-        // constraints like 'c <= '0 that are known to hold due to\n-        // closure signatures (see the comment above on the `givens`\n-        // field). They should go away. But until they do, the role\n-        // of this fn is to account for the transitive nature:\n-        //\n-        //     Given 'c <= '0\n-        //     and   '0 <= '1\n-        //     then  'c <= '1\n-\n-        let seeds: Vec<_> = self.data.givens.iter().cloned().collect();\n-        for (r, vid) in seeds {\n-            // While all things transitively reachable in the graph\n-            // from the variable (`'0` in the example above).\n-            let seed_index = NodeIndex(vid.index() as usize);\n-            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n-                let succ_index = succ_index.0;\n-\n-                // The first N nodes correspond to the region\n-                // variables. Other nodes correspond to constant\n-                // regions.\n-                if succ_index < self.num_vars() {\n-                    let succ_vid = RegionVid::new(succ_index);\n-\n-                    // Add `'c <= '1`.\n-                    self.data.givens.insert((r, succ_vid));\n-                }\n-            }\n-        }\n-    }\n-\n     /// Gets the LUb of a given region and the empty region\n     fn lub_empty(&self, a_region: Region<'tcx>) -> Result<Region<'tcx>, PlaceholderRegion> {\n         match *a_region {\n@@ -362,18 +329,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n \n-        match *a_region {\n-            // Check if this relationship is implied by a given.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                if self.data.givens.contains(&(a_region, b_vid)) {\n-                    debug!(\"given\");\n-                    return false;\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n         match *b_data {\n             VarValue::Empty(empty_ui) => {\n                 let lub = match self.lub_empty(a_region) {"}, {"sha": "9903ffa90bae1588bc724071c04c03791c3791d3", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -713,12 +713,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n \n     pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n-        freshen::TypeFreshener::new(self, false)\n-    }\n-\n-    /// Like `freshener`, but does not replace `'static` regions.\n-    pub fn freshener_keep_static<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n-        freshen::TypeFreshener::new(self, true)\n+        freshen::TypeFreshener::new(self)\n     }\n \n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n@@ -874,10 +869,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow().undo_log.opaque_types_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n-    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n-    }\n-\n     pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,"}, {"sha": "47e3dd762b08b2d6f07ce8dd0aa457bfc228ac52", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::free_regions::FreeRegionMap;\n-use crate::infer::{GenericKind, InferCtxt};\n+use crate::infer::GenericKind;\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_data_structures::transitive_relation::TransitiveRelationBuilder;\n-use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n+use rustc_middle::ty::{self, Region};\n \n use super::explicit_outlives_bounds;\n \n@@ -75,7 +75,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n             region_bound_pairs: Default::default(),\n         };\n \n-        builder.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n+        builder.add_outlives_bounds(explicit_outlives_bounds(param_env));\n \n         builder\n     }\n@@ -89,11 +89,10 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n     /// Create a new `OutlivesEnvironment` with extra outlives bounds.\n     pub fn with_bounds(\n         param_env: ty::ParamEnv<'tcx>,\n-        infcx: Option<&InferCtxt<'tcx>>,\n         extra_bounds: impl IntoIterator<Item = OutlivesBound<'tcx>>,\n     ) -> Self {\n         let mut builder = Self::builder(param_env);\n-        builder.add_outlives_bounds(infcx, extra_bounds);\n+        builder.add_outlives_bounds(extra_bounds);\n         builder.build()\n     }\n \n@@ -120,12 +119,7 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n-    ///\n-    /// The `infcx` parameter is optional; if the implied bounds may\n-    /// contain inference variables, it must be supplied, in which\n-    /// case we will register \"givens\" on the inference context. (See\n-    /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'tcx>>, outlives_bounds: I)\n+    fn add_outlives_bounds<I>(&mut self, outlives_bounds: I)\n     where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n@@ -142,27 +136,17 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n-                OutlivesBound::RegionSubRegion(r_a, r_b) => {\n-                    if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {\n-                        infcx\n-                            .expect(\"no infcx provided but region vars found\")\n-                            .add_given(r_a, vid_b);\n-                    } else {\n-                        // In principle, we could record (and take\n-                        // advantage of) every relationship here, but\n-                        // we are also free not to -- it simply means\n-                        // strictly less that we can successfully type\n-                        // check. Right now we only look for things\n-                        // relationships between free regions. (It may\n-                        // also be that we should revise our inference\n-                        // system to be more general and to make use\n-                        // of *every* relationship that arises here,\n-                        // but presently we do not.)\n-                        if r_a.is_free_or_static() && r_b.is_free() {\n-                            self.region_relation.add(r_a, r_b)\n-                        }\n-                    }\n-                }\n+                OutlivesBound::RegionSubRegion(r_a, r_b) => match (*r_a, *r_b) {\n+                    (\n+                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n+                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n+                    ) => self.region_relation.add(r_a, r_b),\n+                    (ty::ReError(_), _) | (_, ty::ReError(_)) => {}\n+                    // FIXME(#109628): We shouldn't have existential variables in implied bounds.\n+                    // Panic here once the linked issue is resolved!\n+                    (ty::ReVar(_), _) | (_, ty::ReVar(_)) => {}\n+                    _ => bug!(\"add_outlives_bounds: unexpected regions: ({r_a:?}, {r_b:?})\"),\n+                },\n             }\n         }\n     }"}, {"sha": "89ada23c6673aefeaa4ccac65e25ff748ee14a13", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -424,9 +424,6 @@ impl<'tcx> MiniGraph<'tcx> {\n                 &AddConstraint(Constraint::RegSubReg(a, b)) => {\n                     each_edge(a, b);\n                 }\n-                &AddGiven(a, b) => {\n-                    each_edge(a, tcx.mk_re_var(b));\n-                }\n                 &AddVerify(i) => span_bug!(\n                     verifys[i].origin.span(),\n                     \"we never add verifications while doing higher-ranked things\","}, {"sha": "7b272dfd2a4547f3dcba6ab063b12ca39eb816af", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 41, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -7,7 +7,7 @@ use super::{\n     InferCtxtUndoLogs, MiscVariable, RegionVariableOrigin, Rollback, Snapshot, SubregionOrigin,\n };\n \n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n@@ -104,26 +104,6 @@ pub struct RegionConstraintData<'tcx> {\n     /// An example is a `A <= B` where neither `A` nor `B` are\n     /// inference variables.\n     pub verifys: Vec<Verify<'tcx>>,\n-\n-    /// A \"given\" is a relationship that is known to hold. In\n-    /// particular, we often know from closure fn signatures that a\n-    /// particular free region must be a subregion of a region\n-    /// variable:\n-    ///\n-    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    ///\n-    /// In situations like this, `'b` is in fact a region variable\n-    /// introduced by the call to `iter()`, and `'a` is a bound region\n-    /// on the closure (as indicated by the `<'a>` prefix). If we are\n-    /// naive, we wind up inferring that `'b` must be `'static`,\n-    /// because we require that it be greater than `'a` and we do not\n-    /// know what `'a` is precisely.\n-    ///\n-    /// This hashmap is used to avoid that naive scenario. Basically\n-    /// we record the fact that `'a <= 'b` is implied by the fn\n-    /// signature, and then ignore the constraint when solving\n-    /// equations. This is a bit of a hack but seems to work.\n-    pub givens: FxIndexSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n /// Represents a constraint that influences the inference process.\n@@ -297,9 +277,6 @@ pub(crate) enum UndoLog<'tcx> {\n     /// We added the given `verify`.\n     AddVerify(usize),\n \n-    /// We added the given `given`.\n-    AddGiven(Region<'tcx>, ty::RegionVid),\n-\n     /// We added a GLB/LUB \"combination variable\".\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n }\n@@ -348,9 +325,6 @@ impl<'tcx> RegionConstraintStorage<'tcx> {\n                 self.data.verifys.pop();\n                 assert_eq!(self.data.verifys.len(), index);\n             }\n-            AddGiven(sub, sup) => {\n-                self.data.givens.remove(&(sub, sup));\n-            }\n             AddCombination(Glb, ref regions) => {\n                 self.glbs.remove(regions);\n             }\n@@ -492,15 +466,6 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.undo_log.push(AddVerify(index));\n     }\n \n-    pub(super) fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n-        // cannot add givens once regions are resolved\n-        if self.data.givens.insert((sub, sup)) {\n-            debug!(\"add_given({:?} <= {:?})\", sub, sup);\n-\n-            self.undo_log.push(AddGiven(sub, sup));\n-        }\n-    }\n-\n     pub(super) fn make_eqregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -804,11 +769,8 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     /// Returns `true` if this region constraint data contains no constraints, and `false`\n     /// otherwise.\n     pub fn is_empty(&self) -> bool {\n-        let RegionConstraintData { constraints, member_constraints, verifys, givens } = self;\n-        constraints.is_empty()\n-            && member_constraints.is_empty()\n-            && verifys.is_empty()\n-            && givens.is_empty()\n+        let RegionConstraintData { constraints, member_constraints, verifys } = self;\n+        constraints.is_empty() && member_constraints.is_empty() && verifys.is_empty()\n     }\n }\n "}, {"sha": "98d3ab87f9cbd4a60fc4d35ff8ccf7e61da31e0a", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -8,8 +8,8 @@ edition = \"2021\"\n [dependencies]\n libloading = \"0.7.1\"\n tracing = \"0.1\"\n-rustc-rayon-core = { version = \"0.4.0\", optional = true }\n-rayon = { version = \"0.4.0\", package = \"rustc-rayon\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n+rustc-rayon = { version = \"0.5.0\", optional = true }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }\n@@ -52,4 +52,4 @@ rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n \n [features]\n llvm = ['rustc_codegen_llvm']\n-rustc_use_parallel_compiler = ['rayon', 'rustc-rayon-core', 'rustc_query_impl/rustc_use_parallel_compiler', 'rustc_errors/rustc_use_parallel_compiler']\n+rustc_use_parallel_compiler = ['rustc-rayon', 'rustc-rayon-core', 'rustc_query_impl/rustc_use_parallel_compiler', 'rustc_errors/rustc_use_parallel_compiler']"}, {"sha": "612903810d21191102ff746cdc5c53c319121595", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -183,7 +183,7 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n                     .try_collect_active_jobs()\n                     .expect(\"active jobs shouldn't be locked in deadlock handler\")\n             });\n-            let registry = rustc_rayon_core::Registry::current();\n+            let registry = rayon_core::Registry::current();\n             thread::spawn(move || deadlock(query_map, &registry));\n         });\n     if let Some(size) = get_stack_size() {"}, {"sha": "5b2ec9029b16e1d87a1d261b0a5fd1000f547759", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -26,8 +26,8 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n-rustc-rayon-core = { version = \"0.4.0\", optional = true }\n-rustc-rayon = { version = \"0.4.0\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n+rustc-rayon = { version = \"0.5.0\", optional = true }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "fb0d909307e78d3d4a8ba651e8b2f930d1591988", "filename": "compiler/rustc_middle/src/ty/context/tls.rs", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -4,6 +4,8 @@ use crate::dep_graph::TaskDepsRef;\n use crate::ty::query;\n use rustc_data_structures::sync::{self, Lock};\n use rustc_errors::Diagnostic;\n+#[cfg(not(parallel_compiler))]\n+use std::cell::Cell;\n use std::mem;\n use std::ptr;\n use thin_vec::ThinVec;\n@@ -47,52 +49,15 @@ impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n     }\n }\n \n+// Import the thread-local variable from Rayon, which is preserved for Rayon jobs.\n #[cfg(parallel_compiler)]\n-mod tlv {\n-    use rustc_rayon_core as rayon_core;\n-    use std::ptr;\n-\n-    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n-    /// This is used to get the pointer to the current `ImplicitCtxt`.\n-    #[inline]\n-    pub(super) fn get_tlv() -> *const () {\n-        ptr::from_exposed_addr(rayon_core::tlv::get())\n-    }\n-\n-    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n-    /// to `value` during the call to `f`. It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[inline]\n-    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n-        rayon_core::tlv::with(value.expose_addr(), f)\n-    }\n-}\n+use rayon_core::tlv::TLV;\n \n+// Otherwise define our own\n #[cfg(not(parallel_compiler))]\n-mod tlv {\n-    use std::cell::Cell;\n-    use std::ptr;\n-\n-    thread_local! {\n-        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n-        static TLV: Cell<*const ()> = const { Cell::new(ptr::null()) };\n-    }\n-\n-    /// Gets the pointer to the current `ImplicitCtxt`.\n-    #[inline]\n-    pub(super) fn get_tlv() -> *const () {\n-        TLV.with(|tlv| tlv.get())\n-    }\n-\n-    /// Sets TLV to `value` during the call to `f`.\n-    /// It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[inline]\n-    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n-        let old = TLV.replace(value);\n-        let _reset = rustc_data_structures::OnDrop(move || TLV.set(old));\n-        f()\n-    }\n+thread_local! {\n+    /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n+    static TLV: Cell<*const ()> = const { Cell::new(ptr::null()) };\n }\n \n #[inline]\n@@ -111,7 +76,11 @@ pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) ->\n where\n     F: FnOnce() -> R,\n {\n-    tlv::with_tlv(erase(context), f)\n+    TLV.with(|tlv| {\n+        let old = tlv.replace(erase(context));\n+        let _reset = rustc_data_structures::OnDrop(move || tlv.set(old));\n+        f()\n+    })\n }\n \n /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n@@ -120,7 +89,7 @@ pub fn with_context_opt<F, R>(f: F) -> R\n where\n     F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n {\n-    let context = tlv::get_tlv();\n+    let context = TLV.get();\n     if context.is_null() {\n         f(None)\n     } else {"}, {"sha": "98265d58a0a59c0a192d03020a669faadf80642e", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1327,27 +1327,40 @@ fn create_mono_items_for_default_impls<'tcx>(\n         return;\n     }\n \n+    let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) else {\n+        return;\n+    };\n+\n+    // Lifetimes never affect trait selection, so we are allowed to eagerly\n+    // instantiate an instance of an impl method if the impl (and method,\n+    // which we check below) is only parameterized over lifetime. In that case,\n+    // we use the ReErased, which has no lifetime information associated with\n+    // it, to validate whether or not the impl is legal to instantiate at all.\n+    let only_region_params = |param: &ty::GenericParamDef, _: &_| match param.kind {\n+        GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+            unreachable!(\n+                \"`own_requires_monomorphization` check means that \\\n+                we should have no type/const params\"\n+            )\n+        }\n+    };\n+    let impl_substs = InternalSubsts::for_item(tcx, item.owner_id.to_def_id(), only_region_params);\n+    let trait_ref = trait_ref.subst(tcx, impl_substs);\n+\n     // Unlike 'lazy' monomorphization that begins by collecting items transitively\n     // called by `main` or other global items, when eagerly monomorphizing impl\n     // items, we never actually check that the predicates of this impl are satisfied\n     // in a empty reveal-all param env (i.e. with no assumptions).\n     //\n-    // Even though this impl has no substitutions, because we don't consider higher-\n-    // ranked predicates such as `for<'a> &'a mut [u8]: Copy` to be trivially false,\n-    // we must now check that the impl has no impossible-to-satisfy predicates.\n-    if tcx.subst_and_check_impossible_predicates((\n-        item.owner_id.to_def_id(),\n-        &InternalSubsts::identity_for_item(tcx, item.owner_id.to_def_id()),\n-    )) {\n+    // Even though this impl has no type or const substitutions, because we don't\n+    // consider higher-ranked predicates such as `for<'a> &'a mut [u8]: Copy` to\n+    // be trivially false. We must now check that the impl has no impossible-to-satisfy\n+    // predicates.\n+    if tcx.subst_and_check_impossible_predicates((item.owner_id.to_def_id(), impl_substs)) {\n         return;\n     }\n \n-    let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) else {\n-        return;\n-    };\n-\n-    let trait_ref = trait_ref.subst_identity();\n-\n     let param_env = ty::ParamEnv::reveal_all();\n     let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n     let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n@@ -1360,12 +1373,9 @@ fn create_mono_items_for_default_impls<'tcx>(\n             continue;\n         }\n \n-        let substs = InternalSubsts::for_item(tcx, method.def_id, |param, _| match param.kind {\n-            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-            GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                trait_ref.substs[param.index as usize]\n-            }\n-        });\n+        // As mentioned above, the method is legal to eagerly instantiate if it\n+        // only has lifetime substitutions. This is validated by\n+        let substs = trait_ref.substs.extend_to(tcx, method.def_id, only_region_params);\n         let instance = ty::Instance::expect_resolve(tcx, param_env, method.def_id, substs);\n \n         let mono_item = create_fn_mono_item(tcx, instance, DUMMY_SP);"}, {"sha": "b107a3f03fe590997589a0ae83b80f4f6ec35e1c", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -16,7 +16,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n-rustc-rayon-core = { version = \"0.4.0\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "12b4a1143136bd9a4cbf812d2b2b5445356d3d5c", "filename": "compiler/rustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2FCargo.toml?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -15,7 +15,7 @@ rustc_feature = { path = \"../rustc_feature\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n-rustc-rayon-core = { version = \"0.4.0\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "a534b54070cd0bccd155fd18bbec89c68a821926", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -18,11 +18,11 @@ use std::num::NonZeroU64;\n #[cfg(parallel_compiler)]\n use {\n     parking_lot::{Condvar, Mutex},\n+    rayon_core,\n     rustc_data_structures::fx::FxHashSet,\n     rustc_data_structures::sync::Lock,\n     rustc_data_structures::sync::Lrc,\n     rustc_data_structures::{jobserver, OnDrop},\n-    rustc_rayon_core as rayon_core,\n     rustc_span::DUMMY_SP,\n     std::iter,\n     std::process,"}, {"sha": "e4dbb8a637cea9fbc644dc1988700d69684d429c", "filename": "compiler/rustc_serialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_serialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_serialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2FCargo.toml?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n-indexmap = \"1.9.1\"\n+indexmap = \"1.9.3\"\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n thin-vec = \"0.2.12\"\n "}, {"sha": "a7c7575f392e6fdeab11daba9c47a4d4fa733e0b", "filename": "compiler/rustc_span/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_span%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_span%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2FCargo.toml?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -18,4 +18,4 @@ tracing = \"0.1\"\n sha1 = \"0.10.0\"\n sha2 = \"0.10.1\"\n md5 = { package = \"md-5\", version = \"0.10.0\" }\n-indexmap = { version = \"1.9.1\" }\n+indexmap = { version = \"1.9.3\" }"}, {"sha": "4e5e756dc4af489f262a7907b7467413b3278a9e", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -402,7 +402,6 @@ fn resolve_negative_obligation<'tcx>(\n     let wf_tys = ocx.assumed_wf_types(param_env, DUMMY_SP, body_def_id);\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, body_def_id, wf_tys),\n     );\n "}, {"sha": "0bde43c54df99892fba558fa3bef7ac282986fb5", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -111,7 +111,6 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n             // Check regions assuming the self type of the impl is WF\n             let outlives_env = OutlivesEnvironment::with_bounds(\n                 param_env,\n-                Some(&infcx),\n                 infcx.implied_bounds_tys(\n                     param_env,\n                     parent_cause.body_id,"}, {"sha": "6d2dc94845d0d6dfb0121c6dfa55c1bdb8373988", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -3,7 +3,8 @@ use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n use crate::traits::{ObligationCause, ObligationCtxt};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_middle::ty::{self, ParamEnv, Ty};\n+use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_middle::ty::{self, ParamEnv, Ty, TypeFolder, TypeVisitableExt};\n use rustc_span::def_id::LocalDefId;\n \n pub use rustc_middle::traits::query::OutlivesBound;\n@@ -52,6 +53,10 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         body_id: LocalDefId,\n         ty: Ty<'tcx>,\n     ) -> Vec<OutlivesBound<'tcx>> {\n+        let ty = self.resolve_vars_if_possible(ty);\n+        let ty = OpportunisticRegionResolver::new(self).fold_ty(ty);\n+        assert!(!ty.needs_infer());\n+\n         let span = self.tcx.def_span(body_id);\n         let result = param_env\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n@@ -106,10 +111,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         tys: FxIndexSet<Ty<'tcx>>,\n     ) -> Bounds<'a, 'tcx> {\n         tys.into_iter()\n-            .map(move |ty| {\n-                let ty = self.resolve_vars_if_possible(ty);\n-                self.implied_outlives_bounds(param_env, body_id, ty)\n-            })\n+            .map(move |ty| self.implied_outlives_bounds(param_env, body_id, ty))\n             .flatten()\n     }\n }"}, {"sha": "98c3e7c13ac6e3fba8aad3ef94a1a41300e75fc6", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 86, "deletions": 78, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -211,7 +211,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n-            freshener: infcx.freshener_keep_static(),\n+            freshener: infcx.freshener(),\n             intercrate_ambiguity_causes: None,\n             query_mode: TraitQueryMode::Standard,\n         }\n@@ -770,14 +770,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(pred)) => {\n-                    // A global type with no late-bound regions can only\n-                    // contain the \"'static\" lifetime (any other lifetime\n-                    // would either be late-bound or local), so it is guaranteed\n-                    // to outlive any other lifetime\n-                    if pred.0.is_global() && !pred.0.has_late_bound_vars() {\n-                        Ok(EvaluatedToOk)\n-                    } else {\n+                    // A global type with no free lifetimes or generic parameters\n+                    // outlives anything.\n+                    if pred.0.has_free_regions()\n+                        || pred.0.has_late_bound_regions()\n+                        || pred.0.has_non_region_infer()\n+                        || pred.0.has_non_region_infer()\n+                    {\n                         Ok(EvaluatedToOkModuloRegions)\n+                    } else {\n+                        Ok(EvaluatedToOk)\n                     }\n                 }\n \n@@ -1825,6 +1827,12 @@ enum DropVictim {\n     No,\n }\n \n+impl DropVictim {\n+    fn drop_if(should_drop: bool) -> DropVictim {\n+        if should_drop { DropVictim::Yes } else { DropVictim::No }\n+    }\n+}\n+\n /// ## Winnowing\n ///\n /// Winnowing is the process of attempting to resolve ambiguity by\n@@ -1890,11 +1898,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                     // or the current one if tied (they should both evaluate to the same answer). This is\n                     // probably best characterized as a \"hack\", since we might prefer to just do our\n                     // best to *not* create essentially duplicate candidates in the first place.\n-                    if other.bound_vars().len() <= victim.bound_vars().len() {\n-                        DropVictim::Yes\n-                    } else {\n-                        DropVictim::No\n-                    }\n+                    DropVictim::drop_if(other.bound_vars().len() <= victim.bound_vars().len())\n                 } else if other.skip_binder().trait_ref == victim.skip_binder().trait_ref\n                     && victim.skip_binder().constness == ty::BoundConstness::NotConst\n                     && other.skip_binder().polarity == victim.skip_binder().polarity\n@@ -1924,17 +1928,13 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                 | ObjectCandidate(_)\n                 | ProjectionCandidate(..),\n             ) => {\n-                if is_global(other_cand) {\n-                    DropVictim::No\n-                } else {\n-                    // We have a where clause so don't go around looking\n-                    // for impls. Arbitrarily give param candidates priority\n-                    // over projection and object candidates.\n-                    //\n-                    // Global bounds from the where clause should be ignored\n-                    // here (see issue #50825).\n-                    DropVictim::Yes\n-                }\n+                // We have a where clause so don't go around looking\n+                // for impls. Arbitrarily give param candidates priority\n+                // over projection and object candidates.\n+                //\n+                // Global bounds from the where clause should be ignored\n+                // here (see issue #50825).\n+                DropVictim::drop_if(!is_global(other_cand))\n             }\n             (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref victim_cand)) => {\n                 // Prefer these to a global where-clause bound\n@@ -1956,18 +1956,16 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n             ) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                if is_global(victim_cand) && other.evaluation.must_apply_modulo_regions() {\n-                    DropVictim::Yes\n-                } else {\n-                    DropVictim::No\n-                }\n+                DropVictim::drop_if(\n+                    is_global(victim_cand) && other.evaluation.must_apply_modulo_regions(),\n+                )\n             }\n \n             (ProjectionCandidate(i, _), ProjectionCandidate(j, _))\n             | (ObjectCandidate(i), ObjectCandidate(j)) => {\n                 // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                if i < j && !needs_infer { DropVictim::Yes } else { DropVictim::No }\n+                DropVictim::drop_if(i < j && !needs_infer)\n             }\n             (ObjectCandidate(_), ProjectionCandidate(..))\n             | (ProjectionCandidate(..), ObjectCandidate(_)) => {\n@@ -2018,55 +2016,65 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                     }\n                 }\n \n-                if other.evaluation.must_apply_considering_regions() {\n-                    match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n-                        Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n-                            // Subtle: If the predicate we are evaluating has inference\n-                            // variables, do *not* allow discarding candidates due to\n-                            // marker trait impls.\n-                            //\n-                            // Without this restriction, we could end up accidentally\n-                            // constraining inference variables based on an arbitrarily\n-                            // chosen trait impl.\n-                            //\n-                            // Imagine we have the following code:\n-                            //\n-                            // ```rust\n-                            // #[marker] trait MyTrait {}\n-                            // impl MyTrait for u8 {}\n-                            // impl MyTrait for bool {}\n-                            // ```\n-                            //\n-                            // And we are evaluating the predicate `<_#0t as MyTrait>`.\n-                            //\n-                            // During selection, we will end up with one candidate for each\n-                            // impl of `MyTrait`. If we were to discard one impl in favor\n-                            // of the other, we would be left with one candidate, causing\n-                            // us to \"successfully\" select the predicate, unifying\n-                            // _#0t with (for example) `u8`.\n-                            //\n-                            // However, we have no reason to believe that this unification\n-                            // is correct - we've essentially just picked an arbitrary\n-                            // *possibility* for _#0t, and required that this be the *only*\n-                            // possibility.\n-                            //\n-                            // Eventually, we will either:\n-                            // 1) Unify all inference variables in the predicate through\n-                            // some other means (e.g. type-checking of a function). We will\n-                            // then be in a position to drop marker trait candidates\n-                            // without constraining inference variables (since there are\n-                            // none left to constrain)\n-                            // 2) Be left with some unconstrained inference variables. We\n-                            // will then correctly report an inference error, since the\n-                            // existence of multiple marker trait impls tells us nothing\n-                            // about which one should actually apply.\n-                            if needs_infer { DropVictim::No } else { DropVictim::Yes }\n-                        }\n-                        Some(_) => DropVictim::Yes,\n-                        None => DropVictim::No,\n+                match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n+                    // For #33140 the impl headers must be exactly equal, the trait must not have\n+                    // any associated items and there are no where-clauses.\n+                    //\n+                    // We can just arbitrarily drop one of the impls.\n+                    Some(ty::ImplOverlapKind::Issue33140) => {\n+                        assert_eq!(other.evaluation, victim.evaluation);\n+                        DropVictim::Yes\n                     }\n-                } else {\n-                    DropVictim::No\n+                    // For candidates which already reference errors it doesn't really\n+                    // matter what we do \ud83e\udd37\n+                    Some(ty::ImplOverlapKind::Permitted { marker: false }) => {\n+                        DropVictim::drop_if(other.evaluation.must_apply_considering_regions())\n+                    }\n+                    Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n+                        // Subtle: If the predicate we are evaluating has inference\n+                        // variables, do *not* allow discarding candidates due to\n+                        // marker trait impls.\n+                        //\n+                        // Without this restriction, we could end up accidentally\n+                        // constraining inference variables based on an arbitrarily\n+                        // chosen trait impl.\n+                        //\n+                        // Imagine we have the following code:\n+                        //\n+                        // ```rust\n+                        // #[marker] trait MyTrait {}\n+                        // impl MyTrait for u8 {}\n+                        // impl MyTrait for bool {}\n+                        // ```\n+                        //\n+                        // And we are evaluating the predicate `<_#0t as MyTrait>`.\n+                        //\n+                        // During selection, we will end up with one candidate for each\n+                        // impl of `MyTrait`. If we were to discard one impl in favor\n+                        // of the other, we would be left with one candidate, causing\n+                        // us to \"successfully\" select the predicate, unifying\n+                        // _#0t with (for example) `u8`.\n+                        //\n+                        // However, we have no reason to believe that this unification\n+                        // is correct - we've essentially just picked an arbitrary\n+                        // *possibility* for _#0t, and required that this be the *only*\n+                        // possibility.\n+                        //\n+                        // Eventually, we will either:\n+                        // 1) Unify all inference variables in the predicate through\n+                        // some other means (e.g. type-checking of a function). We will\n+                        // then be in a position to drop marker trait candidates\n+                        // without constraining inference variables (since there are\n+                        // none left to constrain)\n+                        // 2) Be left with some unconstrained inference variables. We\n+                        // will then correctly report an inference error, since the\n+                        // existence of multiple marker trait impls tells us nothing\n+                        // about which one should actually apply.\n+                        DropVictim::drop_if(\n+                            !needs_infer && other.evaluation.must_apply_considering_regions(),\n+                        )\n+                    }\n+                    None => DropVictim::No,\n                 }\n             }\n "}, {"sha": "e2b40f7912e0f308ca57b7652b75ef5430651733", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use core::iter::{FusedIterator, TrustedLen};\n+use core::num::NonZeroUsize;\n use core::{array, fmt, mem::MaybeUninit, ops::Try, ptr};\n \n use crate::alloc::{Allocator, Global};\n@@ -54,15 +55,16 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        if self.inner.len < n {\n-            let len = self.inner.len;\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        let len = self.inner.len;\n+        let rem = if len < n {\n             self.inner.clear();\n-            Err(len)\n+            n - len\n         } else {\n             self.inner.drain(..n);\n-            Ok(())\n-        }\n+            0\n+        };\n+        NonZeroUsize::new(rem).map_or(Ok(()), Err)\n     }\n \n     #[inline]\n@@ -182,15 +184,16 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         let len = self.inner.len;\n-        if len >= n {\n-            self.inner.truncate(len - n);\n-            Ok(())\n-        } else {\n+        let rem = if len < n {\n             self.inner.clear();\n-            Err(len)\n-        }\n+            n - len\n+        } else {\n+            self.inner.truncate(len - n);\n+            0\n+        };\n+        NonZeroUsize::new(rem).map_or(Ok(()), Err)\n     }\n \n     fn try_rfold<B, F, R>(&mut self, mut init: B, mut f: F) -> R"}, {"sha": "646a2a991e701903123a96ec46cdd0755fa0cccc", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n+use core::num::NonZeroUsize;\n use core::ops::Try;\n use core::{fmt, mem, slice};\n \n@@ -55,13 +56,15 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         }\n     }\n \n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        let m = match self.i1.advance_by(n) {\n-            Ok(_) => return Ok(()),\n-            Err(m) => m,\n-        };\n-        mem::swap(&mut self.i1, &mut self.i2);\n-        self.i1.advance_by(n - m).map_err(|o| o + m)\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        let remaining = self.i1.advance_by(n);\n+        match remaining {\n+            Ok(()) => return Ok(()),\n+            Err(n) => {\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i1.advance_by(n.get())\n+            }\n+        }\n     }\n \n     #[inline]\n@@ -125,14 +128,14 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n         }\n     }\n \n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n-        let m = match self.i2.advance_back_by(n) {\n-            Ok(_) => return Ok(()),\n-            Err(m) => m,\n-        };\n-\n-        mem::swap(&mut self.i1, &mut self.i2);\n-        self.i2.advance_back_by(n - m).map_err(|o| m + o)\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        match self.i2.advance_back_by(n) {\n+            Ok(()) => return Ok(()),\n+            Err(n) => {\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i2.advance_back_by(n.get())\n+            }\n+        }\n     }\n \n     fn rfold<Acc, F>(self, accum: Acc, mut f: F) -> Acc"}, {"sha": "7defbb1090ffd682b86e2ebe1d1647ab79fa5054", "filename": "library/alloc/src/collections/vec_deque/iter_mut.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n+use core::num::NonZeroUsize;\n use core::ops::Try;\n use core::{fmt, mem, slice};\n \n@@ -47,13 +48,14 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         }\n     }\n \n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        let m = match self.i1.advance_by(n) {\n-            Ok(_) => return Ok(()),\n-            Err(m) => m,\n-        };\n-        mem::swap(&mut self.i1, &mut self.i2);\n-        self.i1.advance_by(n - m).map_err(|o| o + m)\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        match self.i1.advance_by(n) {\n+            Ok(()) => return Ok(()),\n+            Err(remaining) => {\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i1.advance_by(remaining.get())\n+            }\n+        }\n     }\n \n     #[inline]\n@@ -117,14 +119,14 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n         }\n     }\n \n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n-        let m = match self.i2.advance_back_by(n) {\n-            Ok(_) => return Ok(()),\n-            Err(m) => m,\n-        };\n-\n-        mem::swap(&mut self.i1, &mut self.i2);\n-        self.i2.advance_back_by(n - m).map_err(|o| m + o)\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        match self.i2.advance_back_by(n) {\n+            Ok(()) => return Ok(()),\n+            Err(remaining) => {\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i2.advance_back_by(remaining.get())\n+            }\n+        }\n     }\n \n     fn rfold<Acc, F>(self, accum: Acc, mut f: F) -> Acc"}, {"sha": "6a05f70e4374753a3a6254f2d21f40860bcfba85", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -11,6 +11,7 @@ use core::iter::{\n };\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit, SizedTypeProperties};\n+use core::num::NonZeroUsize;\n #[cfg(not(no_global_oom_handling))]\n use core::ops::Deref;\n use core::ptr::{self, NonNull};\n@@ -213,7 +214,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         let step_size = self.len().min(n);\n         let to_drop = ptr::slice_from_raw_parts_mut(self.ptr as *mut T, step_size);\n         if T::IS_ZST {\n@@ -227,10 +228,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         unsafe {\n             ptr::drop_in_place(to_drop);\n         }\n-        if step_size < n {\n-            return Err(step_size);\n-        }\n-        Ok(())\n+        NonZeroUsize::new(n - step_size).map_or(Ok(()), Err)\n     }\n \n     #[inline]\n@@ -313,7 +311,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         let step_size = self.len().min(n);\n         if T::IS_ZST {\n             // SAFETY: same as for advance_by()\n@@ -327,10 +325,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n         unsafe {\n             ptr::drop_in_place(to_drop);\n         }\n-        if step_size < n {\n-            return Err(step_size);\n-        }\n-        Ok(())\n+        NonZeroUsize::new(n - step_size).map_or(Ok(()), Err)\n     }\n }\n "}, {"sha": "3ee16f04e92f58fd5d734980f102cc53e8583b9d", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,7 @@\n use core::alloc::{Allocator, Layout};\n+use core::assert_eq;\n use core::iter::IntoIterator;\n+use core::num::NonZeroUsize;\n use core::ptr::NonNull;\n use std::alloc::System;\n use std::assert_matches::assert_matches;\n@@ -1062,21 +1064,21 @@ fn test_into_iter_leak() {\n \n #[test]\n fn test_into_iter_advance_by() {\n-    let mut i = [1, 2, 3, 4, 5].into_iter();\n-    i.advance_by(0).unwrap();\n-    i.advance_back_by(0).unwrap();\n+    let mut i = vec![1, 2, 3, 4, 5].into_iter();\n+    assert_eq!(i.advance_by(0), Ok(()));\n+    assert_eq!(i.advance_back_by(0), Ok(()));\n     assert_eq!(i.as_slice(), [1, 2, 3, 4, 5]);\n \n-    i.advance_by(1).unwrap();\n-    i.advance_back_by(1).unwrap();\n+    assert_eq!(i.advance_by(1), Ok(()));\n+    assert_eq!(i.advance_back_by(1), Ok(()));\n     assert_eq!(i.as_slice(), [2, 3, 4]);\n \n-    assert_eq!(i.advance_back_by(usize::MAX), Err(3));\n+    assert_eq!(i.advance_back_by(usize::MAX), Err(NonZeroUsize::new(usize::MAX - 3).unwrap()));\n \n-    assert_eq!(i.advance_by(usize::MAX), Err(0));\n+    assert_eq!(i.advance_by(usize::MAX), Err(NonZeroUsize::new(usize::MAX).unwrap()));\n \n-    i.advance_by(0).unwrap();\n-    i.advance_back_by(0).unwrap();\n+    assert_eq!(i.advance_by(0), Ok(()));\n+    assert_eq!(i.advance_back_by(0), Ok(()));\n \n     assert_eq!(i.len(), 0);\n }\n@@ -1124,7 +1126,7 @@ fn test_into_iter_zst() {\n     for _ in vec![C; 5].into_iter().rev() {}\n \n     let mut it = vec![C, C].into_iter();\n-    it.advance_by(1).unwrap();\n+    assert_eq!(it.advance_by(1), Ok(()));\n     drop(it);\n \n     let mut it = vec![C, C].into_iter();"}, {"sha": "ddc27e34ed994c7be4a86ac4f2f8f20647a2647c", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,3 +1,4 @@\n+use core::num::NonZeroUsize;\n use std::assert_matches::assert_matches;\n use std::collections::TryReserveErrorKind::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n@@ -426,6 +427,28 @@ fn test_into_iter() {\n         assert_eq!(it.next(), Some(7));\n         assert_eq!(it.size_hint(), (5, Some(5)));\n     }\n+\n+    // advance_by\n+    {\n+        let mut d = VecDeque::new();\n+        for i in 0..=4 {\n+            d.push_back(i);\n+        }\n+        for i in 6..=8 {\n+            d.push_front(i);\n+        }\n+\n+        let mut it = d.into_iter();\n+        assert_eq!(it.advance_by(1), Ok(()));\n+        assert_eq!(it.next(), Some(7));\n+        assert_eq!(it.advance_back_by(1), Ok(()));\n+        assert_eq!(it.next_back(), Some(3));\n+\n+        let mut it = VecDeque::from(vec![1, 2, 3, 4, 5]).into_iter();\n+        assert_eq!(it.advance_by(10), Err(NonZeroUsize::new(5).unwrap()));\n+        let mut it = VecDeque::from(vec![1, 2, 3, 4, 5]).into_iter();\n+        assert_eq!(it.advance_back_by(10), Err(NonZeroUsize::new(5).unwrap()));\n+    }\n }\n \n #[test]"}, {"sha": "73e2c2cfbbef6d19b7cd33ec4ee6f428d61ed1b3", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,6 @@\n //! Defines the `IntoIter` owned iterator for arrays.\n \n+use crate::num::NonZeroUsize;\n use crate::{\n     fmt,\n     iter::{self, ExactSizeIterator, FusedIterator, TrustedLen},\n@@ -284,20 +285,19 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n         self.next_back()\n     }\n \n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        let original_len = self.len();\n-\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         // This also moves the start, which marks them as conceptually \"dropped\",\n         // so if anything goes bad then our drop impl won't double-free them.\n         let range_to_drop = self.alive.take_prefix(n);\n+        let remaining = n - range_to_drop.len();\n \n         // SAFETY: These elements are currently initialized, so it's fine to drop them.\n         unsafe {\n             let slice = self.data.get_unchecked_mut(range_to_drop);\n             ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(slice));\n         }\n \n-        if n > original_len { Err(original_len) } else { Ok(()) }\n+        NonZeroUsize::new(remaining).map_or(Ok(()), Err)\n     }\n }\n \n@@ -334,20 +334,19 @@ impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N> {\n         })\n     }\n \n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n-        let original_len = self.len();\n-\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         // This also moves the end, which marks them as conceptually \"dropped\",\n         // so if anything goes bad then our drop impl won't double-free them.\n         let range_to_drop = self.alive.take_suffix(n);\n+        let remaining = n - range_to_drop.len();\n \n         // SAFETY: These elements are currently initialized, so it's fine to drop them.\n         unsafe {\n             let slice = self.data.get_unchecked_mut(range_to_drop);\n             ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(slice));\n         }\n \n-        if n > original_len { Err(original_len) } else { Ok(()) }\n+        NonZeroUsize::new(remaining).map_or(Ok(()), Err)\n     }\n }\n "}, {"sha": "4e0e19ddc78223f40a2d10f058242597d093d747", "filename": "library/core/src/iter/adapters/by_ref_sized.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,3 +1,4 @@\n+use crate::num::NonZeroUsize;\n use crate::ops::{NeverShortCircuit, Try};\n \n /// Like `Iterator::by_ref`, but requiring `Sized` so it can forward generics.\n@@ -26,7 +27,7 @@ impl<I: Iterator> Iterator for ByRefSized<'_, I> {\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         I::advance_by(self.0, n)\n     }\n \n@@ -62,7 +63,7 @@ impl<I: DoubleEndedIterator> DoubleEndedIterator for ByRefSized<'_, I> {\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         I::advance_back_by(self.0, n)\n     }\n "}, {"sha": "2046b70c9c6b43edfa8632272e86e2bfe0779665", "filename": "library/core/src/iter/adapters/chain.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use crate::iter::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n+use crate::num::NonZeroUsize;\n use crate::ops::Try;\n \n /// An iterator that links two iterators together, in a chain.\n@@ -95,38 +96,33 @@ where\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        let mut rem = n;\n-\n+    fn advance_by(&mut self, mut n: usize) -> Result<(), NonZeroUsize> {\n         if let Some(ref mut a) = self.a {\n-            match a.advance_by(rem) {\n+            n = match a.advance_by(n) {\n                 Ok(()) => return Ok(()),\n-                Err(k) => rem -= k,\n-            }\n+                Err(k) => k.get(),\n+            };\n             self.a = None;\n         }\n \n         if let Some(ref mut b) = self.b {\n-            match b.advance_by(rem) {\n-                Ok(()) => return Ok(()),\n-                Err(k) => rem -= k,\n-            }\n+            return b.advance_by(n);\n             // we don't fuse the second iterator\n         }\n \n-        if rem == 0 { Ok(()) } else { Err(n - rem) }\n+        NonZeroUsize::new(n).map_or(Ok(()), Err)\n     }\n \n     #[inline]\n     fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n         if let Some(ref mut a) = self.a {\n-            match a.advance_by(n) {\n+            n = match a.advance_by(n) {\n                 Ok(()) => match a.next() {\n-                    None => n = 0,\n+                    None => 0,\n                     x => return x,\n                 },\n-                Err(k) => n -= k,\n-            }\n+                Err(k) => k.get(),\n+            };\n \n             self.a = None;\n         }\n@@ -186,38 +182,33 @@ where\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n-        let mut rem = n;\n-\n+    fn advance_back_by(&mut self, mut n: usize) -> Result<(), NonZeroUsize> {\n         if let Some(ref mut b) = self.b {\n-            match b.advance_back_by(rem) {\n+            n = match b.advance_back_by(n) {\n                 Ok(()) => return Ok(()),\n-                Err(k) => rem -= k,\n-            }\n+                Err(k) => k.get(),\n+            };\n             self.b = None;\n         }\n \n         if let Some(ref mut a) = self.a {\n-            match a.advance_back_by(rem) {\n-                Ok(()) => return Ok(()),\n-                Err(k) => rem -= k,\n-            }\n+            return a.advance_back_by(n);\n             // we don't fuse the second iterator\n         }\n \n-        if rem == 0 { Ok(()) } else { Err(n - rem) }\n+        NonZeroUsize::new(n).map_or(Ok(()), Err)\n     }\n \n     #[inline]\n     fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n         if let Some(ref mut b) = self.b {\n-            match b.advance_back_by(n) {\n+            n = match b.advance_back_by(n) {\n                 Ok(()) => match b.next_back() {\n-                    None => n = 0,\n+                    None => 0,\n                     x => return x,\n                 },\n-                Err(k) => n -= k,\n-            }\n+                Err(k) => k.get(),\n+            };\n \n             self.b = None;\n         }"}, {"sha": "2289025d0a78087b3d864aa4cd7479b5c7b5149c", "filename": "library/core/src/iter/adapters/copied.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -4,6 +4,7 @@ use crate::iter::adapters::{\n use crate::iter::{FusedIterator, TrustedLen};\n use crate::mem::MaybeUninit;\n use crate::mem::SizedTypeProperties;\n+use crate::num::NonZeroUsize;\n use crate::ops::Try;\n use crate::{array, ptr};\n \n@@ -89,7 +90,7 @@ where\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.it.advance_by(n)\n     }\n \n@@ -130,7 +131,7 @@ where\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.it.advance_back_by(n)\n     }\n }"}, {"sha": "51bd09b6effe1ea00ba9f184466f8b3858f7e02e", "filename": "library/core/src/iter/adapters/cycle.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,3 +1,4 @@\n+use crate::num::NonZeroUsize;\n use crate::{iter::FusedIterator, ops::Try};\n \n /// An iterator that repeats endlessly.\n@@ -81,23 +82,22 @@ where\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        let mut rem = n;\n-        match self.iter.advance_by(rem) {\n-            ret @ Ok(_) => return ret,\n-            Err(advanced) => rem -= advanced,\n-        }\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        let mut n = match self.iter.advance_by(n) {\n+            Ok(()) => return Ok(()),\n+            Err(rem) => rem.get(),\n+        };\n \n-        while rem > 0 {\n+        while n > 0 {\n             self.iter = self.orig.clone();\n-            match self.iter.advance_by(rem) {\n-                ret @ Ok(_) => return ret,\n-                Err(0) => return Err(n - rem),\n-                Err(advanced) => rem -= advanced,\n-            }\n+            n = match self.iter.advance_by(n) {\n+                Ok(()) => return Ok(()),\n+                e @ Err(rem) if rem.get() == n => return e,\n+                Err(rem) => rem.get(),\n+            };\n         }\n \n-        Ok(())\n+        NonZeroUsize::new(n).map_or(Ok(()), Err)\n     }\n \n     // No `fold` override, because `fold` doesn't make much sense for `Cycle`,"}, {"sha": "479ea6d83c74e9d847585d104775f627a6a94c25", "filename": "library/core/src/iter/adapters/enumerate.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -2,6 +2,7 @@ use crate::iter::adapters::{\n     zip::try_get_unchecked, SourceIter, TrustedRandomAccess, TrustedRandomAccessNoCoerce,\n };\n use crate::iter::{FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::num::NonZeroUsize;\n use crate::ops::Try;\n \n /// An iterator that yields the current count and the element during iteration.\n@@ -114,17 +115,14 @@ where\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        match self.iter.advance_by(n) {\n-            ret @ Ok(_) => {\n-                self.count += n;\n-                ret\n-            }\n-            ret @ Err(advanced) => {\n-                self.count += advanced;\n-                ret\n-            }\n-        }\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        let remaining = self.iter.advance_by(n);\n+        let advanced = match remaining {\n+            Ok(()) => n,\n+            Err(rem) => n - rem.get(),\n+        };\n+        self.count += advanced;\n+        remaining\n     }\n \n     #[rustc_inherit_overflow_checks]\n@@ -208,7 +206,7 @@ where\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         // we do not need to update the count since that only tallies the number of items\n         // consumed from the front. consuming items from the back can never reduce that.\n         self.iter.advance_back_by(n)"}, {"sha": "e0308e3360f45a1880a779ebcc60ac0262d4dc61", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,6 @@\n use crate::fmt;\n use crate::iter::{DoubleEndedIterator, Fuse, FusedIterator, Iterator, Map, TrustedLen};\n+use crate::num::NonZeroUsize;\n use crate::ops::{ControlFlow, Try};\n \n /// An iterator that maps each element to an iterator, and yields the elements\n@@ -75,7 +76,7 @@ where\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.inner.advance_by(n)\n     }\n \n@@ -120,7 +121,7 @@ where\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.inner.advance_back_by(n)\n     }\n }\n@@ -236,7 +237,7 @@ where\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.inner.advance_by(n)\n     }\n \n@@ -281,7 +282,7 @@ where\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.inner.advance_back_by(n)\n     }\n }\n@@ -552,18 +553,18 @@ where\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n         fn advance<U: Iterator>(n: usize, iter: &mut U) -> ControlFlow<(), usize> {\n             match iter.advance_by(n) {\n                 Ok(()) => ControlFlow::Break(()),\n-                Err(advanced) => ControlFlow::Continue(n - advanced),\n+                Err(remaining) => ControlFlow::Continue(remaining.get()),\n             }\n         }\n \n         match self.iter_try_fold(n, advance) {\n-            ControlFlow::Continue(remaining) if remaining > 0 => Err(n - remaining),\n+            ControlFlow::Continue(remaining) => NonZeroUsize::new(remaining).map_or(Ok(()), Err),\n             _ => Ok(()),\n         }\n     }\n@@ -642,18 +643,18 @@ where\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n         fn advance<U: DoubleEndedIterator>(n: usize, iter: &mut U) -> ControlFlow<(), usize> {\n             match iter.advance_back_by(n) {\n                 Ok(()) => ControlFlow::Break(()),\n-                Err(advanced) => ControlFlow::Continue(n - advanced),\n+                Err(remaining) => ControlFlow::Continue(remaining.get()),\n             }\n         }\n \n         match self.iter_try_rfold(n, advance) {\n-            ControlFlow::Continue(remaining) if remaining > 0 => Err(n - remaining),\n+            ControlFlow::Continue(remaining) => NonZeroUsize::new(remaining).map_or(Ok(()), Err),\n             _ => Ok(()),\n         }\n     }"}, {"sha": "1d882087f695d9cbdef301588263fc1b4c63c630", "filename": "library/core/src/iter/adapters/rev.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use crate::iter::{FusedIterator, TrustedLen};\n+use crate::num::NonZeroUsize;\n use crate::ops::Try;\n \n /// A double-ended iterator with the direction inverted.\n@@ -38,7 +39,7 @@ where\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.iter.advance_back_by(n)\n     }\n \n@@ -83,7 +84,7 @@ where\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.iter.advance_by(n)\n     }\n "}, {"sha": "306338bc7cca0b85e2e94e98fe8832513ba0aa0a", "filename": "library/core/src/iter/adapters/skip.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,6 @@\n use crate::intrinsics::unlikely;\n use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::num::NonZeroUsize;\n use crate::ops::{ControlFlow, Try};\n \n /// An iterator that skips over `n` elements of `iter`.\n@@ -128,34 +129,27 @@ where\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        let mut rem = n;\n-        let step_one = self.n.saturating_add(rem);\n-\n-        match self.iter.advance_by(step_one) {\n-            Ok(_) => {\n-                rem -= step_one - self.n;\n-                self.n = 0;\n-            }\n-            Err(advanced) => {\n-                let advanced_without_skip = advanced.saturating_sub(self.n);\n-                self.n = self.n.saturating_sub(advanced);\n-                return if n == 0 { Ok(()) } else { Err(advanced_without_skip) };\n-            }\n-        }\n+    fn advance_by(&mut self, mut n: usize) -> Result<(), NonZeroUsize> {\n+        let skip_inner = self.n;\n+        let skip_and_advance = skip_inner.saturating_add(n);\n \n-        // step_one calculation may have saturated\n-        if unlikely(rem > 0) {\n-            return match self.iter.advance_by(rem) {\n-                ret @ Ok(_) => ret,\n-                Err(advanced) => {\n-                    rem -= advanced;\n-                    Err(n - rem)\n-                }\n-            };\n+        let remainder = match self.iter.advance_by(skip_and_advance) {\n+            Ok(()) => 0,\n+            Err(n) => n.get(),\n+        };\n+        let advanced_inner = skip_and_advance - remainder;\n+        n -= advanced_inner.saturating_sub(skip_inner);\n+        self.n = self.n.saturating_sub(advanced_inner);\n+\n+        // skip_and_advance may have saturated\n+        if unlikely(remainder == 0 && n > 0) {\n+            n = match self.iter.advance_by(n) {\n+                Ok(()) => 0,\n+                Err(n) => n.get(),\n+            }\n         }\n \n-        Ok(())\n+        NonZeroUsize::new(n).map_or(Ok(()), Err)\n     }\n }\n \n@@ -209,13 +203,11 @@ where\n     impl_fold_via_try_fold! { rfold -> try_rfold }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         let min = crate::cmp::min(self.len(), n);\n-        return match self.iter.advance_back_by(min) {\n-            ret @ Ok(_) if n <= min => ret,\n-            Ok(_) => Err(min),\n-            _ => panic!(\"ExactSizeIterator contract violation\"),\n-        };\n+        let rem = self.iter.advance_back_by(min);\n+        assert!(rem.is_ok(), \"ExactSizeIterator contract violation\");\n+        NonZeroUsize::new(n - min).map_or(Ok(()), Err)\n     }\n }\n "}, {"sha": "ce18bffe7146f9da9d34d58f28c7be62534279cb", "filename": "library/core/src/iter/adapters/take.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,6 @@\n use crate::cmp;\n use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::num::NonZeroUsize;\n use crate::ops::{ControlFlow, Try};\n \n /// An iterator that only iterates over the first `n` iterations of `iter`.\n@@ -121,18 +122,15 @@ where\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         let min = self.n.min(n);\n-        match self.iter.advance_by(min) {\n-            Ok(_) => {\n-                self.n -= min;\n-                if min < n { Err(min) } else { Ok(()) }\n-            }\n-            ret @ Err(advanced) => {\n-                self.n -= advanced;\n-                ret\n-            }\n-        }\n+        let rem = match self.iter.advance_by(min) {\n+            Ok(()) => 0,\n+            Err(rem) => rem.get(),\n+        };\n+        let advanced = min - rem;\n+        self.n -= advanced;\n+        NonZeroUsize::new(n - advanced).map_or(Ok(()), Err)\n     }\n }\n \n@@ -223,7 +221,7 @@ where\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         // The amount by which the inner iterator needs to be shortened for it to be\n         // at most as long as the take() amount.\n         let trim_inner = self.iter.len().saturating_sub(self.n);\n@@ -232,12 +230,14 @@ where\n         // about having to advance more than usize::MAX here.\n         let advance_by = trim_inner.saturating_add(n);\n \n-        let advanced = match self.iter.advance_back_by(advance_by) {\n-            Ok(_) => advance_by - trim_inner,\n-            Err(advanced) => advanced - trim_inner,\n+        let remainder = match self.iter.advance_back_by(advance_by) {\n+            Ok(()) => 0,\n+            Err(rem) => rem.get(),\n         };\n-        self.n -= advanced;\n-        return if advanced < n { Err(advanced) } else { Ok(()) };\n+        let advanced_by_inner = advance_by - remainder;\n+        let advanced_by = advanced_by_inner - trim_inner;\n+        self.n -= advanced_by;\n+        NonZeroUsize::new(n - advanced_by).map_or(Ok(()), Err)\n     }\n }\n "}, {"sha": "1cd71193bd772f693828ae8af8ca5b77857fbff1", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,6 +1,7 @@\n use crate::convert::TryFrom;\n use crate::marker::Destruct;\n use crate::mem;\n+use crate::num::NonZeroUsize;\n use crate::ops::{self, Try};\n \n use super::{\n@@ -530,12 +531,12 @@ trait RangeIteratorImpl {\n     // Iterator\n     fn spec_next(&mut self) -> Option<Self::Item>;\n     fn spec_nth(&mut self, n: usize) -> Option<Self::Item>;\n-    fn spec_advance_by(&mut self, n: usize) -> Result<(), usize>;\n+    fn spec_advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize>;\n \n     // DoubleEndedIterator\n     fn spec_next_back(&mut self) -> Option<Self::Item>;\n     fn spec_nth_back(&mut self, n: usize) -> Option<Self::Item>;\n-    fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize>;\n+    fn spec_advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize>;\n }\n \n impl<A: ~const Step + ~const Destruct> const RangeIteratorImpl for ops::Range<A> {\n@@ -567,7 +568,7 @@ impl<A: ~const Step + ~const Destruct> const RangeIteratorImpl for ops::Range<A>\n     }\n \n     #[inline]\n-    default fn spec_advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    default fn spec_advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         let available = if self.start <= self.end {\n             Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n         } else {\n@@ -579,7 +580,7 @@ impl<A: ~const Step + ~const Destruct> const RangeIteratorImpl for ops::Range<A>\n         self.start =\n             Step::forward_checked(self.start.clone(), taken).expect(\"`Step` invariants not upheld\");\n \n-        if taken < n { Err(taken) } else { Ok(()) }\n+        NonZeroUsize::new(n - taken).map_or(Ok(()), Err)\n     }\n \n     #[inline]\n@@ -608,7 +609,7 @@ impl<A: ~const Step + ~const Destruct> const RangeIteratorImpl for ops::Range<A>\n     }\n \n     #[inline]\n-    default fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    default fn spec_advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         let available = if self.start <= self.end {\n             Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n         } else {\n@@ -620,7 +621,7 @@ impl<A: ~const Step + ~const Destruct> const RangeIteratorImpl for ops::Range<A>\n         self.end =\n             Step::backward_checked(self.end.clone(), taken).expect(\"`Step` invariants not upheld\");\n \n-        if taken < n { Err(taken) } else { Ok(()) }\n+        NonZeroUsize::new(n - taken).map_or(Ok(()), Err)\n     }\n }\n \n@@ -651,7 +652,7 @@ impl<T: ~const TrustedStep + ~const Destruct> const RangeIteratorImpl for ops::R\n     }\n \n     #[inline]\n-    fn spec_advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn spec_advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         let available = if self.start <= self.end {\n             Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n         } else {\n@@ -666,7 +667,7 @@ impl<T: ~const TrustedStep + ~const Destruct> const RangeIteratorImpl for ops::R\n         // Otherwise 0 is returned which always safe to use.\n         self.start = unsafe { Step::forward_unchecked(self.start.clone(), taken) };\n \n-        if taken < n { Err(taken) } else { Ok(()) }\n+        NonZeroUsize::new(n - taken).map_or(Ok(()), Err)\n     }\n \n     #[inline]\n@@ -695,7 +696,7 @@ impl<T: ~const TrustedStep + ~const Destruct> const RangeIteratorImpl for ops::R\n     }\n \n     #[inline]\n-    fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn spec_advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         let available = if self.start <= self.end {\n             Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n         } else {\n@@ -707,7 +708,7 @@ impl<T: ~const TrustedStep + ~const Destruct> const RangeIteratorImpl for ops::R\n         // SAFETY: same as the spec_advance_by() implementation\n         self.end = unsafe { Step::backward_unchecked(self.end.clone(), taken) };\n \n-        if taken < n { Err(taken) } else { Ok(()) }\n+        NonZeroUsize::new(n - taken).map_or(Ok(()), Err)\n     }\n }\n \n@@ -757,7 +758,7 @@ impl<A: ~const Step + ~const Destruct> const Iterator for ops::Range<A> {\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.spec_advance_by(n)\n     }\n \n@@ -836,7 +837,7 @@ impl<A: ~const Step + ~const Destruct> const DoubleEndedIterator for ops::Range<\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.spec_advance_back_by(n)\n     }\n }"}, {"sha": "67051f6e97bdd42b9a3810d8094e83245f543129", "filename": "library/core/src/iter/sources/repeat.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use crate::iter::{FusedIterator, TrustedLen};\n+use crate::num::NonZeroUsize;\n \n /// Creates a new iterator that endlessly repeats a single element.\n ///\n@@ -80,7 +81,7 @@ impl<A: Clone> Iterator for Repeat<A> {\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         // Advancing an infinite iterator of a single element is a no-op.\n         let _ = n;\n         Ok(())\n@@ -109,7 +110,7 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         // Advancing an infinite iterator of a single element is a no-op.\n         let _ = n;\n         Ok(())"}, {"sha": "0b0445850bf526ed02b5a7349e954751ebdab859", "filename": "library/core/src/iter/sources/repeat_n.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,6 @@\n use crate::iter::{FusedIterator, TrustedLen};\n use crate::mem::ManuallyDrop;\n+use crate::num::NonZeroUsize;\n \n /// Creates a new iterator that repeats a single element a given number of times.\n ///\n@@ -137,15 +138,16 @@ impl<A: Clone> Iterator for RepeatN<A> {\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, skip: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, skip: usize) -> Result<(), NonZeroUsize> {\n         let len = self.count;\n \n         if skip >= len {\n             self.take_element();\n         }\n \n         if skip > len {\n-            Err(len)\n+            // SAFETY: we just checked that the difference is positive\n+            Err(unsafe { NonZeroUsize::new_unchecked(skip - len) })\n         } else {\n             self.count = len - skip;\n             Ok(())\n@@ -178,7 +180,7 @@ impl<A: Clone> DoubleEndedIterator for RepeatN<A> {\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         self.advance_by(n)\n     }\n "}, {"sha": "d82ecb698dd085abed3a72806617654221602cba", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use crate::marker::Destruct;\n+use crate::num::NonZeroUsize;\n use crate::ops::{ControlFlow, Try};\n \n /// An iterator able to yield elements from both ends.\n@@ -100,10 +101,11 @@ pub trait DoubleEndedIterator: Iterator {\n     /// eagerly skip `n` elements starting from the back by calling [`next_back`] up\n     /// to `n` times until [`None`] is encountered.\n     ///\n-    /// `advance_back_by(n)` will return [`Ok(())`] if the iterator successfully advances by\n-    /// `n` elements, or [`Err(k)`] if [`None`] is encountered, where `k` is the number of\n-    /// elements the iterator is advanced by before running out of elements (i.e. the length\n-    /// of the iterator). Note that `k` is always less than `n`.\n+    /// `advance_back_by(n)` will return `Ok(())` if the iterator successfully advances by\n+    /// `n` elements, or a `Err(NonZeroUsize)` with value `k` if [`None`] is encountered, where `k`\n+    /// is remaining number of steps that could not be advanced because the iterator ran out.\n+    /// If `self` is empty and `n` is non-zero, then this returns `Err(n)`.\n+    /// Otherwise, `k` is always less than `n`.\n     ///\n     /// Calling `advance_back_by(0)` can do meaningful work, for example [`Flatten`] can advance its\n     /// outer iterator until it finds an inner iterator that is not empty, which then often\n@@ -120,25 +122,29 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     /// #![feature(iter_advance_by)]\n     ///\n+    /// use std::num::NonZeroUsize;\n     /// let a = [3, 4, 5, 6];\n     /// let mut iter = a.iter();\n     ///\n     /// assert_eq!(iter.advance_back_by(2), Ok(()));\n     /// assert_eq!(iter.next_back(), Some(&4));\n     /// assert_eq!(iter.advance_back_by(0), Ok(()));\n-    /// assert_eq!(iter.advance_back_by(100), Err(1)); // only `&3` was skipped\n+    /// assert_eq!(iter.advance_back_by(100), Err(NonZeroUsize::new(99).unwrap())); // only `&3` was skipped\n     /// ```\n     ///\n     /// [`Ok(())`]: Ok\n     /// [`Err(k)`]: Err\n     #[inline]\n     #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"77404\")]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize>\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize>\n     where\n         Self::Item: ~const Destruct,\n     {\n         for i in 0..n {\n-            self.next_back().ok_or(i)?;\n+            if self.next_back().is_none() {\n+                // SAFETY: `i` is always less than `n`.\n+                return Err(unsafe { NonZeroUsize::new_unchecked(n - i) });\n+            }\n         }\n         Ok(())\n     }\n@@ -188,7 +194,9 @@ pub trait DoubleEndedIterator: Iterator {\n     #[stable(feature = \"iter_nth_back\", since = \"1.37.0\")]\n     #[rustc_do_not_const_check]\n     fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        self.advance_back_by(n).ok()?;\n+        if self.advance_back_by(n).is_err() {\n+            return None;\n+        }\n         self.next_back()\n     }\n \n@@ -374,7 +382,7 @@ impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n     fn next_back(&mut self) -> Option<I::Item> {\n         (**self).next_back()\n     }\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         (**self).advance_back_by(n)\n     }\n     fn nth_back(&mut self, n: usize) -> Option<I::Item> {"}, {"sha": "080330fa41ef5c177eb5ed0602c4c4759954fdf6", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,6 +1,7 @@\n use crate::array;\n use crate::cmp::{self, Ordering};\n use crate::marker::Destruct;\n+use crate::num::NonZeroUsize;\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n \n use super::super::try_process;\n@@ -308,10 +309,11 @@ pub trait Iterator {\n     /// This method will eagerly skip `n` elements by calling [`next`] up to `n`\n     /// times until [`None`] is encountered.\n     ///\n-    /// `advance_by(n)` will return [`Ok(())`][Ok] if the iterator successfully advances by\n-    /// `n` elements, or [`Err(k)`][Err] if [`None`] is encountered, where `k` is the number\n-    /// of elements the iterator is advanced by before running out of elements (i.e. the\n-    /// length of the iterator). Note that `k` is always less than `n`.\n+    /// `advance_by(n)` will return `Ok(())` if the iterator successfully advances by\n+    /// `n` elements, or a `Err(NonZeroUsize)` with value `k` if [`None`] is encountered,\n+    /// where `k` is remaining number of steps that could not be advanced because the iterator ran out.\n+    /// If `self` is empty and `n` is non-zero, then this returns `Err(n)`.\n+    /// Otherwise, `k` is always less than `n`.\n     ///\n     /// Calling `advance_by(0)` can do meaningful work, for example [`Flatten`]\n     /// can advance its outer iterator until it finds an inner iterator that is not empty, which\n@@ -327,22 +329,26 @@ pub trait Iterator {\n     /// ```\n     /// #![feature(iter_advance_by)]\n     ///\n+    /// use std::num::NonZeroUsize;\n     /// let a = [1, 2, 3, 4];\n     /// let mut iter = a.iter();\n     ///\n     /// assert_eq!(iter.advance_by(2), Ok(()));\n     /// assert_eq!(iter.next(), Some(&3));\n     /// assert_eq!(iter.advance_by(0), Ok(()));\n-    /// assert_eq!(iter.advance_by(100), Err(1)); // only `&4` was skipped\n+    /// assert_eq!(iter.advance_by(100), Err(NonZeroUsize::new(99).unwrap())); // only `&4` was skipped\n     /// ```\n     #[inline]\n     #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"77404\")]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize>\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize>\n     where\n         Self::Item: ~const Destruct,\n     {\n         for i in 0..n {\n-            self.next().ok_or(i)?;\n+            if self.next().is_none() {\n+                // SAFETY: `i` is always less than `n`.\n+                return Err(unsafe { NonZeroUsize::new_unchecked(n - i) });\n+            }\n         }\n         Ok(())\n     }\n@@ -4013,7 +4019,7 @@ impl<I: Iterator + ?Sized> Iterator for &mut I {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (**self).size_hint()\n     }\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n         (**self).advance_by(n)\n     }\n     fn nth(&mut self, n: usize) -> Option<Self::Item> {"}, {"sha": "265022a394e882fced2cc9fb899d6bc12a8c44c2", "filename": "library/core/src/ops/index_range.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,6 @@\n use crate::intrinsics::{assert_unsafe_precondition, unchecked_add, unchecked_sub};\n use crate::iter::{FusedIterator, TrustedLen};\n+use crate::num::NonZeroUsize;\n \n /// Like a `Range<usize>`, but with a safety invariant that `start <= end`.\n ///\n@@ -132,10 +133,9 @@ impl Iterator for IndexRange {\n     }\n \n     #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        let original_len = self.len();\n-        self.take_prefix(n);\n-        if n > original_len { Err(original_len) } else { Ok(()) }\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        let taken = self.take_prefix(n);\n+        NonZeroUsize::new(n - taken.len()).map_or(Ok(()), Err)\n     }\n }\n \n@@ -151,10 +151,9 @@ impl DoubleEndedIterator for IndexRange {\n     }\n \n     #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n-        let original_len = self.len();\n-        self.take_suffix(n);\n-        if n > original_len { Err(original_len) } else { Ok(()) }\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        let taken = self.take_suffix(n);\n+        NonZeroUsize::new(n - taken.len()).map_or(Ok(()), Err)\n     }\n }\n "}, {"sha": "b73e35f1e9138b5744afef54cee24073e5048694", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -176,11 +176,11 @@ macro_rules! iterator {\n             }\n \n             #[inline]\n-            fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+            fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n                 let advance = cmp::min(len!(self), n);\n                 // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                 unsafe { self.post_inc_start(advance) };\n-                if advance == n { Ok(()) } else { Err(advance) }\n+                NonZeroUsize::new(n - advance).map_or(Ok(()), Err)\n             }\n \n             #[inline]\n@@ -371,11 +371,11 @@ macro_rules! iterator {\n             }\n \n             #[inline]\n-            fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n                 let advance = cmp::min(len!(self), n);\n                 // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                 unsafe { self.pre_dec_end(advance) };\n-                if advance == n { Ok(()) } else { Err(advance) }\n+                NonZeroUsize::new(n - advance).map_or(Ok(()), Err)\n             }\n         }\n "}, {"sha": "0869644c040f5572c7222d9e3f2d04a2709dad08", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,6 @@\n-use core::array;\n+use core::{array, assert_eq};\n use core::convert::TryFrom;\n+use core::num::NonZeroUsize;\n use core::sync::atomic::{AtomicUsize, Ordering};\n \n #[test]\n@@ -557,7 +558,7 @@ fn array_intoiter_advance_by() {\n     assert_eq!(counter.get(), 13);\n \n     let r = it.advance_by(123456);\n-    assert_eq!(r, Err(87));\n+    assert_eq!(r, Err(NonZeroUsize::new(123456 - 87).unwrap()));\n     assert_eq!(it.len(), 0);\n     assert_eq!(counter.get(), 100);\n \n@@ -567,7 +568,7 @@ fn array_intoiter_advance_by() {\n     assert_eq!(counter.get(), 100);\n \n     let r = it.advance_by(10);\n-    assert_eq!(r, Err(0));\n+    assert_eq!(r, Err(NonZeroUsize::new(10).unwrap()));\n     assert_eq!(it.len(), 0);\n     assert_eq!(counter.get(), 100);\n }\n@@ -610,7 +611,7 @@ fn array_intoiter_advance_back_by() {\n     assert_eq!(counter.get(), 13);\n \n     let r = it.advance_back_by(123456);\n-    assert_eq!(r, Err(87));\n+    assert_eq!(r, Err(NonZeroUsize::new(123456 - 87).unwrap()));\n     assert_eq!(it.len(), 0);\n     assert_eq!(counter.get(), 100);\n \n@@ -620,7 +621,7 @@ fn array_intoiter_advance_back_by() {\n     assert_eq!(counter.get(), 100);\n \n     let r = it.advance_back_by(10);\n-    assert_eq!(r, Err(0));\n+    assert_eq!(r, Err(NonZeroUsize::new(10).unwrap()));\n     assert_eq!(it.len(), 0);\n     assert_eq!(counter.get(), 100);\n }\n@@ -679,8 +680,8 @@ fn array_into_iter_fold() {\n \n     let a = [1, 2, 3, 4, 5, 6];\n     let mut it = a.into_iter();\n-    it.advance_by(1).unwrap();\n-    it.advance_back_by(2).unwrap();\n+    assert_eq!(it.advance_by(1), Ok(()));\n+    assert_eq!(it.advance_back_by(2), Ok(()));\n     let s = it.fold(10, |a, b| 10 * a + b);\n     assert_eq!(s, 10234);\n }\n@@ -695,8 +696,8 @@ fn array_into_iter_rfold() {\n \n     let a = [1, 2, 3, 4, 5, 6];\n     let mut it = a.into_iter();\n-    it.advance_by(1).unwrap();\n-    it.advance_back_by(2).unwrap();\n+    assert_eq!(it.advance_by(1), Ok(()));\n+    assert_eq!(it.advance_back_by(2), Ok(()));\n     let s = it.rfold(10, |a, b| 10 * a + b);\n     assert_eq!(s, 10432);\n }"}, {"sha": "175a1b638e1a1e48995769f90b23561c52ff9fd6", "filename": "library/core/tests/iter/adapters/chain.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fchain.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use core::iter::*;\n+use core::num::NonZeroUsize;\n \n #[test]\n fn test_iterator_chain() {\n@@ -31,28 +32,28 @@ fn test_iterator_chain_advance_by() {\n \n         for i in 0..xs.len() {\n             let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n-            iter.advance_by(i).unwrap();\n+            assert_eq!(iter.advance_by(i), Ok(()));\n             assert_eq!(iter.next(), Some(&xs[i]));\n-            assert_eq!(iter.advance_by(100), Err(len - i - 1));\n-            iter.advance_by(0).unwrap();\n+            assert_eq!(iter.advance_by(100), Err(NonZeroUsize::new(100 - (len - i - 1)).unwrap()));\n+            assert_eq!(iter.advance_by(0), Ok(()));\n         }\n \n         for i in 0..ys.len() {\n             let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n-            iter.advance_by(xs.len() + i).unwrap();\n+            assert_eq!(iter.advance_by(xs.len() + i), Ok(()));\n             assert_eq!(iter.next(), Some(&ys[i]));\n-            assert_eq!(iter.advance_by(100), Err(ys.len() - i - 1));\n-            iter.advance_by(0).unwrap();\n+            assert_eq!(iter.advance_by(100), Err(NonZeroUsize::new(100 - (ys.len() - i - 1)).unwrap()));\n+            assert_eq!(iter.advance_by(0), Ok(()));\n         }\n \n         let mut iter = xs.iter().chain(ys);\n-        iter.advance_by(len).unwrap();\n+        assert_eq!(iter.advance_by(len), Ok(()));\n         assert_eq!(iter.next(), None);\n-        iter.advance_by(0).unwrap();\n+        assert_eq!(iter.advance_by(0), Ok(()));\n \n         let mut iter = xs.iter().chain(ys);\n-        assert_eq!(iter.advance_by(len + 1), Err(len));\n-        iter.advance_by(0).unwrap();\n+        assert_eq!(iter.advance_by(len + 1), Err(NonZeroUsize::new(1).unwrap()));\n+        assert_eq!(iter.advance_by(0), Ok(()));\n     }\n \n     test_chain(&[], &[]);\n@@ -68,28 +69,28 @@ fn test_iterator_chain_advance_back_by() {\n \n         for i in 0..ys.len() {\n             let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n-            iter.advance_back_by(i).unwrap();\n+            assert_eq!(iter.advance_back_by(i), Ok(()));\n             assert_eq!(iter.next_back(), Some(&ys[ys.len() - i - 1]));\n-            assert_eq!(iter.advance_back_by(100), Err(len - i - 1));\n-            iter.advance_back_by(0).unwrap();\n+            assert_eq!(iter.advance_back_by(100), Err(NonZeroUsize::new(100 - (len - i - 1)).unwrap()));\n+            assert_eq!(iter.advance_back_by(0), Ok(()));\n         }\n \n         for i in 0..xs.len() {\n             let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n-            iter.advance_back_by(ys.len() + i).unwrap();\n+            assert_eq!(iter.advance_back_by(ys.len() + i), Ok(()));\n             assert_eq!(iter.next_back(), Some(&xs[xs.len() - i - 1]));\n-            assert_eq!(iter.advance_back_by(100), Err(xs.len() - i - 1));\n-            iter.advance_back_by(0).unwrap();\n+            assert_eq!(iter.advance_back_by(100), Err(NonZeroUsize::new(100 - (xs.len() - i - 1)).unwrap()));\n+            assert_eq!(iter.advance_back_by(0), Ok(()));\n         }\n \n         let mut iter = xs.iter().chain(ys);\n-        iter.advance_back_by(len).unwrap();\n+        assert_eq!(iter.advance_back_by(len), Ok(()));\n         assert_eq!(iter.next_back(), None);\n-        iter.advance_back_by(0).unwrap();\n+        assert_eq!(iter.advance_back_by(0), Ok(()));\n \n         let mut iter = xs.iter().chain(ys);\n-        assert_eq!(iter.advance_back_by(len + 1), Err(len));\n-        iter.advance_back_by(0).unwrap();\n+        assert_eq!(iter.advance_back_by(len + 1), Err(NonZeroUsize::new(1).unwrap()));\n+        assert_eq!(iter.advance_back_by(0), Ok(()));\n     }\n \n     test_chain(&[], &[]);"}, {"sha": "ff57973a62a4b41f008f5ed0f2ef5aec803ffe99", "filename": "library/core/tests/iter/adapters/enumerate.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fenumerate.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use core::iter::*;\n+use core::num::NonZeroUsize;\n \n #[test]\n fn test_iterator_enumerate() {\n@@ -55,6 +56,20 @@ fn test_iterator_enumerate_count() {\n     assert_eq!(xs.iter().enumerate().count(), 6);\n }\n \n+#[test]\n+fn test_iterator_enumerate_advance_by() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().enumerate();\n+    assert_eq!(it.advance_by(0), Ok(()));\n+    assert_eq!(it.next(), Some((0, &0)));\n+    assert_eq!(it.advance_by(1), Ok(()));\n+    assert_eq!(it.next(), Some((2, &2)));\n+    assert_eq!(it.advance_by(2), Ok(()));\n+    assert_eq!(it.next(), Some((5, &5)));\n+    assert_eq!(it.advance_by(1), Err(NonZeroUsize::new(1).unwrap()));\n+    assert_eq!(it.next(), None);\n+}\n+\n #[test]\n fn test_iterator_enumerate_fold() {\n     let xs = [0, 1, 2, 3, 4, 5];"}, {"sha": "91809c9e5fd5d66247541a42f12443922a1a886d", "filename": "library/core/tests/iter/adapters/flatten.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,5 +1,7 @@\n+use core::assert_eq;\n use super::*;\n use core::iter::*;\n+use core::num::NonZeroUsize;\n \n #[test]\n fn test_iterator_flatten() {\n@@ -61,19 +63,19 @@ fn test_flatten_try_folds() {\n fn test_flatten_advance_by() {\n     let mut it = once(0..10).chain(once(10..30)).chain(once(30..40)).flatten();\n \n-    it.advance_by(5).unwrap();\n+    assert_eq!(it.advance_by(5), Ok(()));\n     assert_eq!(it.next(), Some(5));\n-    it.advance_by(9).unwrap();\n+    assert_eq!(it.advance_by(9), Ok(()));\n     assert_eq!(it.next(), Some(15));\n-    it.advance_back_by(4).unwrap();\n+    assert_eq!(it.advance_back_by(4), Ok(()));\n     assert_eq!(it.next_back(), Some(35));\n-    it.advance_back_by(9).unwrap();\n+    assert_eq!(it.advance_back_by(9), Ok(()));\n     assert_eq!(it.next_back(), Some(25));\n \n-    assert_eq!(it.advance_by(usize::MAX), Err(9));\n-    assert_eq!(it.advance_back_by(usize::MAX), Err(0));\n-    it.advance_by(0).unwrap();\n-    it.advance_back_by(0).unwrap();\n+    assert_eq!(it.advance_by(usize::MAX), Err(NonZeroUsize::new(usize::MAX - 9).unwrap()));\n+    assert_eq!(it.advance_back_by(usize::MAX), Err(NonZeroUsize::new(usize::MAX).unwrap()));\n+    assert_eq!(it.advance_by(0), Ok(()));\n+    assert_eq!(it.advance_back_by(0), Ok(()));\n     assert_eq!(it.size_hint(), (0, Some(0)));\n }\n \n@@ -174,19 +176,19 @@ fn test_flatten_count() {\n     let mut it = once(0..10).chain(once(10..30)).chain(once(30..40)).flatten();\n \n     assert_eq!(it.clone().count(), 40);\n-    it.advance_by(5).unwrap();\n+    assert_eq!(it.advance_by(5), Ok(()));\n     assert_eq!(it.clone().count(), 35);\n-    it.advance_back_by(5).unwrap();\n+    assert_eq!(it.advance_back_by(5), Ok(()));\n     assert_eq!(it.clone().count(), 30);\n-    it.advance_by(10).unwrap();\n+    assert_eq!(it.advance_by(10), Ok(()));\n     assert_eq!(it.clone().count(), 20);\n-    it.advance_back_by(8).unwrap();\n+    assert_eq!(it.advance_back_by(8), Ok(()));\n     assert_eq!(it.clone().count(), 12);\n-    it.advance_by(4).unwrap();\n+    assert_eq!(it.advance_by(4), Ok(()));\n     assert_eq!(it.clone().count(), 8);\n-    it.advance_back_by(5).unwrap();\n+    assert_eq!(it.advance_back_by(5), Ok(()));\n     assert_eq!(it.clone().count(), 3);\n-    it.advance_by(3).unwrap();\n+    assert_eq!(it.advance_by(3), Ok(()));\n     assert_eq!(it.clone().count(), 0);\n }\n \n@@ -195,18 +197,18 @@ fn test_flatten_last() {\n     let mut it = once(0..10).chain(once(10..30)).chain(once(30..40)).flatten();\n \n     assert_eq!(it.clone().last(), Some(39));\n-    it.advance_by(5).unwrap(); // 5..40\n+    assert_eq!(it.advance_by(5), Ok(())); // 5..40\n     assert_eq!(it.clone().last(), Some(39));\n-    it.advance_back_by(5).unwrap(); // 5..35\n+    assert_eq!(it.advance_back_by(5), Ok(())); // 5..35\n     assert_eq!(it.clone().last(), Some(34));\n-    it.advance_by(10).unwrap(); // 15..35\n+    assert_eq!(it.advance_by(10), Ok(())); // 15..35\n     assert_eq!(it.clone().last(), Some(34));\n-    it.advance_back_by(8).unwrap(); // 15..27\n+    assert_eq!(it.advance_back_by(8), Ok(())); // 15..27\n     assert_eq!(it.clone().last(), Some(26));\n-    it.advance_by(4).unwrap(); // 19..27\n+    assert_eq!(it.advance_by(4), Ok(())); // 19..27\n     assert_eq!(it.clone().last(), Some(26));\n-    it.advance_back_by(5).unwrap(); // 19..22\n+    assert_eq!(it.advance_back_by(5), Ok(())); // 19..22\n     assert_eq!(it.clone().last(), Some(21));\n-    it.advance_by(3).unwrap(); // 22..22\n+    assert_eq!(it.advance_by(3), Ok(())); // 22..22\n     assert_eq!(it.clone().last(), None);\n }"}, {"sha": "e3e88a84fadf6da200aac49908492e6ebc3e68a6", "filename": "library/core/tests/iter/adapters/skip.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fskip.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use core::iter::*;\n+use core::num::NonZeroUsize;\n \n use super::Unfuse;\n \n@@ -74,11 +75,14 @@ fn test_iterator_skip_nth() {\n #[test]\n fn test_skip_advance_by() {\n     assert_eq!((0..0).skip(10).advance_by(0), Ok(()));\n-    assert_eq!((0..0).skip(10).advance_by(1), Err(0));\n-    assert_eq!((0u128..(usize::MAX as u128) + 1).skip(usize::MAX).advance_by(usize::MAX), Err(1));\n-    assert_eq!((0u128..u128::MAX).skip(usize::MAX).advance_by(1), Ok(()));\n-\n-    assert_eq!((0..2).skip(1).advance_back_by(10), Err(1));\n+    assert_eq!((0..0).skip(10).advance_by(1), Err(NonZeroUsize::new(1).unwrap()));\n+    assert_eq!(\n+        (0u128..(usize::MAX as u128) + 1).skip(usize::MAX - 10).advance_by(usize::MAX - 5),\n+        Err(NonZeroUsize::new(usize::MAX - 16).unwrap())\n+    );\n+    assert_eq!((0u128..u128::MAX).skip(usize::MAX - 10).advance_by(20), Ok(()));\n+\n+    assert_eq!((0..2).skip(1).advance_back_by(10), Err(NonZeroUsize::new(9).unwrap()));\n     assert_eq!((0..0).skip(1).advance_back_by(0), Ok(()));\n }\n "}, {"sha": "3cad47c06de031e0b47e68ff31cc9210722a6aed", "filename": "library/core/tests/iter/adapters/take.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ftake.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,5 @@\n use core::iter::*;\n+use core::num::NonZeroUsize;\n \n #[test]\n fn test_iterator_take() {\n@@ -78,21 +79,21 @@ fn test_take_advance_by() {\n     let mut take = (0..10).take(3);\n     assert_eq!(take.advance_by(2), Ok(()));\n     assert_eq!(take.next(), Some(2));\n-    assert_eq!(take.advance_by(1), Err(0));\n+    assert_eq!(take.advance_by(1), Err(NonZeroUsize::new(1).unwrap()));\n \n     assert_eq!((0..0).take(10).advance_by(0), Ok(()));\n-    assert_eq!((0..0).take(10).advance_by(1), Err(0));\n-    assert_eq!((0..10).take(4).advance_by(5), Err(4));\n+    assert_eq!((0..0).take(10).advance_by(1), Err(NonZeroUsize::new(1).unwrap()));\n+    assert_eq!((0..10).take(4).advance_by(5), Err(NonZeroUsize::new(1).unwrap()));\n \n     let mut take = (0..10).take(3);\n     assert_eq!(take.advance_back_by(2), Ok(()));\n     assert_eq!(take.next(), Some(0));\n-    assert_eq!(take.advance_back_by(1), Err(0));\n+    assert_eq!(take.advance_back_by(1), Err(NonZeroUsize::new(1).unwrap()));\n \n-    assert_eq!((0..2).take(1).advance_back_by(10), Err(1));\n-    assert_eq!((0..0).take(1).advance_back_by(1), Err(0));\n+    assert_eq!((0..2).take(1).advance_back_by(10), Err(NonZeroUsize::new(9).unwrap()));\n+    assert_eq!((0..0).take(1).advance_back_by(1), Err(NonZeroUsize::new(1).unwrap()));\n     assert_eq!((0..0).take(1).advance_back_by(0), Ok(()));\n-    assert_eq!((0..usize::MAX).take(100).advance_back_by(usize::MAX), Err(100));\n+    assert_eq!((0..usize::MAX).take(100).advance_back_by(usize::MAX), Err(NonZeroUsize::new(usize::MAX - 100).unwrap()));\n }\n \n #[test]"}, {"sha": "0a77ecddb84d5b38776db36b1c53155346928f7d", "filename": "library/core/tests/iter/range.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Frange.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,3 +1,4 @@\n+use core::num::NonZeroUsize;\n use super::*;\n \n #[test]\n@@ -287,25 +288,25 @@ fn test_range_step() {\n #[test]\n fn test_range_advance_by() {\n     let mut r = 0..usize::MAX;\n-    r.advance_by(0).unwrap();\n-    r.advance_back_by(0).unwrap();\n+    assert_eq!(Ok(()), r.advance_by(0));\n+    assert_eq!(Ok(()), r.advance_back_by(0));\n \n     assert_eq!(r.len(), usize::MAX);\n \n-    r.advance_by(1).unwrap();\n-    r.advance_back_by(1).unwrap();\n+    assert_eq!(Ok(()), r.advance_by(1));\n+    assert_eq!(Ok(()), r.advance_back_by(1));\n \n     assert_eq!((r.start, r.end), (1, usize::MAX - 1));\n \n-    assert_eq!(r.advance_by(usize::MAX), Err(usize::MAX - 2));\n+    assert_eq!(Err(NonZeroUsize::new(2).unwrap()), r.advance_by(usize::MAX));\n \n-    r.advance_by(0).unwrap();\n-    r.advance_back_by(0).unwrap();\n+    assert_eq!(Ok(()), r.advance_by(0));\n+    assert_eq!(Ok(()), r.advance_back_by(0));\n \n     let mut r = 0u128..u128::MAX;\n \n-    r.advance_by(usize::MAX).unwrap();\n-    r.advance_back_by(usize::MAX).unwrap();\n+    assert_eq!(Ok(()), r.advance_by(usize::MAX));\n+    assert_eq!(Ok(()), r.advance_back_by(usize::MAX));\n \n     assert_eq!((r.start, r.end), (0u128 + usize::MAX as u128, u128::MAX - usize::MAX as u128));\n }"}, {"sha": "9eebfb1f1f359120a65b1d9127b90f41eb8e86a9", "filename": "library/core/tests/iter/traits/iterator.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,3 +1,5 @@\n+use core::num::NonZeroUsize;\n+\n /// A wrapper struct that implements `Eq` and `Ord` based on the wrapped\n /// integer modulo 3. Used to test that `Iterator::max` and `Iterator::min`\n /// return the correct element if some of them are equal.\n@@ -150,11 +152,11 @@ fn test_iterator_advance_by() {\n         let mut iter = v.iter();\n         assert_eq!(iter.advance_by(i), Ok(()));\n         assert_eq!(iter.next().unwrap(), &v[i]);\n-        assert_eq!(iter.advance_by(100), Err(v.len() - 1 - i));\n+        assert_eq!(iter.advance_by(100), Err(NonZeroUsize::new(100 - (v.len() - 1 - i)).unwrap()));\n     }\n \n     assert_eq!(v.iter().advance_by(v.len()), Ok(()));\n-    assert_eq!(v.iter().advance_by(100), Err(v.len()));\n+    assert_eq!(v.iter().advance_by(100), Err(NonZeroUsize::new(100 - v.len()).unwrap()));\n }\n \n #[test]\n@@ -165,11 +167,11 @@ fn test_iterator_advance_back_by() {\n         let mut iter = v.iter();\n         assert_eq!(iter.advance_back_by(i), Ok(()));\n         assert_eq!(iter.next_back().unwrap(), &v[v.len() - 1 - i]);\n-        assert_eq!(iter.advance_back_by(100), Err(v.len() - 1 - i));\n+        assert_eq!(iter.advance_back_by(100), Err(NonZeroUsize::new(100 - (v.len() - 1 - i)).unwrap()));\n     }\n \n     assert_eq!(v.iter().advance_back_by(v.len()), Ok(()));\n-    assert_eq!(v.iter().advance_back_by(100), Err(v.len()));\n+    assert_eq!(v.iter().advance_back_by(100), Err(NonZeroUsize::new(100 - v.len()).unwrap()));\n }\n \n #[test]\n@@ -180,11 +182,11 @@ fn test_iterator_rev_advance_back_by() {\n         let mut iter = v.iter().rev();\n         assert_eq!(iter.advance_back_by(i), Ok(()));\n         assert_eq!(iter.next_back().unwrap(), &v[i]);\n-        assert_eq!(iter.advance_back_by(100), Err(v.len() - 1 - i));\n+        assert_eq!(iter.advance_back_by(100), Err(NonZeroUsize::new(100 - (v.len() - 1 - i)).unwrap()));\n     }\n \n     assert_eq!(v.iter().rev().advance_back_by(v.len()), Ok(()));\n-    assert_eq!(v.iter().rev().advance_back_by(100), Err(v.len()));\n+    assert_eq!(v.iter().rev().advance_back_by(100), Err(NonZeroUsize::new(100 - v.len()).unwrap()));\n }\n \n #[test]\n@@ -424,11 +426,11 @@ fn test_iterator_rev_advance_by() {\n         let mut iter = v.iter().rev();\n         assert_eq!(iter.advance_by(i), Ok(()));\n         assert_eq!(iter.next().unwrap(), &v[v.len() - 1 - i]);\n-        assert_eq!(iter.advance_by(100), Err(v.len() - 1 - i));\n+        assert_eq!(iter.advance_by(100), Err(NonZeroUsize::new(100 - (v.len() - 1 - i)).unwrap()));\n     }\n \n     assert_eq!(v.iter().rev().advance_by(v.len()), Ok(()));\n-    assert_eq!(v.iter().rev().advance_by(100), Err(v.len()));\n+    assert_eq!(v.iter().rev().advance_by(100), Err(NonZeroUsize::new(100 - v.len()).unwrap()));\n }\n \n #[test]"}, {"sha": "88f54591bb4a49036cad9660d25ec739b1dbeda4", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,6 +1,7 @@\n use core::cell::Cell;\n use core::cmp::Ordering;\n use core::mem::MaybeUninit;\n+use core::num::NonZeroUsize;\n use core::result::Result::{Err, Ok};\n use core::slice;\n \n@@ -142,20 +143,20 @@ fn test_iterator_advance_by() {\n \n     for i in 0..=v.len() {\n         let mut iter = v.iter();\n-        iter.advance_by(i).unwrap();\n+        assert_eq!(iter.advance_by(i), Ok(()));\n         assert_eq!(iter.as_slice(), &v[i..]);\n     }\n \n     let mut iter = v.iter();\n-    assert_eq!(iter.advance_by(v.len() + 1), Err(v.len()));\n+    assert_eq!(iter.advance_by(v.len() + 1), Err(NonZeroUsize::new(1).unwrap()));\n     assert_eq!(iter.as_slice(), &[]);\n \n     let mut iter = v.iter();\n-    iter.advance_by(3).unwrap();\n+    assert_eq!(iter.advance_by(3), Ok(()));\n     assert_eq!(iter.as_slice(), &v[3..]);\n-    iter.advance_by(2).unwrap();\n+    assert_eq!(iter.advance_by(2), Ok(()));\n     assert_eq!(iter.as_slice(), &[]);\n-    iter.advance_by(0).unwrap();\n+    assert_eq!(iter.advance_by(0), Ok(()));\n }\n \n #[test]\n@@ -164,20 +165,20 @@ fn test_iterator_advance_back_by() {\n \n     for i in 0..=v.len() {\n         let mut iter = v.iter();\n-        iter.advance_back_by(i).unwrap();\n+        assert_eq!(iter.advance_back_by(i), Ok(()));\n         assert_eq!(iter.as_slice(), &v[..v.len() - i]);\n     }\n \n     let mut iter = v.iter();\n-    assert_eq!(iter.advance_back_by(v.len() + 1), Err(v.len()));\n+    assert_eq!(iter.advance_back_by(v.len() + 1), Err(NonZeroUsize::new(1).unwrap()));\n     assert_eq!(iter.as_slice(), &[]);\n \n     let mut iter = v.iter();\n-    iter.advance_back_by(3).unwrap();\n+    assert_eq!(iter.advance_back_by(3), Ok(()));\n     assert_eq!(iter.as_slice(), &v[..v.len() - 3]);\n-    iter.advance_back_by(2).unwrap();\n+    assert_eq!(iter.advance_back_by(2), Ok(()));\n     assert_eq!(iter.as_slice(), &[]);\n-    iter.advance_back_by(0).unwrap();\n+    assert_eq!(iter.advance_back_by(0), Ok(()));\n }\n \n #[test]"}, {"sha": "cf708db6f27e1d780e66cdf52f555b55d003aebe", "filename": "library/std/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fbuild.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -6,6 +6,9 @@ fn main() {\n     if target.contains(\"freebsd\") {\n         if env::var(\"RUST_STD_FREEBSD_12_ABI\").is_ok() {\n             println!(\"cargo:rustc-cfg=freebsd12\");\n+        } else if env::var(\"RUST_STD_FREEBSD_13_ABI\").is_ok() {\n+            println!(\"cargo:rustc-cfg=freebsd12\");\n+            println!(\"cargo:rustc-cfg=freebsd13\");\n         }\n     } else if target.contains(\"linux\")\n         || target.contains(\"netbsd\")"}, {"sha": "7565fbc0d099cb66a59def3d45d47864f617bfa3", "filename": "library/std/src/os/unix/net/ancillary.rs", "status": "modified", "additions": 129, "deletions": 12, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -86,7 +86,12 @@ fn add_to_ancillary_data<T>(\n     cmsg_level: libc::c_int,\n     cmsg_type: libc::c_int,\n ) -> bool {\n-    let source_len = if let Some(source_len) = source.len().checked_mul(size_of::<T>()) {\n+    #[cfg(not(target_os = \"freebsd\"))]\n+    let cmsg_size = source.len().checked_mul(size_of::<T>());\n+    #[cfg(target_os = \"freebsd\")]\n+    let cmsg_size = Some(unsafe { libc::SOCKCRED2SIZE(1) });\n+\n+    let source_len = if let Some(source_len) = cmsg_size {\n         if let Ok(source_len) = u32::try_from(source_len) {\n             source_len\n         } else {\n@@ -178,7 +183,13 @@ impl<'a, T> Iterator for AncillaryDataIter<'a, T> {\n     }\n }\n \n-#[cfg(all(doc, not(target_os = \"android\"), not(target_os = \"linux\"), not(target_os = \"netbsd\")))]\n+#[cfg(all(\n+    doc,\n+    not(target_os = \"android\"),\n+    not(target_os = \"linux\"),\n+    not(target_os = \"netbsd\"),\n+    not(target_os = \"freebsd\")\n+))]\n #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n #[derive(Clone)]\n pub struct SocketCred(());\n@@ -194,6 +205,11 @@ pub struct SocketCred(libc::ucred);\n #[derive(Clone)]\n pub struct SocketCred(libc::sockcred);\n \n+#[cfg(target_os = \"freebsd\")]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+#[derive(Clone)]\n+pub struct SocketCred(libc::sockcred2);\n+\n #[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n impl SocketCred {\n@@ -246,6 +262,66 @@ impl SocketCred {\n     }\n }\n \n+#[cfg(target_os = \"freebsd\")]\n+impl SocketCred {\n+    /// Create a Unix credential struct.\n+    ///\n+    /// PID, UID and GID is set to 0.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    #[must_use]\n+    pub fn new() -> SocketCred {\n+        SocketCred(libc::sockcred2 {\n+            sc_version: 0,\n+            sc_pid: 0,\n+            sc_uid: 0,\n+            sc_euid: 0,\n+            sc_gid: 0,\n+            sc_egid: 0,\n+            sc_ngroups: 0,\n+            sc_groups: [0; 1],\n+        })\n+    }\n+\n+    /// Set the PID.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn set_pid(&mut self, pid: libc::pid_t) {\n+        self.0.sc_pid = pid;\n+    }\n+\n+    /// Get the current PID.\n+    #[must_use]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn get_pid(&self) -> libc::pid_t {\n+        self.0.sc_pid\n+    }\n+\n+    /// Set the UID.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn set_uid(&mut self, uid: libc::uid_t) {\n+        self.0.sc_euid = uid;\n+    }\n+\n+    /// Get the current UID.\n+    #[must_use]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn get_uid(&self) -> libc::uid_t {\n+        self.0.sc_euid\n+    }\n+\n+    /// Set the GID.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn set_gid(&mut self, gid: libc::gid_t) {\n+        self.0.sc_egid = gid;\n+    }\n+\n+    /// Get the current GID.\n+    #[must_use]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn get_gid(&self) -> libc::gid_t {\n+        self.0.sc_egid\n+    }\n+}\n+\n #[cfg(target_os = \"netbsd\")]\n impl SocketCred {\n     /// Create a Unix credential struct.\n@@ -271,6 +347,7 @@ impl SocketCred {\n     }\n \n     /// Get the current PID.\n+    #[must_use]\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn get_pid(&self) -> libc::pid_t {\n         self.0.sc_pid\n@@ -283,6 +360,7 @@ impl SocketCred {\n     }\n \n     /// Get the current UID.\n+    #[must_use]\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn get_uid(&self) -> libc::uid_t {\n         self.0.sc_uid\n@@ -295,6 +373,7 @@ impl SocketCred {\n     }\n \n     /// Get the current GID.\n+    #[must_use]\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn get_gid(&self) -> libc::gid_t {\n         self.0.sc_gid\n@@ -316,7 +395,13 @@ impl<'a> Iterator for ScmRights<'a> {\n     }\n }\n \n-#[cfg(all(doc, not(target_os = \"android\"), not(target_os = \"linux\"), not(target_os = \"netbsd\")))]\n+#[cfg(all(\n+    doc,\n+    not(target_os = \"android\"),\n+    not(target_os = \"linux\"),\n+    not(target_os = \"netbsd\"),\n+    not(target_os = \"freebsd\")\n+))]\n #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n pub struct ScmCredentials<'a>(AncillaryDataIter<'a, ()>);\n \n@@ -327,11 +412,21 @@ pub struct ScmCredentials<'a>(AncillaryDataIter<'a, ()>);\n #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n pub struct ScmCredentials<'a>(AncillaryDataIter<'a, libc::ucred>);\n \n+#[cfg(target_os = \"freebsd\")]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+pub struct ScmCredentials<'a>(AncillaryDataIter<'a, libc::sockcred2>);\n+\n #[cfg(target_os = \"netbsd\")]\n #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n pub struct ScmCredentials<'a>(AncillaryDataIter<'a, libc::sockcred>);\n \n-#[cfg(any(doc, target_os = \"android\", target_os = \"linux\", target_os = \"netbsd\",))]\n+#[cfg(any(\n+    doc,\n+    target_os = \"android\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"freebsd\"\n+))]\n #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n impl<'a> Iterator for ScmCredentials<'a> {\n     type Item = SocketCred;\n@@ -353,7 +448,13 @@ pub enum AncillaryError {\n #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n pub enum AncillaryData<'a> {\n     ScmRights(ScmRights<'a>),\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\", target_os = \"netbsd\",))]\n+    #[cfg(any(\n+        doc,\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"freebsd\"\n+    ))]\n     ScmCredentials(ScmCredentials<'a>),\n }\n \n@@ -376,7 +477,13 @@ impl<'a> AncillaryData<'a> {\n     ///\n     /// `data` must contain a valid control message and the control message must be type of\n     /// `SOL_SOCKET` and level of `SCM_CREDENTIALS` or `SCM_CREDS`.\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\", target_os = \"netbsd\",))]\n+    #[cfg(any(\n+        doc,\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"freebsd\"\n+    ))]\n     unsafe fn as_credentials(data: &'a [u8]) -> Self {\n         let ancillary_data_iter = AncillaryDataIter::new(data);\n         let scm_credentials = ScmCredentials(ancillary_data_iter);\n@@ -395,6 +502,8 @@ impl<'a> AncillaryData<'a> {\n                     libc::SCM_RIGHTS => Ok(AncillaryData::as_rights(data)),\n                     #[cfg(any(target_os = \"android\", target_os = \"linux\",))]\n                     libc::SCM_CREDENTIALS => Ok(AncillaryData::as_credentials(data)),\n+                    #[cfg(target_os = \"freebsd\")]\n+                    libc::SCM_CREDS2 => Ok(AncillaryData::as_credentials(data)),\n                     #[cfg(target_os = \"netbsd\")]\n                     libc::SCM_CREDS => Ok(AncillaryData::as_credentials(data)),\n                     cmsg_type => {\n@@ -603,12 +712,18 @@ impl<'a> SocketAncillary<'a> {\n \n     /// Add credentials to the ancillary data.\n     ///\n-    /// The function returns `true` if there was enough space in the buffer.\n-    /// If there was not enough space then no credentials was appended.\n+    /// The function returns `true` if there is enough space in the buffer.\n+    /// If there is not enough space then no credentials will be appended.\n     /// Technically, that means this operation adds a control message with the level `SOL_SOCKET`\n-    /// and type `SCM_CREDENTIALS` or `SCM_CREDS`.\n-    ///\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\", target_os = \"netbsd\",))]\n+    /// and type `SCM_CREDENTIALS`, `SCM_CREDS`, or `SCM_CREDS2`.\n+    ///\n+    #[cfg(any(\n+        doc,\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"freebsd\"\n+    ))]\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn add_creds(&mut self, creds: &[SocketCred]) -> bool {\n         self.truncated = false;\n@@ -617,8 +732,10 @@ impl<'a> SocketAncillary<'a> {\n             &mut self.length,\n             creds,\n             libc::SOL_SOCKET,\n-            #[cfg(not(target_os = \"netbsd\"))]\n+            #[cfg(not(any(target_os = \"netbsd\", target_os = \"freebsd\")))]\n             libc::SCM_CREDENTIALS,\n+            #[cfg(target_os = \"freebsd\")]\n+            libc::SCM_CREDS2,\n             #[cfg(target_os = \"netbsd\")]\n             libc::SCM_CREDS,\n         )"}, {"sha": "41cdcda4613f7eaec086c7664594f55d1fe6d9f5", "filename": "library/std/src/os/unix/net/datagram.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -808,8 +808,24 @@ impl UnixDatagram {\n     ///\n     /// # Examples\n     ///\n-    #[cfg_attr(any(target_os = \"android\", target_os = \"linux\"), doc = \"```no_run\")]\n-    #[cfg_attr(not(any(target_os = \"android\", target_os = \"linux\")), doc = \"```ignore\")]\n+    #[cfg_attr(\n+        any(\n+            target_os = \"android\",\n+            target_os = \"linux\",\n+            target_os = \"netbsd\",\n+            target_os = \"freebsd\",\n+        ),\n+        doc = \"```no_run\"\n+    )]\n+    #[cfg_attr(\n+        not(any(\n+            target_os = \"android\",\n+            target_os = \"linux\",\n+            target_os = \"netbsd\",\n+            target_os = \"freebsd\"\n+        )),\n+        doc = \"```ignore\"\n+    )]\n     /// #![feature(unix_socket_ancillary_data)]\n     /// use std::os::unix::net::UnixDatagram;\n     ///\n@@ -819,7 +835,13 @@ impl UnixDatagram {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\", target_os = \"netbsd\",))]\n+    #[cfg(any(\n+        doc,\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"freebsd\"\n+    ))]\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {\n         self.0.set_passcred(passcred)\n@@ -831,7 +853,13 @@ impl UnixDatagram {\n     /// Get the socket option `SO_PASSCRED`.\n     ///\n     /// [`set_passcred`]: UnixDatagram::set_passcred\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\", target_os = \"netbsd\",))]\n+    #[cfg(any(\n+        doc,\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"freebsd\"\n+    ))]\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn passcred(&self) -> io::Result<bool> {\n         self.0.passcred()"}, {"sha": "5aa3fb92576c93984107a79779c080a60e975e6e", "filename": "library/std/src/os/unix/net/stream.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -397,8 +397,24 @@ impl UnixStream {\n     ///\n     /// # Examples\n     ///\n-    #[cfg_attr(any(target_os = \"android\", target_os = \"linux\"), doc = \"```no_run\")]\n-    #[cfg_attr(not(any(target_os = \"android\", target_os = \"linux\")), doc = \"```ignore\")]\n+    #[cfg_attr(\n+        any(\n+            target_os = \"android\",\n+            target_os = \"linux\",\n+            target_os = \"netbsd\",\n+            target_os = \"freebsd\"\n+        ),\n+        doc = \"```no_run\"\n+    )]\n+    #[cfg_attr(\n+        not(any(\n+            target_os = \"android\",\n+            target_os = \"linux\",\n+            target_os = \"netbsd\",\n+            target_os = \"freebsd\"\n+        )),\n+        doc = \"```ignore\"\n+    )]\n     /// #![feature(unix_socket_ancillary_data)]\n     /// use std::os::unix::net::UnixStream;\n     ///\n@@ -408,7 +424,13 @@ impl UnixStream {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\", target_os = \"netbsd\",))]\n+    #[cfg(any(\n+        doc,\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"freebsd\"\n+    ))]\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {\n         self.0.set_passcred(passcred)\n@@ -420,7 +442,13 @@ impl UnixStream {\n     /// Get the socket option `SO_PASSCRED`.\n     ///\n     /// [`set_passcred`]: UnixStream::set_passcred\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\", target_os = \"netbsd\",))]\n+    #[cfg(any(\n+        doc,\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"freebsd\"\n+    ))]\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn passcred(&self) -> io::Result<bool> {\n         self.0.passcred()"}, {"sha": "39f10c50dc4212c6371b77ead070422f9516d07a", "filename": "library/std/src/os/unix/net/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -646,7 +646,7 @@ fn test_send_vectored_fds_unix_stream() {\n     }\n }\n \n-#[cfg(any(target_os = \"android\", target_os = \"linux\",))]\n+#[cfg(any(target_os = \"android\", target_os = \"linux\", target_os = \"freebsd\"))]\n #[test]\n fn test_send_vectored_with_ancillary_to_unix_datagram() {\n     fn getpid() -> libc::pid_t {"}, {"sha": "573bfa6587e8154fd13fd18f296fb6e86bcb46b7", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -443,6 +443,17 @@ impl Socket {\n         Ok(passcred != 0)\n     }\n \n+    #[cfg(target_os = \"freebsd\")]\n+    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {\n+        setsockopt(self, libc::AF_LOCAL, libc::LOCAL_CREDS_PERSISTENT, passcred as libc::c_int)\n+    }\n+\n+    #[cfg(target_os = \"freebsd\")]\n+    pub fn passcred(&self) -> io::Result<bool> {\n+        let passcred: libc::c_int = getsockopt(self, libc::AF_LOCAL, libc::LOCAL_CREDS_PERSISTENT)?;\n+        Ok(passcred != 0)\n+    }\n+\n     #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         let mut nonblocking = nonblocking as libc::c_int;"}, {"sha": "ed103a9a51c5a0b882a88081ca408c7a54519a92", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -125,6 +125,7 @@ const EXTRA_CHECK_CFGS: &[(Option<Mode>, &'static str, Option<&[&'static str]>)]\n     (Some(Mode::Std), \"no_rc\", None),\n     (Some(Mode::Std), \"no_sync\", None),\n     (Some(Mode::Std), \"freebsd12\", None),\n+    (Some(Mode::Std), \"freebsd13\", None),\n     (Some(Mode::Std), \"backtrace_in_libstd\", None),\n     /* Extra values not defined in the built-in targets yet, but used in std */\n     (Some(Mode::Std), \"target_env\", Some(&[\"libnx\"])),"}, {"sha": "21eb2c9b2f2da329cc9cd3e703115a66ba753f21", "filename": "tests/ui/codegen/mono-impossible-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fcodegen%2Fmono-impossible-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fcodegen%2Fmono-impossible-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcodegen%2Fmono-impossible-2.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -0,0 +1,19 @@\n+//compile-flags: --crate-type=lib -Clink-dead-code=on\n+// build-pass\n+\n+// Make sure that we don't monomorphize the impossible method `<() as Visit>::visit`,\n+// which does not hold under a reveal-all param env.\n+\n+pub trait Visit {\n+    fn visit() {}\n+}\n+\n+pub trait Array {\n+    type Element;\n+}\n+\n+impl<'a> Visit for () where (): Array<Element = &'a ()> {}\n+\n+impl Array for () {\n+    type Element = ();\n+}"}, {"sha": "b43f982283b8b1f84fcd52800e22951a8e69c44b", "filename": "tests/ui/generic-associated-types/gat-bounds-normalize-pred.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fgeneric-associated-types%2Fgat-bounds-normalize-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fgeneric-associated-types%2Fgat-bounds-normalize-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fgat-bounds-normalize-pred.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+trait Foo {\n+    type Assoc<T>: PartialEq<Self::Assoc<i32>>;\n+}\n+\n+impl Foo for () {\n+    type Assoc<T> = Wrapper<T>;\n+}\n+\n+struct Wrapper<T>(T);\n+\n+impl<T> PartialEq<Wrapper<i32>> for Wrapper<T> {\n+    fn eq(&self, _other: &Wrapper<i32>) -> bool { true }\n+}\n+\n+fn main() {}"}, {"sha": "9e1e3feaeec9fafb022b3a1d7e4660d8e682e27f", "filename": "tests/ui/implied-bounds/ice-unbound-region-vars.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fimplied-bounds%2Fice-unbound-region-vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fimplied-bounds%2Fice-unbound-region-vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fice-unbound-region-vars.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -0,0 +1,24 @@\n+// Because of #109628, we can have unbounded region vars in implied bounds.\n+// Make sure we don't ICE in this case!\n+//\n+// check-pass\n+\n+pub trait MapAccess {\n+    type Error;\n+    fn next_key_seed(&mut self) -> Option<Self::Error>;\n+}\n+\n+struct Access<'a> {\n+    _marker: std::marker::PhantomData<&'a ()>,\n+}\n+\n+// implied_bounds(Option<Self::Error>) = ['?1: 'a, ]\n+// where '?1 is a fresh region var.\n+impl<'a, 'b: 'a> MapAccess for Access<'a> {\n+    type Error = ();\n+    fn next_key_seed(&mut self) -> Option<Self::Error> {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f776fc98a9edeb24b3ba13298659d652e38884c2", "filename": "tests/ui/implied-bounds/normalization.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -0,0 +1,58 @@\n+// Test that we get implied bounds from complex projections after normalization.\n+\n+// check-pass\n+\n+// implementations wil ensure that\n+// WF(<T as Combine<'a>>::Ty) implies T: 'a\n+trait Combine<'a> {\n+    type Ty;\n+}\n+\n+impl<'a, T: 'a> Combine<'a> for Box<T> {\n+    type Ty = &'a T;\n+}\n+\n+// ======= Wrappers ======\n+\n+// normalizes to a projection\n+struct WrapA<T>(T);\n+impl<'a, T> Combine<'a> for WrapA<T>\n+where\n+    T: Combine<'a>,\n+{\n+    type Ty = T::Ty;\n+}\n+\n+// <WrapB<T> as Combine<'a>>::Ty normalizes to a type variable ?X\n+// with constraint `<T as Combine<'a>>::Ty == ?X`\n+struct WrapB<T>(T);\n+impl<'a, X, T> Combine<'a> for WrapB<T>\n+where\n+    T: Combine<'a, Ty = X>,\n+{\n+    type Ty = X;\n+}\n+\n+// <WrapC<T> as Combine<'a>>::Ty normalizes to `&'a &'?x ()`\n+// with constraint `<T as Combine<'a>>::Ty == &'a &'?x ()`\n+struct WrapC<T>(T);\n+impl<'a, 'x: 'a, T> Combine<'a> for WrapC<T>\n+where\n+    T: Combine<'a, Ty = &'a &'x ()>,\n+{\n+    type Ty = &'a &'x ();\n+}\n+\n+//==== Test implied bounds ======\n+\n+fn test_wrap<'a, 'b, 'c1, 'c2, A, B>(\n+    _: <WrapA<Box<A>> as Combine<'a>>::Ty,        // normalized: &'a A\n+    _: <WrapB<Box<B>> as Combine<'b>>::Ty,        // normalized: &'b B\n+    _: <WrapC<Box<&'c1 ()>> as Combine<'c2>>::Ty, // normalized: &'c2 &'c1 ()\n+) {\n+    None::<&'a A>;\n+    None::<&'b B>;\n+    None::<&'c2 &'c1 ()>;\n+}\n+\n+fn main() {}"}, {"sha": "b9f1de7ec13a538d625a1902d88e44cf729514a2", "filename": "tests/ui/marker_trait_attr/overlap-marker-trait-with-static-lifetime.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,4 +1,8 @@\n-// check-pass\n+// known-bug: #89515\n+//\n+// The trait solver cannot deal with ambiguous marker trait impls\n+// if there are lifetimes involved. As we must not special-case any\n+// regions this does not work, even with 'static\n #![feature(marker_trait_attr)]\n \n #[marker]"}, {"sha": "fe4de540b513af95e7db0c76e780c0b5e7a532a3", "filename": "tests/ui/marker_trait_attr/overlap-marker-trait-with-static-lifetime.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.stderr?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -0,0 +1,31 @@\n+error[E0283]: type annotations needed: cannot satisfy `&'static (): Marker`\n+  --> $DIR/overlap-marker-trait-with-static-lifetime.rs:11:17\n+   |\n+LL | impl Marker for &'static () {}\n+   |                 ^^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&'static (): Marker` found\n+  --> $DIR/overlap-marker-trait-with-static-lifetime.rs:11:1\n+   |\n+LL | impl Marker for &'static () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl Marker for &'static () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0283]: type annotations needed: cannot satisfy `&'static (): Marker`\n+  --> $DIR/overlap-marker-trait-with-static-lifetime.rs:12:17\n+   |\n+LL | impl Marker for &'static () {}\n+   |                 ^^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&'static (): Marker` found\n+  --> $DIR/overlap-marker-trait-with-static-lifetime.rs:11:1\n+   |\n+LL | impl Marker for &'static () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl Marker for &'static () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "97a814f51eec58278b8e4a1d155148cf1919d00d", "filename": "tests/ui/marker_trait_attr/overlapping-impl-1-modulo-regions.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.rs?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -1,9 +1,17 @@\n-// check-pass\n+// known-bug: #109481\n+//\n+// While the `T: Copy` is always applicable when checking\n+// that the impl `impl<T: Copy> F for T {}` is well formed,\n+// the old trait solver can only approximate this by checking\n+// that there are no inference variables in the obligation and\n+// no region constraints in the evaluation result.\n+//\n+// Because of this we end up with ambiguity here.\n #![feature(marker_trait_attr)]\n \n #[marker]\n pub trait F {}\n-impl<T> F for T where T: Copy {}\n-impl<T> F for T where T: 'static {}\n+impl<T: Copy> F for T {}\n+impl<T: 'static> F for T {}\n \n fn main() {}"}, {"sha": "e713d1451cfd2762867271ddf3bca44c9ff9c7fb", "filename": "tests/ui/marker_trait_attr/overlapping-impl-1-modulo-regions.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/478cbb42b730ba4739351b72ce2aa928e78e2f81/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.stderr?ref=478cbb42b730ba4739351b72ce2aa928e78e2f81", "patch": "@@ -0,0 +1,14 @@\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/overlapping-impl-1-modulo-regions.rs:14:21\n+   |\n+LL | impl<T: Copy> F for T {}\n+   |                     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl<T: Copy + 'static> F for T {}\n+   |              +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0310`."}]}