{"sha": "3c872e2dc70cf20b5ac7c5ced4191824cd64bd2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjODcyZTJkYzcwY2YyMGI1YWM3YzVjZWQ0MTkxODI0Y2Q2NGJkMmM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-05-03T23:42:54Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-05-03T23:42:54Z"}, "message": "review comments: move logic to their own methods", "tree": {"sha": "3cb793e8dad71fdd70a06fe0fcad1534af995994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cb793e8dad71fdd70a06fe0fcad1534af995994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c872e2dc70cf20b5ac7c5ced4191824cd64bd2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c872e2dc70cf20b5ac7c5ced4191824cd64bd2c", "html_url": "https://github.com/rust-lang/rust/commit/3c872e2dc70cf20b5ac7c5ced4191824cd64bd2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c872e2dc70cf20b5ac7c5ced4191824cd64bd2c/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de3b4d4dae5bc9f55a6ed1b56b6caf98711b2a7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/de3b4d4dae5bc9f55a6ed1b56b6caf98711b2a7d", "html_url": "https://github.com/rust-lang/rust/commit/de3b4d4dae5bc9f55a6ed1b56b6caf98711b2a7d"}], "stats": {"total": 276, "additions": 139, "deletions": 137}, "files": [{"sha": "22f576db08d13c277da2eae6a8b757292bbd6f3e", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 139, "deletions": 137, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/3c872e2dc70cf20b5ac7c5ced4191824cd64bd2c/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c872e2dc70cf20b5ac7c5ced4191824cd64bd2c/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=3c872e2dc70cf20b5ac7c5ced4191824cd64bd2c", "patch": "@@ -5,7 +5,7 @@ use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span};\n use rustc_target::spec::abi;\n \n@@ -616,26 +616,11 @@ impl<T> Trait<T> for X {\n         // We don't want to suggest calling an assoc fn in a scope where that isn't feasible.\n         let callable_scope = match body_owner {\n             Some(\n-                hir::Node::Item(hir::Item {\n-                    kind:\n-                        hir::ItemKind::Trait(..)\n-                        | hir::ItemKind::Impl { .. }\n-                        | hir::ItemKind::Const(..)\n-                        | hir::ItemKind::Enum(..)\n-                        | hir::ItemKind::Struct(..)\n-                        | hir::ItemKind::Union(..),\n-                    ..\n-                })\n-                | hir::Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..),\n-                    ..\n-                })\n-                | hir::Node::ImplItem(hir::ImplItem {\n-                    kind: hir::ImplItemKind::Const(..) | hir::ImplItemKind::TyAlias(..),\n-                    ..\n-                }),\n-            ) => false,\n-            _ => true,\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n+                | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n+                | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n+            ) => true,\n+            _ => false,\n         };\n         let impl_comparison = matches!(\n             cause_code,\n@@ -649,112 +634,20 @@ impl<T> Trait<T> for X {\n             // type error is a comparison of an `impl` with its `trait` or when the\n             // scope is outside of a `Body`.\n         } else {\n-            let items = self.associated_items(assoc.container.id());\n-            // Find all the methods in the trait that could be called to construct the\n-            // expected associated type.\n-            // FIXME: consider suggesting the use of associated `const`s.\n-            let methods: Vec<(Span, String)> = items\n-                .items\n-                .iter()\n-                .filter(|(name, item)| {\n-                    ty::AssocKind::Fn == item.kind && Some(**name) != current_method_ident\n-                })\n-                .filter_map(|(_, item)| {\n-                    let method = self.fn_sig(item.def_id);\n-                    match method.output().skip_binder().kind {\n-                        ty::Projection(ty::ProjectionTy { item_def_id, .. })\n-                            if item_def_id == proj_ty.item_def_id =>\n-                        {\n-                            Some((\n-                                self.sess.source_map().guess_head_span(self.def_span(item.def_id)),\n-                                format!(\"consider calling `{}`\", self.def_path_str(item.def_id)),\n-                            ))\n-                        }\n-                        _ => None,\n-                    }\n-                })\n-                .collect();\n-            if !methods.is_empty() {\n-                // Use a single `help:` to show all the methods in the trait that can\n-                // be used to construct the expected associated type.\n-                let mut span: MultiSpan =\n-                    methods.iter().map(|(sp, _)| *sp).collect::<Vec<Span>>().into();\n-                let msg = format!(\n-                    \"{some} method{s} {are} available that return{r} `{ty}`\",\n-                    some = if methods.len() == 1 { \"a\" } else { \"some\" },\n-                    s = pluralize!(methods.len()),\n-                    are = if methods.len() == 1 { \"is\" } else { \"are\" },\n-                    r = if methods.len() == 1 { \"s\" } else { \"\" },\n-                    ty = values.expected\n-                );\n-                for (sp, label) in methods.into_iter() {\n-                    span.push_span_label(sp, label);\n-                }\n-                db.span_help(span, &msg);\n-                suggested = true;\n-            }\n+            suggested |= self.point_at_methods_that_satisfy_associated_type(\n+                db,\n+                assoc.container.id(),\n+                current_method_ident,\n+                proj_ty.item_def_id,\n+                values.expected,\n+            );\n             // Possibly suggest constraining the associated type to conform to the\n             // found type.\n             suggested |=\n                 self.suggest_constraint(db, &msg, body_owner_def_id, proj_ty, values.found);\n         }\n-        if let (Some(hir_id), false) =\n-            (body_owner_def_id.as_local().map(|id| self.hir().as_local_hir_id(id)), suggested)\n-        {\n-            // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n-            // `expected` and point at it.\n-            let parent_id = self.hir().get_parent_item(hir_id);\n-            let item = self.hir().find(parent_id);\n-            debug!(\"expected_projection parent item {:?}\", item);\n-            match item {\n-                Some(hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Trait(.., items), ..\n-                })) => {\n-                    // FIXME: account for `#![feature(specialization)]`\n-                    for item in &items[..] {\n-                        match item.kind {\n-                            hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n-                                if self.type_of(self.hir().local_def_id(item.id.hir_id))\n-                                    == values.found\n-                                {\n-                                    if let hir::Defaultness::Default { has_value: true } =\n-                                        item.defaultness\n-                                    {\n-                                        db.span_label(\n-                                            item.span,\n-                                            \"associated type defaults can't be assumed inside the \\\n-                                                trait defining them\",\n-                                        );\n-                                    } else {\n-                                        db.span_label(item.span, \"expected this associated type\");\n-                                    }\n-                                    suggested = true;\n-                                }\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-                Some(hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Impl { items, .. },\n-                    ..\n-                })) => {\n-                    for item in &items[..] {\n-                        match item.kind {\n-                            hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n-                                if self.type_of(self.hir().local_def_id(item.id.hir_id))\n-                                    == values.found\n-                                {\n-                                    db.span_label(item.span, \"expected this associated type\");\n-                                    suggested = true;\n-                                }\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            }\n+        if !suggested {\n+            suggested = self.point_at_associated_type(db, body_owner_def_id, values.found);\n         }\n         if let ty::Opaque(def_id, _) = proj_ty.self_ty().kind {\n             // When the expected `impl Trait` is not defined in the current item, it will come from\n@@ -800,6 +693,121 @@ fn foo(&self) -> Self::T { String::new() }\n         }\n     }\n \n+    fn point_at_methods_that_satisfy_associated_type(\n+        &self,\n+        db: &mut DiagnosticBuilder<'_>,\n+        assoc_container_id: DefId,\n+        current_method_ident: Option<Symbol>,\n+        proj_ty_item_def_id: DefId,\n+        expected: Ty<'tcx>,\n+    ) -> bool {\n+        let items = self.associated_items(assoc_container_id);\n+        // Find all the methods in the trait that could be called to construct the\n+        // expected associated type.\n+        // FIXME: consider suggesting the use of associated `const`s.\n+        let methods: Vec<(Span, String)> = items\n+            .items\n+            .iter()\n+            .filter(|(name, item)| {\n+                ty::AssocKind::Fn == item.kind && Some(**name) != current_method_ident\n+            })\n+            .filter_map(|(_, item)| {\n+                let method = self.fn_sig(item.def_id);\n+                match method.output().skip_binder().kind {\n+                    ty::Projection(ty::ProjectionTy { item_def_id, .. })\n+                        if item_def_id == proj_ty_item_def_id =>\n+                    {\n+                        Some((\n+                            self.sess.source_map().guess_head_span(self.def_span(item.def_id)),\n+                            format!(\"consider calling `{}`\", self.def_path_str(item.def_id)),\n+                        ))\n+                    }\n+                    _ => None,\n+                }\n+            })\n+            .collect();\n+        if !methods.is_empty() {\n+            // Use a single `help:` to show all the methods in the trait that can\n+            // be used to construct the expected associated type.\n+            let mut span: MultiSpan =\n+                methods.iter().map(|(sp, _)| *sp).collect::<Vec<Span>>().into();\n+            let msg = format!(\n+                \"{some} method{s} {are} available that return{r} `{ty}`\",\n+                some = if methods.len() == 1 { \"a\" } else { \"some\" },\n+                s = pluralize!(methods.len()),\n+                are = if methods.len() == 1 { \"is\" } else { \"are\" },\n+                r = if methods.len() == 1 { \"s\" } else { \"\" },\n+                ty = expected\n+            );\n+            for (sp, label) in methods.into_iter() {\n+                span.push_span_label(sp, label);\n+            }\n+            db.span_help(span, &msg);\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn point_at_associated_type(\n+        &self,\n+        db: &mut DiagnosticBuilder<'_>,\n+        body_owner_def_id: DefId,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        let hir_id = match body_owner_def_id.as_local().map(|id| self.hir().as_local_hir_id(id)) {\n+            Some(hir_id) => hir_id,\n+            None => return false,\n+        };\n+        // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n+        // `expected` and point at it.\n+        let parent_id = self.hir().get_parent_item(hir_id);\n+        let item = self.hir().find(parent_id);\n+        debug!(\"expected_projection parent item {:?}\", item);\n+        match item {\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Trait(.., items), .. })) => {\n+                // FIXME: account for `#![feature(specialization)]`\n+                for item in &items[..] {\n+                    match item.kind {\n+                        hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n+                            if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n+                                if let hir::Defaultness::Default { has_value: true } =\n+                                    item.defaultness\n+                                {\n+                                    db.span_label(\n+                                        item.span,\n+                                        \"associated type defaults can't be assumed inside the \\\n+                                            trait defining them\",\n+                                    );\n+                                } else {\n+                                    db.span_label(item.span, \"expected this associated type\");\n+                                }\n+                                return true;\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            Some(hir::Node::Item(hir::Item {\n+                kind: hir::ItemKind::Impl { items, .. }, ..\n+            })) => {\n+                for item in &items[..] {\n+                    match item.kind {\n+                        hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n+                            if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n+                                db.span_label(item.span, \"expected this associated type\");\n+                                return true;\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        false\n+    }\n+\n     /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n     /// requirement, provide a strucuted suggestion to constrain it to a given type `ty`.\n     fn constrain_generic_bound_associated_type_structured_suggestion(\n@@ -812,22 +820,16 @@ fn foo(&self) -> Self::T { String::new() }\n         msg: &str,\n     ) -> bool {\n         // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n-        for bound in bounds {\n-            match bound {\n-                hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => {\n-                    // Relate the type param against `T` in `<A as T>::Foo`.\n-                    if ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id)\n-                        && self.constrain_associated_type_structured_suggestion(\n-                            db, ptr.span, assoc, ty, msg,\n-                        )\n-                    {\n-                        return true;\n-                    }\n-                }\n-                _ => {}\n+        bounds.iter().any(|bound| match bound {\n+            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => {\n+                // Relate the type param against `T` in `<A as T>::Foo`.\n+                ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id)\n+                    && self.constrain_associated_type_structured_suggestion(\n+                        db, ptr.span, assoc, ty, msg,\n+                    )\n             }\n-        }\n-        false\n+            _ => false,\n+        })\n     }\n \n     /// Given a span corresponding to a bound, provide a structured suggestion to set an"}]}