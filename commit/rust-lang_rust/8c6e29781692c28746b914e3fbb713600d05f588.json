{"sha": "8c6e29781692c28746b914e3fbb713600d05f588", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNmUyOTc4MTY5MmMyODc0NmI5MTRlM2ZiYjcxMzYwMGQwNWY1ODg=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2019-11-11T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2019-11-13T16:59:42Z"}, "message": "compiletest: Obtain timestamps for common inputs only once\n\nObtain timestamps for common inputs (e.g., libraries in run-lib path, or\nsources in `src/tool/compiletest/`) only once and reuse the result,\ninstead of repeating the work for each test case.\n\nNo functional changes intended.", "tree": {"sha": "028f8fa6dff43795d33ff839ae559131af76936d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/028f8fa6dff43795d33ff839ae559131af76936d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c6e29781692c28746b914e3fbb713600d05f588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c6e29781692c28746b914e3fbb713600d05f588", "html_url": "https://github.com/rust-lang/rust/commit/8c6e29781692c28746b914e3fbb713600d05f588", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c6e29781692c28746b914e3fbb713600d05f588/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "695fe965173795f9242dfcad6d1c07d7a17b106a", "url": "https://api.github.com/repos/rust-lang/rust/commits/695fe965173795f9242dfcad6d1c07d7a17b106a", "html_url": "https://github.com/rust-lang/rust/commit/695fe965173795f9242dfcad6d1c07d7a17b106a"}], "stats": {"total": 157, "additions": 87, "deletions": 70}, "files": [{"sha": "241a1aeec6e8b882a84a2052dac7102b87297756", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 87, "deletions": 70, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/8c6e29781692c28746b914e3fbb713600d05f588/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6e29781692c28746b914e3fbb713600d05f588/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=8c6e29781692c28746b914e3fbb713600d05f588", "patch": "@@ -574,22 +574,59 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n \n pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n     debug!(\"making tests from {:?}\", config.src_base.display());\n+    let inputs = common_inputs_stamp(config);\n     let mut tests = Vec::new();\n     collect_tests_from_dir(\n         config,\n         &config.src_base,\n         &config.src_base,\n         &PathBuf::new(),\n+        &inputs,\n         &mut tests,\n     ).unwrap();\n     tests\n }\n \n+/// Returns a stamp constructed from input files common to all test cases.\n+fn common_inputs_stamp(config: &Config) -> Stamp {\n+    let rust_src_dir = config\n+        .find_rust_src_root()\n+        .expect(\"Could not find Rust source root\");\n+\n+    let mut stamp = Stamp::from_path(&config.rustc_path);\n+\n+    // Relevant pretty printer files\n+    let pretty_printer_files = [\n+        \"src/etc/debugger_pretty_printers_common.py\",\n+        \"src/etc/gdb_load_rust_pretty_printers.py\",\n+        \"src/etc/gdb_rust_pretty_printing.py\",\n+        \"src/etc/lldb_batchmode.py\",\n+        \"src/etc/lldb_rust_formatters.py\",\n+    ];\n+    for file in &pretty_printer_files {\n+        let path = rust_src_dir.join(file);\n+        stamp.add_path(&path);\n+    }\n+\n+    stamp.add_dir(&config.run_lib_path);\n+\n+    if let Some(ref rustdoc_path) = config.rustdoc_path {\n+        stamp.add_path(&rustdoc_path);\n+        stamp.add_path(&rust_src_dir.join(\"src/etc/htmldocck.py\"));\n+    }\n+\n+    // Compiletest itself.\n+    stamp.add_dir(&rust_src_dir.join(\"src/tools/compiletest/\"));\n+\n+    stamp\n+}\n+\n fn collect_tests_from_dir(\n     config: &Config,\n     base: &Path,\n     dir: &Path,\n     relative_dir_path: &Path,\n+    inputs: &Stamp,\n     tests: &mut Vec<test::TestDescAndFn>,\n ) -> io::Result<()> {\n     // Ignore directories that contain a file named `compiletest-ignore-dir`.\n@@ -602,7 +639,7 @@ fn collect_tests_from_dir(\n             file: dir.to_path_buf(),\n             relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n         };\n-        tests.extend(make_test(config, &paths));\n+        tests.extend(make_test(config, &paths, inputs));\n         return Ok(());\n     }\n \n@@ -627,12 +664,14 @@ fn collect_tests_from_dir(\n                 file: file_path,\n                 relative_dir: relative_dir_path.to_path_buf(),\n             };\n-            tests.extend(make_test(config, &paths))\n+            tests.extend(make_test(config, &paths, inputs))\n         } else if file_path.is_dir() {\n             let relative_file_path = relative_dir_path.join(file.file_name());\n             if &file_name != \"auxiliary\" {\n                 debug!(\"found directory: {:?}\", file_path.display());\n-                collect_tests_from_dir(config, base, &file_path, &relative_file_path, tests)?;\n+                collect_tests_from_dir(\n+                    config, base, &file_path, &relative_file_path,\n+                    inputs, tests)?;\n             }\n         } else {\n             debug!(\"found other file/directory: {:?}\", file_path.display());\n@@ -655,7 +694,7 @@ pub fn is_test(file_name: &OsString) -> bool {\n     !invalid_prefixes.iter().any(|p| file_name.starts_with(p))\n }\n \n-pub fn make_test(config: &Config, testpaths: &TestPaths) -> Vec<test::TestDescAndFn> {\n+fn make_test(config: &Config, testpaths: &TestPaths, inputs: &Stamp) -> Vec<test::TestDescAndFn> {\n     let early_props = if config.mode == Mode::RunMake {\n         // Allow `ignore` directives to be in the Makefile.\n         EarlyProps::from_file(config, &testpaths.file.join(\"Makefile\"))\n@@ -685,19 +724,20 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> Vec<test::TestDescAn\n     revisions\n         .into_iter()\n         .map(|revision| {\n-            // Debugging emscripten code doesn't make sense today\n             let ignore = early_props.ignore == Ignore::Ignore\n-                || !up_to_date(\n-                    config,\n-                    testpaths,\n-                    &early_props,\n-                    revision.map(|s| s.as_str()),\n-                )\n+                // Debugging emscripten code doesn't make sense today\n                 || ((config.mode == DebugInfoGdbLldb || config.mode == DebugInfoCdb ||\n                      config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n                     && config.target.contains(\"emscripten\"))\n                 || (config.mode == DebugInfoGdb && !early_props.ignore.can_run_gdb())\n-                || (config.mode == DebugInfoLldb && !early_props.ignore.can_run_lldb());\n+                || (config.mode == DebugInfoLldb && !early_props.ignore.can_run_lldb())\n+                || !is_outdated(\n+                    config,\n+                    testpaths,\n+                    &early_props,\n+                    revision.map(|s| s.as_str()),\n+                    inputs,\n+                );\n             test::TestDescAndFn {\n                 desc: test::TestDesc {\n                     name: make_test_name(config, testpaths, revision),\n@@ -716,11 +756,12 @@ fn stamp(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> Path\n     output_base_dir(config, testpaths, revision).join(\"stamp\")\n }\n \n-fn up_to_date(\n+fn is_outdated(\n     config: &Config,\n     testpaths: &TestPaths,\n     props: &EarlyProps,\n     revision: Option<&str>,\n+    inputs: &Stamp,\n ) -> bool {\n     let stamp_name = stamp(config, testpaths, revision);\n     // Check hash.\n@@ -735,79 +776,55 @@ fn up_to_date(\n     }\n \n     // Check timestamps.\n-    let rust_src_dir = config\n-        .find_rust_src_root()\n-        .expect(\"Could not find Rust source root\");\n-    let stamp = Stamp::from_path(&stamp_name);\n-    let mut inputs = vec![Stamp::from_path(&testpaths.file), Stamp::from_path(&config.rustc_path)];\n-    inputs.extend(\n-        props\n-            .aux\n-            .iter()\n-            .map(|aux| {\n-                Stamp::from_path(&testpaths.file.parent().unwrap().join(\"auxiliary\").join(aux))\n-            }),\n-    );\n-    // Relevant pretty printer files\n-    let pretty_printer_files = [\n-        \"src/etc/debugger_pretty_printers_common.py\",\n-        \"src/etc/gdb_load_rust_pretty_printers.py\",\n-        \"src/etc/gdb_rust_pretty_printing.py\",\n-        \"src/etc/lldb_batchmode.py\",\n-        \"src/etc/lldb_rust_formatters.py\",\n-    ];\n-    inputs.extend(pretty_printer_files.iter().map(|pretty_printer_file| {\n-        Stamp::from_path(&rust_src_dir.join(pretty_printer_file))\n-    }));\n-    inputs.extend(Stamp::from_dir(&config.run_lib_path));\n-    if let Some(ref rustdoc_path) = config.rustdoc_path {\n-        inputs.push(Stamp::from_path(&rustdoc_path));\n-        inputs.push(Stamp::from_path(&rust_src_dir.join(\"src/etc/htmldocck.py\")));\n+    let mut inputs = inputs.clone();\n+    inputs.add_path(&testpaths.file);\n+\n+    for aux in &props.aux {\n+        let path = testpaths.file.parent()\n+            .unwrap()\n+            .join(\"auxiliary\")\n+            .join(aux);\n+        inputs.add_path(&path);\n     }\n \n     // UI test files.\n-    inputs.extend(UI_EXTENSIONS.iter().map(|extension| {\n+    for extension in UI_EXTENSIONS {\n         let path = &expected_output_path(testpaths, revision, &config.compare_mode, extension);\n-        Stamp::from_path(path)\n-    }));\n-\n-    // Compiletest itself.\n-    inputs.extend(Stamp::from_dir(&rust_src_dir.join(\"src/tools/compiletest/\")));\n+        inputs.add_path(path);\n+    }\n \n-    inputs.iter().any(|input| input > &stamp)\n+    inputs > Stamp::from_path(&stamp_name)\n }\n \n-#[derive(Debug, PartialEq, PartialOrd, Ord, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n struct Stamp {\n     time: SystemTime,\n-    file: PathBuf,\n }\n \n impl Stamp {\n-    fn from_path(p: &Path) -> Self {\n-        let time = fs::metadata(p)\n+    fn from_path(path: &Path) -> Self {\n+        let mut stamp = Stamp { time: SystemTime::UNIX_EPOCH };\n+        stamp.add_path(path);\n+        stamp\n+    }\n+\n+    fn add_path(&mut self, path: &Path) {\n+        let modified = fs::metadata(path)\n             .and_then(|metadata| metadata.modified())\n             .unwrap_or(SystemTime::UNIX_EPOCH);\n-\n-        Stamp {\n-            time,\n-            file: p.into(),\n-        }\n+        self.time = self.time.max(modified);\n     }\n \n-    fn from_dir(path: &Path) -> impl Iterator<Item = Stamp> {\n-        WalkDir::new(path)\n-            .into_iter()\n-            .map(|entry| entry.unwrap())\n-            .filter(|entry| entry.file_type().is_file())\n-            .map(|entry| {\n-                let time = (|| -> io::Result<_> { entry.metadata()?.modified() })();\n-\n-                Stamp {\n-                    time: time.unwrap_or(SystemTime::UNIX_EPOCH),\n-                    file: entry.path().into(),\n-                }\n-            })\n+    fn add_dir(&mut self, path: &Path) {\n+        for entry in WalkDir::new(path) {\n+            let entry = entry.unwrap();\n+            if entry.file_type().is_file() {\n+                let modified = entry.metadata().ok()\n+                    .and_then(|metadata| metadata.modified().ok())\n+                    .unwrap_or(SystemTime::UNIX_EPOCH);\n+                self.time = self.time.max(modified);\n+            }\n+        }\n     }\n }\n "}]}