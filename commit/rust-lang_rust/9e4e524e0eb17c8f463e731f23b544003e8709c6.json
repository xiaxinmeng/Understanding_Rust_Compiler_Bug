{"sha": "9e4e524e0eb17c8f463e731f23b544003e8709c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNGU1MjRlMGViMTdjOGY0NjNlNzMxZjIzYjU0NDAwM2U4NzA5YzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-07T05:31:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-07T05:31:23Z"}, "message": "auto merge of #20677 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "916024d35e08f0826c20654f629ec596b5cb1f14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/916024d35e08f0826c20654f629ec596b5cb1f14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e4e524e0eb17c8f463e731f23b544003e8709c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e4e524e0eb17c8f463e731f23b544003e8709c6", "html_url": "https://github.com/rust-lang/rust/commit/9e4e524e0eb17c8f463e731f23b544003e8709c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e4e524e0eb17c8f463e731f23b544003e8709c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea6f65c5f1a3f84e010d2cef02a0160804e9567a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea6f65c5f1a3f84e010d2cef02a0160804e9567a", "html_url": "https://github.com/rust-lang/rust/commit/ea6f65c5f1a3f84e010d2cef02a0160804e9567a"}, {"sha": "a64000820f0fc32be4d7535a9a92418a434fa4ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/a64000820f0fc32be4d7535a9a92418a434fa4ba", "html_url": "https://github.com/rust-lang/rust/commit/a64000820f0fc32be4d7535a9a92418a434fa4ba"}], "stats": {"total": 22743, "additions": 8950, "deletions": 13793}, "files": [{"sha": "c29f74d74181087ab05ef8f6f6e79af20fdc6670", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -43,9 +43,9 @@ impl FromStr for Mode {\n     }\n }\n \n-impl fmt::Show for Mode {\n+impl fmt::String for Mode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let msg = match *self {\n+        fmt::String::fmt(match *self {\n             CompileFail => \"compile-fail\",\n             RunFail => \"run-fail\",\n             RunPass => \"run-pass\",\n@@ -54,8 +54,13 @@ impl fmt::Show for Mode {\n             DebugInfoGdb => \"debuginfo-gdb\",\n             DebugInfoLldb => \"debuginfo-lldb\",\n             Codegen => \"codegen\",\n-        };\n-        msg.fmt(f)\n+        }, f)\n+    }\n+}\n+\n+impl fmt::Show for Mode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n     }\n }\n "}, {"sha": "e2420b0a22024848204509e849edbc066b166a78", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -9,21 +9,15 @@\n // except according to those terms.\n \n #![crate_type = \"bin\"]\n-#![feature(phase, slicing_syntax, globs, unboxed_closures)]\n+#![feature(slicing_syntax, unboxed_closures)]\n \n #![deny(warnings)]\n \n extern crate test;\n extern crate getopts;\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n extern crate log;\n-\n extern crate regex;\n \n use std::os;\n@@ -108,7 +102,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n     let matches =\n         &match getopts::getopts(args_.as_slice(), groups.as_slice()) {\n           Ok(m) => m,\n-          Err(f) => panic!(\"{}\", f)\n+          Err(f) => panic!(\"{:?}\", f)\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n@@ -127,7 +121,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         match regex::Regex::new(s) {\n             Ok(re) => Some(re),\n             Err(e) => {\n-                println!(\"failed to parse filter /{}/: {}\", s, e);\n+                println!(\"failed to parse filter /{}/: {:?}\", s, e);\n                 panic!()\n             }\n         }\n@@ -186,11 +180,11 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n pub fn log_config(config: &Config) {\n     let c = config;\n     logv(c, format!(\"configuration:\"));\n-    logv(c, format!(\"compile_lib_path: {}\", config.compile_lib_path));\n-    logv(c, format!(\"run_lib_path: {}\", config.run_lib_path));\n-    logv(c, format!(\"rustc_path: {}\", config.rustc_path.display()));\n-    logv(c, format!(\"src_base: {}\", config.src_base.display()));\n-    logv(c, format!(\"build_base: {}\", config.build_base.display()));\n+    logv(c, format!(\"compile_lib_path: {:?}\", config.compile_lib_path));\n+    logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n+    logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n+    logv(c, format!(\"src_base: {:?}\", config.src_base.display()));\n+    logv(c, format!(\"build_base: {:?}\", config.build_base.display()));\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n     logv(c, format!(\"mode: {}\", config.mode));\n     logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n@@ -206,10 +200,10 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"jit: {}\", config.jit));\n     logv(c, format!(\"target: {}\", config.target));\n     logv(c, format!(\"host: {}\", config.host));\n-    logv(c, format!(\"android-cross-path: {}\",\n+    logv(c, format!(\"android-cross-path: {:?}\",\n                     config.android_cross_path.display()));\n-    logv(c, format!(\"adb_path: {}\", config.adb_path));\n-    logv(c, format!(\"adb_test_dir: {}\", config.adb_test_dir));\n+    logv(c, format!(\"adb_path: {:?}\", config.adb_path));\n+    logv(c, format!(\"adb_test_dir: {:?}\", config.adb_test_dir));\n     logv(c, format!(\"adb_device_status: {}\",\n                     config.adb_device_status));\n     match config.test_shard {\n@@ -271,7 +265,7 @@ pub fn run_tests(config: &Config) {\n         Ok(true) => {}\n         Ok(false) => panic!(\"Some tests failed\"),\n         Err(e) => {\n-            println!(\"I/O failure during tests: {}\", e);\n+            println!(\"I/O failure during tests: {:?}\", e);\n         }\n     }\n }\n@@ -299,13 +293,13 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n }\n \n pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n-    debug!(\"making tests from {}\",\n+    debug!(\"making tests from {:?}\",\n            config.src_base.display());\n     let mut tests = Vec::new();\n     let dirs = fs::readdir(&config.src_base).unwrap();\n     for file in dirs.iter() {\n         let file = file.clone();\n-        debug!(\"inspecting file {}\", file.display());\n+        debug!(\"inspecting file {:?}\", file.display());\n         if is_test(config, &file) {\n             let t = make_test(config, &file, || {\n                 match config.mode {"}, {"sha": "dcfac688c7f62cd0083c919df1bf1c55209f9522", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -84,7 +84,7 @@ fn parse_expected(last_nonfollow_error: Option<uint>,\n             (which, line)\n         };\n \n-        debug!(\"line={} which={} kind={} msg={}\", line_num, which, kind, msg);\n+        debug!(\"line={} which={:?} kind={:?} msg={:?}\", line_num, which, kind, msg);\n         Some((which, ExpectedError { line: line,\n                                      kind: kind,\n                                      msg: msg, }))"}, {"sha": "f8e2ba4828f383773acd17983a7db49636afd2e7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -61,7 +61,7 @@ pub fn run_metrics(config: Config, testfile: String, mm: &mut MetricMap) {\n         print!(\"\\n\\n\");\n     }\n     let testfile = Path::new(testfile);\n-    debug!(\"running {}\", testfile.display());\n+    debug!(\"running {:?}\", testfile.display());\n     let props = header::load_props(&testfile);\n     debug!(\"loaded props\");\n     match config.mode {\n@@ -141,7 +141,7 @@ fn check_correct_failure_status(proc_res: &ProcRes) {\n     static RUST_ERR: int = 101;\n     if !proc_res.status.matches_exit_status(RUST_ERR) {\n         fatal_proc_rec(\n-            format!(\"failure produced the wrong error: {}\",\n+            format!(\"failure produced the wrong error: {:?}\",\n                     proc_res.status).as_slice(),\n             proc_res);\n     }\n@@ -410,7 +410,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                          ],\n                          vec!((\"\".to_string(), \"\".to_string())),\n                          Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+                .expect(format!(\"failed to exec `{:?}`\", config.adb_path).as_slice());\n \n             procsrv::run(\"\",\n                          config.adb_path.as_slice(),\n@@ -422,7 +422,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                          ],\n                          vec!((\"\".to_string(), \"\".to_string())),\n                          Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+                .expect(format!(\"failed to exec `{:?}`\", config.adb_path).as_slice());\n \n             let adb_arg = format!(\"export LD_LIBRARY_PATH={}; \\\n                                    gdbserver :5039 {}/{}\",\n@@ -443,11 +443,11 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                                       vec!((\"\".to_string(),\n                                                             \"\".to_string())),\n                                                       Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+                .expect(format!(\"failed to exec `{:?}`\", config.adb_path).as_slice());\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n-                let result = Thread::spawn(move || {\n+                let result = Thread::scoped(move || {\n                     tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n                 }).join();\n                 if result.is_err() {\n@@ -481,7 +481,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                              debugger_opts.as_slice(),\n                              vec!((\"\".to_string(), \"\".to_string())),\n                              None)\n-                .expect(format!(\"failed to exec `{}`\", gdb_path).as_slice());\n+                .expect(format!(\"failed to exec `{:?}`\", gdb_path).as_slice());\n             let cmdline = {\n                 let cmdline = make_cmdline(\"\",\n                                            \"arm-linux-androideabi-gdb\",\n@@ -539,18 +539,17 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             script_str.push_str(\"set print pretty off\\n\");\n \n             // Add the pretty printer directory to GDB's source-file search path\n-            script_str.push_str(format!(\"directory {}\\n\", rust_pp_module_abs_path)[]);\n+            script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path)[]);\n \n             // Load the target executable\n-            script_str.push_str(format!(\"file {}\\n\",\n-                                        exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))\n-                                    .as_slice());\n+            script_str.push_str(&format!(\"file {}\\n\",\n+                                         exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))[]);\n \n             // Add line breakpoints\n             for line in breakpoint_lines.iter() {\n-                script_str.push_str(format!(\"break '{}':{}\\n\",\n-                                            testfile.filename_display(),\n-                                            *line)[]);\n+                script_str.push_str(&format!(\"break '{:?}':{}\\n\",\n+                                             testfile.filename_display(),\n+                                             *line)[]);\n             }\n \n             script_str.push_str(cmds.as_slice());\n@@ -676,7 +675,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                                                .unwrap()\n                                                .to_string();\n \n-    script_str.push_str(format!(\"command script import {}\\n\", rust_pp_module_abs_path[])[]);\n+    script_str.push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[])[]);\n     script_str.push_str(\"type summary add --no-value \");\n     script_str.push_str(\"--python-function lldb_rust_formatters.print_val \");\n     script_str.push_str(\"-x \\\".*\\\" --category Rust\\n\");\n@@ -889,7 +888,7 @@ fn check_error_patterns(props: &TestProps,\n                         output_to_check: &str,\n                         proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(format!(\"no error pattern specified in {}\",\n+        fatal(format!(\"no error pattern specified in {:?}\",\n                       testfile.display()).as_slice());\n     }\n     let mut next_err_idx = 0u;\n@@ -910,7 +909,7 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns =\n-        props.error_patterns[next_err_idx..];\n+        props.error_patterns.index(&(next_err_idx..));\n     if missing_patterns.len() == 1u {\n         fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]).as_slice(),\n@@ -955,7 +954,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        format!(\"{}:{}:\", testfile.display(), ee.line)\n+        format!(\"{:?}:{}:\", testfile.display(), ee.line)\n     }).collect::<Vec<String> >();\n \n     #[cfg(windows)]\n@@ -1191,7 +1190,7 @@ fn compose_and_run_compiler(\n                                      None);\n         if !auxres.status.success() {\n             fatal_proc_rec(\n-                format!(\"auxiliary build of {} failed to compile: \",\n+                format!(\"auxiliary build of {:?} failed to compile: \",\n                         abs_ab.display()).as_slice(),\n                 &auxres);\n         }\n@@ -1601,7 +1600,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n \n             if config.verbose {\n-                println!(\"push ({}) {} {} {}\",\n+                println!(\"push ({}) {:?} {} {}\",\n                     config.target, file.display(),\n                     copy_result.out, copy_result.err);\n             }"}, {"sha": "d241e77f810c70f61361c2a69927ca29773a0914", "filename": "src/doc/guide-error-handling.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fguide-error-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fguide-error-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-error-handling.md?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -167,10 +167,10 @@ fn parse_version(header: &[u8]) -> Result<Version, ParseError> {\n let version = parse_version(&[1, 2, 3, 4]);\n match version {\n     Ok(v) => {\n-        println!(\"working with version: {}\", v);\n+        println!(\"working with version: {:?}\", v);\n     }\n     Err(e) => {\n-        println!(\"error parsing header: {}\", e);\n+        println!(\"error parsing header: {:?}\", e);\n     }\n }\n ```"}, {"sha": "95f5305775eedfa1147db08d02b35ffc7ed74498", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -42,17 +42,17 @@ the pattern in the above code:\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n macro_rules! early_return {\n-    ($inp:expr $sp:path) => ( // invoke it like `(input_5 SpecialE)`\n+    ($inp:expr, $sp:path) => ( // invoke it like `(input_5 SpecialE)`\n         match $inp {\n             $sp(x) => { return x; }\n             _ => {}\n         }\n     );\n }\n // ...\n-early_return!(input_1 T::SpecialA);\n+early_return!(input_1, T::SpecialA);\n // ...\n-early_return!(input_2 T::SpecialB);\n+early_return!(input_2, T::SpecialB);\n # return 0;\n # }\n # fn main() {}\n@@ -161,7 +161,7 @@ instead of `*` to mean \"at least one\".\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n macro_rules! early_return {\n-    ($inp:expr, [ $($sp:path)|+ ]) => (\n+    ($inp:expr, [ $($sp:path),+ ]) => (\n         match $inp {\n             $(\n                 $sp(x) => { return x; }\n@@ -171,7 +171,7 @@ macro_rules! early_return {\n     )\n }\n // ...\n-early_return!(input_1, [T::SpecialA|T::SpecialC|T::SpecialD]);\n+early_return!(input_1, [T::SpecialA,T::SpecialC,T::SpecialD]);\n // ...\n early_return!(input_2, [T::SpecialB]);\n # return 0;\n@@ -245,7 +245,7 @@ can solve the problem:\n ~~~~\n macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n+    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n       binds $bind_res:ident\n     ) => (\n         let $bind_res = match $e {\n@@ -254,7 +254,7 @@ macro_rules! biased_match {\n         };\n     );\n     // more than one name; use a tuple\n-    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n+    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n       binds $( $bind_res:ident ),*\n     ) => (\n         let ( $( $bind_res ),* ) = match $e {\n@@ -268,9 +268,9 @@ macro_rules! biased_match {\n # struct T2 { body: T3 }\n # enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n-biased_match!((x)       ~ (T1::Good1(g1, val)) else { return 0 };\n+biased_match!((x)       -> (T1::Good1(g1, val)) else { return 0 };\n               binds g1, val );\n-biased_match!((g1.body) ~ (T3::Good2(result) )\n+biased_match!((g1.body) -> (T3::Good2(result) )\n                   else { panic!(\"Didn't get good_2\") };\n               binds result );\n // complicated stuff goes here\n@@ -286,7 +286,7 @@ pattern we want is clear:\n ~~~~\n # fn main() {}\n # macro_rules! b {\n-    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n       binds $( $bind_res:ident ),*\n     )\n # => (0) }\n@@ -317,8 +317,8 @@ input patterns:\n ~~~~\n # fn main() {}\n # macro_rules! b {\n-    (    ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n-      $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n+    (    ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n+      $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     )\n # => (0) }\n@@ -333,14 +333,14 @@ piece of syntax (the `let`) which we only want to transcribe once.\n \n macro_rules! biased_match_rec {\n     // Handle the first layer\n-    (   ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n-     $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n+    (   ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n+     $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n      binds $( $bind_res:ident ),*\n     ) => (\n         match $e {\n             $p => {\n                 // Recursively handle the next layer\n-                biased_match_rec!($( ($e_rest) ~ ($p_rest) else $err_rest ; )*\n+                biased_match_rec!($( ($e_rest) -> ($p_rest) else $err_rest ; )*\n                                   binds $( $bind_res ),*\n                 )\n             }\n@@ -354,20 +354,20 @@ macro_rules! biased_match_rec {\n // Wrap the whole thing in a `let`.\n macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n       binds $bind_res:ident\n     ) => (\n         let $bind_res = biased_match_rec!(\n-            $( ($e) ~ ($p) else $err ; )*\n+            $( ($e) -> ($p) else $err ; )*\n             binds $bind_res\n         );\n     );\n     // more than one name: use a tuple\n-    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     ) => (\n         let ( $( $bind_res ),* ) = biased_match_rec!(\n-            $( ($e) ~ ($p) else $err ; )*\n+            $( ($e) -> ($p) else $err ; )*\n             binds $( $bind_res ),*\n         );\n     )\n@@ -379,8 +379,8 @@ macro_rules! biased_match {\n # enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n biased_match!(\n-    (x)       ~ (T1::Good1(g1, val)) else { return 0 };\n-    (g1.body) ~ (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n+    (x)       -> (T1::Good1(g1, val)) else { return 0 };\n+    (g1.body) -> (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n     binds val, result );\n // complicated stuff goes here\n return result + val;"}, {"sha": "14e33ab0f74a9edfdb4ca90a345e5158bbc4e8d1", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -620,7 +620,7 @@ enum List<T> {\n \n fn main() {\n     let list: List<int> = List::Cons(1, box List::Cons(2, box List::Cons(3, box List::Nil)));\n-    println!(\"{}\", list);\n+    println!(\"{:?}\", list);\n }\n ```\n "}, {"sha": "11bc0bc30f20ee863fb614b1376da2786fcc4e4a", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -703,10 +703,10 @@ Other features provided by lang items include:\n   `deref`, and `add` respectively.\n - stack unwinding and general failure; the `eh_personality`, `fail`\n   and `fail_bounds_checks` lang items.\n-- the traits in `std::kinds` used to indicate types that satisfy\n+- the traits in `std::markers` used to indicate types of\n   various kinds; lang items `send`, `sync` and `copy`.\n - the marker types and variance indicators found in\n-  `std::kinds::markers`; lang items `covariant_type`,\n+  `std::markers`; lang items `covariant_type`,\n   `contravariant_lifetime`, `no_sync_bound`, etc.\n \n Lang items are loaded lazily by the compiler; e.g. if one never uses"}, {"sha": "fbc96a577a41acc43c237f2d951c53869ff8d544", "filename": "src/doc/intro.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -395,7 +395,7 @@ fn main() {\n     for _ in range(0u, 10u) {\n         Thread::spawn(move || {\n             println!(\"Hello, world!\");\n-        }).detach();\n+        });\n     }\n }\n ```\n@@ -405,8 +405,7 @@ This program creates ten threads, who all print `Hello, world!`. The\n double bars `||`. (The `move` keyword indicates that the closure takes\n ownership of any data it uses; we'll have more on the significance of\n this shortly.) This closure is executed in a new thread created by\n-`spawn`. The `detach` method means that the child thread is allowed to\n-outlive its parent.\n+`spawn`.\n \n One common form of problem in concurrent programs is a 'data race.'\n This occurs when two different threads attempt to access the same\n@@ -429,7 +428,7 @@ fn main() {\n     for i in range(0u, 3u) {\n         Thread::spawn(move || {\n             for j in range(0, 3) { numbers[j] += 1 }\n-        }).detach();\n+        });\n     }\n }\n ```\n@@ -488,7 +487,7 @@ fn main() {\n             (*array)[i] += 1;\n \n             println!(\"numbers[{}] is {}\", i, (*array)[i]);\n-        }).detach();\n+        });\n     }\n }\n ```"}, {"sha": "a907f096809e6b4774627a225863d184d3d25f2b", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -690,10 +690,9 @@ balanced, but they are otherwise not special.\n \n In the matcher, `$` _name_ `:` _designator_ matches the nonterminal in the Rust\n syntax named by _designator_. Valid designators are `item`, `block`, `stmt`,\n-`pat`, `expr`, `ty` (type), `ident`, `path`, `matchers` (lhs of the `=>` in\n-macro rules), `tt` (rhs of the `=>` in macro rules). In the transcriber, the\n-designator is already known, and so only the name of a matched nonterminal\n-comes after the dollar sign.\n+`pat`, `expr`, `ty` (type), `ident`, `path`, `tt` (either side of the `=>`\n+in macro rules). In the transcriber, the designator is already known, and so\n+only the name of a matched nonterminal comes after the dollar sign.\n \n In both the matcher and transcriber, the Kleene star-like operator indicates\n repetition. The Kleene star operator consists of `$` and parens, optionally"}, {"sha": "b6770c99975f13caf0f178e07533e6bdc2dbf021", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -51,7 +51,7 @@ def rust_pretty_printer_lookup_function(val):\n     enum_member_count = len(enum_members)\n \n     if enum_member_count == 0:\n-      return RustStructPrinter(val, false)\n+      return RustStructPrinter(val, False)\n \n     if enum_member_count == 1:\n       first_variant_name = enum_members[0].name\n@@ -60,21 +60,27 @@ def rust_pretty_printer_lookup_function(val):\n         return rust_pretty_printer_lookup_function(val[enum_members[0]])\n       else:\n         assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n-        # This is a space-optimized enum\n+        # This is a space-optimized enum.\n+        # This means this enum has only two states, and Rust uses one of the\n+        # fields somewhere in the struct to determine which of the two states\n+        # it's in. The location of the field is encoded in the name as something\n+        # like RUST$ENCODED$ENUM$(num$)*name_of_zero_state\n         last_separator_index = first_variant_name.rfind(\"$\")\n-        second_last_separator_index = first_variant_name.rfind(\"$\", 0, last_separator_index)\n-        disr_field_index = first_variant_name[second_last_separator_index + 1 :\n-                                              last_separator_index]\n-        disr_field_index = int(disr_field_index)\n+        start_index = len(\"RUST$ENCODED$ENUM$\")\n+        disr_field_indices = first_variant_name[start_index :\n+                                              last_separator_index].split(\"$\")\n+        disr_field_indices = [int(index) for index in disr_field_indices]\n \n         sole_variant_val = val[enum_members[0]]\n-        disr_field = get_field_at_index(sole_variant_val, disr_field_index)\n-        discriminant = sole_variant_val[disr_field]\n+        discriminant = sole_variant_val\n+        for disr_field_index in disr_field_indices:\n+          disr_field = get_field_at_index(discriminant, disr_field_index)\n+          discriminant = discriminant[disr_field]\n \n         # If the discriminant field is a fat pointer we have to consider the\n         # first word as the true discriminant\n         if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n-            discriminant = discriminant[get_field_at_index(discriminant, 0)]\n+          discriminant = discriminant[get_field_at_index(discriminant, 0)]\n \n         if discriminant == 0:\n           null_variant_name = first_variant_name[last_separator_index + 1:]\n@@ -234,4 +240,5 @@ def get_field_at_index(val, index):\n   for field in val.type.fields():\n     if i == index:\n       return field\n+    i += 1\n   return None"}, {"sha": "05d71902904b46b5ee3b9eecf92d3e9595a70b0c", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -79,11 +79,11 @@ def print_struct_val_starting_from(field_start_index, val, internal_dict):\n   has_field_names = type_has_field_names(t)\n \n   if has_field_names:\n-      template = \"%(type_name)s {\\n%(body)s\\n}\"\n-      separator = \", \\n\"\n+    template = \"%(type_name)s {\\n%(body)s\\n}\"\n+    separator = \", \\n\"\n   else:\n-      template = \"%(type_name)s(%(body)s)\"\n-      separator = \", \"\n+    template = \"%(type_name)s(%(body)s)\"\n+    separator = \", \"\n \n   if type_name.startswith(\"(\"):\n     # this is a tuple, so don't print the type name\n@@ -125,25 +125,25 @@ def print_enum_val(val, internal_dict):\n       if last_separator_index == -1:\n         return \"<invalid enum encoding: %s>\" % first_variant_name\n \n-      second_last_separator_index = first_variant_name.rfind(\"$\", 0, last_separator_index)\n-      if second_last_separator_index == -1:\n-        return \"<invalid enum encoding: %s>\" % first_variant_name\n+      start_index = len(\"RUST$ENCODED$ENUM$\")\n \n-      # Extract index of the discriminator field\n+      # Extract indices of the discriminator field\n       try:\n-        disr_field_index = first_variant_name[second_last_separator_index + 1 :\n-                                              last_separator_index]\n-        disr_field_index = int(disr_field_index)\n+        disr_field_indices = first_variant_name[start_index :\n+                                              last_separator_index].split(\"$\")\n+        disr_field_indices = [int(index) for index in disr_field_indices]\n       except:\n         return \"<invalid enum encoding: %s>\" % first_variant_name\n \n       # Read the discriminant\n-      disr_val = val.GetChildAtIndex(0).GetChildAtIndex(disr_field_index)\n+      disr_val = val.GetChildAtIndex(0)\n+      for index in disr_field_indices:\n+        disr_val = disr_val.GetChildAtIndex(index)\n \n       # If the discriminant field is a fat pointer we have to consider the\n       # first word as the true discriminant\n       if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n-          disr_val = disr_val.GetChildAtIndex(0)\n+        disr_val = disr_val.GetChildAtIndex(0)\n \n       if disr_val.GetValueAsUnsigned() == 0:\n         # Null case: Print the name of the null-variant"}, {"sha": "404f622f970c37f237bed5fd51a79964889b192b", "filename": "src/etc/zsh/_rust", "status": "modified", "additions": 93, "deletions": 69, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fetc%2Fzsh%2F_rust", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fetc%2Fzsh%2F_rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fzsh%2F_rust?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -20,63 +20,71 @@ _rustc_crate_types=(\n \n _rustc_emit_types=(\n     'asm'\n-    'bc'\n-    'ir'\n+    'llvm-bc'\n+    'llvm-ir'\n     'obj'\n     'link'\n+    'dep-info'\n )\n _rustc_pretty_types=(\n     'normal[un-annotated source]'\n     'expanded[crates expanded]'\n     'typed[crates  expanded,  with  type  annotations]'\n     'identified[fully parenthesized, AST nodes and blocks with IDs]'\n-    'flowgraph=[graphviz formatted flowgraph for node]:NODEID:'\n+    'flowgraph[graphviz formatted flowgraph for node]:NODEID:'\n )\n _rustc_color_types=(\n     'auto[colorize, if output goes to a tty (default)]'\n     'always[always colorize output]'\n     'never[never colorize output]'\n )\n+_rustc_info_types=(\n+    'crate-name[Output the crate name and exit]'\n+    'file-names[Output the file(s) that would be written if compilation continued and exited]'\n+    'sysroot[Output the sysroot and exit]'\n+)\n \n _rustc_opts_vals=(\n     --crate-name='[Specify the name of the crate being built]'\n     --crate-type='[Comma separated list of types of crates for the compiler to emit]:TYPES:_values -s \",\" \"Crate types\"  \"$_rustc_crate_types[@]\"'\n     --emit='[Comma separated list of types of output for the compiler to emit]:TYPES:_values -s \",\" \"Emit Targets\" \"$_rustc_emit_types[@]\"'\n-    --debuginfo='[Emit DWARF debug info to the objects created]:LEVEL:_values \"Debug Levels\" \"$_rustc_debuginfo_levels[@]\"'\n-    --dep-info='[Output dependency info to <filename> after compiling]::FILE:_files -/'\n-    --sysroot='[Override the system root]:PATH:_files -/'\n     --cfg='[Configure the compilation environment]:SPEC:'\n     --out-dir='[Write output to compiler-chosen filename in <dir>.  Ignored  if  -o  is  specified. (default the current directory)]:DIR:_files -/'\n     -o'[Write output to <filename>. Ignored if more than one --emit is specified.]:FILENAME:_files'\n-    --opt-level='[Optimize with possible levels 0-3]:LEVEL:(0 1 2 3)'\n     --pretty='[Pretty-print the input instead of compiling]::TYPE:_values \"TYPES\" \"$_rustc_pretty_types[@]\"'\n     -L'[Add a directory to the library search path]:DIR:_files -/'\n     --target='[Target triple cpu-manufacturer-kernel\\[-os\\] to compile]:TRIPLE:'\n     --color='[Configure coloring of output]:CONF:_values \"COLORS\" \"$_rustc_color_types[@]\"'\n     {-v,--version}'[Print version info and exit]::VERBOSE:(verbose)'\n     --explain='[Provide a detailed explanation of an error message]:OPT:'\n     --extern'[Specify where an external rust library is located]:ARG:'\n+    --print='[Comma separated list of compiler information to print on stdout]:TYPES:_values -s \",\" \"Compiler Information\" \"$_rustc_info_types[@]\"'\n )\n \n _rustc_opts_switches=(\n-    -g'[Equivalent to --debuginfo=2]'\n-    {-h,--help}'[Display this message]'\n-    --no-analysis'[Parse and expand the output, but run no analysis or produce output]'\n-    --no-trans'[Run all passes except translation; no output]'\n-    -O'[Equivalent to --opt-level=2]'\n-    --parse-only'[Parse only; do not compile, assemble, or link]'\n-    --print-crate-name'[Output the crate name and exit]'\n-    --print-file-name'[Output the file(s) that would be written if compilation continued and exit]'\n+    -g'[Equivalent to -C debuginfo=2]'\n+    {-h,--help}'[Display the help message]'\n+    {-V,--verbose}'[use verbose output]'\n+    -O'[Equivalent to -C opt-level=2]'\n     --test'[Build a test harness]'\n )\n+\n+\n+_rustc_opts_link=(\n+    'static[Path to the library to link statically]:PATH:_files -/'\n+    'dylib[Path to the library to link dynamically]:PATH:_files -/'\n+    'framework[Path to the library to link as a framework]:PATH:_files -/'\n+)\n+\n _rustc_opts_codegen=(\n-    'ar=[Path to the archive utility to use when assembling archives.]:BIN:_path_files'\n-    'linker=[Path to the linker utility to use when linking libraries, executables, and objects.]:BIN:_path_files'\n-    'link-args=[A space-separated list of extra arguments to pass to the linker when the linker is invoked.]:ARGS:'\n-    'target-cpu=[Selects a target processor. If the value is \"help\", then a list of  available  CPUs is printed.]:CPU:'\n-    'target-feature=[A space-separated list of features to enable or disable for the target. A preceding \"+\" enables a feature while a preceding \"-\" disables it. Available features can be discovered through target-cpu=help.]:FEATURE:'\n-    'passes=[A space-separated list of extra LLVM passes to run. A value of \"list\" will cause rustc to print all known passes and exit. The passes specified are appended at the end of the normal pass manager.]:LIST:'\n-    'llvm-args=[A space-separated list of arguments to pass through to LLVM.]:ARGS:'\n+    'ar[Path to the archive utility to use when assembling archives.]:BIN:_path_files'\n+    'linker[Path to the linker utility to use when linking libraries, executables, and objects.]:BIN:_path_files'\n+    'link-args[A space-separated list of extra arguments to pass to the linker when the linker is invoked.]:ARGS:'\n+    'lto[Perform LLVM link-time optimizations]'\n+    'target-cpu[Selects a target processor. If the value is \"help\", then a list of  available  CPUs is printed.]:CPU:'\n+    'target-feature[A space-separated list of features to enable or disable for the target. A preceding \"+\" enables a feature while a preceding \"-\" disables it. Available features can be discovered through target-cpu=help.]:FEATURE:'\n+    'passes[A space-separated list of extra LLVM passes to run. A value of \"list\" will cause rustc to print all known passes and exit. The passes specified are appended at the end of the normal pass manager.]:LIST:'\n+    'llvm-args[A space-separated list of arguments to pass through to LLVM.]:ARGS:'\n     'save-temps[If specified, the compiler will save more files (.bc, .o, .no-opt.bc) generated throughout compilation in the output directory.]'\n     'rpath[If specified, then the rpath value for dynamic libraries will be set in either dynamic library or executable outputs.]'\n     'no-prepopulate-passes[Suppresses pre-population of the LLVM pass manager that is run over the module.]'\n@@ -86,55 +94,62 @@ _rustc_opts_codegen=(\n     'prefer-dynamic[Prefers dynamic linking to static linking.]'\n     \"no-integrated-as[Force usage of an external assembler rather than LLVM's integrated one.]\"\n     'no-redzone[disable the use of the redzone]'\n-    'relocation-model=[The relocation model to use. (default: pic)]:MODEL:(pic static dynamic-no-pic)'\n-    'code-model=[choose the code model to use (llc -code-model for details)]:MODEL:'\n-    'metadata=[metadata to mangle symbol names with]:VAL:'\n-    'extra-filenames=[extra data to put in each output filename]:VAL:'\n-    'codegen-units=[divide crate into N units to optimize in parallel]:N:'\n+    'relocation-model[The relocation model to use. (default: pic)]:MODEL:(pic static dynamic-no-pic)'\n+    'code-model[choose the code model to use (llc -code-model for details)]:MODEL:'\n+    'metadata[metadata to mangle symbol names with]:VAL:'\n+    'extra-filenames[extra data to put in each output filename]:VAL:'\n+    'codegen-units[divide crate into N units to optimize in parallel]:N:'\n+    'remark[print remarks for these optimization passes (space separated, or \"all\")]:TYPE:'\n+    'debuginfo[debug info emission level, 0 = no debug info, 1 = line tables only, 2 = full debug info with variable and type information]:LEVEL:_values \"Debug Levels\" \"$_rustc_debuginfo_levels[@]\"'\n+    'opt-level[Optimize with possible levels 0-3]:LEVEL:(0 1 2 3)'\n     'help[Show all codegen options]'\n )\n \n _rustc_opts_lint=(\n     'help[Show a list of all lints]'\n-    'experimental[detects use of #\\[experimental\\] items]'\n-    'heap-memory[use of any (Box type or @ type) heap memory]'\n-    'managed-heap-memory[use of managed (@ type) heap memory]'\n-    'missing-doc[detects missing documentation for public members]'\n-    'non-uppercase-statics[static constants should have uppercase identifiers]'\n-    'owned-heap-memory[use of owned (~ type) heap memory]'\n-    'unnecessary-qualification[detects unnecessarily qualified names]'\n-    'unsafe-block[usage of an `unsafe` block]'\n-    'unstable[detects use of #\\[unstable\\] items (incl. items with no stability attribute)]'\n-    'unused-result[unused result of an expression in a statement]'\n-    'variant-size-difference[detects enums with widely varying variant sizes]'\n-    'ctypes[proper use of libc types in foreign modules]'\n-    'dead-assignment[detect assignments that will never be read]'\n-    'dead-code[detect piece of code that will never be used]'\n-    'deprecated[detects use of #\\[deprecated\\] items]'\n-    'non-camel-case-types[types, variants and traits should have camel case names]'\n-    'non-snake-case[methods, functions, lifetime parameters and modules should have snake case names]'\n-    'path-statement[path statements with no effect]'\n-    'raw-pointer-deriving[uses of #\\[deriving\\] with raw pointers are rarely correct]'\n-    'type-limits[comparisons made useless by limits of the types involved]'\n-    'type-overflow[literal out of range for its type]'\n-    'unnecessary-allocation[detects unnecessary allocations that can be eliminated]'\n-    'unnecessary-parens[`if`, `match`, `while` and `return` do not need parentheses]'\n-    'unreachable-code[detects unreachable code]'\n-    'unrecognized-lint[unrecognized lint attribute]'\n-    'unsigned-negate[using an unary minus operator on unsigned type]'\n-    'unused-attribute[detects attributes that were not used by the compiler]'\n-    'unused-imports[imports that are never used]'\n-    'unused-must-use[unused result of a type flagged as #\\[must_use\\]]'\n-    \"unused-mut[detect mut variables which don't need to be mutable]\"\n-    'unused-unsafe[unnecessary use of an `unsafe` block]'\n-    'unused-variable[detect variables which are not used in any way]'\n-    'visible-private-types[detect use of private types in exported type signatures]'\n-    'warnings[mass-change the level for lints which produce warnings]'\n-    'while-true[suggest using `loop { }` instead of `while true { }`]'\n-    'unknown-crate-type[unknown crate type found in #\\[crate_type\\] directive]'\n-    'unknown-features[unknown features found in crate-level #\\[feature\\] directives]'\n-    'bad-style[group of non_camel_case_types, non_snake_case, non_uppercase_statics]'\n-    'unused[group of unused_imports, unused_variable, dead_assignment, dead_code, unused_mut, unreachable_code]'\n+    'box-pointers[(default: allow) use of owned (Box type) heap memory]'\n+    'experimental[(default: allow) detects use of #\\[experimental\\] items]'\n+    'fat-ptr-transmutes[(default: allow) detects transmutes of fat pointers]'\n+    'missing-docs[(default: allow) detects missing documentation for public members]'\n+    'unsafe-blocks[(default: allow) usage of an \"unsafe\" block]'\n+    'unstable[(default: allow) detects use of #\\[unstable\\] items (incl. items with no stability attribute)]'\n+    'unused-extern-crates[(default: allow) extern crates that are never used]'\n+    'unused-import-braces[(default: allow) unnecessary braces around an imported item]'\n+    'unused-qualifications[(default: allow) detects unnecessarily qualified names]'\n+    'unused-results[(default: allow) unused result of an expression in a statement]'\n+    'unused-typecasts[(default: allow) detects unnecessary type casts that can be removed]'\n+    'variant-size-differences[(default: allow) detects enums with widely varying variant sizes]'\n+    'dead-code[(default: warn) detect unused, unexported items]'\n+    'deprecated[(default: warn) detects use of #\\[deprecated\\] items]'\n+    'improper-ctypes[(default: warn) proper use of libc types in foreign modules]'\n+    'missing-copy-implementations[(default: warn) detects potentially-forgotten implementations of \"Copy\"]'\n+    'non-camel-case-types[(default: warn) types, variants, traits and type parameters should have camel case names]'\n+    'non-shorthand-field-patterns[(default: warn) using \"Struct { x: x }\" instead of \"Struct { x }\"]'\n+    'non-snake-case[(default: warn) methods, functions, lifetime parameters and modules should have snake case names]'\n+    'non-upper-case-globals[(default: warn) static constants should have uppercase identifiers]'\n+    'overflowing-literals[(default: warn) literal out of range for its type]'\n+    'path-statements[(default: warn) path statements with no effect]'\n+    'raw-pointer-deriving[(default: warn) uses of #\\[derive\\] with raw pointers are rarely correct]'\n+    'unknown-lints[(default: warn) unrecognized lint attribute]'\n+    'unreachable-code[(default: warn) detects unreachable code paths]'\n+    'unsigned-negation[(default: warn) using an unary minus operator on unsigned type]'\n+    'unused-allocation[(default: warn) detects unnecessary allocations that can be eliminated]'\n+    'unused-assignments[(default: warn) detect assignments that will never be read]'\n+    'unused-attributes[(default: warn) detects attributes that were not used by the compiler]'\n+    'unused-comparisons[(default: warn) comparisons made useless by limits of the types involved]'\n+    'unused-imports[(default: warn) imports that are never used]'\n+    'unused-must-use[(default: warn) unused result of a type flagged as must_use]'\n+    \"unused-mut[(default: warn) detect mut variables which don't need to be mutable]\"\n+    'unused-parens[(default: warn) \"if\", \"match\", \"while\" and \"return\" do not need parentheses]'\n+    'unused-unsafe[(default: warn) unnecessary use of an \"unsafe\" block]'\n+    'unused-variables[(default: warn) detect variables which are not used in any way]'\n+    'warnings[(default: warn) mass-change the level for lints which produce warnings]'\n+    'while-true[(default: warn) suggest using \"loop { }\" instead of \"while true { }\"]'\n+    \"exceeding-bitshifts[(default: deny) shift exceeds the type's number of bits]\"\n+    'unknown-crate-types[(default: deny) unknown crate type found in #\\[crate_type\\] directive]'\n+    'unknown-features[(default: deny) unknown features found in crate-level #\\[feature\\] directives]'\n+    'bad-style[non-camel-case-types, non-snake-case, non-upper-case-globals]'\n+    'unused[unused-imports, unused-variables, unused-assignments, dead-code, unused-mut, unreachable-code, unused-must-use, unused-unsafe, path-statements]'\n )\n \n _rustc_opts_debug=(\n@@ -151,11 +166,9 @@ _rustc_opts_debug=(\n     'show-span[show spans for compiler debugging]'\n     'count-type-sizes[count the sizes of aggregate types]'\n     'meta-stats[gather metadata statistics]'\n-    'no-opt[do not optimize, even if -O is passed]'\n     'print-link-args[Print the arguments passed to the linker]'\n     'gc[Garbage collect shared data (experimental)]'\n     'print-llvm-passes[Prints the llvm optimization passes being run]'\n-    'lto[Perform LLVM link-time optimizations]'\n     'ast-json[Print the AST as JSON and halt]'\n     'ast-json-noexpand[Print the pre-expansion AST as JSON and halt]'\n     'ls[List the symbols defined by a library crate]'\n@@ -164,6 +177,12 @@ _rustc_opts_debug=(\n     'flowgraph-print-moves[Include move analysis data in --pretty flowgraph output]'\n     'flowgraph-print-assigns[Include assignment analysis data in --pretty flowgraph output]'\n     'flowgraph-print-all[Include all dataflow analysis data in --pretty flowgraph output]'\n+    'print-regiion-graph[Prints region inference graph. Use with RUST_REGION_GRAPH=help for more info]'\n+    'parse-only[Parse only; do not compile, assemble, or link]'\n+    'no-trans[Run all passes except translation; no output]'\n+    'no-analysis[Parse and expand the source, but run no analysis]'\n+    'unstable-options[Adds unstable command line options to rustc interface]'\n+    'print-enum-sizes[Print the size of enums and their variants]'\n )\n \n _rustc_opts_fun_lint(){\n@@ -179,13 +198,18 @@ _rustc_opts_fun_codegen(){\n     _values 'options' \"$_rustc_opts_codegen[@]\"\n }\n \n+_rustc_opts_fun_link(){\n+    _values 'options' \"$_rustc_opts_link[@]\"\n+}\n+\n _arguments -s :  \\\n     '(-W --warn)'{-W,--warn=}'[Set lint warnings]:lint options:_rustc_opts_fun_lint' \\\n     '(-A --allow)'{-A,--allow=}'[Set lint allowed]:lint options:_rustc_opts_fun_lint' \\\n     '(-D --deny)'{-D,--deny=}'[Set lint denied]:lint options:_rustc_opts_fun_lint' \\\n     '(-F --forbid)'{-F,--forbid=}'[Set lint forbidden]:lint options:_rustc_opts_fun_lint' \\\n     '*-Z[Set internal debugging options]:debug options:_rustc_opts_fun_debug' \\\n-    '*-C[Set internal Codegen options]:codegen options:_rustc_opts_fun_codegen' \\\n+    '(-C --codegen)'{-C,--codegen}'[Set internal Codegen options]:codegen options:_rustc_opts_fun_codegen' \\\n+    '*-l[Link the generated crates to the specified native library NAME. the optional KIND can be one of, static, dylib, or framework. If omitted, dylib is assumed.]:ARG:_rustc_opts_fun_link' \\\n     \"$_rustc_opts_switches[@]\" \\\n     \"$_rustc_opts_vals[@]\" \\\n     '::files:_files -g \"*.rs\"'"}, {"sha": "8def8ad7215284b759b7a91a7de2c12234f9d5c5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -41,8 +41,8 @@\n //!     let five = five.clone();\n //!\n //!     Thread::spawn(move || {\n-//!         println!(\"{}\", five);\n-//!     }).detach();\n+//!         println!(\"{:?}\", five);\n+//!     });\n //! }\n //! ```\n //!\n@@ -63,7 +63,7 @@\n //!         *number += 1;\n //!\n //!         println!(\"{}\", *number); // prints 6\n-//!     }).detach();\n+//!     });\n //! }\n //! ```\n \n@@ -74,7 +74,7 @@ use core::clone::Clone;\n use core::fmt::{self, Show};\n use core::cmp::{Eq, Ord, PartialEq, PartialOrd, Ordering};\n use core::default::Default;\n-use core::kinds::{Sync, Send};\n+use core::marker::{Sync, Send};\n use core::mem::{min_align_of, size_of, drop};\n use core::mem;\n use core::nonzero::NonZero;\n@@ -106,7 +106,7 @@ use heap::deallocate;\n ///             let local_numbers = child_numbers.as_slice();\n ///\n ///             // Work with the local numbers\n-///         }).detach();\n+///         });\n ///     }\n /// }\n /// ```\n@@ -581,7 +581,7 @@ impl<T: Eq> Eq for Arc<T> {}\n \n impl<T: fmt::Show> fmt::Show for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n+        write!(f, \"Arc({:?})\", (**self))\n     }\n }\n \n@@ -794,7 +794,7 @@ mod tests {\n     #[test]\n     fn show_arc() {\n         let a = Arc::new(5u32);\n-        assert!(format!(\"{}\", a) == \"5\")\n+        assert!(format!(\"{:?}\", a) == \"Arc(5u32)\")\n     }\n \n     // Make sure deriving works with Arc<T>"}, {"sha": "d46f18abf97b481f781225bc42b7d291cc399f37", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -18,7 +18,7 @@ use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::kinds::Sized;\n+use core::marker::Sized;\n use core::mem;\n use core::option::Option;\n use core::ptr::Unique;\n@@ -145,7 +145,13 @@ impl BoxAny for Box<Any> {\n \n impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n+        write!(f, \"Box({:?})\", &**self)\n+    }\n+}\n+\n+impl<T: ?Sized + fmt::String> fmt::String for Box<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(&**self, f)\n     }\n }\n "}, {"sha": "ba6e89cdd768e5016ec408f43c7206e00fa41876", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -65,36 +65,16 @@\n \n #![no_std]\n #![allow(unknown_features)]\n-#![feature(lang_items, phase, unsafe_destructor, default_type_params, old_orphan_check)]\n-#![feature(associated_types)]\n+#![feature(lang_items, unsafe_destructor)]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate core;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n extern crate core;\n-\n extern crate libc;\n \n // Allow testing this library\n \n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate std;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate std;\n-\n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate log;\n+#[cfg(test)] #[macro_use] extern crate std;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n // Heaps provided for low-level allocation strategies\n "}, {"sha": "67b254277101229ae9d8bab6de237e4fc28cf90d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -148,7 +148,7 @@ use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::kinds::marker;\n+use core::marker;\n use core::mem::{transmute, min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n@@ -607,7 +607,7 @@ impl<S: hash::Writer, T: Hash<S>> Hash<S> for Rc<T> {\n #[experimental = \"Show is experimental.\"]\n impl<T: fmt::Show> fmt::Show for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n+        write!(f, \"Rc({:?})\", **self)\n     }\n }\n \n@@ -962,4 +962,10 @@ mod tests {\n         assert!(cow1_weak.upgrade().is_none());\n     }\n \n+    #[test]\n+    fn test_show() {\n+        let foo = Rc::new(75u);\n+        assert!(format!(\"{:?}\", foo) == \"Rc(75u)\")\n+    }\n+\n }"}, {"sha": "2154d06377a198913632f25f5ec58e90300e3572", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -143,17 +143,17 @@ static FALSE: bool = false;\n /// bv.set(3, true);\n /// bv.set(5, true);\n /// bv.set(7, true);\n-/// println!(\"{}\", bv.to_string());\n+/// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n ///\n /// // flip all values in bitvector, producing non-primes less than 10\n /// bv.negate();\n-/// println!(\"{}\", bv.to_string());\n+/// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n ///\n /// // reset bitvector to empty\n /// bv.clear();\n-/// println!(\"{}\", bv.to_string());\n+/// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n #[stable]\n@@ -330,7 +330,7 @@ impl Bitv {\n \n         if extra_bytes > 0 {\n             let mut last_word = 0u32;\n-            for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n+            for (i, &byte) in bytes.index(&((complete_words*4)..)).iter().enumerate() {\n                 last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n             bitv.storage.push(last_word);\n@@ -1729,13 +1729,13 @@ impl BitvSet {\n \n impl fmt::Show for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"{{\"));\n+        try!(write!(fmt, \"BitvSet {{\"));\n         let mut first = true;\n         for n in self.iter() {\n             if !first {\n                 try!(write!(fmt, \", \"));\n             }\n-            try!(write!(fmt, \"{}\", n));\n+            try!(write!(fmt, \"{:?}\", n));\n             first = false;\n         }\n         write!(fmt, \"}}\")\n@@ -1881,10 +1881,10 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let zerolen = Bitv::new();\n-        assert_eq!(zerolen.to_string(), \"\");\n+        assert_eq!(format!(\"{:?}\", zerolen), \"\");\n \n         let eightbits = Bitv::from_elem(8u, false);\n-        assert_eq!(eightbits.to_string(), \"00000000\")\n+        assert_eq!(format!(\"{:?}\", eightbits), \"00000000\")\n     }\n \n     #[test]\n@@ -1910,7 +1910,7 @@ mod tests {\n         let mut b = Bitv::from_elem(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        assert_eq!(b.to_string(), \"10\");\n+        assert_eq!(format!(\"{:?}\", b), \"10\");\n         assert!(!b.none() && !b.all());\n     }\n \n@@ -2245,7 +2245,7 @@ mod tests {\n     fn test_from_bytes() {\n         let bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n         let str = concat!(\"10110110\", \"00000000\", \"11111111\");\n-        assert_eq!(bitv.to_string(), str);\n+        assert_eq!(format!(\"{:?}\", bitv), str);\n     }\n \n     #[test]\n@@ -2264,7 +2264,7 @@ mod tests {\n     fn test_from_bools() {\n         let bools = vec![true, false, true, true];\n         let bitv: Bitv = bools.iter().map(|n| *n).collect();\n-        assert_eq!(bitv.to_string(), \"1011\");\n+        assert_eq!(format!(\"{:?}\", bitv), \"1011\");\n     }\n \n     #[test]\n@@ -2622,7 +2622,7 @@ mod bitv_set_test {\n         s.insert(10);\n         s.insert(50);\n         s.insert(2);\n-        assert_eq!(\"{1, 2, 10, 50}\", s.to_string());\n+        assert_eq!(\"BitvSet {1u, 2u, 10u, 50u}\", format!(\"{:?}\", s));\n     }\n \n     #[test]"}, {"sha": "4e44779810b29257aa88309e5e2ee7c5f0f569f0", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -19,7 +19,7 @@ pub use self::Entry::*;\n \n use core::prelude::*;\n \n-use core::borrow::{BorrowFrom, ToOwned};\n+use core::borrow::BorrowFrom;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Show;\n@@ -128,24 +128,24 @@ pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n-#[stable]\n /// A view into a single entry in a map, which may either be vacant or occupied.\n-pub enum Entry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n+#[unstable = \"precise API still under development\"]\n+pub enum Entry<'a, K:'a, V:'a> {\n     /// A vacant Entry\n-    Vacant(VacantEntry<'a, Q, K, V>),\n+    Vacant(VacantEntry<'a, K, V>),\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n }\n \n-#[stable]\n /// A vacant Entry.\n-pub struct VacantEntry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n-    key: &'a Q,\n+#[unstable = \"precise API still under development\"]\n+pub struct VacantEntry<'a, K:'a, V:'a> {\n+    key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n-#[stable]\n /// An occupied Entry.\n+#[unstable = \"precise API still under development\"]\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n@@ -480,7 +480,7 @@ enum Continuation<A, B> {\n /// boilerplate gets cut out.\n mod stack {\n     use core::prelude::*;\n-    use core::kinds::marker;\n+    use core::marker;\n     use core::mem;\n     use core::ops::{Deref, DerefMut};\n     use super::BTreeMap;\n@@ -866,11 +866,11 @@ impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n #[stable]\n impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n+        try!(write!(f, \"BTreeMap {{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}: {}\", *k, *v));\n+            try!(write!(f, \"{:?}: {:?}\", *k, *v));\n         }\n \n         write!(f, \"}}\")\n@@ -933,7 +933,7 @@ enum StackOp<T> {\n }\n \n impl<K, V, E, T> Iterator for AbsIter<T> where\n-    T: DoubleEndedIterator + Iterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n+    T: DoubleEndedIterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n {\n     type Item = (K, V);\n \n@@ -1002,7 +1002,7 @@ impl<K, V, E, T> Iterator for AbsIter<T> where\n }\n \n impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n-    T: DoubleEndedIterator + Iterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n+    T: DoubleEndedIterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n {\n     // next_back is totally symmetric to next\n     fn next_back(&mut self) -> Option<(K, V)> {\n@@ -1111,55 +1111,55 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n #[stable]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n-impl<'a, Q: ?Sized, K: Ord, V> Entry<'a, Q, K, V> {\n+impl<'a, K: Ord, V> Entry<'a, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n             Occupied(entry) => Ok(entry.into_mut()),\n             Vacant(entry) => Err(entry),\n         }\n     }\n }\n \n-impl<'a, Q: ?Sized + ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n-    #[stable]\n+impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn insert(self, value: V) -> &'a mut V {\n-        self.stack.insert(self.key.to_owned(), value)\n+        self.stack.insert(self.key, value)\n     }\n }\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n-    #[stable]\n     /// Gets a reference to the value in the entry.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn get(&self) -> &V {\n         self.stack.peek()\n     }\n \n-    #[stable]\n     /// Gets a mutable reference to the value in the entry.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.stack.peek_mut()\n     }\n \n-    #[stable]\n     /// Converts the entry into a mutable reference to its value.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn into_mut(self) -> &'a mut V {\n         self.stack.into_top()\n     }\n \n-    #[stable]\n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, mut value: V) -> V {\n         mem::swap(self.stack.peek_mut(), &mut value);\n         value\n     }\n \n-    #[stable]\n     /// Takes the value of the entry out of the map, and returns it.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn remove(self) -> V {\n         self.stack.remove()\n     }\n@@ -1347,7 +1347,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// // count the number of occurrences of letters in the vec\n     /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"].iter() {\n-    ///     match count.entry(x) {\n+    ///     match count.entry(*x) {\n     ///         Entry::Vacant(view) => {\n     ///             view.insert(1);\n     ///         },\n@@ -1361,15 +1361,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3u);\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n-    #[stable]\n-    pub fn entry<'a, Q: ?Sized>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n-        where Q: Ord + ToOwned<K>\n-    {\n+    #[unstable = \"precise API still under development\"]\n+    pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                return match Node::search(node, key) {\n+                return match Node::search(node, &key) {\n                     Found(handle) => {\n                         // Perfect match\n                         Finished(Occupied(OccupiedEntry {\n@@ -1412,7 +1410,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use std::borrow::{ToOwned, BorrowFrom};\n+    use std::borrow::BorrowFrom;\n \n     use super::{BTreeMap, Occupied, Vacant};\n \n@@ -1562,7 +1560,7 @@ mod test {\n         let mut map: BTreeMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         // Existing key (insert)\n-        match map.entry(&1) {\n+        match map.entry(1) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 assert_eq!(view.get(), &10);\n@@ -1574,7 +1572,7 @@ mod test {\n \n \n         // Existing key (update)\n-        match map.entry(&2) {\n+        match map.entry(2) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 let v = view.get_mut();\n@@ -1585,7 +1583,7 @@ mod test {\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n-        match map.entry(&3) {\n+        match map.entry(3) {\n             Vacant(_) => unreachable!(),\n             Occupied(view) => {\n                 assert_eq!(view.remove(), 30);\n@@ -1596,7 +1594,7 @@ mod test {\n \n \n         // Inexistent key (insert)\n-        match map.entry(&10) {\n+        match map.entry(10) {\n             Occupied(_) => unreachable!(),\n             Vacant(view) => {\n                 assert_eq!(*view.insert(1000), 1000);"}, {"sha": "82d8dc286ee45d13cc84d45541e775dba0142e2f", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -493,7 +493,7 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n ///     // Now the handle still points at index 75, but on the small node, which has no index 75.\n ///     flag.set(true);\n ///\n-///     println!(\"Uninitialized memory: {}\", handle.into_kv());\n+///     println!(\"Uninitialized memory: {:?}\", handle.into_kv());\n /// }\n /// ```\n #[derive(Copy)]\n@@ -1417,7 +1417,7 @@ pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a,\n /// An owning traversal over a node's entries and edges\n pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;\n \n-\n+#[old_impl_check]\n impl<K, V, E, Impl: TraversalImpl<K, V, E>> Iterator for AbsTraversal<Impl> {\n     type Item = TraversalItem<K, V, E>;\n \n@@ -1433,6 +1433,7 @@ impl<K, V, E, Impl: TraversalImpl<K, V, E>> Iterator for AbsTraversal<Impl> {\n     }\n }\n \n+#[old_impl_check]\n impl<K, V, E, Impl: TraversalImpl<K, V, E>> DoubleEndedIterator for AbsTraversal<Impl> {\n     fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n         let tail_is_edge = self.tail_is_edge;"}, {"sha": "25df4a3cc2a6fc61d168e9dbc5e1940c87aa1905", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -556,11 +556,11 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n #[stable]\n impl<T: Show> Show for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n+        try!(write!(f, \"BTreeSet {{\"));\n \n         for (i, x) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *x));\n+            try!(write!(f, \"{:?}\", *x));\n         }\n \n         write!(f, \"}}\")\n@@ -842,9 +842,9 @@ mod test {\n         set.insert(1);\n         set.insert(2);\n \n-        let set_str = format!(\"{}\", set);\n+        let set_str = format!(\"{:?}\", set);\n \n-        assert!(set_str == \"{1, 2}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\");\n+        assert_eq!(set_str, \"BTreeSet {1i, 2i}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"BTreeSet {}\");\n     }\n }"}, {"sha": "63ea9f7cb4322dad9e791ef710fa7b822a60673d", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -663,11 +663,11 @@ impl<A: Clone> Clone for DList<A> {\n #[stable]\n impl<A: fmt::Show> fmt::Show for DList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"[\"));\n+        try!(write!(f, \"DList [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *e));\n+            try!(write!(f, \"{:?}\", *e));\n         }\n \n         write!(f, \"]\")\n@@ -924,7 +924,7 @@ mod tests {\n     #[test]\n     fn test_send() {\n         let n = list_from(&[1i,2,3]);\n-        Thread::spawn(move || {\n+        Thread::scoped(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n             assert_eq!(a, n.iter().collect::<Vec<&int>>());\n@@ -1018,12 +1018,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let list: DList<int> = range(0i, 10).collect();\n-        assert!(list.to_string() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert_eq!(format!(\"{:?}\", list), \"DList [0i, 1i, 2i, 3i, 4i, 5i, 6i, 7i, 8i, 9i]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                    .map(|&s| s)\n                                                                    .collect();\n-        assert!(list.to_string() == \"[just, one, test, more]\");\n+        assert_eq!(format!(\"{:?}\", list), \"DList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[cfg(test)]"}, {"sha": "1b852d0ba680d20a07a8b29325957e2dea95287c", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -33,13 +33,13 @@ impl<E> Copy for EnumSet<E> {}\n \n impl<E:CLike+fmt::Show> fmt::Show for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"{{\"));\n+        try!(write!(fmt, \"EnumSet {{\"));\n         let mut first = true;\n         for e in self.iter() {\n             if !first {\n                 try!(write!(fmt, \", \"));\n             }\n-            try!(write!(fmt, \"{}\", e));\n+            try!(write!(fmt, \"{:?}\", e));\n             first = false;\n         }\n         write!(fmt, \"}}\")\n@@ -287,11 +287,11 @@ mod test {\n     #[test]\n     fn test_show() {\n         let mut e = EnumSet::new();\n-        assert_eq!(\"{}\", e.to_string());\n+        assert!(format!(\"{:?}\", e) == \"EnumSet {}\");\n         e.insert(A);\n-        assert_eq!(\"{A}\", e.to_string());\n+        assert!(format!(\"{:?}\", e) == \"EnumSet {A}\");\n         e.insert(C);\n-        assert_eq!(\"{A, C}\", e.to_string());\n+        assert!(format!(\"{:?}\", e) == \"EnumSet {A, C}\");\n     }\n \n     #[test]"}, {"sha": "6eab36d8844df9372b9e55c567500c007d912bf3", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -22,41 +22,20 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, default_type_params, phase, globs)]\n #![feature(unsafe_destructor, slicing_syntax)]\n+#![feature(old_impl_check)]\n #![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n #![no_std]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate core;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n extern crate core;\n \n extern crate unicode;\n extern crate alloc;\n \n #[cfg(test)] extern crate test;\n-\n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate std;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate std;\n-\n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate log;\n+#[cfg(test)] #[macro_use] extern crate std;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n pub use binary_heap::BinaryHeap;\n pub use bitv::Bitv;\n@@ -73,8 +52,7 @@ pub use vec_map::VecMap;\n // Needed for the vec! macro\n pub use alloc::boxed;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod macros;\n \n pub mod binary_heap;\n@@ -123,7 +101,9 @@ mod std {\n     pub use core::option;   // necessary for panic!()\n     pub use core::clone;    // deriving(Clone)\n     pub use core::cmp;      // deriving(Eq, Ord, etc.)\n-    pub use core::kinds;    // deriving(Copy)\n+    #[cfg(stage0)]\n+    pub use core::marker as kinds;\n+    pub use core::marker;  // deriving(Copy)\n     pub use core::hash;     // deriving(Hash)\n }\n \n@@ -138,7 +118,7 @@ mod prelude {\n     pub use core::iter::{FromIterator, Extend, IteratorExt};\n     pub use core::iter::{Iterator, DoubleEndedIterator, RandomAccessIterator};\n     pub use core::iter::{ExactSizeIterator};\n-    pub use core::kinds::{Copy, Send, Sized, Sync};\n+    pub use core::marker::{Copy, Send, Sized, Sync};\n     pub use core::mem::drop;\n     pub use core::ops::{Drop, Fn, FnMut, FnOnce};\n     pub use core::option::Option;"}, {"sha": "68e2482964dbb87c3152b8435e92ea02c8cd183e", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -8,21 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// Creates a `std::vec::Vec` containing the arguments.\n-// NOTE: remove after the next snapshot\n-#[cfg(stage0)]\n-macro_rules! vec {\n-    ($($e:expr),*) => ({\n-        // leading _ to allow empty construction without a warning.\n-        let mut _temp = ::vec::Vec::new();\n-        $(_temp.push($e);)*\n-        _temp\n-    });\n-    ($($e:expr),+,) => (vec!($($e),+))\n-}\n-\n /// Creates a `Vec` containing the arguments.\n-#[cfg(not(stage0))]\n #[macro_export]\n macro_rules! vec {\n     ($($x:expr),*) => ({"}, {"sha": "42c17136a0882824c6c17029ff6bd5e46f28ce42", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -20,7 +20,7 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::iter::{self, repeat, FromIterator, RandomAccessIterator};\n-use core::kinds::marker;\n+use core::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n use core::ops::{Index, IndexMut};\n@@ -525,7 +525,7 @@ impl<T> RingBuf<T> {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n-    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n+    /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     #[stable]\n     pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n@@ -556,7 +556,7 @@ impl<T> RingBuf<T> {\n             let buf = self.buffer_as_slice();\n             if contiguous {\n                 let (empty, buf) = buf.split_at(0);\n-                (buf[self.tail..self.head], empty)\n+                (buf.index(&(self.tail..self.head)), empty)\n             } else {\n                 let (mid, right) = buf.split_at(self.tail);\n                 let (left, _) = mid.split_at(self.head);\n@@ -1613,11 +1613,11 @@ impl<A> Extend<A> for RingBuf<A> {\n #[stable]\n impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"[\"));\n+        try!(write!(f, \"RingBuf [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *e));\n+            try!(write!(f, \"{:?}\", *e));\n         }\n \n         write!(f, \"]\")\n@@ -1648,21 +1648,15 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_back(137);\n         assert_eq!(d.len(), 4u);\n-        debug!(\"{}\", d.front());\n         assert_eq!(*d.front().unwrap(), 42);\n-        debug!(\"{}\", d.back());\n         assert_eq!(*d.back().unwrap(), 137);\n         let mut i = d.pop_front();\n-        debug!(\"{}\", i);\n         assert_eq!(i, Some(42));\n         i = d.pop_back();\n-        debug!(\"{}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n-        debug!(\"{}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n-        debug!(\"{}\", i);\n         assert_eq!(i, Some(17));\n         assert_eq!(d.len(), 0u);\n         d.push_back(3);\n@@ -2308,12 +2302,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let ringbuf: RingBuf<int> = range(0i, 10).collect();\n-        assert!(format!(\"{}\", ringbuf) == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0i, 1i, 2i, 3i, 4i, 5i, 6i, 7i, 8i, 9i]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .map(|&s| s)\n                                                                         .collect();\n-        assert!(format!(\"{}\", ringbuf) == \"[just, one, test, more]\");\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[test]"}, {"sha": "582887ac38a532de06df7893aab234bac72fb745", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -55,7 +55,7 @@\n //! #![feature(slicing_syntax)]\n //! fn main() {\n //!     let numbers = [0i, 1i, 2i];\n-//!     let last_numbers = numbers[1..3];\n+//!     let last_numbers = numbers.index(&(1..3));\n //!     // last_numbers is now &[1i, 2i]\n //! }\n //! ```\n@@ -95,10 +95,10 @@ use core::cmp::Ordering::{self, Greater, Less};\n use core::cmp::{self, Ord, PartialEq};\n use core::iter::{Iterator, IteratorExt};\n use core::iter::{range, range_step, MultiplicativeIterator};\n-use core::kinds::Sized;\n+use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n-use core::ops::{FnMut, SliceMut};\n+use core::ops::{FnMut, FullRange, Index, IndexMut};\n use core::option::Option::{self, Some, None};\n use core::ptr::PtrExt;\n use core::ptr;\n@@ -1065,12 +1065,12 @@ impl ElementSwaps {\n \n #[unstable = \"trait is unstable\"]\n impl<T> BorrowFrom<Vec<T>> for [T] {\n-    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n+    fn borrow_from(owned: &Vec<T>) -> &[T] { owned.index(&FullRange) }\n }\n \n #[unstable = \"trait is unstable\"]\n impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.as_mut_slice_() }\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.index_mut(&FullRange) }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -1393,15 +1393,20 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n \n #[cfg(test)]\n mod tests {\n-    use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n-    use prelude::{SliceExt, Iterator, IteratorExt};\n-    use prelude::AsSlice;\n-    use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n+    use core::cmp::Ordering::{Greater, Less, Equal};\n+    use core::prelude::{Some, None, range, Clone};\n+    use core::prelude::{Iterator, IteratorExt};\n+    use core::prelude::{AsSlice};\n+    use core::prelude::{Ord, FullRange};\n     use core::default::Default;\n     use core::mem;\n+    use core::ops::Index;\n+    use std::iter::RandomAccessIterator;\n     use std::rand::{Rng, thread_rng};\n     use std::rc::Rc;\n-    use super::ElementSwaps;\n+    use string::ToString;\n+    use vec::Vec;\n+    use super::{ElementSwaps, SliceConcatExt, SliceExt};\n \n     fn square(n: uint) -> uint { n * n }\n \n@@ -1606,15 +1611,15 @@ mod tests {\n \n         // Test on stack.\n         let vec_stack: &[_] = &[1i, 2, 3];\n-        let v_b = vec_stack[1u..3u].to_vec();\n+        let v_b = vec_stack.index(&(1u..3u)).to_vec();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique[1u..6u].to_vec();\n+        let v_d = vec_unique.index(&(1u..6u)).to_vec();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n         assert_eq!(v_d[0], 2);\n@@ -1627,21 +1632,21 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec[0..], vec);\n+        assert_eq!(vec.index(&(0..)), vec);\n         let b: &[int] = &[3, 4];\n-        assert_eq!(vec[2..], b);\n+        assert_eq!(vec.index(&(2..)), b);\n         let b: &[int] = &[];\n-        assert_eq!(vec[4..], b);\n+        assert_eq!(vec.index(&(4..)), b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec[..4], vec);\n+        assert_eq!(vec.index(&(0..4)), vec);\n         let b: &[int] = &[1, 2];\n-        assert_eq!(vec[..2], b);\n+        assert_eq!(vec.index(&(0..2)), b);\n         let b: &[int] = &[];\n-        assert_eq!(vec[..0], b);\n+        assert_eq!(vec.index(&(0..0)), b);\n     }\n \n \n@@ -2466,25 +2471,25 @@ mod tests {\n         macro_rules! test_show_vec {\n             ($x:expr, $x_str:expr) => ({\n                 let (x, x_str) = ($x, $x_str);\n-                assert_eq!(format!(\"{}\", x), x_str);\n-                assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n+                assert_eq!(format!(\"{:?}\", x), x_str);\n+                assert_eq!(format!(\"{:?}\", x.as_slice()), x_str);\n             })\n         }\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\");\n-        test_show_vec!(vec![1i], \"[1]\");\n-        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\");\n+        test_show_vec!(vec![1i], \"[1i]\");\n+        test_show_vec!(vec![1i, 2, 3], \"[1i, 2i, 3i]\");\n         test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n-                       \"[[], [1], [1, 1]]\");\n+                       \"[[], [1u], [1u, 1u]]\");\n \n         let empty_mut: &mut [int] = &mut[];\n         test_show_vec!(empty_mut, \"[]\");\n         let v: &mut[int] = &mut[1];\n-        test_show_vec!(v, \"[1]\");\n+        test_show_vec!(v, \"[1i]\");\n         let v: &mut[int] = &mut[1, 2, 3];\n-        test_show_vec!(v, \"[1, 2, 3]\");\n+        test_show_vec!(v, \"[1i, 2i, 3i]\");\n         let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n-        test_show_vec!(v, \"[[], [1], [1, 1]]\");\n+        test_show_vec!(v, \"[[], [1u], [1u, 1u]]\");\n     }\n \n     #[test]\n@@ -2567,7 +2572,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v[1..3].iter() {\n+        for f in v.index(&(1..3)).iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }"}, {"sha": "09d140067f451902fe7649a84ee51df73084d8cf", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -60,7 +60,7 @@ use core::char::CharExt;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n use core::iter::{range, Iterator, IteratorExt};\n-use core::ops;\n+use core::ops::{FullRange, Index};\n use core::option::Option::{self, Some, None};\n use core::slice::AsSlice;\n use core::str as core_str;\n@@ -386,7 +386,7 @@ macro_rules! utf8_acc_cont_byte {\n \n #[unstable = \"trait is unstable\"]\n impl BorrowFrom<String> for str {\n-    fn borrow_from(owned: &String) -> &str { owned[] }\n+    fn borrow_from(owned: &String) -> &str { owned.index(&FullRange) }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -408,7 +408,7 @@ Section: Trait implementations\n \n /// Any string that can be represented as a slice.\n #[stable]\n-pub trait StrExt: ops::Slice<uint, str> {\n+pub trait StrExt: Index<FullRange, Output = str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n     #[unstable = \"return type may change to be an iterator\"]\n     fn escape_default(&self) -> String {\n@@ -464,7 +464,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self[].chars(),\n+            iter: self.index(&FullRange).chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Canonical\n@@ -477,7 +477,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self[].chars(),\n+            iter: self.index(&FullRange).chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Compatible\n@@ -525,7 +525,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn contains(&self, pat: &str) -> bool {\n-        core_str::StrExt::contains(self[], pat)\n+        core_str::StrExt::contains(self.index(&FullRange), pat)\n     }\n \n     /// Returns true if a string contains a char pattern.\n@@ -541,7 +541,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might get removed in favour of a more generic contains()\"]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n-        core_str::StrExt::contains_char(self[], pat)\n+        core_str::StrExt::contains_char(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over the characters of `self`. Note, this iterates\n@@ -555,7 +555,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(self[])\n+        core_str::StrExt::chars(self.index(&FullRange))\n     }\n \n     /// An iterator over the bytes of `self`\n@@ -568,13 +568,13 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(self[])\n+        core_str::StrExt::bytes(self.index(&FullRange))\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n     #[stable]\n     fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(self[])\n+        core_str::StrExt::char_indices(self.index(&FullRange))\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -597,7 +597,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n-        core_str::StrExt::split(self[], pat)\n+        core_str::StrExt::split(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -624,7 +624,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n-        core_str::StrExt::splitn(self[], count, pat)\n+        core_str::StrExt::splitn(self.index(&FullRange), count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -653,7 +653,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might get removed\"]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n-        core_str::StrExt::split_terminator(self[], pat)\n+        core_str::StrExt::split_terminator(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -674,7 +674,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n-        core_str::StrExt::rsplitn(self[], count, pat)\n+        core_str::StrExt::rsplitn(self.index(&FullRange), count, pat)\n     }\n \n     /// An iterator over the start and end indices of the disjoint\n@@ -699,7 +699,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might have its iterator type changed\"]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n-        core_str::StrExt::match_indices(self[], pat)\n+        core_str::StrExt::match_indices(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over the substrings of `self` separated by the pattern `sep`.\n@@ -715,7 +715,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might get removed in the future in favor of a more generic split()\"]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n-        core_str::StrExt::split_str(self[], pat)\n+        core_str::StrExt::split_str(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over the lines of a string (subsequences separated\n@@ -731,7 +731,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(self[])\n+        core_str::StrExt::lines(self.index(&FullRange))\n     }\n \n     /// An iterator over the lines of a string, separated by either\n@@ -747,7 +747,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(self[])\n+        core_str::StrExt::lines_any(self.index(&FullRange))\n     }\n \n     /// Returns a slice of the given string from the byte range\n@@ -782,7 +782,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"use slice notation [a..b] instead\"]\n     fn slice(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice(self[], begin, end)\n+        core_str::StrExt::slice(self.index(&FullRange), begin, end)\n     }\n \n     /// Returns a slice of the string from `begin` to its end.\n@@ -795,7 +795,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// See also `slice`, `slice_to` and `slice_chars`.\n     #[unstable = \"use slice notation [a..] instead\"]\n     fn slice_from(&self, begin: uint) -> &str {\n-        core_str::StrExt::slice_from(self[], begin)\n+        core_str::StrExt::slice_from(self.index(&FullRange), begin)\n     }\n \n     /// Returns a slice of the string from the beginning to byte\n@@ -809,7 +809,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// See also `slice`, `slice_from` and `slice_chars`.\n     #[unstable = \"use slice notation [0..a] instead\"]\n     fn slice_to(&self, end: uint) -> &str {\n-        core_str::StrExt::slice_to(self[], end)\n+        core_str::StrExt::slice_to(self.index(&FullRange), end)\n     }\n \n     /// Returns a slice of the string from the character range\n@@ -837,7 +837,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"may have yet to prove its worth\"]\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice_chars(self[], begin, end)\n+        core_str::StrExt::slice_chars(self.index(&FullRange), begin, end)\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -848,7 +848,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// the entire slice as well.\n     #[stable]\n     unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice_unchecked(self[], begin, end)\n+        core_str::StrExt::slice_unchecked(self.index(&FullRange), begin, end)\n     }\n \n     /// Returns true if the pattern `pat` is a prefix of the string.\n@@ -860,7 +860,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn starts_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::starts_with(self[], pat)\n+        core_str::StrExt::starts_with(self.index(&FullRange), pat)\n     }\n \n     /// Returns true if the pattern `pat` is a suffix of the string.\n@@ -872,7 +872,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn ends_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::ends_with(self[], pat)\n+        core_str::StrExt::ends_with(self.index(&FullRange), pat)\n     }\n \n     /// Returns a string with all pre- and suffixes that match\n@@ -892,7 +892,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_matches(self[], pat)\n+        core_str::StrExt::trim_matches(self.index(&FullRange), pat)\n     }\n \n     /// Returns a string with all prefixes that match\n@@ -912,7 +912,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_left_matches(self[], pat)\n+        core_str::StrExt::trim_left_matches(self.index(&FullRange), pat)\n     }\n \n     /// Returns a string with all suffixes that match\n@@ -932,7 +932,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_right_matches(self[], pat)\n+        core_str::StrExt::trim_right_matches(self.index(&FullRange), pat)\n     }\n \n     /// Check that `index`-th byte lies at the start and/or end of a\n@@ -960,7 +960,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn is_char_boundary(&self, index: uint) -> bool {\n-        core_str::StrExt::is_char_boundary(self[], index)\n+        core_str::StrExt::is_char_boundary(self.index(&FullRange), index)\n     }\n \n     /// Pluck a character out of a string and return the index of the next\n@@ -1018,7 +1018,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_range_at(&self, start: uint) -> CharRange {\n-        core_str::StrExt::char_range_at(self[], start)\n+        core_str::StrExt::char_range_at(self.index(&FullRange), start)\n     }\n \n     /// Given a byte position and a str, return the previous char and its position.\n@@ -1033,7 +1033,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n-        core_str::StrExt::char_range_at_reverse(self[], start)\n+        core_str::StrExt::char_range_at_reverse(self.index(&FullRange), start)\n     }\n \n     /// Plucks the character starting at the `i`th byte of a string.\n@@ -1053,7 +1053,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_at(&self, i: uint) -> char {\n-        core_str::StrExt::char_at(self[], i)\n+        core_str::StrExt::char_at(self.index(&FullRange), i)\n     }\n \n     /// Plucks the character ending at the `i`th byte of a string.\n@@ -1064,7 +1064,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_at_reverse(&self, i: uint) -> char {\n-        core_str::StrExt::char_at_reverse(self[], i)\n+        core_str::StrExt::char_at_reverse(self.index(&FullRange), i)\n     }\n \n     /// Work with the byte buffer of a string as a byte slice.\n@@ -1076,7 +1076,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(self[])\n+        core_str::StrExt::as_bytes(self.index(&FullRange))\n     }\n \n     /// Returns the byte index of the first character of `self` that\n@@ -1104,7 +1104,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n-        core_str::StrExt::find(self[], pat)\n+        core_str::StrExt::find(self.index(&FullRange), pat)\n     }\n \n     /// Returns the byte index of the last character of `self` that\n@@ -1132,7 +1132,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n-        core_str::StrExt::rfind(self[], pat)\n+        core_str::StrExt::rfind(self.index(&FullRange), pat)\n     }\n \n     /// Returns the byte index of the first matching substring\n@@ -1156,7 +1156,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might get removed in favor of a more generic find in the future\"]\n     fn find_str(&self, needle: &str) -> Option<uint> {\n-        core_str::StrExt::find_str(self[], needle)\n+        core_str::StrExt::find_str(self.index(&FullRange), needle)\n     }\n \n     /// Retrieves the first character from a string slice and returns\n@@ -1179,7 +1179,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"awaiting conventions about shifting and slices\"]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        core_str::StrExt::slice_shift_char(self[])\n+        core_str::StrExt::slice_shift_char(self.index(&FullRange))\n     }\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n@@ -1198,7 +1198,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"awaiting convention about comparability of arbitrary slices\"]\n     fn subslice_offset(&self, inner: &str) -> uint {\n-        core_str::StrExt::subslice_offset(self[], inner)\n+        core_str::StrExt::subslice_offset(self.index(&FullRange), inner)\n     }\n \n     /// Return an unsafe pointer to the strings buffer.\n@@ -1209,13 +1209,13 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[stable]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(self[])\n+        core_str::StrExt::as_ptr(self.index(&FullRange))\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn utf16_units(&self) -> Utf16Units {\n-        Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n+        Utf16Units { encoder: Utf16Encoder::new(self.index(&FullRange).chars()) }\n     }\n \n     /// Return the number of bytes in this string\n@@ -1229,7 +1229,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[stable]\n     #[inline]\n     fn len(&self) -> uint {\n-        core_str::StrExt::len(self[])\n+        core_str::StrExt::len(self.index(&FullRange))\n     }\n \n     /// Returns true if this slice contains no bytes\n@@ -1242,7 +1242,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[inline]\n     #[stable]\n     fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(self[])\n+        core_str::StrExt::is_empty(self.index(&FullRange))\n     }\n \n     /// Parse this string into the specified type.\n@@ -1256,7 +1256,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[inline]\n     #[unstable = \"this method was just created\"]\n     fn parse<F: FromStr>(&self) -> Option<F> {\n-        core_str::StrExt::parse(self[])\n+        core_str::StrExt::parse(self.index(&FullRange))\n     }\n \n     /// Returns an iterator over the\n@@ -1280,7 +1280,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        UnicodeStr::graphemes(self[], is_extended)\n+        UnicodeStr::graphemes(self.index(&FullRange), is_extended)\n     }\n \n     /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n@@ -1295,7 +1295,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        UnicodeStr::grapheme_indices(self[], is_extended)\n+        UnicodeStr::grapheme_indices(self.index(&FullRange), is_extended)\n     }\n \n     /// An iterator over the words of a string (subsequences separated\n@@ -1311,7 +1311,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn words(&self) -> Words {\n-        UnicodeStr::words(self[])\n+        UnicodeStr::words(self.index(&FullRange))\n     }\n \n     /// Returns a string's displayed width in columns, treating control\n@@ -1325,25 +1325,25 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// `is_cjk` = `false`) if the locale is unknown.\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn width(&self, is_cjk: bool) -> uint {\n-        UnicodeStr::width(self[], is_cjk)\n+        UnicodeStr::width(self.index(&FullRange), is_cjk)\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n     #[stable]\n     fn trim(&self) -> &str {\n-        UnicodeStr::trim(self[])\n+        UnicodeStr::trim(self.index(&FullRange))\n     }\n \n     /// Returns a string with leading whitespace removed.\n     #[stable]\n     fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(self[])\n+        UnicodeStr::trim_left(self.index(&FullRange))\n     }\n \n     /// Returns a string with trailing whitespace removed.\n     #[stable]\n     fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(self[])\n+        UnicodeStr::trim_right(self.index(&FullRange))\n     }\n }\n \n@@ -2133,7 +2133,7 @@ mod tests {\n         let mut bytes = [0u8; 4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n+            let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n             if Some(c) != s.chars().next() {\n                 panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }\n@@ -2145,7 +2145,7 @@ mod tests {\n         let mut bytes = [0u8; 4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n+            let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }"}, {"sha": "59418f50e3c7d44b89a792a04121e97e5c783454", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -22,7 +22,7 @@ use core::fmt;\n use core::hash;\n use core::iter::FromIterator;\n use core::mem;\n-use core::ops::{self, Deref, Add};\n+use core::ops::{self, Deref, Add, Index};\n use core::ptr;\n use core::raw::Slice as RawSlice;\n use unicode::str as unicode_str;\n@@ -168,7 +168,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.as_mut_vec().push_all(v[..i])\n+                res.as_mut_vec().push_all(v.index(&(0..i)))\n             };\n         }\n \n@@ -185,7 +185,7 @@ impl String {\n             macro_rules! error { () => ({\n                 unsafe {\n                     if subseqidx != i_ {\n-                        res.as_mut_vec().push_all(v[subseqidx..i_]);\n+                        res.as_mut_vec().push_all(v.index(&(subseqidx..i_)));\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n@@ -254,7 +254,7 @@ impl String {\n         }\n         if subseqidx < total {\n             unsafe {\n-                res.as_mut_vec().push_all(v[subseqidx..total])\n+                res.as_mut_vec().push_all(v.index(&(subseqidx..total)))\n             };\n         }\n         Cow::Owned(res)\n@@ -677,13 +677,25 @@ impl FromUtf8Error {\n \n impl fmt::Show for FromUtf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.error.fmt(f)\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for FromUtf8Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(&self.error, f)\n     }\n }\n \n impl fmt::Show for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        \"invalid utf-16: lone surrogate found\".fmt(f)\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for FromUtf16Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n \n@@ -793,10 +805,17 @@ impl Default for String {\n     }\n }\n \n-#[experimental = \"waiting on Show stabilization\"]\n+#[experimental = \"waiting on fmt stabilization\"]\n+impl fmt::String for String {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(&**self, f)\n+    }\n+}\n+\n+#[experimental = \"waiting on fmt stabilization\"]\n impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n+        fmt::Show::fmt(&**self, f)\n     }\n }\n \n@@ -818,25 +837,32 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n-impl ops::Slice<uint, str> for String {\n+impl ops::Index<ops::Range<uint>> for String {\n+    type Output = str;\n     #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a str {\n-        unsafe { mem::transmute(self.vec.as_slice()) }\n+    fn index(&self, index: &ops::Range<uint>) -> &str {\n+        &self.index(&FullRange)[*index]\n     }\n-\n+}\n+impl ops::Index<ops::RangeTo<uint>> for String {\n+    type Output = str;\n     #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, from: &uint) -> &'a str {\n-        self[][*from..]\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n+        &self.index(&FullRange)[*index]\n     }\n-\n+}\n+impl ops::Index<ops::RangeFrom<uint>> for String {\n+    type Output = str;\n     #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, to: &uint) -> &'a str {\n-        self[][..*to]\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n+        &self.index(&FullRange)[*index]\n     }\n-\n+}\n+impl ops::Index<ops::FullRange> for String {\n+    type Output = str;\n     #[inline]\n-    fn slice_or_fail<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-        self[][*from..*to]\n+    fn index(&self, _index: &ops::FullRange) -> &str {\n+        unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n \n@@ -845,7 +871,7 @@ impl ops::Deref for String {\n     type Target = str;\n \n     fn deref<'a>(&'a self) -> &'a str {\n-        unsafe { mem::transmute(self.vec[]) }\n+        unsafe { mem::transmute(self.vec.index(&FullRange)) }\n     }\n }\n \n@@ -895,6 +921,7 @@ pub trait ToString {\n     fn to_string(&self) -> String;\n }\n \n+#[cfg(stage0)]\n impl<T: fmt::Show> ToString for T {\n     fn to_string(&self) -> String {\n         use core::fmt::Writer;\n@@ -905,6 +932,17 @@ impl<T: fmt::Show> ToString for T {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<T: fmt::String> ToString for T {\n+    fn to_string(&self) -> String {\n+        use core::fmt::Writer;\n+        let mut buf = String::new();\n+        let _ = buf.write_fmt(format_args!(\"{}\", self));\n+        buf.shrink_to_fit();\n+        buf\n+    }\n+}\n+\n impl IntoCow<'static, String, str> for String {\n     fn into_cow(self) -> CowString<'static> {\n         Cow::Owned(self)\n@@ -943,6 +981,7 @@ mod tests {\n     use str::Utf8Error;\n     use core::iter::repeat;\n     use super::{as_string, CowString};\n+    use core::ops::FullRange;\n \n     #[test]\n     fn test_as_string() {\n@@ -1224,10 +1263,10 @@ mod tests {\n     #[test]\n     fn test_slicing() {\n         let s = \"foobar\".to_string();\n-        assert_eq!(\"foobar\", s[]);\n-        assert_eq!(\"foo\", s[..3]);\n-        assert_eq!(\"bar\", s[3..]);\n-        assert_eq!(\"oob\", s[1..4]);\n+        assert_eq!(\"foobar\", &s[]);\n+        assert_eq!(\"foo\", &s[..3]);\n+        assert_eq!(\"bar\", &s[3..]);\n+        assert_eq!(\"oob\", &s[1..4]);\n     }\n \n     #[test]"}, {"sha": "5fc3fafac9e229f3dcda6e96f2965285f86292ab", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 69, "deletions": 34, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -55,7 +55,7 @@ use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::iter::{repeat, FromIterator};\n-use core::kinds::marker::{ContravariantLifetime, InvariantType};\n+use core::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n use core::nonzero::NonZero;\n use core::num::{Int, UnsignedInt};\n@@ -1178,7 +1178,7 @@ impl<T:Clone> Clone for Vec<T> {\n \n         // self.len <= other.len due to the truncate above, so the\n         // slice here is always in-bounds.\n-        let slice = other[self.len()..];\n+        let slice = other.index(&(self.len()..));\n         self.push_all(slice);\n     }\n }\n@@ -1209,48 +1209,66 @@ impl<T> IndexMut<uint> for Vec<T> {\n     }\n }\n \n-impl<T> ops::Slice<uint, [T]> for Vec<T> {\n+\n+impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self.as_slice()\n+    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n-\n+}\n+impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.as_slice().slice_from_or_fail(start)\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n-\n+}\n+impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_to_or_fail(end)\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n+}\n+impl<T> ops::Index<ops::FullRange> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_or_fail(start, end)\n+    fn index(&self, _index: &ops::FullRange) -> &[T] {\n+        self.as_slice()\n     }\n }\n \n-impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n+impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self.as_mut_slice()\n+    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+        self.as_mut_slice().index_mut(index)\n     }\n-\n+}\n+impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_from_or_fail_mut(start)\n+    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+        self.as_mut_slice().index_mut(index)\n     }\n-\n+}\n+impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_to_or_fail_mut(end)\n+    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+        self.as_mut_slice().index_mut(index)\n     }\n+}\n+impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n+    type Output = [T];\n     #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_or_fail_mut(start, end)\n+    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n+        self.as_mut_slice()\n     }\n }\n \n+\n #[stable]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n@@ -1430,9 +1448,25 @@ impl<T> Default for Vec<T> {\n }\n \n #[experimental = \"waiting on Show stability\"]\n-impl<T:fmt::Show> fmt::Show for Vec<T> {\n+impl<T: fmt::Show> fmt::Show for Vec<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Show::fmt(self.as_slice(), f)\n+    }\n+}\n+\n+#[cfg(stage0)]\n+#[experimental = \"waiting on Show stability\"]\n+impl<T: fmt::Show> fmt::String for Vec<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self.as_slice(), f)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+#[experimental = \"waiting on Show stability\"]\n+impl<T: fmt::String> fmt::String for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n+        fmt::String::fmt(self.as_slice(), f)\n     }\n }\n \n@@ -1781,6 +1815,7 @@ mod tests {\n     use prelude::*;\n     use core::mem::size_of;\n     use core::iter::repeat;\n+    use core::ops::FullRange;\n     use test::Bencher;\n     use super::as_vec;\n \n@@ -1918,15 +1953,15 @@ mod tests {\n             let (left, right) = values.split_at_mut(2);\n             {\n                 let left: &[_] = left;\n-                assert!(left[0..left.len()] == [1, 2][]);\n+                assert!(&left[..left.len()] == &[1, 2][]);\n             }\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n-                assert!(right[0..right.len()] == [3, 4, 5][]);\n+                assert!(&right[..right.len()] == &[3, 4, 5][]);\n             }\n             for p in right.iter_mut() {\n                 *p += 2;\n@@ -2097,35 +2132,35 @@ mod tests {\n     #[should_fail]\n     fn test_slice_out_of_bounds_1() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[-1..];\n+        &x[(-1)..];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_2() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[..6];\n+        &x[..6];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_3() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[-1..4];\n+        &x[(-1)..4];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_4() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[1..6];\n+        &x[1..6];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_5() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[3..2];\n+        &x[3..2];\n     }\n \n     #[test]\n@@ -2371,7 +2406,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst = src.clone().as_slice().to_vec();\n+            let dst = src.clone()[].to_vec();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });"}, {"sha": "4399a6fec2274bd42b8e8a5553a6490a0fcfb3f4", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -455,7 +455,8 @@ impl<V> VecMap<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n-        self.v[*key].take()\n+        let result = &mut self.v[*key];\n+        result.take()\n     }\n }\n \n@@ -488,11 +489,11 @@ impl<V: Ord> Ord for VecMap<V> {\n #[stable]\n impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n+        try!(write!(f, \"VecMap {{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}: {}\", k, *v));\n+            try!(write!(f, \"{}: {:?}\", k, *v));\n         }\n \n         write!(f, \"}}\")\n@@ -928,9 +929,9 @@ mod test_map {\n         map.insert(1, 2i);\n         map.insert(3, 4i);\n \n-        let map_str = map.to_string();\n-        assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\");\n+        let map_str = format!(\"{:?}\", map);\n+        assert!(map_str == \"VecMap {1: 2i, 3: 4i}\" || map_str == \"{3: 4i, 1: 2i}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"VecMap {}\");\n     }\n \n     #[test]"}, {"sha": "25007bfde93a9d6c0af0ef7604044046ec83ec52", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -49,7 +49,7 @@\n //!             println!(\"String ({}): {}\", as_string.len(), as_string);\n //!         }\n //!         None => {\n-//!             println!(\"{}\", value);\n+//!             println!(\"{:?}\", value);\n //!         }\n //!     }\n //! }"}, {"sha": "05db9e11760e38615889566361962de4f954993d", "filename": "src/libcore/array.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -17,8 +17,8 @@\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n-use kinds::Copy;\n-use ops::Deref;\n+use marker::Copy;\n+use ops::{Deref, FullRange, Index};\n use option::Option;\n \n // macro for implementing n-ary tuple functions and operations\n@@ -35,19 +35,19 @@ macro_rules! array_impls {\n             #[unstable = \"waiting for Show to stabilize\"]\n             impl<T:fmt::Show> fmt::Show for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    fmt::Show::fmt(&self[], f)\n+                    fmt::Show::fmt(&self.index(&FullRange), f)\n                 }\n             }\n \n             #[stable]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    self[] == other[]\n+                    self.index(&FullRange) == other.index(&FullRange)\n                 }\n                 #[inline]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    self[] != other[]\n+                    self.index(&FullRange) != other.index(&FullRange)\n                 }\n             }\n \n@@ -57,9 +57,13 @@ macro_rules! array_impls {\n                 Rhs: Deref<Target=[B]>,\n             {\n                 #[inline(always)]\n-                fn eq(&self, other: &Rhs) -> bool { PartialEq::eq(self[], &**other) }\n+                fn eq(&self, other: &Rhs) -> bool {\n+                    PartialEq::eq(self.index(&FullRange), &**other)\n+                }\n                 #[inline(always)]\n-                fn ne(&self, other: &Rhs) -> bool { PartialEq::ne(self[], &**other) }\n+                fn ne(&self, other: &Rhs) -> bool {\n+                    PartialEq::ne(self.index(&FullRange), &**other)\n+                }\n             }\n \n             #[stable]\n@@ -68,9 +72,13 @@ macro_rules! array_impls {\n                 Lhs: Deref<Target=[A]>\n             {\n                 #[inline(always)]\n-                fn eq(&self, other: &[B; $N]) -> bool { PartialEq::eq(&**self, other[]) }\n+                fn eq(&self, other: &[B; $N]) -> bool {\n+                    PartialEq::eq(&**self, other.index(&FullRange))\n+                }\n                 #[inline(always)]\n-                fn ne(&self, other: &[B; $N]) -> bool { PartialEq::ne(&**self, other[]) }\n+                fn ne(&self, other: &[B; $N]) -> bool {\n+                    PartialEq::ne(&**self, other.index(&FullRange))\n+                }\n             }\n \n             #[stable]\n@@ -80,31 +88,31 @@ macro_rules! array_impls {\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n-                    PartialOrd::partial_cmp(&self[], &other[])\n+                    PartialOrd::partial_cmp(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n                 #[inline]\n                 fn lt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::lt(&self[], &other[])\n+                    PartialOrd::lt(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n                 #[inline]\n                 fn le(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::le(&self[], &other[])\n+                    PartialOrd::le(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n                 #[inline]\n                 fn ge(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::ge(&self[], &other[])\n+                    PartialOrd::ge(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n                 #[inline]\n                 fn gt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::gt(&self[], &other[])\n+                    PartialOrd::gt(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n             }\n \n             #[stable]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {\n-                    Ord::cmp(&self[], &other[])\n+                    Ord::cmp(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n             }\n         )+"}, {"sha": "e740a9292528cfc0a8d7ac8c0d8f66ffba64b59e", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -50,7 +50,7 @@\n //!     let spinlock_clone = spinlock.clone();\n //!     Thread::spawn(move|| {\n //!         spinlock_clone.store(0, Ordering::SeqCst);\n-//!     }).detach();\n+//!     });\n //!\n //!     // Wait for the other task to release the lock\n //!     while spinlock.load(Ordering::SeqCst) != 0 {}\n@@ -72,7 +72,7 @@\n \n use self::Ordering::*;\n \n-use kinds::Sync;\n+use marker::Sync;\n \n use intrinsics;\n use cell::UnsafeCell;"}, {"sha": "31631355422964cce82aec6a145a3c897f824ed4", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -47,7 +47,7 @@\n use clone::Clone;\n use cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n use fmt;\n-use kinds::Sized;\n+use marker::Sized;\n use ops::Deref;\n use option::Option;\n use self::Cow::*;\n@@ -133,6 +133,7 @@ impl<T> ToOwned<T> for T where T: Clone {\n ///     }\n /// }\n /// ```\n+//#[deriving(Show)] NOTE(stage0): uncomment after snapshot\n pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     /// Borrowed data.\n     Borrowed(&'a B),\n@@ -141,6 +142,16 @@ pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     Owned(T)\n }\n \n+//NOTE(stage0): replace with deriving(Show) after snapshot\n+impl<'a, T, B: ?Sized> fmt::Show for Cow<'a, T, B> where\n+    B: fmt::String + ToOwned<T>,\n+    T: fmt::String\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n #[stable]\n impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n@@ -237,11 +248,14 @@ impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwne\n     }\n }\n \n-impl<'a, T, B: ?Sized> fmt::Show for Cow<'a, T, B> where B: fmt::Show + ToOwned<T>, T: fmt::Show {\n+impl<'a, T, B: ?Sized> fmt::String for Cow<'a, T, B> where\n+    B: fmt::String + ToOwned<T>,\n+    T: fmt::String,\n+{\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Borrowed(ref b) => fmt::Show::fmt(b, f),\n-            Owned(ref o) => fmt::Show::fmt(o, f),\n+            Borrowed(ref b) => fmt::String::fmt(b, f),\n+            Owned(ref o) => fmt::String::fmt(o, f),\n         }\n     }\n }"}, {"sha": "674364269f1da0bcb0573f6d05be3e12a1a36761", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -160,8 +160,7 @@\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;\n-use fmt;\n-use kinds::{Copy, Send};\n+use marker::{Copy, Send};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{None, Some};\n@@ -364,16 +363,6 @@ impl<T: PartialEq> PartialEq for RefCell<T> {\n     }\n }\n \n-#[unstable]\n-impl<T:fmt::Show> fmt::Show for RefCell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.try_borrow() {\n-            Some(val) => write!(f, \"{}\", val),\n-            None => write!(f, \"<borrowed RefCell>\")\n-        }\n-    }\n-}\n-\n struct BorrowRef<'b> {\n     _borrow: &'b Cell<BorrowFlag>,\n }\n@@ -520,7 +509,7 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n ///\n /// ```rust\n /// use std::cell::UnsafeCell;\n-/// use std::kinds::marker;\n+/// use std::marker;\n ///\n /// struct NotThreadSafe<T> {\n ///     value: UnsafeCell<T>,"}, {"sha": "3149247a83aed96cf4df8e6af48ef4178138febf", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -21,7 +21,7 @@\n \n #![stable]\n \n-use kinds::Sized;\n+use marker::Sized;\n \n /// A common trait for cloning an object.\n #[stable]"}, {"sha": "c3dfd5f51595f80b1c0e561cc4c68ca4852ad615", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -43,7 +43,7 @@\n \n use self::Ordering::*;\n \n-use kinds::Sized;\n+use marker::Sized;\n use option::Option::{self, Some, None};\n \n /// Trait for equality comparisons which are [partial equivalence relations](\n@@ -316,7 +316,7 @@ pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n mod impls {\n     use cmp::{PartialOrd, Ord, PartialEq, Eq, Ordering};\n     use cmp::Ordering::{Less, Greater, Equal};\n-    use kinds::Sized;\n+    use marker::Sized;\n     use option::Option;\n     use option::Option::{Some, None};\n "}, {"sha": "d833b8fed7779ff8213ca0e515dc53dc6836d53c", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -20,7 +20,7 @@ use fmt;\n use iter::{IteratorExt, range};\n use num::{cast, Float, ToPrimitive};\n use num::FpCategory as Fp;\n-use ops::FnOnce;\n+use ops::{FnOnce, Index};\n use result::Result::Ok;\n use slice::{self, SliceExt};\n use str::{self, StrExt};\n@@ -332,5 +332,5 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         }\n     }\n \n-    f(unsafe { str::from_utf8_unchecked(buf[..end]) })\n+    f(unsafe { str::from_utf8_unchecked(buf.index(&(0..end))) })\n }"}, {"sha": "f9027f19068e435f51062e2745a642fa9db45d36", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 162, "deletions": 26, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -13,22 +13,20 @@\n #![allow(unused_variables)]\n \n use any;\n-use cell::{Cell, Ref, RefMut};\n+use cell::{Cell, RefCell, Ref, RefMut};\n+use char::CharExt;\n use iter::{Iterator, IteratorExt, range};\n-use kinds::{Copy, Sized};\n+use marker::{Copy, Sized};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n-use ops::{Deref, FnOnce};\n use result::Result::Ok;\n+use ops::{Deref, FnOnce, Index};\n use result;\n use slice::SliceExt;\n use slice;\n use str::{self, StrExt, Utf8Error};\n \n-// NOTE: for old macros; remove after the next snapshot\n-#[cfg(stage0)] use result::Result::Err;\n-\n pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n@@ -216,20 +214,33 @@ pub struct Arguments<'a> {\n }\n \n impl<'a> Show for Arguments<'a> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result {\n+        String::fmt(self, fmt)\n+    }\n+}\n+\n+impl<'a> String for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n     }\n }\n \n-/// When a format is not otherwise specified, types are formatted by ascribing\n-/// to this trait. There is not an explicit way of selecting this trait to be\n-/// used for formatting, it is only if no other format is specified.\n+/// Format trait for the `:?` format. Useful for debugging, most all types\n+/// should implement this.\n #[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait Show {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+/// When a value can be semantically expressed as a String, this trait may be\n+/// used. It corresponds to the default format, `{}`.\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n+pub trait String {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n \n /// Format trait for the `o` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n@@ -413,7 +424,7 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0; 4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);\n-                let b = unsafe { str::from_utf8_unchecked(b[0..n]) };\n+                let b = unsafe { str::from_utf8_unchecked(b.index(&(0..n))) };\n                 try!(f.buf.write_str(b));\n             }\n             if prefixed { f.buf.write_str(prefix) }\n@@ -521,7 +532,7 @@ impl<'a> Formatter<'a> {\n \n         let mut fill = [0u8; 4];\n         let len = self.fill.encode_utf8(&mut fill).unwrap_or(0);\n-        let fill = unsafe { str::from_utf8_unchecked(fill[..len]) };\n+        let fill = unsafe { str::from_utf8_unchecked(fill.index(&(..len))) };\n \n         for _ in range(0, pre_pad) {\n             try!(self.buf.write_str(fill));\n@@ -572,7 +583,7 @@ impl<'a> Formatter<'a> {\n \n impl Show for Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        \"an error occurred when formatting an argument\".fmt(f)\n+        String::fmt(\"an error occurred when formatting an argument\", f)\n     }\n }\n \n@@ -595,33 +606,86 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n \n // Implementations of the core formatting traits\n \n-impl<'a, T: ?Sized + Show> Show for &'a T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n-}\n-impl<'a, T: ?Sized + Show> Show for &'a mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n+macro_rules! fmt_refs {\n+    ($($tr:ident),*) => {\n+        $(\n+        impl<'a, T: ?Sized + $tr> $tr for &'a T {\n+            fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n+        }\n+        impl<'a, T: ?Sized + $tr> $tr for &'a mut T {\n+            fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n+        }\n+        )*\n+    }\n }\n \n+fmt_refs! { Show, String, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n+\n impl Show for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        Show::fmt(if *self { \"true\" } else { \"false\" }, f)\n+        String::fmt(self, f)\n+    }\n+}\n+\n+impl String for bool {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        String::fmt(if *self { \"true\" } else { \"false\" }, f)\n+    }\n+}\n+\n+#[cfg(stage0)]\n+//NOTE(stage0): remove impl after snapshot\n+impl Show for str {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        String::fmt(self, f)\n     }\n }\n \n+#[cfg(not(stage0))]\n+//NOTE(stage0): remove cfg after snapshot\n impl Show for str {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        try!(write!(f, \"\\\"\"));\n+        for c in self.chars().flat_map(|c| c.escape_default()) {\n+            try!(write!(f, \"{}\", c));\n+        }\n+        write!(f, \"\\\"\")\n+    }\n+}\n+\n+impl String for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n     }\n }\n \n+#[cfg(stage0)]\n+//NOTE(stage0): remove impl after snapshot\n+impl Show for char {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        String::fmt(self, f)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+//NOTE(stage0): remove cfg after snapshot\n impl Show for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::CharExt;\n+        try!(write!(f, \"'\"));\n+        for c in self.escape_default() {\n+            try!(write!(f, \"{}\", c));\n+        }\n+        write!(f, \"'\")\n+    }\n+}\n \n+impl String for char {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n         let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n-        let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n-        Show::fmt(s, f)\n+        let s: &str = unsafe { mem::transmute(utf8.index(&(0..amt))) };\n+        String::fmt(s, f)\n     }\n }\n \n@@ -653,7 +717,15 @@ impl<'a, T> Pointer for &'a mut T {\n }\n \n macro_rules! floating { ($ty:ident) => {\n+\n     impl Show for $ty {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n+            try!(String::fmt(self, fmt));\n+            fmt.write_str(stringify!($ty))\n+        }\n+    }\n+\n+    impl String for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n \n@@ -724,10 +796,15 @@ floating! { f64 }\n impl<T> Show for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n-\n+impl<T> String for *const T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n+}\n impl<T> Show for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n+impl<T> String for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n+}\n \n macro_rules! peel {\n     ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n@@ -746,7 +823,7 @@ macro_rules! tuple {\n                     if n > 0 {\n                         try!(write!(f, \", \"));\n                     }\n-                    try!(write!(f, \"{}\", *$name));\n+                    try!(write!(f, \"{:?}\", *$name));\n                     n += 1;\n                 )*\n                 if n == 1 {\n@@ -766,6 +843,49 @@ impl<'a> Show for &'a (any::Any+'a) {\n }\n \n impl<T: Show> Show for [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+            try!(write!(f, \"[\"));\n+        }\n+        let mut is_first = true;\n+        for x in self.iter() {\n+            if is_first {\n+                is_first = false;\n+            } else {\n+                try!(write!(f, \", \"));\n+            }\n+            try!(write!(f, \"{:?}\", *x))\n+        }\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+            try!(write!(f, \"]\"));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<T: Show> String for [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+            try!(write!(f, \"[\"));\n+        }\n+        let mut is_first = true;\n+        for x in self.iter() {\n+            if is_first {\n+                is_first = false;\n+            } else {\n+                try!(write!(f, \", \"));\n+            }\n+            try!(write!(f, \"{}\", *x))\n+        }\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+            try!(write!(f, \"]\"));\n+        }\n+        Ok(())\n+    }\n+}\n+#[cfg(not(stage0))]\n+impl<T: String> String for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n             try!(write!(f, \"[\"));\n@@ -792,25 +912,41 @@ impl Show for () {\n     }\n }\n \n+impl String for () {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(\"()\")\n+    }\n+}\n+\n impl<T: Copy + Show> Show for Cell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        write!(f, \"Cell {{ value: {} }}\", self.get())\n+        write!(f, \"Cell {{ value: {:?} }}\", self.get())\n+    }\n+}\n+\n+#[unstable]\n+impl<T: Show> Show for RefCell<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match self.try_borrow() {\n+            Some(val) => write!(f, \"RefCell {{ value: {:?} }}\", val),\n+            None => write!(f, \"RefCell {{ <borrowed> }}\")\n+        }\n     }\n }\n \n impl<'b, T: Show> Show for Ref<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        (**self).fmt(f)\n+        Show::fmt(&**self, f)\n     }\n }\n \n impl<'b, T: Show> Show for RefMut<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        (*(self.deref())).fmt(f)\n+        Show::fmt(&*(self.deref()), f)\n     }\n }\n \n-impl Show for Utf8Error {\n+impl String for Utf8Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match *self {\n             Utf8Error::InvalidByte(n) => {"}, {"sha": "17149aed3dbab4375e652c2203c644d010b41b8e", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -16,6 +16,7 @@\n \n use fmt;\n use iter::IteratorExt;\n+use ops::Index;\n use num::{Int, cast};\n use slice::SliceExt;\n use str;\n@@ -61,7 +62,7 @@ trait GenericRadix {\n                 if x == zero { break };                   // No more digits left to accumulate.\n             }\n         }\n-        let buf = unsafe { str::from_utf8_unchecked(buf[curr..]) };\n+        let buf = unsafe { str::from_utf8_unchecked(buf.index(&(curr..))) };\n         f.pad_integral(is_positive, self.prefix(), buf)\n     }\n }\n@@ -153,8 +154,22 @@ pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n }\n \n macro_rules! radix_fmt {\n-    ($T:ty as $U:ty, $fmt:ident) => {\n+    ($T:ty as $U:ty, $fmt:ident, $S:expr) => {\n+        #[cfg(stage0)]\n         impl fmt::Show for RadixFmt<$T, Radix> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                fmt::String::fmt(self, f)\n+            }\n+        }\n+\n+        #[cfg(not(stage0))]\n+        impl fmt::Show for RadixFmt<$T, Radix> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                try!(fmt::String::fmt(self, f));\n+                f.write_str($S)\n+            }\n+        }\n+        impl fmt::String for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 match *self { RadixFmt(ref x, radix) => radix.$fmt(*x as $U, f) }\n             }\n@@ -170,24 +185,48 @@ macro_rules! int_base {\n         }\n     }\n }\n+\n+macro_rules! show {\n+    ($T:ident with $S:expr) => {\n+        #[cfg(stage0)]\n+        impl fmt::Show for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                fmt::String::fmt(self, f)\n+            }\n+        }\n+\n+        #[cfg(not(stage0))]\n+        impl fmt::Show for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                try!(fmt::String::fmt(self, f));\n+                f.write_str($S)\n+            }\n+        }\n+    }\n+}\n macro_rules! integer {\n     ($Int:ident, $Uint:ident) => {\n-        int_base! { Show     for $Int as $Int   -> Decimal }\n+        integer! { $Int, $Uint, stringify!($Int), stringify!($Uint) }\n+    };\n+    ($Int:ident, $Uint:ident, $SI:expr, $SU:expr) => {\n+        int_base! { String   for $Int as $Int   -> Decimal }\n         int_base! { Binary   for $Int as $Uint  -> Binary }\n         int_base! { Octal    for $Int as $Uint  -> Octal }\n         int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n         int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n-        radix_fmt! { $Int as $Int, fmt_int }\n+        radix_fmt! { $Int as $Int, fmt_int, $SI }\n+        show! { $Int with $SI }\n \n-        int_base! { Show     for $Uint as $Uint -> Decimal }\n+        int_base! { String   for $Uint as $Uint -> Decimal }\n         int_base! { Binary   for $Uint as $Uint -> Binary }\n         int_base! { Octal    for $Uint as $Uint -> Octal }\n         int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n         int_base! { UpperHex for $Uint as $Uint -> UpperHex }\n-        radix_fmt! { $Uint as $Uint, fmt_int }\n+        radix_fmt! { $Uint as $Uint, fmt_int, $SU }\n+        show! { $Uint with $SU }\n     }\n }\n-integer! { int, uint }\n+integer! { int, uint, \"i\", \"u\" }\n integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }"}, {"sha": "822416a387e63405b152d460baafb786cabdc659", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -202,7 +202,6 @@ extern \"rust-intrinsic\" {\n     /// crate it is invoked in.\n     pub fn type_id<T: 'static>() -> TypeId;\n \n-\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,"}, {"sha": "d30cfc405a1fface3eba57e663748b2f505869e4", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 76, "deletions": 79, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -67,7 +67,7 @@ use num::{ToPrimitive, Int};\n use ops::{Add, Deref, FnMut};\n use option::Option;\n use option::Option::{Some, None};\n-use std::kinds::Sized;\n+use std::marker::Sized;\n use uint;\n \n /// An interface for dealing with \"external iterators\". These types of iterators\n@@ -142,7 +142,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn last(mut self) -> Option< <Self as Iterator>::Item> {\n+    fn last(mut self) -> Option<Self::Item> {\n         let mut last = None;\n         for x in self { last = Some(x); }\n         last\n@@ -161,7 +161,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn nth(&mut self, mut n: uint) -> Option< <Self as Iterator>::Item> {\n+    fn nth(&mut self, mut n: uint) -> Option<Self::Item> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n             n -= 1;\n@@ -186,7 +186,7 @@ pub trait IteratorExt: Iterator + Sized {\n     #[inline]\n     #[stable]\n     fn chain<U>(self, other: U) -> Chain<Self, U> where\n-        U: Iterator<Item=<Self as Iterator>::Item>,\n+        U: Iterator<Item=Self::Item>,\n     {\n         Chain{a: self, b: other, flag: false}\n     }\n@@ -228,8 +228,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn map<B, F>(self, f: F) -> Map< <Self as Iterator>::Item, B, Self, F> where\n-        F: FnMut(<Self as Iterator>::Item) -> B,\n+    fn map<B, F>(self, f: F) -> Map<Self::Item, B, Self, F> where\n+        F: FnMut(Self::Item) -> B,\n     {\n         Map{iter: self, f: f}\n     }\n@@ -248,8 +248,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn filter<P>(self, predicate: P) -> Filter< <Self as Iterator>::Item, Self, P> where\n-        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    fn filter<P>(self, predicate: P) -> Filter<Self::Item, Self, P> where\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         Filter{iter: self, predicate: predicate}\n     }\n@@ -268,8 +268,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn filter_map<B, F>(self, f: F) -> FilterMap< <Self as Iterator>::Item, B, Self, F> where\n-        F: FnMut(<Self as Iterator>::Item) -> Option<B>,\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<Self::Item, B, Self, F> where\n+        F: FnMut(Self::Item) -> Option<B>,\n     {\n         FilterMap { iter: self, f: f }\n     }\n@@ -312,7 +312,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn peekable(self) -> Peekable< <Self as Iterator>::Item, Self> {\n+    fn peekable(self) -> Peekable<Self::Item, Self> {\n         Peekable{iter: self, peeked: None}\n     }\n \n@@ -332,8 +332,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn skip_while<P>(self, predicate: P) -> SkipWhile< <Self as Iterator>::Item, Self, P> where\n-        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self::Item, Self, P> where\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n@@ -353,8 +353,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn take_while<P>(self, predicate: P) -> TakeWhile< <Self as Iterator>::Item, Self, P> where\n-        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    fn take_while<P>(self, predicate: P) -> TakeWhile<Self::Item, Self, P> where\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n@@ -422,8 +422,8 @@ pub trait IteratorExt: Iterator + Sized {\n         self,\n         initial_state: St,\n         f: F,\n-    ) -> Scan< <Self as Iterator>::Item, B, Self, St, F> where\n-        F: FnMut(&mut St, <Self as Iterator>::Item) -> Option<B>,\n+    ) -> Scan<Self::Item, B, Self, St, F> where\n+        F: FnMut(&mut St, Self::Item) -> Option<B>,\n     {\n         Scan{iter: self, f: f, state: initial_state}\n     }\n@@ -448,9 +448,9 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn flat_map<B, U, F>(self, f: F) -> FlatMap< <Self as Iterator>::Item, B, Self, U, F> where\n+    fn flat_map<B, U, F>(self, f: F) -> FlatMap<Self::Item, B, Self, U, F> where\n         U: Iterator<Item=B>,\n-        F: FnMut(<Self as Iterator>::Item) -> U,\n+        F: FnMut(Self::Item) -> U,\n     {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n@@ -508,8 +508,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn inspect<F>(self, f: F) -> Inspect< <Self as Iterator>::Item, Self, F> where\n-        F: FnMut(&<Self as Iterator>::Item),\n+    fn inspect<F>(self, f: F) -> Inspect<Self::Item, Self, F> where\n+        F: FnMut(&Self::Item),\n     {\n         Inspect{iter: self, f: f}\n     }\n@@ -546,7 +546,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn collect<B: FromIterator< <Self as Iterator>::Item>>(self) -> B {\n+    fn collect<B: FromIterator<Self::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n \n@@ -563,8 +563,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[unstable = \"recently added as part of collections reform\"]\n     fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n-        B: Default + Extend< <Self as Iterator>::Item>,\n-        F: FnMut(&<Self as Iterator>::Item) -> bool\n+        B: Default + Extend<Self::Item>,\n+        F: FnMut(&Self::Item) -> bool\n     {\n         let mut left: B = Default::default();\n         let mut right: B = Default::default();\n@@ -592,7 +592,7 @@ pub trait IteratorExt: Iterator + Sized {\n     #[inline]\n     #[stable]\n     fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n-        F: FnMut(B, <Self as Iterator>::Item) -> B,\n+        F: FnMut(B, Self::Item) -> B,\n     {\n         let mut accum = init;\n         for x in self {\n@@ -612,7 +612,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n+    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n     }\n@@ -630,7 +630,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n+    fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n     }\n@@ -640,8 +640,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n     #[stable]\n-    fn find<P>(&mut self, mut predicate: P) -> Option< <Self as Iterator>::Item> where\n-        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         for x in *self {\n             if predicate(&x) { return Some(x) }\n@@ -653,7 +653,7 @@ pub trait IteratorExt: Iterator + Sized {\n     #[inline]\n     #[stable]\n     fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n-        P: FnMut(<Self as Iterator>::Item) -> bool,\n+        P: FnMut(Self::Item) -> bool,\n     {\n         let mut i = 0;\n         for x in *self {\n@@ -671,7 +671,7 @@ pub trait IteratorExt: Iterator + Sized {\n     #[inline]\n     #[stable]\n     fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n-        P: FnMut(<Self as Iterator>::Item) -> bool,\n+        P: FnMut(Self::Item) -> bool,\n         Self: ExactSizeIterator + DoubleEndedIterator\n     {\n         let len = self.len();\n@@ -693,8 +693,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn max(self) -> Option< <Self as Iterator>::Item> where\n-        <Self as Iterator>::Item: Ord\n+    fn max(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |max, x| {\n             match max {\n@@ -714,8 +713,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn min(self) -> Option< <Self as Iterator>::Item> where\n-        <Self as Iterator>::Item: Ord\n+    fn min(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |min, x| {\n             match min {\n@@ -759,8 +757,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(v.iter().min_max() == MinMax(&1, &1));\n     /// ```\n     #[unstable = \"return type may change\"]\n-    fn min_max(mut self) -> MinMaxResult< <Self as Iterator>::Item> where\n-        <Self as Iterator>::Item: Ord\n+    fn min_max(mut self) -> MinMaxResult<Self::Item> where Self::Item: Ord\n     {\n         let (mut min, mut max) = match self.next() {\n             None => return NoElements,\n@@ -817,10 +814,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n-    fn max_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n-        F: FnMut(&<Self as Iterator>::Item) -> B,\n+    fn max_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n+        F: FnMut(&Self::Item) -> B,\n     {\n-        self.fold(None, |max: Option<(<Self as Iterator>::Item, B)>, x| {\n+        self.fold(None, |max: Option<(Self::Item, B)>, x| {\n             let x_val = f(&x);\n             match max {\n                 None             => Some((x, x_val)),\n@@ -846,10 +843,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n-    fn min_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n-        F: FnMut(&<Self as Iterator>::Item) -> B,\n+    fn min_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n+        F: FnMut(&Self::Item) -> B,\n     {\n-        self.fold(None, |min: Option<(<Self as Iterator>::Item, B)>, x| {\n+        self.fold(None, |min: Option<(Self::Item, B)>, x| {\n             let x_val = f(&x);\n             match min {\n                 None             => Some((x, x_val)),\n@@ -968,7 +965,7 @@ impl<I> IteratorExt for I where I: Iterator {}\n #[stable]\n pub trait DoubleEndedIterator: Iterator {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    fn next_back(&mut self) -> Option< <Self as Iterator>::Item>;\n+    fn next_back(&mut self) -> Option<Self::Item>;\n }\n \n /// An object implementing random access indexing by `uint`\n@@ -984,7 +981,7 @@ pub trait RandomAccessIterator: Iterator {\n     fn indexable(&self) -> uint;\n \n     /// Return an element at an index, or `None` if the index is out of bounds\n-    fn idx(&mut self, index: uint) -> Option< <Self as Iterator>::Item>;\n+    fn idx(&mut self, index: uint) -> Option<Self::Item>;\n }\n \n /// An iterator that knows its exact length\n@@ -1015,14 +1012,14 @@ pub trait ExactSizeIterator: Iterator {\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n #[stable]\n impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n-    I: ExactSizeIterator + Iterator<Item=A>,\n+    I: ExactSizeIterator<Item=A>,\n     F: FnMut(&A),\n {}\n #[stable]\n impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n #[stable]\n impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n-    I: ExactSizeIterator + Iterator<Item=A>,\n+    I: ExactSizeIterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n #[stable]\n@@ -1041,23 +1038,23 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next_back() }\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[stable]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next() }\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n }\n \n #[experimental = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint { self.iter.indexable() }\n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n+    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n         let amt = self.indexable();\n         self.iter.idx(amt - index - 1)\n     }\n@@ -1075,15 +1072,15 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next() }\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[stable]\n impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n }\n \n /// A trait for iterators over elements which can be added together\n@@ -1244,7 +1241,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n-    I: DoubleEndedIterator + Iterator<Item=D>,\n+    I: DoubleEndedIterator<Item=D>,\n {\n     fn next_back(&mut self) -> Option<T> {\n         self.it.next_back().cloned()\n@@ -1255,7 +1252,7 @@ impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n impl<T, D, I> ExactSizeIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n-    I: ExactSizeIterator + Iterator<Item=D>,\n+    I: ExactSizeIterator<Item=D>,\n {}\n \n /// An iterator that repeats endlessly\n@@ -1272,7 +1269,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n         match self.iter.next() {\n             None => { self.iter = self.orig.clone(); self.iter.next() }\n             y => y\n@@ -1304,7 +1301,7 @@ impl<I> RandomAccessIterator for Cycle<I> where\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n+    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n         let liter = self.iter.indexable();\n         let lorig = self.orig.indexable();\n         if lorig == 0 {\n@@ -1363,8 +1360,8 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n \n #[stable]\n impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n-    A: DoubleEndedIterator + Iterator<Item=T>,\n-    B: DoubleEndedIterator + Iterator<Item=T>,\n+    A: DoubleEndedIterator<Item=T>,\n+    B: DoubleEndedIterator<Item=T>,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n@@ -1377,8 +1374,8 @@ impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n \n #[experimental = \"trait is experimental\"]\n impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n-    A: RandomAccessIterator + Iterator<Item=T>,\n-    B: RandomAccessIterator + Iterator<Item=T>,\n+    A: RandomAccessIterator<Item=T>,\n+    B: RandomAccessIterator<Item=T>,\n {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1444,8 +1441,8 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n \n #[stable]\n impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n-    A: ExactSizeIterator + Iterator<Item=T> + DoubleEndedIterator,\n-    B: ExactSizeIterator + Iterator<Item=U> + DoubleEndedIterator,\n+    A: DoubleEndedIterator + ExactSizeIterator<Item=T>,\n+    B: DoubleEndedIterator + ExactSizeIterator<Item=U>,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(T, U)> {\n@@ -1469,8 +1466,8 @@ impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n \n #[experimental = \"trait is experimental\"]\n impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n-    A: RandomAccessIterator + Iterator<Item=T>,\n-    B: RandomAccessIterator + Iterator<Item=U>,\n+    A: RandomAccessIterator<Item=T>,\n+    B: RandomAccessIterator<Item=U>,\n {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1539,7 +1536,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n \n #[stable]\n impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n-    I: DoubleEndedIterator + Iterator<Item=A>,\n+    I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> B,\n {\n     #[inline]\n@@ -1551,7 +1548,7 @@ impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n \n #[experimental = \"trait is experimental\"]\n impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n-    I: RandomAccessIterator + Iterator<Item=A>,\n+    I: RandomAccessIterator<Item=A>,\n     F: FnMut(A) -> B,\n {\n     #[inline]\n@@ -1613,7 +1610,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n \n #[stable]\n impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n-    I: DoubleEndedIterator + Iterator<Item=A>,\n+    I: DoubleEndedIterator<Item=A>,\n     P: FnMut(&A) -> bool,\n {\n     #[inline]\n@@ -1676,7 +1673,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n \n #[stable]\n impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n-    I: DoubleEndedIterator + Iterator<Item=A>,\n+    I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n {\n     #[inline]\n@@ -1925,7 +1922,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n         let mut next = self.iter.next();\n         if self.n == 0 {\n             next\n@@ -1972,7 +1969,7 @@ impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n+    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n         if index >= self.indexable() {\n             None\n         } else {\n@@ -1995,7 +1992,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n         if self.n != 0 {\n             self.n -= 1;\n             self.iter.next()\n@@ -2027,7 +2024,7 @@ impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n+    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n         if index >= self.n {\n             None\n         } else {\n@@ -2153,8 +2150,8 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n \n #[stable]\n impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n-    I: DoubleEndedIterator + Iterator<Item=A>,\n-    U: DoubleEndedIterator + Iterator<Item=B>,\n+    I: DoubleEndedIterator<Item=A>,\n+    U: DoubleEndedIterator<Item=B>,\n     F: FnMut(A) -> U,\n {\n     #[inline]\n@@ -2189,7 +2186,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n         if self.done {\n             None\n         } else {\n@@ -2216,7 +2213,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n #[stable]\n impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option< <I as Iterator>::Item> {\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n         if self.done {\n             None\n         } else {\n@@ -2240,7 +2237,7 @@ impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n+    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n         self.iter.idx(index)\n     }\n }\n@@ -2308,7 +2305,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n \n #[stable]\n impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n-    I: DoubleEndedIterator + Iterator<Item=A>,\n+    I: DoubleEndedIterator<Item=A>,\n     F: FnMut(&A),\n {\n     #[inline]\n@@ -2320,7 +2317,7 @@ impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n \n #[experimental = \"trait is experimental\"]\n impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n-    I: RandomAccessIterator + Iterator<Item=A>,\n+    I: RandomAccessIterator<Item=A>,\n     F: FnMut(&A),\n {\n     #[inline]"}, {"sha": "5d69938fccff702adc1d8184f4503c3c899a26af", "filename": "src/libcore/kinds.rs", "status": "removed", "additions": 0, "deletions": 298, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=ea6f65c5f1a3f84e010d2cef02a0160804e9567a", "patch": "@@ -1,298 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Primitive traits representing basic 'kinds' of types\n-//!\n-//! Rust types can be classified in various useful ways according to\n-//! intrinsic properties of the type. These classifications, often called\n-//! 'kinds', are represented as traits.\n-//!\n-//! They cannot be implemented by user code, but are instead implemented\n-//! by the compiler automatically for the types to which they apply.\n-\n-/// Types able to be transferred across task boundaries.\n-#[lang=\"send\"]\n-pub unsafe trait Send : 'static {\n-    // empty.\n-}\n-\n-/// Types with a constant size known at compile-time.\n-#[lang=\"sized\"]\n-pub trait Sized {\n-    // Empty.\n-}\n-\n-/// Types that can be copied by simply copying bits (i.e. `memcpy`).\n-#[lang=\"copy\"]\n-pub trait Copy {\n-    // Empty.\n-}\n-\n-/// Types that can be safely shared between tasks when aliased.\n-///\n-/// The precise definition is: a type `T` is `Sync` if `&T` is\n-/// thread-safe. In other words, there is no possibility of data races\n-/// when passing `&T` references between tasks.\n-///\n-/// As one would expect, primitive types like `u8` and `f64` are all\n-/// `Sync`, and so are simple aggregate types containing them (like\n-/// tuples, structs and enums). More instances of basic `Sync` types\n-/// include \"immutable\" types like `&T` and those with simple\n-/// inherited mutability, such as `Box<T>`, `Vec<T>` and most other\n-/// collection types. (Generic parameters need to be `Sync` for their\n-/// container to be `Sync`.)\n-///\n-/// A somewhat surprising consequence of the definition is `&mut T` is\n-/// `Sync` (if `T` is `Sync`) even though it seems that it might\n-/// provide unsynchronised mutation. The trick is a mutable reference\n-/// stored in an aliasable reference (that is, `& &mut T`) becomes\n-/// read-only, as if it were a `& &T`, hence there is no risk of a data\n-/// race.\n-///\n-/// Types that are not `Sync` are those that have \"interior\n-/// mutability\" in a non-thread-safe way, such as `Cell` and `RefCell`\n-/// in `std::cell`. These types allow for mutation of their contents\n-/// even when in an immutable, aliasable slot, e.g. the contents of\n-/// `&Cell<T>` can be `.set`, and do not ensure data races are\n-/// impossible, hence they cannot be `Sync`. A higher level example\n-/// of a non-`Sync` type is the reference counted pointer\n-/// `std::rc::Rc`, because any reference `&Rc<T>` can clone a new\n-/// reference, which modifies the reference counts in a non-atomic\n-/// way.\n-///\n-/// For cases when one does need thread-safe interior mutability,\n-/// types like the atomics in `std::sync` and `Mutex` & `RWLock` in\n-/// the `sync` crate do ensure that any mutation cannot cause data\n-/// races.  Hence these types are `Sync`.\n-///\n-/// Users writing their own types with interior mutability (or anything\n-/// else that is not thread-safe) should use the `NoSync` marker type\n-/// (from `std::kinds::marker`) to ensure that the compiler doesn't\n-/// consider the user-defined type to be `Sync`.  Any types with\n-/// interior mutability must also use the `std::cell::UnsafeCell` wrapper\n-/// around the value(s) which can be mutated when behind a `&`\n-/// reference; not doing this is undefined behaviour (for example,\n-/// `transmute`-ing from `&T` to `&mut T` is illegal).\n-#[lang=\"sync\"]\n-pub unsafe trait Sync {\n-    // Empty\n-}\n-\n-/// Marker types are special types that are used with unsafe code to\n-/// inform the compiler of special constraints. Marker types should\n-/// only be needed when you are creating an abstraction that is\n-/// implemented using unsafe code. In that case, you may want to embed\n-/// some of the marker types below into your type.\n-pub mod marker {\n-    use super::{Copy,Sized};\n-    use clone::Clone;\n-\n-    /// A marker type whose type parameter `T` is considered to be\n-    /// covariant with respect to the type itself. This is (typically)\n-    /// used to indicate that an instance of the type `T` is being stored\n-    /// into memory and read from, even though that may not be apparent.\n-    ///\n-    /// For more information about variance, refer to this Wikipedia\n-    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-    ///\n-    /// *Note:* It is very unusual to have to add a covariant constraint.\n-    /// If you are not sure, you probably want to use `InvariantType`.\n-    ///\n-    /// # Example\n-    ///\n-    /// Given a struct `S` that includes a type parameter `T`\n-    /// but does not actually *reference* that type parameter:\n-    ///\n-    /// ```ignore\n-    /// use std::mem;\n-    ///\n-    /// struct S<T> { x: *() }\n-    /// fn get<T>(s: &S<T>) -> T {\n-    ///    unsafe {\n-    ///        let x: *T = mem::transmute(s.x);\n-    ///        *x\n-    ///    }\n-    /// }\n-    /// ```\n-    ///\n-    /// The type system would currently infer that the value of\n-    /// the type parameter `T` is irrelevant, and hence a `S<int>` is\n-    /// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n-    /// any `U`). But this is incorrect because `get()` converts the\n-    /// `*()` into a `*T` and reads from it. Therefore, we should include the\n-    /// a marker field `CovariantType<T>` to inform the type checker that\n-    /// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n-    /// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n-    /// for some lifetime `'a`, but not the other way around).\n-    #[lang=\"covariant_type\"]\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct CovariantType<T: ?Sized>;\n-\n-    impl<T: ?Sized> Copy for CovariantType<T> {}\n-    impl<T: ?Sized> Clone for CovariantType<T> {\n-        fn clone(&self) -> CovariantType<T> { *self }\n-    }\n-\n-    /// A marker type whose type parameter `T` is considered to be\n-    /// contravariant with respect to the type itself. This is (typically)\n-    /// used to indicate that an instance of the type `T` will be consumed\n-    /// (but not read from), even though that may not be apparent.\n-    ///\n-    /// For more information about variance, refer to this Wikipedia\n-    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-    ///\n-    /// *Note:* It is very unusual to have to add a contravariant constraint.\n-    /// If you are not sure, you probably want to use `InvariantType`.\n-    ///\n-    /// # Example\n-    ///\n-    /// Given a struct `S` that includes a type parameter `T`\n-    /// but does not actually *reference* that type parameter:\n-    ///\n-    /// ```\n-    /// use std::mem;\n-    ///\n-    /// struct S<T> { x: *const () }\n-    /// fn get<T>(s: &S<T>, v: T) {\n-    ///    unsafe {\n-    ///        let x: fn(T) = mem::transmute(s.x);\n-    ///        x(v)\n-    ///    }\n-    /// }\n-    /// ```\n-    ///\n-    /// The type system would currently infer that the value of\n-    /// the type parameter `T` is irrelevant, and hence a `S<int>` is\n-    /// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n-    /// any `U`). But this is incorrect because `get()` converts the\n-    /// `*()` into a `fn(T)` and then passes a value of type `T` to it.\n-    ///\n-    /// Supplying a `ContravariantType` marker would correct the\n-    /// problem, because it would mark `S` so that `S<T>` is only a\n-    /// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n-    /// function requires arguments of type `T`, it must also accept\n-    /// arguments of type `U`, hence such a conversion is safe.\n-    #[lang=\"contravariant_type\"]\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct ContravariantType<T: ?Sized>;\n-\n-    impl<T: ?Sized> Copy for ContravariantType<T> {}\n-    impl<T: ?Sized> Clone for ContravariantType<T> {\n-        fn clone(&self) -> ContravariantType<T> { *self }\n-    }\n-\n-    /// A marker type whose type parameter `T` is considered to be\n-    /// invariant with respect to the type itself. This is (typically)\n-    /// used to indicate that instances of the type `T` may be read or\n-    /// written, even though that may not be apparent.\n-    ///\n-    /// For more information about variance, refer to this Wikipedia\n-    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-    ///\n-    /// # Example\n-    ///\n-    /// The Cell type is an example which uses unsafe code to achieve\n-    /// \"interior\" mutability:\n-    ///\n-    /// ```\n-    /// pub struct Cell<T> { value: T }\n-    /// # fn main() {}\n-    /// ```\n-    ///\n-    /// The type system would infer that `value` is only read here and\n-    /// never written, but in fact `Cell` uses unsafe code to achieve\n-    /// interior mutability.\n-    #[lang=\"invariant_type\"]\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct InvariantType<T: ?Sized>;\n-\n-    impl<T: ?Sized> Copy for InvariantType<T> {}\n-    impl<T: ?Sized> Clone for InvariantType<T> {\n-        fn clone(&self) -> InvariantType<T> { *self }\n-    }\n-\n-    /// As `CovariantType`, but for lifetime parameters. Using\n-    /// `CovariantLifetime<'a>` indicates that it is ok to substitute\n-    /// a *longer* lifetime for `'a` than the one you originally\n-    /// started with (e.g., you could convert any lifetime `'foo` to\n-    /// `'static`). You almost certainly want `ContravariantLifetime`\n-    /// instead, or possibly `InvariantLifetime`. The only case where\n-    /// it would be appropriate is that you have a (type-casted, and\n-    /// hence hidden from the type system) function pointer with a\n-    /// signature like `fn(&'a T)` (and no other uses of `'a`). In\n-    /// this case, it is ok to substitute a larger lifetime for `'a`\n-    /// (e.g., `fn(&'static T)`), because the function is only\n-    /// becoming more selective in terms of what it accepts as\n-    /// argument.\n-    ///\n-    /// For more information about variance, refer to this Wikipedia\n-    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-    #[lang=\"covariant_lifetime\"]\n-    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct CovariantLifetime<'a>;\n-\n-    /// As `ContravariantType`, but for lifetime parameters. Using\n-    /// `ContravariantLifetime<'a>` indicates that it is ok to\n-    /// substitute a *shorter* lifetime for `'a` than the one you\n-    /// originally started with (e.g., you could convert `'static` to\n-    /// any lifetime `'foo`). This is appropriate for cases where you\n-    /// have an unsafe pointer that is actually a pointer into some\n-    /// memory with lifetime `'a`, and thus you want to limit the\n-    /// lifetime of your data structure to `'a`. An example of where\n-    /// this is used is the iterator for vectors.\n-    ///\n-    /// For more information about variance, refer to this Wikipedia\n-    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-    #[lang=\"contravariant_lifetime\"]\n-    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct ContravariantLifetime<'a>;\n-\n-    /// As `InvariantType`, but for lifetime parameters. Using\n-    /// `InvariantLifetime<'a>` indicates that it is not ok to\n-    /// substitute any other lifetime for `'a` besides its original\n-    /// value. This is appropriate for cases where you have an unsafe\n-    /// pointer that is actually a pointer into memory with lifetime `'a`,\n-    /// and this pointer is itself stored in an inherently mutable\n-    /// location (such as a `Cell`).\n-    #[lang=\"invariant_lifetime\"]\n-    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct InvariantLifetime<'a>;\n-\n-    /// A type which is considered \"not sendable\", meaning that it cannot\n-    /// be safely sent between tasks, even if it is owned. This is\n-    /// typically embedded in other types, such as `Gc`, to ensure that\n-    /// their instances remain thread-local.\n-    #[lang=\"no_send_bound\"]\n-    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct NoSend;\n-\n-    /// A type which is considered \"not POD\", meaning that it is not\n-    /// implicitly copyable. This is typically embedded in other types to\n-    /// ensure that they are never copied, even if they lack a destructor.\n-    #[lang=\"no_copy_bound\"]\n-    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    #[allow(missing_copy_implementations)]\n-    pub struct NoCopy;\n-\n-    /// A type which is considered \"not sync\", meaning that\n-    /// its contents are not threadsafe, hence they cannot be\n-    /// shared between tasks.\n-    #[lang=\"no_sync_bound\"]\n-    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct NoSync;\n-\n-    /// A type which is considered managed by the GC. This is typically\n-    /// embedded in other types.\n-    #[lang=\"managed_bound\"]\n-    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    #[allow(missing_copy_implementations)]\n-    pub struct Managed;\n-}\n-"}, {"sha": "a7e3b61b0d42bd6ac7be7c94e90af53a216265d0", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -56,29 +56,25 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![no_std]\n-#![allow(unknown_features, raw_pointer_deriving)]\n-#![feature(globs, intrinsics, lang_items, macro_rules, phase)]\n+#![allow(unknown_features, raw_pointer_derive)]\n+#![feature(intrinsics, lang_items)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n-#![feature(default_type_params, unboxed_closures, associated_types)]\n+#![feature(unboxed_closures)]\n #![deny(missing_docs)]\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod macros;\n \n #[path = \"num/float_macros.rs\"]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod float_macros;\n \n #[path = \"num/int_macros.rs\"]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod int_macros;\n \n #[path = \"num/uint_macros.rs\"]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod uint_macros;\n \n #[path = \"num/int.rs\"]  pub mod int;\n@@ -111,7 +107,7 @@ pub mod ptr;\n \n /* Core language traits */\n \n-pub mod kinds;\n+pub mod marker;\n pub mod ops;\n pub mod cmp;\n pub mod clone;\n@@ -150,7 +146,9 @@ mod core {\n mod std {\n     pub use clone;\n     pub use cmp;\n-    pub use kinds;\n+    #[cfg(stage0)]\n+    pub use marker as kinds;\n+    pub use marker;\n     pub use option;\n     pub use fmt;\n     pub use hash;"}, {"sha": "bfe88fff22fb1ff2290652809227e9aa4fa09302", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -83,7 +83,7 @@ macro_rules! assert_eq {\n                 if !((*left_val == *right_val) &&\n                      (*right_val == *left_val)) {\n                     panic!(\"assertion failed: `(left == right) && (right == left)` \\\n-                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n+                           (left: `{:?}`, right: `{:?}`)\", *left_val, *right_val)\n                 }\n             }\n         }\n@@ -142,16 +142,9 @@ macro_rules! debug_assert_eq {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n }\n \n-#[cfg(stage0)]\n-#[macro_export]\n-macro_rules! try {\n-    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-}\n-\n /// Short circuiting evaluation on Err\n ///\n /// `libstd` contains a more general `try!` macro that uses `FromError`.\n-#[cfg(not(stage0))]\n #[macro_export]\n macro_rules! try {\n     ($e:expr) => ({\n@@ -186,9 +179,12 @@ macro_rules! write {\n #[macro_export]\n #[stable]\n macro_rules! writeln {\n-    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n-        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n-    )\n+    ($dst:expr, $fmt:expr) => (\n+        write!($dst, concat!($fmt, \"\\n\"))\n+    );\n+    ($dst:expr, $fmt:expr, $($arg:tt)*) => (\n+        write!($dst, concat!($fmt, \"\\n\"), $($arg)*)\n+    );\n }\n \n /// A utility macro for indicating unreachable code."}, {"sha": "d400cb47cbff6d14f5ed4da9d26ff6921e3c4a70", "filename": "src/libcore/marker.rs", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -0,0 +1,314 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Primitive traits and marker types representing basic 'kinds' of types.\n+//!\n+//! Rust types can be classified in various useful ways according to\n+//! intrinsic properties of the type. These classifications, often called\n+//! 'kinds', are represented as traits.\n+//!\n+//! They cannot be implemented by user code, but are instead implemented\n+//! by the compiler automatically for the types to which they apply.\n+//!\n+//! Marker types are special types that are used with unsafe code to\n+//! inform the compiler of special constraints. Marker types should\n+//! only be needed when you are creating an abstraction that is\n+//! implemented using unsafe code. In that case, you may want to embed\n+//! some of the marker types below into your type.\n+\n+#![stable]\n+\n+use clone::Clone;\n+\n+/// Types able to be transferred across task boundaries.\n+#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n+#[lang=\"send\"]\n+pub unsafe trait Send: 'static {\n+    // empty.\n+}\n+\n+/// Types with a constant size known at compile-time.\n+#[stable]\n+#[lang=\"sized\"]\n+pub trait Sized {\n+    // Empty.\n+}\n+\n+/// Types that can be copied by simply copying bits (i.e. `memcpy`).\n+#[stable]\n+#[lang=\"copy\"]\n+pub trait Copy {\n+    // Empty.\n+}\n+\n+/// Types that can be safely shared between tasks when aliased.\n+///\n+/// The precise definition is: a type `T` is `Sync` if `&T` is\n+/// thread-safe. In other words, there is no possibility of data races\n+/// when passing `&T` references between tasks.\n+///\n+/// As one would expect, primitive types like `u8` and `f64` are all\n+/// `Sync`, and so are simple aggregate types containing them (like\n+/// tuples, structs and enums). More instances of basic `Sync` types\n+/// include \"immutable\" types like `&T` and those with simple\n+/// inherited mutability, such as `Box<T>`, `Vec<T>` and most other\n+/// collection types. (Generic parameters need to be `Sync` for their\n+/// container to be `Sync`.)\n+///\n+/// A somewhat surprising consequence of the definition is `&mut T` is\n+/// `Sync` (if `T` is `Sync`) even though it seems that it might\n+/// provide unsynchronised mutation. The trick is a mutable reference\n+/// stored in an aliasable reference (that is, `& &mut T`) becomes\n+/// read-only, as if it were a `& &T`, hence there is no risk of a data\n+/// race.\n+///\n+/// Types that are not `Sync` are those that have \"interior\n+/// mutability\" in a non-thread-safe way, such as `Cell` and `RefCell`\n+/// in `std::cell`. These types allow for mutation of their contents\n+/// even when in an immutable, aliasable slot, e.g. the contents of\n+/// `&Cell<T>` can be `.set`, and do not ensure data races are\n+/// impossible, hence they cannot be `Sync`. A higher level example\n+/// of a non-`Sync` type is the reference counted pointer\n+/// `std::rc::Rc`, because any reference `&Rc<T>` can clone a new\n+/// reference, which modifies the reference counts in a non-atomic\n+/// way.\n+///\n+/// For cases when one does need thread-safe interior mutability,\n+/// types like the atomics in `std::sync` and `Mutex` & `RWLock` in\n+/// the `sync` crate do ensure that any mutation cannot cause data\n+/// races.  Hence these types are `Sync`.\n+///\n+/// Users writing their own types with interior mutability (or anything\n+/// else that is not thread-safe) should use the `NoSync` marker type\n+/// (from `std::marker`) to ensure that the compiler doesn't\n+/// consider the user-defined type to be `Sync`.  Any types with\n+/// interior mutability must also use the `std::cell::UnsafeCell` wrapper\n+/// around the value(s) which can be mutated when behind a `&`\n+/// reference; not doing this is undefined behaviour (for example,\n+/// `transmute`-ing from `&T` to `&mut T` is illegal).\n+#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n+#[lang=\"sync\"]\n+pub unsafe trait Sync {\n+    // Empty\n+}\n+\n+\n+/// A marker type whose type parameter `T` is considered to be\n+/// covariant with respect to the type itself. This is (typically)\n+/// used to indicate that an instance of the type `T` is being stored\n+/// into memory and read from, even though that may not be apparent.\n+///\n+/// For more information about variance, refer to this Wikipedia\n+/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+///\n+/// *Note:* It is very unusual to have to add a covariant constraint.\n+/// If you are not sure, you probably want to use `InvariantType`.\n+///\n+/// # Example\n+///\n+/// Given a struct `S` that includes a type parameter `T`\n+/// but does not actually *reference* that type parameter:\n+///\n+/// ```ignore\n+/// use std::mem;\n+///\n+/// struct S<T> { x: *() }\n+/// fn get<T>(s: &S<T>) -> T {\n+///    unsafe {\n+///        let x: *T = mem::transmute(s.x);\n+///        *x\n+///    }\n+/// }\n+/// ```\n+///\n+/// The type system would currently infer that the value of\n+/// the type parameter `T` is irrelevant, and hence a `S<int>` is\n+/// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n+/// any `U`). But this is incorrect because `get()` converts the\n+/// `*()` into a `*T` and reads from it. Therefore, we should include the\n+/// a marker field `CovariantType<T>` to inform the type checker that\n+/// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n+/// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n+/// for some lifetime `'a`, but not the other way around).\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"covariant_type\"]\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n+pub struct CovariantType<T: ?Sized>;\n+\n+impl<T: ?Sized> Copy for CovariantType<T> {}\n+impl<T: ?Sized> Clone for CovariantType<T> {\n+    fn clone(&self) -> CovariantType<T> { *self }\n+}\n+\n+/// A marker type whose type parameter `T` is considered to be\n+/// contravariant with respect to the type itself. This is (typically)\n+/// used to indicate that an instance of the type `T` will be consumed\n+/// (but not read from), even though that may not be apparent.\n+///\n+/// For more information about variance, refer to this Wikipedia\n+/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+///\n+/// *Note:* It is very unusual to have to add a contravariant constraint.\n+/// If you are not sure, you probably want to use `InvariantType`.\n+///\n+/// # Example\n+///\n+/// Given a struct `S` that includes a type parameter `T`\n+/// but does not actually *reference* that type parameter:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// struct S<T> { x: *const () }\n+/// fn get<T>(s: &S<T>, v: T) {\n+///    unsafe {\n+///        let x: fn(T) = mem::transmute(s.x);\n+///        x(v)\n+///    }\n+/// }\n+/// ```\n+///\n+/// The type system would currently infer that the value of\n+/// the type parameter `T` is irrelevant, and hence a `S<int>` is\n+/// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n+/// any `U`). But this is incorrect because `get()` converts the\n+/// `*()` into a `fn(T)` and then passes a value of type `T` to it.\n+///\n+/// Supplying a `ContravariantType` marker would correct the\n+/// problem, because it would mark `S` so that `S<T>` is only a\n+/// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n+/// function requires arguments of type `T`, it must also accept\n+/// arguments of type `U`, hence such a conversion is safe.\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"contravariant_type\"]\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n+pub struct ContravariantType<T: ?Sized>;\n+\n+impl<T: ?Sized> Copy for ContravariantType<T> {}\n+impl<T: ?Sized> Clone for ContravariantType<T> {\n+    fn clone(&self) -> ContravariantType<T> { *self }\n+}\n+\n+/// A marker type whose type parameter `T` is considered to be\n+/// invariant with respect to the type itself. This is (typically)\n+/// used to indicate that instances of the type `T` may be read or\n+/// written, even though that may not be apparent.\n+///\n+/// For more information about variance, refer to this Wikipedia\n+/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+///\n+/// # Example\n+///\n+/// The Cell type is an example which uses unsafe code to achieve\n+/// \"interior\" mutability:\n+///\n+/// ```\n+/// pub struct Cell<T> { value: T }\n+/// # fn main() {}\n+/// ```\n+///\n+/// The type system would infer that `value` is only read here and\n+/// never written, but in fact `Cell` uses unsafe code to achieve\n+/// interior mutability.\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"invariant_type\"]\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n+pub struct InvariantType<T: ?Sized>;\n+\n+#[unstable = \"likely to change with new variance strategy\"]\n+impl<T: ?Sized> Copy for InvariantType<T> {}\n+#[unstable = \"likely to change with new variance strategy\"]\n+impl<T: ?Sized> Clone for InvariantType<T> {\n+    fn clone(&self) -> InvariantType<T> { *self }\n+}\n+\n+/// As `CovariantType`, but for lifetime parameters. Using\n+/// `CovariantLifetime<'a>` indicates that it is ok to substitute\n+/// a *longer* lifetime for `'a` than the one you originally\n+/// started with (e.g., you could convert any lifetime `'foo` to\n+/// `'static`). You almost certainly want `ContravariantLifetime`\n+/// instead, or possibly `InvariantLifetime`. The only case where\n+/// it would be appropriate is that you have a (type-casted, and\n+/// hence hidden from the type system) function pointer with a\n+/// signature like `fn(&'a T)` (and no other uses of `'a`). In\n+/// this case, it is ok to substitute a larger lifetime for `'a`\n+/// (e.g., `fn(&'static T)`), because the function is only\n+/// becoming more selective in terms of what it accepts as\n+/// argument.\n+///\n+/// For more information about variance, refer to this Wikipedia\n+/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"covariant_lifetime\"]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct CovariantLifetime<'a>;\n+\n+/// As `ContravariantType`, but for lifetime parameters. Using\n+/// `ContravariantLifetime<'a>` indicates that it is ok to\n+/// substitute a *shorter* lifetime for `'a` than the one you\n+/// originally started with (e.g., you could convert `'static` to\n+/// any lifetime `'foo`). This is appropriate for cases where you\n+/// have an unsafe pointer that is actually a pointer into some\n+/// memory with lifetime `'a`, and thus you want to limit the\n+/// lifetime of your data structure to `'a`. An example of where\n+/// this is used is the iterator for vectors.\n+///\n+/// For more information about variance, refer to this Wikipedia\n+/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"contravariant_lifetime\"]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct ContravariantLifetime<'a>;\n+\n+/// As `InvariantType`, but for lifetime parameters. Using\n+/// `InvariantLifetime<'a>` indicates that it is not ok to\n+/// substitute any other lifetime for `'a` besides its original\n+/// value. This is appropriate for cases where you have an unsafe\n+/// pointer that is actually a pointer into memory with lifetime `'a`,\n+/// and this pointer is itself stored in an inherently mutable\n+/// location (such as a `Cell`).\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"invariant_lifetime\"]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct InvariantLifetime<'a>;\n+\n+/// A type which is considered \"not sendable\", meaning that it cannot\n+/// be safely sent between tasks, even if it is owned. This is\n+/// typically embedded in other types, such as `Gc`, to ensure that\n+/// their instances remain thread-local.\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"no_send_bound\"]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct NoSend;\n+\n+/// A type which is considered \"not POD\", meaning that it is not\n+/// implicitly copyable. This is typically embedded in other types to\n+/// ensure that they are never copied, even if they lack a destructor.\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"no_copy_bound\"]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+#[allow(missing_copy_implementations)]\n+pub struct NoCopy;\n+\n+/// A type which is considered \"not sync\", meaning that\n+/// its contents are not threadsafe, hence they cannot be\n+/// shared between tasks.\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"no_sync_bound\"]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct NoSync;\n+\n+/// A type which is considered managed by the GC. This is typically\n+/// embedded in other types.\n+#[unstable = \"likely to change with new variance strategy\"]\n+#[lang=\"managed_bound\"]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+#[allow(missing_copy_implementations)]\n+pub struct Managed;"}, {"sha": "8438c9b206ee7132ac9331b94c7c6a127e746ffc", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -15,7 +15,7 @@\n \n #![stable]\n \n-use kinds::Sized;\n+use marker::Sized;\n use intrinsics;\n use ptr;\n "}, {"sha": "490d8111f463ad3d14e319969734b5a21003c9b8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -21,10 +21,10 @@ use cmp::{PartialEq, Eq};\n use cmp::{PartialOrd, Ord};\n use intrinsics;\n use iter::IteratorExt;\n-use kinds::Copy;\n+use marker::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr, Index};\n use option::Option;\n use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n@@ -992,7 +992,7 @@ impl_to_primitive_float! { f64 }\n \n /// A generic trait for converting a number to a value.\n #[experimental = \"trait is likely to be removed\"]\n-pub trait FromPrimitive : ::kinds::Sized {\n+pub trait FromPrimitive : ::marker::Sized {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n     #[inline]\n@@ -1577,7 +1577,7 @@ macro_rules! from_str_radix_float_impl {\n                         };\n \n                         // Parse the exponent as decimal integer\n-                        let src = src[offset..];\n+                        let src = src.index(&(offset..));\n                         let (is_positive, exp) = match src.slice_shift_char() {\n                             Some(('-', src)) => (false, src.parse::<uint>()),\n                             Some(('+', src)) => (true,  src.parse::<uint>()),"}, {"sha": "4debab91739c1951765512e470095edd38b479be", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 4, "deletions": 105, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -51,8 +51,8 @@\n //!     }\n //! }\n //! fn main() {\n-//!     println!(\"{}\", Point {x: 1, y: 0} + Point {x: 2, y: 3});\n-//!     println!(\"{}\", Point {x: 1, y: 0} - Point {x: 2, y: 3});\n+//!     println!(\"{:?}\", Point {x: 1, y: 0} + Point {x: 2, y: 3});\n+//!     println!(\"{:?}\", Point {x: 1, y: 0} - Point {x: 2, y: 3});\n //! }\n //! ```\n //!\n@@ -63,7 +63,7 @@\n \n use clone::Clone;\n use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n-use kinds::Sized;\n+use marker::Sized;\n use option::Option::{self, Some, None};\n \n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n@@ -846,105 +846,6 @@ pub trait IndexMut<Index: ?Sized> {\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n-/// The `Slice` trait is used to specify the functionality of slicing operations\n-/// like `arr[from..to]` when used in an immutable context.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Slice`. When `Foo[..Foo]` happens, it ends up\n-/// calling `slice_to`, and therefore, `main` prints `Slicing!`.\n-///\n-/// ```ignore\n-/// use std::ops::Slice;\n-///\n-/// #[derive(Copy)]\n-/// struct Foo;\n-///\n-/// impl Slice<Foo, Foo> for Foo {\n-///     fn as_slice_<'a>(&'a self) -> &'a Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_from_or_fail<'a>(&'a self, _from: &Foo) -> &'a Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_to_or_fail<'a>(&'a self, _to: &Foo) -> &'a Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_or_fail<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo[..Foo];\n-/// }\n-/// ```\n-#[lang=\"slice\"]\n-pub trait Slice<Idx: ?Sized, Result: ?Sized> {\n-    /// The method for the slicing operation foo[]\n-    fn as_slice_<'a>(&'a self) -> &'a Result;\n-    /// The method for the slicing operation foo[from..]\n-    fn slice_from_or_fail<'a>(&'a self, from: &Idx) -> &'a Result;\n-    /// The method for the slicing operation foo[..to]\n-    fn slice_to_or_fail<'a>(&'a self, to: &Idx) -> &'a Result;\n-    /// The method for the slicing operation foo[from..to]\n-    fn slice_or_fail<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n-}\n-\n-/// The `SliceMut` trait is used to specify the functionality of slicing\n-/// operations like `arr[from..to]`, when used in a mutable context.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `SliceMut`. When `Foo[Foo..]` happens, it ends up\n-/// calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n-///\n-/// ```ignore\n-/// use std::ops::SliceMut;\n-///\n-/// #[derive(Copy)]\n-/// struct Foo;\n-///\n-/// impl SliceMut<Foo, Foo> for Foo {\n-///     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_from_or_fail_mut<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_to_or_fail_mut<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_or_fail_mut<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-/// }\n-///\n-/// pub fn main() {\n-///     Foo[mut Foo..];\n-/// }\n-/// ```\n-#[lang=\"slice_mut\"]\n-pub trait SliceMut<Idx: ?Sized, Result: ?Sized> {\n-    /// The method for the slicing operation foo[]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Result;\n-    /// The method for the slicing operation foo[from..]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, from: &Idx) -> &'a mut Result;\n-    /// The method for the slicing operation foo[..to]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, to: &Idx) -> &'a mut Result;\n-    /// The method for the slicing operation foo[from..to]\n-    fn slice_or_fail_mut<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n-}\n-\n-\n /// An unbounded range.\n #[derive(Copy)]\n #[lang=\"full_range\"]\n@@ -962,8 +863,6 @@ pub struct Range<Idx> {\n     pub end: Idx,\n }\n \n-// FIXME(#19391) needs a snapshot\n-//impl<Idx: Clone + Step<T=uint>> Iterator<Idx> for Range<Idx> {\n #[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     type Item = Idx;\n@@ -1134,7 +1033,7 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n pub trait DerefMut: Deref {\n     /// The method called to mutably dereference a value\n     #[stable]\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut <Self as Deref>::Target;\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut Self::Target;\n }\n \n #[stable]"}, {"sha": "272570a0d5bb93e0e48256625bd4ed76400c88c4", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -238,7 +238,7 @@ impl<T> Option<T> {\n     /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n     /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n     /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n-    /// println!(\"still can print num_as_str: {}\", num_as_str);\n+    /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n     /// ```\n     #[inline]\n     #[stable]"}, {"sha": "c3bb9c91557f334da2485f25d9b896abecfc2ae7", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -29,8 +29,8 @@\n //! ```\n \n // Reexported core operators\n-pub use kinds::{Copy, Send, Sized, Sync};\n-pub use ops::{Drop, Fn, FnMut, FnOnce};\n+pub use marker::{Copy, Send, Sized, Sync};\n+pub use ops::{Drop, Fn, FnMut, FnOnce, FullRange};\n \n // Reexported functions\n pub use iter::range;"}, {"sha": "c35d948165ab8084ee5e4feb5abe044a6642d942", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -92,7 +92,7 @@ use mem;\n use clone::Clone;\n use intrinsics;\n use option::Option::{self, Some, None};\n-use kinds::{Send, Sized, Sync};\n+use marker::{Send, Sized, Sync};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd};\n use cmp::Ordering::{self, Less, Equal, Greater};"}, {"sha": "1ad6d43f76f0919308996a5034f230e7929fc78e", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -18,7 +18,7 @@\n //!\n //! Their definition should always match the ABI defined in `rustc::back::abi`.\n \n-use kinds::Copy;\n+use marker::Copy;\n use mem;\n \n /// The representation of a Rust slice"}, {"sha": "95ae6ebfb68c30b9ad26a0cb1fd2b7fa5d75d588", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -47,10 +47,10 @@\n //! let version = parse_version(&[1, 2, 3, 4]);\n //! match version {\n //!     Ok(v) => {\n-//!         println!(\"working with version: {}\", v);\n+//!         println!(\"working with version: {:?}\", v);\n //!     }\n //!     Err(e) => {\n-//!         println!(\"error parsing header: {}\", e);\n+//!         println!(\"error parsing header: {:?}\", e);\n //!     }\n //! }\n //! ```\n@@ -743,7 +743,7 @@ impl<T, E: Show> Result<T, E> {\n         match self {\n             Ok(t) => t,\n             Err(e) =>\n-                panic!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n+                panic!(\"called `Result::unwrap()` on an `Err` value: {:?}\", e)\n         }\n     }\n }\n@@ -773,7 +773,7 @@ impl<T: Show, E> Result<T, E> {\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n-                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n+                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {:?}\", t),\n             Err(e) => e\n         }\n     }"}, {"sha": "1f9aebb91beab0189faf4ed3a53d7a6ccc3447c4", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -25,7 +25,7 @@\n //!     use std::simd::f32x4;\n //!     let a = f32x4(40.0, 41.0, 42.0, 43.0);\n //!     let b = f32x4(1.0, 1.1, 3.4, 9.8);\n-//!     println!(\"{}\", a + b);\n+//!     println!(\"{:?}\", a + b);\n //! }\n //! ```\n //!"}, {"sha": "bf2df465370084df2bb62cbd87fbf4be80484e40", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 161, "deletions": 97, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -41,9 +41,9 @@ use cmp::Ordering::{Less, Equal, Greater};\n use cmp;\n use default::Default;\n use iter::*;\n-use kinds::Copy;\n+use marker::Copy;\n use num::Int;\n-use ops::{FnMut, self};\n+use ops::{FnMut, self, Index};\n use option::Option;\n use option::Option::{None, Some};\n use result::Result;\n@@ -52,7 +52,7 @@ use ptr;\n use ptr::PtrExt;\n use mem;\n use mem::size_of;\n-use kinds::{Sized, marker};\n+use marker::{Sized, self};\n use raw::Repr;\n // Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n use raw::Slice as RawSlice;\n@@ -159,7 +159,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n-        (self[..mid], self[mid..])\n+        (self.index(&(0..mid)), self.index(&(mid..)))\n     }\n \n     #[inline]\n@@ -236,11 +236,11 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn tail(&self) -> &[T] { self[1..] }\n+    fn tail(&self) -> &[T] { self.index(&(1..)) }\n \n     #[inline]\n     fn init(&self) -> &[T] {\n-        self[..self.len() - 1]\n+        self.index(&(0..(self.len() - 1)))\n     }\n \n     #[inline]\n@@ -292,26 +292,26 @@ impl<T> SliceExt for [T] {\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] {\n-        ops::SliceMut::slice_or_fail_mut(self, &start, &end)\n+        ops::IndexMut::index_mut(self, &ops::Range { start: start, end: end } )\n     }\n \n     #[inline]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [T] {\n-        ops::SliceMut::slice_from_or_fail_mut(self, &start)\n+        ops::IndexMut::index_mut(self, &ops::RangeFrom { start: start } )\n     }\n \n     #[inline]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [T] {\n-        ops::SliceMut::slice_to_or_fail_mut(self, &end)\n+        ops::IndexMut::index_mut(self, &ops::RangeTo { end: end } )\n     }\n \n     #[inline]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n         unsafe {\n             let self2: &mut [T] = mem::transmute_copy(&self);\n \n-            (ops::SliceMut::slice_to_or_fail_mut(self, &mid),\n-             ops::SliceMut::slice_from_or_fail_mut(self2, &mid))\n+            (ops::IndexMut::index_mut(self, &ops::RangeTo { end: mid } ),\n+             ops::IndexMut::index_mut(self2, &ops::RangeFrom { start: mid } ))\n         }\n     }\n \n@@ -443,13 +443,13 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let n = needle.len();\n-        self.len() >= n && needle == self[..n]\n+        self.len() >= n && needle == self.index(&(0..n))\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == self[m-n..]\n+        m >= n && needle == self.index(&((m-n)..))\n     }\n \n     #[unstable]\n@@ -551,62 +551,79 @@ impl<T> ops::IndexMut<uint> for [T] {\n     }\n }\n \n-impl<T> ops::Slice<uint, [T]> for [T] {\n+impl<T> ops::Index<ops::Range<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.slice_or_fail(start, &self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.slice_or_fail(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n+    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n         unsafe {\n             transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n+                    data: self.as_ptr().offset(index.start as int),\n+                    len: index.end - index.start\n                 })\n         }\n     }\n }\n-\n-impl<T> ops::SliceMut<uint, [T]> for [T] {\n+impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+        self.index(&ops::Range{ start: 0, end: index.end })\n     }\n-\n+}\n+impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        let len = &self.len();\n-        self.slice_or_fail_mut(start, len)\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+        self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n-\n+}\n+impl<T> ops::Index<ops::FullRange> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.slice_or_fail_mut(&0, end)\n+    fn index(&self, _index: &ops::FullRange) -> &[T] {\n+        self\n     }\n+}\n+\n+impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n+    type Output = [T];\n     #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n+    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n         unsafe {\n             transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n+                    data: self.as_ptr().offset(index.start as int),\n+                    len: index.end - index.start\n                 })\n         }\n     }\n }\n+impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n+    type Output = [T];\n+    #[inline]\n+    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+        self.index_mut(&ops::Range{ start: 0, end: index.end })\n+    }\n+}\n+impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n+    type Output = [T];\n+    #[inline]\n+    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+        let len = self.len();\n+        self.index_mut(&ops::Range{ start: index.start, end: len })\n+    }\n+}\n+impl<T> ops::IndexMut<ops::FullRange> for [T] {\n+    type Output = [T];\n+    #[inline]\n+    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n+        self\n+    }\n+}\n+\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common traits\n@@ -716,7 +733,7 @@ macro_rules! iterator {\n }\n \n macro_rules! make_slice {\n-    ($t: ty -> $result: ty: $start: expr, $end: expr) => {{\n+    ($t: ty => $result: ty: $start: expr, $end: expr) => {{\n         let diff = $end as uint - $start as uint;\n         let len = if mem::size_of::<T>() == 0 {\n             diff\n@@ -738,21 +755,38 @@ pub struct Iter<'a, T: 'a> {\n }\n \n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for Iter<'a, T> {\n-    fn as_slice_(&self) -> &[T] {\n-        self.as_slice()\n+impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n-    fn slice_from_or_fail<'b>(&'b self, from: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice().slice_from_or_fail(from)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n-    fn slice_to_or_fail<'b>(&'b self, to: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice().slice_to_or_fail(to)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n-    fn slice_or_fail<'b>(&'b self, from: &uint, to: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice().slice_or_fail(from, to)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index(&self, _index: &ops::FullRange) -> &[T] {\n+        self.as_slice()\n     }\n }\n \n@@ -763,7 +797,7 @@ impl<'a, T> Iter<'a, T> {\n     /// iterator can continue to be used while this exists.\n     #[experimental]\n     pub fn as_slice(&self) -> &'a [T] {\n-        make_slice!(T -> &'a [T]: self.ptr, self.end)\n+        make_slice!(T => &'a [T]: self.ptr, self.end)\n     }\n }\n \n@@ -812,44 +846,74 @@ pub struct IterMut<'a, T: 'a> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n+\n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for IterMut<'a, T> {\n-    fn as_slice_<'b>(&'b self) -> &'b [T] {\n-        make_slice!(T -> &'b [T]: self.ptr, self.end)\n+impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+        self.index(&ops::FullRange).index(index)\n     }\n-    fn slice_from_or_fail<'b>(&'b self, from: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice_().slice_from_or_fail(from)\n+}\n+#[experimental]\n+impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+        self.index(&ops::FullRange).index(index)\n     }\n-    fn slice_to_or_fail<'b>(&'b self, to: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice_().slice_to_or_fail(to)\n+}\n+#[experimental]\n+impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+        self.index(&ops::FullRange).index(index)\n     }\n-    fn slice_or_fail<'b>(&'b self, from: &uint, to: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice_().slice_or_fail(from, to)\n+}\n+#[experimental]\n+impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index(&self, _index: &ops::FullRange) -> &[T] {\n+        make_slice!(T => &[T]: self.ptr, self.end)\n     }\n }\n \n #[experimental]\n-impl<'a, T> ops::SliceMut<uint, [T]> for IterMut<'a, T> {\n-    fn as_mut_slice_<'b>(&'b mut self) -> &'b mut [T] {\n-        make_slice!(T -> &'b mut [T]: self.ptr, self.end)\n+impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+        self.index_mut(&ops::FullRange).index_mut(index)\n     }\n-    fn slice_from_or_fail_mut<'b>(&'b mut self, from: &uint) -> &'b mut [T] {\n-        use ops::SliceMut;\n-        self.as_mut_slice_().slice_from_or_fail_mut(from)\n+}\n+#[experimental]\n+impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+        self.index_mut(&ops::FullRange).index_mut(index)\n     }\n-    fn slice_to_or_fail_mut<'b>(&'b mut self, to: &uint) -> &'b mut [T] {\n-        use ops::SliceMut;\n-        self.as_mut_slice_().slice_to_or_fail_mut(to)\n+}\n+#[experimental]\n+impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+        self.index_mut(&ops::FullRange).index_mut(index)\n     }\n-    fn slice_or_fail_mut<'b>(&'b mut self, from: &uint, to: &uint) -> &'b mut [T] {\n-        use ops::SliceMut;\n-        self.as_mut_slice_().slice_or_fail_mut(from, to)\n+}\n+#[experimental]\n+impl<'a, T> ops::IndexMut<ops::FullRange> for IterMut<'a, T> {\n+    type Output = [T];\n+    #[inline]\n+    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n+        make_slice!(T => &mut [T]: self.ptr, self.end)\n     }\n }\n \n+\n impl<'a, T> IterMut<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n@@ -859,7 +923,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// restricted lifetimes that do not consume the iterator.\n     #[experimental]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        make_slice!(T -> &'a mut [T]: self.ptr, self.end)\n+        make_slice!(T => &'a mut [T]: self.ptr, self.end)\n     }\n }\n \n@@ -873,7 +937,7 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n trait SplitIter: DoubleEndedIterator {\n     /// Mark the underlying iterator as complete, extracting the remaining\n     /// portion of the slice.\n-    fn finish(&mut self) -> Option< <Self as Iterator>::Item>;\n+    fn finish(&mut self) -> Option<Self::Item>;\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n@@ -908,8 +972,8 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v[..idx]);\n-                self.v = self.v[idx + 1..];\n+                let ret = Some(self.v.index(&(0..idx)));\n+                self.v = self.v.index(&((idx + 1)..));\n                 ret\n             }\n         }\n@@ -934,8 +998,8 @@ impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> boo\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v[idx + 1..]);\n-                self.v = self.v[..idx];\n+                let ret = Some(self.v.index(&((idx + 1)..)));\n+                self.v = self.v.index(&(0..idx));\n                 ret\n             }\n         }\n@@ -1038,7 +1102,7 @@ struct GenericSplitN<I> {\n     invert: bool\n }\n \n-impl<T, I: SplitIter + Iterator<Item=T>> Iterator for GenericSplitN<I> {\n+impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n     type Item = T;\n \n     #[inline]\n@@ -1131,8 +1195,8 @@ impl<'a, T> Iterator for Windows<'a, T> {\n         if self.size > self.v.len() {\n             None\n         } else {\n-            let ret = Some(self.v[..self.size]);\n-            self.v = self.v[1..];\n+            let ret = Some(self.v.index(&(0..self.size)));\n+            self.v = self.v.index(&(1..));\n             ret\n         }\n     }\n@@ -1219,7 +1283,7 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n             let mut hi = lo + self.size;\n             if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n \n-            Some(self.v[lo..hi])\n+            Some(self.v.index(&(lo..hi)))\n         } else {\n             None\n         }"}, {"sha": "3f8ce000e214cffde43574336ce829fde9e47ec7", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -23,10 +23,10 @@ use default::Default;\n use iter::range;\n use iter::ExactSizeIterator;\n use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n-use kinds::Sized;\n+use marker::Sized;\n use mem;\n use num::Int;\n-use ops::{Fn, FnMut};\n+use ops::{Fn, FnMut, Index};\n use option::Option::{self, None, Some};\n use ptr::PtrExt;\n use raw::{Repr, Slice};\n@@ -35,17 +35,16 @@ use slice::{self, SliceExt};\n use uint;\n \n macro_rules! delegate_iter {\n-    (exact $te:ty in $ti:ty) => {\n-        delegate_iter!{$te in $ti}\n-        #[stable]\n+    (exact $te:ty : $ti:ty) => {\n+        delegate_iter!{$te : $ti}\n         impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n             fn len(&self) -> uint {\n                 self.0.len()\n             }\n         }\n     };\n-    ($te:ty in $ti:ty) => {\n+    ($te:ty : $ti:ty) => {\n         #[stable]\n         impl<'a> Iterator for $ti {\n             type Item = $te;\n@@ -67,7 +66,7 @@ macro_rules! delegate_iter {\n             }\n         }\n     };\n-    (pattern $te:ty in $ti:ty) => {\n+    (pattern $te:ty : $ti:ty) => {\n         #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n@@ -89,7 +88,7 @@ macro_rules! delegate_iter {\n             }\n         }\n     };\n-    (pattern forward $te:ty in $ti:ty) => {\n+    (pattern forward $te:ty : $ti:ty) => {\n         #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n@@ -143,7 +142,7 @@ Section: Creating a string\n */\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n-#[derive(Copy, Eq, PartialEq, Clone)]\n+#[derive(Copy, Eq, PartialEq, Clone, Show)]\n #[unstable = \"error enumeration recently added and definitions may be refined\"]\n pub enum Utf8Error {\n     /// An invalid byte was detected at the byte offset given.\n@@ -415,7 +414,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n #[stable]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n-delegate_iter!{exact u8 in Bytes<'a>}\n+delegate_iter!{exact u8 : Bytes<'a>}\n \n /// A temporary fn new type that ensures that the `Bytes` iterator\n /// is cloneable.\n@@ -581,7 +580,7 @@ impl NaiveSearcher {\n \n     fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n         while self.position + needle.len() <= haystack.len() {\n-            if haystack[self.position .. self.position + needle.len()] == needle {\n+            if haystack.index(&(self.position .. self.position + needle.len())) == needle {\n                 let match_pos = self.position;\n                 self.position += needle.len(); // add 1 for all matches\n                 return Some((match_pos, match_pos + needle.len()));\n@@ -702,10 +701,10 @@ impl TwoWaySearcher {\n         //\n         // What's going on is we have some critical factorization (u, v) of the\n         // needle, and we want to determine whether u is a suffix of\n-        // v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // v.index(&(0..period)). If it is, we use \"Algorithm CP1\". Otherwise we use\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n-        if needle[..crit_pos] == needle[period.. period + crit_pos] {\n+        if needle.index(&(0..crit_pos)) == needle.index(&(period.. period + crit_pos)) {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 period: period,\n@@ -1119,25 +1118,32 @@ mod traits {\n         }\n     }\n \n-    impl ops::Slice<uint, str> for str {\n+    impl ops::Index<ops::Range<uint>> for str {\n+        type Output = str;\n         #[inline]\n-        fn as_slice_<'a>(&'a self) -> &'a str {\n-            self\n+        fn index(&self, index: &ops::Range<uint>) -> &str {\n+            self.slice(index.start, index.end)\n         }\n-\n+    }\n+    impl ops::Index<ops::RangeTo<uint>> for str {\n+        type Output = str;\n         #[inline]\n-        fn slice_from_or_fail<'a>(&'a self, from: &uint) -> &'a str {\n-            self.slice_from(*from)\n+        fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n+            self.slice_to(index.end)\n         }\n-\n+    }\n+    impl ops::Index<ops::RangeFrom<uint>> for str {\n+        type Output = str;\n         #[inline]\n-        fn slice_to_or_fail<'a>(&'a self, to: &uint) -> &'a str {\n-            self.slice_to(*to)\n+        fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n+            self.slice_from(index.start)\n         }\n-\n+    }\n+    impl ops::Index<ops::FullRange> for str {\n+        type Output = str;\n         #[inline]\n-        fn slice_or_fail<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-            self.slice(*from, *to)\n+        fn index(&self, _index: &ops::FullRange) -> &str {\n+            self\n         }\n     }\n }\n@@ -1165,25 +1171,25 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n #[derive(Clone)]\n #[stable]\n pub struct Split<'a, P>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str in Split<'a, P>}\n+delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[derive(Clone)]\n #[unstable = \"might get removed in favour of a constructor method on Split\"]\n pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str in SplitTerminator<'a, P>}\n+delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n /// Return type of `StrExt::splitn`\n #[derive(Clone)]\n #[stable]\n pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str in SplitN<'a, P>}\n+delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n #[derive(Clone)]\n #[stable]\n pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str in RSplitN<'a, P>}\n+delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n \n /// Methods for string slices\n #[allow(missing_docs)]\n@@ -1406,13 +1412,13 @@ impl StrExt for str {\n     #[inline]\n     fn starts_with(&self, needle: &str) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes()[..n]\n+        self.len() >= n && needle.as_bytes() == self.as_bytes().index(&(0..n))\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes()[m-n..]\n+        m >= n && needle.as_bytes() == self.as_bytes().index(&((m-n)..))\n     }\n \n     #[inline]"}, {"sha": "35c1cb09281f41cc035500f52014afca66f60754", "filename": "src/libcore/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcore%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fty.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -10,4 +10,4 @@\n \n //! Types dealing with unsafe actions.\n \n-use kinds::marker;\n+use marker;"}, {"sha": "c0be3a287940a9bbbac8546b48f764fcfc2f479f", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -56,12 +56,12 @@ fn any_downcast_ref() {\n \n     match a.downcast_ref::<uint>() {\n         Some(&5) => {}\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match a.downcast_ref::<Test>() {\n         None => {}\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n }\n \n@@ -79,35 +79,35 @@ fn any_downcast_mut() {\n             assert_eq!(*x, 5u);\n             *x = 612;\n         }\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match b_r.downcast_mut::<uint>() {\n         Some(x) => {\n             assert_eq!(*x, 7u);\n             *x = 413;\n         }\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match a_r.downcast_mut::<Test>() {\n         None => (),\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match b_r.downcast_mut::<Test>() {\n         None => (),\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match a_r.downcast_mut::<uint>() {\n         Some(&612) => {}\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match b_r.downcast_mut::<uint>() {\n         Some(&413) => {}\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n }\n "}, {"sha": "86f34ecd15efeefdef43ac28f2712aaedbcc05e4", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -29,22 +29,22 @@ fn smoketest_cell() {\n #[test]\n fn cell_has_sensible_show() {\n     let x = Cell::new(\"foo bar\");\n-    assert!(format!(\"{}\", x).contains(x.get()));\n+    assert!(format!(\"{:?}\", x).contains(x.get()));\n \n     x.set(\"baz qux\");\n-    assert!(format!(\"{}\", x).contains(x.get()));\n+    assert!(format!(\"{:?}\", x).contains(x.get()));\n }\n \n #[test]\n fn ref_and_refmut_have_sensible_show() {\n     let refcell = RefCell::new(\"foo\");\n \n     let refcell_refmut = refcell.borrow_mut();\n-    assert!(format!(\"{}\", refcell_refmut).contains(\"foo\"));\n+    assert!(format!(\"{:?}\", refcell_refmut).contains(\"foo\"));\n     drop(refcell_refmut);\n \n     let refcell_ref = refcell.borrow();\n-    assert!(format!(\"{}\", refcell_ref).contains(\"foo\"));\n+    assert!(format!(\"{:?}\", refcell_ref).contains(\"foo\"));\n     drop(refcell_ref);\n }\n "}, {"sha": "f901e8001767d5ce6644369d23a976383d33a33b", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -167,7 +167,7 @@ fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8; 4];\n         let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf[..n], expect);\n+        assert_eq!(buf.index(&(0..n)), expect);\n     }\n \n     check('x', &[0x78]);\n@@ -181,7 +181,7 @@ fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16; 2];\n         let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf[..n], expect);\n+        assert_eq!(buf.index(&(0..n)), expect);\n     }\n \n     check('x', &[0x0078]);"}, {"sha": "c259e4cbb686d3da9e619ee9cd3bd6961b7658a8", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -26,6 +26,11 @@ fn test_format_int() {\n     assert!(format!(\"{}\", -1i16) == \"-1\");\n     assert!(format!(\"{}\", -1i32) == \"-1\");\n     assert!(format!(\"{}\", -1i64) == \"-1\");\n+    assert!(format!(\"{:?}\", 1i) == \"1i\");\n+    assert!(format!(\"{:?}\", 1i8) == \"1i8\");\n+    assert!(format!(\"{:?}\", 1i16) == \"1i16\");\n+    assert!(format!(\"{:?}\", 1i32) == \"1i32\");\n+    assert!(format!(\"{:?}\", 1i64) == \"1i64\");\n     assert!(format!(\"{:b}\", 1i) == \"1\");\n     assert!(format!(\"{:b}\", 1i8) == \"1\");\n     assert!(format!(\"{:b}\", 1i16) == \"1\");\n@@ -52,6 +57,11 @@ fn test_format_int() {\n     assert!(format!(\"{}\", 1u16) == \"1\");\n     assert!(format!(\"{}\", 1u32) == \"1\");\n     assert!(format!(\"{}\", 1u64) == \"1\");\n+    assert!(format!(\"{:?}\", 1u) == \"1u\");\n+    assert!(format!(\"{:?}\", 1u8) == \"1u8\");\n+    assert!(format!(\"{:?}\", 1u16) == \"1u16\");\n+    assert!(format!(\"{:?}\", 1u32) == \"1u32\");\n+    assert!(format!(\"{:?}\", 1u64) == \"1u64\");\n     assert!(format!(\"{:b}\", 1u) == \"1\");\n     assert!(format!(\"{:b}\", 1u8) == \"1\");\n     assert!(format!(\"{:b}\", 1u16) == \"1\");\n@@ -84,12 +94,14 @@ fn test_format_int() {\n #[test]\n fn test_format_int_zero() {\n     assert!(format!(\"{}\", 0i) == \"0\");\n+    assert!(format!(\"{:?}\", 0i) == \"0i\");\n     assert!(format!(\"{:b}\", 0i) == \"0\");\n     assert!(format!(\"{:o}\", 0i) == \"0\");\n     assert!(format!(\"{:x}\", 0i) == \"0\");\n     assert!(format!(\"{:X}\", 0i) == \"0\");\n \n     assert!(format!(\"{}\", 0u) == \"0\");\n+    assert!(format!(\"{:?}\", 0u) == \"0u\");\n     assert!(format!(\"{:b}\", 0u) == \"0\");\n     assert!(format!(\"{:o}\", 0u) == \"0\");\n     assert!(format!(\"{:x}\", 0u) == \"0\");\n@@ -183,6 +195,12 @@ mod uint {\n         b.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n     }\n \n+    #[bench]\n+    fn format_show(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:?}\", rng.gen::<uint>()); })\n+    }\n+\n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n         let mut rng = weak_rng();\n@@ -219,6 +237,12 @@ mod int {\n         b.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n     }\n \n+    #[bench]\n+    fn format_show(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:?}\", rng.gen::<int>()); })\n+    }\n+\n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n         let mut rng = weak_rng();"}, {"sha": "63bf9ec331454f368c7cb354888425a7aa53018f", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use core::kinds::Sized;\n+use core::marker::Sized;\n use std::mem;\n \n use core::slice::SliceExt;"}, {"sha": "61266a926494458f62bfffdbac6b964cbcffac83", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -14,7 +14,6 @@ use core::iter::MinMaxResult::*;\n use core::num::SignedInt;\n use core::uint;\n use core::cmp;\n-use core::ops::Slice;\n \n use test::Bencher;\n \n@@ -230,7 +229,7 @@ fn test_inspect() {\n                .collect::<Vec<uint>>();\n \n     assert_eq!(n, xs.len());\n-    assert_eq!(xs[], ys[]);\n+    assert_eq!(&xs[], &ys[]);\n }\n \n #[test]\n@@ -281,21 +280,21 @@ fn test_iterator_nth() {\n fn test_iterator_last() {\n     let v: &[_] = &[0i, 1, 2, 3, 4];\n     assert_eq!(v.iter().last().unwrap(), &4);\n-    assert_eq!(v[0..1].iter().last().unwrap(), &0);\n+    assert_eq!(v[..1].iter().last().unwrap(), &0);\n }\n \n #[test]\n fn test_iterator_len() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().count(), 4);\n-    assert_eq!(v[0..10].iter().count(), 10);\n+    assert_eq!(v[..4].iter().count(), 4);\n+    assert_eq!(v[..10].iter().count(), 10);\n     assert_eq!(v[0..0].iter().count(), 0);\n }\n \n #[test]\n fn test_iterator_sum() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).sum(), 6);\n+    assert_eq!(v[..4].iter().map(|&x| x).sum(), 6);\n     assert_eq!(v.iter().map(|&x| x).sum(), 55);\n     assert_eq!(v[0..0].iter().map(|&x| x).sum(), 0);\n }\n@@ -374,7 +373,7 @@ fn test_all() {\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n-    assert!(v.slice_or_fail(&0, &0).iter().all(|_| panic!()));\n+    assert!(v[0..0].iter().all(|_| panic!()));\n }\n \n #[test]\n@@ -383,7 +382,7 @@ fn test_any() {\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n-    assert!(!v.slice_or_fail(&0, &0).iter().any(|_| panic!()));\n+    assert!(!v[0..0].iter().any(|_| panic!()));\n }\n \n #[test]\n@@ -586,7 +585,7 @@ fn check_randacc_iter<A, T>(a: T, len: uint) where\n fn test_double_ended_flat_map() {\n     let u = [0u,1];\n     let v = [5u,6,7,8];\n-    let mut it = u.iter().flat_map(|x| v[*x..v.len()].iter());\n+    let mut it = u.iter().flat_map(|x| v[(*x)..v.len()].iter());\n     assert_eq!(it.next_back().unwrap(), &8);\n     assert_eq!(it.next().unwrap(),      &5);\n     assert_eq!(it.next_back().unwrap(), &7);"}, {"sha": "8186a4f0904afe8fe39d0eeee5066034c990e29b", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -12,10 +12,9 @@ use core::cmp::PartialEq;\n use core::fmt::Show;\n use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n-use core::kinds::Copy;\n+use core::marker::Copy;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod int_macros;\n \n mod i8;\n@@ -24,8 +23,7 @@ mod i32;\n mod i64;\n mod int;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod uint_macros;\n \n mod u8;"}, {"sha": "1169f910238022b2c7148e013d8ef10b96b20f98", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use core::option::*;\n-use core::kinds::marker;\n+use core::marker;\n use core::mem;\n use core::clone::Clone;\n "}, {"sha": "b9403598ec2b2d3b8f0ab8d2b5b5bd5545a76c39", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -95,10 +95,10 @@ pub fn test_fmt_default() {\n     let ok: Result<int, &'static str> = Ok(100);\n     let err: Result<int, &'static str> = Err(\"Err\");\n \n-    let s = format!(\"{}\", ok);\n-    assert_eq!(s, \"Ok(100)\");\n-    let s = format!(\"{}\", err);\n-    assert_eq!(s, \"Err(Err)\");\n+    let s = format!(\"{:?}\", ok);\n+    assert_eq!(s, \"Ok(100i)\");\n+    let s = format!(\"{:?}\", err);\n+    assert_eq!(s, \"Err(\\\"Err\\\")\");\n }\n \n #[test]"}, {"sha": "b714b6a4e417dfb1bdfde88a2741fb6d122177d9", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -43,35 +43,35 @@ fn iterator_to_slice() {\n \n             {\n                 let mut iter = data.iter();\n-                assert_eq!(iter[], other_data[]);\n+                assert_eq!(&iter[], &other_data[]);\n \n                 iter.next();\n-                assert_eq!(iter[], other_data[1..]);\n+                assert_eq!(&iter[], &other_data[1..]);\n \n                 iter.next_back();\n-                assert_eq!(iter[], other_data[1..2]);\n+                assert_eq!(&iter[], &other_data[1..2]);\n \n                 let s = iter.as_slice();\n                 iter.next();\n-                assert_eq!(s, other_data[1..2]);\n+                assert_eq!(s, &other_data[1..2]);\n             }\n             {\n                 let mut iter = data.iter_mut();\n-                assert_eq!(iter[], other_data[]);\n+                assert_eq!(iter.index(&FullRange), other_data.index(&FullRange));\n                 // mutability:\n-                assert!(iter[mut] == other_data);\n+                assert!(&mut iter[] == other_data);\n \n                 iter.next();\n-                assert_eq!(iter[], other_data[1..]);\n-                assert!(iter[mut] == other_data[mut 1..]);\n+                assert_eq!(iter.index(&FullRange), other_data.index(&(1..)));\n+                assert!(&mut iter[] == &mut other_data[1..]);\n \n                 iter.next_back();\n \n-                assert_eq!(iter[], other_data[1..2]);\n-                assert!(iter[mut] == other_data[mut 1..2]);\n+                assert_eq!(iter.index(&FullRange), other_data.index(&(1..2)));\n+                assert!(&mut iter[] == &mut other_data[1..2]);\n \n                 let s = iter.into_slice();\n-                assert!(s == other_data[mut 1..2]);\n+                assert!(s == &mut other_data[1..2]);\n             }\n         }}\n     }"}, {"sha": "62eb9f4ad3480c9df71a12feb97692c735297072", "filename": "src/libcoretest/tuple.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -59,10 +59,10 @@ fn test_tuple_cmp() {\n \n #[test]\n fn test_show() {\n-    let s = format!(\"{}\", (1i,));\n-    assert_eq!(s, \"(1,)\");\n-    let s = format!(\"{}\", (1i, true));\n-    assert_eq!(s, \"(1, true)\");\n-    let s = format!(\"{}\", (1i, \"hi\", true));\n-    assert_eq!(s, \"(1, hi, true)\");\n+    let s = format!(\"{:?}\", (1i,));\n+    assert_eq!(s, \"(1i,)\");\n+    let s = format!(\"{:?}\", (1i, true));\n+    assert_eq!(s, \"(1i, true)\");\n+    let s = format!(\"{:?}\", (1i, \"hi\", true));\n+    assert_eq!(s, \"(1i, \\\"hi\\\", true)\");\n }"}, {"sha": "f38440d86c6e855a4f171443d9397469adb9d1b3", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -21,7 +21,6 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(unboxed_closures, associated_types)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "47cc072a636a147fe81e5b69b537bd28da6cca21", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -23,8 +23,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(globs, slicing_syntax)]\n-#![feature(associated_types)]\n+#![feature(slicing_syntax)]\n \n pub use self::Piece::*;\n pub use self::Position::*;\n@@ -212,11 +211,12 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n             }\n             Some((_, other)) => {\n-                self.err(format!(\"expected `{}`, found `{}`\", c, other)[]);\n+                self.err(format!(\"expected `{:?}`, found `{:?}`\", c,\n+                                 other).index(&FullRange));\n             }\n             None => {\n-                self.err(format!(\"expected `{}` but string was terminated\",\n-                                 c)[]);\n+                self.err(format!(\"expected `{:?}` but string was terminated\",\n+                                 c).index(&FullRange));\n             }\n         }\n     }\n@@ -239,12 +239,12 @@ impl<'a> Parser<'a> {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n                 Some((pos, '}')) | Some((pos, '{')) => {\n-                    return self.input[start..pos];\n+                    return self.input.index(&(start..pos));\n                 }\n                 Some(..) => { self.cur.next(); }\n                 None => {\n                     self.cur.next();\n-                    return self.input[start..self.input.len()];\n+                    return self.input.index(&(start..self.input.len()));\n                 }\n             }\n         }\n@@ -284,7 +284,7 @@ impl<'a> Parser<'a> {\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n-            ty: self.input[0..0],\n+            ty: self.input.index(&(0..0)),\n         };\n         if !self.consume(':') { return spec }\n \n@@ -393,7 +393,7 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n                 pos\n             }\n-            Some(..) | None => { return self.input[0..0]; }\n+            Some(..) | None => { return self.input.index(&(0..0)); }\n         };\n         let mut end;\n         loop {\n@@ -405,7 +405,7 @@ impl<'a> Parser<'a> {\n                 None => { end = self.input.len(); break }\n             }\n         }\n-        self.input[start..end]\n+        self.input.index(&(start..end))\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal"}, {"sha": "f50e24c6354f184ea6a344be5abe6361c8125482", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -85,8 +85,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(globs, slicing_syntax)]\n-#![feature(unboxed_closures)]\n+#![feature(slicing_syntax)]\n #![deny(missing_docs)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n@@ -105,7 +104,7 @@ use std::iter::repeat;\n use std::result;\n \n /// Name of an option. Either a string or a single char.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub enum Name {\n     /// A string representing the long name of an option.\n     /// For example: \"help\"\n@@ -116,7 +115,7 @@ pub enum Name {\n }\n \n /// Describes whether an option has an argument.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Show)]\n pub enum HasArg {\n     /// The option requires an argument.\n     Yes,\n@@ -127,7 +126,7 @@ pub enum HasArg {\n }\n \n /// Describes how often an option may occur.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Show)]\n pub enum Occur {\n     /// The option occurs once.\n     Req,\n@@ -138,7 +137,7 @@ pub enum Occur {\n }\n \n /// A description of a possible option.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub struct Opt {\n     /// Name of the option\n     pub name: Name,\n@@ -152,7 +151,7 @@ pub struct Opt {\n \n /// One group of options, e.g., both `-h` and `--help`, along with\n /// their shared description and properties.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub struct OptGroup {\n     /// Short name of the option, e.g. `h` for a `-h` option\n     pub short_name: String,\n@@ -169,15 +168,15 @@ pub struct OptGroup {\n }\n \n /// Describes whether an option is given at all or has a value.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n enum Optval {\n     Val(String),\n     Given,\n }\n \n /// The result of checking command line arguments. Contains a vector\n /// of matches and a vector of free strings.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub struct Matches {\n     /// Options that matched\n     opts: Vec<Opt>,\n@@ -190,7 +189,7 @@ pub struct Matches {\n /// The type returned when the command line does not conform to the\n /// expected format. Use the `Show` implementation to output detailed\n /// information.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub enum Fail {\n     /// The option requires an argument but none was passed.\n     ArgumentMissing(String),\n@@ -205,7 +204,7 @@ pub enum Fail {\n }\n \n /// The type of failure that occurred.\n-#[derive(Copy, PartialEq, Eq)]\n+#[derive(Copy, PartialEq, Eq, Show)]\n #[allow(missing_docs)]\n pub enum FailType {\n     ArgumentMissing_,\n@@ -281,7 +280,7 @@ impl OptGroup {\n \n impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(self.opts[], Name::from_str(nm)) {\n+        match find_opt(self.opts.index(&FullRange), Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n             None => panic!(\"No option '{}' defined\", nm)\n         }\n@@ -309,7 +308,7 @@ impl Matches {\n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[String]) -> bool {\n         for nm in names.iter() {\n-            match find_opt(self.opts.as_slice(), Name::from_str(nm[])) {\n+            match find_opt(self.opts.as_slice(), Name::from_str(nm.index(&FullRange))) {\n                 Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n             };\n@@ -320,7 +319,7 @@ impl Matches {\n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names.iter() {\n-            match self.opt_val(nm[]) {\n+            match self.opt_val(nm.index(&FullRange)) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -536,13 +535,13 @@ pub fn opt(short_name: &str,\n \n impl Fail {\n     /// Convert a `Fail` enum into an error string.\n-    #[deprecated=\"use `Show` (`{}` format specifier)\"]\n+    #[deprecated=\"use `fmt::String` (`{}` format specifier)\"]\n     pub fn to_err_msg(self) -> String {\n         self.to_string()\n     }\n }\n \n-impl fmt::Show for Fail {\n+impl fmt::String for Fail {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ArgumentMissing(ref nm) => {\n@@ -585,7 +584,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(cur[]) {\n+        if !is_arg(cur.index(&FullRange)) {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n@@ -595,7 +594,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             let mut names;\n             let mut i_arg = None;\n             if cur.as_bytes()[1] == b'-' {\n-                let tail = cur[2..curlen];\n+                let tail = cur.index(&(2..curlen));\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = vec!(Long(tail.to_string()));\n@@ -631,7 +630,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     };\n \n                     if arg_follows && range.next < curlen {\n-                        i_arg = Some(cur[range.next..curlen].to_string());\n+                        i_arg = Some(cur.index(&(range.next..curlen)).to_string());\n                         break;\n                     }\n \n@@ -650,29 +649,34 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     if name_pos == names.len() && !i_arg.is_none() {\n                         return Err(UnexpectedArgument(nm.to_string()));\n                     }\n-                    vals[optid].push(Given);\n+                    let v = &mut vals[optid];\n+                    v.push(Given);\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vals[optid]\n-                            .push(Val((i_arg.clone())\n+                        let v = &mut vals[optid];\n+                        v.push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(args[i + 1][]) {\n-                        vals[optid].push(Given);\n+                            is_arg(args[i + 1].index(&FullRange)) {\n+                        let v = &mut vals[optid];\n+                        v.push(Given);\n                     } else {\n                         i += 1;\n-                        vals[optid].push(Val(args[i].clone()));\n+                        let v = &mut vals[optid];\n+                        v.push(Val(args[i].clone()));\n                     }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val(i_arg.clone().unwrap()));\n+                        let v = &mut vals[optid];\n+                        v.push(Val(i_arg.clone().unwrap()));\n                     } else if i + 1 == l {\n                         return Err(ArgumentMissing(nm.to_string()));\n                     } else {\n                         i += 1;\n-                        vals[optid].push(Val(args[i].clone()));\n+                        let v = &mut vals[optid];\n+                        v.push(Val(args[i].clone()));\n                     }\n                   }\n                 }\n@@ -717,7 +721,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             1 => {\n                 row.push('-');\n-                row.push_str(short_name[]);\n+                row.push_str(short_name.index(&FullRange));\n                 row.push(' ');\n             }\n             _ => panic!(\"the short name should only be 1 ascii char long\"),\n@@ -728,18 +732,18 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(long_name[]);\n+                row.push_str(long_name.index(&FullRange));\n                 row.push(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(hint[]),\n+            Yes => row.push_str(hint.index(&FullRange)),\n             Maybe => {\n                 row.push('[');\n-                row.push_str(hint[]);\n+                row.push_str(hint.index(&FullRange));\n                 row.push(']');\n             }\n         }\n@@ -752,7 +756,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                 row.push(' ');\n             }\n         } else {\n-            row.push_str(desc_sep[]);\n+            row.push_str(desc_sep.index(&FullRange));\n         }\n \n         // Normalize desc to contain words separated by one space character\n@@ -764,14 +768,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n-        each_split_within(desc_normalized_whitespace[], 54, |substr| {\n+        each_split_within(desc_normalized_whitespace.index(&FullRange), 54, |substr| {\n             desc_rows.push(substr.to_string());\n             true\n         });\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(desc_rows.connect(desc_sep[])[]);\n+        row.push_str(desc_rows.connect(desc_sep.index(&FullRange)).index(&FullRange));\n \n         row\n     });\n@@ -790,18 +794,18 @@ fn format_option(opt: &OptGroup) -> String {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push('-');\n-        line.push_str(opt.short_name[]);\n+        line.push_str(opt.short_name.index(&FullRange));\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(opt.long_name[]);\n+        line.push_str(opt.long_name.index(&FullRange));\n     }\n \n     if opt.hasarg != No {\n         line.push(' ');\n         if opt.hasarg == Maybe {\n             line.push('[');\n         }\n-        line.push_str(opt.hint[]);\n+        line.push_str(opt.hint.index(&FullRange));\n         if opt.hasarg == Maybe {\n             line.push(']');\n         }\n@@ -823,7 +827,7 @@ pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     line.push_str(opts.iter()\n                       .map(format_option)\n                       .collect::<Vec<String>>()\n-                      .connect(\" \")[]);\n+                      .connect(\" \").index(&FullRange));\n     line\n }\n \n@@ -886,9 +890,9 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                             => panic!(\"word starting with {} longer than limit!\",\n-                                    ss[last_start..i + 1]),\n+                                    ss.index(&(last_start..(i + 1)))),\n             (B, Cr, OverLim)  => {\n-                *cont = it(ss[slice_start..last_end]);\n+                *cont = it(ss.index(&(slice_start..last_end)));\n                 slice_start = last_start;\n                 B\n             }\n@@ -898,7 +902,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             }\n             (B, Ws, OverLim)  => {\n                 last_end = i;\n-                *cont = it(ss[slice_start..last_end]);\n+                *cont = it(ss.index(&(slice_start..last_end)));\n                 A\n             }\n \n@@ -907,14 +911,14 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n                 B\n             }\n             (C, Cr, OverLim)  => {\n-                *cont = it(ss[slice_start..last_end]);\n+                *cont = it(ss.index(&(slice_start..last_end)));\n                 slice_start = i;\n                 last_start = i;\n                 last_end = i;\n                 B\n             }\n             (C, Ws, OverLim)  => {\n-                *cont = it(ss[slice_start..last_end]);\n+                *cont = it(ss.index(&(slice_start..last_end)));\n                 A\n             }\n             (C, Ws, UnderLim) => {"}, {"sha": "83bad70e7b117b05f67ff3a4157e2d21279713be", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -271,8 +271,7 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(globs, slicing_syntax)]\n-#![feature(unboxed_closures)]\n+#![feature(slicing_syntax)]\n \n use self::LabelText::*;\n \n@@ -453,7 +452,7 @@ impl<'a> LabelText<'a> {\n     pub fn escape(&self) -> String {\n         match self {\n             &LabelStr(ref s) => s.escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(s[]),\n+            &EscStr(ref s) => LabelText::escape_str(s.index(&FullRange)),\n         }\n     }\n \n@@ -482,7 +481,7 @@ impl<'a> LabelText<'a> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n-        prefix.push_str(suffix[]);\n+        prefix.push_str(suffix.index(&FullRange));\n         EscStr(prefix.into_cow())\n     }\n }\n@@ -676,7 +675,7 @@ mod tests {\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(self.name[]).unwrap()\n+            Id::new(self.name.index(&FullRange)).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)"}, {"sha": "e48272b4e09dabf4bbcfe8691333f616db3a2984", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(globs)]\n #![crate_name = \"libc\"]\n #![experimental]\n #![no_std] // we don't need std, and we can't have std, since it doesn't exist\n@@ -76,7 +75,7 @@\n #![allow(non_upper_case_globals)]\n #![allow(missing_docs)]\n #![allow(non_snake_case)]\n-#![allow(raw_pointer_deriving)]\n+#![allow(raw_pointer_derive)]\n \n extern crate core;\n \n@@ -5081,5 +5080,7 @@ pub fn issue_14344_workaround() {} // FIXME #14344 force linkage to happen corre\n #[doc(hidden)]\n #[cfg(not(test))]\n mod std {\n-    pub use core::kinds;\n+    #[cfg(stage0)]\n+    pub use core::marker as kinds;\n+    pub use core::marker;\n }"}, {"sha": "d741019aa7b9c3804e9e0ee27d12dcd5f208fabb", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -84,7 +84,7 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<Regex>) {\n         match Regex::new(filter) {\n             Ok(re) => Some(re),\n             Err(e) => {\n-                println!(\"warning: invalid regex filter - {}\", e);\n+                println!(\"warning: invalid regex filter - {:?}\", e);\n                 None\n             }\n         }"}, {"sha": "08b01e956e1ac83c073524226f8ca2ef5200d41d", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -16,12 +16,12 @@\n //! #[macro_use] extern crate log;\n //!\n //! fn main() {\n-//!     debug!(\"this is a debug {}\", \"message\");\n+//!     debug!(\"this is a debug {:?}\", \"message\");\n //!     error!(\"this is printed by default\");\n //!\n //!     if log_enabled!(log::INFO) {\n //!         let x = 3i * 4i; // expensive computation\n-//!         info!(\"the answer was: {}\", x);\n+//!         info!(\"the answer was: {:?}\", x);\n //!     }\n //! }\n //! ```\n@@ -163,7 +163,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules, unboxed_closures, slicing_syntax)]\n+#![feature(slicing_syntax)]\n #![deny(missing_docs)]\n \n extern crate regex;\n@@ -182,8 +182,7 @@ use regex::Regex;\n \n use directive::LOG_LEVEL_NAMES;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n pub mod macros;\n \n mod directive;\n@@ -238,11 +237,17 @@ struct DefaultLogger {\n pub struct LogLevel(pub u32);\n \n impl fmt::Show for LogLevel {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, fmt)\n+    }\n+}\n+\n+impl fmt::String for LogLevel {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let LogLevel(level) = *self;\n         match LOG_LEVEL_NAMES.get(level as uint - 1) {\n-            Some(name) => name.fmt(fmt),\n-            None => level.fmt(fmt)\n+            Some(ref name) => fmt::String::fmt(name, fmt),\n+            None => fmt::String::fmt(&level, fmt)\n         }\n     }\n }\n@@ -254,7 +259,7 @@ impl Logger for DefaultLogger {\n                        record.level,\n                        record.module_path,\n                        record.args) {\n-            Err(e) => panic!(\"failed to log: {}\", e),\n+            Err(e) => panic!(\"failed to log: {:?}\", e),\n             Ok(()) => {}\n         }\n     }\n@@ -264,7 +269,7 @@ impl Drop for DefaultLogger {\n     fn drop(&mut self) {\n         // FIXME(#12628): is panicking the right thing to do?\n         match self.handle.flush() {\n-            Err(e) => panic!(\"failed to flush a logger: {}\", e),\n+            Err(e) => panic!(\"failed to flush a logger: {:?}\", e),\n             Ok(()) => {}\n         }\n     }\n@@ -282,7 +287,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(args.to_string()[]) => return,\n+        Some(filter) if !filter.is_match(args.to_string().index(&FullRange)) => return,\n         _ => {}\n     }\n \n@@ -377,7 +382,7 @@ fn enabled(level: u32,\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(name[]) => {},\n+            Some(ref name) if !module.starts_with(name.index(&FullRange)) => {},\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -392,7 +397,7 @@ fn enabled(level: u32,\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n     let (mut directives, filter) = match os::getenv(\"RUST_LOG\") {\n-        Some(spec) => directive::parse_logging_spec(spec[]),\n+        Some(spec) => directive::parse_logging_spec(spec.index(&FullRange)),\n         None => (Vec::new(), None),\n     };\n "}, {"sha": "1002d9693ba691e3778abe1a1c0cf068f4cc9ac0", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -12,7 +12,7 @@\n \n // this is surprisingly complicated to be both generic & correct\n \n-use core::prelude::*;\n+use core::prelude::{PartialOrd};\n use core::num::Int;\n \n use Rng;\n@@ -166,7 +166,7 @@ mod tests {\n     use std::num::Int;\n     use std::prelude::v1::*;\n     use distributions::{Sample, IndependentSample};\n-    use super::Range;\n+    use super::Range as Range;\n \n     #[should_fail]\n     #[test]"}, {"sha": "ad2a4dbec4e923b98ac91786b1c310cf6d3c941b", "filename": "src/librand/lib.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -23,35 +23,14 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(macro_rules, phase, globs)]\n-#![feature(unboxed_closures)]\n-#![feature(associated_types)]\n #![no_std]\n #![experimental]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate core;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n extern crate core;\n \n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate std;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate std;\n-\n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate log;\n+#[cfg(test)] #[macro_use] extern crate std;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n use core::prelude::*;\n \n@@ -161,7 +140,7 @@ pub trait Rng : Sized {\n     ///\n     /// let mut v = [0u8; 13579];\n     /// thread_rng().fill_bytes(&mut v);\n-    /// println!(\"{}\", v.as_slice());\n+    /// println!(\"{:?}\", v.as_slice());\n     /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n         // this could, in theory, be done by transmuting dest to a\n@@ -197,7 +176,7 @@ pub trait Rng : Sized {\n     /// let mut rng = thread_rng();\n     /// let x: uint = rng.gen();\n     /// println!(\"{}\", x);\n-    /// println!(\"{}\", rng.gen::<(f64, bool)>());\n+    /// println!(\"{:?}\", rng.gen::<(f64, bool)>());\n     /// ```\n     #[inline(always)]\n     fn gen<T: Rand>(&mut self) -> T {\n@@ -215,8 +194,8 @@ pub trait Rng : Sized {\n     /// let mut rng = thread_rng();\n     /// let x = rng.gen_iter::<uint>().take(10).collect::<Vec<uint>>();\n     /// println!(\"{}\", x);\n-    /// println!(\"{}\", rng.gen_iter::<(f64, bool)>().take(5)\n-    ///                   .collect::<Vec<(f64, bool)>>());\n+    /// println!(\"{:?}\", rng.gen_iter::<(f64, bool)>().take(5)\n+    ///                     .collect::<Vec<(f64, bool)>>());\n     /// ```\n     fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self> {\n         Generator { rng: self }\n@@ -289,9 +268,9 @@ pub trait Rng : Sized {\n     ///\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = thread_rng();\n-    /// println!(\"{}\", rng.choose(&choices));\n-    /// # // replace with slicing syntax when it's stable!\n-    /// assert_eq!(rng.choose(choices.slice_to(0)), None);\n+    /// println!(\"{:?}\", rng.choose(&choices));\n+    /// # // uncomment when slicing syntax is stable\n+    /// //assert_eq!(rng.choose(choices.index(&(0..0))), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {\n@@ -516,7 +495,9 @@ pub struct Closed01<F>(pub F);\n mod std {\n     pub use core::{option, fmt}; // panic!()\n     pub use core::clone; // derive Clone\n-    pub use core::kinds;\n+    #[cfg(stage0)]\n+    pub use core::marker as kinds;\n+    pub use core::marker;\n }\n \n #[cfg(test)]"}, {"sha": "5ebec32d733841796f250b596328b6482fe47d73", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -95,7 +95,7 @@ impl Writer for SeekableMemWriter {\n             // there (left), and what will be appended on the end (right)\n             let cap = self.buf.len() - self.pos;\n             let (left, right) = if cap <= buf.len() {\n-                (buf[..cap], buf[cap..])\n+                (buf.index(&(0..cap)), buf.index(&(cap..)))\n             } else {\n                 let result: (_, &[_]) = (buf, &[]);\n                 result"}, {"sha": "a66d1dd08c1eb6aac528aa7723cde4a25d46e884", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 19, "deletions": 488, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -24,19 +24,10 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n-#![feature(macro_rules, phase, slicing_syntax, globs)]\n-#![feature(unboxed_closures, associated_types)]\n-#![allow(missing_docs)]\n+#![feature(slicing_syntax)]\n \n extern crate serialize;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n+#[macro_use] extern crate log;\n \n #[cfg(test)] extern crate test;\n \n@@ -65,7 +56,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data[self.start..self.end]).unwrap()\n+        str::from_utf8(self.data.index(&(self.start..self.end))).unwrap()\n     }\n \n     pub fn as_str(&self) -> String {\n@@ -147,7 +138,7 @@ pub mod reader {\n             match $e {\n                 Ok(e) => e,\n                 Err(e) => {\n-                    debug!(\"ignored error: {}\", e);\n+                    debug!(\"ignored error: {:?}\", e);\n                     return $r\n                 }\n             }\n@@ -256,7 +247,7 @@ pub mod reader {\n         match maybe_get_doc(d, tg) {\n             Some(d) => d,\n             None => {\n-                error!(\"failed to find block with tag {}\", tg);\n+                error!(\"failed to find block with tag {:?}\", tg);\n                 panic!();\n             }\n         }\n@@ -300,7 +291,7 @@ pub mod reader {\n     pub fn with_doc_data<T, F>(d: Doc, f: F) -> T where\n         F: FnOnce(&[u8]) -> T,\n     {\n-        f(d.data[d.start..d.end])\n+        f(d.data.index(&(d.start..d.end)))\n     }\n \n \n@@ -351,32 +342,32 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = r_doc.as_str_slice();\n                     if lbl != str {\n-                        return Err(Expected(format!(\"Expected label {} but \\\n-                                                     found {}\", lbl, str)));\n+                        return Err(Expected(format!(\"Expected label {:?} but \\\n+                                                     found {:?}\", lbl, str)));\n                     }\n                 }\n             }\n             Ok(())\n         }\n \n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n-            debug!(\". next_doc(exp_tag={})\", exp_tag);\n+            debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n                 return Err(Expected(format!(\"no more documents in \\\n                                              current node!\")));\n             }\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 try!(doc_at(self.parent.data, self.pos));\n-            debug!(\"self.parent={}-{} self.pos={} r_tag={} r_doc={}-{}\",\n+            debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n                    self.parent.start,\n                    self.parent.end,\n                    self.pos,\n                    r_tag,\n                    r_doc.start,\n                    r_doc.end);\n             if r_tag != (exp_tag as uint) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {} but \\\n-                                             found tag {}\", exp_tag, r_tag)));\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} but \\\n+                                             found tag {:?}\", exp_tag, r_tag)));\n             }\n             if r_doc.end > self.parent.end {\n                 return Err(Expected(format!(\"invalid EBML, child extends to \\\n@@ -403,7 +394,7 @@ pub mod reader {\n \n         fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<uint> {\n             let r = doc_as_u32(try!(self.next_doc(exp_tag)));\n-            debug!(\"_next_uint exp_tag={} result={}\", exp_tag, r);\n+            debug!(\"_next_uint exp_tag={:?} result={:?}\", exp_tag, r);\n             Ok(r as uint)\n         }\n \n@@ -424,263 +415,6 @@ pub mod reader {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    impl<'doc> serialize::Decoder<Error> for Decoder<'doc> {\n-        fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n-\n-        fn read_u64(&mut self) -> DecodeResult<u64> { Ok(doc_as_u64(try!(self.next_doc(EsU64)))) }\n-        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(doc_as_u32(try!(self.next_doc(EsU32)))) }\n-        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(doc_as_u16(try!(self.next_doc(EsU16)))) }\n-        fn read_u8 (&mut self) -> DecodeResult<u8 > { Ok(doc_as_u8 (try!(self.next_doc(EsU8 )))) }\n-        fn read_uint(&mut self) -> DecodeResult<uint> {\n-            let v = doc_as_u64(try!(self.next_doc(EsUint)));\n-            if v > (::std::uint::MAX as u64) {\n-                Err(IntTooBig(v as uint))\n-            } else {\n-                Ok(v as uint)\n-            }\n-        }\n-\n-        fn read_i64(&mut self) -> DecodeResult<i64> {\n-            Ok(doc_as_u64(try!(self.next_doc(EsI64))) as i64)\n-        }\n-        fn read_i32(&mut self) -> DecodeResult<i32> {\n-            Ok(doc_as_u32(try!(self.next_doc(EsI32))) as i32)\n-        }\n-        fn read_i16(&mut self) -> DecodeResult<i16> {\n-            Ok(doc_as_u16(try!(self.next_doc(EsI16))) as i16)\n-        }\n-        fn read_i8 (&mut self) -> DecodeResult<i8> {\n-            Ok(doc_as_u8(try!(self.next_doc(EsI8 ))) as i8)\n-        }\n-        fn read_int(&mut self) -> DecodeResult<int> {\n-            let v = doc_as_u64(try!(self.next_doc(EsInt))) as i64;\n-            if v > (int::MAX as i64) || v < (int::MIN as i64) {\n-                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                Err(IntTooBig(v as uint))\n-            } else {\n-                Ok(v as int)\n-            }\n-        }\n-\n-        fn read_bool(&mut self) -> DecodeResult<bool> {\n-            Ok(doc_as_u8(try!(self.next_doc(EsBool))) != 0)\n-        }\n-\n-        fn read_f64(&mut self) -> DecodeResult<f64> {\n-            let bits = doc_as_u64(try!(self.next_doc(EsF64)));\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_f32(&mut self) -> DecodeResult<f32> {\n-            let bits = doc_as_u32(try!(self.next_doc(EsF32)));\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_char(&mut self) -> DecodeResult<char> {\n-            Ok(char::from_u32(doc_as_u32(try!(self.next_doc(EsChar)))).unwrap())\n-        }\n-        fn read_str(&mut self) -> DecodeResult<String> {\n-            Ok(try!(self.next_doc(EsStr)).as_str())\n-        }\n-\n-        // Compound types:\n-        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_enum({})\", name);\n-            try!(self._check_label(name));\n-\n-            let doc = try!(self.next_doc(EsEnum));\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = try!(f(self));\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_variant<T, F>(&mut self, _: &[&str],\n-                                   mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_enum_variant()\");\n-            let idx = try!(self._next_uint(EsEnumVid));\n-            debug!(\"  idx={}\", idx);\n-\n-            let doc = try!(self.next_doc(EsEnumBody));\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = try!(f(self, idx));\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_enum_variant_arg(idx={})\", idx);\n-            f(self)\n-        }\n-\n-        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str],\n-                                          mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_enum_struct_variant()\");\n-            let idx = try!(self._next_uint(EsEnumVid));\n-            debug!(\"  idx={}\", idx);\n-\n-            let doc = try!(self.next_doc(EsEnumBody));\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = try!(f(self, idx));\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                                name: &str,\n-                                                idx: uint,\n-                                                f: F)\n-                                                -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-                debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_struct<T, F>(&mut self, name: &str, _: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_struct(name={})\", name);\n-            f(self)\n-        }\n-\n-        fn read_struct_field<T, F>(&mut self, name: &str, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-            try!(self._check_label(name));\n-            f(self)\n-        }\n-\n-        fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_tuple()\");\n-            self.read_seq(move |d, len| {\n-                if len == tuple_len {\n-                    f(d)\n-                } else {\n-                    Err(Expected(format!(\"Expected tuple of length `{}`, \\\n-                                          found tuple of length `{}`\", tuple_len, len)))\n-                }\n-            })\n-        }\n-\n-        fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_tuple_arg(idx={})\", idx);\n-            self.read_seq_elt(idx, f)\n-        }\n-\n-        fn read_tuple_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_tuple_struct(name={})\", name);\n-            self.read_tuple(len, f)\n-        }\n-\n-        fn read_tuple_struct_arg<T, F>(&mut self,\n-                                       idx: uint,\n-                                       f: F)\n-                                       -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n-            self.read_tuple_arg(idx, f)\n-        }\n-\n-        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T> where\n-            F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_option()\");\n-            self.read_enum(\"Option\", move |this| {\n-                this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n-                    match idx {\n-                        0 => f(this, false),\n-                        1 => f(this, true),\n-                        _ => {\n-                            Err(Expected(format!(\"Expected None or Some\")))\n-                        }\n-                    }\n-                })\n-            })\n-        }\n-\n-        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_seq()\");\n-            self.push_doc(EsVec, move |d| {\n-                let len = try!(d._next_uint(EsVecLen));\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_seq_elt(idx={})\", idx);\n-            self.push_doc(EsVecElt, f)\n-        }\n-\n-        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_map()\");\n-            self.push_doc(EsMap, move |d| {\n-                let len = try!(d._next_uint(EsMapLen));\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_map_elt_key(idx={})\", idx);\n-            self.push_doc(EsMapKey, f)\n-        }\n-\n-        fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_map_elt_val(idx={})\", idx);\n-            self.push_doc(EsMapVal, f)\n-        }\n-\n-        fn error(&mut self, err: &str) -> Error {\n-            ApplicationError(err.to_string())\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     impl<'doc> serialize::Decoder for Decoder<'doc> {\n         type Error = Error;\n         fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n@@ -1007,7 +741,7 @@ pub mod writer {\n         }\n \n         pub fn start_tag(&mut self, tag_id: uint) -> EncodeResult {\n-            debug!(\"Start tag {}\", tag_id);\n+            debug!(\"Start tag {:?}\", tag_id);\n \n             // Write the enum ID:\n             try!(write_vuint(self.writer, tag_id));\n@@ -1026,7 +760,7 @@ pub mod writer {\n             try!(write_sized_vuint(self.writer, size, 4u));\n             let r = try!(self.writer.seek(cur_pos as i64, io::SeekSet));\n \n-            debug!(\"End tag (size = {})\", size);\n+            debug!(\"End tag (size = {:?})\", size);\n             Ok(r)\n         }\n \n@@ -1093,12 +827,12 @@ pub mod writer {\n         }\n \n         pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n-            debug!(\"Write {} bytes\", b.len());\n+            debug!(\"Write {:?} bytes\", b.len());\n             self.writer.write(b)\n         }\n \n         pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n-            debug!(\"Write str: {}\", s);\n+            debug!(\"Write str: {:?}\", s);\n             self.writer.write(s.as_bytes())\n         }\n     }\n@@ -1137,209 +871,6 @@ pub mod writer {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    impl<'a, W: Writer + Seek> serialize::Encoder<io::IoError> for Encoder<'a, W> {\n-\n-        fn emit_nil(&mut self) -> EncodeResult {\n-            Ok(())\n-        }\n-\n-        fn emit_uint(&mut self, v: uint) -> EncodeResult {\n-            self.wr_tagged_u64(EsUint as uint, v as u64)\n-        }\n-        fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            self.wr_tagged_u64(EsU64 as uint, v)\n-        }\n-        fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            self.wr_tagged_u32(EsU32 as uint, v)\n-        }\n-        fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            self.wr_tagged_u16(EsU16 as uint, v)\n-        }\n-        fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_u8(EsU8 as uint, v)\n-        }\n-\n-        fn emit_int(&mut self, v: int) -> EncodeResult {\n-            self.wr_tagged_i64(EsInt as uint, v as i64)\n-        }\n-        fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            self.wr_tagged_i64(EsI64 as uint, v)\n-        }\n-        fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            self.wr_tagged_i32(EsI32 as uint, v)\n-        }\n-        fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            self.wr_tagged_i16(EsI16 as uint, v)\n-        }\n-        fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_i8(EsI8 as uint, v)\n-        }\n-\n-        fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_u8(EsBool as uint, v as u8)\n-        }\n-\n-        fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_u64(EsF64 as uint, bits)\n-        }\n-        fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_u32(EsF32 as uint, bits)\n-        }\n-        fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_u32(EsChar as uint, v as u32)\n-        }\n-\n-        fn emit_str(&mut self, v: &str) -> EncodeResult {\n-            self.wr_tagged_str(EsStr as uint, v)\n-        }\n-\n-        fn emit_enum<F>(&mut self, name: &str, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            try!(self._emit_label(name));\n-            try!(self.start_tag(EsEnum as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_enum_variant<F>(&mut self,\n-                                _: &str,\n-                                v_id: uint,\n-                                _: uint,\n-                                f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            try!(self._emit_tagged_uint(EsEnumVid, v_id));\n-            try!(self.start_tag(EsEnumBody as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_enum_variant_arg<F>(&mut self, _: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_enum_struct_variant<F>(&mut self,\n-                                       v_name: &str,\n-                                       v_id: uint,\n-                                       cnt: uint,\n-                                       f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_enum_variant(v_name, v_id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field<F>(&mut self,\n-                                             _: &str,\n-                                             idx: uint,\n-                                             f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct<F>(&mut self, _: &str, _len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_struct_field<F>(&mut self, name: &str, _: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            try!(self._emit_label(name));\n-            f(self)\n-        }\n-\n-        fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_enum(\"Option\", f)\n-        }\n-        fn emit_option_none(&mut self) -> EncodeResult {\n-            self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-        }\n-        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            self.emit_enum_variant(\"Some\", 1, 1, f)\n-        }\n-\n-        fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            try!(self.start_tag(EsVec as uint));\n-            try!(self._emit_tagged_uint(EsVecLen, len));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_seq_elt<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            try!(self.start_tag(EsVecElt as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            try!(self.start_tag(EsMap as uint));\n-            try!(self._emit_tagged_uint(EsMapLen, len));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_key<F>(&mut self, _idx: uint, mut f: F) -> EncodeResult where\n-            F: FnMut(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            try!(self.start_tag(EsMapKey as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            try!(self.start_tag(EsMapVal as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     impl<'a, W: Writer + Seek> serialize::Encoder for Encoder<'a, W> {\n         type Error = io::IoError;\n \n@@ -1608,7 +1139,7 @@ mod tests {\n     #[test]\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n-            debug!(\"v == {}\", v);\n+            debug!(\"v == {:?}\", v);\n             let mut wr = SeekableMemWriter::new();\n             {\n                 let mut rbml_w = writer::Encoder::new(&mut wr);\n@@ -1617,7 +1148,7 @@ mod tests {\n             let rbml_doc = Doc::new(wr.get_ref());\n             let mut deser = reader::Decoder::new(rbml_doc);\n             let v1 = Decodable::decode(&mut deser).unwrap();\n-            debug!(\"v1 == {}\", v1);\n+            debug!(\"v1 == {:?}\", v1);\n             assert_eq!(v, v1);\n         }\n "}, {"sha": "5803da1d3350d541867c381caad253e904a4e0fa", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -105,7 +105,7 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = String::with_capacity(5);\n-        for inst in c.insts[1..].iter() {\n+        for inst in c.insts.index(&(1..)).iter() {\n             match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push(c),\n                 _ => break"}, {"sha": "c039abc9aff2a8955134bfbcd8181f2a46b85ae9", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -13,7 +13,6 @@\n //! Regular expressions implemented in Rust\n //!\n //! For official documentation, see the rust-lang/regex crate\n-\n #![crate_name = \"regex\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -24,9 +23,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, slicing_syntax, globs)]\n-#![feature(unboxed_closures)]\n-#![feature(associated_types)]\n+#![feature(slicing_syntax)]\n #![deny(missing_docs)]\n \n #[cfg(test)]"}, {"sha": "dd11d42b8aad60b0186701538d1554d1de626d52", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -18,6 +18,7 @@ use std::cmp;\n use std::fmt;\n use std::iter;\n use std::num;\n+use std::ops::Index;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n@@ -39,7 +40,7 @@ pub struct Error {\n \n impl fmt::Show for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Regex syntax error near position {}: {}\",\n+        write!(f, \"Regex syntax error near position {}: {:?}\",\n                self.pos, self.msg)\n     }\n }\n@@ -121,15 +122,15 @@ impl BuildAst {\n     fn flags(&self) -> Flags {\n         match *self {\n             Paren(flags, _, _) => flags,\n-            _ => panic!(\"Cannot get flags from {}\", self),\n+            _ => panic!(\"Cannot get flags from {:?}\", self),\n         }\n     }\n \n     fn capture(&self) -> Option<uint> {\n         match *self {\n             Paren(_, 0, _) => None,\n             Paren(_, c, _) => Some(c),\n-            _ => panic!(\"Cannot get capture group from {}\", self),\n+            _ => panic!(\"Cannot get capture group from {:?}\", self),\n         }\n     }\n \n@@ -143,7 +144,7 @@ impl BuildAst {\n                     Some(name.clone())\n                 }\n             }\n-            _ => panic!(\"Cannot get capture name from {}\", self),\n+            _ => panic!(\"Cannot get capture name from {:?}\", self),\n         }\n     }\n \n@@ -157,7 +158,7 @@ impl BuildAst {\n     fn unwrap(self) -> Result<Ast, Error> {\n         match self {\n             Expr(x) => Ok(x),\n-            _ => panic!(\"Tried to unwrap non-AST item: {}\", self),\n+            _ => panic!(\"Tried to unwrap non-AST item: {:?}\", self),\n         }\n     }\n }\n@@ -284,20 +285,20 @@ impl<'a> Parser<'a> {\n         match self.next_char() {\n             true => Ok(()),\n             false => {\n-                self.err(format!(\"Expected {} but got EOF.\",\n-                                 expected)[])\n+                self.err(format!(\"Expected {:?} but got EOF.\",\n+                                 expected).index(&FullRange))\n             }\n         }\n     }\n \n     fn expect(&mut self, expected: char) -> Result<(), Error> {\n         match self.next_char() {\n             true if self.cur() == expected => Ok(()),\n-            true => self.err(format!(\"Expected '{}' but got '{}'.\",\n-                                     expected, self.cur())[]),\n+            true => self.err(format!(\"Expected '{:?}' but got '{:?}'.\",\n+                                     expected, self.cur()).index(&FullRange)),\n             false => {\n-                self.err(format!(\"Expected '{}' but got EOF.\",\n-                                 expected)[])\n+                self.err(format!(\"Expected '{:?}' but got EOF.\",\n+                                 expected).index(&FullRange))\n             }\n         }\n     }\n@@ -394,7 +395,7 @@ impl<'a> Parser<'a> {\n                             continue\n                         }\n                         Some(ast) =>\n-                            panic!(\"Expected Class AST but got '{}'\", ast),\n+                            panic!(\"Expected Class AST but got '{:?}'\", ast),\n                         // Just drop down and try to add as a regular character.\n                         None => {},\n                     },\n@@ -409,7 +410,7 @@ impl<'a> Parser<'a> {\n                             return self.err(\n                                 \"\\\\A, \\\\z, \\\\b and \\\\B are not valid escape \\\n                                  sequences inside a character class.\"),\n-                        ast => panic!(\"Unexpected AST item '{}'\", ast),\n+                        ast => panic!(\"Unexpected AST item '{:?}'\", ast),\n                     }\n                 }\n                 ']' if ranges.len() > 0 || alts.len() > 0 => {\n@@ -442,15 +443,15 @@ impl<'a> Parser<'a> {\n                     match try!(self.parse_escape()) {\n                         Literal(c3, _) => c2 = c3, // allow literal escapes below\n                         ast =>\n-                            return self.err(format!(\"Expected a literal, but got {}.\",\n-                                                    ast)[]),\n+                            return self.err(format!(\"Expected a literal, but got {:?}.\",\n+                                                    ast).index(&FullRange)),\n                     }\n                 }\n                 if c2 < c {\n                     return self.err(format!(\"Invalid character class \\\n                                              range '{}-{}'\",\n                                             c,\n-                                            c2)[])\n+                                            c2).index(&FullRange))\n                 }\n                 ranges.push((c, self.cur()))\n             } else {\n@@ -488,7 +489,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let name = self.slice(name_start, closer - 1);\n-        match find_class(ASCII_CLASSES, name[]) {\n+        match find_class(ASCII_CLASSES, name.index(&FullRange)) {\n             None => None,\n             Some(ranges) => {\n                 self.chari = closer;\n@@ -512,19 +513,19 @@ impl<'a> Parser<'a> {\n                 None => {\n                     return self.err(format!(\"No closing brace for counted \\\n                                              repetition starting at position \\\n-                                             {}.\",\n-                                            start)[])\n+                                             {:?}.\",\n+                                            start).index(&FullRange))\n                 }\n             };\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n-        let inner = self.chars[start+1..closer].iter().cloned()\n+        let inner = self.chars.index(&((start+1)..closer)).iter().cloned()\n                                                .collect::<String>();\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n         if !inner.contains(\",\") {\n-            min = try!(self.parse_uint(inner[]));\n+            min = try!(self.parse_uint(inner.index(&FullRange)));\n             max = Some(min);\n         } else {\n             let pieces: Vec<&str> = inner.splitn(1, ',').collect();\n@@ -546,19 +547,19 @@ impl<'a> Parser<'a> {\n         if min > MAX_REPEAT {\n             return self.err(format!(\n                 \"{} exceeds maximum allowed repetitions ({})\",\n-                min, MAX_REPEAT)[]);\n+                min, MAX_REPEAT).index(&FullRange));\n         }\n         if max.is_some() {\n             let m = max.unwrap();\n             if m > MAX_REPEAT {\n                 return self.err(format!(\n                     \"{} exceeds maximum allowed repetitions ({})\",\n-                    m, MAX_REPEAT)[]);\n+                    m, MAX_REPEAT).index(&FullRange));\n             }\n             if m < min {\n                 return self.err(format!(\n                     \"Max repetitions ({}) cannot be smaller than min \\\n-                     repetitions ({}).\", m, min)[]);\n+                     repetitions ({}).\", m, min).index(&FullRange));\n             }\n         }\n \n@@ -622,7 +623,7 @@ impl<'a> Parser<'a> {\n                 Ok(AstClass(ranges, flags))\n             }\n             _ => {\n-                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)[])\n+                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c).index(&FullRange))\n             }\n         }\n     }\n@@ -642,7 +643,7 @@ impl<'a> Parser<'a> {\n                     Some(i) => i,\n                     None => return self.err(format!(\n                         \"Missing '}}' for unclosed '{{' at position {}\",\n-                        self.chari)[]),\n+                        self.chari).index(&FullRange)),\n                 };\n             if closer - self.chari + 1 == 0 {\n                 return self.err(\"No Unicode class name found.\")\n@@ -656,10 +657,10 @@ impl<'a> Parser<'a> {\n             name = self.slice(self.chari + 1, self.chari + 2);\n             self.chari += 1;\n         }\n-        match find_class(UNICODE_CLASSES, name[]) {\n+        match find_class(UNICODE_CLASSES, name.index(&FullRange)) {\n             None => {\n                 return self.err(format!(\"Could not find Unicode class '{}'\",\n-                                        name)[])\n+                                        name).index(&FullRange))\n             }\n             Some(ranges) => {\n                 Ok(AstClass(ranges, negated | (self.flags & FLAG_NOCASE)))\n@@ -682,11 +683,11 @@ impl<'a> Parser<'a> {\n             }\n         }\n         let s = self.slice(start, end);\n-        match num::from_str_radix::<u32>(s[], 8) {\n+        match num::from_str_radix::<u32>(s.index(&FullRange), 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{}' as octal number.\",\n-                                 s)[])\n+                self.err(format!(\"Could not parse '{:?}' as octal number.\",\n+                                 s).index(&FullRange))\n             }\n         }\n     }\n@@ -704,12 +705,12 @@ impl<'a> Parser<'a> {\n                 None => {\n                     return self.err(format!(\"Missing '}}' for unclosed \\\n                                              '{{' at position {}\",\n-                                            start)[])\n+                                            start).index(&FullRange))\n                 }\n                 Some(i) => i,\n             };\n         self.chari = closer;\n-        self.parse_hex_digits(self.slice(start, closer)[])\n+        self.parse_hex_digits(self.slice(start, closer).index(&FullRange))\n     }\n \n     // Parses a two-digit hex number.\n@@ -729,7 +730,7 @@ impl<'a> Parser<'a> {\n         match num::from_str_radix::<u32>(s, 16) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{}' as hex number.\", s)[])\n+                self.err(format!(\"Could not parse '{}' as hex number.\", s).index(&FullRange))\n             }\n         }\n     }\n@@ -755,7 +756,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.names.contains(&name) {\n             return self.err(format!(\"Duplicate capture group name '{}'.\",\n-                                    name)[])\n+                                    name).index(&FullRange))\n         }\n         self.names.push(name.clone());\n         self.chari = closer;\n@@ -789,7 +790,7 @@ impl<'a> Parser<'a> {\n                     if sign < 0 {\n                         return self.err(format!(\n                             \"Cannot negate flags twice in '{}'.\",\n-                            self.slice(start, self.chari + 1))[])\n+                            self.slice(start, self.chari + 1)).index(&FullRange))\n                     }\n                     sign = -1;\n                     saw_flag = false;\n@@ -800,7 +801,7 @@ impl<'a> Parser<'a> {\n                         if !saw_flag {\n                             return self.err(format!(\n                                 \"A valid flag does not follow negation in '{}'\",\n-                                self.slice(start, self.chari + 1))[])\n+                                self.slice(start, self.chari + 1)).index(&FullRange))\n                         }\n                         flags = flags ^ flags;\n                     }\n@@ -812,7 +813,7 @@ impl<'a> Parser<'a> {\n                     return Ok(())\n                 }\n                 _ => return self.err(format!(\n-                    \"Unrecognized flag '{}'.\", self.cur())[]),\n+                    \"Unrecognized flag '{}'.\", self.cur()).index(&FullRange)),\n             }\n         }\n     }\n@@ -910,7 +911,7 @@ impl<'a> Parser<'a> {\n             Some(i) => Ok(i),\n             None => {\n                 self.err(format!(\"Expected an unsigned integer but got '{}'.\",\n-                                 s)[])\n+                                 s).index(&FullRange))\n             }\n         }\n     }\n@@ -920,7 +921,7 @@ impl<'a> Parser<'a> {\n             Some(c) => Ok(c),\n             None => {\n                 self.err(format!(\"Could not decode '{}' to unicode \\\n-                                  character.\", n)[])\n+                                  character.\", n).index(&FullRange))\n             }\n         }\n     }\n@@ -953,7 +954,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        self.chars[start..end].iter().cloned().collect()\n+        self.chars.index(&(start..end)).iter().cloned().collect()\n     }\n }\n "}, {"sha": "37f9869f3bfaf6e50e0be95965f8fe993472390c", "filename": "src/libregex/re.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -90,10 +90,19 @@ impl Clone for ExNative {\n     }\n }\n \n+#[cfg(stage0)]\n+//FIXME: remove after stage0 snapshot\n impl fmt::Show for Regex {\n     /// Shows the original regular expression.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.as_str())\n+        fmt::String::fmt(self.as_str(), f)\n+    }\n+}\n+\n+impl fmt::String for Regex {\n+    /// Shows the original regular expression.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self.as_str(), f)\n     }\n }\n \n@@ -238,19 +247,19 @@ impl Regex {\n             }\n \n             let (s, e) = cap.pos(0).unwrap(); // captures only reports matches\n-            new.push_str(text[last_match..s]);\n-            new.push_str(rep.reg_replace(&cap)[]);\n+            new.push_str(text.index(&(last_match..s)));\n+            new.push_str(rep.reg_replace(&cap).index(&FullRange));\n             last_match = e;\n         }\n-        new.push_str(text[last_match..text.len()]);\n+        new.push_str(text.index(&(last_match..text.len())));\n         return new;\n     }\n \n     /// Returns the original string of this regex.\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         match *self {\n-            Dynamic(ExDynamic { ref original, .. }) => original[],\n-            Native(ExNative { ref original, .. }) => original[],\n+            Dynamic(ExDynamic { ref original, .. }) => original.index(&FullRange),\n+            Native(ExNative { ref original, .. }) => original.index(&FullRange),\n         }\n     }\n \n@@ -347,13 +356,13 @@ impl<'r, 't> Iterator for RegexSplits<'r, 't> {\n                 if self.last >= text.len() {\n                     None\n                 } else {\n-                    let s = text[self.last..text.len()];\n+                    let s = text.index(&(self.last..text.len()));\n                     self.last = text.len();\n                     Some(s)\n                 }\n             }\n             Some((s, e)) => {\n-                let matched = text[self.last..s];\n+                let matched = text.index(&(self.last..s));\n                 self.last = e;\n                 Some(matched)\n             }\n@@ -384,7 +393,7 @@ impl<'r, 't> Iterator for RegexSplitsN<'r, 't> {\n         } else {\n             self.cur += 1;\n             if self.cur >= self.limit {\n-                Some(text[self.splits.last..text.len()])\n+                Some(text.index(&(self.splits.last..text.len())))\n             } else {\n                 self.splits.next()\n             }\n@@ -517,7 +526,7 @@ impl<'t> Captures<'t> {\n             })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n-        re.replace_all(text[], NoExpand(\"$\"))\n+        re.replace_all(text.index(&FullRange), NoExpand(\"$\"))\n     }\n \n     /// Returns the number of captured groups."}, {"sha": "e11094b1174713a1b2bdbdc0480d4c94421dbd83", "filename": "src/libregex/test/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -12,7 +12,7 @@ macro_rules! regex {\n     ($re:expr) => (\n         match ::regex::Regex::new($re) {\n             Ok(re) => re,\n-            Err(err) => panic!(\"{}\", err),\n+            Err(err) => panic!(\"{:?}\", err),\n         }\n     );\n }"}, {"sha": "b69420ac05bd1336e5b187950f8037bd0c2815e6", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -159,10 +159,10 @@ macro_rules! mat {\n             // actual capture groups to match test set.\n             let mut sgot = got.as_slice();\n             if sgot.len() > expected.len() {\n-                sgot = sgot[0..expected.len()]\n+                sgot = &sgot[..expected.len()]\n             }\n             if expected != sgot {\n-                panic!(\"For RE '{}' against '{}', expected '{}' but got '{}'\",\n+                panic!(\"For RE '{}' against '{}', expected '{:?}' but got '{:?}'\",\n                       $re, text, expected, sgot);\n             }\n         }"}, {"sha": "04c430da4d29080f222f10cb935b57aa1482e7c5", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -152,7 +152,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                 // out early.\n                 if self.prog.prefix.len() > 0 && clist.size == 0 {\n                     let needle = self.prog.prefix.as_bytes();\n-                    let haystack = self.input.as_bytes()[self.ic..];\n+                    let haystack = self.input.as_bytes().index(&(self.ic..));\n                     match find_prefix(needle, haystack) {\n                         None => break,\n                         Some(i) => {\n@@ -503,7 +503,8 @@ impl Threads {\n \n     #[inline]\n     fn groups<'r>(&'r mut self, i: uint) -> &'r mut [Option<uint>] {\n-        self.queue[i].groups.as_mut_slice()\n+        let q = &mut self.queue[i];\n+        q.groups.as_mut_slice()\n     }\n }\n "}, {"sha": "a3a041c2497c7a9fed075053374a2127f9e6929a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -23,12 +23,10 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(unknown_features)]\n-#![feature(default_type_params, globs, macro_rules, phase, quote)]\n+#![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n+#![feature(old_impl_check)]\n \n extern crate arena;\n extern crate flate;\n@@ -40,22 +38,8 @@ extern crate rustc_back;\n extern crate serialize;\n extern crate rbml;\n extern crate collections;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n "}, {"sha": "1af8e2f29ebd7c63faf25b93bc15f9a54bb92dd4", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -46,7 +46,7 @@ use syntax::ast_util::is_shift_binop;\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token;\n-use syntax::ast::{TyI, TyU, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n+use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ast_util;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n@@ -216,7 +216,7 @@ impl LintPass for TypeLimits {\n                         match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                                let int_type = if t == ast::TyI {\n+                                let int_type = if t == ast::TyIs {\n                                     cx.sess().target.int_type\n                                 } else { t };\n                                 let (min, max) = int_ty_range(int_type);\n@@ -233,7 +233,7 @@ impl LintPass for TypeLimits {\n                         };\n                     },\n                     ty::ty_uint(t) => {\n-                        let uint_type = if t == ast::TyU {\n+                        let uint_type = if t == ast::TyUs {\n                             cx.sess().target.uint_type\n                         } else { t };\n                         let (min, max) = uint_ty_range(uint_type);\n@@ -296,7 +296,7 @@ impl LintPass for TypeLimits {\n         // warnings are consistent between 32- and 64-bit platforms\n         fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n             match int_ty {\n-                ast::TyI =>    (i64::MIN,        i64::MAX),\n+                ast::TyIs=>    (i64::MIN,        i64::MAX),\n                 ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n                 ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n                 ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n@@ -306,7 +306,7 @@ impl LintPass for TypeLimits {\n \n         fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                ast::TyU =>   (u64::MIN,         u64::MAX),\n+                ast::TyUs=>   (u64::MIN,         u64::MAX),\n                 ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n                 ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n                 ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n@@ -323,7 +323,7 @@ impl LintPass for TypeLimits {\n \n         fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::TyI =>    int_ty_bits(target_int_ty, target_int_ty),\n+                ast::TyIs=>    int_ty_bits(target_int_ty, target_int_ty),\n                 ast::TyI8 =>   i8::BITS  as u64,\n                 ast::TyI16 =>  i16::BITS as u64,\n                 ast::TyI32 =>  i32::BITS as u64,\n@@ -333,7 +333,7 @@ impl LintPass for TypeLimits {\n \n         fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::TyU =>    uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::TyUs=>    uint_ty_bits(target_uint_ty, target_uint_ty),\n                 ast::TyU8 =>   u8::BITS  as u64,\n                 ast::TyU16 =>  u16::BITS as u64,\n                 ast::TyU32 =>  u32::BITS as u64,\n@@ -404,14 +404,14 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, ty_id: ast::NodeId, path_id: ast::NodeId) {\n         match self.cx.tcx.def_map.borrow()[path_id].clone() {\n-            def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n+            def::DefPrimTy(ast::TyInt(ast::TyIs)) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                  \"found rust type `int` in foreign module, while \\\n+                                  \"found rust type `isize` in foreign module, while \\\n                                    libc::c_int or libc::c_long should be used\");\n             }\n-            def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n+            def::DefPrimTy(ast::TyUint(ast::TyUs)) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                  \"found rust type `uint` in foreign module, while \\\n+                                  \"found rust type `usize` in foreign module, while \\\n                                    libc::c_uint or libc::c_ulong should be used\");\n             }\n             def::DefTy(..) => {\n@@ -506,7 +506,7 @@ impl BoxPointers {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(BOX_POINTERS, span, m[]);\n+            cx.span_lint(BOX_POINTERS, span, m.index(&FullRange));\n         }\n     }\n }\n@@ -586,7 +586,7 @@ impl LintPass for RawPointerDerive {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !attr::contains_name(item.attrs[], \"automatically_derived\") {\n+        if !attr::contains_name(item.attrs.index(&FullRange), \"automatically_derived\") {\n             return\n         }\n         let did = match item.node {\n@@ -669,6 +669,7 @@ impl LintPass for UnusedAttributes {\n \n             // FIXME: #19470 this shouldn't be needed forever\n             \"old_orphan_check\",\n+            \"old_impl_check\",\n         ];\n \n         static CRATE_ATTRS: &'static [&'static str] = &[\n@@ -769,11 +770,11 @@ impl LintPass for UnusedResults {\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, it.attrs[], s.span);\n+                        warned |= check_must_use(cx, it.attrs.index(&FullRange), s.span);\n                     }\n                 } else {\n                     csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n-                        warned |= check_must_use(cx, attrs[], s.span);\n+                        warned |= check_must_use(cx, attrs.index(&FullRange), s.span);\n                     });\n                 }\n             }\n@@ -795,7 +796,7 @@ impl LintPass for UnusedResults {\n                             msg.push_str(s.get());\n                         }\n                     }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, msg[]);\n+                    cx.span_lint(UNUSED_MUST_USE, sp, msg.index(&FullRange));\n                     return true;\n                 }\n             }\n@@ -841,7 +842,7 @@ impl NonCamelCaseTypes {\n             } else {\n                 format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n             };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m[]);\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m.index(&FullRange));\n         }\n     }\n }\n@@ -981,7 +982,7 @@ impl NonSnakeCase {\n         if !is_snake_case(ident) {\n             cx.span_lint(NON_SNAKE_CASE, span,\n                 format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, s, to_snake_case(s.get()))[]);\n+                        sort, s, to_snake_case(s.get())).index(&FullRange));\n         }\n     }\n }\n@@ -1068,7 +1069,7 @@ impl LintPass for NonUpperCaseGlobals {\n                         format!(\"static constant `{}` should have an uppercase name \\\n                                  such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                .collect::<String>()[])[]);\n+                                .collect::<String>().index(&FullRange)).index(&FullRange));\n                 }\n             }\n             _ => {}\n@@ -1085,7 +1086,7 @@ impl LintPass for NonUpperCaseGlobals {\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>()[])[]);\n+                                    .collect::<String>().index(&FullRange)).index(&FullRange));\n                 }\n             }\n             _ => {}\n@@ -1110,7 +1111,7 @@ impl UnusedParens {\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n                              format!(\"unnecessary parentheses around {}\",\n-                                     msg)[])\n+                                     msg).index(&FullRange))\n             }\n         }\n \n@@ -1212,7 +1213,7 @@ impl LintPass for UnusedImportBraces {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n                                     cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n-                                                 m[]);\n+                                                 m.index(&FullRange));\n                                 },\n                                 _ => ()\n                             }\n@@ -1251,7 +1252,7 @@ impl LintPass for NonShorthandFieldPatterns {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str())[])\n+                                              be removed\", ident.node.as_str()).index(&FullRange))\n                     }\n                 }\n             }\n@@ -1328,7 +1329,7 @@ impl UnusedMut {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n                     if !token::get_ident(ident).get().starts_with(\"_\") {\n-                        match mutables.entry(&ident.name.uint()) {\n+                        match mutables.entry(ident.name.uint()) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }\n@@ -1355,7 +1356,7 @@ impl LintPass for UnusedMut {\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms.iter() {\n-                self.check_unused_mut_pat(cx, a.pats[])\n+                self.check_unused_mut_pat(cx, a.pats.index(&FullRange))\n             }\n         }\n     }\n@@ -1476,7 +1477,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                format!(\"missing documentation for {}\", desc)[]);\n+                format!(\"missing documentation for {}\", desc).index(&FullRange));\n         }\n     }\n }\n@@ -1490,7 +1491,7 @@ impl LintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(l[], \"hidden\"),\n+                Some(l) => attr::contains_name(l.index(&FullRange), \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -1512,7 +1513,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, krate.attrs[],\n+        self.check_missing_docs_attrs(cx, None, krate.attrs.index(&FullRange),\n                                      krate.span, \"crate\");\n     }\n \n@@ -1526,7 +1527,7 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs.index(&FullRange),\n                                      it.span, desc);\n     }\n \n@@ -1539,13 +1540,13 @@ impl LintPass for MissingDoc {\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs[],\n+            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs.index(&FullRange),\n                                           m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs.index(&FullRange),\n                                      tm.span, \"a type method\");\n     }\n \n@@ -1555,14 +1556,14 @@ impl LintPass for MissingDoc {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              sf.node.attrs[], sf.span,\n+                                              sf.node.attrs.index(&FullRange), sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs.index(&FullRange),\n                                      v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n@@ -1629,7 +1630,6 @@ declare_lint! {\n     Warn,\n     \"detects use of #[deprecated] items\"\n }\n-\n // FIXME #6875: Change to Warn after std library stabilization is complete\n declare_lint! {\n     EXPERIMENTAL,\n@@ -1674,7 +1674,7 @@ impl Stability {\n             _ => format!(\"use of {} item\", label)\n         };\n \n-        cx.span_lint(lint, span, msg[]);\n+        cx.span_lint(lint, span, msg.index(&FullRange));\n     }\n \n     fn is_internal(&self, cx: &Context, span: Span) -> bool {\n@@ -1848,7 +1848,7 @@ declare_lint! {\n     \"detects transmutes of fat pointers\"\n }\n \n-declare_lint!{\n+declare_lint! {\n     pub MISSING_COPY_IMPLEMENTATIONS,\n     Warn,\n     \"detects potentially-forgotten implementations of `Copy`\""}, {"sha": "51998bdbcf299dda29f9bcf011b4c3b051af0d67", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -104,7 +104,7 @@ impl LintStore {\n     }\n \n     pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n-        self.lints[]\n+        self.lints.index(&FullRange)\n     }\n \n     pub fn get_lint_groups<'t>(&'t self) -> Vec<(&'static str, Vec<LintId>, bool)> {\n@@ -124,11 +124,11 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(msg[]),\n-                    (Some(sess), false) => sess.bug(msg[]),\n+                    (None, _) => early_error(msg.index(&FullRange)),\n+                    (Some(sess), false) => sess.bug(msg.index(&FullRange)),\n \n                     // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(msg[]),\n+                    (Some(sess), true)  => sess.err(msg.index(&FullRange)),\n                 }\n             }\n \n@@ -149,11 +149,11 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(msg[]),\n-                (Some(sess), false) => sess.bug(msg[]),\n+                (None, _) => early_error(msg.index(&FullRange)),\n+                (Some(sess), false) => sess.bug(msg.index(&FullRange)),\n \n                 // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(msg[]),\n+                (Some(sess), true)  => sess.err(msg.index(&FullRange)),\n             }\n         }\n     }\n@@ -267,8 +267,8 @@ impl LintStore {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n                                       lint_name, new_name);\n                 match span {\n-                    Some(span) => sess.span_warn(span, warning[]),\n-                    None => sess.warn(warning[]),\n+                    Some(span) => sess.span_warn(span, warning.index(&FullRange)),\n+                    None => sess.warn(warning.index(&FullRange)),\n                 };\n                 Some(lint_id)\n             }\n@@ -278,21 +278,21 @@ impl LintStore {\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n-            match self.find_lint(lint_name[], sess, None) {\n+            match self.find_lint(lint_name.index(&FullRange), sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .get(lint_name[]) {\n+                                                 .get(lint_name.index(&FullRange)) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n                                      self.set_level(*lint_id, (level, CommandLine)))\n                              .collect::<Vec<()>>();\n                         }\n                         None => sess.err(format!(\"unknown {} flag: {}\",\n-                                                 level.as_str(), lint_name)[]),\n+                                                 level.as_str(), lint_name).index(&FullRange)),\n                     }\n                 }\n             }\n@@ -403,10 +403,10 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     if level == Forbid { level = Deny; }\n \n     match (level, span) {\n-        (Warn, Some(sp)) => sess.span_warn(sp, msg[]),\n-        (Warn, None)     => sess.warn(msg[]),\n-        (Deny, Some(sp)) => sess.span_err(sp, msg[]),\n-        (Deny, None)     => sess.err(msg[]),\n+        (Warn, Some(sp)) => sess.span_warn(sp, msg.index(&FullRange)),\n+        (Warn, None)     => sess.warn(msg.index(&FullRange)),\n+        (Deny, Some(sp)) => sess.span_err(sp, msg.index(&FullRange)),\n+        (Deny, None)     => sess.err(msg.index(&FullRange)),\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n@@ -499,7 +499,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                                 None => {\n                                     self.span_lint(builtin::UNKNOWN_LINTS, span,\n                                                format!(\"unknown `{}` attribute: `{}`\",\n-                                                       level.as_str(), lint_name)[]);\n+                                                       level.as_str(), lint_name).as_slice());\n                                     continue;\n                                 }\n                             }\n@@ -515,7 +515,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     self.tcx.sess.span_err(span,\n                                            format!(\"{}({}) overruled by outer forbid({})\",\n                                                    level.as_str(), lint_name,\n-                                                   lint_name)[]);\n+                                                   lint_name).index(&FullRange));\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));\n@@ -550,22 +550,22 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        self.with_lint_attrs(it.attrs[], |cx| {\n+        self.with_lint_attrs(it.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n             visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n-        self.with_lint_attrs(it.attrs[], |cx| {\n+        self.with_lint_attrs(it.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it);\n         })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        self.with_lint_attrs(i.attrs[], |cx| {\n+        self.with_lint_attrs(i.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_view_item, i);\n             cx.visit_ids(|v| v.visit_view_item(i));\n             visit::walk_view_item(cx, i);\n@@ -591,7 +591,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(m.attrs[], |cx| {\n+                self.with_lint_attrs(m.attrs.index(&FullRange), |cx| {\n                     run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id);\n@@ -607,7 +607,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(t.attrs[], |cx| {\n+        self.with_lint_attrs(t.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_ty_method, t);\n             visit::walk_ty_method(cx, t);\n         })\n@@ -624,14 +624,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField) {\n-        self.with_lint_attrs(s.node.attrs[], |cx| {\n+        self.with_lint_attrs(s.node.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n-        self.with_lint_attrs(v.node.attrs[], |cx| {\n+        self.with_lint_attrs(v.node.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -725,7 +725,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints.into_iter() {\n-                    self.span_lint(lint_id.lint, span, msg[])\n+                    self.span_lint(lint_id.lint, span, msg.index(&FullRange))\n                 }\n             }\n         }\n@@ -771,7 +771,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(krate.attrs[], |cx| {\n+    cx.with_lint_attrs(krate.attrs.index(&FullRange), |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n@@ -791,7 +791,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span,\n                               format!(\"unprocessed lint {} at {}: {}\",\n-                                      lint.as_str(), tcx.map.node_to_string(*id), *msg)[])\n+                                      lint.as_str(), tcx.map.node_to_string(*id), *msg).as_slice())\n         }\n     }\n "}, {"sha": "66967a735460fe8bca856b5d6d3597acb2a46ec0", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -65,7 +65,8 @@ fn dump_crates(cstore: &CStore) {\n }\n \n fn should_link(i: &ast::ViewItem) -> bool {\n-    !attr::contains_name(i.attrs[], \"no_link\")\n+    !attr::contains_name(i.attrs.index(&FullRange), \"no_link\")\n+\n }\n \n struct CrateInfo {\n@@ -89,14 +90,15 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }\n         if c == '_' || c == '-' { continue }\n-        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s)[]);\n+        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s).index(&FullRange));\n     }\n     match sess {\n         Some(sess) => sess.abort_if_errors(),\n         None => {}\n     }\n }\n \n+\n fn register_native_lib(sess: &Session,\n                        span: Option<Span>,\n                        name: String,\n@@ -187,8 +189,8 @@ impl<'a> CrateReader<'a> {\n         match self.extract_crate_info(i) {\n             Some(info) => {\n                 let (cnum, _, _) = self.resolve_crate(&None,\n-                                                      info.ident[],\n-                                                      info.name[],\n+                                                      info.ident.index(&FullRange),\n+                                                      info.name.index(&FullRange),\n                                                       None,\n                                                       i.span,\n                                                       PathKind::Crate);\n@@ -202,12 +204,12 @@ impl<'a> CrateReader<'a> {\n         match i.node {\n             ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n                 let ident = token::get_ident(ident);\n-                debug!(\"resolving extern crate stmt. ident: {} path_opt: {}\",\n+                debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n                        ident, path_opt);\n                 let name = match *path_opt {\n                     Some((ref path_str, _)) => {\n                         let name = path_str.get().to_string();\n-                        validate_crate_name(Some(self.sess), name[],\n+                        validate_crate_name(Some(self.sess), name.index(&FullRange),\n                                             Some(i.span));\n                         name\n                     }\n@@ -274,7 +276,7 @@ impl<'a> CrateReader<'a> {\n                                     } else {\n                                         self.sess.span_err(m.span,\n                                             format!(\"unknown kind: `{}`\",\n-                                                    k)[]);\n+                                                    k).index(&FullRange));\n                                         cstore::NativeUnknown\n                                     }\n                                 }\n@@ -328,7 +330,7 @@ impl<'a> CrateReader<'a> {\n             match self.sess.opts.externs.get(name) {\n                 Some(locs) => {\n                     let found = locs.iter().any(|l| {\n-                        let l = fs::realpath(&Path::new(l[])).ok();\n+                        let l = fs::realpath(&Path::new(l.index(&FullRange))).ok();\n                         l == source.dylib || l == source.rlib\n                     });\n                     if found {\n@@ -407,7 +409,7 @@ impl<'a> CrateReader<'a> {\n                     crate_name: name,\n                     hash: hash.map(|a| &*a),\n                     filesearch: self.sess.target_filesearch(kind),\n-                    triple: self.sess.opts.target_triple[],\n+                    triple: self.sess.opts.target_triple.index(&FullRange),\n                     root: root,\n                     rejected_via_hash: vec!(),\n                     rejected_via_triple: vec!(),\n@@ -433,8 +435,8 @@ impl<'a> CrateReader<'a> {\n         decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n-                                                   dep.name[],\n-                                                   dep.name[],\n+                                                   dep.name.index(&FullRange),\n+                                                   dep.name.index(&FullRange),\n                                                    Some(&dep.hash),\n                                                    span,\n                                                    PathKind::Dependency);\n@@ -445,7 +447,7 @@ impl<'a> CrateReader<'a> {\n     pub fn read_plugin_metadata<'b>(&'b mut self,\n                                     vi: &'b ast::ViewItem) -> PluginMetadata<'b> {\n         let info = self.extract_crate_info(vi).unwrap();\n-        let target_triple = self.sess.opts.target_triple[];\n+        let target_triple = self.sess.opts.target_triple.index(&FullRange);\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n         let mut target_only = false;\n@@ -454,8 +456,8 @@ impl<'a> CrateReader<'a> {\n         let mut load_ctxt = loader::Context {\n             sess: self.sess,\n             span: vi.span,\n-            ident: ident[],\n-            crate_name: name[],\n+            ident: ident.index(&FullRange),\n+            crate_name: name.index(&FullRange),\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             triple: config::host_triple(),\n@@ -480,11 +482,11 @@ impl<'a> CrateReader<'a> {\n         };\n \n         let dylib = library.dylib.clone();\n-        let register = should_link && self.existing_match(info.name[], None).is_none();\n+        let register = should_link && self.existing_match(info.name.as_slice(), None).is_none();\n         let metadata = if register {\n             // Register crate now to avoid double-reading metadata\n-            let (_, cmd, _) = self.register_crate(&None, info.ident[],\n-                                info.name[], vi.span, library);\n+            let (_, cmd, _) = self.register_crate(&None, info.ident.index(&FullRange),\n+                                info.name.index(&FullRange), vi.span, library);\n             PMDSource::Registered(cmd)\n         } else {\n             // Not registering the crate; just hold on to the metadata\n@@ -505,8 +507,8 @@ impl<'a> CrateReader<'a> {\n impl<'a> PluginMetadata<'a> {\n     /// Read exported macros\n     pub fn exported_macros(&self) -> Vec<ast::MacroDef> {\n-        let imported_from = Some(token::intern(self.info.ident[]).ident());\n-        let source_name = format!(\"<{} macros>\", self.info.ident[]);\n+        let imported_from = Some(token::intern(self.info.ident.index(&FullRange)).ident());\n+        let source_name = format!(\"<{} macros>\", self.info.ident.index(&FullRange));\n         let mut macros = vec![];\n         decoder::each_exported_macro(self.metadata.as_slice(),\n                                      &*self.sess.cstore.intr,\n@@ -548,7 +550,7 @@ impl<'a> PluginMetadata<'a> {\n                                   self.info.ident,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(self.vi_span, message[]);\n+            self.sess.span_err(self.vi_span, message.index(&FullRange));\n             self.sess.abort_if_errors();\n         }\n \n@@ -561,7 +563,7 @@ impl<'a> PluginMetadata<'a> {\n                 let message = format!(\"plugin crate `{}` only found in rlib format, \\\n                                        but must be available in dylib format\",\n                                        self.info.ident);\n-                self.sess.span_err(self.vi_span, message[]);\n+                self.sess.span_err(self.vi_span, message.index(&FullRange));\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None"}, {"sha": "72ce61b133a2bad37f32d9f3296b26c6ddc018f8", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -95,7 +95,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    let mut r = vec![ast_map::PathMod(token::intern(cdata.name[]))];\n+    let mut r = vec![ast_map::PathMod(token::intern(cdata.name.index(&FullRange)))];\n     r.push_all(path.as_slice());\n     r\n }\n@@ -246,13 +246,13 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n     let class_doc = expect(tcx.sess.diagnostic(),\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || {\n-        (format!(\"get_field_type: class ID {} not found\",\n+        (format!(\"get_field_type: class ID {:?} not found\",\n                  class_id)).to_string()\n     });\n     let the_field = expect(tcx.sess.diagnostic(),\n         decoder::maybe_find_item(def.node, class_doc),\n         || {\n-            (format!(\"get_field_type: in class {}, field ID {} not found\",\n+            (format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                     class_id,\n                     def)).to_string()\n         });"}, {"sha": "9e71c867efa09473242fd17cfcdc5a696bccbb74", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -75,7 +75,7 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(elt.data[elt.start + 4 .. elt.end]) {\n+        if eq_fn(elt.data.index(&((elt.start + 4) .. elt.end))) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {\n@@ -89,7 +89,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            bytes[0u..4u], 0u, 4u) as ast::NodeId\n+            bytes.index(&(0u..4u)), 0u, 4u) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,\n@@ -675,14 +675,14 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n     let path = item_path(item_doc).init().to_vec();\n-    match decode_inlined_item.call_mut((cdata, tcx, path, item_doc)) {\n+    match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ii) => csearch::found(ii),\n         Err(path) => {\n             match item_parent_item(item_doc) {\n                 Some(did) => {\n                     let did = translate_def_id(cdata, did);\n                     let parent_item = lookup_item(did.node, cdata.data());\n-                    match decode_inlined_item.call_mut((cdata, tcx, path, parent_item)) {\n+                    match decode_inlined_item(cdata, tcx, path, parent_item) {\n                         Ok(ii) => csearch::found_parent(did, ii),\n                         Err(_) => csearch::not_found\n                     }\n@@ -1191,7 +1191,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash)[]);\n+        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash).index(&FullRange));\n         deps.push(CrateDep {\n             cnum: crate_num,\n             name: name,"}, {"sha": "28ad36194ef9a0104d986c09beb08caaf4bc7513", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -95,7 +95,7 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id)[]);\n+    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id).index(&FullRange));\n }\n \n #[derive(Clone)]\n@@ -154,7 +154,7 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(s[]);\n+    rbml_w.wr_str(s.index(&FullRange));\n     rbml_w.end_tag();\n }\n \n@@ -264,7 +264,7 @@ fn encode_symbol(ecx: &EncodeContext,\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                format!(\"encode_symbol: id not found {}\", id)[]);\n+                format!(\"encode_symbol: id not found {}\", id).index(&FullRange));\n         }\n     }\n     rbml_w.end_tag();\n@@ -332,8 +332,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(rbml_w, variant.node.name.name);\n         encode_parent_item(rbml_w, local_def(id));\n         encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, variant.node.attrs[]);\n-        encode_repr_attrs(rbml_w, ecx, variant.node.attrs[]);\n+        encode_attributes(rbml_w, variant.node.attrs.index(&FullRange));\n+        encode_repr_attrs(rbml_w, ecx, variant.node.attrs.index(&FullRange));\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(rbml_w, stab);\n@@ -344,9 +344,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n-                                                 fields[],\n+                                                 fields.index(&FullRange),\n                                                  index);\n-                encode_struct_fields(rbml_w, fields[], def_id);\n+                encode_struct_fields(rbml_w, fields.index(&FullRange), def_id);\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n@@ -386,12 +386,12 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(def_to_string(method_def_id)[]);\n+    rbml_w.wr_str(def_to_string(method_def_id).index(&FullRange));\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_items_data_item_reexport_name);\n     rbml_w.wr_str(format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_name(method_name))[]);\n+                          token::get_name(method_name)).index(&FullRange));\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n@@ -529,7 +529,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(def_to_string(exp.def_id)[]);\n+                rbml_w.wr_str(def_to_string(exp.def_id).index(&FullRange));\n                 rbml_w.end_tag();\n                 rbml_w.start_tag(tag_items_data_item_reexport_name);\n                 rbml_w.wr_str(exp.name.as_str());\n@@ -562,13 +562,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in md.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id))[]);\n+        rbml_w.wr_str(def_to_string(local_def(item.id)).index(&FullRange));\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id))[]);\n+                        auxiliary_node_id)).index(&FullRange));\n             rbml_w.end_tag();\n             true\n         });\n@@ -580,7 +580,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(def_to_string(local_def(did))[]);\n+            rbml_w.wr_str(def_to_string(local_def(did)).index(&FullRange));\n             rbml_w.end_tag();\n         }\n     }\n@@ -615,7 +615,7 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(ch.to_string()[]);\n+    rbml_w.wr_str(ch.to_string().index(&FullRange));\n     rbml_w.end_tag();\n }\n \n@@ -627,7 +627,7 @@ fn encode_unboxed_closure_kind(rbml_w: &mut Encoder,\n         ty::FnMutUnboxedClosureKind => 'm',\n         ty::FnOnceUnboxedClosureKind => 'o',\n     };\n-    rbml_w.wr_str(ch.to_string()[]);\n+    rbml_w.wr_str(ch.to_string().index(&FullRange));\n     rbml_w.end_tag();\n }\n \n@@ -788,7 +788,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n \n         rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             def_to_string(param.def_id)[]);\n+                             def_to_string(param.def_id).index(&FullRange));\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -845,7 +845,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     parent_id: NodeId,\n                                     ast_item_opt: Option<&ast::ImplItem>) {\n \n-    debug!(\"encode_info_for_method: {} {}\", m.def_id,\n+    debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            token::get_name(m.name));\n     rbml_w.start_tag(tag_items_data_item);\n \n@@ -864,9 +864,9 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, ast_method.attrs[]);\n+            encode_attributes(rbml_w, ast_method.attrs.index(&FullRange));\n             let any_types = !pty.generics.types.is_empty();\n-            if any_types || is_default_impl || should_inline(ast_method.attrs[]) {\n+            if any_types || is_default_impl || should_inline(ast_method.attrs.index(&FullRange)) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n             }\n@@ -887,7 +887,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n                                    impl_path: PathElems,\n                                    parent_id: NodeId,\n                                    typedef_opt: Option<P<ast::Typedef>>) {\n-    debug!(\"encode_info_for_associated_type({},{})\",\n+    debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n            token::get_name(associated_type.name));\n \n@@ -912,7 +912,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     match typedef_opt {\n         None => {}\n         Some(typedef) => {\n-            encode_attributes(rbml_w, typedef.attrs[]);\n+            encode_attributes(rbml_w, typedef.attrs.index(&FullRange));\n             encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n                                                          typedef.id));\n         }\n@@ -953,7 +953,7 @@ fn encode_inlined_item(ecx: &EncodeContext,\n                        ii: InlinedItemRef) {\n     let mut eii = ecx.encode_inlined_item.borrow_mut();\n     let eii: &mut EncodeInlinedItem = &mut *eii;\n-    eii.call_mut((ecx, rbml_w, ii))\n+    eii(ecx, rbml_w, ii)\n }\n \n const FN_FAMILY: char = 'f';\n@@ -1046,7 +1046,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        encode_attributes(rbml_w, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n         rbml_w.end_tag();\n       }\n       ast::ItemConst(_, _) => {\n@@ -1072,8 +1072,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-        encode_attributes(rbml_w, item.attrs[]);\n-        if tps_len > 0u || should_inline(item.attrs[]) {\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        if tps_len > 0u || should_inline(item.attrs.index(&FullRange)) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n@@ -1089,7 +1089,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n-                            item.attrs[],\n+                            item.attrs.index(&FullRange),\n                             item.id,\n                             path,\n                             item.ident,\n@@ -1106,7 +1106,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(foreign_item.id))[]);\n+            rbml_w.wr_str(def_to_string(local_def(foreign_item.id)).index(&FullRange));\n             rbml_w.end_tag();\n         }\n         encode_visibility(rbml_w, vis);\n@@ -1134,8 +1134,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs[]);\n-        encode_repr_attrs(rbml_w, ecx, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_repr_attrs(rbml_w, ecx, item.attrs.index(&FullRange));\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n@@ -1152,7 +1152,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 (*enum_definition).variants[],\n+                                 (*enum_definition).variants.index(&FullRange),\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n@@ -1164,7 +1164,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          rbml_w,\n-                                         fields[],\n+                                         fields.index(&FullRange),\n                                          index);\n \n         /* Index the class*/\n@@ -1178,16 +1178,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, item.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, item.attrs.index(&FullRange));\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, fields[], def_id);\n+        encode_struct_fields(rbml_w, fields.index(&FullRange), def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n \n@@ -1219,7 +1219,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n         match ty.node {\n@@ -1323,7 +1323,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n@@ -1341,7 +1341,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n \n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(method_def_id.def_id())[]);\n+            rbml_w.wr_str(def_to_string(method_def_id.def_id()).index(&FullRange));\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1433,14 +1433,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             };\n             match trait_item {\n                 &ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs[]);\n+                    encode_attributes(rbml_w, m.attrs.index(&FullRange));\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 &ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs[]);\n+                    encode_attributes(rbml_w, m.attrs.index(&FullRange));\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n@@ -1449,7 +1449,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                 &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n-                                      associated_type.attrs[]);\n+                                      associated_type.attrs.index(&FullRange));\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }\n@@ -1603,7 +1603,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     let mut buckets: Vec<Vec<entry<T>>> = range(0, 256u16).map(|_| Vec::new()).collect();\n     for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;\n-        buckets[h % 256].push(elt);\n+        (&mut buckets[h % 256]).push(elt);\n     }\n \n     rbml_w.start_tag(tag_index);\n@@ -1826,10 +1826,10 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         rbml_w.start_tag(tag_macro_def);\n \n         encode_name(rbml_w, def.ident.name);\n-        encode_attributes(rbml_w, def.attrs[]);\n+        encode_attributes(rbml_w, def.attrs.index(&FullRange));\n \n         rbml_w.start_tag(tag_macro_def_body);\n-        rbml_w.wr_str(pprust::tts_to_string(def.body[])[]);\n+        rbml_w.wr_str(pprust::tts_to_string(def.body.index(&FullRange)).index(&FullRange));\n         rbml_w.end_tag();\n \n         rbml_w.end_tag();\n@@ -1869,7 +1869,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n         fn visit_struct_field(&mut self, field: &ast::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.rbml_w, field.node.attrs[]);\n+            encode_attributes(self.rbml_w, field.node.attrs.index(&FullRange));\n             self.rbml_w.end_tag();\n         }\n     }\n@@ -1941,13 +1941,13 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in krate.module.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id))[]);\n+        rbml_w.wr_str(def_to_string(local_def(item.id)).index(&FullRange));\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id))[]);\n+                        auxiliary_node_id)).index(&FullRange));\n             rbml_w.end_tag();\n             true\n         });\n@@ -2116,17 +2116,17 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name[]);\n+    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name.index(&FullRange));\n     encode_crate_triple(&mut rbml_w,\n                         tcx.sess\n                            .opts\n                            .target_triple\n-                           []);\n+                           .index(&FullRange));\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.tell().unwrap();\n-    encode_attributes(&mut rbml_w, krate.attrs[]);\n+    encode_attributes(&mut rbml_w, krate.attrs.index(&FullRange));\n     stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     i = rbml_w.writer.tell().unwrap();"}, {"sha": "0fa9472287caa05440fc6dff03f1ba5ee73bbe69", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -315,14 +315,14 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\"{} which `{}` depends on\",\n                                     message, r.ident)\n         };\n-        self.sess.span_err(self.span, message[]);\n+        self.sess.span_err(self.span, message.index(&FullRange));\n \n         if self.rejected_via_triple.len() > 0 {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display())[]);\n+                            self.ident, i+1, got, path.display()).index(&FullRange));\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -332,15 +332,15 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}` path {}{}: {}\",\n-                            self.ident, \"#\", i+1, path.display())[]);\n+                            self.ident, \"#\", i+1, path.display()).index(&FullRange));\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n                             format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display())[]);\n+                                    r.ident, i+1, path.display()).index(&FullRange));\n                     }\n                 }\n             }\n@@ -386,7 +386,7 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(rlib_prefix[]) &&\n+            let (hash, rlib) = if file.starts_with(rlib_prefix.index(&FullRange)) &&\n                     file.ends_with(\".rlib\") {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n@@ -400,7 +400,7 @@ impl<'a> Context<'a> {\n             info!(\"lib candidate: {}\", path.display());\n \n             let hash_str = hash.to_string();\n-            let slot = candidates.entry(&hash_str).get().unwrap_or_else(\n+            let slot = candidates.entry(hash_str).get().unwrap_or_else(\n                 |vacant_entry| vacant_entry.insert((HashSet::new(), HashSet::new())));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             if rlib {\n@@ -446,26 +446,26 @@ impl<'a> Context<'a> {\n             _ => {\n                 self.sess.span_err(self.span,\n                     format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name)[]);\n+                            self.crate_name).index(&FullRange));\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\",\n-                                                   p.display())[]);\n+                                                   p.display()).index(&FullRange));\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\",\n-                                                   p.display())[]);\n+                                                   p.display()).index(&FullRange));\n                         }\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n-                    note_crate_name(self.sess.diagnostic(), name[]);\n+                    note_crate_name(self.sess.diagnostic(), name.index(&FullRange));\n                 }\n                 None\n             }\n@@ -519,19 +519,19 @@ impl<'a> Context<'a> {\n                                    format!(\"multiple {} candidates for `{}` \\\n                                             found\",\n                                            flavor,\n-                                           self.crate_name)[]);\n+                                           self.crate_name).index(&FullRange));\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap()\n-                                               .display())[]);\n+                                               .display()).index(&FullRange));\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #{}: {}\", error,\n-                                            lib.display())[]);\n+                                            lib.display()).index(&FullRange));\n                 continue\n             }\n             *slot = Some(metadata);\n@@ -606,30 +606,31 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashSet::new();\n         let mut dylibs = HashSet::new();\n         {\n-            let mut locs = locs.iter().map(|l| Path::new(l[])).filter(|loc| {\n+            let mut locs = locs.iter().map(|l| Path::new(l.index(&FullRange))).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display())[]);\n+                                     self.crate_name, loc.display()).index(&FullRange));\n                     return false;\n                 }\n                 let file = match loc.filename_str() {\n                     Some(file) => file,\n                     None => {\n                         sess.err(format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display())[]);\n+                                         self.crate_name, loc.display()).index(&FullRange));\n                         return false;\n                     }\n                 };\n                 if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n                     return true\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(prefix[]) && file.ends_with(suffix[]) {\n+                    if file.starts_with(prefix.index(&FullRange)) &&\n+                       file.ends_with(suffix.index(&FullRange)) {\n                         return true\n                     }\n                 }\n                 sess.err(format!(\"extern location for {} is of an unknown type: {}\",\n-                                 self.crate_name, loc.display())[]);\n+                                 self.crate_name, loc.display()).index(&FullRange));\n                 false\n             });\n \n@@ -662,7 +663,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(format!(\"crate name: {}\", name)[]);\n+    diag.handler().note(format!(\"crate name: {}\", name).index(&FullRange));\n }\n \n impl ArchiveMetadata {"}, {"sha": "a4304bf1e2d62a7d7918c9dbc003d57eb746a76b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -98,7 +98,7 @@ fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n-    return op(st.data[start_pos..end_pos]);\n+    return op(st.data.index(&(start_pos..end_pos)));\n }\n \n pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n@@ -251,7 +251,7 @@ fn parse_trait_store_<F>(st: &mut PState, conv: &mut F) -> ty::TraitStore where\n         '&' => ty::RegionTraitStore(parse_region_(st, conv), parse_mutability(st)),\n         c => {\n             st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\",\n-                                    c)[])\n+                                    c).index(&FullRange))\n         }\n     }\n }\n@@ -318,7 +318,7 @@ fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion wher\n         }\n         '[' => {\n             let def = parse_def_(st, RegionParameter, conv);\n-            let ident = token::str_to_ident(parse_str(st, ']')[]);\n+            let ident = token::str_to_ident(parse_str(st, ']').index(&FullRange));\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n@@ -357,7 +357,7 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n         assert_eq!(next(st), '|');\n         let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(parse_str(st, ']')[]);\n+        let nm = token::str_to_ident(parse_str(st, ']').index(&FullRange));\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n       }\n       'f' => {\n@@ -443,8 +443,8 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n     let tcx = st.tcx;\n     match next(st) {\n       'b' => return tcx.types.bool,\n-      'i' => return tcx.types.int,\n-      'u' => return tcx.types.uint,\n+      'i' => { /* eat the s of is */ next(st); return tcx.types.int },\n+      'u' => { /* eat the s of us */ next(st); return tcx.types.uint },\n       'M' => {\n         match next(st) {\n           'b' => return tcx.types.u8,\n@@ -481,7 +481,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        let name = token::intern(parse_str(st, ']')[]);\n+        let name = token::intern(parse_str(st, ']').index(&FullRange));\n         return ty::mk_param(tcx, space, index, name);\n       }\n       '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),\n@@ -637,7 +637,7 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n         let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(abi_str[]).expect(abi_str)\n+        abi::lookup(abi_str.index(&FullRange)).expect(abi_str)\n     })\n }\n \n@@ -733,17 +733,17 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n         panic!();\n     }\n \n-    let crate_part = buf[0u..colon_idx];\n-    let def_part = buf[colon_idx + 1u..len];\n+    let crate_part = buf.index(&(0u..colon_idx));\n+    let def_part = buf.index(&((colon_idx + 1u)..len));\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(cn) => cn as ast::CrateNum,\n-       None => panic!(\"internal error: parse_def_id: crate number expected, found {}\",\n+       None => panic!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n                      crate_part)\n     };\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(dn) => dn as ast::NodeId,\n-       None => panic!(\"internal error: parse_def_id: id expected, found {}\",\n+       None => panic!(\"internal error: parse_def_id: id expected, found {:?}\",\n                      def_part)\n     };\n     ast::DefId { krate: crate_num, node: def_num }"}, {"sha": "c019d129218b659ea878992351cb223157ca4742", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -61,7 +61,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         ty::ty_char => mywrite!(w, \"c\"),\n         ty::ty_int(t) => {\n             match t {\n-                ast::TyI => mywrite!(w, \"i\"),\n+                ast::TyIs => mywrite!(w, \"is\"),\n                 ast::TyI8 => mywrite!(w, \"MB\"),\n                 ast::TyI16 => mywrite!(w, \"MW\"),\n                 ast::TyI32 => mywrite!(w, \"ML\"),\n@@ -70,7 +70,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         }\n         ty::ty_uint(t) => {\n             match t {\n-                ast::TyU => mywrite!(w, \"u\"),\n+                ast::TyUs => mywrite!(w, \"us\"),\n                 ast::TyU8 => mywrite!(w, \"Mb\"),\n                 ast::TyU16 => mywrite!(w, \"Mw\"),\n                 ast::TyU32 => mywrite!(w, \"Ml\"),"}, {"sha": "955f522b8041b36dfe2b2694ab530cab157c7618", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -48,7 +48,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       format!(\"unbound path {}\",\n-                                              path.repr(tcx))[])\n+                                              path.repr(tcx)).index(&FullRange))\n                 }\n                 Some(&d) => d\n             };"}, {"sha": "32ce131c57a3cb1eab725ae13c5df991e405505c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -82,7 +82,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n         e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id,\n         e::IIImplItemRef(_, &ast::TypeImplItem(ref ti)) => ti.id,\n     };\n-    debug!(\"> Encoding inlined item: {} ({})\",\n+    debug!(\"> Encoding inlined item: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n            rbml_w.writer.tell());\n \n@@ -96,7 +96,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     encode_side_tables_for_ii(ecx, rbml_w, &ii);\n     rbml_w.end_tag();\n \n-    debug!(\"< Encoded inlined fn: {} ({})\",\n+    debug!(\"< Encoded inlined fn: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n            rbml_w.writer.tell());\n }\n@@ -127,12 +127,12 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n       None => Err(path),\n       Some(ast_doc) => {\n         let mut path_as_str = None;\n-        debug!(\"> Decoding inlined fn: {}::?\",\n+        debug!(\"> Decoding inlined fn: {:?}::?\",\n         {\n             // Do an Option dance to use the path after it is moved below.\n             let s = ast_map::path_to_string(ast_map::Values(path.iter()));\n             path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| x[])\n+            path_as_str.as_ref().map(|x| x.index(&FullRange))\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n@@ -263,14 +263,6 @@ trait def_id_encoder_helpers {\n     fn emit_def_id(&mut self, did: ast::DefId);\n }\n \n-#[cfg(stage0)]\n-impl<S:serialize::Encoder<E>, E> def_id_encoder_helpers for S {\n-    fn emit_def_id(&mut self, did: ast::DefId) {\n-        did.encode(self).ok().unwrap()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n     fn emit_def_id(&mut self, did: ast::DefId) {\n         did.encode(self).ok().unwrap()\n@@ -283,21 +275,6 @@ trait def_id_decoder_helpers {\n                          cdata: &cstore::crate_metadata) -> ast::DefId;\n }\n \n-#[cfg(stage0)]\n-impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n-    fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId {\n-        let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n-        did.tr(dcx)\n-    }\n-\n-    fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::crate_metadata) -> ast::DefId {\n-        let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n-        decoder::translate_def_id(cdata, did)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n     fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n@@ -1880,7 +1857,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n             TypeParameter | UnboxedClosureSource => dcx.tr_intern_def_id(did)\n         };\n-        debug!(\"convert_def_id(source={}, did={})={}\", source, did, r);\n+        debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n         return r;\n     }\n }\n@@ -1900,7 +1877,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n             None => {\n                 dcx.tcx.sess.bug(\n                     format!(\"unknown tag found in side tables: {:x}\",\n-                            tag)[]);\n+                            tag).index(&FullRange));\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1985,7 +1962,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     _ => {\n                         dcx.tcx.sess.bug(\n                             format!(\"unknown tag found in side tables: {:x}\",\n-                                    tag)[]);\n+                                    tag).index(&FullRange));\n                     }\n                 }\n             }"}, {"sha": "f7fc90bcef6510c914a5a460f1ce62ad9dd2d5b3", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(arm.pats[],\n+                    let pats_exit = self.pats_any(arm.pats.index(&FullRange),\n                                                   cond_exit);            // 3\n                     let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n@@ -480,12 +480,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let inputs = inline_asm.inputs.iter();\n                 let outputs = inline_asm.outputs.iter();\n                 let post_inputs = self.exprs(inputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} input:{}\", expr.id, a);\n+                    debug!(\"cfg::construct InlineAsm id:{} input:{:?}\", expr.id, a);\n                     let &(_, ref expr) = a;\n                     &**expr\n                 }), pred);\n                 let post_outputs = self.exprs(outputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} output:{}\", expr.id, a);\n+                    debug!(\"cfg::construct InlineAsm id:{} output:{:?}\", expr.id, a);\n                     let &(_, ref expr, _) = a;\n                     &**expr\n                 }), post_inputs);\n@@ -514,7 +514,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if return_ty == ty::FnDiverging {\n+        if return_ty.diverges() {\n             self.add_node(ast::DUMMY_NODE_ID, &[])\n         } else {\n             ret\n@@ -616,14 +616,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             format!(\"no loop scope for id {}\",\n-                                    loop_id)[]);\n+                                    loop_id).index(&FullRange));\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"bad entry `{}` in def_map for label\",\n-                                    r)[]);\n+                            format!(\"bad entry `{:?}` in def_map for label\",\n+                                    r).index(&FullRange));\n                     }\n                 }\n             }"}, {"sha": "8b9a0d89b380c90547d0f304d07cf854e726d562", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -52,7 +52,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name[]).unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.index(&FullRange)).unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n         dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n@@ -85,7 +85,9 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label.push_str(format!(\"exiting scope_{} {}\", i, s[])[]);\n+            label.push_str(format!(\"exiting scope_{} {}\",\n+                                   i,\n+                                   s.index(&FullRange)).index(&FullRange));\n         }\n         dot::LabelText::EscStr(label.into_cow())\n     }"}, {"sha": "621d7274b3f7c01a41c3c386ab8c1c3cf4623c5d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -118,7 +118,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n                 DefStruct(_) | DefVariant(_, _, _) => {}\n \n                 def => {\n-                    debug!(\"(checking const) found bad def: {}\", def);\n+                    debug!(\"(checking const) found bad def: {:?}\", def);\n                     span_err!(v.tcx.sess, e.span, E0014,\n                               \"paths in constants may only refer to constants \\\n                                or functions\");"}, {"sha": "5024e5c4f77de0ebdc745e4751d24b569301968a", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -74,11 +74,11 @@ impl<'a> CheckLoopVisitor<'a> {\n             Loop => {}\n             Closure => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` inside of a closure\", name)[]);\n+                                   format!(\"`{}` inside of a closure\", name).index(&FullRange));\n             }\n             Normal => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` outside of loop\", name)[]);\n+                                   format!(\"`{}` outside of loop\", name).index(&FullRange));\n             }\n         }\n     }"}, {"sha": "f1edfb37273bb37f73ed1229c8d3768ec45fc31d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -47,7 +47,7 @@ struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n \n /// Pretty-printer for matrices of patterns, example:\n /// ++++++++++++++++++++++++++\n-/// + _     + []             +\n+/// + _     + .index(&FullRange)             +\n /// ++++++++++++++++++++++++++\n /// + true  + [First]        +\n /// ++++++++++++++++++++++++++\n@@ -161,7 +161,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n-                                                arm.pats[]);\n+                                                arm.pats.index(&FullRange));\n \n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n@@ -198,7 +198,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, inlined_arms[], source);\n+            check_arms(cx, inlined_arms.index(&FullRange), source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -230,7 +230,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                     pat.span,\n                     format!(\"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat))[]);\n+                            pat_to_string(uncovered_pat)).index(&FullRange));\n             });\n \n             // Check legality of move bindings.\n@@ -303,7 +303,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n         for pat in pats.iter() {\n             let v = vec![&**pat];\n \n-            match is_useful(cx, &seen, v[], LeaveOutWitness) {\n+            match is_useful(cx, &seen, v.index(&FullRange), LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n                         ast::MatchSource::IfLetDesugar { .. } => {\n@@ -355,7 +355,7 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let witness = match pats[] {\n+            let witness = match pats.index(&FullRange) {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n@@ -574,7 +574,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n              witness: WitnessPreference)\n              -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n-    debug!(\"{:}\", matrix);\n+    debug!(\"{:?}\", matrix);\n     if rows.len() == 0u {\n         return match witness {\n             ConstructWitness => UsefulWithWitness(vec!()),\n@@ -609,7 +609,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n-                                let pat_slice = pats[];\n+                                let pat_slice = pats.index(&FullRange);\n                                 let subpats: Vec<_> = range(0, arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 }).collect();\n@@ -656,10 +656,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r[], &ctor, 0u, arity)\n+        specialize(cx, r.index(&FullRange), &ctor, 0u, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0u, arity) {\n-        Some(v) => is_useful(cx, &matrix, v[], witness),\n+        Some(v) => is_useful(cx, &matrix, v.index(&FullRange), witness),\n         None => NotUseful\n     }\n }\n@@ -729,7 +729,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n /// This computes the arity of a constructor. The arity of a constructor\n /// is how many subpattern patterns of that constructor should be expanded to.\n ///\n-/// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n+/// For instance, a tuple pattern (_, 42u, Some(.index(&FullRange))) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n     match ty.sty {\n@@ -926,8 +926,8 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n     };\n     head.map(|mut head| {\n-        head.push_all(r[..col]);\n-        head.push_all(r[col + 1..]);\n+        head.push_all(r.index(&(0..col)));\n+        head.push_all(r.index(&((col + 1)..)));\n         head\n     })\n }\n@@ -1042,9 +1042,9 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                         cx.tcx.sess.span_bug(\n                             p.span,\n                             format!(\"binding pattern {} is not an \\\n-                                     identifier: {}\",\n+                                     identifier: {:?}\",\n                                     p.id,\n-                                    p.node)[]);\n+                                    p.node).index(&FullRange));\n                     }\n                 }\n             }"}, {"sha": "5ff1f36f0e06abae12e525a013003809e6539d3f", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                span: Span,\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n-        debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n+        debug!(\"consume; cmt: {:?}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n         if !ty::type_is_sized(self.param_env, span, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\","}, {"sha": "994a2b0dc8abc8a0b20c347c1db0cedf5ca10fd5", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         };\n \n         self.tcx.sess.span_err(e.span, format!(\"mutable statics are not allowed \\\n-                                                to have {}\", suffix)[]);\n+                                                to have {}\", suffix).index(&FullRange));\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n@@ -170,7 +170,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n             ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n                 self.tcx.sess.span_err(e.span,\n                                        format!(\"{} are not allowed to have \\\n-                                                destructors\", self.msg())[])\n+                                                destructors\", self.msg()).index(&FullRange))\n             }\n             _ => {}\n         }\n@@ -234,7 +234,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n                         let msg = \"constants cannot refer to other statics, \\\n                                    insert an intermediate constant \\\n                                    instead\";\n-                        self.tcx.sess.span_err(e.span, msg[]);\n+                        self.tcx.sess.span_err(e.span, msg.index(&FullRange));\n                     }\n                     _ => {}\n                 }"}, {"sha": "75851f0a8533327f145a660515996b30935fc132", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                           _ => {\n                             self.sess.span_err(e.span,\n                               format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node))[]);\n+                                      self.ast_map.node_to_string(def_id.node)).index(&FullRange));\n                             return;\n                           },\n                         }"}, {"sha": "e726993bd48402cfa27c835dec2e81a408091cac", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -48,7 +48,7 @@ use std::rc::Rc;\n //     target uses\". This _includes_ integer-constants, plus the following\n //     constructors:\n //\n-//        fixed-size vectors and strings: [] and \"\"/_\n+//        fixed-size vectors and strings: .index(&FullRange) and \"\"/_\n //        vector and string slices: &[] and &\"\"\n //        tuples: (,)\n //        enums: foo(...)\n@@ -117,7 +117,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n-                    variant_expr(variants[], variant_def.node)\n+                    variant_expr(variants.index(&FullRange), variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -138,7 +138,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n-                    variant_expr(variants[], variant_def.node).map(|e| e.id)\n+                    variant_expr(variants.index(&FullRange), variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n@@ -311,7 +311,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n \n         ast::ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow()[callee.id].clone();\n-            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(&expr.id) {\n+            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(def);\n             }\n             let path = match def {\n@@ -364,7 +364,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, s[])\n+        Err(s) => tcx.sess.span_fatal(e.span, s.index(&FullRange))\n     }\n }\n \n@@ -528,12 +528,12 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n \n         eval_const_expr_partial(tcx, &**base)\n             .and_then(|val| define_casts!(val, {\n-                ty::ty_int(ast::TyI) => (int, const_int, i64),\n+                ty::ty_int(ast::TyIs) => (int, const_int, i64),\n                 ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n                 ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n                 ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n                 ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n-                ty::ty_uint(ast::TyU) => (uint, const_uint, u64),\n+                ty::ty_uint(ast::TyUs) => (uint, const_uint, u64),\n                 ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n                 ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n                 ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),"}, {"sha": "bdd98a94fc32fba293defd79466b811d0c7fc395", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n-        debug!(\"DataFlowContext::new(analysis_name: {}, id_range={}, \\\n+        debug!(\"DataFlowContext::new(analysis_name: {}, id_range={:?}, \\\n                                      bits_per_id={}, words_per_id={}) \\\n                                      num_nodes: {}\",\n                analysis_name, id_range, bits_per_id, words_per_id,\n@@ -251,7 +251,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n     fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `cfgidx` to `bits`\n-        debug!(\"{} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n+        debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [before]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n         assert!(self.bits_per_id > 0);\n \n@@ -261,7 +261,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, &Subtract);\n \n-        debug!(\"{} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n+        debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [after]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n     }\n \n@@ -312,10 +312,10 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let mut t = on_entry.to_vec();\n                 self.apply_gen_kill(cfgidx, t.as_mut_slice());\n                 temp_bits = t;\n-                temp_bits[]\n+                temp_bits.index(&FullRange)\n             }\n         };\n-        debug!(\"{} each_bit_for_node({}, cfgidx={}) bits={}\",\n+        debug!(\"{} each_bit_for_node({:?}, cfgidx={:?}) bits={}\",\n                self.analysis_name, e, cfgidx, bits_to_string(slice));\n         self.each_bit(slice, f)\n     }\n@@ -410,7 +410,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                         }\n                     }\n                     None => {\n-                        debug!(\"{} add_kills_from_flow_exits flow_exit={} \\\n+                        debug!(\"{} add_kills_from_flow_exits flow_exit={:?} \\\n                                 no cfg_idx for exiting_scope={}\",\n                                self.analysis_name, flow_exit, node_id);\n                     }\n@@ -419,10 +419,10 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n             if changed {\n                 let bits = self.kills.slice_mut(start, end);\n-                debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n+                debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.clone_from_slice(orig_kills[]);\n-                debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n+                bits.clone_from_slice(orig_kills.index(&FullRange));\n+                debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n             true\n@@ -481,7 +481,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         assert!(self.dfcx.bits_per_id > 0);\n \n         cfg.graph.each_node(|node_index, node| {\n-            debug!(\"DataFlowContext::walk_cfg idx={} id={} begin in_out={}\",\n+            debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n                    node_index, node.data.id, bits_to_string(in_out));\n \n             let (start, end) = self.dfcx.compute_id_range(node_index);\n@@ -521,7 +521,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n                                          edge: &cfg::CFGEdge) {\n         let source = edge.source();\n         let cfgidx = edge.target();\n-        debug!(\"{} propagate_bits_into_entry_set_for(pred_bits={}, {} to {})\",\n+        debug!(\"{} propagate_bits_into_entry_set_for(pred_bits={}, {:?} to {:?})\",\n                self.dfcx.analysis_name, bits_to_string(pred_bits), source, cfgidx);\n         assert!(self.dfcx.bits_per_id > 0);\n \n@@ -532,7 +532,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n-            debug!(\"{} changed entry set for {} to {}\",\n+            debug!(\"{} changed entry set for {:?} to {}\",\n                    self.dfcx.analysis_name, cfgidx,\n                    bits_to_string(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n@@ -554,7 +554,7 @@ fn bits_to_string(words: &[uint]) -> String {\n         let mut v = word;\n         for _ in range(0u, uint::BYTES) {\n             result.push(sep);\n-            result.push_str(format!(\"{:02x}\", v & 0xFF)[]);\n+            result.push_str(format!(\"{:02x}\", v & 0xFF).index(&FullRange));\n             v >>= 8;\n             sep = '-';\n         }"}, {"sha": "0bc899a8a62937ec3ff7c956a0c23dc5e4c77b2a", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -118,7 +118,7 @@ fn calculate_type(sess: &session::Session,\n                 let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n                 if src.rlib.is_some() { return }\n                 sess.err(format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name)[]);\n+                                 data.name).index(&FullRange));\n             });\n             return Vec::new();\n         }\n@@ -149,7 +149,7 @@ fn calculate_type(sess: &session::Session,\n             add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n             let deps = csearch::get_dylib_dependency_formats(&sess.cstore, cnum);\n             for &(depnum, style) in deps.iter() {\n-                debug!(\"adding {}: {}\", style,\n+                debug!(\"adding {:?}: {}\", style,\n                        sess.cstore.get_crate_data(depnum).name.clone());\n                 add_library(sess, depnum, style, &mut formats);\n             }\n@@ -197,7 +197,7 @@ fn calculate_type(sess: &session::Session,\n                                  match kind {\n                                      cstore::RequireStatic => \"rlib\",\n                                      cstore::RequireDynamic => \"dylib\",\n-                                 })[]);\n+                                 }).index(&FullRange));\n             }\n         }\n     }\n@@ -222,7 +222,7 @@ fn add_library(sess: &session::Session,\n                 let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(format!(\"cannot satisfy dependencies so `{}` only \\\n                                   shows up once\",\n-                                 data.name)[]);\n+                                 data.name).index(&FullRange));\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }"}, {"sha": "45838436e6097350d1b12342228e85b4b50a540f", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -29,7 +29,7 @@ use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::ty::{MethodStatic, MethodStaticUnboxedClosure};\n use util::ppaux::Repr;\n \n-use std::kinds;\n+use std::marker;\n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n use syntax::codemap::Span;\n@@ -135,7 +135,7 @@ enum TrackMatchMode<T> {\n     Conflicting,\n }\n \n-impl<T> kinds::Copy for TrackMatchMode<T> {}\n+impl<T> marker::Copy for TrackMatchMode<T> {}\n \n impl<T> TrackMatchMode<T> {\n     // Builds up the whole match mode for a pattern from its constituent\n@@ -441,28 +441,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                match rhs.node {\n-                    ast::ExprRange(ref start, ref end) => {\n-                        // Hacked slicing syntax (KILLME).\n-                        let args = match (start, end) {\n-                            (&Some(ref e1), &Some(ref e2)) => vec![&**e1, &**e2],\n-                            (&Some(ref e), &None) => vec![&**e],\n-                            (&None, &Some(ref e)) => vec![&**e],\n-                            (&None, &None) => Vec::new()\n-                        };\n-                        let overloaded =\n-                            self.walk_overloaded_operator(expr, &**lhs, args, PassArgs::ByRef);\n-                        assert!(overloaded);\n-                    }\n-                    _ => {\n-                        if !self.walk_overloaded_operator(expr,\n-                                                          &**lhs,\n-                                                          vec![&**rhs],\n-                                                          PassArgs::ByRef) {\n-                            self.select_from_expr(&**lhs);\n-                            self.consume_expr(&**rhs);\n-                        }\n-                    }\n+                if !self.walk_overloaded_operator(expr,\n+                                                  &**lhs,\n+                                                  vec![&**rhs],\n+                                                  PassArgs::ByRef) {\n+                    self.select_from_expr(&**lhs);\n+                    self.consume_expr(&**rhs);\n                 }\n             }\n \n@@ -864,12 +848,17 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 None => {}\n                 Some(method_ty) => {\n                     let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n-                    let self_ty = ty::ty_fn_args(method_ty)[0];\n+\n+                    // the method call infrastructure should have\n+                    // replaced all late-bound regions with variables:\n+                    let self_ty = ty::ty_fn_sig(method_ty).input(0);\n+                    let self_ty = ty::assert_no_late_bound_regions(self.tcx(), &self_ty);\n+\n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx()))[])\n+                                    method_ty.repr(self.tcx())).index(&FullRange))\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -1035,7 +1024,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n-                debug!(\"binding cmt_pat={} pat={} match_mode={}\",\n+                debug!(\"binding cmt_pat={} pat={} match_mode={:?}\",\n                        cmt_pat.repr(tcx),\n                        pat.repr(tcx),\n                        match_mode);\n@@ -1171,10 +1160,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // pattern.\n \n                             if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected type: {} and type {}\",\n+                                let msg = format!(\"Pattern has unexpected type: {:?} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n-                                tcx.sess.span_bug(pat.span, msg[])\n+                                tcx.sess.span_bug(pat.span, msg.as_slice())\n                             }\n                         }\n \n@@ -1188,10 +1177,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // reported.\n \n                             if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected def: {} and type {}\",\n+                                let msg = format!(\"Pattern has unexpected def: {:?} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n-                                tcx.sess.span_bug(pat.span, msg[])\n+                                tcx.sess.span_bug(pat.span, msg.index(&FullRange))\n                             }\n                         }\n                     }"}, {"sha": "30e0ce33018d0f7c4c3e45de584019bdd2f1a4ce", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -55,7 +55,7 @@ pub struct Edge<E> {\n \n impl<E: Show> Show for Edge<E> {\n     fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n-        write!(f, \"Edge {{ next_edge: [{}, {}], source: {}, target: {}, data: {} }}\",\n+        write!(f, \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n                self.next_edge[0], self.next_edge[1], self.source,\n                self.target, self.data)\n     }\n@@ -419,7 +419,7 @@ mod test {\n         graph.each_incoming_edge(start_index, |edge_index, edge| {\n             assert!(graph.edge_data(edge_index) == &edge.data);\n             assert!(counter < expected_incoming.len());\n-            debug!(\"counter={} expected={} edge_index={} edge={}\",\n+            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_incoming[counter], edge_index, edge);\n             match expected_incoming[counter] {\n                 (ref e, ref n) => {\n@@ -437,7 +437,7 @@ mod test {\n         graph.each_outgoing_edge(start_index, |edge_index, edge| {\n             assert!(graph.edge_data(edge_index) == &edge.data);\n             assert!(counter < expected_outgoing.len());\n-            debug!(\"counter={} expected={} edge_index={} edge={}\",\n+            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_outgoing[counter], edge_index, edge);\n             match expected_outgoing[counter] {\n                 (ref e, ref n) => {"}, {"sha": "9f87e73d4af9df47ace6d33f6e2d608da2e73875", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -265,7 +265,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({})))\", kind);\n+                                    AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n@@ -288,7 +288,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({})))\", kind);\n+                                    AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n@@ -306,7 +306,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let ty = ty::mk_uniq(self.tcx(), ty);\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoUnsizeUniq({}))\", kind);\n+                                    AutoUnsizeUniq({:?}))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsizeUniq(kind))\n@@ -328,7 +328,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                  a: Ty<'tcx>,\n                  ty_b: Ty<'tcx>)\n                  -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n-        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.tcx()));\n+        debug!(\"unsize_ty(a={:?}, ty_b={})\", a, ty_b.repr(self.tcx()));\n \n         let tcx = self.tcx();\n \n@@ -406,7 +406,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.tcx();\n \n-        debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={})\",\n+        debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={:?})\",\n                a.repr(tcx),\n                b.repr(tcx), b_mutbl);\n \n@@ -426,7 +426,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.tcx();\n \n-        debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={})\",\n+        debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={:?})\",\n                a.repr(tcx),\n                b.repr(tcx), b_mutbl);\n \n@@ -449,7 +449,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         match a.sty {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n                 ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n-                    debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n+                    debug!(\"mutbl={:?} b_mutbl={:?}\", mutbl, b_mutbl);\n                     let tr = ty::mk_trait(tcx, principal.clone(), bounds.clone());\n                     try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AdjustDerefRef(AutoDerefRef {"}, {"sha": "22975f54a9fb4e73cee177ab340c947adb234393", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -142,7 +142,7 @@ pub trait Combine<'tcx> : Sized {\n                             for _ in a_regions.iter() {\n                                 invariance.push(ty::Invariant);\n                             }\n-                            invariance[]\n+                            invariance.index(&FullRange)\n                         }\n                     };\n \n@@ -361,7 +361,7 @@ pub trait Combine<'tcx> : Sized {\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n                     -> cres<'tcx, ty::TraitStore> {\n-        debug!(\"{}.trait_stores(a={}, b={})\", self.tag(), a, b);\n+        debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r, a_m),\n@@ -471,7 +471,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n     let tcx = this.infcx().tcx;\n     let a_sty = &a.sty;\n     let b_sty = &b.sty;\n-    debug!(\"super_tys: a_sty={} b_sty={}\", a_sty, b_sty);\n+    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n     return match (a_sty, b_sty) {\n       // The \"subtype\" ought to be handling cases involving var:\n       (&ty::ty_infer(TyVar(_)), _) |\n@@ -480,7 +480,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             format!(\"{}: bot and var types should have been handled ({},{})\",\n                     this.tag(),\n                     a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx))[]);\n+                    b.repr(this.infcx().tcx)).index(&FullRange));\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {\n@@ -550,7 +550,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n \n       (&ty::ty_trait(ref a_),\n        &ty::ty_trait(ref b_)) => {\n-          debug!(\"Trying to match traits {} and {}\", a, b);\n+          debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n           let principal = try!(this.binders(&a_.principal, &b_.principal));\n           let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n           Ok(ty::mk_trait(tcx, principal, bounds))\n@@ -724,7 +724,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                 Some(e) => e,\n             };\n \n-            debug!(\"instantiate(a_ty={} dir={} b_vid={})\",\n+            debug!(\"instantiate(a_ty={} dir={:?} b_vid={})\",\n                    a_ty.repr(tcx),\n                    dir,\n                    b_vid.repr(tcx));\n@@ -745,7 +745,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                             self.generalize(a_ty, b_vid, true)\n                         }\n                     });\n-                    debug!(\"instantiate(a_ty={}, dir={}, \\\n+                    debug!(\"instantiate(a_ty={}, dir={:?}, \\\n                                         b_vid={}, generalized_ty={})\",\n                            a_ty.repr(tcx), dir, b_vid.repr(tcx),\n                            generalized_ty.repr(tcx));\n@@ -856,7 +856,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     format!(\"Encountered early bound region when generalizing: {}\",\n-                            r.repr(self.tcx()))[]);\n+                            r.repr(self.tcx())).index(&FullRange));\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "64b3c14ff699d9c53f1669d77be5bc391e9a528a", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -200,9 +200,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ref trace_origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(var_origins[],\n-                                                     trace_origins[],\n-                                                     same_regions[]);\n+                        self.report_processed_errors(var_origins.index(&FullRange),\n+                                                     trace_origins.index(&FullRange),\n+                                                     same_regions.index(&FullRange));\n                     }\n                 }\n             }\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n             let pe = ProcessedErrors(var_origins, trace_origins, same_regions);\n-            debug!(\"errors processed: {}\", pe);\n+            debug!(\"errors processed: {:?}\", pe);\n             processed_errors.push(pe);\n         }\n         return processed_errors;\n@@ -297,7 +297,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                      sub: Region,\n                                      sup: Region)\n                                      -> Option<FreeRegionsFromSameFn> {\n-            debug!(\"free_regions_from_same_fn(sub={}, sup={})\", sub, sup);\n+            debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n                 (ReFree(fr1), ReFree(fr2)) => {\n                     if fr1.scope != fr2.scope {\n@@ -376,7 +376,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr))[]);\n+                 ty::type_err_to_str(self.tcx, terr)).index(&FullRange));\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -445,25 +445,25 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                    format!(\"{} may not live long enough\", labeled_user_string).index(&FullRange));\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n                         bound_kind.user_string(self.tcx),\n-                        sub.user_string(self.tcx))[]);\n+                        sub.user_string(self.tcx)).index(&FullRange));\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                    format!(\"{} may not live long enough\", labeled_user_string).index(&FullRange));\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx)).index(&FullRange));\n             }\n \n             _ => {\n@@ -472,15 +472,15 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     format!(\n                         \"{} may not live long enough\",\n-                        labeled_user_string)[]);\n+                        labeled_user_string).index(&FullRange));\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx)).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"{} must be valid for \", labeled_user_string)[],\n+                    format!(\"{} must be valid for \", labeled_user_string).index(&FullRange),\n                     sub,\n                     \"...\");\n             }\n@@ -522,7 +522,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string())[]);\n+                                .to_string()).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -534,7 +534,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string())[],\n+                                .to_string()).index(&FullRange),\n                     sup,\n                     \"\");\n             }\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n                                                    id).get()\n-                                                      .to_string())[]);\n+                                                      .to_string()).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -622,7 +622,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)).index(&FullRange));\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -648,7 +648,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)).index(&FullRange));\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -714,7 +714,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"type is only valid for \",\n@@ -736,7 +736,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -861,7 +861,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let (fn_decl, generics, unsafety, ident, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(taken[]);\n+        let life_giver = LifeGiver::with_taken(taken.index(&FullRange));\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n             expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n                                                    &anon_nums, &region_names);\n-            inputs = self.rebuild_args_ty(inputs[], lifetime,\n+            inputs = self.rebuild_args_ty(inputs.index(&FullRange), lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n@@ -972,7 +972,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(names[0][]).name;\n+            let name = token::str_to_ident(names[0].index(&FullRange)).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1222,7 +1222,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 .sess\n                                 .fatal(format!(\n                                         \"unbound path {}\",\n-                                        pprust::path_to_string(path))[])\n+                                        pprust::path_to_string(path)).index(&FullRange))\n                         }\n                         Some(&d) => d\n                     };\n@@ -1420,7 +1420,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_help(span, msg[]);\n+        self.tcx.sess.span_help(span, msg.index(&FullRange));\n     }\n \n     fn report_inference_failure(&self,\n@@ -1463,7 +1463,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             var_origin.span(),\n             format!(\"cannot infer an appropriate lifetime{} \\\n                     due to conflicting requirements\",\n-                    var_description)[]);\n+                    var_description).index(&FullRange));\n     }\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n@@ -1511,7 +1511,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n                             format!(\"...so that {} ({})\",\n-                                    desc, values_str)[]);\n+                                    desc, values_str).index(&FullRange));\n                     }\n                     None => {\n                         // Really should avoid printing this error at\n@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         // doing right now. - nmatsakis\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            format!(\"...so that {}\", desc)[]);\n+                            format!(\"...so that {}\", desc).index(&FullRange));\n                     }\n                 }\n             }\n@@ -1537,7 +1537,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n                             .get()\n-                            .to_string())[])\n+                            .to_string()).index(&FullRange))\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1562,7 +1562,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).get().to_string())[]);\n+                                id).get().to_string()).index(&FullRange));\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1606,7 +1606,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"...so type `{}` of expression is valid during the \\\n                              expression\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)).index(&FullRange));\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note(\n@@ -1618,28 +1618,28 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"...so that the reference type `{}` \\\n                              does not outlive the data it points at\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)).index(&FullRange));\n             }\n             infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that the type `{}` \\\n                              will meet the declared lifetime bounds\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)).index(&FullRange));\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that type parameter \\\n                              instantiated with `{}`, \\\n                              will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)).index(&FullRange));\n             }\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\")[]);\n+                                are satisfied\").index(&FullRange));\n             }\n         }\n     }\n@@ -1691,15 +1691,15 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n                 ast::ItemFn(_, _, _, ref gen, _) => {\n-                    taken.push_all(gen.lifetimes[]);\n+                    taken.push_all(gen.lifetimes.index(&FullRange));\n                     None\n                 },\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => {\n-                        taken.push_all(m.pe_generics().lifetimes[]);\n+                        taken.push_all(m.pe_generics().lifetimes.index(&FullRange));\n                         Some(m.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n@@ -1758,10 +1758,10 @@ impl LifeGiver {\n         let mut lifetime;\n         loop {\n             let mut s = String::from_str(\"'\");\n-            s.push_str(num_to_string(self.counter.get())[]);\n+            s.push_str(num_to_string(self.counter.get()).index(&FullRange));\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n-                                    token::str_to_ident(s[]).name);\n+                                    token::str_to_ident(s.index(&FullRange)).name);\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "02c52f82967613316bc9be19fd016e07c4941e65", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n             None => { }\n         }\n \n-        match self.freshen_map.entry(&key) {\n+        match self.freshen_map.entry(key) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let index = self.freshen_count;"}, {"sha": "073052dd368709571097ad8e6b81add70c5ef09f", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -154,7 +154,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n-                debug!(\"generalize_region(r0={}): not new variable\", r0);\n+                debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n                 return r0;\n             }\n \n@@ -164,8 +164,8 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n             if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n-                debug!(\"generalize_region(r0={}): \\\n-                        non-new-variables found in {}\",\n+                debug!(\"generalize_region(r0={:?}): \\\n+                        non-new-variables found in {:?}\",\n                        r0, tainted);\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -178,18 +178,18 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             // with.\n             for (a_br, a_r) in a_map.iter() {\n                 if tainted.iter().any(|x| x == a_r) {\n-                    debug!(\"generalize_region(r0={}): \\\n-                            replacing with {}, tainted={}\",\n+                    debug!(\"generalize_region(r0={:?}): \\\n+                            replacing with {:?}, tainted={:?}\",\n                            r0, *a_br, tainted);\n                     return ty::ReLateBound(debruijn, *a_br);\n                 }\n             }\n \n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"region {} is not associated with \\\n+                format!(\"region {:?} is not associated with \\\n                          any bound region from A!\",\n-                        r0)[])\n+                        r0).index(&FullRange))\n         }\n     }\n \n@@ -322,7 +322,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"could not find original bound region for {}\", r)[]);\n+                format!(\"could not find original bound region for {:?}\", r).index(&FullRange));\n         }\n \n         fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -339,7 +339,7 @@ fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n             r => {\n                 combiner.infcx().tcx.sess.span_bug(\n                     combiner.trace().origin.span(),\n-                    format!(\"found non-region-vid: {}\", r)[]);\n+                    format!(\"found non-region-vid: {:?}\", r).index(&FullRange));\n             }\n         }).collect()\n }"}, {"sha": "3f18af3d768e4331319d3eab85b96569665e0230", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -989,7 +989,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                    err: Option<&ty::type_err<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n-        debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n+        debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n \n@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 self.tcx.sess.span_err(sp, format!(\"{}{}\",\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str)[]);\n+                    error_str).index(&FullRange));\n \n                 for err in err.iter() {\n                     ty::note_and_explain_type_err(self.tcx, *err)\n@@ -1219,7 +1219,7 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n             }\n             Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n             ReborrowUpvar(a, b) => {\n-                format!(\"ReborrowUpvar({},{})\", a.repr(tcx), b)\n+                format!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b)\n             }\n             ReferenceOutlivesReferent(_, a) => {\n                 format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx))\n@@ -1277,7 +1277,7 @@ impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n                 format!(\"EarlyBoundRegion({},{})\", a.repr(tcx), b.repr(tcx))\n             }\n             LateBoundRegion(a, b, c) => {\n-                format!(\"LateBoundRegion({},{},{})\", a.repr(tcx), b.repr(tcx), c)\n+                format!(\"LateBoundRegion({},{},{:?})\", a.repr(tcx), b.repr(tcx), c)\n             }\n             BoundRegionInCoherence(a) => {\n                 format!(\"bound_regionInCoherence({})\", a.repr(tcx))"}, {"sha": "29feaf358e2e259795cef71f9505b386b5e92fe4", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -67,7 +67,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n \n     let requested_output = os::getenv(\"RUST_REGION_GRAPH\");\n-    debug!(\"requested_output: {} requested_node: {}\",\n+    debug!(\"requested_output: {:?} requested_node: {:?}\",\n            requested_output, requested_node);\n \n     let output_path = {\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n         let mut node_ids = FnvHashMap::new();\n         {\n             let mut add_node = |&mut : node| {\n-                if let Vacant(e) = node_ids.entry(&node) {\n+                if let Vacant(e) = node_ids.entry(node) {\n                     e.insert(i);\n                     i += 1;\n                 }\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     fn node_label(&self, n: &Node) -> dot::LabelText {\n         match *n {\n             Node::RegionVid(n_vid) =>\n-                dot::LabelText::label(format!(\"{}\", n_vid)),\n+                dot::LabelText::label(format!(\"{:?}\", n_vid)),\n             Node::Region(n_rgn) =>\n                 dot::LabelText::label(format!(\"{}\", n_rgn.repr(self.tcx))),\n         }\n@@ -204,12 +204,12 @@ impl<'a, 'tcx> dot::GraphWalk<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     }\n     fn source(&self, edge: &Edge) -> Node {\n         let (n1, _) = constraint_to_nodes(edge);\n-        debug!(\"edge {} has source {}\", edge, n1);\n+        debug!(\"edge {:?} has source {:?}\", edge, n1);\n         n1\n     }\n     fn target(&self, edge: &Edge) -> Node {\n         let (_, n2) = constraint_to_nodes(edge);\n-        debug!(\"edge {} has target {}\", edge, n2);\n+        debug!(\"edge {:?} has target {:?}\", edge, n2);\n         n2\n     }\n }"}, {"sha": "bdc787e4d589cc010a05eb29e8476d07e4c9e945", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -273,7 +273,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn rollback_to(&self, snapshot: RegionSnapshot) {\n-        debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n+        debug!(\"RegionVarBindings: rollback_to({:?})\", snapshot);\n         let mut undo_log = self.undo_log.borrow_mut();\n         assert!(undo_log.len() > snapshot.length);\n         assert!((*undo_log)[snapshot.length] == OpenSnapshot);\n@@ -325,7 +325,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n-        debug!(\"created new region variable {} with origin {}\",\n+        debug!(\"created new region variable {:?} with origin {}\",\n                vid, origin.repr(self.tcx));\n         return vid;\n     }\n@@ -427,7 +427,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         let mut givens = self.givens.borrow_mut();\n         if givens.insert((sub, sup)) {\n-            debug!(\"add_given({} <= {})\",\n+            debug!(\"add_given({} <= {:?})\",\n                    sub.repr(self.tcx),\n                    sup);\n \n@@ -475,7 +475,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 origin.span(),\n                 format!(\"cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n-                        sup.repr(self.tcx))[]);\n+                        sup.repr(self.tcx)).index(&FullRange));\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -565,7 +565,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n             Some(ref values) => {\n                 let r = lookup(values, rid);\n-                debug!(\"resolve_var({}) = {}\", rid, r.repr(self.tcx));\n+                debug!(\"resolve_var({:?}) = {}\", rid, r.repr(self.tcx));\n                 r\n             }\n         }\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n         relate(self, a, ReInfer(ReVar(c)));\n         relate(self, b, ReInfer(ReVar(c)));\n-        debug!(\"combine_vars() c={}\", c);\n+        debug!(\"combine_vars() c={:?}\", c);\n         ReInfer(ReVar(c))\n     }\n \n@@ -623,7 +623,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// made---`r0` itself will be the first entry. This is used when checking whether skolemized\n     /// regions are being improperly related to other regions.\n     pub fn tainted(&self, mark: &RegionSnapshot, r0: Region) -> Vec<Region> {\n-        debug!(\"tainted(mark={}, r0={})\", mark, r0.repr(self.tcx));\n+        debug!(\"tainted(mark={:?}, r0={})\", mark, r0.repr(self.tcx));\n         let _indenter = indenter();\n \n         // `result_set` acts as a worklist: we explore all outgoing\n@@ -634,7 +634,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n             let r = result_set[result_index];\n-            debug!(\"result_index={}, r={}\", result_index, r);\n+            debug!(\"result_index={}, r={:?}\", result_index, r);\n \n             for undo_entry in\n                 self.undo_log.borrow().slice_from(mark.length).iter()\n@@ -736,7 +736,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.bug(\n                 format!(\"cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n-                        b.repr(self.tcx))[]);\n+                        b.repr(self.tcx)).index(&FullRange));\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -751,9 +751,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.span_bug(\n                 (*self.var_origins.borrow())[v_id.index as uint].span(),\n                 format!(\"lub_concrete_regions invoked with \\\n-                         non-concrete regions: {}, {}\",\n+                         non-concrete regions: {:?}, {:?}\",\n                         a,\n-                        b)[]);\n+                        b).index(&FullRange));\n           }\n \n           (ReFree(ref fr), ReScope(s_id)) |\n@@ -827,7 +827,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                             a: Region,\n                             b: Region)\n                          -> cres<'tcx, Region> {\n-        debug!(\"glb_concrete_regions({}, {})\", a, b);\n+        debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (ReLateBound(..), _) |\n             (_, ReLateBound(..)) |\n@@ -836,7 +836,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n               self.tcx.sess.bug(\n                   format!(\"cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n-                          b.repr(self.tcx))[]);\n+                          b.repr(self.tcx)).index(&FullRange));\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -854,9 +854,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 self.tcx.sess.span_bug(\n                     (*self.var_origins.borrow())[v_id.index as uint].span(),\n                     format!(\"glb_concrete_regions invoked with \\\n-                             non-concrete regions: {}, {}\",\n+                             non-concrete regions: {:?}, {:?}\",\n                             a,\n-                            b)[]);\n+                            b).index(&FullRange));\n             }\n \n             (ReFree(ref fr), ReScope(s_id)) |\n@@ -932,7 +932,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // scopes or two free regions.  So, if one of\n         // these scopes is a subscope of the other, return\n         // it. Otherwise fail.\n-        debug!(\"intersect_scopes(scope_a={}, scope_b={}, region_a={}, region_b={})\",\n+        debug!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n                scope_a, scope_b, region_a, region_b);\n         match self.tcx.region_maps.nearest_common_ancestor(scope_a, scope_b) {\n             Some(r_id) if scope_a == r_id => Ok(ReScope(scope_b)),\n@@ -971,13 +971,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n-        debug!(\"----() End constraint listing {}---\", self.dump_constraints());\n+        debug!(\"----() End constraint listing {:?}---\", self.dump_constraints());\n         graphviz::maybe_print_constraints_for(self, subject);\n \n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());\n         let values =\n-            self.extract_values_and_collect_conflicts(var_data[],\n+            self.extract_values_and_collect_conflicts(var_data.index(&FullRange),\n                                                       errors);\n         self.collect_concrete_region_errors(&values, errors);\n         values\n@@ -1039,7 +1039,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                    b_data: &mut VarData)\n                    -> bool\n     {\n-        debug!(\"expand_node({}, {} == {})\",\n+        debug!(\"expand_node({}, {:?} == {})\",\n                a_region.repr(self.tcx),\n                b_vid,\n                b_data.value.repr(self.tcx));\n@@ -1058,7 +1058,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         b_data.classification = Expanding;\n         match b_data.value {\n           NoValue => {\n-            debug!(\"Setting initial value of {} to {}\",\n+            debug!(\"Setting initial value of {:?} to {}\",\n                    b_vid, a_region.repr(self.tcx));\n \n             b_data.value = Value(a_region);\n@@ -1071,7 +1071,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 return false;\n             }\n \n-            debug!(\"Expanding value of {} from {} to {}\",\n+            debug!(\"Expanding value of {:?} from {} to {}\",\n                    b_vid,\n                    cur_region.repr(self.tcx),\n                    lub.repr(self.tcx));\n@@ -1122,7 +1122,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                      a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n-        debug!(\"contract_node({} == {}/{}, {})\",\n+        debug!(\"contract_node({:?} == {}/{:?}, {})\",\n                a_vid, a_data.value.repr(self.tcx),\n                a_data.classification, b_region.repr(self.tcx));\n \n@@ -1156,7 +1156,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                       b_region: Region)\n                    -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n-                debug!(\"Setting {} to ErrorValue: {} not subregion of {}\",\n+                debug!(\"Setting {:?} to ErrorValue: {} not subregion of {}\",\n                        a_vid,\n                        a_region.repr(this.tcx),\n                        b_region.repr(this.tcx));\n@@ -1176,7 +1176,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     if glb == a_region {\n                         false\n                     } else {\n-                        debug!(\"Contracting value of {} from {} to {}\",\n+                        debug!(\"Contracting value of {:?} from {} to {}\",\n                                a_vid,\n                                a_region.repr(this.tcx),\n                                glb.repr(this.tcx));\n@@ -1185,7 +1185,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     }\n                 }\n                 Err(_) => {\n-                    debug!(\"Setting {} to ErrorValue: no glb of {}, {}\",\n+                    debug!(\"Setting {:?} to ErrorValue: no glb of {}, {}\",\n                            a_vid,\n                            a_region.repr(this.tcx),\n                            b_region.repr(this.tcx));\n@@ -1412,10 +1412,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as uint].span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n-                    for var {}, lower_bounds={}, upper_bounds={}\",\n+                    for var {:?}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n                     lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx))[]);\n+                    upper_bounds.repr(self.tcx)).index(&FullRange));\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1457,9 +1457,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as uint].span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n-                     for var {}, upper_bounds={}\",\n+                     for var {:?}, upper_bounds={}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx))[]);\n+                    upper_bounds.repr(self.tcx)).index(&FullRange));\n     }\n \n     fn collect_concrete_regions(&self,\n@@ -1498,8 +1498,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 state.dup_found = true;\n             }\n \n-            debug!(\"collect_concrete_regions(orig_node_idx={}, node_idx={}, \\\n-                    classification={})\",\n+            debug!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?}, \\\n+                    classification={:?})\",\n                    orig_node_idx, node_idx, classification);\n \n             // figure out the direction from which this node takes its\n@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                          graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n-            debug!(\"process_edges(source_vid={}, dir={})\", source_vid, dir);\n+            debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.index as uint);\n             graph.each_adjacent_edge(source_node_index, dir, |_, edge| {"}, {"sha": "9035d72e9a2fb633443a928ed7441d04779b6e6a", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 ty::ty_infer(_) => {\n                     self.infcx.tcx.sess.bug(\n                         format!(\"Unexpected type in full type resolver: {}\",\n-                                t.repr(self.infcx.tcx))[]);\n+                                t.repr(self.infcx.tcx)).index(&FullRange));\n                 }\n                 _ => {\n                     ty_fold::super_fold_ty(self, t)"}, {"sha": "3f3e4c50e70479591b86bb15a3b67ac4cc94b8f4", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -184,7 +184,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                         let escaping_type = self.probe(vid).unwrap();\n                         escaping_types.push(escaping_type);\n                     }\n-                    debug!(\"SpecifyVar({}) new_elem_threshold={}\", vid, new_elem_threshold);\n+                    debug!(\"SpecifyVar({:?}) new_elem_threshold={}\", vid, new_elem_threshold);\n                 }\n \n                 _ => { }"}, {"sha": "4fa8e07ddd4f1ddd3d702d75d71f950a6d052bb8", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -10,7 +10,7 @@\n \n pub use self::VarValue::*;\n \n-use std::kinds::marker;\n+use std::marker;\n \n use middle::ty::{expected_found, IntVarValue};\n use middle::ty::{self, Ty};\n@@ -129,7 +129,7 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n     pub fn new_key(&mut self, value: V) -> K {\n         let index = self.values.push(Root(value, 0));\n         let k = UnifyKey::from_index(index);\n-        debug!(\"{}: created new key: {}\",\n+        debug!(\"{}: created new key: {:?}\",\n                UnifyKey::tag(None::<K>),\n                k);\n         k"}, {"sha": "bd96a8a0f2cd78f980ea42ecb19fcb9749f59321", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -205,11 +205,11 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n                 debug!(\"with_each_combination(substs={})\",\n                        substs.repr(self.tcx));\n \n-                callback.call_mut((substs,));\n+                callback(substs);\n             }\n \n             Some((space, index, &param_ty)) => {\n-                debug!(\"with_each_combination: space={}, index={}, param_ty={}\",\n+                debug!(\"with_each_combination: space={:?}, index={}, param_ty={}\",\n                        space, index, param_ty.repr(self.tcx));\n \n                 if !ty::type_is_sized(param_env, span, param_ty) {"}, {"sha": "2f81d8c0f701e4f10611bd0374e6e524a3343ae0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -266,8 +266,6 @@ lets_do_this! {\n     ShrTraitLangItem,                \"shr\",                     shr_trait;\n     IndexTraitLangItem,              \"index\",                   index_trait;\n     IndexMutTraitLangItem,           \"index_mut\",               index_mut_trait;\n-    SliceTraitLangItem,              \"slice\",                   slice_trait;\n-    SliceMutTraitLangItem,           \"slice_mut\",               slice_mut_trait;\n     RangeStructLangItem,             \"range\",                   range_struct;\n     RangeFromStructLangItem,         \"range_from\",              range_from_struct;\n     RangeToStructLangItem,           \"range_to\",                range_to_struct;"}, {"sha": "850033b3ed126a0c65d0db7cceaf020561a01b55", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -112,6 +112,7 @@ use self::VarKind::*;\n use middle::def::*;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n+use middle::region::CodeExtent;\n use middle::ty;\n use middle::ty::UnboxedClosureTyper;\n use lint;\n@@ -289,7 +290,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         self.lnks.push(lnk);\n         self.num_live_nodes += 1;\n \n-        debug!(\"{} is of kind {}\", ln.to_string(),\n+        debug!(\"{:?} is of kind {}\", ln,\n                live_node_kind_to_string(lnk, self.tcx));\n \n         ln\n@@ -299,7 +300,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n-        debug!(\"{} is node {}\", ln.to_string(), node_id);\n+        debug!(\"{:?} is node {}\", ln, node_id);\n     }\n \n     fn add_variable(&mut self, vk: VarKind) -> Variable {\n@@ -314,7 +315,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             ImplicitRet | CleanExit => {}\n         }\n \n-        debug!(\"{} is {}\", v.to_string(), vk);\n+        debug!(\"{:?} is {:?}\", v, vk);\n \n         v\n     }\n@@ -326,7 +327,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             self.tcx\n                 .sess\n                 .span_bug(span, format!(\"no variable registered for id {}\",\n-                                        node_id)[]);\n+                                        node_id).index(&FullRange));\n           }\n         }\n     }\n@@ -377,7 +378,7 @@ fn visit_fn(ir: &mut IrMaps,\n     // swap in a new set of IR maps for this function body:\n     let mut fn_maps = IrMaps::new(ir.tcx);\n \n-    debug!(\"creating fn_maps: {}\", &fn_maps as *const IrMaps);\n+    debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n     for arg in decl.inputs.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n@@ -430,7 +431,7 @@ fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n     for pat in arm.pats.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from match with bm {}\",\n+            debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -448,7 +449,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       // live nodes required for uses or definitions of variables:\n       ast::ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow()[expr.id].clone();\n-        debug!(\"expr {}: path that leads to {}\", expr.id, def);\n+        debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let DefLocal(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n@@ -491,7 +492,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       }\n       ast::ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from for loop with bm {}\",\n+            debug!(\"adding local variable {} from for loop with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -597,7 +598,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.ir.tcx.sess.span_bug(\n                 span,\n                 format!(\"no live node registered for node {}\",\n-                        node_id)[]);\n+                        node_id).index(&FullRange));\n           }\n         }\n     }\n@@ -702,7 +703,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                try!(write!(wr, \" {}\", Variable(var_idx).to_string()));\n+                try!(write!(wr, \" {:?}\", Variable(var_idx)));\n             }\n         }\n         Ok(())\n@@ -740,11 +741,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut wr = Vec::new();\n         {\n             let wr = &mut wr as &mut io::Writer;\n-            write!(wr, \"[ln({}) of kind {} reads\", ln.get(), self.ir.lnk(ln));\n+            write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n             self.write_vars(wr, ln, |idx| self.users[idx].reader);\n             write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.users[idx].writer);\n-            write!(wr, \"  precedes {}]\", self.successors[ln.get()].to_string());\n+            write!(wr, \"  precedes {:?}]\", self.successors[ln.get()]);\n         }\n         String::from_utf8(wr).unwrap()\n     }\n@@ -792,8 +793,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         });\n \n-        debug!(\"merge_from_succ(ln={}, succ={}, first_merge={}, changed={})\",\n-               ln.to_string(), self.ln_str(succ_ln), first_merge, changed);\n+        debug!(\"merge_from_succ(ln={:?}, succ={}, first_merge={}, changed={})\",\n+               ln, self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n \n         fn copy_if_invalid(src: LiveNode, dst: &mut LiveNode) -> bool {\n@@ -814,14 +815,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n \n-        debug!(\"{} defines {} (idx={}): {}\", writer.to_string(), var.to_string(),\n+        debug!(\"{:?} defines {:?} (idx={}): {}\", writer, var,\n                idx, self.ln_str(writer));\n     }\n \n     // Either read, write, or both depending on the acc bitset\n     fn acc(&mut self, ln: LiveNode, var: Variable, acc: uint) {\n-        debug!(\"{} accesses[{:x}] {}: {}\",\n-               ln.to_string(), acc, var.to_string(), self.ln_str(ln));\n+        debug!(\"{:?} accesses[{:x}] {:?}: {}\",\n+               ln, acc, var, self.ln_str(ln));\n \n         let idx = self.idx(ln, var);\n         let user = &mut self.users[idx];\n@@ -857,14 +858,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               |this| this.propagate_through_fn_block(decl, body));\n \n         // hack to skip the loop unless debug! is enabled:\n-        debug!(\"^^ liveness computation results for body {} (entry={})\",\n+        debug!(\"^^ liveness computation results for body {} (entry={:?})\",\n                {\n                    for ln_idx in range(0u, self.ir.num_live_nodes) {\n-                       debug!(\"{}\", self.ln_str(LiveNode(ln_idx)));\n+                       debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n                },\n-               entry_ln.to_string());\n+               entry_ln);\n \n         entry_ln\n     }\n@@ -1132,7 +1133,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           ast::ExprVec(ref exprs) => {\n-            self.propagate_through_exprs(exprs[], succ)\n+            self.propagate_through_exprs(exprs.index(&FullRange), succ)\n           }\n \n           ast::ExprRepeat(ref element, ref count) => {\n@@ -1149,32 +1150,31 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n-                let t_ret = ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f));\n-                t_ret == ty::FnDiverging\n+                ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f)).diverges()\n             };\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(args[], succ);\n+            let succ = self.propagate_through_exprs(args.index(&FullRange), succ);\n             self.propagate_through_expr(&**f, succ)\n           }\n \n           ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n-            let diverges = ty::ty_fn_ret(method_ty) == ty::FnDiverging;\n+            let diverges = ty::ty_fn_ret(method_ty).diverges();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(args[], succ)\n+            self.propagate_through_exprs(args.index(&FullRange), succ)\n           }\n \n           ast::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(exprs[], succ)\n+            self.propagate_through_exprs(exprs.index(&FullRange), succ)\n           }\n \n           ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n@@ -1514,11 +1514,11 @@ fn check_fn(_v: &Liveness,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::FnOutput<'tcx> {\n+    fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n             ty::ty_unboxed_closure(closure_def_id, _, substs) =>\n-                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.0.output,\n+                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.output(),\n             _ =>\n                 ty::ty_fn_ret(fn_ty),\n         }\n@@ -1529,8 +1529,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &ast::Block) {\n-        match self.fn_ret(id) {\n+                 body: &ast::Block)\n+    {\n+        // within the fn body, late-bound regions are liberated:\n+        let fn_ret =\n+            ty::liberate_late_bound_regions(\n+                self.ir.tcx,\n+                CodeExtent::from_node_id(body.id),\n+                &self.fn_ret(id));\n+\n+        match fn_ret {\n             ty::FnConverging(t_ret)\n                 if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n "}, {"sha": "b29c24c586114ff6492c2a32e89647bf069c4564", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -482,28 +482,20 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n           }\n \n-          ast::ExprIndex(ref base, ref idx) => {\n-            match idx.node {\n-                ast::ExprRange(..) => {\n-                    // Slicing syntax special case (KILLME).\n-                    Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n+          ast::ExprIndex(ref base, _) => {\n+            let method_call = ty::MethodCall::expr(expr.id());\n+            match self.typer.node_method_ty(method_call) {\n+                Some(method_ty) => {\n+                    // If this is an index implemented by a method call, then it\n+                    // will include an implicit deref of the result.\n+                    let ret_ty = self.overloaded_method_return_ty(method_ty);\n+                    self.cat_deref(expr,\n+                                   self.cat_rvalue_node(expr.id(),\n+                                                        expr.span(),\n+                                                        ret_ty), 1, true)\n                 }\n-                _ => {\n-                    let method_call = ty::MethodCall::expr(expr.id());\n-                    match self.typer.node_method_ty(method_call) {\n-                        Some(method_ty) => {\n-                            // If this is an index implemented by a method call, then it will\n-                            // include an implicit deref of the result.\n-                            let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n-                            self.cat_deref(expr,\n-                                           self.cat_rvalue_node(expr.id(),\n-                                                                expr.span(),\n-                                                                ret_ty), 1, true)\n-                        }\n-                        None => {\n-                            self.cat_index(expr, try!(self.cat_expr(&**base)))\n-                        }\n-                    }\n+                None => {\n+                    self.cat_index(expr, try!(self.cat_expr(&**base)))\n                 }\n             }\n           }\n@@ -547,7 +539,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    expr_ty: Ty<'tcx>,\n                    def: def::Def)\n                    -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_def: id={} expr={} def={}\",\n+        debug!(\"cat_def: id={} expr={} def={:?}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n@@ -594,7 +586,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           span,\n                           format!(\"Upvar of non-closure {} - {}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx()))[]);\n+                                  ty.repr(self.tcx())).index(&FullRange));\n                   }\n               }\n           }\n@@ -860,12 +852,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let method_ty = self.typer.node_method_ty(method_call);\n \n-        debug!(\"cat_deref: method_call={} method_ty={}\",\n+        debug!(\"cat_deref: method_call={:?} method_ty={:?}\",\n                method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n \n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n-                let ref_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                let ref_ty =\n+                    ty::assert_no_late_bound_regions(\n+                        self.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n@@ -945,9 +939,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         let element_ty = match method_ty {\n             Some(method_ty) => {\n-                let ref_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                let ref_ty = self.overloaded_method_return_ty(method_ty);\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n-                ty::ty_fn_args(method_ty)[0]\n+\n+                // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n+                let self_ty = ty::ty_fn_sig(method_ty).input(0);\n+                ty::assert_no_late_bound_regions(self.tcx(), &self_ty)\n             }\n             None => {\n                 match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n@@ -1269,6 +1266,19 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         Ok(())\n     }\n+\n+    fn overloaded_method_return_ty(&self,\n+                                   method_ty: Ty<'tcx>)\n+                                   -> Ty<'tcx>\n+    {\n+        // When we process an overloaded `*` or `[]` etc, we often\n+        // need to extract the return type of the method. These method\n+        // types are generated by method resolution and always have\n+        // all late-bound regions fully instantiated, so we just want\n+        // to skip past the binder.\n+        ty::assert_no_late_bound_regions(self.tcx(), &ty::ty_fn_ret(method_ty))\n+            .unwrap() // overloaded ops do not diverge, either\n+    }\n }\n \n #[derive(Copy)]\n@@ -1455,7 +1465,7 @@ impl<'tcx> cmt_<'tcx> {\n \n impl<'tcx> Repr<'tcx> for cmt_<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"{{{} id:{} m:{} ty:{}}}\",\n+        format!(\"{{{} id:{} m:{:?} ty:{}}}\",\n                 self.cat.repr(tcx),\n                 self.id,\n                 self.mutbl,\n@@ -1470,7 +1480,7 @@ impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_upvar(..) => {\n-                format!(\"{}\", *self)\n+                format!(\"{:?}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n                 format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr_sigil(ptr), derefs)"}, {"sha": "861c4a2c85e356b52f6750833e6fe10cc4fc4024", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -435,28 +435,28 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     fn def_privacy(&self, did: ast::DefId) -> PrivacyResult {\n         if !is_local(did) {\n             if self.external_exports.contains(&did) {\n-                debug!(\"privacy - {} was externally exported\", did);\n+                debug!(\"privacy - {:?} was externally exported\", did);\n                 return Allowable;\n             }\n-            debug!(\"privacy - is {} a public method\", did);\n+            debug!(\"privacy - is {:?} a public method\", did);\n \n             return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n-                    debug!(\"privacy - well at least it's a method: {}\",\n+                    debug!(\"privacy - well at least it's a method: {:?}\",\n                            *meth);\n                     match meth.container {\n                         ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {}\", id);\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n-                                    debug!(\"privacy - impl of trait {}\", id);\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n-                                    debug!(\"privacy - found a method {}\",\n+                                    debug!(\"privacy - found a method {:?}\",\n                                             meth.vis);\n                                     if meth.vis == ast::Public {\n                                         Allowable\n@@ -471,17 +471,17 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 Some(&ty::TypeTraitItem(ref typedef)) => {\n                     match typedef.container {\n                         ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {}\", id);\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n-                                    debug!(\"privacy - impl of trait {}\", id);\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n-                                    debug!(\"privacy - found a typedef {}\",\n+                                    debug!(\"privacy - found a typedef {:?}\",\n                                             typedef.vis);\n                                     if typedef.vis == ast::Public {\n                                         Allowable\n@@ -615,10 +615,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, msg[]);\n+                self.tcx.sess.span_err(span, msg.index(&FullRange));\n                 match note {\n                     Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, msg[])\n+                        self.tcx.sess.span_note(span, msg.index(&FullRange))\n                     }\n                     None => {},\n                 }\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         let field = match name {\n             NamedField(ident) => {\n-                debug!(\"privacy - check named field {} in struct {}\", ident.name, id);\n+                debug!(\"privacy - check named field {} in struct {:?}\", ident.name, id);\n                 fields.iter().find(|f| f.name == ident.name).unwrap()\n             }\n             UnnamedField(idx) => &fields[idx]\n@@ -720,7 +720,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n-        self.tcx.sess.span_err(span, msg[]);\n+        self.tcx.sess.span_err(span, msg.index(&FullRange));\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n@@ -742,7 +742,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                              method_id,\n                                              None,\n                                              format!(\"method `{}`\",\n-                                                     string)[]));\n+                                                     string).index(&FullRange)));\n     }\n \n     // Checks that a path is in scope.\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n-                                   format!(\"{} `{}`\", tyname, name)[])\n+                                   format!(\"{} `{}`\", tyname, name).index(&FullRange))\n             };\n \n             match self.last_private_map[path_id] {"}, {"sha": "51602e88f9342c3dfe0a84ff545d448b54dcb15c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -50,7 +50,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(item.attrs[]) {\n+    if attributes_specify_inlining(item.attrs.index(&FullRange)) {\n         return true\n     }\n \n@@ -65,7 +65,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(method.attrs[]) ||\n+    if attributes_specify_inlining(method.attrs.index(&FullRange)) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n-                                    method.attrs[]) {\n+                                    method.attrs.index(&FullRange)) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 None => {\n                     self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n-                                              search_item)[])\n+                                              search_item).index(&FullRange))\n                 }\n             }\n         }\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     .bug(format!(\"found unexpected thingy in worklist: {}\",\n                                  self.tcx\n                                      .map\n-                                     .node_to_string(search_item))[])\n+                                     .node_to_string(search_item)).index(&FullRange))\n             }\n         }\n     }"}, {"sha": "5d18843097f37f7f4491faba54220232a2347c36", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -146,24 +146,24 @@ impl RegionMaps {\n             None => {}\n         }\n \n-        debug!(\"relate_free_regions(sub={}, sup={})\", sub, sup);\n+        debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n         self.free_region_map.borrow_mut().insert(sub, vec!(sup));\n     }\n \n     pub fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n-        debug!(\"record_encl_scope(sub={}, sup={})\", sub, sup);\n+        debug!(\"record_encl_scope(sub={:?}, sup={:?})\", sub, sup);\n         assert!(sub != sup);\n         self.scope_map.borrow_mut().insert(sub, sup);\n     }\n \n     pub fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n-        debug!(\"record_var_scope(sub={}, sup={})\", var, lifetime);\n+        debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.var_map.borrow_mut().insert(var, lifetime);\n     }\n \n     pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n-        debug!(\"record_rvalue_scope(sub={}, sup={})\", var, lifetime);\n+        debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n     }\n@@ -172,7 +172,7 @@ impl RegionMaps {\n     /// e.g. by an expression like `a().f` -- they will be freed within the innermost terminating\n     /// scope.\n     pub fn mark_as_terminating_scope(&self, scope_id: CodeExtent) {\n-        debug!(\"record_terminating_scope(scope_id={})\", scope_id);\n+        debug!(\"record_terminating_scope(scope_id={:?})\", scope_id);\n         self.terminating_scopes.borrow_mut().insert(scope_id);\n     }\n \n@@ -186,15 +186,15 @@ impl RegionMaps {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         match self.scope_map.borrow().get(&id) {\n             Some(&r) => r,\n-            None => { panic!(\"no enclosing scope for id {}\", id); }\n+            None => { panic!(\"no enclosing scope for id {:?}\", id); }\n         }\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n     pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n         match self.var_map.borrow().get(&var_id) {\n             Some(&r) => r,\n-            None => { panic!(\"no enclosing scope for id {}\", var_id); }\n+            None => { panic!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n@@ -204,7 +204,7 @@ impl RegionMaps {\n         // check for a designated rvalue scope\n         match self.rvalue_scopes.borrow().get(&expr_id) {\n             Some(&s) => {\n-                debug!(\"temporary_scope({}) = {} [custom]\", expr_id, s);\n+                debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n                 return Some(s);\n             }\n             None => { }\n@@ -225,20 +225,20 @@ impl RegionMaps {\n                     id = p;\n                 }\n                 None => {\n-                    debug!(\"temporary_scope({}) = None\", expr_id);\n+                    debug!(\"temporary_scope({:?}) = None\", expr_id);\n                     return None;\n                 }\n             }\n         }\n-        debug!(\"temporary_scope({}) = {} [enclosing]\", expr_id, id);\n+        debug!(\"temporary_scope({:?}) = {:?} [enclosing]\", expr_id, id);\n         return Some(id);\n     }\n \n     pub fn var_region(&self, id: ast::NodeId) -> ty::Region {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n-        debug!(\"var_region({}) = {}\", id, scope);\n+        debug!(\"var_region({:?}) = {:?}\", id, scope);\n         scope\n     }\n \n@@ -258,7 +258,7 @@ impl RegionMaps {\n         while superscope != s {\n             match self.scope_map.borrow().get(&s) {\n                 None => {\n-                    debug!(\"is_subscope_of({}, {}, s={})=false\",\n+                    debug!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n                            subscope, superscope, s);\n \n                     return false;\n@@ -267,7 +267,7 @@ impl RegionMaps {\n             }\n         }\n \n-        debug!(\"is_subscope_of({}, {})=true\",\n+        debug!(\"is_subscope_of({:?}, {:?})=true\",\n                subscope, superscope);\n \n         return true;\n@@ -287,7 +287,7 @@ impl RegionMaps {\n                            sub_region: ty::Region,\n                            super_region: ty::Region)\n                            -> bool {\n-        debug!(\"is_subregion_of(sub_region={}, super_region={})\",\n+        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n                sub_region, super_region);\n \n         sub_region == super_region || {\n@@ -365,7 +365,7 @@ impl RegionMaps {\n \n         fn ancestors_of(this: &RegionMaps, scope: CodeExtent)\n             -> Vec<CodeExtent> {\n-            // debug!(\"ancestors_of(scope={})\", scope);\n+            // debug!(\"ancestors_of(scope={:?})\", scope);\n             let mut result = vec!(scope);\n             let mut scope = scope;\n             loop {\n@@ -376,7 +376,7 @@ impl RegionMaps {\n                         scope = superscope;\n                     }\n                 }\n-                // debug!(\"ancestors_of_loop(scope={})\", scope);\n+                // debug!(\"ancestors_of_loop(scope={:?})\", scope);\n             }\n         }\n     }\n@@ -414,7 +414,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n }\n \n fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n-    debug!(\"resolve_block(blk.id={})\", blk.id);\n+    debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     // Record the parent of this block.\n     record_superlifetime(visitor, blk.id, blk.span);\n@@ -466,7 +466,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n \n fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     let stmt_id = stmt_id(stmt);\n-    debug!(\"resolve_stmt(stmt.id={})\", stmt_id);\n+    debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     let stmt_scope = CodeExtent::from_node_id(stmt_id);\n     visitor.region_maps.mark_as_terminating_scope(stmt_scope);\n@@ -479,7 +479,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n-    debug!(\"resolve_expr(expr.id={})\", expr.id);\n+    debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     record_superlifetime(visitor, expr.id, expr.span);\n \n@@ -566,7 +566,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n }\n \n fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n-    debug!(\"resolve_local(local.id={},local.init={})\",\n+    debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n \n     let blk_id = match visitor.cx.var_parent {\n@@ -643,7 +643,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     // A, but the inner rvalues `a()` and `b()` have an extended lifetime\n     // due to rule C.\n     //\n-    // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n+    // FIXME(#6308) -- Note that `.index(&FullRange)` patterns work more smoothly post-DST.\n \n     match local.init {\n         Some(ref expr) => {\n@@ -815,10 +815,10 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               body: &ast::Block,\n               sp: Span,\n               id: ast::NodeId) {\n-    debug!(\"region::resolve_fn(id={}, \\\n-                               span={}, \\\n-                               body.id={}, \\\n-                               cx.parent={})\",\n+    debug!(\"region::resolve_fn(id={:?}, \\\n+                               span={:?}, \\\n+                               body.id={:?}, \\\n+                               cx.parent={:?})\",\n            id,\n            visitor.sess.codemap().span_to_string(sp),\n            body.id,"}, {"sha": "8e03d774b812418544b92ac685941282cf1dfdf1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_poly_trait_ref(&mut self, trait_ref:\n                             &ast::PolyTraitRef,\n                             _modifier: &ast::TraitBoundModifier) {\n-        debug!(\"visit_poly_trait_ref trait_ref={}\", trait_ref);\n+        debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n             this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n@@ -250,9 +250,9 @@ impl<'a> LifetimeContext<'a> {\n             scope: &wrap_scope,\n             def_map: self.def_map,\n         };\n-        debug!(\"entering scope {}\", this.scope);\n+        debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);\n-        debug!(\"exiting scope {}\", this.scope);\n+        debug!(\"exiting scope {:?}\", this.scope);\n     }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n@@ -281,7 +281,7 @@ impl<'a> LifetimeContext<'a> {\n     {\n         let referenced_idents = early_bound_lifetime_names(generics);\n \n-        debug!(\"visit_early_late: referenced_idents={}\",\n+        debug!(\"visit_early_late: referenced_idents={:?}\",\n                referenced_idents);\n \n         let (early, late): (Vec<_>, _) = generics.lifetimes.iter().cloned().partition(\n@@ -399,7 +399,7 @@ impl<'a> LifetimeContext<'a> {\n         self.sess.span_err(\n             lifetime_ref.span,\n             format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name))[]);\n+                    token::get_name(lifetime_ref.name)).index(&FullRange));\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -413,7 +413,7 @@ impl<'a> LifetimeContext<'a> {\n                         lifetime.lifetime.span,\n                         format!(\"illegal lifetime parameter name: `{}`\",\n                                 token::get_name(lifetime.lifetime.name))\n-                            []);\n+                            .index(&FullRange));\n                 }\n             }\n \n@@ -427,7 +427,7 @@ impl<'a> LifetimeContext<'a> {\n                         format!(\"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n                                 token::get_name(lifetime_j.lifetime.name))\n-                            []);\n+                            .index(&FullRange));\n                 }\n             }\n \n@@ -488,7 +488,7 @@ impl<'a> LifetimeContext<'a> {\n                                probably a bug in syntax::fold\");\n         }\n \n-        debug!(\"lifetime_ref={} id={} resolved to {}\",\n+        debug!(\"lifetime_ref={:?} id={:?} resolved to {:?}\",\n                 lifetime_to_string(lifetime_ref),\n                 lifetime_ref.id,\n                 def);\n@@ -605,9 +605,9 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n impl<'a> fmt::Show for ScopeChain<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({}, {})\", space, defs),\n-            LateScope(defs, _) => write!(fmt, \"LateScope({})\", defs),\n-            BlockScope(id, _) => write!(fmt, \"BlockScope({})\", id),\n+            EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({:?}, {:?})\", space, defs),\n+            LateScope(defs, _) => write!(fmt, \"LateScope({:?})\", defs),\n+            BlockScope(id, _) => write!(fmt, \"BlockScope({:?})\", id),\n             RootScope => write!(fmt, \"RootScope\"),\n         }\n     }"}, {"sha": "359ad8d394129c09b027f503c0201de8b6827928", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -161,7 +161,7 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n     // is this definition the implementation of a trait method?\n     match ty::trait_item_of_item(tcx, id) {\n         Some(ty::MethodTraitItemId(trait_method_id)) if trait_method_id != id => {\n-            debug!(\"lookup: trait_method_id={}\", trait_method_id);\n+            debug!(\"lookup: trait_method_id={:?}\", trait_method_id);\n             return lookup(tcx, trait_method_id)\n         }\n         _ => {}\n@@ -182,7 +182,7 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n             // stability of the trait to determine the stability of any\n             // unmarked impls for it. See FIXME above for more details.\n \n-            debug!(\"lookup: trait_id={}\", trait_id);\n+            debug!(\"lookup: trait_id={:?}\", trait_id);\n             lookup(tcx, trait_id)\n         } else {\n             None"}, {"sha": "98bb0645befd10f488e7c0844f5926fe08a59ab7", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -242,7 +242,7 @@ impl<T:fmt::Show> fmt::Show for VecPerParamSpace<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"VecPerParamSpace {{\"));\n         for space in ParamSpace::all().iter() {\n-            try!(write!(fmt, \"{}: {}, \", *space, self.get_slice(*space)));\n+            try!(write!(fmt, \"{:?}: {:?}, \", *space, self.get_slice(*space)));\n         }\n         try!(write!(fmt, \"}}\"));\n         Ok(())\n@@ -601,10 +601,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                     span,\n                                     format!(\"Type parameter out of range \\\n                                      when substituting in region {} (root type={}) \\\n-                                     (space={}, index={})\",\n+                                     (space={:?}, index={})\",\n                                     region_name.as_str(),\n                                     self.root_ty.repr(self.tcx()),\n-                                    space, i)[]);\n+                                    space, i).index(&FullRange));\n                             }\n                         }\n                 }\n@@ -654,14 +654,14 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 self.tcx().sess.span_bug(\n                     span,\n-                    format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n+                    format!(\"Type parameter `{}` ({}/{:?}/{}) out of range \\\n                                  when substituting (root type={}) substs={}\",\n                             p.repr(self.tcx()),\n                             source_ty.repr(self.tcx()),\n                             p.space,\n                             p.idx,\n                             self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx()))[]);\n+                            self.substs.repr(self.tcx())).index(&FullRange));\n             }\n         };\n \n@@ -711,15 +711,15 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     /// first case we do not increase the Debruijn index and in the second case we do. The reason\n     /// is that only in the second case have we passed through a fn binder.\n     fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"shift_regions(ty={}, region_binders_passed={}, type_has_escaping_regions={})\",\n+        debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, type_has_escaping_regions={:?})\",\n                ty.repr(self.tcx()), self.region_binders_passed, ty::type_has_escaping_regions(ty));\n \n         if self.region_binders_passed == 0 || !ty::type_has_escaping_regions(ty) {\n             return ty;\n         }\n \n         let result = ty_fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n-        debug!(\"shift_regions: shifted result = {}\", result.repr(self.tcx()));\n+        debug!(\"shift_regions: shifted result = {:?}\", result.repr(self.tcx()));\n \n         result\n     }"}, {"sha": "49c7d6aafaa5e4583057a7a5cad507d3f2a593c9", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -137,7 +137,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_err => {\n             tcx.sess.bug(\n                 format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx))[])\n+                        ty.repr(tcx)).index(&FullRange))\n         }\n     }\n }"}, {"sha": "fd6773afb765d055ed795aaa26feb21b25069ffe", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -339,5 +339,5 @@ pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n         span,\n         format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-            suggested_limit)[]);\n+            suggested_limit).index(&FullRange));\n }"}, {"sha": "71a3ad64faf9ba965bd0d02fdbbae8604fc8a4c9", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n-        self.predicates[]\n+        self.predicates.index(&FullRange)\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n@@ -437,11 +437,9 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"register_region_obligation({})\",\n            region_obligation.repr(tcx));\n \n-    let body_id = region_obligation.cause.body_id;\n-    match region_obligations.entry(&body_id) {\n+    match region_obligations.entry(region_obligation.cause.body_id) {\n         Vacant(entry) => { entry.insert(vec![region_obligation]); },\n         Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n     }\n \n }\n-"}, {"sha": "3ef6694ce31c76f3793920dae07c55b44b47c02a", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -297,7 +297,7 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                        span: Span)\n                                        -> SelectionResult<'tcx, ()>\n {\n-    debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={})\",\n+    debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={:?})\",\n            ty.repr(infcx.tcx),\n            bound);\n \n@@ -347,7 +347,7 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n         }\n     };\n \n-    debug!(\"type_known_to_meet_builtin_bound: ty={} bound={} result={}\",\n+    debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} result={:?}\",\n            ty.repr(infcx.tcx),\n            bound,\n            result);\n@@ -378,7 +378,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                 span,\n                 format!(\"overflow evaluating whether `{}` is `{}`\",\n                         ty.user_string(infcx.tcx),\n-                        bound.user_string(infcx.tcx))[]);\n+                        bound.user_string(infcx.tcx)).as_slice());\n             suggest_new_overflow_limit(infcx.tcx, span);\n             false\n         }"}, {"sha": "beb3340e3c44a069818ff9569afc88d8642c5803", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -178,7 +178,7 @@ fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // The `Self` type is erased, so it should not appear in list of\n     // arguments or return type apart from the receiver.\n     let ref sig = method.fty.sig;\n-    for &input_ty in sig.0.inputs[1..].iter() {\n+    for &input_ty in sig.0.inputs.index(&(1..)).iter() {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }\n@@ -295,7 +295,7 @@ impl<'tcx> Repr<'tcx> for ObjectSafetyViolation<'tcx> {\n             ObjectSafetyViolation::SizedSelf =>\n                 format!(\"SizedSelf\"),\n             ObjectSafetyViolation::Method(ref m, code) =>\n-                format!(\"Method({},{})\", m.repr(tcx), code),\n+                format!(\"Method({},{:?})\", m.repr(tcx), code),\n         }\n     }\n }"}, {"sha": "67a8508e60dd1760486520a98ea378607cbf5fa8", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -490,7 +490,7 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n                 format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n-                        object_ty.repr(selcx.tcx()))[]);\n+                        object_ty.repr(selcx.tcx())).as_slice());\n         }\n     };\n     let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);"}, {"sha": "25a33de1cc7f018defafcdedef785a2b2ee4a16e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -368,7 +368,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let result = self.evaluate_stack(&stack);\n \n-        debug!(\"result: {}\", result);\n+        debug!(\"result: {:?}\", result);\n         result\n     }\n \n@@ -903,7 +903,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let all_bounds =\n             util::transitive_bounds(\n-                self.tcx(), caller_trait_refs[]);\n+                self.tcx(), caller_trait_refs.index(&FullRange));\n \n         let matching_bounds =\n             all_bounds.filter(\n@@ -944,14 +944,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => { return Ok(()); }\n         };\n \n-        debug!(\"assemble_unboxed_candidates: self_ty={} kind={} obligation={}\",\n+        debug!(\"assemble_unboxed_candidates: self_ty={} kind={:?} obligation={}\",\n                self_ty.repr(self.tcx()),\n                kind,\n                obligation.repr(self.tcx()));\n \n         let closure_kind = self.closure_typer.unboxed_closure_kind(closure_def_id);\n \n-        debug!(\"closure_kind = {}\", closure_kind);\n+        debug!(\"closure_kind = {:?}\", closure_kind);\n \n         if closure_kind == kind {\n             candidates.vec.push(UnboxedClosureCandidate(closure_def_id, substs.clone()));\n@@ -1102,7 +1102,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Err(error) => EvaluatedToErr(error),\n             }\n         });\n-        debug!(\"winnow_candidate depth={} result={}\",\n+        debug!(\"winnow_candidate depth={} result={:?}\",\n                stack.obligation.recursion_depth, result);\n         result\n     }\n@@ -1467,7 +1467,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx()))[]);\n+                        self_ty.repr(self.tcx())).index(&FullRange));\n             }\n         };\n \n@@ -1637,7 +1637,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx()))[]);\n+                            obligation.repr(self.tcx())).index(&FullRange));\n             }\n         }\n     }\n@@ -1716,7 +1716,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let substs =\n                 self.rematch_impl(impl_def_id, obligation,\n                                   snapshot, &skol_map, skol_obligation_trait_ref.trait_ref);\n-            debug!(\"confirm_impl_candidate substs={}\", substs);\n+            debug!(\"confirm_impl_candidate substs={:?}\", substs);\n             Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n         })\n@@ -1816,7 +1816,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"Fn pointer candidate for inappropriate self type: {}\",\n-                            self_ty.repr(self.tcx()))[]);\n+                            self_ty.repr(self.tcx())).index(&FullRange));\n             }\n         };\n \n@@ -1946,7 +1946,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\"Impl {} was matchable against {} but now is not\",\n                             impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx()))[]);\n+                            obligation.repr(self.tcx())).index(&FullRange));\n             }\n         }\n     }\n@@ -2225,7 +2225,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n-            BuiltinCandidate(b) => format!(\"BuiltinCandidate({})\", b),\n+            BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n@@ -2234,7 +2234,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n                 format!(\"ObjectCandidate\")\n             }\n             UnboxedClosureCandidate(c, ref s) => {\n-                format!(\"UnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n+                format!(\"UnboxedClosureCandidate({:?},{})\", c, s.repr(tcx))\n             }\n         }\n     }"}, {"sha": "272447027afd8f6d56e4269d44962e2560731274", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -238,7 +238,7 @@ pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableImpl({})\", self.impl_def_id)\n+        write!(f, \"VtableImpl({:?})\", self.impl_def_id)\n     }\n }\n \n@@ -451,8 +451,8 @@ impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n impl<'tcx> fmt::Show for super::FulfillmentErrorCode<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            super::CodeSelectionError(ref e) => write!(f, \"{}\", e),\n-            super::CodeProjectionError(ref e) => write!(f, \"{}\", e),\n+            super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n+            super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n             super::CodeAmbiguity => write!(f, \"Ambiguity\")\n         }\n     }"}, {"sha": "90716844fbe8097d43f81b064c892228059927e3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 165, "deletions": 157, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -1047,13 +1047,17 @@ pub struct ClosureTy<'tcx> {\n     pub abi: abi::Abi,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum FnOutput<'tcx> {\n     FnConverging(Ty<'tcx>),\n     FnDiverging\n }\n \n impl<'tcx> FnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        *self == FnDiverging\n+    }\n+\n     pub fn unwrap(self) -> Ty<'tcx> {\n         match self {\n             ty::FnConverging(t) => t,\n@@ -1062,6 +1066,14 @@ impl<'tcx> FnOutput<'tcx> {\n     }\n }\n \n+pub type PolyFnOutput<'tcx> = Binder<FnOutput<'tcx>>;\n+\n+impl<'tcx> PolyFnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        self.0.diverges()\n+    }\n+}\n+\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n@@ -1077,6 +1089,21 @@ pub struct FnSig<'tcx> {\n \n pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n+impl<'tcx> PolyFnSig<'tcx> {\n+    pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+        ty::Binder(self.0.inputs.clone())\n+    }\n+    pub fn input(&self, index: uint) -> ty::Binder<Ty<'tcx>> {\n+        ty::Binder(self.0.inputs[index])\n+    }\n+    pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n+        ty::Binder(self.0.output.clone())\n+    }\n+    pub fn variadic(&self) -> bool {\n+        self.0.variadic\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n@@ -1699,8 +1726,7 @@ impl fmt::Show for RegionVid {\n \n impl<'tcx> fmt::Show for FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // grr, without tcx not much we can do.\n-        write!(f, \"(...)\")\n+        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs, self.variadic, self.output)\n     }\n }\n \n@@ -1710,8 +1736,8 @@ impl fmt::Show for InferTy {\n             TyVar(ref v) => v.fmt(f),\n             IntVar(ref v) => v.fmt(f),\n             FloatVar(ref v) => v.fmt(f),\n-            FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-            FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+            FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n         }\n     }\n }\n@@ -2006,8 +2032,8 @@ impl<'tcx> Predicate<'tcx> {\n ///     struct Foo<T,U:Bar<T>> { ... }\n ///\n /// Here, the `Generics` for `Foo` would contain a list of bounds like\n-/// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n-/// like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n+/// `[.index(&FullRange), [U:Bar<T>]]`.  Now if there were some particular reference\n+/// like `Foo<int,uint>`, then the `GenericBounds` would be `[.index(&FullRange),\n /// [uint:Bar<int>]]`.\n #[derive(Clone, Show)]\n pub struct GenericBounds<'tcx> {\n@@ -2184,7 +2210,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             _ => {\n                 cx.sess.bug(format!(\"ParameterEnvironment::from_item(): \\\n                                      `{}` is not an item\",\n-                                    cx.map.node_to_string(id))[])\n+                                    cx.map.node_to_string(id)).index(&FullRange))\n             }\n         }\n     }\n@@ -2269,7 +2295,7 @@ impl UnboxedClosureKind {\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(err[]),\n+            Err(err) => cx.sess.fatal(err.index(&FullRange)),\n         }\n     }\n }\n@@ -2302,12 +2328,12 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: intern_ty(arena, interner, ty_bool),\n             char: intern_ty(arena, interner, ty_char),\n             err: intern_ty(arena, interner, ty_err),\n-            int: intern_ty(arena, interner, ty_int(ast::TyI)),\n+            int: intern_ty(arena, interner, ty_int(ast::TyIs)),\n             i8: intern_ty(arena, interner, ty_int(ast::TyI8)),\n             i16: intern_ty(arena, interner, ty_int(ast::TyI16)),\n             i32: intern_ty(arena, interner, ty_int(ast::TyI32)),\n             i64: intern_ty(arena, interner, ty_int(ast::TyI64)),\n-            uint: intern_ty(arena, interner, ty_uint(ast::TyU)),\n+            uint: intern_ty(arena, interner, ty_uint(ast::TyUs)),\n             u8: intern_ty(arena, interner, ty_uint(ast::TyU8)),\n             u16: intern_ty(arena, interner, ty_uint(ast::TyU16)),\n             u32: intern_ty(arena, interner, ty_uint(ast::TyU32)),\n@@ -2471,7 +2497,7 @@ fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n         region_depth: flags.depth,\n     });\n \n-    debug!(\"Interned type: {} Pointer: {}\",\n+    debug!(\"Interned type: {:?} Pointer: {:?}\",\n            ty, ty as *const _);\n \n     interner.insert(InternedTy { ty: ty }, ty);\n@@ -2590,7 +2616,7 @@ impl FlagComputation {\n             }\n \n             &ty_tup(ref ts) => {\n-                self.add_tys(ts[]);\n+                self.add_tys(ts.index(&FullRange));\n             }\n \n             &ty_bare_fn(_, ref f) => {\n@@ -2613,7 +2639,7 @@ impl FlagComputation {\n     fn add_fn_sig(&mut self, fn_sig: &PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(fn_sig.0.inputs[]);\n+        computation.add_tys(fn_sig.0.inputs.index(&FullRange));\n \n         if let ty::FnConverging(output) = fn_sig.0.output {\n             computation.add_ty(output);\n@@ -2653,7 +2679,7 @@ impl FlagComputation {\n \n pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyI    => tcx.types.int,\n+        ast::TyIs   => tcx.types.int,\n         ast::TyI8   => tcx.types.i8,\n         ast::TyI16  => tcx.types.i16,\n         ast::TyI32  => tcx.types.i32,\n@@ -2663,7 +2689,7 @@ pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n \n pub fn mk_mach_uint<'tcx>(tcx: &ctxt<'tcx>, tm: ast::UintTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyU    => tcx.types.uint,\n+        ast::TyUs   => tcx.types.uint,\n         ast::TyU8   => tcx.types.u8,\n         ast::TyU16  => tcx.types.u16,\n         ast::TyU32  => tcx.types.u32,\n@@ -2782,7 +2808,7 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n \n fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n     bounds.len() == 0 ||\n-        bounds[1..].iter().enumerate().all(\n+        bounds.index(&(1..)).iter().enumerate().all(\n             |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n \n@@ -3037,7 +3063,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         ty_str => mk_mach_uint(cx, ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                 ty_to_string(cx, ty))[]),\n+                                 ty_to_string(cx, ty)).index(&FullRange)),\n     }\n }\n \n@@ -3324,7 +3350,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n         let result = match ty.sty {\n             // uint and int are ffi-unsafe\n-            ty_uint(ast::TyU) | ty_int(ast::TyI) => {\n+            ty_uint(ast::TyUs) | ty_int(ast::TyIs) => {\n                 TC::ReachesFfiUnsafe\n             }\n \n@@ -3371,7 +3397,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_struct(did, substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(flds[],\n+                    TypeContents::union(flds.index(&FullRange),\n                                         |f| tc_mt(cx, f.mt, cache));\n \n                 if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n@@ -3395,15 +3421,15 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(tys[],\n+                TypeContents::union(tys.index(&FullRange),\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(variants[], |variant| {\n-                        TypeContents::union(variant.args[],\n+                    TypeContents::union(variants.index(&FullRange), |variant| {\n+                        TypeContents::union(variant.args.index(&FullRange),\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n@@ -3533,7 +3559,7 @@ fn type_impls_bound<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n         match cache.borrow().get(&ty) {\n             None => {}\n             Some(&result) => {\n-                debug!(\"type_impls_bound({}, {}) = {} (cached)\",\n+                debug!(\"type_impls_bound({}, {:?}) = {:?} (cached)\",\n                        ty.repr(param_env.tcx),\n                        bound,\n                        result);\n@@ -3546,7 +3572,7 @@ fn type_impls_bound<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n \n     let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound, span);\n \n-    debug!(\"type_impls_bound({}, {}) = {}\",\n+    debug!(\"type_impls_bound({}, {:?}) = {:?}\",\n            ty.repr(param_env.tcx),\n            bound,\n            is_impld);\n@@ -3585,13 +3611,13 @@ pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n     fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                            r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n-        debug!(\"type_requires({}, {})?\",\n+        debug!(\"type_requires({:?}, {:?})?\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n \n         let r = r_ty == ty || subtypes_require(cx, seen, r_ty, ty);\n \n-        debug!(\"type_requires({}, {})? {}\",\n+        debug!(\"type_requires({:?}, {:?})? {:?}\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty),\n                r);\n@@ -3600,7 +3626,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n \n     fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                               r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n-        debug!(\"subtypes_require({}, {})?\",\n+        debug!(\"subtypes_require({:?}, {:?})?\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n \n@@ -3655,7 +3681,8 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_unboxed_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // inference by-products or unboxed closure types\n-                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\", ty)[])\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n+                                    ty).as_slice())\n             }\n \n             ty_tup(ref ts) => {\n@@ -3680,7 +3707,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             }\n         };\n \n-        debug!(\"subtypes_require({}, {})? {}\",\n+        debug!(\"subtypes_require({:?}, {:?})? {:?}\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty),\n                r);\n@@ -3748,7 +3775,8 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n             ty_unboxed_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // unboxed closure types\n-                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\", ty)[])\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n+                                    ty).as_slice())\n             }\n             _ => Representable,\n         }\n@@ -3789,7 +3817,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n     fn is_type_structurally_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n                                             seen: &mut Vec<Ty<'tcx>>,\n                                             ty: Ty<'tcx>) -> Representability {\n-        debug!(\"is_type_structurally_recursive: {}\",\n+        debug!(\"is_type_structurally_recursive: {:?}\",\n                ::util::ppaux::ty_to_string(cx, ty));\n \n         match ty.sty {\n@@ -3809,7 +3837,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                     match iter.next() {\n                         Some(&seen_type) => {\n                             if same_struct_or_enum_def_id(seen_type, did) {\n-                                debug!(\"SelfRecursive: {} contains {}\",\n+                                debug!(\"SelfRecursive: {:?} contains {:?}\",\n                                        ::util::ppaux::ty_to_string(cx, seen_type),\n                                        ::util::ppaux::ty_to_string(cx, ty));\n                                 return SelfRecursive;\n@@ -3829,7 +3857,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n                     for &seen_type in iter {\n                         if same_type(ty, seen_type) {\n-                            debug!(\"ContainsRecursive: {} contains {}\",\n+                            debug!(\"ContainsRecursive: {:?} contains {:?}\",\n                                    ::util::ppaux::ty_to_string(cx, seen_type),\n                                    ::util::ppaux::ty_to_string(cx, ty));\n                             return ContainsRecursive;\n@@ -3851,15 +3879,15 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n         }\n     }\n \n-    debug!(\"is_type_representable: {}\",\n+    debug!(\"is_type_representable: {:?}\",\n            ::util::ppaux::ty_to_string(cx, ty));\n \n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n     let mut seen: Vec<Ty> = Vec::new();\n     let r = is_type_structurally_recursive(cx, sp, &mut seen, ty);\n-    debug!(\"is_type_representable: {} is {}\",\n+    debug!(\"is_type_representable: {:?} is {:?}\",\n            ::util::ppaux::ty_to_string(cx, ty), r);\n     r\n }\n@@ -3896,7 +3924,7 @@ pub fn type_is_fresh(ty: Ty) -> bool {\n \n pub fn type_is_uint(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_infer(IntVar(_)) | ty_uint(ast::TyU) => true,\n+      ty_infer(IntVar(_)) | ty_uint(ast::TyUs) => true,\n       _ => false\n     }\n }\n@@ -3942,7 +3970,7 @@ pub fn type_is_signed(ty: Ty) -> bool {\n \n pub fn type_is_machine(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_int(ast::TyI) | ty_uint(ast::TyU) => false,\n+        ty_int(ast::TyIs) | ty_uint(ast::TyUs) => false,\n         ty_int(..) | ty_uint(..) | ty_float(..) => true,\n         _ => false\n     }\n@@ -3986,7 +4014,7 @@ pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty))[])\n+                                 ty_to_string(cx, ty)).index(&FullRange))\n     }\n }\n \n@@ -4087,7 +4115,7 @@ pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n             format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                    cx.map.node_to_string(id))[])\n+                    cx.map.node_to_string(id)).index(&FullRange))\n     }\n }\n \n@@ -4100,7 +4128,7 @@ pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n-                   cx.map.node_to_string(id))[])\n+                   cx.map.node_to_string(id)).index(&FullRange))\n     }\n }\n \n@@ -4122,7 +4150,7 @@ pub fn fn_is_variadic(fty: Ty) -> bool {\n     match fty.sty {\n         ty_bare_fn(_, ref f) => f.sig.0.variadic,\n         ref s => {\n-            panic!(\"fn_is_variadic() called on non-fn type: {}\", s)\n+            panic!(\"fn_is_variadic() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -4131,7 +4159,7 @@ pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n     match fty.sty {\n         ty_bare_fn(_, ref f) => &f.sig,\n         ref s => {\n-            panic!(\"ty_fn_sig() called on non-fn type: {}\", s)\n+            panic!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -4145,8 +4173,8 @@ pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n }\n \n // Type accessors for substructures of types\n-pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> &'tcx [Ty<'tcx>] {\n-    ty_fn_sig(fty).0.inputs.as_slice()\n+pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> ty::Binder<Vec<Ty<'tcx>>> {\n+    ty_fn_sig(fty).inputs()\n }\n \n pub fn ty_closure_store(fty: Ty) -> TraitStore {\n@@ -4157,16 +4185,16 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n             UniqTraitStore\n         }\n         ref s => {\n-            panic!(\"ty_closure_store() called on non-closure type: {}\", s)\n+            panic!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n         }\n     }\n }\n \n-pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n+pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> Binder<FnOutput<'tcx>> {\n     match fty.sty {\n-        ty_bare_fn(_, ref f) => f.sig.0.output,\n+        ty_bare_fn(_, ref f) => f.sig.output(),\n         ref s => {\n-            panic!(\"ty_fn_ret() called on non-fn type: {}\", s)\n+            panic!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -4186,8 +4214,8 @@ pub fn ty_region(tcx: &ctxt,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n-                format!(\"ty_region() invoked on an inappropriate ty: {}\",\n-                        s)[]);\n+                format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n+                        s).index(&FullRange));\n         }\n     }\n }\n@@ -4246,13 +4274,13 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n             e.span\n         }\n         Some(f) => {\n-            cx.sess.bug(format!(\"Node id {} is not an expr: {}\",\n+            cx.sess.bug(format!(\"Node id {} is not an expr: {:?}\",\n                                 id,\n-                                f)[]);\n+                                f).index(&FullRange));\n         }\n         None => {\n             cx.sess.bug(format!(\"Node id {} is not present \\\n-                                in the node map\", id)[]);\n+                                in the node map\", id).index(&FullRange));\n         }\n     }\n }\n@@ -4266,16 +4294,16 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                 }\n                 _ => {\n                     cx.sess.bug(\n-                        format!(\"Variable id {} maps to {}, not local\",\n+                        format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                pat)[]);\n+                                pat).index(&FullRange));\n                 }\n             }\n         }\n         r => {\n-            cx.sess.bug(format!(\"Variable id {} maps to {}, not local\",\n+            cx.sess.bug(format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                r)[]);\n+                                r).index(&FullRange));\n         }\n     }\n }\n@@ -4297,16 +4325,16 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n     return match adjustment {\n         Some(adjustment) => {\n             match *adjustment {\n-                AdjustReifyFnPointer(_) => {\n+               AdjustReifyFnPointer(_) => {\n                     match unadjusted_ty.sty {\n                         ty::ty_bare_fn(Some(_), b) => {\n                             ty::mk_bare_fn(cx, None, b)\n                         }\n                         ref b => {\n                             cx.sess.bug(\n                                 format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n-                                         {}\",\n-                                        b)[]);\n+                                         {:?}\",\n+                                        b).index(&FullRange));\n                         }\n                     }\n                 }\n@@ -4319,9 +4347,12 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             let method_call = MethodCall::autoderef(expr_id, i);\n                             match method_type(method_call) {\n                                 Some(method_ty) => {\n-                                    if let ty::FnConverging(result_type) = ty_fn_ret(method_ty) {\n-                                        adjusted_ty = result_type;\n-                                    }\n+                                    // overloaded deref operators have all late-bound\n+                                    // regions fully instantiated and coverge\n+                                    let fn_ret =\n+                                        ty::assert_no_late_bound_regions(cx,\n+                                                                         &ty_fn_ret(method_ty));\n+                                    adjusted_ty = fn_ret.unwrap();\n                                 }\n                                 None => {}\n                             }\n@@ -4334,7 +4365,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                                 {}\",\n                                                 i,\n                                                 ty_to_string(cx, adjusted_ty))\n-                                                          []);\n+                                                          .index(&FullRange));\n                                 }\n                             }\n                         }\n@@ -4396,8 +4427,8 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                 mk_vec(cx, ty, None)\n             }\n             _ => cx.sess.span_bug(span,\n-                                  format!(\"UnsizeLength with bad sty: {}\",\n-                                          ty_to_string(cx, ty))[])\n+                                  format!(\"UnsizeLength with bad sty: {:?}\",\n+                                          ty_to_string(cx, ty)).index(&FullRange))\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n             ty_struct(did, substs) => {\n@@ -4408,8 +4439,8 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                 mk_struct(cx, did, cx.mk_substs(unsized_substs))\n             }\n             _ => cx.sess.span_bug(span,\n-                                  format!(\"UnsizeStruct with bad sty: {}\",\n-                                          ty_to_string(cx, ty))[])\n+                                  format!(\"UnsizeStruct with bad sty: {:?}\",\n+                                          ty_to_string(cx, ty)).index(&FullRange))\n         },\n         &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n             mk_trait(cx, principal.clone(), bounds.clone())\n@@ -4422,7 +4453,7 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n-                \"no def-map entry for expr {}\", expr.id)[]);\n+                \"no def-map entry for expr {}\", expr.id).index(&FullRange));\n         }\n     }\n }\n@@ -4515,9 +4546,9 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def => {\n                     tcx.sess.span_bug(\n                         expr.span,\n-                        format!(\"uncategorized def for expr {}: {}\",\n+                        format!(\"uncategorized def for expr {}: {:?}\",\n                                 expr.id,\n-                                def)[]);\n+                                def).index(&FullRange));\n                 }\n             }\n         }\n@@ -4638,11 +4669,11 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n     let mut i = 0u;\n     for f in fields.iter() { if f.name == name { return i; } i += 1u; }\n     tcx.sess.bug(format!(\n-        \"no field named `{}` found in the list of fields `{}`\",\n+        \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_name(f.name).get().to_string())\n-              .collect::<Vec<String>>())[]);\n+              .collect::<Vec<String>>()).index(&FullRange));\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n@@ -4715,18 +4746,18 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n         terr_mismatch => \"types differ\".to_string(),\n         terr_unsafety_mismatch(values) => {\n             format!(\"expected {} fn, found {} fn\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+                    values.expected,\n+                    values.found)\n         }\n         terr_abi_mismatch(values) => {\n             format!(\"expected {} fn, found {} fn\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+                    values.expected,\n+                    values.found)\n         }\n         terr_onceness_mismatch(values) => {\n             format!(\"expected {} fn, found {} fn\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+                    values.expected,\n+                    values.found)\n         }\n         terr_sigil_mismatch(values) => {\n             format!(\"expected {}, found {}\",\n@@ -4818,14 +4849,14 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n             \"expected an integral type, found `char`\".to_string()\n         }\n         terr_int_mismatch(ref values) => {\n-            format!(\"expected `{}`, found `{}`\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+            format!(\"expected `{:?}`, found `{:?}`\",\n+                    values.expected,\n+                    values.found)\n         }\n         terr_float_mismatch(ref values) => {\n-            format!(\"expected `{}`, found `{}`\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+            format!(\"expected `{:?}`, found `{:?}`\",\n+                    values.expected,\n+                    values.found)\n         }\n         terr_variadic_mismatch(ref values) => {\n             format!(\"expected {} fn, found {} function\",\n@@ -4897,7 +4928,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n                         let (_, p) =\n-                            ast_util::split_trait_methods(ms[]);\n+                            ast_util::split_trait_methods(ms.index(&FullRange));\n                         p.iter()\n                          .map(|m| {\n                             match impl_or_trait_item(\n@@ -4914,16 +4945,16 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                          }).collect()\n                     }\n                     _ => {\n-                        cx.sess.bug(format!(\"provided_trait_methods: `{}` is \\\n+                        cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is \\\n                                              not a trait\",\n-                                            id)[])\n+                                            id).index(&FullRange))\n                     }\n                 }\n             }\n             _ => {\n-                cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a \\\n+                cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is not a \\\n                                      trait\",\n-                                    id)[])\n+                                    id).index(&FullRange))\n             }\n         }\n     } else {\n@@ -4950,7 +4981,7 @@ fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n     }\n \n     if def_id.krate == ast::LOCAL_CRATE {\n-        panic!(\"No def'n found for {} in tcx.{}\", def_id, descr);\n+        panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n     map.insert(def_id, v.clone());\n@@ -5057,7 +5088,7 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                             -> Option<Rc<TraitRef<'tcx>>> {\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n-            debug!(\"(impl_trait_ref) searching for trait impl {}\", id);\n+            debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n             match cx.map.find(id.node) {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n@@ -5143,7 +5174,9 @@ impl<'tcx> VariantInfo<'tcx> {\n         match ast_variant.node.kind {\n             ast::TupleVariantKind(ref args) => {\n                 let arg_tys = if args.len() > 0 {\n-                    ty_fn_args(ctor_ty).iter().map(|a| *a).collect()\n+                    // the regions in the argument types come from the\n+                    // enum def'n, and hence will all be early bound\n+                    ty::assert_no_late_bound_regions(cx, &ty_fn_args(ctor_ty))\n                 } else {\n                     Vec::new()\n                 };\n@@ -5159,8 +5192,7 @@ impl<'tcx> VariantInfo<'tcx> {\n                 };\n             },\n             ast::StructVariantKind(ref struct_def) => {\n-\n-                let fields: &[StructField] = struct_def.fields[];\n+                let fields: &[StructField] = struct_def.fields.index(&FullRange);\n \n                 assert!(fields.len() > 0);\n \n@@ -5311,7 +5343,7 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                 cx.sess\n                                                   .span_err(e.span,\n                                                             format!(\"expected constant: {}\",\n-                                                                    *err)[]);\n+                                                                    *err).index(&FullRange));\n                                             }\n                                         },\n                                     None => {}\n@@ -5377,7 +5409,7 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n {\n     let trait_def = lookup_trait_def(tcx, trait_ref.def_id());\n \n-    debug!(\"bounds_for_trait_ref(trait_def={}, trait_ref={})\",\n+    debug!(\"bounds_for_trait_ref(trait_def={:?}, trait_ref={:?})\",\n            trait_def.repr(tcx), trait_ref.repr(tcx));\n \n     // The interaction between HRTB and supertraits is not entirely\n@@ -5584,7 +5616,7 @@ pub fn lookup_field_type<'tcx>(tcx: &ctxt<'tcx>,\n         node_id_to_type(tcx, id.node)\n     } else {\n         let mut tcache = tcx.tcache.borrow_mut();\n-        let pty = tcache.entry(&id).get().unwrap_or_else(\n+        let pty = tcache.entry(id).get().unwrap_or_else(\n             |vacant_entry| vacant_entry.insert(csearch::get_field_type(tcx, struct_id, id)));\n         pty.ty\n     };\n@@ -5601,7 +5633,7 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n             _ => {\n                 cx.sess.bug(\n                     format!(\"ID not mapped to struct fields: {}\",\n-                            cx.map.node_to_string(did.node))[]);\n+                            cx.map.node_to_string(did.node)).index(&FullRange));\n             }\n         }\n     } else {\n@@ -5634,7 +5666,7 @@ pub fn struct_fields<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &Substs<'tc\n pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n-            name: token::intern(i.to_string()[]),\n+            name: token::intern(i.to_string().index(&FullRange)),\n             mt: mt {\n                 ty: f,\n                 mutbl: MutImmutable\n@@ -5791,40 +5823,6 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n     return tbl[tycat(cx, ty) as uint ][opcat(op) as uint];\n }\n \n-/// Returns an equivalent type with all the typedefs and self regions removed.\n-pub fn normalize_ty<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    let u = TypeNormalizer(cx).fold_ty(ty);\n-    return u;\n-\n-    struct TypeNormalizer<'a, 'tcx: 'a>(&'a ctxt<'tcx>);\n-\n-    impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n-        fn tcx(&self) -> &ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n-                None => {}\n-                Some(u) => return u\n-            }\n-\n-            let t_norm = ty_fold::super_fold_ty(self, ty);\n-            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n-            return t_norm;\n-        }\n-\n-        fn fold_region(&mut self, _: ty::Region) -> ty::Region {\n-            ty::ReStatic\n-        }\n-\n-        fn fold_substs(&mut self,\n-                       substs: &subst::Substs<'tcx>)\n-                       -> subst::Substs<'tcx> {\n-            subst::Substs { regions: subst::ErasedRegions,\n-                            types: substs.types.fold_with(self) }\n-        }\n-    }\n-}\n-\n // Returns the repeat count for a repeating vector expression.\n pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n     match const_eval::eval_const_expr_partial(tcx, count_expr) {\n@@ -5845,7 +5843,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n             };\n             tcx.sess.span_err(count_expr.span, format!(\n                 \"expected positive integer for repeat count, found {}\",\n-                found)[]);\n+                found).index(&FullRange));\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5860,7 +5858,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n             };\n             tcx.sess.span_err(count_expr.span, format!(\n                 \"expected constant integer for repeat count, found {}\",\n-                found)[]);\n+                found).index(&FullRange));\n         }\n     }\n     0\n@@ -5929,7 +5927,7 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n                                     predicates: Vec<ty::Predicate<'tcx>>)\n                                     -> Vec<ty::Region>\n {\n-    debug!(\"required_region_bounds(erased_self_ty={}, predicates={})\",\n+    debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n            erased_self_ty.repr(tcx),\n            predicates.repr(tcx));\n \n@@ -6007,7 +6005,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         return\n     }\n \n-    debug!(\"populate_implementations_for_type_if_necessary: searching for {}\", type_id);\n+    debug!(\"populate_implementations_for_type_if_necessary: searching for {:?}\", type_id);\n \n     let mut inherent_impls = Vec::new();\n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n@@ -6204,7 +6202,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n             mt.mutbl.hash(state);\n         };\n         let fn_sig = |&: state: &mut sip::SipState, sig: &Binder<FnSig<'tcx>>| {\n-            let sig = anonymize_late_bound_regions(tcx, sig);\n+            let sig = anonymize_late_bound_regions(tcx, sig).0;\n             for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {\n                 helper(tcx, output, svh, state);\n@@ -6265,7 +6263,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     did(state, data.principal_def_id());\n                     hash!(data.bounds);\n \n-                    let principal = anonymize_late_bound_regions(tcx, &data.principal);\n+                    let principal = anonymize_late_bound_regions(tcx, &data.principal).0;\n                     for subty in principal.substs.types.iter() {\n                         helper(tcx, *subty, svh, state);\n                     }\n@@ -6368,7 +6366,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n \n     record_region_bounds(tcx, &bounds);\n \n-    debug!(\"construct_parameter_environment: free_id={} free_subst={} bounds={}\",\n+    debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} bounds={:?}\",\n            free_id,\n            free_substs.repr(tcx),\n            bounds.repr(tcx));\n@@ -6394,15 +6392,15 @@ pub fn construct_parameter_environment<'a,'tcx>(\n                                   types: &mut VecPerParamSpace<Ty<'tcx>>,\n                                   defs: &[TypeParameterDef<'tcx>]) {\n         for def in defs.iter() {\n-            debug!(\"construct_parameter_environment(): push_types_from_defs: def={}\",\n+            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n                    def.repr(tcx));\n             let ty = ty::mk_param_from_def(tcx, def);\n             types.push(def.space, ty);\n-        }\n+       }\n     }\n \n     fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, bounds: &GenericBounds<'tcx>) {\n-        debug!(\"record_region_bounds(bounds={})\", bounds.repr(tcx));\n+        debug!(\"record_region_bounds(bounds={:?})\", bounds.repr(tcx));\n \n         for predicate in bounds.predicates.iter() {\n             match *predicate {\n@@ -6644,7 +6642,7 @@ pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n {\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n-        Some(d) => f(d[])\n+        Some(d) => f(d.index(&FullRange))\n     }\n }\n \n@@ -6696,6 +6694,16 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     count_late_bound_regions(tcx, value) > 0\n }\n \n+pub fn assert_no_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    value: &Binder<T>)\n+    -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n+{\n+    assert!(!binds_late_bound_regions(tcx, value));\n+    value.0.clone()\n+}\n+\n /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n /// method lookup and a few other places where precise region relationships are not required.\n pub fn erase_late_bound_regions<'tcx, T>(\n@@ -6718,14 +6726,14 @@ pub fn erase_late_bound_regions<'tcx, T>(\n pub fn anonymize_late_bound_regions<'tcx, T>(\n     tcx: &ctxt<'tcx>,\n     sig: &Binder<T>)\n-    -> T\n+    -> Binder<T>\n     where T : TypeFoldable<'tcx> + Repr<'tcx>,\n {\n     let mut counter = 0;\n-    replace_late_bound_regions(tcx, sig, |_, db| {\n+    ty::Binder(replace_late_bound_regions(tcx, sig, |_, db| {\n         counter += 1;\n         ReLateBound(db, BrAnon(counter))\n-    }).0\n+    }).0)\n }\n \n /// Replaces the late-bound-regions in `value` that are bound by `value`.\n@@ -6747,7 +6755,7 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n         debug!(\"region={}\", region.repr(tcx));\n         match region {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n-                * map.entry(&br).get().unwrap_or_else(\n+                * map.entry(br).get().unwrap_or_else(\n                       |vacant_entry| vacant_entry.insert(mapf(br, debruijn)))\n             }\n             _ => {\n@@ -6756,7 +6764,7 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n         }\n     });\n \n-    debug!(\"resulting map: {} value: {}\", map, value.repr(tcx));\n+    debug!(\"resulting map: {:?} value: {:?}\", map, value.repr(tcx));\n     (value, map)\n }\n \n@@ -6804,7 +6812,7 @@ impl<'tcx> Repr<'tcx> for AutoRef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n             AutoPtr(a, b, ref c) => {\n-                format!(\"AutoPtr({},{},{})\", a.repr(tcx), b, c.repr(tcx))\n+                format!(\"AutoPtr({},{:?},{})\", a.repr(tcx), b, c.repr(tcx))\n             }\n             AutoUnsize(ref a) => {\n                 format!(\"AutoUnsize({})\", a.repr(tcx))\n@@ -6813,7 +6821,7 @@ impl<'tcx> Repr<'tcx> for AutoRef<'tcx> {\n                 format!(\"AutoUnsizeUniq({})\", a.repr(tcx))\n             }\n             AutoUnsafe(ref a, ref b) => {\n-                format!(\"AutoUnsafe({},{})\", a, b.repr(tcx))\n+                format!(\"AutoUnsafe({:?},{})\", a, b.repr(tcx))\n             }\n         }\n     }\n@@ -6843,19 +6851,19 @@ impl<'tcx> Repr<'tcx> for vtable_origin<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n-                format!(\"vtable_static({}:{}, {}, {})\",\n+                format!(\"vtable_static({:?}:{}, {}, {})\",\n                         def_id,\n                         ty::item_path_str(tcx, def_id),\n                         tys.repr(tcx),\n                         vtable_res.repr(tcx))\n             }\n \n             vtable_param(x, y) => {\n-                format!(\"vtable_param({}, {})\", x, y)\n+                format!(\"vtable_param({:?}, {})\", x, y)\n             }\n \n             vtable_unboxed_closure(def_id) => {\n-                format!(\"vtable_unboxed_closure({})\", def_id)\n+                format!(\"vtable_unboxed_closure({:?})\", def_id)\n             }\n \n             vtable_error => {\n@@ -7286,7 +7294,7 @@ impl ReferencesError for Region\n \n impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ClosureTy({},{},{},{},{},{})\",\n+        format!(\"ClosureTy({},{},{:?},{},{},{})\",\n                 self.unsafety,\n                 self.onceness,\n                 self.store,"}, {"sha": "dadbae9349fc352621b4dbedede72a3f623f96ba", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n             _ => {\n                 debug!(\"RegionFolder.fold_region({}) folding free region (current_depth={})\",\n                        r.repr(self.tcx()), self.current_depth);\n-                self.fld_r.call_mut((r, self.current_depth))\n+                (self.fld_r)(r, self.current_depth)\n             }\n         }\n     }\n@@ -868,6 +868,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        // because whether or not a region is bound affects subtyping,\n+        // we can't erase the bound/free distinction, but we can\n+        // replace all free regions with 'static\n         match r {\n             ty::ReLateBound(..) | ty::ReEarlyBound(..) => r,\n             _ => ty::ReStatic"}, {"sha": "28975c7341659cb9692f5891be91655e3fa331cb", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -95,15 +95,15 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n     type Item = Ty<'tcx>;\n \n     fn next(&mut self) -> Option<Ty<'tcx>> {\n-        debug!(\"next(): stack={}\", self.stack);\n+        debug!(\"next(): stack={:?}\", self.stack);\n         match self.stack.pop() {\n             None => {\n                 return None;\n             }\n             Some(ty) => {\n                 self.last_subtree = self.stack.len();\n                 self.push_subtypes(ty);\n-                debug!(\"next: stack={}\", self.stack);\n+                debug!(\"next: stack={:?}\", self.stack);\n                 Some(ty)\n             }\n         }"}, {"sha": "a38298d52dd877a86625433ab9aa585aa857b45b", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -223,17 +223,17 @@ impl<'a> PluginLoader<'a> {\n             // this is fatal: there are almost certainly macros we need\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n-            Err(err) => self.sess.span_fatal(vi.span, err[])\n+            Err(err) => self.sess.span_fatal(vi.span, err.index(&FullRange))\n         };\n \n         unsafe {\n             let registrar =\n-                match lib.symbol(symbol[]) {\n+                match lib.symbol(symbol.index(&FullRange)) {\n                     Ok(registrar) => {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n-                    Err(err) => self.sess.span_fatal(vi.span, err[])\n+                    Err(err) => self.sess.span_fatal(vi.span, err.index(&FullRange))\n                 };\n \n             // Intentionally leak the dynamic library. We can't ever unload it"}, {"sha": "4968066f7b696b01ba5807cb4902746e3189dd95", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -330,7 +330,7 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"parse-only\", \"Parse only; do not compile, assemble, or link\", PARSE_ONLY),\n      (\"no-trans\", \"Run all passes except translation; no output\", NO_TRANS),\n      (\"no-analysis\", \"Parse and expand the source, but run no analysis and\",\n-      NO_TRANS),\n+      NO_ANALYSIS),\n      (\"unstable-options\", \"Adds unstable command line options to rustc interface\",\n       UNSTABLE_OPTIONS),\n      (\"print-enum-sizes\", \"Print the size of enums and their variants\", PRINT_ENUM_SIZES),\n@@ -559,17 +559,17 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n                 match (value, opt_type_desc) {\n                     (Some(..), None) => {\n                         early_error(format!(\"codegen option `{}` takes no \\\n-                                             value\", key)[])\n+                                             value\", key).index(&FullRange))\n                     }\n                     (None, Some(type_desc)) => {\n                         early_error(format!(\"codegen option `{0}` requires \\\n                                              {1} (-C {0}=<value>)\",\n-                                            key, type_desc)[])\n+                                            key, type_desc).index(&FullRange))\n                     }\n                     (Some(value), Some(type_desc)) => {\n                         early_error(format!(\"incorrect value `{}` for codegen \\\n                                              option `{}` - {} was expected\",\n-                                             value, key, type_desc)[])\n+                                             value, key, type_desc).index(&FullRange))\n                     }\n                     (None, None) => unreachable!()\n                 }\n@@ -579,7 +579,7 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n         }\n         if !found {\n             early_error(format!(\"unknown codegen option: `{}`\",\n-                                key)[]);\n+                                key).index(&FullRange));\n         }\n     }\n     return cg;\n@@ -592,10 +592,10 @@ pub fn default_lib_output() -> CrateType {\n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     use syntax::parse::token::intern_and_get_ident as intern;\n \n-    let end = sess.target.target.target_endian[];\n-    let arch = sess.target.target.arch[];\n-    let wordsz = sess.target.target.target_word_size[];\n-    let os = sess.target.target.target_os[];\n+    let end = sess.target.target.target_endian.index(&FullRange);\n+    let arch = sess.target.target.arch.index(&FullRange);\n+    let wordsz = sess.target.target.target_word_size.index(&FullRange);\n+    let os = sess.target.target.target_os.index(&FullRange);\n \n     let fam = match sess.target.target.options.is_like_windows {\n         true  => InternedString::new(\"windows\"),\n@@ -631,23 +631,23 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n     let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.push_all(default_cfg[]);\n+    v.push_all(default_cfg.index(&FullRange));\n     v\n }\n \n pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n-    let target = match Target::search(opts.target_triple[]) {\n+    let target = match Target::search(opts.target_triple.index(&FullRange)) {\n         Ok(t) => t,\n         Err(e) => {\n-            sp.handler().fatal((format!(\"Error loading target specification: {}\", e))[]);\n+            sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).as_slice());\n     }\n     };\n \n-    let (int_type, uint_type) = match target.target_word_size[] {\n+    let (int_type, uint_type) = match target.target_word_size.index(&FullRange) {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n         w    => sp.handler().fatal((format!(\"target specification was invalid: unrecognized \\\n-                                            target-word-size {}\", w))[])\n+                                            target-word-size {}\", w)).index(&FullRange))\n     };\n \n     Config {\n@@ -845,7 +845,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(e[]));\n+        .unwrap_or_else(|e| early_error(e.index(&FullRange)));\n \n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n@@ -873,7 +873,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n         if this_bit == 0 {\n             early_error(format!(\"unknown debug flag: {}\",\n-                                *debug_flag)[])\n+                                *debug_flag).index(&FullRange))\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -918,7 +918,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     \"dep-info\" => OutputTypeDepInfo,\n                     _ => {\n                         early_error(format!(\"unknown emission type: `{}`\",\n-                                            part)[])\n+                                            part).index(&FullRange))\n                     }\n                 };\n                 output_types.push(output_type)\n@@ -957,7 +957,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 Some(arg) => {\n                     early_error(format!(\"optimization level needs to be \\\n                                          between 0-3 (instead was `{}`)\",\n-                                        arg)[]);\n+                                        arg).index(&FullRange));\n                 }\n             }\n         } else {\n@@ -995,7 +995,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             Some(arg) => {\n                 early_error(format!(\"debug info level needs to be between \\\n                                      0-2 (instead was `{}`)\",\n-                                    arg)[]);\n+                                    arg).index(&FullRange));\n             }\n         }\n     } else {\n@@ -1013,7 +1013,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut search_paths = SearchPaths::new();\n     for s in matches.opt_strs(\"L\").iter() {\n-        search_paths.add_path(s[]);\n+        search_paths.add_path(s.index(&FullRange));\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n@@ -1027,7 +1027,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 s => {\n                     early_error(format!(\"unknown library kind `{}`, expected \\\n                                          one of dylib, framework, or static\",\n-                                        s)[]);\n+                                        s).as_slice());\n                 }\n             };\n             return (name.to_string(), kind)\n@@ -1045,7 +1045,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             (_, s) => {\n                 early_error(format!(\"unknown library kind `{}`, expected \\\n                                      one of dylib, framework, or static\",\n-                                    s)[]);\n+                                    s).index(&FullRange));\n             }\n         };\n         (name.to_string(), kind)\n@@ -1089,7 +1089,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     --debuginfo\");\n     }\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| s[]) {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| s.index(&FullRange)) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,\n         Some(\"never\")  => Never,\n@@ -1099,7 +1099,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         Some(arg) => {\n             early_error(format!(\"argument for --color must be auto, always \\\n                                  or never (instead was `{}`)\",\n-                                arg)[])\n+                                arg).index(&FullRange))\n         }\n     };\n \n@@ -1115,7 +1115,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None => early_error(\"--extern value must be of the format `foo=bar`\"),\n         };\n \n-        match externs.entry(&name.to_string()) {\n+        match externs.entry(name.to_string()) {\n             Vacant(entry) => { entry.insert(vec![location.to_string()]); },\n             Occupied(mut entry) => { entry.get_mut().push(location.to_string()); },\n         }\n@@ -1201,15 +1201,15 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts(&[\"--test\".to_string()], optgroups()[]) {\n+            &match getopts(&[\"--test\".to_string()], optgroups().index(&FullRange)) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n-        assert!((attr::contains_name(cfg[], \"test\")));\n+        assert!((attr::contains_name(cfg.index(&FullRange), \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -1218,7 +1218,7 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n-                           optgroups()[]) {\n+                           optgroups().index(&FullRange)) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n@@ -1238,7 +1238,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n-            ], optgroups()[]).unwrap();\n+            ], optgroups().index(&FullRange)).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1249,7 +1249,7 @@ mod test {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n-            ], optgroups()[]).unwrap();\n+            ], optgroups().index(&FullRange)).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1259,7 +1259,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n-            ], optgroups()[]).unwrap();\n+            ], optgroups().index(&FullRange)).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);"}, {"sha": "94a6bca4e06e588a6fcd0a31ecea5144f51a99ce", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -174,7 +174,7 @@ impl Session {\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp,\n-                      format!(\"impossible case reached: {}\", msg)[]);\n+                      format!(\"impossible case reached: {}\", msg).index(&FullRange));\n     }\n     pub fn verbose(&self) -> bool { self.debugging_opt(config::VERBOSE) }\n     pub fn time_passes(&self) -> bool { self.debugging_opt(config::TIME_PASSES) }\n@@ -216,7 +216,7 @@ impl Session {\n     }\n     pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch {\n         filesearch::FileSearch::new(self.sysroot(),\n-                                    self.opts.target_triple[],\n+                                    self.opts.target_triple.index(&FullRange),\n                                     &self.opts.search_paths,\n                                     kind)\n     }"}, {"sha": "26f98e28a8d950473db969dcbd06af9aee27510e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -64,7 +64,7 @@ pub fn indent<R, F>(op: F) -> R where\n     // to make debug output more readable.\n     debug!(\">>\");\n     let r = op();\n-    debug!(\"<< (Result = {})\", r);\n+    debug!(\"<< (Result = {:?})\", r);\n     r\n }\n "}, {"sha": "8f5820d92c589772274043332863a7ddb27d7a66", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -48,7 +48,7 @@ fn test_lev_distance() {\n     for c in range(0u32, MAX as u32)\n              .filter_map(|i| from_u32(i))\n              .map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(c[], c[]), 0);\n+        assert_eq!(lev_distance(c.index(&FullRange), c.index(&FullRange)), 0);\n     }\n \n     let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";"}, {"sha": "2d433369366eb9f4d397c0ae851eb1f02eab29ea", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -55,12 +55,12 @@ pub fn note_and_explain_region(cx: &ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            format!(\"{}{}{}\", prefix, *str, suffix)[]);\n+            format!(\"{}{}{}\", prefix, *str, suffix).index(&FullRange));\n         Some(span)\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            format!(\"{}{}{}\", prefix, *str, suffix)[]);\n+            format!(\"{}{}{}\", prefix, *str, suffix).index(&FullRange));\n         None\n       }\n     }\n@@ -111,7 +111,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (format!(\"unknown scope: {}.  Please report a bug.\", scope), None)\n+            (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n           }\n         }\n       }\n@@ -140,7 +140,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           }\n           Some(_) | None => {\n               // this really should not happen\n-              (format!(\"{} unknown free region bounded by scope {}\", prefix, fr.scope), None)\n+              (format!(\"{} unknown free region bounded by scope {:?}\", prefix, fr.scope), None)\n           }\n         }\n       }\n@@ -156,7 +156,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n       ty::ReInfer(_) | ty::ReLateBound(..) => {\n-        (format!(\"lifetime {}\", region), None)\n+        (format!(\"lifetime {:?}\", region), None)\n       }\n     };\n \n@@ -271,7 +271,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(format!(\"extern {} \", abi.to_string())[]);\n+            s.push_str(format!(\"extern {} \", abi.to_string()).index(&FullRange));\n         };\n \n         s.push_str(\"fn\");\n@@ -290,7 +290,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             Some(def_id) => {\n                 s.push_str(\" {\");\n                 let path_str = ty::item_path_str(cx, def_id);\n-                s.push_str(path_str[]);\n+                s.push_str(path_str.index(&FullRange));\n                 s.push_str(\"}\");\n             }\n             None => { }\n@@ -305,7 +305,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         match cty.store {\n             ty::UniqTraitStore => {}\n             ty::RegionTraitStore(region, _) => {\n-                s.push_str(region_to_string(cx, \"\", true, region)[]);\n+                s.push_str(region_to_string(cx, \"\", true, region).index(&FullRange));\n             }\n         }\n \n@@ -324,15 +324,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n                 push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   bounds_str[]);\n+                                   bounds_str.index(&FullRange));\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n                 push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   bounds_str[]);\n+                                   bounds_str.index(&FullRange));\n             }\n         }\n \n@@ -365,7 +365,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n-                   s.push_str(ty_to_string(cx, t)[]);\n+                   s.push_str(ty_to_string(cx, t).index(&FullRange));\n                 }\n             }\n             ty::FnDiverging => {\n@@ -402,7 +402,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_rptr(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, *r);\n-            buf.push_str(mt_to_string(cx, tm)[]);\n+            buf.push_str(mt_to_string(cx, tm).index(&FullRange));\n             buf\n         }\n         ty_open(typ) =>\n@@ -412,7 +412,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 .iter()\n                 .map(|elem| ty_to_string(cx, *elem))\n                 .collect::<Vec<_>>();\n-            match strs[] {\n+            match strs.index(&FullRange) {\n                 [ref string] => format!(\"({},)\", string),\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n@@ -541,19 +541,19 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         0\n     };\n \n-    for t in tps[..tps.len() - num_defaults].iter() {\n+    for t in tps.index(&(0..(tps.len() - num_defaults))).iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n \n     if cx.lang_items.fn_trait_kind(did).is_some() {\n         format!(\"{}({}){}\",\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n-                    strs[0][1 .. strs[0].len() - 2] // Remove '(' and ',)'\n+                    strs[0].index(&(1 .. (strs[0].len() - 2))) // Remove '(' and ',)'\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n-                    strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n+                    strs[0].index(&(1 .. (strs[0].len() - 1))) // Remove '(' and ')'\n                 } else {\n-                    strs[0][]\n+                    strs[0].index(&FullRange)\n                 },\n                 if &*strs[1] == \"()\" { String::new() } else { format!(\" -> {}\", strs[1]) })\n     } else if strs.len() > 0 {\n@@ -566,7 +566,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n-        s = s[0u..32u].to_string();\n+        s = s.index(&(0u..32u)).to_string();\n     }\n     return s;\n }\n@@ -631,15 +631,15 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self[])\n+        repr_vec(tcx, self.index(&FullRange))\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self[])\n+        repr_vec(tcx, self.index(&FullRange))\n     }\n }\n \n@@ -653,13 +653,13 @@ impl<'tcx, T:UserString<'tcx>> UserString<'tcx> for Vec<T> {\n \n impl<'tcx> Repr<'tcx> for def::Def {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TypeParameterDef({}, {}, {}/{})\",\n+        format!(\"TypeParameterDef({:?}, {}, {:?}/{})\",\n                 self.def_id,\n                 self.bounds.repr(tcx),\n                 self.space,\n@@ -854,31 +854,31 @@ impl<'tcx> Repr<'tcx> for ty::Region {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             ty::ReEarlyBound(id, space, index, name) => {\n-                format!(\"ReEarlyBound({}, {}, {}, {})\",\n+                format!(\"ReEarlyBound({}, {:?}, {}, {})\",\n                                id,\n                                space,\n                                index,\n                                token::get_name(name))\n             }\n \n             ty::ReLateBound(binder_id, ref bound_region) => {\n-                format!(\"ReLateBound({}, {})\",\n+                format!(\"ReLateBound({:?}, {})\",\n                         binder_id,\n                         bound_region.repr(tcx))\n             }\n \n             ty::ReFree(ref fr) => fr.repr(tcx),\n \n             ty::ReScope(id) => {\n-                format!(\"ReScope({})\", id)\n+                format!(\"ReScope({:?})\", id)\n             }\n \n             ty::ReStatic => {\n                 \"ReStatic\".to_string()\n             }\n \n             ty::ReInfer(ReVar(ref vid)) => {\n-                format!(\"{}\", vid)\n+                format!(\"{:?}\", vid)\n             }\n \n             ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n@@ -920,14 +920,14 @@ impl<'tcx> Repr<'tcx> for ast::DefId {\n                 Some(ast_map::NodeVariant(..)) |\n                 Some(ast_map::NodeStructCtor(..)) => {\n                     return format!(\n-                                \"{}:{}\",\n+                                \"{:?}:{}\",\n                                 *self,\n                                 ty::item_path_str(tcx, *self))\n                 }\n                 _ => {}\n             }\n         }\n-        return format!(\"{}\", *self)\n+        return format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1007,13 +1007,13 @@ impl<'tcx> Repr<'tcx> for ast::Ident {\n \n impl<'tcx> Repr<'tcx> for ast::ExplicitSelf_ {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ast::Visibility {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1026,6 +1026,7 @@ impl<'tcx> Repr<'tcx> for ty::BareFnTy<'tcx> {\n     }\n }\n \n+\n impl<'tcx> Repr<'tcx> for ty::FnSig<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"fn{} -> {}\", self.inputs.repr(tcx), self.output.repr(tcx))\n@@ -1096,7 +1097,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitStore {\n \n impl<'tcx> Repr<'tcx> for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1251,13 +1252,13 @@ impl<'tcx> Repr<'tcx> for ty::UpvarId {\n \n impl<'tcx> Repr<'tcx> for ast::Mutability {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::BorrowKind {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1271,49 +1272,49 @@ impl<'tcx> Repr<'tcx> for ty::UpvarBorrow {\n \n impl<'tcx> Repr<'tcx> for ty::IntVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::FloatVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::RegionVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::TyVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::IntVarValue {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ast::IntTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ast::UintTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ast::FloatTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1332,7 +1333,7 @@ impl<'tcx> UserString<'tcx> for ParamTy {\n impl<'tcx> Repr<'tcx> for ParamTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n         let ident = self.user_string(tcx);\n-        format!(\"{}/{}.{}\", ident, self.space, self.idx)\n+        format!(\"{}/{:?}.{}\", ident, self.space, self.idx)\n     }\n }\n \n@@ -1349,6 +1350,7 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n     }\n }\n \n+#[old_impl_check]\n impl<'tcx, S, H, K, V> Repr<'tcx> for HashMap<K,V,H>\n     where K : Hash<S> + Eq + Repr<'tcx>,\n           V : Repr<'tcx>,"}, {"sha": "6040f55ceeba039b347cd8e372cfda8469e72ac5", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -116,7 +116,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n     pub fn actions_since_snapshot(&self,\n                                   snapshot: &Snapshot)\n                                   -> &[UndoLog<T,U>] {\n-        self.undo_log[snapshot.length..]\n+        self.undo_log.index(&(snapshot.length..))\n     }\n \n     fn assert_open_snapshot(&self, snapshot: &Snapshot) {"}, {"sha": "48004acaac0878825b6ec0e05ba2d1ad8ee01c1d", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -53,7 +53,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n     let ar = match *maybe_ar_prog {\n-        Some(ref ar) => ar[],\n+        Some(ref ar) => ar.index(&FullRange),\n         None => \"ar\"\n     };\n     let mut cmd = Command::new(ar);\n@@ -64,7 +64,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n     match cwd {\n         Some(p) => {\n             cmd.cwd(p);\n-            debug!(\"inside {}\", p.display());\n+            debug!(\"inside {:?}\", p.display());\n         }\n         None => {}\n     }\n@@ -75,22 +75,22 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n             if !o.status.success() {\n                 handler.err(format!(\"{} failed with: {}\",\n                                  cmd,\n-                                 o.status)[]);\n+                                 o.status).index(&FullRange));\n                 handler.note(format!(\"stdout ---\\n{}\",\n                                   str::from_utf8(o.output\n-                                                  []).unwrap())\n-                          []);\n+                                                  .index(&FullRange)).unwrap())\n+                          .index(&FullRange));\n                 handler.note(format!(\"stderr ---\\n{}\",\n                                   str::from_utf8(o.error\n-                                                  []).unwrap())\n-                          []);\n+                                                  .index(&FullRange)).unwrap())\n+                          .index(&FullRange));\n                 handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n-            handler.err(format!(\"could not exec `{}`: {}\", ar[],\n-                             e)[]);\n+            handler.err(format!(\"could not exec `{}`: {}\", ar.index(&FullRange),\n+                             e).index(&FullRange));\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -105,17 +105,17 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n     let unixlibname = format!(\"lib{}.a\", name);\n \n     for path in search_paths.iter() {\n-        debug!(\"looking for {} inside {}\", name, path.display());\n-        let test = path.join(oslibname[]);\n+        debug!(\"looking for {} inside {:?}\", name, path.display());\n+        let test = path.join(oslibname.index(&FullRange));\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n-            let test = path.join(unixlibname[]);\n+            let test = path.join(unixlibname.index(&FullRange));\n             if test.exists() { return test }\n         }\n     }\n     handler.fatal(format!(\"could not find native static library `{}`, \\\n                            perhaps an -L flag is missing?\",\n-                          name)[]);\n+                          name).index(&FullRange));\n }\n \n impl<'a> Archive<'a> {\n@@ -147,7 +147,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(output.output[]).unwrap();\n+        let output = str::from_utf8(output.output.index(&FullRange)).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_string()).collect()\n@@ -179,9 +179,9 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n         let location = find_library(name,\n-                                    self.archive.slib_prefix[],\n-                                    self.archive.slib_suffix[],\n-                                    self.archive.lib_search_paths[],\n+                                    self.archive.slib_prefix.index(&FullRange),\n+                                    self.archive.slib_suffix.index(&FullRange),\n+                                    self.archive.lib_search_paths.index(&FullRange),\n                                     self.archive.handler);\n         self.add_archive(&location, name, |_| false)\n     }\n@@ -197,12 +197,12 @@ impl<'a> ArchiveBuilder<'a> {\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n         let obj_start = format!(\"{}\", name);\n-        let obj_start = obj_start[];\n+        let obj_start = obj_start.index(&FullRange);\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n \n-        self.add_archive(rlib, name[], |fname: &str| {\n+        self.add_archive(rlib, name.index(&FullRange), |fname: &str| {\n             let skip_obj = lto && fname.starts_with(obj_start)\n                 && fname.ends_with(\".o\");\n             skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n@@ -239,7 +239,7 @@ impl<'a> ArchiveBuilder<'a> {\n             // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), args[]);\n+                       \"s\", Some(self.work_dir.path()), args.index(&FullRange));\n             }\n             return self.archive;\n         }\n@@ -259,7 +259,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 // Add the archive members seen so far, without updating the\n                 // symbol table (`S`).\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), args[]);\n+                       \"cruS\", Some(self.work_dir.path()), args.index(&FullRange));\n \n                 args.clear();\n                 args.push(&abs_dst);\n@@ -274,7 +274,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // necessary.\n         let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), args[]);\n+               flags, Some(self.work_dir.path()), args.index(&FullRange));\n \n         self.archive\n     }\n@@ -316,7 +316,7 @@ impl<'a> ArchiveBuilder<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = self.work_dir.path().join(filename[]);\n+            let new_filename = self.work_dir.path().join(filename.index(&FullRange));\n             try!(fs::rename(file, &new_filename));\n             self.members.push(Path::new(filename));\n         }"}, {"sha": "ca39477fbdcb2e9d700d5602f491d7a253108c13", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -28,22 +28,11 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![allow(unknown_features)]\n-#![feature(globs, phase, macro_rules, slicing_syntax)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n+#![feature(slicing_syntax)]\n \n extern crate syntax;\n extern crate serialize;\n+#[macro_use] extern crate log;\n \n pub mod abi;\n pub mod archive;"}, {"sha": "db1dfa6b6eed88fc689bacfac752eab6cebea636", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -44,15 +44,15 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(config, libs[]);\n-    flags.push_all(rpaths_to_flags(rpaths[])[]);\n+    let rpaths = get_rpaths(config, libs.index(&FullRange));\n+    flags.push_all(rpaths_to_flags(rpaths.index(&FullRange)).index(&FullRange));\n     flags\n }\n \n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n-        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath)[]));\n+        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).index(&FullRange)));\n     }\n     return ret;\n }\n@@ -61,10 +61,10 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n     F: FnOnce() -> Path,\n     G: FnMut(&Path) -> Result<Path, IoError>,\n {\n-    debug!(\"output: {}\", config.out_filename.display());\n+    debug!(\"output: {:?}\", config.out_filename.display());\n     debug!(\"libs:\");\n     for libpath in libs.iter() {\n-        debug!(\"    {}\", libpath.display());\n+        debug!(\"    {:?}\", libpath.display());\n     }\n \n     // Use relative paths to the libraries. Binaries can be moved\n@@ -82,14 +82,14 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n         }\n     }\n \n-    log_rpaths(\"relative\", rel_rpaths[]);\n-    log_rpaths(\"fallback\", fallback_rpaths[]);\n+    log_rpaths(\"relative\", rel_rpaths.index(&FullRange));\n+    log_rpaths(\"fallback\", fallback_rpaths.index(&FullRange));\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(fallback_rpaths[]);\n+    rpaths.push_all(fallback_rpaths.index(&FullRange));\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(rpaths[]);\n+    let rpaths = minimize_rpaths(rpaths.index(&FullRange));\n     return rpaths;\n }\n \n@@ -140,7 +140,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n-        if set.insert(rpath[]) {\n+        if set.insert(rpath.index(&FullRange)) {\n             minimized.push(rpath.clone());\n         }\n     }"}, {"sha": "f33971a6ac0c2f2e4ad6f0e310bf22eed39a186d", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -140,7 +140,7 @@ impl FixedBuffer for FixedBuffer64 {\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n                         self.buffer.slice_mut(self.buffer_idx, size),\n-                        input[..buffer_remaining]);\n+                        input.index(&(0..buffer_remaining)));\n                 self.buffer_idx = 0;\n                 func(&self.buffer);\n                 i += buffer_remaining;\n@@ -156,7 +156,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(input[i..i + size]);\n+            func(input.index(&(i..(i + size))));\n             i += size;\n         }\n \n@@ -166,7 +166,7 @@ impl FixedBuffer for FixedBuffer64 {\n         let input_remaining = input.len() - i;\n         copy_memory(\n             self.buffer.slice_to_mut(input_remaining),\n-            input[i..]);\n+            input.index(&(i..)));\n         self.buffer_idx += input_remaining;\n     }\n \n@@ -188,7 +188,7 @@ impl FixedBuffer for FixedBuffer64 {\n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return self.buffer[..64];\n+        return self.buffer.index(&(0..64));\n     }\n \n     fn position(&self) -> uint { self.buffer_idx }"}, {"sha": "863c1a7c865f3b5fbcac9f6b8f45a8b1e8a5b5e9", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -65,7 +65,7 @@ impl Svh {\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {\n-        self.hash[]\n+        self.hash.index(&FullRange)\n     }\n \n     pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n@@ -119,6 +119,14 @@ impl Svh {\n }\n \n impl fmt::Show for Svh {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        //NOTE(stage0): uncomment after snapshot\n+        //write!(f, \"Svh {{ {} }}\", self.as_str())\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for Svh {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(self.as_str())\n     }\n@@ -358,7 +366,7 @@ mod svh_visitor {\n             fn macro_name(mac: &Mac) -> token::InternedString {\n                 match &mac.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n-                        let s = path.segments[];\n+                        let s = path.segments.index(&FullRange);\n                         assert_eq!(s.len(), 1);\n                         content(s[0].identifier)\n                     }"}, {"sha": "23c8fc7de51b550391bbc7621c5c127c6ad40acd", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -225,7 +225,7 @@ impl Target {\n                 Some(val) => val,\n                 None =>\n                     handler.fatal((format!(\"Field {} in target specification is required\", name))\n-                                  [])\n+                                  .index(&FullRange))\n             }\n         };\n \n@@ -242,16 +242,18 @@ impl Target {\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name[]).map(|o| o.as_string()\n+                obj.find(name.index(&FullRange)).map(|o| o.as_string()\n                                     .map(|s| base.options.$key_name = s.to_string()));\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name[]).map(|o| o.as_boolean().map(|s| base.options.$key_name = s));\n+                obj.find(name.index(&FullRange))\n+                    .map(|o| o.as_boolean()\n+                         .map(|s| base.options.$key_name = s));\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name[]).map(|o| o.as_array()\n+                obj.find(name.index(&FullRange)).map(|o| o.as_array()\n                     .map(|v| base.options.$key_name = v.iter()\n                         .map(|a| a.as_string().unwrap().to_string()).collect()\n                         )\n@@ -299,8 +301,8 @@ impl Target {\n         use serialize::json;\n \n         fn load_file(path: &Path) -> Result<Target, String> {\n-            let mut f = try!(File::open(path).map_err(|e| e.to_string()));\n-            let obj = try!(json::from_reader(&mut f).map_err(|e| e.to_string()));\n+            let mut f = try!(File::open(path).map_err(|e| format!(\"{:?}\", e)));\n+            let obj = try!(json::from_reader(&mut f).map_err(|e| format!(\"{:?}\", e)));\n             Ok(Target::from_json(obj))\n         }\n \n@@ -313,7 +315,7 @@ impl Target {\n                     $(\n                         else if target == stringify!($name) {\n                             let t = $name::target();\n-                            debug!(\"Got builtin target: {}\", t);\n+                            debug!(\"Got builtin target: {:?}\", t);\n                             return Ok(t);\n                         }\n                     )*\n@@ -367,7 +369,7 @@ impl Target {\n \n         let target_path = os::getenv(\"RUST_TARGET_PATH\").unwrap_or(String::new());\n \n-        let paths = os::split_paths(target_path[]);\n+        let paths = os::split_paths(target_path.index(&FullRange));\n         // FIXME 16351: add a sane default search path?\n \n         for dir in paths.iter() {\n@@ -377,6 +379,6 @@ impl Target {\n             }\n         }\n \n-        Err(format!(\"Could not find specification for target {}\", target))\n+        Err(format!(\"Could not find specification for target {:?}\", target))\n     }\n }"}, {"sha": "d942581ca62f22b71a1ff72d4b1267b0a6eb10cb", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                consume_span: Span,\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n+        debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n                consume_id, cmt.repr(self.tcx()), mode);\n \n         self.consume_common(consume_id, consume_span, cmt, mode);\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n+        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n                consume_pat.repr(self.tcx()),\n                cmt.repr(self.tcx()),\n                mode);\n@@ -127,8 +127,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n-               bk={}, loan_cause={})\",\n+        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n+               bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt.repr(self.tcx()), loan_region,\n                bk, loan_cause);\n \n@@ -355,10 +355,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! (Note that some loans can be *issued* without necessarily\n         //! taking effect yet.)\n \n-        debug!(\"check_for_conflicting_loans(scope={})\", scope);\n+        debug!(\"check_for_conflicting_loans(scope={:?})\", scope);\n \n         let new_loan_indices = self.loans_generated_by(scope);\n-        debug!(\"new_loan_indices = {}\", new_loan_indices);\n+        debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n         self.each_issued_loan(scope, |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n@@ -465,23 +465,23 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                nl, new_loan_msg)[])\n+                                nl, new_loan_msg).index(&FullRange))\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg)[]);\n+                                nl, ol_pronoun, old_loan_msg).index(&FullRange));\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str())[]);\n+                                nl, new_loan_msg, new_loan.kind.to_user_str()).index(&FullRange));\n                 }\n \n                 (_, _) => {\n@@ -494,7 +494,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                 new_loan.kind.to_user_str(),\n                                 ol_pronoun,\n                                 old_loan.kind.to_user_str(),\n-                                old_loan_msg)[]);\n+                                old_loan_msg).index(&FullRange));\n                 }\n             }\n \n@@ -503,7 +503,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl)[]);\n+                                nl).index(&FullRange));\n                 }\n                 _ => { }\n             }\n@@ -552,7 +552,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             self.bccx.span_note(\n                 old_loan.span,\n-                format!(\"{}; {}\", borrow_summary, rule_summary)[]);\n+                format!(\"{}; {}\", borrow_summary, rule_summary).index(&FullRange));\n \n             let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n             self.bccx.span_end_note(old_loan_span,\n@@ -622,13 +622,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.bccx.span_err(\n                     span,\n                     format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            self.bccx.loan_path_to_string(copy_path)[])\n-                    []);\n+                            self.bccx.loan_path_to_string(copy_path).index(&FullRange))\n+                    .index(&FullRange));\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path)[])\n-                    []);\n+                            self.bccx.loan_path_to_string(&*loan_path).index(&FullRange))\n+                    .index(&FullRange));\n             }\n         }\n     }\n@@ -647,20 +647,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path)[]),\n+                                self.bccx.loan_path_to_string(move_path).index(&FullRange)),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path)[])\n+                                self.bccx.loan_path_to_string(move_path).index(&FullRange))\n                 };\n \n-                self.bccx.span_err(span, err_message[]);\n+                self.bccx.span_err(span, err_message.index(&FullRange));\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path)[])\n-                    []);\n+                            self.bccx.loan_path_to_string(&*loan_path).index(&FullRange))\n+                    .index(&FullRange));\n             }\n         }\n     }\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                               span: Span,\n                               use_kind: MovedValueUseKind,\n                               lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={}, use_kind={}, lp={})\",\n+        debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n         let base_lp = owned_ptr_base_path_rc(lp);\n         self.move_data.each_move_of(id, &base_lp, |the_move, moved_lp| {\n@@ -810,7 +810,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_err(\n                         assignment_span,\n                         format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n                     self.bccx.span_help(\n                         self.tcx().map.span(upvar_id.closure_expr_id),\n                         \"consider changing this closure to take self by mutable reference\");\n@@ -819,7 +819,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         assignment_span,\n                         format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n                 }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n@@ -829,14 +829,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         format!(\"cannot assign to {} {} `{}`\",\n                                 assignee_cmt.mutbl.to_user_str(),\n                                 self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp))[]);\n+                                self.bccx.loan_path_to_string(&*lp)).index(&FullRange));\n                 }\n                 None => {\n                     self.bccx.span_err(\n                         assignment_span,\n                         format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n                 }\n             }\n         }\n@@ -956,10 +956,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         self.bccx.span_err(\n             span,\n             format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path))[]);\n+                    self.bccx.loan_path_to_string(loan_path)).index(&FullRange));\n         self.bccx.span_note(\n             loan.span,\n             format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_string(loan_path))[]);\n+                    self.bccx.loan_path_to_string(loan_path)).index(&FullRange));\n     }\n }"}, {"sha": "2100d5a9bc307cec26d3283c165b59b68b626291", "filename": "src/librustc_borrowck/borrowck/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -660,7 +660,7 @@\n //! necessary to add any restrictions at all to the final result.\n //!\n //! ```text\n-//!     RESTRICTIONS(*LV, LT, []) = []                         // R-Deref-Freeze-Borrowed\n+//!     RESTRICTIONS(*LV, LT, []) = []                // R-Deref-Freeze-Borrowed\n //!       TYPE(LV) = &const Ty\n //! ```\n //!"}, {"sha": "d7527487465895db0aea649a865ba5f807cea5f4", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -38,7 +38,7 @@ enum Fragment {\n     // This represents the collection of all but one of the elements\n     // from an array at the path described by the move path index.\n     // Note that attached MovePathIndex should have mem_categorization\n-    // of InteriorElement (i.e. array dereference `[]`).\n+    // of InteriorElement (i.e. array dereference `.index(&FullRange)`).\n     AllButOneFrom(MovePathIndex),\n }\n \n@@ -123,12 +123,12 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         let attrs : &[ast::Attribute];\n         attrs = match tcx.map.find(id) {\n             Some(ast_map::NodeItem(ref item)) =>\n-                item.attrs[],\n+                item.attrs.index(&FullRange),\n             Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                m.attrs[],\n+                m.attrs.index(&FullRange),\n             Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                m.attrs[],\n-            _ => [][],\n+                m.attrs.index(&FullRange),\n+            _ => [].index(&FullRange),\n         };\n \n         let span_err =\n@@ -144,7 +144,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, mpi) in vec_rc.iter().enumerate() {\n             let render = |&:| this.path_loan_path(*mpi).user_string(tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).index(&FullRange));\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -156,7 +156,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, f) in vec_rc.iter().enumerate() {\n             let render = |&:| f.loan_path_user_string(this, tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).index(&FullRange));\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -198,11 +198,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {}\", path_lps(moved[]));\n+    debug!(\"fragments 1 moved: {:?}\", path_lps(moved.index(&FullRange)));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {}\", path_lps(assigned[]));\n+    debug!(\"fragments 1 assigned: {:?}\", path_lps(assigned.index(&FullRange)));\n \n     // Second, build parents from the moved and assigned.\n     for m in moved.iter() {\n@@ -222,14 +222,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {}\", path_lps(parents[]));\n+    debug!(\"fragments 2 parents: {:?}\", path_lps(parents.index(&FullRange)));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, parents[]));\n-    debug!(\"fragments 3 moved: {}\", path_lps(moved[]));\n+    moved.retain(|f| non_member(*f, parents.index(&FullRange)));\n+    debug!(\"fragments 3 moved: {:?}\", path_lps(moved.index(&FullRange)));\n \n-    assigned.retain(|f| non_member(*f, parents[]));\n-    debug!(\"fragments 3 assigned: {}\", path_lps(assigned[]));\n+    assigned.retain(|f| non_member(*f, parents.index(&FullRange)));\n+    debug!(\"fragments 3 assigned: {:?}\", path_lps(assigned.index(&FullRange)));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in moved.iter() {\n@@ -247,16 +247,16 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved[]));\n+    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(unmoved.index(&FullRange)));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n         AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, parents[]) &&\n-            non_member(mpi, moved[]) &&\n-            non_member(mpi, assigned[])\n+        Just(mpi) => non_member(mpi, parents.index(&FullRange)) &&\n+            non_member(mpi, moved.index(&FullRange)) &&\n+            non_member(mpi, assigned.index(&FullRange))\n     });\n-    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved[]));\n+    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(unmoved.index(&FullRange)));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;\n@@ -430,10 +430,10 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n         }\n \n         ref sty_and_variant_info => {\n-            let msg = format!(\"type {} ({}) is not fragmentable\",\n+            let msg = format!(\"type {} ({:?}) is not fragmentable\",\n                               parent_ty.repr(tcx), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            tcx.sess.opt_span_bug(opt_span, msg[])\n+            tcx.sess.opt_span_bug(opt_span, msg.index(&FullRange))\n         }\n     }\n }"}, {"sha": "ca1fba53de42aa11f6fa1c39929017abaa371e91", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -65,7 +65,7 @@ pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       cmt: mc::cmt<'tcx>,\n                                       mode: euv::MatchMode) {\n     let tcx = bccx.tcx;\n-    debug!(\"gather_match_variant(move_pat={}, cmt={}, mode={})\",\n+    debug!(\"gather_match_variant(move_pat={}, cmt={}, mode={:?})\",\n            move_pat.id, cmt.repr(tcx), mode);\n \n     let opt_lp = opt_loan_path(&cmt);"}, {"sha": "2c48e0da01d77e48f7e51213e564acdd25f264eb", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                _consume_span: Span,\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n+        debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n                consume_id, cmt.repr(self.tcx()), mode);\n \n         match mode {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    matched_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::MatchMode) {\n-        debug!(\"matched_pat(matched_pat={}, cmt={}, mode={})\",\n+        debug!(\"matched_pat(matched_pat={}, cmt={}, mode={:?})\",\n                matched_pat.repr(self.tcx()),\n                cmt.repr(self.tcx()),\n                mode);\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n+        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n                consume_pat.repr(self.tcx()),\n                cmt.repr(self.tcx()),\n                mode);\n@@ -132,8 +132,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n-               bk={}, loan_cause={})\",\n+        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n+               bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt.repr(self.tcx()), loan_region,\n                bk, loan_cause);\n \n@@ -235,7 +235,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                        loan_region: ty::Region,\n                        cause: euv::LoanCause) {\n         debug!(\"guarantee_valid(borrow_id={}, cmt={}, \\\n-                req_mutbl={}, loan_region={})\",\n+                req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt.repr(self.tcx()),\n                req_kind,\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             self.bccx, borrow_span, cause,\n             cmt.clone(), loan_region);\n \n-        debug!(\"guarantee_valid(): restrictions={}\", restr);\n+        debug!(\"guarantee_valid(): restrictions={:?}\", restr);\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -306,18 +306,18 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReInfer(..) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n-                            format!(\"invalid borrow lifetime: {}\",\n-                                    loan_region)[]);\n+                            format!(\"invalid borrow lifetime: {:?}\",\n+                                    loan_region).index(&FullRange));\n                     }\n                 };\n-                debug!(\"loan_scope = {}\", loan_scope);\n+                debug!(\"loan_scope = {:?}\", loan_scope);\n \n                 let borrow_scope = region::CodeExtent::from_node_id(borrow_id);\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n-                debug!(\"gen_scope = {}\", gen_scope);\n+                debug!(\"gen_scope = {:?}\", gen_scope);\n \n                 let kill_scope = self.compute_kill_scope(loan_scope, &*loan_path);\n-                debug!(\"kill_scope = {}\", kill_scope);\n+                debug!(\"kill_scope = {:?}\", kill_scope);\n \n                 if req_kind == ty::MutBorrow {\n                     self.mark_loan_path_as_mutated(&*loan_path);"}, {"sha": "1bb143e1dc8d3c87d66a7534bf0cc2e3090070d9", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -120,7 +120,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_string(&*move_from))[]);\n+                        bccx.cmt_to_string(&*move_from)).index(&FullRange));\n         }\n \n         mc::cat_downcast(ref b, _) |\n@@ -132,7 +132,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         move_from.span,\n                         format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx))[]);\n+                                b.ty.user_string(bccx.tcx)).index(&FullRange));\n                 },\n                 _ => panic!(\"this path should not cause illegal move\")\n             }\n@@ -155,10 +155,10 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n             format!(\"to prevent the move, \\\n                      use `ref {0}` or `ref mut {0}` to capture value by \\\n                      reference\",\n-                    pat_name)[]);\n+                    pat_name).index(&FullRange));\n     } else {\n         bccx.span_note(move_to_span,\n                        format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name)[]);\n+                               pat_name).index(&FullRange));\n     }\n }"}, {"sha": "88f56f6862218b276c227945c733e9d897e047f1", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -137,7 +137,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     check_loans::check_loans(this,\n                              &loan_dfcx,\n                              flowed_moves,\n-                             all_loans[],\n+                             all_loans.index(&FullRange),\n                              id,\n                              decl,\n                              body);\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_string(&err)[]);\n+            self.bckerr_to_string(&err).index(&FullRange));\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -527,7 +527,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     use_span,\n                     format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n-                            self.loan_path_to_string(lp))[]);\n+                            self.loan_path_to_string(lp)).index(&FullRange));\n                 (self.loan_path_to_string(moved_lp),\n                  String::new())\n             }\n@@ -569,7 +569,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     format!(\"{} of {}moved value: `{}`\",\n                             verb,\n                             msg,\n-                            nl)[]);\n+                            nl).index(&FullRange));\n                 (ol, moved_lp_msg)\n             }\n         };\n@@ -586,9 +586,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     r => {\n                         self.tcx.sess.bug(format!(\"MoveExpr({}) maps to \\\n-                                                   {}, not Expr\",\n+                                                   {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r)[])\n+                                                  r).index(&FullRange))\n                     }\n                 };\n                 let (suggestion, _) =\n@@ -599,7 +599,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion)[]);\n+                            suggestion).index(&FullRange));\n             }\n \n             move_data::MovePat => {\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx))[]);\n+                            pat_ty.user_string(self.tcx)).index(&FullRange));\n                 self.tcx.sess.span_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -624,9 +624,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     r => {\n                         self.tcx.sess.bug(format!(\"Captured({}) maps to \\\n-                                                   {}, not Expr\",\n+                                                   {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r)[])\n+                                                  r).index(&FullRange))\n                     }\n                 };\n                 let (suggestion, help) =\n@@ -642,7 +642,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion)[]);\n+                            suggestion).index(&FullRange));\n                 self.tcx.sess.span_help(expr_span, help);\n             }\n         }\n@@ -673,7 +673,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(\n             span,\n             format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_string(lp))[]);\n+                    self.loan_path_to_string(lp)).index(&FullRange));\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -799,25 +799,25 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     format!(\"{} in an aliasable location\",\n-                             prefix)[]);\n+                             prefix).index(&FullRange));\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n                                        format!(\"{} in a captured outer \\\n-                                               variable in an `Fn` closure\", prefix)[]);\n+                                               variable in an `Fn` closure\", prefix).as_slice());\n                 span_help!(self.tcx.sess, self.tcx.map.span(id),\n                            \"consider changing this closure to take self by mutable reference\");\n             }\n             mc::AliasableStatic(..) |\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a static location\", prefix)[]);\n+                    format!(\"{} in a static location\", prefix).index(&FullRange));\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `&` reference\", prefix)[]);\n+                    format!(\"{} in a `&` reference\", prefix).index(&FullRange));\n             }\n         }\n \n@@ -885,12 +885,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 note_and_explain_region(\n                     self.tcx,\n                     format!(\"{} would have to be valid for \",\n-                            descr)[],\n+                            descr).index(&FullRange),\n                     loan_scope,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"...but {} is only valid for \", descr)[],\n+                    format!(\"...but {} is only valid for \", descr).index(&FullRange),\n                     ptr_scope,\n                     \"\");\n             }\n@@ -910,7 +910,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id)[]);\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).index(&FullRange));\n                 out.push(')');\n             }\n \n@@ -924,7 +924,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');\n-                        out.push_str(idx.to_string()[]);\n+                        out.push_str(idx.to_string().index(&FullRange));\n                     }\n                 }\n             }\n@@ -956,7 +956,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id)[]);\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).index(&FullRange));\n                 out.push(')');\n             }\n \n@@ -1005,7 +1005,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n \n impl<'tcx> Repr<'tcx> for Loan<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Loan_{}({}, {}, {}-{}, {})\",\n+        format!(\"Loan_{}({}, {:?}, {:?}-{:?}, {})\",\n                  self.index,\n                  self.loan_path.repr(tcx),\n                  self.kind,"}, {"sha": "21b3c910d328a72ec814ec97dd18969308bf9421", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -311,7 +311,7 @@ impl<'tcx> MoveData<'tcx> {\n             }\n         };\n \n-        debug!(\"move_path(lp={}, index={})\",\n+        debug!(\"move_path(lp={}, index={:?})\",\n                lp.repr(tcx),\n                index);\n \n@@ -362,7 +362,7 @@ impl<'tcx> MoveData<'tcx> {\n                     lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n-        debug!(\"add_move(lp={}, id={}, kind={})\",\n+        debug!(\"add_move(lp={}, id={}, kind={:?})\",\n                lp.repr(tcx),\n                id,\n                kind);\n@@ -413,12 +413,12 @@ impl<'tcx> MoveData<'tcx> {\n         };\n \n         if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={})\",\n+            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n                    lp.repr(tcx), self.var_assignments.borrow().len(), path_index);\n \n             self.var_assignments.borrow_mut().push(assignment);\n         } else {\n-            debug!(\"add_assignment[path](lp={}, path_index={})\",\n+            debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n                    lp.repr(tcx), path_index);\n \n             self.path_assignments.borrow_mut().push(assignment);"}, {"sha": "647a5dd559c1dcd60c65357eac00976439824d72", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -53,14 +53,14 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n         let id = n.1.data.id;\n-        debug!(\"dataflow_for({}, id={}) {}\", e, id, self.variants);\n+        debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;\n         for &variant in self.variants.iter() {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");\n-            sets.push_str(self.dataflow_for_variant(e, n, variant)[]);\n+            sets.push_str(self.dataflow_for_variant(e, n, variant).index(&FullRange));\n         }\n         sets\n     }\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                 set.push_str(\", \");\n             }\n             let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n-            set.push_str(loan_str[]);\n+            set.push_str(loan_str.index(&FullRange));\n             saw_some = true;\n             true\n         });\n@@ -101,7 +101,8 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let dfcx = &self.analysis_data.loans;\n         let loan_index_to_path = |&mut: loan_index| {\n             let all_loans = &self.analysis_data.all_loans;\n-            all_loans[loan_index].loan_path()\n+            let l: &borrowck::Loan = &all_loans[loan_index];\n+            l.loan_path()\n         };\n         self.build_set(e, cfgidx, dfcx, loan_index_to_path)\n     }\n@@ -111,7 +112,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let move_index_to_path = |&mut: move_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let moves = move_data.moves.borrow();\n-            let the_move = &(*moves)[move_index];\n+            let the_move: &borrowck::move_data::Move = &(*moves)[move_index];\n             move_data.path_loan_path(the_move.path)\n         };\n         self.build_set(e, cfgidx, dfcx, move_index_to_path)\n@@ -122,7 +123,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let assign_index_to_path = |&mut: assign_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let assignments = move_data.var_assignments.borrow();\n-            let assignment = &(*assignments)[assign_index];\n+            let assignment: &borrowck::move_data::Assignment = &(*assignments)[assign_index];\n             move_data.path_loan_path(assignment.path)\n         };\n         self.build_set(e, cfgidx, dfcx, assign_index_to_path)"}, {"sha": "26bcd5f4c10cd3b82c702dd34fb13e7cb09a2f89", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -17,28 +17,13 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(unknown_features)]\n-#![feature(default_type_params, globs, macro_rules, phase, quote)]\n+#![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n #![allow(non_camel_case_types)]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits."}, {"sha": "52d49924d05d51fe43421d5f524d156ae0daf792", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -58,12 +58,12 @@ pub fn compile_input(sess: Session,\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n-                                                 krate.attrs[],\n+                                                 krate.attrs.index(&FullRange),\n                                                  &sess);\n-            let id = link::find_crate_name(Some(&sess), krate.attrs[],\n+            let id = link::find_crate_name(Some(&sess), krate.attrs.index(&FullRange),\n                                            input);\n             let expanded_crate\n-                = match phase_2_configure_and_expand(&sess, krate, id[],\n+                = match phase_2_configure_and_expand(&sess, krate, id.index(&FullRange),\n                                                      addl_plugins) {\n                     None => return,\n                     Some(k) => k\n@@ -75,7 +75,7 @@ pub fn compile_input(sess: Session,\n         let mut forest = ast_map::Forest::new(expanded_crate);\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n-        write_out_deps(&sess, input, &outputs, id[]);\n+        write_out_deps(&sess, input, &outputs, id.index(&FullRange));\n \n         if stop_after_phase_2(&sess) { return; }\n \n@@ -171,9 +171,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n-        collect_crate_types(sess, krate.attrs[]);\n+        collect_crate_types(sess, krate.attrs.index(&FullRange));\n     *sess.crate_metadata.borrow_mut() =\n-        collect_crate_metadata(sess, krate.attrs[]);\n+        collect_crate_metadata(sess, krate.attrs.index(&FullRange));\n \n     time(time_passes, \"recursion limit\", (), |_| {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -268,8 +268,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n-                new_path.extend(os::split_paths(_old_path[]).into_iter());\n-                os::setenv(\"PATH\", os::join_paths(new_path[]).unwrap());\n+                new_path.extend(os::split_paths(_old_path.index(&FullRange)).into_iter());\n+                os::setenv(\"PATH\", os::join_paths(new_path.index(&FullRange)).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n@@ -533,7 +533,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             write::run_passes(sess,\n                               trans,\n-                              sess.opts.output_types[],\n+                              sess.opts.output_types.index(&FullRange),\n                               outputs));\n     }\n \n@@ -547,14 +547,14 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n-    new_path.extend(os::split_paths(old_path[]).into_iter());\n-    os::setenv(\"PATH\", os::join_paths(new_path[]).unwrap());\n+    new_path.extend(os::split_paths(old_path.index(&FullRange)).into_iter());\n+    os::setenv(\"PATH\", os::join_paths(new_path.index(&FullRange)).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           trans.link.crate_name[]));\n+                           trans.link.crate_name.index(&FullRange)));\n \n     os::setenv(\"PATH\", old_path);\n }\n@@ -643,7 +643,7 @@ fn write_out_deps(sess: &Session,\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| escape_dep_filename(fmap.name[]))\n+                                   .map(|fmap| escape_dep_filename(fmap.name.index(&FullRange)))\n                                    .collect();\n         let mut file = try!(io::File::create(&deps_filename));\n         for path in out_filenames.iter() {\n@@ -657,7 +657,7 @@ fn write_out_deps(sess: &Session,\n         Ok(()) => {}\n         Err(e) => {\n             sess.fatal(format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e)[]);\n+                               deps_filename.display(), e).index(&FullRange));\n         }\n     }\n }\n@@ -726,9 +726,9 @@ pub fn collect_crate_types(session: &Session,\n         let res = !link::invalid_output_for_target(session, *crate_type);\n \n         if !res {\n-            session.warn(format!(\"dropping unsupported crate type `{}` \\\n+            session.warn(format!(\"dropping unsupported crate type `{:?}` \\\n                                    for target `{}`\",\n-                                 *crate_type, session.opts.target_triple)[]);\n+                                 *crate_type, session.opts.target_triple).index(&FullRange));\n         }\n \n         res"}, {"sha": "5af114abeea77ca85c7cdb7f6c7b79298d27a3d7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -22,11 +22,9 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(default_type_params, globs, macro_rules, phase, quote)]\n+#![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unboxed_closures)]\n-#![feature(associated_types)]\n \n extern crate arena;\n extern crate flate;\n@@ -41,22 +39,8 @@ extern crate rustc_trans;\n extern crate rustc_typeck;\n extern crate serialize;\n extern crate \"rustc_llvm\" as llvm;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n pub use syntax::diagnostic;\n \n@@ -105,12 +89,12 @@ fn run_compiler(args: &[String]) {\n     let descriptions = diagnostics::registry::Registry::new(&DIAGNOSTICS);\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n-            match descriptions.find_description(code[]) {\n+            match descriptions.find_description(code.index(&FullRange)) {\n                 Some(ref description) => {\n                     println!(\"{}\", description);\n                 }\n                 None => {\n-                    early_error(format!(\"no extended information for {}\", code)[]);\n+                    early_error(format!(\"no extended information for {}\", code).index(&FullRange));\n                 }\n             }\n             return;\n@@ -136,7 +120,7 @@ fn run_compiler(args: &[String]) {\n             early_error(\"no input filename given\");\n         }\n         1u => {\n-            let ifile = matches.free[0][];\n+            let ifile = matches.free[0].index(&FullRange);\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n                 let src = String::from_utf8(contents).unwrap();\n@@ -313,7 +297,7 @@ Available lint options:\n         for lint in lints.into_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(name[]), lint.default_level.as_str(), lint.desc);\n+                     padded(name.index(&FullRange)), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -343,7 +327,7 @@ Available lint options:\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n-                     padded(name[]), desc);\n+                     padded(name.index(&FullRange)), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -409,7 +393,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     let matches =\n-        match getopts::getopts(args[], config::optgroups()[]) {\n+        match getopts::getopts(args.index(&FullRange), config::optgroups().index(&FullRange)) {\n             Ok(m) => m,\n             Err(f_stable_attempt) => {\n                 // redo option parsing, including unstable options this time,\n@@ -559,7 +543,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n-    match cfg.spawn(move || { std::io::stdio::set_stderr(box w); f() }).join() {\n+    match cfg.scoped(move || { std::io::stdio::set_stderr(box w); f() }).join() {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n             // Thread panicked without emitting a fatal diagnostic\n@@ -583,15 +567,15 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in xs.iter() {\n-                    emitter.emit(None, note[], None, diagnostic::Note)\n+                    emitter.emit(None, note.index(&FullRange), None, diagnostic::Note)\n                 }\n \n                 match r.read_to_string() {\n                     Ok(s) => println!(\"{}\", s),\n                     Err(e) => {\n                         emitter.emit(None,\n                                      format!(\"failed to read internal \\\n-                                              stderr: {}\", e)[],\n+                                              stderr: {}\", e).index(&FullRange),\n                                      None,\n                                      diagnostic::Error)\n                     }"}, {"sha": "44a35ef6be70be5178bd20d83cb3257c6c36f763", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -296,7 +296,7 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n                 try!(pp::word(&mut s.s,\n                               ppaux::ty_to_string(\n                                   tcx,\n-                                  ty::expr_ty(tcx, expr))[]));\n+                                  ty::expr_ty(tcx, expr)).index(&FullRange)));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -370,7 +370,7 @@ impl UserIdentifiedItem {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(parts[])),\n+                NodesMatchingSuffix(map.nodes_matching_suffix(parts.index(&FullRange))),\n         }\n     }\n \n@@ -382,7 +382,7 @@ impl UserIdentifiedItem {\n                         user_option,\n                         self.reconstructed_input(),\n                         is_wrong_because);\n-            sess.fatal(message[])\n+            sess.fatal(message.index(&FullRange))\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n@@ -509,7 +509,7 @@ pub fn pretty_print_input(sess: Session,\n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, krate, id[], None) {\n+        match driver::phase_2_configure_and_expand(&sess, krate, id.index(&FullRange), None) {\n             None => return,\n             Some(k) => k\n         }\n@@ -528,7 +528,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = sess.codemap().get_filemap(src_name[])\n+    let src = sess.codemap().get_filemap(src_name.index(&FullRange))\n                             .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n@@ -548,7 +548,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmSource(s), None) =>\n             s.call_with_pp_support(\n                 sess, ast_map, &arenas, id, out, |annotation, out| {\n-                    debug!(\"pretty printing source code {}\", s);\n+                    debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n                                         sess.diagnostic(),\n@@ -563,7 +563,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmSource(s), Some(uii)) =>\n             s.call_with_pp_support(\n                 sess, ast_map, &arenas, id, (out,uii), |annotation, (out,uii)| {\n-                    debug!(\"pretty printing source code {}\", s);\n+                    debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let ast_map = annotation.ast_map()\n                         .expect(\"--pretty missing ast_map\");\n@@ -586,18 +586,18 @@ pub fn pretty_print_input(sess: Session,\n                 }),\n \n         (PpmFlowGraph, opt_uii) => {\n-            debug!(\"pretty printing flow graph for {}\", opt_uii);\n+            debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n                 sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     unique path suffix (b::c::d)\")[])\n+                                     unique path suffix (b::c::d)\").index(&FullRange))\n \n             });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n             let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n \n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n                 sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid)[])\n+                                   nodeid).index(&FullRange))\n             });\n \n             let code = blocks::Code::from_node(node);\n@@ -609,14 +609,14 @@ pub fn pretty_print_input(sess: Session,\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\\n-                                           block, fn, or method; got {}\",\n+                                           block, fn, or method; got {:?}\",\n                                           node);\n \n                     // point to what was found, if there's an\n                     // accessible span.\n                     match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, message[]),\n-                        None => sess.fatal(message[])\n+                        Some(sp) => sess.span_fatal(sp, message.index(&FullRange)),\n+                        None => sess.fatal(message.index(&FullRange))\n                     }\n                 }\n             }"}, {"sha": "d301e9c7b5c279b8e850a4fa1e2de9d2805fcb3f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        ty::mk_param(self.infcx.tcx, space, index, token::intern(name[]))\n+        ty::mk_param(self.infcx.tcx, space, index, token::intern(name.index(&FullRange)))\n     }\n \n     pub fn re_early_bound(&self,\n@@ -418,7 +418,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                self.ty_to_string(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n-                panic!(\"unexpected error computing LUB: {}\", e)\n+                panic!(\"unexpected error computing LUB: {:?}\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_glb);\n@@ -841,7 +841,7 @@ fn walk_ty_skip_subtree() {\n \n         let mut walker = uniq_ty.walk();\n         while let Some(t) = walker.next() {\n-            debug!(\"walked to {}\", t);\n+            debug!(\"walked to {:?}\", t);\n             let (expected_ty, skip) = expected.pop().unwrap();\n             assert_eq!(t, expected_ty);\n             if skip { walker.skip_current_subtree(); }"}, {"sha": "0bed754aa3c1bf8cb351377baab05543ae2cb067", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -21,10 +21,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(globs)]\n #![feature(link_args)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n \n extern crate libc;\n "}, {"sha": "ca6b1469f856934a55b78568a915e7a7cb04f859", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -221,14 +221,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.resolve_error(sp,\n                         format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_string(duplicate_type),\n-                             token::get_name(name))[]);\n+                             token::get_name(name)).index(&FullRange));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name))[]);\n+                                      token::get_name(name)).index(&FullRange));\n                         }\n                     }\n                 }\n@@ -845,7 +845,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                            name: Name,\n                            new_parent: &Rc<Module>) {\n         debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv {}\",\n+                external crate) building external def, priv {:?}\",\n                vis);\n         let is_public = vis == ast::Public;\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n@@ -989,7 +989,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n           DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n           DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n-            panic!(\"didn't expect `{}`\", def);\n+            panic!(\"didn't expect `{:?}`\", def);\n           }\n         }\n     }\n@@ -1201,7 +1201,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n                        self.names_to_string(module_.imports.borrow().last().unwrap()\n-                                                 .module_path[]),\n+                                                 .module_path.index(&FullRange)),\n                        token::get_name(target));\n \n                 let mut import_resolutions = module_.import_resolutions"}, {"sha": "18066a7b94bd82fff2ab5bc6c03b8fa3062b0689", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     // public or private item, we will check the correct thing, dependent on how the import\n     // is used.\n     fn finalize_import(&mut self, id: ast::NodeId, span: Span) {\n-        debug!(\"finalizing import uses for {}\",\n+        debug!(\"finalizing import uses for {:?}\",\n                 self.session.codemap().span_to_snippet(span));\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&"}, {"sha": "93ad69e03b17f1af3eb84dd1850b74a14e52a266", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 87, "deletions": 100, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -16,26 +16,11 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(globs, phase, slicing_syntax)]\n+#![feature(slicing_syntax)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(associated_types)]\n-#![feature(old_orphan_check)]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n extern crate rustc;\n \n@@ -86,9 +71,9 @@ use syntax::ast::{PolyTraitRef, PrimTy, SelfExplicit};\n use syntax::ast::{RegionTyParamBound, StructField};\n use syntax::ast::{TraitRef, TraitTyParamBound};\n use syntax::ast::{Ty, TyBool, TyChar, TyF32};\n-use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt, TyObjectSum};\n+use syntax::ast::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt, TyObjectSum};\n use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyPolyTraitRef, TyQPath};\n-use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n+use syntax::ast::{TyRptr, TyStr, TyUs, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem};\n use syntax::ast;\n use syntax::ast_map;\n@@ -548,7 +533,7 @@ impl Module {\n \n impl fmt::Show for Module {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}, kind: {}, {}\",\n+        write!(f, \"{:?}, kind: {:?}, {}\",\n                self.def_id,\n                self.kind,\n                if self.is_public { \"public\" } else { \"private\" } )\n@@ -689,7 +674,7 @@ impl NameBindings {\n \n     /// Records a type definition.\n     fn define_type(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining type for def {} with modifiers {}\", def, modifiers);\n+        debug!(\"defining type for def {:?} with modifiers {:?}\", def, modifiers);\n         // Merges the type with the existing type def or creates a new one.\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n@@ -714,7 +699,7 @@ impl NameBindings {\n \n     /// Records a value definition.\n     fn define_value(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining value for def {} with modifiers {}\", def, modifiers);\n+        debug!(\"defining value for def {:?} with modifiers {:?}\", def, modifiers);\n         *self.value_def.borrow_mut() = Some(ValueNsDef {\n             def: def,\n             value_span: Some(sp),\n@@ -833,13 +818,15 @@ impl PrimitiveTypeTable {\n         table.intern(\"char\",    TyChar);\n         table.intern(\"f32\",     TyFloat(TyF32));\n         table.intern(\"f64\",     TyFloat(TyF64));\n-        table.intern(\"int\",     TyInt(TyI));\n+        table.intern(\"int\",     TyInt(TyIs));\n+        table.intern(\"isize\",   TyInt(TyIs));\n         table.intern(\"i8\",      TyInt(TyI8));\n         table.intern(\"i16\",     TyInt(TyI16));\n         table.intern(\"i32\",     TyInt(TyI32));\n         table.intern(\"i64\",     TyInt(TyI64));\n         table.intern(\"str\",     TyStr);\n-        table.intern(\"uint\",    TyUint(TyU));\n+        table.intern(\"uint\",    TyUint(TyUs));\n+        table.intern(\"usize\",   TyUint(TyUs));\n         table.intern(\"u8\",      TyUint(TyU8));\n         table.intern(\"u16\",     TyUint(TyU16));\n         table.intern(\"u32\",     TyUint(TyU32));\n@@ -1071,10 +1058,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"unresolved import `{}`{}\",\n                                       self.import_path_to_string(\n                                           import_directive.module_path\n-                                                          [],\n+                                                          .index(&FullRange),\n                                           import_directive.subclass),\n                                       help);\n-                    self.resolve_error(span, msg[]);\n+                    self.resolve_error(span, msg.index(&FullRange));\n                 }\n                 Indeterminate => break, // Bail out. We'll come around next time.\n                 Success(()) => () // Good. Continue.\n@@ -1104,7 +1091,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         .iter()\n                                         .map(|seg| seg.identifier.name)\n                                         .collect();\n-        self.names_to_string(names[])\n+        self.names_to_string(names.index(&FullRange))\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n@@ -1168,7 +1155,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module_path = &import_directive.module_path;\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               self.names_to_string(module_path[]),\n+               self.names_to_string(module_path.index(&FullRange)),\n                self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -1177,7 +1164,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_.clone(),\n-                                           module_path[],\n+                                           module_path.index(&FullRange),\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -1272,7 +1259,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                              lp: LastPrivate)\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n-                `{}` id {}, last private {}\",\n+                `{}` id {}, last private {:?}\",\n                token::get_name(target),\n                self.module_to_string(&*containing_module),\n                token::get_name(source),\n@@ -1375,7 +1362,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     shadowable: _\n                                 }) => {\n                                     debug!(\"(resolving single import) found \\\n-                                            import in ns {}\", namespace);\n+                                            import in ns {:?}\", namespace);\n                                     let id = import_resolution.id(namespace);\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n@@ -1484,7 +1471,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 match *result {\n                     BoundResult(ref target_module, ref name_bindings) => {\n-                        debug!(\"(resolving single import) found {} target: {}\",\n+                        debug!(\"(resolving single import) found {:?} target: {:?}\",\n                                namespace_name,\n                                name_bindings.def_for_namespace(namespace));\n                         self.check_for_conflicting_import(\n@@ -1508,7 +1495,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     UnboundResult => { /* Continue. */ }\n                     UnknownResult => {\n-                        panic!(\"{} result should be known at this point\", namespace_name);\n+                        panic!(\"{:?} result should be known at this point\", namespace_name);\n                     }\n                 }\n             };\n@@ -1701,7 +1688,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let is_public = import_directive.is_public;\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry(&name).get().unwrap_or_else(\n+        let dest_import_resolution = import_resolutions.entry(name).get().unwrap_or_else(\n             |vacant_entry| {\n                 // Create a new import resolution from this child.\n                 vacant_entry.insert(ImportResolution::new(id, is_public))\n@@ -1774,7 +1761,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     ValueNS => \"value\",\n                                   },\n                                   token::get_name(name).get());\n-                self.session.span_err(import_span, msg[]);\n+                self.session.span_err(import_span, msg.index(&FullRange));\n             }\n             Some(_) | None => {}\n         }\n@@ -1789,7 +1776,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            self.session.span_err(import_span, msg[]);\n+            self.session.span_err(import_span, msg.index(&FullRange));\n         }\n     }\n \n@@ -1814,7 +1801,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg[]);\n+                    self.session.span_err(import_span, msg.index(&FullRange));\n                 }\n                 Some(_) | None => {}\n             }\n@@ -1836,7 +1823,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg[]);\n+                    self.session.span_err(import_span, msg.index(&FullRange));\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -1854,7 +1841,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               token::get_name(name).get());\n-                            self.session.span_err(import_span, msg[]);\n+                            self.session.span_err(import_span, msg.index(&FullRange));\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -1867,7 +1854,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        self.session.span_err(span, msg[]);\n+                                        self.session.span_err(span, msg.index(&FullRange));\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -1876,7 +1863,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       token::get_name(name).get());\n-                                    self.session.span_err(import_span, msg[]);\n+                                    self.session.span_err(import_span, msg.index(&FullRange));\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -1906,7 +1893,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 .span_err(span,\n                           format!(\"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get()).index(&FullRange));\n         }\n     }\n \n@@ -1925,7 +1912,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                           format!(\"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get()).index(&FullRange));\n         }\n     }\n \n@@ -1973,7 +1960,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let segment_name = token::get_name(name);\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n-                    let msg = if \"???\" == module_name[] {\n+                    let msg = if \"???\" == module_name.index(&FullRange) {\n                         span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n \n                         match search_parent_externals(name,\n@@ -2086,14 +2073,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = self.names_to_string(module_path);\n-                let mpath = mpath[];\n+                let mpath = mpath.index(&FullRange);\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n                                             // idx +- 1 to account for the\n                                             // colons on either side\n-                                            mpath[idx + 1..],\n-                                            mpath[0..idx - 1]);\n+                                            mpath.index(&((idx + 1)..)),\n+                                            mpath.index(&(0..(idx - 1))));\n                         return Failed(Some((span, msg)));\n                     },\n                     None => {\n@@ -2165,7 +2152,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      namespace: Namespace)\n                                     -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n-                namespace {} in `{}`\",\n+                namespace {:?} in `{}`\",\n                token::get_name(name),\n                namespace,\n                self.module_to_string(&*module_));\n@@ -2195,7 +2182,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 None => {\n                     // Not found; continue.\n                     debug!(\"(resolving item in lexical scope) found \\\n-                            import resolution, but not in namespace {}\",\n+                            import resolution, but not in namespace {:?}\",\n                            namespace);\n                 }\n                 Some(target) => {\n@@ -2268,7 +2255,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               true) {\n                 Failed(Some((span, msg))) =>\n                     self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                     msg)[]),\n+                                                     msg).index(&FullRange)),\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -2475,7 +2462,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match import_resolution.target_for_namespace(namespace) {\n                     None => {\n                         debug!(\"(resolving name in module) name found, \\\n-                                but not in namespace {}\",\n+                                but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target) => {\n@@ -2528,7 +2515,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn);\n-                self.resolve_error((*imports)[index].span, err[]);\n+                self.resolve_error((*imports)[index].span, err.index(&FullRange));\n             }\n         }\n \n@@ -2620,7 +2607,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match def_like {\n             DlDef(d @ DefUpvar(..)) => {\n                 self.session.span_bug(span,\n-                    format!(\"unexpected {} in bindings\", d)[])\n+                    format!(\"unexpected {:?} in bindings\", d).index(&FullRange))\n             }\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n@@ -2639,14 +2626,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             def = DefUpvar(node_id, function_id, last_proc_body_id);\n \n                             let mut seen = self.freevars_seen.borrow_mut();\n-                            let seen = match seen.entry(&function_id) {\n+                            let seen = match seen.entry(function_id) {\n                                 Occupied(v) => v.into_mut(),\n                                 Vacant(v) => v.insert(NodeSet::new()),\n                             };\n                             if seen.contains(&node_id) {\n                                 continue;\n                             }\n-                            match self.freevars.borrow_mut().entry(&function_id) {\n+                            match self.freevars.borrow_mut().entry(function_id) {\n                                 Occupied(v) => v.into_mut(),\n                                 Vacant(v) => v.insert(vec![]),\n                             }.push(Freevar { def: prev_def, span: span });\n@@ -2766,7 +2753,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.get(&name).cloned() {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs[i + 1..], def_like, span);\n+                    return self.upvarify(ribs.index(&((i + 1)..)), def_like, span);\n                 }\n                 None => {\n                     // Continue.\n@@ -2859,7 +2846,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             generics,\n                                             implemented_traits,\n                                             &**self_type,\n-                                            impl_items[]);\n+                                            impl_items.index(&FullRange));\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n@@ -2937,7 +2924,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.fields[]);\n+                                    struct_def.fields.index(&FullRange));\n             }\n \n             ItemMod(ref module_) => {\n@@ -3010,7 +2997,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                     parameter in this type \\\n                                                     parameter list\",\n                                                    token::get_name(\n-                                                       name))[])\n+                                                       name)).index(&FullRange))\n                     }\n                     seen_bindings.insert(name);\n \n@@ -3182,26 +3169,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, msg[]);\n+                self.resolve_error(trait_reference.path.span, msg.index(&FullRange));\n             }\n             Some(def) => {\n                 match def {\n                     (DefTrait(_), _) => {\n-                        debug!(\"(resolving trait) found trait def: {}\", def);\n+                        debug!(\"(resolving trait) found trait def: {:?}\", def);\n                         self.record_def(trait_reference.ref_id, def);\n                     }\n                     (def, _) => {\n                         self.resolve_error(trait_reference.path.span,\n                                            format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                       &trait_reference.path))[]);\n+                                                       &trait_reference.path)).index(&FullRange));\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n                             self.session.span_note(\n                                 trait_reference.path.span,\n                                 format!(\"`type` aliases cannot be used for traits\")\n-                                    []);\n+                                    .index(&FullRange));\n                         }\n                     }\n                 }\n@@ -3398,7 +3385,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.resolve_error(span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n-                                            path_str)[]);\n+                                            path_str).index(&FullRange));\n             }\n         }\n     }\n@@ -3467,7 +3454,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                 token::get_name(key),\n-                                i + 1)[]);\n+                                i + 1).index(&FullRange));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n@@ -3476,7 +3463,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                     token::get_name(key),\n-                                    i + 1)[]);\n+                                    i + 1).index(&FullRange));\n                     }\n                   }\n                 }\n@@ -3489,7 +3476,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                 token::get_name(key),\n-                                \"#\", i + 1, \"#\")[]);\n+                                \"#\", i + 1, \"#\").index(&FullRange));\n                 }\n             }\n         }\n@@ -3578,8 +3565,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         match self.resolve_path(ty.id, path, TypeNS, true) {\n                             Some(def) => {\n-                                debug!(\"(resolving type) resolved `{}` to \\\n-                                        type {}\",\n+                                debug!(\"(resolving type) resolved `{:?}` to \\\n+                                        type {:?}\",\n                                        token::get_ident(path.segments.last().unwrap() .identifier),\n                                        def);\n                                 result_def = Some(def);\n@@ -3604,7 +3591,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(ty.span, msg[]);\n+                        self.resolve_error(ty.span, msg.index(&FullRange));\n                     }\n                 }\n             }\n@@ -3676,7 +3663,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        token::get_name(renamed))[]);\n+                                        token::get_name(renamed)).index(&FullRange));\n                         }\n                         FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -3728,7 +3715,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                             list\",\n                                                            token::get_ident(\n                                                                ident))\n-                                                   [])\n+                                                   .index(&FullRange))\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n@@ -3737,7 +3724,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            token::get_ident(ident))[]);\n+                                            token::get_ident(ident)).index(&FullRange));\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -3763,13 +3750,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.resolve_error(path.span,\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n                                     token::get_ident(\n-                                        path.segments.last().unwrap().identifier))[]);\n+                                        path.segments.last().unwrap().identifier)).as_slice());\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n                                 format!(\"unresolved enum variant, struct or const `{}`\",\n                                     token::get_ident(\n-                                        path.segments.last().unwrap().identifier))[]);\n+                                        path.segments.last().unwrap().identifier)).as_slice());\n                         }\n                     }\n \n@@ -3797,10 +3784,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n-                                    def: {}\", result);\n+                                    def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_names_to_string(path));\n-                            self.resolve_error(path.span, msg[]);\n+                            self.resolve_error(path.span, msg.index(&FullRange));\n                         }\n                     }\n                 }\n@@ -3821,7 +3808,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  ValueNS) {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n-                         finding {} at {}\",\n+                         finding {} at {:?}\",\n                         token::get_name(name),\n                         target.bindings.value_def.borrow());\n                 match *target.bindings.value_def.borrow() {\n@@ -3862,7 +3849,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match err {\n                     Some((span, msg)) => {\n                         self.resolve_error(span, format!(\"failed to resolve: {}\",\n-                                                         msg)[]);\n+                                                         msg).index(&FullRange));\n                     }\n                     None => ()\n                 }\n@@ -4057,7 +4044,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n-                                       module_path[],\n+                                       module_path.index(&FullRange),\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n@@ -4072,7 +4059,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg)[]);\n+                                                 msg).index(&FullRange));\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -4115,7 +4102,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 module_path[],\n+                                                 module_path.index(&FullRange),\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n@@ -4125,13 +4112,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(module_path[]));\n+                                          self.names_to_string(module_path.index(&FullRange)));\n                         (path.span, msg)\n                     }\n                 };\n \n                 self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg)[]);\n+                                                 msg).index(&FullRange));\n                 return None;\n             }\n \n@@ -4172,14 +4159,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(self.type_ribs[], name, span)\n+                self.search_ribs(self.type_ribs.index(&FullRange), name, span)\n             }\n         };\n \n         match search_result {\n             Some(DlDef(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `{}` to \\\n-                        local: {}\",\n+                        local: {:?}\",\n                        token::get_ident(ident),\n                        def);\n                 return Some(def);\n@@ -4227,7 +4214,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match err {\n                     Some((span, msg)) =>\n                         self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                         msg)[]),\n+                                                         msg).index(&FullRange)),\n                     None => ()\n                 }\n \n@@ -4284,7 +4271,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                name_path[],\n+                                                name_path.index(&FullRange),\n                                                 UseLexicalScope,\n                                                 span,\n                                                 PathSearch) {\n@@ -4322,7 +4309,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n \n         // Look for a method in the current self type's impl module.\n-        match get_module(self, path.span, name_path[]) {\n+        match get_module(self, path.span, name_path.index(&FullRange)) {\n             Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n@@ -4530,10 +4517,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     result => {\n                         debug!(\"(resolving expression) didn't find struct \\\n-                                def: {}\", result);\n+                                def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(path.span, msg[]);\n+                        self.resolve_error(path.span, msg.index(&FullRange));\n                     }\n                 }\n \n@@ -4594,7 +4581,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.resolve_error(\n                             expr.span,\n                             format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label))[])\n+                                    token::get_ident(label)).index(&FullRange))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -4717,23 +4704,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn record_def(&mut self, node_id: NodeId, (def, lp): (Def, LastPrivate)) {\n-        debug!(\"(recording def) recording {} for {}, last private {}\",\n+        debug!(\"(recording def) recording {:?} for {}, last private {:?}\",\n                 def, node_id, lp);\n         assert!(match lp {LastImport{..} => false, _ => true},\n                 \"Import should only be used for `use` directives\");\n         self.last_private.insert(node_id, lp);\n \n-        match self.def_map.borrow_mut().entry(&node_id) {\n+        match self.def_map.borrow_mut().entry(node_id) {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis\n             Occupied(entry) => if def != *entry.get() {\n                 self.session\n-                    .bug(format!(\"node_id {} resolved first to {} and \\\n-                                  then {}\",\n+                    .bug(format!(\"node_id {} resolved first to {:?} and \\\n+                                  then {:?}\",\n                                  node_id,\n                                  *entry.get(),\n-                                 def)[]);\n+                                 def).index(&FullRange));\n             },\n             Vacant(entry) => { entry.insert(def); },\n         }\n@@ -4749,7 +4736,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.resolve_error(pat.span,\n                                    format!(\"cannot use `ref` binding mode \\\n                                             with {}\",\n-                                           descr)[]);\n+                                           descr).index(&FullRange));\n             }\n         }\n     }\n@@ -4785,7 +4772,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return \"???\".to_string();\n         }\n         self.names_to_string(names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>()[])\n+                                  .collect::<Vec<ast::Name>>().index(&FullRange))\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "67bcf152eb78cfa5d20d71d413f79dabfad1d766", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -117,15 +117,15 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n                                    ns: Namespace) {\n         match namebindings.def_for_namespace(ns) {\n             Some(d) => {\n-                debug!(\"(computing exports) YES: export '{}' => {}\",\n+                debug!(\"(computing exports) YES: export '{}' => {:?}\",\n                        name, d.def_id());\n                 exports.push(Export {\n                     name: name,\n                     def_id: d.def_id()\n                 });\n             }\n             d_opt => {\n-                debug!(\"(computing exports) NO: {}\", d_opt);\n+                debug!(\"(computing exports) NO: {:?}\", d_opt);\n             }\n         }\n     }"}, {"sha": "26241ace76f4889e28b18338465e94034eef80a3", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -128,7 +128,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |&: s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, s[], span);\n+        creader::validate_crate_name(sess, s.index(&FullRange), span);\n         s\n     };\n \n@@ -146,7 +146,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n-                    sess.span_err(attr.span, msg[]);\n+                    sess.span_err(attr.span, msg.index(&FullRange));\n                 }\n             }\n             return validate(s.clone(), None);\n@@ -171,7 +171,7 @@ pub fn build_link_meta(sess: &Session, krate: &ast::Crate,\n         crate_name: name,\n         crate_hash: Svh::calculate(&sess.opts.cg.metadata, krate),\n     };\n-    info!(\"{}\", r);\n+    info!(\"{:?}\", r);\n     return r;\n }\n \n@@ -192,17 +192,17 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(link_meta.crate_name[]);\n+    symbol_hasher.input_str(link_meta.crate_name.index(&FullRange));\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in tcx.sess.crate_metadata.borrow().iter() {\n-        symbol_hasher.input_str(meta[]);\n+        symbol_hasher.input_str(meta.index(&FullRange));\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(encoder::encoded_ty(tcx, t)[]);\n+    symbol_hasher.input_str(encoder::encoded_ty(tcx, t).index(&FullRange));\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from_str(\"h\");\n-    hash.push_str(truncated_hash_result(symbol_hasher)[]);\n+    hash.push_str(truncated_hash_result(symbol_hasher).index(&FullRange));\n     hash\n }\n \n@@ -251,7 +251,7 @@ pub fn sanitize(s: &str) -> String {\n                 let mut tstr = String::new();\n                 for c in c.escape_unicode() { tstr.push(c) }\n                 result.push('$');\n-                result.push_str(tstr[1..]);\n+                result.push_str(tstr.index(&(1..)));\n             }\n         }\n     }\n@@ -260,7 +260,7 @@ pub fn sanitize(s: &str) -> String {\n     if result.len() > 0u &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", result[]);\n+        return format!(\"_{}\", result.index(&FullRange));\n     }\n \n     return result;\n@@ -286,12 +286,12 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(mut path: PI,\n \n     fn push(n: &mut String, s: &str) {\n         let sani = sanitize(s);\n-        n.push_str(format!(\"{}{}\", sani.len(), sani)[]);\n+        n.push_str(format!(\"{}{}\", sani.len(), sani).index(&FullRange));\n     }\n \n     // First, connect each component with <len, name> pairs.\n     for e in path {\n-        push(&mut n, token::get_name(e.name()).get()[])\n+        push(&mut n, token::get_name(e.name()).get().index(&FullRange))\n     }\n \n     match hash {\n@@ -329,17 +329,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n     hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n     hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n-    exported_name(path, hash[])\n+    exported_name(path, hash.index(&FullRange))\n }\n \n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n-    let path = [PathName(token::intern(s[])),\n+    let path = [PathName(token::intern(s.index(&FullRange))),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    mangle(ast_map::Values(path.iter()), Some(hash[]))\n+    mangle(ast_map::Values(path.iter()), Some(hash.index(&FullRange)))\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n@@ -359,7 +359,7 @@ pub fn remove(sess: &Session, path: &Path) {\n         Err(e) => {\n             sess.err(format!(\"failed to remove {}: {}\",\n                              path.display(),\n-                             e)[]);\n+                             e).index(&FullRange));\n         }\n     }\n }\n@@ -373,8 +373,8 @@ pub fn link_binary(sess: &Session,\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n-            sess.bug(format!(\"invalid output type `{}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple)[]);\n+            sess.bug(format!(\"invalid output type `{:?}` for target os `{}`\",\n+                             crate_type, sess.opts.target_triple).index(&FullRange));\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -439,8 +439,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = (sess.target.target.options.dll_prefix[],\n-                                    sess.target.target.options.dll_suffix[]);\n+            let (prefix, suffix) = (sess.target.target.options.dll_prefix.index(&FullRange),\n+                                    sess.target.target.options.dll_suffix.index(&FullRange));\n             out_filename.with_filename(format!(\"{}{}{}\",\n                                                prefix,\n                                                libname,\n@@ -450,7 +450,7 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n-            let suffix = sess.target.target.options.exe_suffix[];\n+            let suffix = sess.target.target.options.exe_suffix.index(&FullRange);\n             out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n         }\n     }\n@@ -479,12 +479,12 @@ fn link_binary_output(sess: &Session,\n     if !out_is_writeable {\n         sess.fatal(format!(\"output file {} is not writeable -- check its \\\n                             permissions.\",\n-                           out_filename.display())[]);\n+                           out_filename.display()).index(&FullRange));\n     }\n     else if !obj_is_writeable {\n         sess.fatal(format!(\"object file {} is not writeable -- check its \\\n                             permissions.\",\n-                           obj_filename.display())[]);\n+                           obj_filename.display()).index(&FullRange));\n     }\n \n     match crate_type {\n@@ -539,7 +539,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                ab.add_native_library(l[]).unwrap();\n+                ab.add_native_library(l.index(&FullRange)).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -587,12 +587,12 @@ fn link_rlib<'a>(sess: &'a Session,\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n             match fs::File::create(&metadata).write(trans.metadata\n-                                                         []) {\n+                                                         .index(&FullRange)) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(format!(\"failed to write {}: {}\",\n                                      metadata.display(),\n-                                     e)[]);\n+                                     e).index(&FullRange));\n                     sess.abort_if_errors();\n                 }\n             }\n@@ -608,27 +608,27 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i)[]);\n+                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).as_slice());\n                 let bc_deflated_filename = obj_filename.with_extension(\n-                    format!(\"{}.bytecode.deflate\", i)[]);\n+                    format!(\"{}.bytecode.deflate\", i).index(&FullRange));\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n                     Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n-                                                 e)[])\n+                                                 e).index(&FullRange))\n                 };\n \n-                let bc_data_deflated = match flate::deflate_bytes(bc_data[]) {\n+                let bc_data_deflated = match flate::deflate_bytes(bc_data.index(&FullRange)) {\n                     Some(compressed) => compressed,\n                     None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n-                                               bc_filename.display())[])\n+                                               bc_filename.display()).index(&FullRange))\n                 };\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n                         sess.fatal(format!(\"failed to create compressed bytecode \\\n-                                            file: {}\", e)[])\n+                                            file: {}\", e).index(&FullRange))\n                     }\n                 };\n \n@@ -637,7 +637,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                     Ok(()) => {}\n                     Err(e) => {\n                         sess.err(format!(\"failed to write compressed bytecode: \\\n-                                          {}\", e)[]);\n+                                          {}\", e).index(&FullRange));\n                         sess.abort_if_errors()\n                     }\n                 };\n@@ -677,7 +677,7 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n     try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write(bc_data_deflated[]) };\n+    try! { writer.write(bc_data_deflated.index(&FullRange)) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -728,11 +728,11 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n                 sess.err(format!(\"could not find rlib for: `{}`\",\n-                                 name)[]);\n+                                 name).index(&FullRange));\n                 continue\n             }\n         };\n-        ab.add_rlib(&p, name[], sess.lto()).unwrap();\n+        ab.add_rlib(&p, name.index(&FullRange), sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.into_iter());\n@@ -754,7 +754,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n             cstore::NativeUnknown => \"library\",\n             cstore::NativeFramework => \"framework\",\n         };\n-        sess.note(format!(\"{}: {}\", name, *lib)[]);\n+        sess.note(format!(\"{}: {}\", name, *lib).index(&FullRange));\n     }\n }\n \n@@ -768,12 +768,12 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // The invocations of cc share some flags across platforms\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname[]);\n+    let mut cmd = Command::new(pname.index(&FullRange));\n \n-    cmd.args(sess.target.target.options.pre_link_args[]);\n+    cmd.args(sess.target.target.options.pre_link_args.index(&FullRange));\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n-    cmd.args(sess.target.target.options.post_link_args[]);\n+    cmd.args(sess.target.target.options.post_link_args.index(&FullRange));\n     if !sess.target.target.options.no_compiler_rt {\n         cmd.arg(\"-lcompiler-rt\");\n     }\n@@ -793,11 +793,11 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status)[]);\n-                sess.note(format!(\"{}\", &cmd)[]);\n+                                 prog.status).index(&FullRange));\n+                sess.note(format!(\"{}\", &cmd).index(&FullRange));\n                 let mut output = prog.error.clone();\n-                output.push_all(prog.output[]);\n-                sess.note(str::from_utf8(output[]).unwrap());\n+                output.push_all(prog.output.index(&FullRange));\n+                sess.note(str::from_utf8(output.index(&FullRange)).unwrap());\n                 sess.abort_if_errors();\n             }\n             debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n@@ -806,7 +806,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e)[]);\n+                             e).index(&FullRange));\n             sess.abort_if_errors();\n         }\n     }\n@@ -818,7 +818,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => {\n-                sess.err(format!(\"failed to run dsymutil: {}\", e)[]);\n+                sess.err(format!(\"failed to run dsymutil: {}\", e).index(&FullRange));\n                 sess.abort_if_errors();\n             }\n         }\n@@ -867,7 +867,7 @@ fn link_args(cmd: &mut Command,\n \n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(morestack.as_vec());\n-            cmd.arg(v[]);\n+            cmd.arg(v.index(&FullRange));\n         } else {\n             cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n@@ -992,7 +992,7 @@ fn link_args(cmd: &mut Command,\n             if sess.opts.cg.rpath {\n                 let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n-                cmd.arg(v[]);\n+                cmd.arg(v.index(&FullRange));\n             }\n         } else {\n             cmd.arg(\"-shared\");\n@@ -1004,7 +1004,7 @@ fn link_args(cmd: &mut Command,\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n-        let target_triple = sess.opts.target_triple[];\n+        let target_triple = sess.opts.target_triple.index(&FullRange);\n         let get_install_prefix_lib_path = |:| {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n@@ -1021,14 +1021,14 @@ fn link_args(cmd: &mut Command,\n             get_install_prefix_lib_path: get_install_prefix_lib_path,\n             realpath: ::util::fs::realpath\n         };\n-        cmd.args(rpath::get_rpath_flags(rpath_config)[]);\n+        cmd.args(rpath::get_rpath_flags(rpath_config).index(&FullRange));\n     }\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n-    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n-    cmd.args(used_link_args[]);\n+    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty).index(&FullRange));\n+    cmd.args(used_link_args.index(&FullRange));\n }\n \n // # Native library linking\n@@ -1082,14 +1082,14 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         } else {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n-            let lib = archive::find_library(l[],\n-                                            sess.target.target.options.staticlib_prefix[],\n-                                            sess.target.target.options.staticlib_suffix[],\n-                                            search_path[],\n+            let lib = archive::find_library(l.index(&FullRange),\n+                                            sess.target.target.options.staticlib_prefix.as_slice(),\n+                                            sess.target.target.options.staticlib_suffix.as_slice(),\n+                                            search_path.index(&FullRange),\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(lib.as_vec());\n-            cmd.arg(v[]);\n+            cmd.arg(v.index(&FullRange));\n         }\n     }\n     if takes_hints {\n@@ -1102,7 +1102,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                 cmd.arg(format!(\"-l{}\", l));\n             }\n             cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(l[]);\n+                cmd.arg(\"-framework\").arg(l.index(&FullRange));\n             }\n             cstore::NativeStatic => unreachable!(),\n         }\n@@ -1158,7 +1158,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // Converts a library file-stem into a cc -l argument\n     fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n         if stem.starts_with(\"lib\".as_bytes()) && !config.target.options.is_like_windows {\n-            stem[3..]\n+            stem.index(&(3..))\n         } else {\n             stem\n         }\n@@ -1183,9 +1183,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // against the archive.\n         if sess.lto() {\n             let name = cratepath.filename_str().unwrap();\n-            let name = name[3..name.len() - 5]; // chop off lib/.rlib\n+            let name = name.index(&(3..(name.len() - 5))); // chop off lib/.rlib\n             time(sess.time_passes(),\n-                 format!(\"altering {}.rlib\", name)[],\n+                 format!(\"altering {}.rlib\", name).index(&FullRange),\n                  (), |()| {\n                 let dst = tmpdir.join(cratepath.filename().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n@@ -1194,7 +1194,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                         sess.err(format!(\"failed to copy {} to {}: {}\",\n                                          cratepath.display(),\n                                          dst.display(),\n-                                         e)[]);\n+                                         e).index(&FullRange));\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1206,7 +1206,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     Err(e) => {\n                         sess.err(format!(\"failed to chmod {} when preparing \\\n                                           for LTO: {}\", dst.display(),\n-                                         e)[]);\n+                                         e).index(&FullRange));\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1220,9 +1220,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     maybe_ar_prog: sess.opts.cg.ar.clone()\n                 };\n                 let mut archive = Archive::open(config);\n-                archive.remove_file(format!(\"{}.o\", name)[]);\n+                archive.remove_file(format!(\"{}.o\", name).index(&FullRange));\n                 let files = archive.files();\n-                if files.iter().any(|s| s[].ends_with(\".o\")) {\n+                if files.iter().any(|s| s.index(&FullRange).ends_with(\".o\")) {\n                     cmd.arg(dst);\n                 }\n             });\n@@ -1244,7 +1244,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n         let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n-        cmd.arg(v[]);\n+        cmd.arg(v.index(&FullRange));\n     }\n }\n \n@@ -1286,7 +1286,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n                 }\n                 cstore::NativeFramework => {\n                     cmd.arg(\"-framework\");\n-                    cmd.arg(lib[]);\n+                    cmd.arg(lib.index(&FullRange));\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "ecf2e9ed7242557360ad7b3d6c8c465b28e90dc5", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -54,29 +54,29 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             Some(p) => p,\n             None => {\n                 sess.fatal(format!(\"could not find rlib for: `{}`\",\n-                                   name)[]);\n+                                   name).index(&FullRange));\n             }\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let file = path.filename_str().unwrap();\n-        let file = file[3..file.len() - 5]; // chop off lib/.rlib\n+        let file = file.index(&(3..(file.len() - 5))); // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in iter::count(0u, 1) {\n             let bc_encoded = time(sess.time_passes(),\n-                                  format!(\"check for {}.{}.bytecode.deflate\", name, i)[],\n+                                  format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n                                   (),\n                                   |_| {\n                                       archive.read(format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i)[])\n+                                                           file, i).index(&FullRange))\n                                   });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n                     if i == 0 {\n                         // No bitcode was found at all.\n                         sess.fatal(format!(\"missing compressed bytecode in {}\",\n-                                           path.display())[]);\n+                                           path.display()).index(&FullRange));\n                     }\n                     // No more bitcode files to read.\n                     break;\n@@ -91,20 +91,20 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     if version == 1 {\n                         // The only version existing so far\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                        let compressed_data = bc_encoded[\n+                        let compressed_data = bc_encoded.index(&(\n                             link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint];\n+                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)));\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Some(inflated) => inflated,\n                             None => {\n                                 sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                                   name)[])\n+                                                   name).index(&FullRange))\n                             }\n                         }\n                     } else {\n                         sess.fatal(format!(\"Unsupported bytecode format version {}\",\n-                                           version)[])\n+                                           version).index(&FullRange))\n                     }\n                 })\n             } else {\n@@ -115,7 +115,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                         Some(bc) => bc,\n                         None => {\n                             sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                               name)[])\n+                                               name).index(&FullRange))\n                         }\n                     }\n                 })\n@@ -124,15 +124,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             let ptr = bc_decoded.as_slice().as_ptr();\n             debug!(\"linking {}, part {}\", name, i);\n             time(sess.time_passes(),\n-                 format!(\"ll link {}.{}\", name, i)[],\n+                 format!(\"ll link {}.{}\", name, i).index(&FullRange),\n                  (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n                     write::llvm_err(sess.diagnostic().handler(),\n                                     format!(\"failed to load bc of `{}`\",\n-                                            name[]));\n+                                            name.index(&FullRange)));\n                 }\n             });\n         }\n@@ -186,7 +186,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n     let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n     return bc.len() > magic_id_byte_count &&\n-           bc[..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+           bc.index(&(0..magic_id_byte_count)) == link::RLIB_BYTECODE_OBJECT_MAGIC;\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n@@ -198,8 +198,8 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = bytes[position_in_bytes..\n-                          position_in_bytes + mem::size_of::<T>()];\n+    let byte_data = bytes.index(&(position_in_bytes..\n+                                  (position_in_bytes + mem::size_of::<T>())));\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "8a80019143ea316b0865705dc487a488be19108a", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -47,14 +47,14 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            handler.fatal(msg[]);\n+            handler.fatal(msg.index(&FullRange));\n         } else {\n             let err = ffi::c_str_to_bytes(&cstr);\n             let err = String::from_utf8_lossy(err.as_slice()).to_string();\n             libc::free(cstr as *mut _);\n             handler.fatal(format!(\"{}: {}\",\n-                                  msg[],\n-                                  err[])[]);\n+                                  msg.index(&FullRange),\n+                                  err.index(&FullRange)).index(&FullRange));\n         }\n     }\n }\n@@ -104,13 +104,13 @@ impl SharedEmitter {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n-                                           diag.msg[],\n-                                           code[],\n+                                           diag.msg.index(&FullRange),\n+                                           code.index(&FullRange),\n                                            diag.lvl);\n                 },\n                 None => {\n                     handler.emit(None,\n-                                 diag.msg[],\n+                                 diag.msg.index(&FullRange),\n                                  diag.lvl);\n                 },\n             }\n@@ -165,19 +165,19 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n \n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => s[],\n-        None => sess.target.target.options.relocation_model[]\n+        Some(ref s) => s.index(&FullRange),\n+        None => sess.target.target.options.relocation_model.index(&FullRange)\n     };\n     let reloc_model = match reloc_model_arg {\n         \"pic\" => llvm::RelocPIC,\n         \"static\" => llvm::RelocStatic,\n         \"default\" => llvm::RelocDefault,\n         \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n         _ => {\n-            sess.err(format!(\"{} is not a valid relocation mode\",\n+            sess.err(format!(\"{:?} is not a valid relocation mode\",\n                              sess.opts\n                                  .cg\n-                                 .relocation_model)[]);\n+                                 .relocation_model).index(&FullRange));\n             sess.abort_if_errors();\n             unreachable!();\n         }\n@@ -198,8 +198,8 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let fdata_sections = ffunction_sections;\n \n     let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => s[],\n-        None => sess.target.target.options.code_model[]\n+        Some(ref s) => s.index(&FullRange),\n+        None => sess.target.target.options.code_model.index(&FullRange)\n     };\n \n     let code_model = match code_model_arg {\n@@ -209,16 +209,16 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n         \"medium\" => llvm::CodeModelMedium,\n         \"large\" => llvm::CodeModelLarge,\n         _ => {\n-            sess.err(format!(\"{} is not a valid code model\",\n+            sess.err(format!(\"{:?} is not a valid code model\",\n                              sess.opts\n                                  .cg\n-                                 .code_model)[]);\n+                                 .code_model).index(&FullRange));\n             sess.abort_if_errors();\n             unreachable!();\n         }\n     };\n \n-    let triple = sess.target.target.llvm_target[];\n+    let triple = sess.target.target.llvm_target.index(&FullRange);\n \n     let tm = unsafe {\n         let triple = CString::from_slice(triple.as_bytes());\n@@ -350,13 +350,13 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n             sess.codemap().with_expn_info(ExpnId::from_llvm_cookie(cookie), |info| match info {\n-                Some(ei) => sess.span_err(ei.call_site, msg[]),\n-                None     => sess.err(msg[]),\n+                Some(ei) => sess.span_err(ei.call_site, msg.index(&FullRange)),\n+                None     => sess.err(msg.index(&FullRange)),\n             });\n         }\n \n         None => {\n-            cgcx.handler.err(msg[]);\n+            cgcx.handler.err(msg.index(&FullRange));\n             cgcx.handler.note(\"build without -C codegen-units for more exact errors\");\n         }\n     }\n@@ -381,8 +381,8 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n                 cgcx.handler.note(format!(\"optimization {} for {} at {}: {}\",\n                                           opt.kind.describe(),\n                                           pass_name,\n-                                          if loc.is_empty() { \"[unknown]\" } else { loc[] },\n-                                          llvm::twine_to_string(opt.message))[]);\n+                                          if loc.is_empty() { \"[unknown]\" } else { loc.as_slice() },\n+                                          llvm::twine_to_string(opt.message)).as_slice());\n             }\n         }\n \n@@ -446,7 +446,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             for pass in config.passes.iter() {\n                 let pass = CString::from_slice(pass.as_bytes());\n                 if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n-                    cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n+                    cgcx.handler.warn(format!(\"unknown pass {:?}, ignoring\",\n                                               pass).as_slice());\n                 }\n             }\n@@ -518,14 +518,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(format!(\"{}.s\", name_extra)[]);\n+            let path = output_names.with_extension(format!(\"{}.s\", name_extra).index(&FullRange));\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n-            let path = output_names.with_extension(format!(\"{}.o\", name_extra)[]);\n+            let path = output_names.with_extension(format!(\"{}.o\", name_extra).index(&FullRange));\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n@@ -639,7 +639,7 @@ pub fn run_passes(sess: &Session,\n \n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n-        run_work_singlethreaded(sess, trans.reachable[], work_items);\n+        run_work_singlethreaded(sess, trans.reachable.index(&FullRange), work_items);\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n     }\n@@ -667,7 +667,7 @@ pub fn run_passes(sess: &Session,\n                 // 2) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n                 sess.warn(format!(\"ignoring -o because multiple .{} files were produced\",\n-                                  ext)[]);\n+                                  ext).index(&FullRange));\n             } else {\n                 // 3) Multiple codegen units, but no `-o some_name`.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -700,20 +700,20 @@ pub fn run_passes(sess: &Session,\n             };\n \n         let pname = get_cc_prog(sess);\n-        let mut cmd = Command::new(pname[]);\n+        let mut cmd = Command::new(pname.index(&FullRange));\n \n-        cmd.args(sess.target.target.options.pre_link_args[]);\n+        cmd.args(sess.target.target.options.pre_link_args.index(&FullRange));\n         cmd.arg(\"-nostdlib\");\n \n         for index in range(0, trans.modules.len()) {\n-            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index)[]));\n+            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index).index(&FullRange)));\n         }\n \n         cmd.arg(\"-r\")\n            .arg(\"-o\")\n            .arg(windows_output_path.as_ref().unwrap_or(output_path));\n \n-        cmd.args(sess.target.target.options.post_link_args[]);\n+        cmd.args(sess.target.target.options.post_link_args.index(&FullRange));\n \n         if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n             println!(\"{}\", &cmd);\n@@ -726,14 +726,14 @@ pub fn run_passes(sess: &Session,\n             Ok(status) => {\n                 if !status.success() {\n                     sess.err(format!(\"linking of {} with `{}` failed\",\n-                                     output_path.display(), cmd)[]);\n+                                     output_path.display(), cmd).index(&FullRange));\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n                 sess.err(format!(\"could not exec the linker `{}`: {}\",\n                                  pname,\n-                                 e)[]);\n+                                 e).index(&FullRange));\n                 sess.abort_if_errors();\n             },\n         }\n@@ -818,12 +818,12 @@ pub fn run_passes(sess: &Session,\n         for i in range(0, trans.modules.len()) {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(ext[]));\n+                remove(sess, &crate_output.with_extension(ext.index(&FullRange)));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(ext[]));\n+                remove(sess, &crate_output.with_extension(ext.index(&FullRange)));\n             }\n         }\n \n@@ -928,7 +928,7 @@ fn run_work_multithreaded(sess: &Session,\n             }\n \n             tx.take().unwrap().send(()).unwrap();\n-        }).detach();\n+        });\n     }\n \n     let mut panicked = false;\n@@ -949,7 +949,7 @@ fn run_work_multithreaded(sess: &Session,\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname[]);\n+    let mut cmd = Command::new(pname.index(&FullRange));\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n@@ -960,18 +960,18 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status)[]);\n-                sess.note(format!(\"{}\", &cmd)[]);\n+                                 prog.status).index(&FullRange));\n+                sess.note(format!(\"{}\", &cmd).index(&FullRange));\n                 let mut note = prog.error.clone();\n-                note.push_all(prog.output[]);\n-                sess.note(str::from_utf8(note[]).unwrap());\n+                note.push_all(prog.output.index(&FullRange));\n+                sess.note(str::from_utf8(note.index(&FullRange)).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e)[]);\n+                             e).index(&FullRange));\n             sess.abort_if_errors();\n         }\n     }\n@@ -1004,7 +1004,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n \n         for arg in sess.opts.cg.llvm_args.iter() {\n-            add((*arg)[]);\n+            add((*arg).index(&FullRange));\n         }\n     }\n "}, {"sha": "b6f90a4c2f52a9ac7420b588f9f3727051fb87eb", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -22,13 +22,9 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(default_type_params, globs, macro_rules, phase, quote)]\n+#![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n \n extern crate arena;\n extern crate flate;\n@@ -40,21 +36,8 @@ extern crate rustc_back;\n extern crate serialize;\n extern crate \"rustc_llvm\" as llvm;\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n pub use rustc::session;\n pub use rustc::metadata;"}, {"sha": "35f168f092a700d5d57dda2dc011504defa3fd1a", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 78, "deletions": 76, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -94,7 +94,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // dump info about all the external crates referenced from this crate\n         self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, cmd.name[], n);\n+            self.fmt.external_crate_str(krate.span, cmd.name.index(&FullRange), n);\n         });\n         self.fmt.recorder.record(\"end_external_crates\\n\");\n     }\n@@ -143,7 +143,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname[],\n+                                     qualname.index(&FullRange),\n                                      self.cur_scope);\n         }\n     }\n@@ -161,7 +161,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname[],\n+                                     qualname.index(&FullRange),\n                                      self.cur_scope);\n         }\n     }\n@@ -180,17 +180,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let (ref span, ref qualname) = sub_paths[len-2];\n         self.fmt.sub_type_ref_str(path.span,\n                                   *span,\n-                                  qualname[]);\n+                                  qualname.index(&FullRange));\n \n         // write the other sub-paths\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = sub_paths[..len-2];\n+        let sub_paths = sub_paths.index(&(0..(len-2)));\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname[],\n+                                     qualname.index(&FullRange),\n                                      self.cur_scope);\n         }\n     }\n@@ -199,7 +199,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n             self.sess.bug(format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id)[]);\n+                                  ref_id).index(&FullRange));\n         }\n         let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n@@ -212,7 +212,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n             self.sess.span_bug(span, format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id)[]);\n+                                             ref_id).index(&FullRange));\n         }\n         let def = (*def_map)[ref_id];\n         match def {\n@@ -240,8 +240,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefUse(_) |\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n-                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {}\",\n-                                                 def)[]);\n+                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {:?}\",\n+                                                 def).index(&FullRange));\n             },\n         }\n     }\n@@ -262,8 +262,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     span_utils.span_for_last_ident(p.span),\n                                     id,\n                                     qualname,\n-                                    path_to_string(p)[],\n-                                    typ[]);\n+                                    path_to_string(p).index(&FullRange),\n+                                    typ.index(&FullRange));\n             }\n             self.collected_paths.clear();\n         }\n@@ -285,14 +285,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     match item.node {\n                         ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(ty_to_string(&**ty)[]);\n+                            result.push_str(ty_to_string(&**ty).index(&FullRange));\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        ty::item_path_str(&self.analysis.ty_cx, def_id)[]);\n+                                        ty::item_path_str(&self.analysis.ty_cx, def_id).as_slice());\n                                 },\n                                 None => {}\n                             }\n@@ -302,17 +302,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id)[]);\n+                                                       impl_id.node, method.id).index(&FullRange));\n                         },\n                     }\n                 },\n                 _ => {\n                     self.sess.span_bug(method.span,\n-                                       format!(\"Container {} for method {} is not a node item {}\",\n+                                       format!(\"Container {} for method {} is not a node item {:?}\",\n                                                impl_id.node,\n                                                method.id,\n                                                self.analysis.ty_cx.map.get(impl_id.node)\n-                                              )[]);\n+                                              ).index(&FullRange));\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n@@ -328,20 +328,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id)[]);\n+                                                       def_id.node, method.id).index(&FullRange));\n                         }\n                     }\n                 },\n                 None => {\n                     self.sess.span_bug(method.span,\n                                        format!(\"Could not find container for method {}\",\n-                                               method.id)[]);\n+                                               method.id).index(&FullRange));\n                 },\n             },\n         };\n \n         qualname.push_str(get_ident(method.pe_ident()).get());\n-        let qualname = qualname[];\n+        let qualname = qualname.index(&FullRange);\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -430,13 +430,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         name.get()[],\n-                                                         qualname[],\n-                                                         typ[],\n+                                                         name.get().index(&FullRange),\n+                                                         qualname.index(&FullRange),\n+                                                         typ.index(&FullRange),\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n                                                format!(\"Could not find sub-span for field {}\",\n-                                                       qualname)[]),\n+                                                       qualname).index(&FullRange)),\n                 }\n             },\n             _ => (),\n@@ -463,7 +463,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.typedef_str(full_span,\n                                  Some(*param_ss),\n                                  param.id,\n-                                 name[],\n+                                 name.index(&FullRange),\n                                  \"\");\n         }\n         self.visit_generics(generics);\n@@ -480,10 +480,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.fn_str(item.span,\n                         sub_span,\n                         item.id,\n-                        qualname[],\n+                        qualname.index(&FullRange),\n                         self.cur_scope);\n \n-        self.process_formals(&decl.inputs, qualname[]);\n+        self.process_formals(&decl.inputs, qualname.index(&FullRange));\n \n         // walk arg and return types\n         for arg in decl.inputs.iter() {\n@@ -497,7 +497,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n \n-        self.process_generic_params(ty_params, item.span, qualname[], item.id);\n+        self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n     }\n \n     fn process_static(&mut self,\n@@ -519,9 +519,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname[],\n-                            value[],\n-                            ty_to_string(&*typ)[],\n+                            qualname.index(&FullRange),\n+                            value.index(&FullRange),\n+                            ty_to_string(&*typ).index(&FullRange),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -542,9 +542,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname[],\n+                            qualname.index(&FullRange),\n                             \"\",\n-                            ty_to_string(&*typ)[],\n+                            ty_to_string(&*typ).index(&FullRange),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -568,17 +568,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             ctor_id,\n-                            qualname[],\n+                            qualname.index(&FullRange),\n                             self.cur_scope,\n-                            val[]);\n+                            val.index(&FullRange));\n \n         // fields\n         for field in def.fields.iter() {\n-            self.process_struct_field_def(field, qualname[], item.id);\n+            self.process_struct_field_def(field, qualname.index(&FullRange), item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, qualname[], item.id);\n+        self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n     }\n \n     fn process_enum(&mut self,\n@@ -591,12 +591,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n                                                 item.id,\n-                                                enum_name[],\n+                                                enum_name.index(&FullRange),\n                                                 self.cur_scope,\n-                                                val[]),\n+                                                val.index(&FullRange)),\n             None => self.sess.span_bug(item.span,\n                                        format!(\"Could not find subspan for enum {}\",\n-                                               enum_name)[]),\n+                                               enum_name).index(&FullRange)),\n         }\n         for variant in enum_definition.variants.iter() {\n             let name = get_ident(variant.node.name);\n@@ -612,9 +612,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                self.span.span_for_first_ident(variant.span),\n                                                variant.node.id,\n                                                name,\n-                                               qualname[],\n-                                               enum_name[],\n-                                               val[],\n+                                               qualname.index(&FullRange),\n+                                               enum_name.index(&FullRange),\n+                                               val.index(&FullRange),\n                                                item.id);\n                     for arg in args.iter() {\n                         self.visit_ty(&*arg.ty);\n@@ -630,20 +630,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         self.span.span_for_first_ident(variant.span),\n                         variant.node.id,\n                         ctor_id,\n-                        qualname[],\n-                        enum_name[],\n-                        val[],\n+                        qualname.index(&FullRange),\n+                        enum_name.index(&FullRange),\n+                        val.index(&FullRange),\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n-                        self.process_struct_field_def(field, qualname[], variant.node.id);\n+                        self.process_struct_field_def(field, qualname.as_slice(), variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n                 }\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, enum_name[], item.id);\n+        self.process_generic_params(ty_params, item.span, enum_name.index(&FullRange), item.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -703,9 +703,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.trait_str(item.span,\n                            sub_span,\n                            item.id,\n-                           qualname[],\n+                           qualname.index(&FullRange),\n                            self.cur_scope,\n-                           val[]);\n+                           val.index(&FullRange));\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n@@ -737,7 +737,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, qualname[], item.id);\n+        self.process_generic_params(generics, item.span, qualname.index(&FullRange), item.id);\n         for method in methods.iter() {\n             self.visit_trait_item(method)\n         }\n@@ -755,9 +755,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.mod_str(item.span,\n                          sub_span,\n                          item.id,\n-                         qualname[],\n+                         qualname.index(&FullRange),\n                          self.cur_scope,\n-                         filename[]);\n+                         filename.index(&FullRange));\n \n         self.nest(item.id, |v| visit::walk_mod(v, m));\n     }\n@@ -774,7 +774,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&id) {\n             self.sess.span_bug(span,\n-                               format!(\"def_map has no key for {} in visit_expr\", id)[]);\n+                               format!(\"def_map has no key for {} in visit_expr\", id).as_slice());\n         }\n         let def = &(*def_map)[id];\n         let sub_span = self.span.span_for_last_ident(span);\n@@ -841,7 +841,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                           self.cur_scope),\n             _ => self.sess.span_bug(span,\n                                     format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(span))[]),\n+                                            self.span.snippet(span)).index(&FullRange)),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -959,7 +959,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                self.cur_scope);\n \n         // walk receiver and args\n-        visit::walk_exprs(self, args[]);\n+        visit::walk_exprs(self, args.index(&FullRange));\n     }\n \n     fn process_pat(&mut self, p:&ast::Pat) {\n@@ -976,7 +976,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(p.span,\n                                            format!(\"Could not find struct_def for `{}`\",\n-                                                   self.span.snippet(p.span))[]);\n+                                                   self.span.snippet(p.span)).index(&FullRange));\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields.iter() {\n@@ -1061,11 +1061,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n-                                     qualname[],\n-                                     value[]);\n+                                     qualname.index(&FullRange),\n+                                     value.index(&FullRange));\n \n                 self.visit_ty(&**ty);\n-                self.process_generic_params(ty_params, item.span, qualname[], item.id);\n+                self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n             },\n             ast::ItemMac(_) => (),\n             _ => visit::walk_item(self, item),\n@@ -1122,12 +1122,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(method_type.span,\n                                            format!(\"Could not find trait for method {}\",\n-                                                   method_type.id)[]);\n+                                                   method_type.id).index(&FullRange));\n                     },\n                 };\n \n                 qualname.push_str(get_ident(method_type.ident).get());\n-                let qualname = qualname[];\n+                let qualname = qualname.index(&FullRange);\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n                 self.fmt.method_decl_str(method_type.span,\n@@ -1262,7 +1262,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           id,\n                                           cnum,\n                                           name,\n-                                          s[],\n+                                          s.index(&FullRange),\n                                           self.cur_scope);\n             },\n         }\n@@ -1371,8 +1371,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 let mut id = String::from_str(\"$\");\n-                id.push_str(ex.id.to_string()[]);\n-                self.process_formals(&decl.inputs, id[]);\n+                id.push_str(ex.id.to_string().index(&FullRange));\n+                self.process_formals(&decl.inputs, id.index(&FullRange));\n \n                 // walk arg and return types\n                 for arg in decl.inputs.iter() {\n@@ -1418,7 +1418,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n-                                   format!(\"def_map has no key for {} in visit_arm\", id)[]);\n+                                   format!(\"def_map has no key for {} in visit_arm\",\n+                                           id).index(&FullRange));\n             }\n             let def = &(*def_map)[id];\n             match *def {\n@@ -1433,8 +1434,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     self.fmt.variable_str(p.span,\n                                           Some(p.span),\n                                           id,\n-                                          path_to_string(p)[],\n-                                          value[],\n+                                          path_to_string(p).index(&FullRange),\n+                                          value.index(&FullRange),\n                                           \"\")\n                 }\n                 def::DefVariant(..) => {\n@@ -1443,7 +1444,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // FIXME(nrc) what are these doing here?\n                 def::DefStatic(_, _) => {}\n                 def::DefConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {}\", *def)\n+                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                            *def)\n             }\n         }\n         for &(id, span, ref path, ref_kind) in paths_to_process.iter() {\n@@ -1488,9 +1490,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             self.fmt.variable_str(p.span,\n                                   sub_span,\n                                   id,\n-                                  path_to_string(p)[],\n-                                  value[],\n-                                  typ[]);\n+                                  path_to_string(p).index(&FullRange),\n+                                  value.index(&FullRange),\n+                                  typ.index(&FullRange));\n         }\n         self.collected_paths.clear();\n \n@@ -1509,7 +1511,7 @@ pub fn process_crate(sess: &Session,\n     }\n \n     assert!(analysis.glob_map.is_some());\n-    let cratename = match attr::find_crate_name(krate.attrs[]) {\n+    let cratename = match attr::find_crate_name(krate.attrs.index(&FullRange)) {\n         Some(name) => name.get().to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n@@ -1530,7 +1532,7 @@ pub fn process_crate(sess: &Session,\n \n     match fs::mkdir_recursive(&root_path, io::USER_RWX) {\n         Err(e) => sess.err(format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e)[]),\n+                           root_path.display(), e).index(&FullRange)),\n         _ => (),\n     }\n \n@@ -1547,7 +1549,7 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(format!(\"Could not open {}: {}\", disp, e)[]);\n+            sess.fatal(format!(\"Could not open {}: {}\", disp, e).index(&FullRange));\n         }\n     };\n     root_path.pop();\n@@ -1573,7 +1575,7 @@ pub fn process_crate(sess: &Session,\n         cur_scope: 0\n     };\n \n-    visitor.dump_crate_info(cratename[], krate);\n+    visitor.dump_crate_info(cratename.index(&FullRange), krate);\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "bb0fb387002083ffc19ec1ea511a60f59972bf78", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -41,7 +41,7 @@ impl Recorder {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n                              kind, su.extent_str(span), escape(su.snippet(span)));\n-        self.record(result[]);\n+        self.record(result.index(&FullRange));\n     }\n }\n \n@@ -160,15 +160,15 @@ impl<'a> FmtStrs<'a> {\n         if values.len() != fields.len() {\n             self.span.sess.span_bug(span, format!(\n                 \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n-                kind, fields.len(), values.len())[]);\n+                kind, fields.len(), values.len()).index(&FullRange));\n         }\n \n         let values = values.iter().map(|s| {\n             // Never take more than 1020 chars\n             if s.len() > 1020 {\n-                s[..1020]\n+                s.index(&(0..1020))\n             } else {\n-                s[]\n+                s.index(&FullRange)\n             }\n         });\n \n@@ -184,7 +184,7 @@ impl<'a> FmtStrs<'a> {\n             }\n         )));\n         Some(strs.fold(String::new(), |mut s, ss| {\n-            s.push_str(ss[]);\n+            s.push_str(ss.index(&FullRange));\n             s\n         }))\n     }\n@@ -198,7 +198,7 @@ impl<'a> FmtStrs<'a> {\n         if needs_span {\n             self.span.sess.span_bug(span, format!(\n                 \"Called record_without_span for '{}' which does requires a span\",\n-                label)[]);\n+                label).index(&FullRange));\n         }\n         assert!(!dump_spans);\n \n@@ -212,9 +212,9 @@ impl<'a> FmtStrs<'a> {\n         };\n \n         let mut result = String::from_str(label);\n-        result.push_str(values_str[]);\n+        result.push_str(values_str.index(&FullRange));\n         result.push_str(\"\\n\");\n-        self.recorder.record(result[]);\n+        self.recorder.record(result.index(&FullRange));\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -237,15 +237,15 @@ impl<'a> FmtStrs<'a> {\n         if !needs_span {\n             self.span.sess.span_bug(span,\n                                     format!(\"Called record_with_span for '{}' \\\n-                                             which does not require a span\", label)[]);\n+                                             which does not require a span\", label).as_slice());\n         }\n \n         let values_str = match self.make_values_str(label, fields, values, span) {\n             Some(vs) => vs,\n             None => return,\n         };\n         let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n-        self.recorder.record(result[]);\n+        self.recorder.record(result.index(&FullRange));\n     }\n \n     pub fn check_and_record(&mut self,\n@@ -275,7 +275,7 @@ impl<'a> FmtStrs<'a> {\n         // variable def's node id\n         let mut qualname = String::from_str(name);\n         qualname.push_str(\"$\");\n-        qualname.push_str(id.to_string()[]);\n+        qualname.push_str(id.to_string().index(&FullRange));\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "8d249b8bfe9036c55f21ff0bb5b110e994118eab", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -218,7 +218,7 @@ impl<'a> SpanUtils<'a> {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             self.sess.span_bug(span,\n                 format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                        self.snippet(span), loc.file.name, loc.line)[]);\n+                        self.snippet(span), loc.file.name, loc.line).index(&FullRange));\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -244,7 +244,7 @@ impl<'a> SpanUtils<'a> {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n                     self.sess.span_bug(span, format!(\n                         \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                         self.snippet(span), loc.file.name, loc.line)[]);\n+                         self.snippet(span), loc.file.name, loc.line).index(&FullRange));\n                 }\n                 return result\n             }"}, {"sha": "49b9ef5a40adebf2e6add1ac35d25a37a17c6690", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -427,7 +427,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(br.pats[]).map(|pats| {\n+        e(br.pats.index(&FullRange)).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -471,8 +471,8 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            let mut r = pats[..col].to_vec();\n-            r.push_all(pats[col + 1..]);\n+            let mut r = pats.index(&(0..col)).to_vec();\n+            r.push_all(pats.index(&((col + 1)..)));\n             Some(r)\n         } else {\n             None\n@@ -518,7 +518,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              variant_size: uint,\n              val: ValueRef)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_opt(bcx={}, m={}, opt={}, col={}, val={})\",\n+    debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            *opt,\n@@ -548,7 +548,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         param_env: param_env,\n     };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats[], &ctor, col, variant_size)\n+        check_match::specialize(&mcx, pats.index(&FullRange), &ctor, col, variant_size)\n     )\n }\n \n@@ -790,7 +790,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         let did = langcall(cx,\n                            None,\n                            format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t))[],\n+                                   cx.ty_to_string(rhs_t)).index(&FullRange),\n                            StrEqFnLangItem);\n         callee::trans_lang_call(cx, did, &[lhs, rhs], None)\n     }\n@@ -945,7 +945,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if has_nested_bindings(m, col) {\n                 let expanded = expand_nested_bindings(bcx, m, col, val);\n                 compile_submatch_continue(bcx,\n-                                          expanded[],\n+                                          expanded.index(&FullRange),\n                                           vals,\n                                           chk,\n                                           col,\n@@ -967,7 +967,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     bcx = compile_guard(bcx,\n                                         &**guard_expr,\n                                         m[0].data,\n-                                        m[1..m.len()],\n+                                        m.index(&(1..m.len())),\n                                         vals,\n                                         chk,\n                                         has_genuine_default);\n@@ -990,8 +990,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let mut vals_left = vals[0u..col].to_vec();\n-    vals_left.push_all(vals[col + 1u..]);\n+    let mut vals_left = vals.index(&(0u..col)).to_vec();\n+    vals_left.push_all(vals.index(&((col + 1u)..)));\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n@@ -1037,16 +1037,16 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         field_vals.len())\n             );\n             let mut vals = field_vals;\n-            vals.push_all(vals_left[]);\n-            compile_submatch(bcx, pats[], vals[], chk, has_genuine_default);\n+            vals.push_all(vals_left.as_slice());\n+            compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n             return;\n         }\n         _ => ()\n     }\n \n     // Decide what kind of branch we need\n     let opts = get_branches(bcx, m, col);\n-    debug!(\"options={}\", opts);\n+    debug!(\"options={:?}\", opts);\n     let mut kind = NoBranch;\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n@@ -1191,10 +1191,10 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;\n-        opt_vals.push_all(vals_left[]);\n+        opt_vals.push_all(vals_left.index(&FullRange));\n         compile_submatch(opt_cx,\n-                         opt_ms[],\n-                         opt_vals[],\n+                         opt_ms.index(&FullRange),\n+                         opt_vals.index(&FullRange),\n                          branch_chk.as_ref().unwrap_or(chk),\n                          has_genuine_default);\n     }\n@@ -1213,8 +1213,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             _ => {\n                 compile_submatch(else_cx,\n-                                 defaults[],\n-                                 vals_left[],\n+                                 defaults.index(&FullRange),\n+                                 vals_left.index(&FullRange),\n                                  chk,\n                                  has_genuine_default);\n             }\n@@ -1333,21 +1333,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                                  \"__llmatch\");\n                 trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n-                                         bcx.ident(ident)[]));\n+                                         bcx.ident(ident).index(&FullRange)));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n-                                 bcx.ident(ident)[]);\n+                                 bcx.ident(ident).index(&FullRange));\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n-                                 bcx.ident(ident)[]);\n+                                 bcx.ident(ident).index(&FullRange));\n                 trmode = TrByRef;\n             }\n         };\n@@ -1415,7 +1415,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, matches[], &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, matches.index(&FullRange), &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n@@ -1429,7 +1429,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs[]);\n+    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs.index(&FullRange));\n     return bcx;\n }\n \n@@ -1582,7 +1582,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident)[]);\n+    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident).index(&FullRange));\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1620,7 +1620,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx()))[]);\n+                                 pat.repr(bcx.tcx())).index(&FullRange));\n     }\n \n     let _indenter = indenter();"}, {"sha": "231de71848a1d44e6179b564f08210f809b11ca9", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -145,7 +145,7 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let repr = Rc::new(represent_type_uncached(cx, t));\n-    debug!(\"Represented as: {}\", repr);\n+    debug!(\"Represented as: {:?}\", repr);\n     cx.adt_reprs().borrow_mut().insert(t, repr.clone());\n     repr\n }\n@@ -154,7 +154,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, elems[], false, t), false)\n+            Univariant(mk_struct(cx, elems.index(&FullRange), false, t), false)\n         }\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -165,17 +165,17 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(cx.tcx().types.bool); }\n \n-            Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n+            Univariant(mk_struct(cx, ftys.index(&FullRange), packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, substs) => {\n             let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n             let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, upvar_types[], false, t), false)\n+            Univariant(mk_struct(cx, upvar_types.index(&FullRange), false, t), false)\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id)[].get(0)\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).index(&FullRange).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n@@ -185,7 +185,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n-                return Univariant(mk_struct(cx, ftys[], false, t),\n+                return Univariant(mk_struct(cx, ftys.index(&FullRange), false, t),\n                                   dtor);\n             }\n \n@@ -208,7 +208,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n                                       ty::item_path_str(cx.tcx(),\n-                                                        def_id))[]);\n+                                                        def_id)).index(&FullRange));\n             }\n \n             if cases.len() == 1 {\n@@ -217,7 +217,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                return Univariant(mk_struct(cx, ftys[], false, t),\n+                return Univariant(mk_struct(cx, ftys.index(&FullRange), false, t),\n                                   dtor);\n             }\n \n@@ -226,7 +226,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, cases[discr].tys[],\n+                        let st = mk_struct(cx, cases[discr].tys.index(&FullRange),\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n                             Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n@@ -316,17 +316,17 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n-                ftys.push_all(c.tys[]);\n+                ftys.push_all(c.tys.index(&FullRange));\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                mk_struct(cx, ftys[], false, t)\n+                mk_struct(cx, ftys.index(&FullRange), false, t)\n             }).collect();\n \n-            ensure_enum_fits_in_address_space(cx, ity, fields[], t);\n+            ensure_enum_fits_in_address_space(cx, ity, fields.index(&FullRange), t);\n \n             General(ity, fields, dtor)\n         }\n         _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_string(cx.tcx(), t))[])\n+                           ty_to_string(cx.tcx(), t)).index(&FullRange))\n     }\n }\n \n@@ -412,7 +412,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n impl<'tcx> Case<'tcx> {\n     fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n-        mk_struct(cx, self.tys[], false, scapegoat).size == 0\n+        mk_struct(cx, self.tys.index(&FullRange), false, scapegoat).size == 0\n     }\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n@@ -451,9 +451,9 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n-    ensure_struct_fits_in_address_space(cx, lltys[], packed, scapegoat);\n+    ensure_struct_fits_in_address_space(cx, lltys.index(&FullRange), packed, scapegoat);\n \n-    let llty_rec = Type::struct_(cx, lltys[], packed);\n+    let llty_rec = Type::struct_(cx, lltys.index(&FullRange), packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec),\n         align: machine::llalign_of_min(cx, llty_rec),\n@@ -482,7 +482,7 @@ fn mk_cenum<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n }\n \n fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n-    debug!(\"range_to_inttype: {} {}\", hint, bounds);\n+    debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n     #[allow(non_upper_case_globals)]\n     static choose_shortest: &'static[IntType] = &[\n@@ -502,7 +502,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match cx.sess().target.target.arch[] {\n+            attempts = match cx.sess().target.target.arch.index(&FullRange) {\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n                 // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n@@ -533,7 +533,7 @@ pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {\n }\n \n fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n-    debug!(\"bounds_usable: {} {}\", ity, bounds);\n+    debug!(\"bounds_usable: {:?} {:?}\", ity, bounds);\n     match ity {\n         attr::SignedInt(_) => {\n             let lllo = C_integral(ll_inttype(cx, ity), bounds.slo as u64, true);\n@@ -628,7 +628,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false, false)[],\n+            llty.set_struct_body(struct_llfields(cx, st, false, false).index(&FullRange),\n                                  st.packed)\n     }\n }\n@@ -644,7 +644,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst)[],\n+                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst).index(&FullRange),\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -663,7 +663,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let (size, align) = union_size_and_align(sts[]);\n+            let (size, align) = union_size_and_align(sts.index(&FullRange));\n             let align_s = align as u64;\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n@@ -684,10 +684,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           Type::array(&discr_ty, align_s / discr_size - 1),\n                           fill_ty];\n             match name {\n-                None => Type::struct_(cx, fields[], false),\n+                None => Type::struct_(cx, fields.index(&FullRange), false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(fields[], false);\n+                    llty.set_struct_body(fields.index(&FullRange), false);\n                     llty\n                 }\n             }\n@@ -731,7 +731,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n     -> ValueRef {\n     let signed;\n     let val;\n-    debug!(\"trans_get_discr r: {}\", r);\n+    debug!(\"trans_get_discr r: {:?}\", r);\n     match *r {\n         CEnum(ity, min, max) => {\n             val = load_discr(bcx, ity, scrutinee, min, max);\n@@ -765,7 +765,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n \n fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &DiscrField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = GEPi(bcx, scrutinee, discrfield[]);\n+    let llptrptr = GEPi(bcx, scrutinee, discrfield.index(&FullRange));\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n@@ -853,7 +853,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n-                let llptrptr = GEPi(bcx, val, discrfield[]);\n+                let llptrptr = GEPi(bcx, val, discrfield.index(&FullRange));\n                 let llptrty = val_ty(llptrptr).element_type();\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n@@ -935,7 +935,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, fields[], st.packed);\n+        let real_ty = Type::struct_(ccx, fields.index(&FullRange), st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -967,14 +967,14 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             for (discr, case) in cases.iter().enumerate() {\n                 let mut variant_cx = fcx.new_temp_block(\n-                    format!(\"enum-variant-iter-{}\", discr.to_string())[]\n+                    format!(\"enum-variant-iter-{}\", discr.to_string()).index(&FullRange)\n                 );\n                 let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n                 AddCase(llswitch, rhs_val, variant_cx.llbb);\n \n                 let fields = case.fields.iter().map(|&ty|\n                     type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n-                let real_ty = Type::struct_(ccx, fields[], case.packed);\n+                let real_ty = Type::struct_(ccx, fields.index(&FullRange), case.packed);\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n@@ -1051,14 +1051,14 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n             f.push_all(vals);\n-            let mut contents = build_const_struct(ccx, case, f[]);\n+            let mut contents = build_const_struct(ccx, case, f.index(&FullRange));\n             contents.push_all(&[padding(ccx, max_sz - case.size)]);\n-            C_struct(ccx, contents[], false)\n+            C_struct(ccx, contents.index(&FullRange), false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(ccx, contents[], st.packed)\n+            C_struct(ccx, contents.index(&FullRange), st.packed)\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             if discr == nndiscr {\n@@ -1072,7 +1072,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             if discr == nndiscr {\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals)[],\n+                                                 vals).index(&FullRange),\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n@@ -1082,7 +1082,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                 }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals[])[],\n+                                                 vals.index(&FullRange)).index(&FullRange),\n                          false)\n             }\n         }"}, {"sha": "890f046be1b2efd226c8e7c691711aae89c0e414", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -71,7 +71,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>();\n-    inputs.push_all(ext_inputs[]);\n+    inputs.push_all(ext_inputs.index(&FullRange));\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -91,18 +91,18 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         if !clobbers.is_empty() {\n             clobbers.push(',');\n         }\n-        clobbers.push_str(more_clobbers[]);\n+        clobbers.push_str(more_clobbers.index(&FullRange));\n     }\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n         constraints.push(',');\n-        constraints.push_str(clobbers[]);\n+        constraints.push_str(clobbers.index(&FullRange));\n     } else {\n-        constraints.push_str(clobbers[]);\n+        constraints.push_str(clobbers.index(&FullRange));\n     }\n \n-    debug!(\"Asm Constraints: {}\", constraints[]);\n+    debug!(\"Asm Constraints: {}\", constraints.index(&FullRange));\n \n     let num_outputs = outputs.len();\n \n@@ -112,7 +112,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     } else if num_outputs == 1 {\n         output_types[0]\n     } else {\n-        Type::struct_(bcx.ccx(), output_types[], false)\n+        Type::struct_(bcx.ccx(), output_types.index(&FullRange), false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "057d0f378e6f41cd37125b55aba7b0914b6530ab", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 99, "deletions": 81, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -249,7 +249,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     csearch::get_item_attrs(&ccx.sess().cstore, did, |attrs| {\n-        set_llvm_fn_attrs(ccx, attrs[], f)\n+        set_llvm_fn_attrs(ccx, attrs.index(&FullRange), f)\n     });\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n@@ -283,35 +283,40 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let fn_ty = monomorphize::normalize_associated_type(ccx.tcx(), &fn_ty);\n \n-    let (inputs, output, abi, env) = match fn_ty.sty {\n+    let function_type; // placeholder so that the memory ownership works out ok\n+\n+    let (sig, abi, env) = match fn_ty.sty {\n         ty::ty_bare_fn(_, ref f) => {\n-            (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, None)\n+            (&f.sig, f.abi, None)\n         }\n         ty::ty_unboxed_closure(closure_did, _, substs) => {\n             let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            let function_type = typer.unboxed_closure_type(closure_did, substs);\n+            function_type = typer.unboxed_closure_type(closure_did, substs);\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did, fn_ty);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n             debug!(\"decl_rust_fn: function_type={} self_type={}\",\n                    function_type.repr(ccx.tcx()),\n                    self_type.repr(ccx.tcx()));\n-            (function_type.sig.0.inputs,\n-             function_type.sig.0.output,\n-             RustCall,\n-             Some(llenvironment_type))\n+            (&function_type.sig, RustCall, Some(llenvironment_type))\n         }\n         _ => panic!(\"expected closure or fn\")\n     };\n \n-    let llfty = type_of_rust_fn(ccx, env, inputs[], output, abi);\n-    debug!(\"decl_rust_fn(input count={},type={})\",\n-           inputs.len(),\n+    let sig = ty::erase_late_bound_regions(ccx.tcx(), sig);\n+    let sig = ty::Binder(sig);\n+\n+    let llfty = type_of_rust_fn(ccx, env, &sig, abi);\n+\n+    debug!(\"decl_rust_fn(sig={}, type={})\",\n+           sig.repr(ccx.tcx()),\n            ccx.tn().type_to_string(llfty));\n \n-    let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, output);\n+    let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output /* (1) */);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n     attrs.apply_llfn(llfn);\n \n+    // (1) it's ok to directly access sig.0.output because we erased all late-bound-regions above\n+\n     llfn\n }\n \n@@ -369,7 +374,7 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Err(s) => {\n             bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n                                      bcx.ty_to_string(info_ty),\n-                                     s)[]);\n+                                     s).index(&FullRange));\n         }\n     }\n }\n@@ -488,7 +493,7 @@ pub fn unset_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n     if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym)[]);\n+        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).index(&FullRange));\n     }\n     ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n@@ -525,7 +530,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n-                      name[],\n+                      name.index(&FullRange),\n                       llvm::CCallConv,\n                       llty,\n                       dtor_ty)\n@@ -774,8 +779,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               format!(\"enum-iter-variant-{}\",\n-                                      variant.disr_val.to_string()[])\n-                                     []);\n+                                      variant.disr_val.to_string().index(&FullRange))\n+                                     .index(&FullRange));\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::SingleResult(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n@@ -800,7 +805,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n       }\n       _ => {\n           cx.sess().unimpl(format!(\"type in iter_structural_ty: {}\",\n-                                   ty_to_string(cx.tcx(), t))[])\n+                                   ty_to_string(cx.tcx(), t)).index(&FullRange))\n       }\n     }\n     return cx;\n@@ -882,7 +887,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         }\n         _ => {\n             cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_string(cx.tcx(), rhs_t))[]);\n+                                  ty_to_string(cx.tcx(), rhs_t)).index(&FullRange));\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -903,8 +908,8 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             ty::ty_int(t) => {\n                 let llty = Type::int_from_ty(cx.ccx(), t);\n                 let min = match t {\n-                    ast::TyI if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n-                    ast::TyI => i64::MIN as u64,\n+                    ast::TyIs if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n+                    ast::TyIs => i64::MIN as u64,\n                     ast::TyI8 => i8::MIN as u64,\n                     ast::TyI16 => i16::MIN as u64,\n                     ast::TyI32 => i32::MIN as u64,\n@@ -936,14 +941,14 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n-                    get_extern_rust_fn(ccx, t, name[], did)\n+                    get_extern_rust_fn(ccx, t, name.index(&FullRange), did)\n                 }\n                 RustIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n-                                                      name[])\n+                                                      name.index(&FullRange))\n                 }\n             }\n         }\n@@ -976,7 +981,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     if need_invoke(bcx) {\n-        debug!(\"invoking {} at {}\", bcx.val_to_string(llfn), bcx.llbb);\n+        debug!(\"invoking {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n         for &llarg in llargs.iter() {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n@@ -990,13 +995,13 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              llargs[],\n+                              llargs.index(&FullRange),\n                               normal_bcx.llbb,\n                               landing_pad,\n                               Some(attributes));\n         return (llresult, normal_bcx);\n     } else {\n-        debug!(\"calling {} at {}\", bcx.val_to_string(llfn), bcx.llbb);\n+        debug!(\"calling {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n         for &llarg in llargs.iter() {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n@@ -1006,7 +1011,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs[], Some(attributes));\n+        let llresult = Call(bcx, llfn, llargs.index(&FullRange), Some(attributes));\n         return (llresult, bcx);\n     }\n }\n@@ -1123,7 +1128,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match ccx.sess().target.target.target_word_size[] {\n+    let key = match ccx.sess().target.target.target_word_size.index(&FullRange) {\n         \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n         \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n@@ -1170,7 +1175,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llty = type_of::type_of(ccx, ty);\n \n-    let intrinsic_key = match ccx.sess().target.target.target_word_size[] {\n+    let intrinsic_key = match ccx.sess().target.target.target_word_size.index(&FullRange) {\n         \"32\" => \"llvm.memset.p0i8.i32\",\n         \"64\" => \"llvm.memset.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n@@ -1658,7 +1663,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n     let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => types[],\n+        ty::ty_tup(ref types) => types.index(&FullRange),\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1846,29 +1851,29 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n-                                  monomorphized_arg_types[])\n+                                  monomorphized_arg_types.index(&FullRange))\n     } else {\n         create_datums_for_fn_args_under_call_abi(\n             bcx,\n             arg_scope,\n-            monomorphized_arg_types[])\n+            monomorphized_arg_types.index(&FullRange))\n     };\n \n     bcx = match closure_env.kind {\n         closure::NotClosure | closure::BoxedClosure(..) => {\n             copy_args_to_allocas(&fcx,\n                                  arg_scope,\n                                  bcx,\n-                                 decl.inputs[],\n+                                 decl.inputs.index(&FullRange),\n                                  arg_datums)\n         }\n         closure::UnboxedClosure(..) => {\n             copy_unboxed_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n-                decl.inputs[],\n+                decl.inputs.index(&FullRange),\n                 arg_datums,\n-                monomorphized_arg_types[])\n+                monomorphized_arg_types.index(&FullRange))\n         }\n     };\n \n@@ -1938,7 +1943,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n-    let output_type = ty::ty_fn_ret(fn_ty);\n+    let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n     let abi = ty::ty_fn_abi(fn_ty);\n     trans_closure(ccx,\n                   decl,\n@@ -1981,11 +1986,13 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output.unwrap(),\n+        ty::ty_bare_fn(_, ref bft) => {\n+            ty::erase_late_bound_regions(bcx.tcx(), &bft.sig.output()).unwrap()\n+        }\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx))[])\n+                     ctor_ty.repr(tcx)).index(&FullRange))\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -2008,7 +2015,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n                                       disr,\n-                                      fields[],\n+                                      fields.index(&FullRange),\n                                       None,\n                                       expr::SaveIn(llresult),\n                                       call_info);\n@@ -2053,11 +2060,13 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output,\n+        ty::ty_bare_fn(_, ref bft) => {\n+            ty::erase_late_bound_regions(ccx.tcx(), &bft.sig.output())\n+        }\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_string(ccx.tcx(), ctor_ty))[])\n+                    ty_to_string(ccx.tcx(), ctor_ty)).index(&FullRange))\n     };\n \n     let arena = TypedArena::new();\n@@ -2067,9 +2076,11 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    let arg_tys = ty::ty_fn_args(ctor_ty);\n+    let arg_tys =\n+        ty::erase_late_bound_regions(\n+            ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys[]);\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.index(&FullRange));\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n@@ -2155,7 +2166,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n                             *lvlsrc.unwrap(), Some(sp),\n                             format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest)[]);\n+                                    largest).index(&FullRange));\n \n         ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n@@ -2239,7 +2250,7 @@ pub fn update_linkage(ccx: &CrateContext,\n     if let Some(id) = id {\n         let item = ccx.tcx().map.get(id);\n         if let ast_map::NodeItem(i) = item {\n-            if let Some(name) = attr::first_attr_value_str_by_name(i.attrs[], \"linkage\") {\n+            if let Some(name) = attr::first_attr_value_str_by_name(i.attrs.as_slice(), \"linkage\") {\n                 if let Some(linkage) = llvm_linkage_by_name(name.get()) {\n                     llvm::SetLinkage(llval, linkage);\n                 } else {\n@@ -2273,7 +2284,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let trans_everywhere = attr::requests_inline(item.attrs[]);\n+            let trans_everywhere = attr::requests_inline(item.attrs.index(&FullRange));\n             // Ignore `trans_everywhere` for cross-crate inlined items\n             // (`from_external`).  `trans_item` will be called once for each\n             // compilation unit that references the item, so it will still get\n@@ -2284,7 +2295,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n-                                                            item.attrs[],\n+                                                            item.attrs.index(&FullRange),\n                                                             llfn,\n                                                             &Substs::trans_empty(),\n                                                             item.id,\n@@ -2296,7 +2307,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                              llfn,\n                              &Substs::trans_empty(),\n                              item.id,\n-                             item.attrs[]);\n+                             item.attrs.index(&FullRange));\n                 }\n                 update_linkage(ccx,\n                                llfn,\n@@ -2313,7 +2324,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n                          item.ident,\n-                         impl_items[],\n+                         impl_items.index(&FullRange),\n                          generics,\n                          item.id);\n       }\n@@ -2343,7 +2354,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(item.attrs[], \"static_assert\") {\n+          if attr::contains_name(item.attrs.index(&FullRange), \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess().span_fatal(expr.span,\n                                         \"cannot have static_assert on a mutable \\\n@@ -2420,55 +2431,58 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected bare rust fn\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, node_type, sym[]);\n+    let llfn = decl_rust_fn(ccx, node_type, sym.index(&FullRange));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n \n pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>)\n-                                        -> llvm::AttrBuilder {\n+                                        -> llvm::AttrBuilder\n+{\n     use middle::ty::{BrAnon, ReLateBound};\n \n+    let function_type;\n     let (fn_sig, abi, has_env) = match fn_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => (f.sig.clone(), f.abi, false),\n+        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _, substs) => {\n             let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            let function_type = typer.unboxed_closure_type(closure_did, substs);\n-            (function_type.sig, RustCall, true)\n+            function_type = typer.unboxed_closure_type(closure_did, substs);\n+            (&function_type.sig, RustCall, true)\n         }\n         _ => ccx.sess().bug(\"expected closure or function.\")\n     };\n \n+    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n \n     // Since index 0 is the return value of the llvm func, we start\n     // at either 1 or 2 depending on whether there's an env slot or not\n     let mut first_arg_offset = if has_env { 2 } else { 1 };\n     let mut attrs = llvm::AttrBuilder::new();\n-    let ret_ty = fn_sig.0.output;\n+    let ret_ty = fn_sig.output;\n \n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_ty.sty {\n         ty::ty_unboxed_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n-            match fn_sig.0.inputs[0].sty {\n+            match fn_sig.inputs[0].sty {\n                 ty::ty_tup(ref inputs) => inputs.clone(),\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n         ty::ty_bare_fn(..) if abi == RustCall => {\n-            let mut inputs = vec![fn_sig.0.inputs[0]];\n+            let mut inputs = vec![fn_sig.inputs[0]];\n \n-            match fn_sig.0.inputs[1].sty {\n+            match fn_sig.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(t_in[]);\n+                    inputs.push_all(t_in.index(&FullRange));\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         }\n-        _ => fn_sig.0.inputs.clone()\n+        _ => fn_sig.inputs.clone()\n     };\n \n     if let ty::FnConverging(ret_ty) = ret_ty {\n@@ -2597,7 +2611,11 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx, sym[], cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    let llfn = decl_fn(ccx,\n+                       sym.index(&FullRange),\n+                       cc,\n+                       llfty,\n+                       ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2650,7 +2668,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(s[]); }\n+                    Err(s) => { ccx.sess().fatal(s.index(&FullRange)); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -2738,11 +2756,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     }\n \n     let item = ccx.tcx().map.get(id);\n-    debug!(\"get_item_val: id={} item={}\", id, item);\n+    debug!(\"get_item_val: id={} item={:?}\", id, item);\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = |&:| exported_name(ccx, id, ty, i.attrs[]);\n+            let sym = |&:| exported_name(ccx, id, ty, i.attrs.index(&FullRange));\n \n             let v = match i.node {\n                 ast::ItemStatic(_, _, ref expr) => {\n@@ -2765,16 +2783,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(sym[]) {\n+                        if contains_null(sym.index(&FullRange)) {\n                             ccx.sess().fatal(\n                                 format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym)[]);\n+                                         value: `{}`\", sym).index(&FullRange));\n                         }\n                         let buf = CString::from_slice(sym.as_bytes());\n                         let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n                                                     buf.as_ptr());\n \n-                        if attr::contains_name(i.attrs[],\n+                        if attr::contains_name(i.attrs.index(&FullRange),\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n@@ -2799,19 +2817,19 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, i.attrs[], llfn);\n+                    set_llvm_fn_attrs(ccx, i.attrs.index(&FullRange), llfn);\n                     llfn\n                 }\n \n                 _ => panic!(\"get_item_val: weird result in table\")\n             };\n \n-            match attr::first_attr_value_str_by_name(i.attrs[],\n+            match attr::first_attr_value_str_by_name(i.attrs.index(&FullRange),\n                                                      \"link_section\") {\n                 Some(sect) => {\n                     if contains_null(sect.get()) {\n                         ccx.sess().fatal(format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 sect.get())[]);\n+                                                 sect.get()).index(&FullRange));\n                     }\n                     unsafe {\n                         let buf = CString::from_slice(sect.get().as_bytes());\n@@ -2854,7 +2872,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get()[])\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get().index(&FullRange))\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, &*ni)\n@@ -2877,7 +2895,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    enm.attrs[]);\n+                                    enm.attrs.index(&FullRange));\n \n             llfn = match enm.node {\n                 ast::ItemEnum(_, _) => {\n@@ -2905,16 +2923,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                     id,\n                                     ty,\n                                     struct_item.attrs\n-                                               []);\n+                                               .index(&FullRange));\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n             set_inline_hint(llfn);\n             llfn\n         }\n \n         ref variant => {\n-            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {}\",\n-                                   variant)[])\n+            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n+                                   variant).index(&FullRange))\n         }\n     };\n \n@@ -2935,10 +2953,10 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, m.attrs[]);\n+    let sym = exported_name(ccx, id, mty, m.attrs.index(&FullRange));\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(ccx, m.attrs[], llfn);\n+    set_llvm_fn_attrs(ccx, m.attrs.index(&FullRange), llfn);\n     llfn\n }\n \n@@ -2977,7 +2995,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n         Some(compressed) => compressed,\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n     }.as_slice());\n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed[]);\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.index(&FullRange));\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n@@ -3106,7 +3124,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(link_meta.crate_name[],\n+    let shared_ccx = SharedCrateContext::new(link_meta.crate_name.index(&FullRange),\n                                              codegen_units,\n                                              tcx,\n                                              export_map,\n@@ -3208,7 +3226,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         llmod: shared_ccx.metadata_llmod(),\n     };\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n-    let no_builtins = attr::contains_name(krate.attrs[], \"no_builtins\");\n+    let no_builtins = attr::contains_name(krate.attrs.index(&FullRange), \"no_builtins\");\n \n     let translation = CrateTranslation {\n         modules: modules,"}, {"sha": "d0eaf799af1bd04a41103f123cbce80eb5311acb", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -552,11 +552,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n-            self.inbounds_gep(base, small_vec[..ixs.len()])\n+            self.inbounds_gep(base, small_vec.index(&(0..ixs.len())))\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, v[])\n+            self.inbounds_gep(base, v.index(&FullRange))\n         }\n     }\n \n@@ -764,8 +764,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let s = format!(\"{} ({})\",\n                             text,\n                             self.ccx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", s[]);\n-            self.add_comment(s[]);\n+            debug!(\"{}\", s.index(&FullRange));\n+            self.add_comment(s.index(&FullRange));\n         }\n     }\n \n@@ -802,7 +802,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n-        let fty = Type::func(argtys[], &output);\n+        let fty = Type::func(argtys.index(&FullRange), &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);"}, {"sha": "a901142467b8debfa535b1133190ca84d962fd34", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -108,7 +108,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match ccx.sess().target.target.arch[] {\n+    match ccx.sess().target.target.arch.index(&FullRange) {\n         \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n             cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n@@ -119,6 +119,6 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, atys, rty, ret_def),\n         \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n         a => ccx.sess().fatal((format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n-                              []),\n+                              .index(&FullRange)),\n     }\n }"}, {"sha": "f40072d1cba3eb33597ecba6aa76da7ebdefe023", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -318,7 +318,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                 tys.push(Type::i64(ccx));\n             }\n             SSEFv => {\n-                let vec_len = llvec_len(cls[i + 1u..]);\n+                let vec_len = llvec_len(cls.index(&((i + 1u)..)));\n                 let vec_ty = Type::vector(&Type::f32(ccx), (vec_len * 2u) as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "b7b486f1d0a52239b329a29560259afd30f818c5", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -114,7 +114,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     expr.span,\n                     format!(\"type of callee is neither bare-fn nor closure: \\\n                              {}\",\n-                            bcx.ty_to_string(datum.ty))[]);\n+                            bcx.ty_to_string(datum.ty)).index(&FullRange));\n             }\n         }\n     }\n@@ -206,8 +206,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             def::DefSelfTy(..) | def::DefAssociatedPath(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n-                    format!(\"cannot translate def {} \\\n-                             to a callable thing!\", def)[]);\n+                    format!(\"cannot translate def {:?} \\\n+                             to a callable thing!\", def).index(&FullRange));\n             }\n         }\n     }\n@@ -223,7 +223,7 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let substs = node_id_substs(ccx, node, param_substs);\n-    debug!(\"trans_fn_ref(def_id={}, node={}, substs={})\",\n+    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n            def_id.repr(ccx.tcx()),\n            node,\n            substs.repr(ccx.tcx()));\n@@ -265,7 +265,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n-    let bare_fn_ty = ty::normalize_ty(tcx, bare_fn_ty);\n+    let bare_fn_ty = normalize_ty(tcx, bare_fn_ty);\n     match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n         Some(&llval) => { return llval; }\n         None => { }\n@@ -279,24 +279,22 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let (opt_def_id, input_tys, output_ty) =\n+    let (opt_def_id, sig) =\n         match bare_fn_ty.sty {\n             ty::ty_bare_fn(opt_def_id,\n                            &ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n-                                          abi: synabi::Rust,\n-                                          sig: ty::Binder(ty::FnSig { inputs: ref input_tys,\n-                                                                      output: output_ty,\n-                                                                      variadic: false })}) =>\n-            {\n-                (opt_def_id, input_tys, output_ty)\n+                                           abi: synabi::Rust,\n+                                           ref sig }) => {\n+                (opt_def_id, sig)\n             }\n \n             _ => {\n                 tcx.sess.bug(format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx))[]);\n+                                           bare_fn_ty.repr(tcx)).index(&FullRange));\n             }\n         };\n-    let tuple_input_ty = ty::mk_tup(tcx, input_tys.to_vec());\n+    let sig = ty::erase_late_bound_regions(tcx, sig);\n+    let tuple_input_ty = ty::mk_tup(tcx, sig.inputs.to_vec());\n     let tuple_fn_ty = ty::mk_bare_fn(tcx,\n                                      opt_def_id,\n                                      tcx.mk_bare_fn(ty::BareFnTy {\n@@ -305,7 +303,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                          sig: ty::Binder(ty::FnSig {\n                                              inputs: vec![bare_fn_ty_ref,\n                                                           tuple_input_ty],\n-                                             output: output_ty,\n+                                             output: sig.output,\n                                              variadic: false\n                                          })}));\n     debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n@@ -317,7 +315,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx,\n                               tuple_fn_ty,\n-                              function_name[]);\n+                              function_name.index(&FullRange));\n \n     //\n     let block_arena = TypedArena::new();\n@@ -326,36 +324,36 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                           llfn,\n                           ast::DUMMY_NODE_ID,\n                           false,\n-                          output_ty,\n+                          sig.output,\n                           &empty_substs,\n                           None,\n                           &block_arena);\n-    let mut bcx = init_function(&fcx, false, output_ty);\n+    let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be ptr to the the fn pointer\n     let llfnpointer =\n         Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32));\n \n     // the remaining arguments will be the untupled values\n     let llargs: Vec<_> =\n-        input_tys.iter()\n+        sig.inputs.iter()\n         .enumerate()\n         .map(|(i, _)| get_param(fcx.llfn, fcx.arg_pos(i+1) as u32))\n         .collect();\n     assert!(!fcx.needs_ret_allocas);\n \n     let dest = fcx.llretslotptr.get().map(|_|\n-        expr::SaveIn(fcx.get_ret_slot(bcx, output_ty, \"ret_slot\"))\n+        expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\"))\n     );\n \n     bcx = trans_call_inner(bcx,\n                            None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(llargs[]),\n+                           ArgVals(llargs.index(&FullRange)),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, output_ty);\n+    finish_fn(&fcx, bcx, sig.output);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n \n@@ -386,7 +384,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(def_id={}, node={}, \\\n+    debug!(\"trans_fn_ref_with_substs(def_id={}, node={:?}, \\\n             param_substs={}, substs={})\",\n            def_id.repr(tcx),\n            node,\n@@ -668,7 +666,10 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => (f.abi, f.sig.0.output),\n+        ty::ty_bare_fn(_, ref f) => {\n+            let output = ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output());\n+            (f.abi, output)\n+        }\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n \n@@ -775,7 +776,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n                                       llfn,\n-                                      llargs[],\n+                                      llargs.index(&FullRange),\n                                       callee_ty,\n                                       call_info);\n         bcx = b;\n@@ -814,7 +815,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         bcx = foreign::trans_native_call(bcx, callee_ty,\n                                          llfn, opt_llretslot.unwrap(),\n-                                         llargs[], arg_tys);\n+                                         llargs.index(&FullRange), arg_tys);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);\n@@ -865,13 +866,18 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n                              ignore_self: bool)\n-                             -> Block<'blk, 'tcx> {\n+                             -> Block<'blk, 'tcx>\n+{\n+    let args =\n+        ty::erase_late_bound_regions(\n+            bcx.tcx(), &ty::ty_fn_args(fn_ty));\n+\n     // Translate the `self` argument first.\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n-                            ty::ty_fn_args(fn_ty)[0],\n+                            args[0],\n                             arg_datum,\n                             arg_cleanup_scope,\n                             DontAutorefArg)\n@@ -926,7 +932,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                               ignore_self: bool)\n                               -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n-    let arg_tys = ty::ty_fn_args(fn_ty);\n+    let arg_tys = ty::erase_late_bound_regions(bcx.tcx(),  &ty::ty_fn_args(fn_ty));\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n@@ -974,7 +980,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n-    let arg_tys = ty::ty_fn_args(fn_ty);\n+    let arg_tys = ty::erase_late_bound_regions(cx.tcx(), &ty::ty_fn_args(fn_ty));\n     let variadic = ty::fn_is_variadic(fn_ty);\n \n     let mut bcx = cx;"}, {"sha": "92a96cd02b501c67f64af211a42772724a82e2ea", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -24,8 +24,7 @@ use trans::common;\n use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n use trans::debuginfo;\n use trans::glue;\n-// Temporary due to slicing syntax hacks (KILLME)\n-//use middle::region;\n+use middle::region;\n use trans::type_::Type;\n use middle::ty::{self, Ty};\n use std::fmt;\n@@ -129,16 +128,15 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         // excluding id's that correspond to closure bodies only). For\n         // now we just say that if there is already an AST scope on the stack,\n         // this new AST scope had better be its immediate child.\n-        // Temporarily removed due to slicing syntax hacks (KILLME).\n-        /*let top_scope = self.top_ast_scope();\n+        let top_scope = self.top_ast_scope();\n         if top_scope.is_some() {\n             assert_eq!(self.ccx\n                            .tcx()\n                            .region_maps\n                            .opt_encl_scope(region::CodeExtent::from_node_id(debug_loc.id))\n                            .map(|s|s.node_id()),\n                        top_scope);\n-        }*/\n+        }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n                                           Some(debug_loc)));\n@@ -229,7 +227,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                           bcx: Block<'blk, 'tcx>,\n                                           custom_scope: CustomScopeIndex)\n                                           -> Block<'blk, 'tcx> {\n-        debug!(\"pop_and_trans_custom_cleanup_scope({})\", custom_scope);\n+        debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n         assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n \n         let scope = self.pop_scope();\n@@ -267,7 +265,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             ptr: val,\n         };\n \n-        debug!(\"schedule_lifetime_end({}, val={})\",\n+        debug!(\"schedule_lifetime_end({:?}, val={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val));\n \n@@ -288,7 +286,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: false\n         };\n \n-        debug!(\"schedule_drop_mem({}, val={}, ty={})\",\n+        debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n@@ -310,7 +308,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: true\n         };\n \n-        debug!(\"schedule_drop_and_zero_mem({}, val={}, ty={}, zero={})\",\n+        debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n@@ -334,7 +332,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: false\n         };\n \n-        debug!(\"schedule_drop_immediate({}, val={}, ty={})\",\n+        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n@@ -350,7 +348,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                            content_ty: Ty<'tcx>) {\n         let drop = box FreeValue { ptr: val, heap: heap, content_ty: content_ty };\n \n-        debug!(\"schedule_free_value({}, val={}, heap={})\",\n+        debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                heap);\n@@ -367,7 +365,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                            heap: Heap) {\n         let drop = box FreeSlice { ptr: val, size: size, align: align, heap: heap };\n \n-        debug!(\"schedule_free_slice({}, val={}, heap={})\",\n+        debug!(\"schedule_free_slice({:?}, val={}, heap={:?})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                heap);\n@@ -406,7 +404,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope))[]);\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope)).index(&FullRange));\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -551,7 +549,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n     fn trans_cleanups_to_exit_scope(&'blk self,\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef {\n-        debug!(\"trans_cleanups_to_exit_scope label={} scopes={}\",\n+        debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\",\n                label, self.scopes_len());\n \n         let orig_scopes_len = self.scopes_len();\n@@ -588,7 +586,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     LoopExit(id, _) => {\n                         self.ccx.sess().bug(format!(\n                                 \"cannot exit from scope {}, \\\n-                                not in scope\", id)[]);\n+                                not in scope\", id).index(&FullRange));\n                     }\n                 }\n             }\n@@ -657,7 +655,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n                 let bcx_in = self.new_block(label.is_unwind(),\n-                                            name[],\n+                                            name.index(&FullRange),\n                                             None);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n@@ -677,7 +675,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n             self.push_scope(scope);\n         }\n \n-        debug!(\"trans_cleanups_to_exit_scope: prev_llbb={}\", prev_llbb);\n+        debug!(\"trans_cleanups_to_exit_scope: prev_llbb={:?}\", prev_llbb);\n \n         assert_eq!(self.scopes_len(), orig_scopes_len);\n         prev_llbb\n@@ -704,7 +702,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => { return llbb; }\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, name[], None);\n+                    pad_bcx = self.new_block(true, name.index(&FullRange), None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }\n@@ -1020,12 +1018,12 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n     match tcx.region_maps.temporary_scope(id) {\n         Some(scope) => {\n             let r = AstScope(scope.node_id());\n-            debug!(\"temporary_scope({}) = {}\", id, r);\n+            debug!(\"temporary_scope({}) = {:?}\", id, r);\n             r\n         }\n         None => {\n             tcx.sess.bug(format!(\"no temporary scope available for expr {}\",\n-                                 id)[])\n+                                 id).index(&FullRange))\n         }\n     }\n }\n@@ -1034,7 +1032,7 @@ pub fn var_scope(tcx: &ty::ctxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n     let r = AstScope(tcx.region_maps.var_scope(id).node_id());\n-    debug!(\"var_scope({}) = {}\", id, r);\n+    debug!(\"var_scope({}) = {:?}\", id, r);\n     r\n }\n "}, {"sha": "ad2ed67b22c9a315bf4ed3be04e80ce014076da3", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -108,7 +108,7 @@ pub struct EnvValue<'tcx> {\n \n impl<'tcx> EnvValue<'tcx> {\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"{}({})\", self.action, self.datum.to_string(ccx))\n+        format!(\"{:?}({})\", self.action, self.datum.to_string(ccx))\n     }\n }\n \n@@ -154,7 +154,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, bound_values[]);\n+    let cdata_ty = mk_closure_tys(tcx, bound_values.index(&FullRange));\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -183,7 +183,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         if ccx.sess().asm_comments() {\n             add_comment(bcx, format!(\"Copy {} into closure\",\n-                                     bv.to_string(ccx))[]);\n+                                     bv.to_string(ccx)).index(&FullRange));\n         }\n \n         let bound_data = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_BODY, i]);\n@@ -420,7 +420,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let s = tcx.map.with_path(id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n-    let llfn = decl_internal_rust_fn(ccx, fty, s[]);\n+    let llfn = decl_internal_rust_fn(ccx, fty, s.index(&FullRange));\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -442,9 +442,9 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   bcx.fcx.param_substs,\n                   id,\n                   &[],\n-                  ty::ty_fn_ret(fty),\n+                  ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fty)),\n                   ty::ty_fn_abi(fty),\n-                  ClosureEnv::new(freevars[],\n+                  ClosureEnv::new(freevars.index(&FullRange),\n                                   BoxedClosure(cdata_ty, store)));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n@@ -466,7 +466,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n \n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let function_type = ty::normalize_ty(ccx.tcx(), function_type);\n+    let function_type = normalize_ty(ccx.tcx(), function_type);\n     let params = match function_type.sty {\n         ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n         _ => unreachable!()\n@@ -489,13 +489,13 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, symbol[]);\n+    let llfn = decl_internal_rust_fn(ccx, function_type, symbol.index(&FullRange));\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n     debug!(\"get_or_create_declaration_if_unboxed_closure(): inserting new \\\n-            closure {} (type {})\",\n+            closure {:?} (type {})\",\n            mono_id,\n            ccx.tn().type_to_string(val_ty(llfn)));\n     ccx.unboxed_closure_vals().borrow_mut().insert(mono_id, llfn);\n@@ -533,16 +533,18 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n     let freevar_mode = bcx.tcx().capture_mode(id);\n \n+    let sig = ty::erase_late_bound_regions(bcx.tcx(), &function_type.sig);\n+\n     trans_closure(bcx.ccx(),\n                   decl,\n                   body,\n                   llfn.val,\n                   bcx.fcx.param_substs,\n                   id,\n                   &[],\n-                  function_type.sig.0.output,\n+                  sig.output,\n                   function_type.abi,\n-                  ClosureEnv::new(freevars[],\n+                  ClosureEnv::new(freevars.index(&FullRange),\n                                   UnboxedClosure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n@@ -579,3 +581,4 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n \n     bcx\n }\n+"}, {"sha": "237fc1856369b7306e025ce9a89ff83075918542", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "b0474d7e011a5fcc17e8d8a3788cb4de41acdb19", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "35fb34eafb4d02a8a6312a21873652dfc315d3a6", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "38d40a8322f900ae728f9ebe899d08b310f63fe8", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "26518d4092fa3d7b2710d5b38760ba5356cf0100", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "e2e1b3a799bfc82f0cbce46786b8dec5171291c7", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 120, "deletions": 107, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "120e2e955e4be5a000fa94542139935c762433ce", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 52, "deletions": 76, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "25eb66ab2eb7311c3abf70880a0e00470b955ee2", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "52e7a986d7e988a17222cecbad342ef59fe928c8", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "ed75445b9939be9b1266334364a9e229c827e244", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "c618889f3f5dca438b951f744f003219d0200426", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "42134789546958bbb3d2a47d835bfc0e6126a4bc", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "e2594765f4fdaaa929286bec3529642466a168b2", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "66e27ed1188f3618375dfc17cb1fce744fdedca1", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "19d50cdd48320ab0b3c4d75967ad62bfa22d2051", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "265ebe00d539fe807441720b88f748f1b030a0c1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "363ce459b3fe92f9989a9cda065da8ee781bd2a0", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "dff216ac2935f99ff386fb77b2cca799adbc5385", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "0079115756993771f4a5cb7b26f1db59b1779f23", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "2471bc85bc9380df50fd30c1d5a27b5bd2ea60f2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "87ea082b6b20b5b1a8a615977afb6edfe716c7bd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "4ba161fa83563af1d670b32f62878de083087a76", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "9563dd45ca23444a4ba77f3c706b4f10be2176d6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 89, "deletions": 213, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "11ad7bcb0915927e9697eb1dc5156a39ef1b26a9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "84d94b0392e9df33be97a4fab3d0c9d7e49f5e1a", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "ec44d765a8e683d5de02b7072414b8781428c75a", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "e302609bf228b52160820ae0faa461914addd6fc", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "84823b0fd57da9c2d4dd7d1f174c61a6793b4adb", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "82da22eab98373c137a107e4881c89193f02b56b", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "a0f30788bbddcc72cba8f5129641a427fa4db5ef", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "79e98f15a2d43daf7a4a609886f632debf61542e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 117, "deletions": 19, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "ae8731dfa476b1e4e20ab0c101f6826906d25b97", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "393ba19ba182ab2ae54f0f048dd11a6a5f11b06b", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "3e2474468adb696c8edc83717f67794a538c0973", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "bf2664bba6ad3b973442ccb637bf4b905c5506da", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "46c212a9f2dbcc4dab77ec64754ce8abf4d07925", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "99cd467cdfccca508e9921b68c35d7a8828f66ba", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "b24e7a7a4cf81a06d6fb25572293a787c1c56b5f", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 202, "deletions": 9, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "3d2c5e2cbb5fb4d933455b5744c1636362518e33", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "13a06f842a2767111f6882327797a4a4b3180736", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "f75ab3f431c2a23455f6a471fa2f814e3711b506", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "f4660a81be496e315ce4fd92b44873091f21094e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "08abdc2af18dc24c435e58f76b29f44be90cae57", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "8d94e1857c41713af3559a01fb71f27693c4b8b1", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "ee65ef0662305a7bf99a4a3cbd145400d8eea2f4", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "bbe35eb0e9ccc53e8b6c7fe1673ee088323941ec", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "428b4e92a681f18dbb77154424347809b319a03b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "d13d110320e1754302d4c2664d3a20a3acffb860", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "d89a4754d2efe0af8ccb921ed5a523e5795910c1", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "f2d79b133469958d48a5a3d8b3519871b5f494c0", "filename": "src/libserialize/collection_impls_stage0.rs", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibserialize%2Fcollection_impls_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibserialize%2Fcollection_impls_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls_stage0.rs?ref=ea6f65c5f1a3f84e010d2cef02a0160804e9567a"}, {"sha": "a11eb3f789875563904e24a1c57fb491f3dcce3a", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "b7bf40a6ec52dc685494b03137a7382e00e31e77", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 142, "deletions": 112, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "a157d9172749855309f8ab4143cd96957d1dfab8", "filename": "src/libserialize/json_stage0.rs", "status": "removed", "additions": 0, "deletions": 3862, "changes": 3862, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibserialize%2Fjson_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibserialize%2Fjson_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson_stage0.rs?ref=ea6f65c5f1a3f84e010d2cef02a0160804e9567a"}, {"sha": "139170fc012cb59d869ab95f93cde444c84cd778", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "7b6ca10669df6036022f49518cff9c2f33709229", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "fd37bb63230af40d1bc0332328d6f03cc2912845", "filename": "src/libserialize/serialize_stage0.rs", "status": "removed", "additions": 0, "deletions": 629, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibserialize%2Fserialize_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibserialize%2Fserialize_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize_stage0.rs?ref=ea6f65c5f1a3f84e010d2cef02a0160804e9567a"}, {"sha": "5764962b51b02162367f2031e4f90976f9fa2e9d", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "2011c03c773d2598d980ef6461dde3e45565f334", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "f66e538494248a7305935c50df5a32efc0f90391", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "6eb98da4da46e7c0223773cf4f88d8a3ee4ae436", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "9b2a4926bcb925cc985dcb1cdacaacb7d6c61bdf", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "9963e4861b778772967f4274a1e59ac6aee39a49", "filename": "src/libstd/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "50538d3e43def43f5df8407a74cc061acd563bd8", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "14b80045a9ac646a26c2103b8a774cc3c6bc9a27", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "69e7e429d07da01b5d7726415d17f08b1163d626", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "74c503e6f2ba8e26c3d6defd7e4e3d2184a7cd7c", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "bce097e17ef0f8d9573331194830bd5de399c530", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "eadca8e42e5505b7305e4097a193c60a74249402", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "9a6ad04fdbc3eb1687fd43494cde57376d446c6f", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "9ef9081bc3c848e443ce6921ca52772dc077b17b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "7825a4e16e161d5b0a46c46f386e9ccea7be772a", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "b9f653f86c2b0b514fd6aee236feacb79671d26b", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "29295b5751cd4c92aec5c684ac8b8106d057a9d6", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "7a376b50cd7dd9ad8705684c93bb89bfee84b263", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "55df6330dd33c463bec0e55d5d005b3573651fb8", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "9ee2f5705b82824ebd2110814539004795037b4d", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "8a0445be47135775ba1483c0371457c231785eed", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "c0254a3e7a205a01382c9e9c649f79822348de10", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "eef5bdb60eeaae2fe7cc6f448c9739c8237b5165", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "befdc156094d18406d32d754c5e36966c21254f7", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "48d62e73e13edeba26b4b7f7907dc6a23716bb65", "filename": "src/libstd/macros_stage0.rs", "status": "removed", "additions": 0, "deletions": 648, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibstd%2Fmacros_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src%2Flibstd%2Fmacros_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros_stage0.rs?ref=ea6f65c5f1a3f84e010d2cef02a0160804e9567a"}, {"sha": "f433cd1e664811947fd6b771e08962a53e7306cc", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "cef85c260a7e570d1a5908b18e8e7482374fc685", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "581969e98fb8bec5d905f8534fd5bb62a8335599", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "0b7dc19fcab4e0be31d6d57be9c64db670368ef7", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "5c4e7aa9ac27b6fe4b6224c53cdc433d487498fa", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 117, "deletions": 138, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "dcb342b9ca2c3dec35b06f76434c9b42fb5f8f37", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "d3e6cd166ecf5e7916d736e1388b2f56c71e0308", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "18d40ecd3ebe54f6e1003f1627f236a7f4790703", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "177b7380831f2d450c4904c67aef7711c408385c", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "1e3ab6d34dab9daecb05e14357c99ce7413e7a6b", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "5ef55f5b487d0ad07563d5efe2b3485c32d1076f", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "fd84f22094282a4a7d203c7d444e623e4f2c3ff8", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "59f654a95caa6e9f2e07fed18c3dc080e604cb5f", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "709398794003869abb034616fdc6fa793d98b64b", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "3c0ae71255dbe39632a8485ee04836e793bf832d", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "568c24446e7a34d9c9059fa302689054913ce221", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "f174771a3e011527a03f052b4252c8705549cdbc", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "eca7d3155b18be2983b1682d4922ec347267a98e", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "f8eae1322bf1f7b9bbeb5e2c6b38d870d6c1a018", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "b7bb22b3ef3147ea94304e90554b1752ae8643da", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "b2cc807eb111d51879b19067a357de57ce01b462", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "c1b55c6ff78db3b3f91bc0201f7994f8e428b29c", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "3bf2ae277e0df10f89913db4e0f48e4f14c6374f", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "7db2111cc4629eed04b5fa749498bf5db000305e", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}, {"sha": "8d44084671aad2c61c3a77ad42b8021ec5606aaf", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6"}]}