{"sha": "152f385055510c65bd94238878be23a258f5cc19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MmYzODUwNTU1MTBjNjViZDk0MjM4ODc4YmUyM2EyNThmNWNjMTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-16T05:48:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-16T05:48:05Z"}, "message": "Merge #8044\n\n8044: Fix macro expansion for statements w/o semicolon r=edwin0cheng a=edwin0cheng\n\nFixes  #7845\r\n\r\nAnd up `ungrammer` to  1.12.\r\n\r\ncc @jonas-schievink \r\n\r\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "e8470eb83c1bc1283f0bb28ea01db789607a3140", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8470eb83c1bc1283f0bb28ea01db789607a3140"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/152f385055510c65bd94238878be23a258f5cc19", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgUEaVCRBK7hj4Ov3rIwAAdHIIAFM33rSSJOa+nBmQ/sBf96X+\nZ+HmLZ7bTuZlRXCkuF6XaOKAqYkSACNBr6XfwqvINFTQQJjuzEorCJbfbBdndEvl\nvE/X2NHfSpNOgX/fEcOSe9tHaO6tCDRt7Hs83W4iajz47xpQdEN8U3Kxf5AZfvhQ\nhITqBXM9uZJfA3kMixJAppn9Y9YTASQ/Vw0/GfQ86eiuSccBtiBzGpN8Tvlqu+Yx\naePOOKNo5ZrgHCgC9wm00+uKYSxwh7dQhTIXO1gbUhsMStz9YPSdeh+OaSoBoSHZ\nWenDREbA7n+UxgWjKe+hKmUix+k/MZ/B7qP4y3TTMY4N2aNLjVtuBbCV6srp948=\n=Uuxb\n-----END PGP SIGNATURE-----\n", "payload": "tree e8470eb83c1bc1283f0bb28ea01db789607a3140\nparent c0a2b4e826e1da20d3cfa8c279fcdffa24f32a7d\nparent 8e07b23b84bff16c0decc6f2b80c27862eac6df1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615873685 +0000\ncommitter GitHub <noreply@github.com> 1615873685 +0000\n\nMerge #8044\n\n8044: Fix macro expansion for statements w/o semicolon r=edwin0cheng a=edwin0cheng\n\nFixes  #7845\r\n\r\nAnd up `ungrammer` to  1.12.\r\n\r\ncc @jonas-schievink \r\n\r\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/152f385055510c65bd94238878be23a258f5cc19", "html_url": "https://github.com/rust-lang/rust/commit/152f385055510c65bd94238878be23a258f5cc19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/152f385055510c65bd94238878be23a258f5cc19/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0a2b4e826e1da20d3cfa8c279fcdffa24f32a7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a2b4e826e1da20d3cfa8c279fcdffa24f32a7d", "html_url": "https://github.com/rust-lang/rust/commit/c0a2b4e826e1da20d3cfa8c279fcdffa24f32a7d"}, {"sha": "8e07b23b84bff16c0decc6f2b80c27862eac6df1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e07b23b84bff16c0decc6f2b80c27862eac6df1", "html_url": "https://github.com/rust-lang/rust/commit/8e07b23b84bff16c0decc6f2b80c27862eac6df1"}], "stats": {"total": 168, "additions": 103, "deletions": 65}, "files": [{"sha": "2efae6a014db80f5052ae27b8531c5e99cd792ac", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -1811,9 +1811,9 @@ checksum = \"56dee185309b50d1f11bfedef0fe6d036842e3fb77413abef29f8f8d1c5d4c1c\"\n \n [[package]]\n name = \"ungrammar\"\n-version = \"1.11.0\"\n+version = \"1.12.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"84c629795d377049f2a1dc5f42cf505dc5ba8b28a5df0a03f4183a24480e4a6a\"\n+checksum = \"df6586a7c530704efe803d49a0b4132dcbdb4063163df39110548e6b5f2373ba\"\n \n [[package]]\n name = \"unicase\""}, {"sha": "7052058f2a1507a300160c953540b8234b2612bd", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 58, "deletions": 47, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -519,21 +519,33 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::MacroCall(e) => {\n                 let mut ids = vec![];\n-                self.collect_macro_call(e, syntax_ptr.clone(), |this, expansion| {\n+                self.collect_macro_call(e, syntax_ptr.clone(), true, |this, expansion| {\n                     ids.push(match expansion {\n                         Some(it) => this.collect_expr(it),\n                         None => this.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n                     })\n                 });\n                 ids[0]\n             }\n+            ast::Expr::MacroStmts(e) => {\n+                // FIXME:  these statements should be held by some hir containter\n+                for stmt in e.statements() {\n+                    self.collect_stmt(stmt);\n+                }\n+                if let Some(expr) = e.expr() {\n+                    self.collect_expr(expr)\n+                } else {\n+                    self.alloc_expr(Expr::Missing, syntax_ptr)\n+                }\n+            }\n         }\n     }\n \n     fn collect_macro_call<F: FnMut(&mut Self, Option<T>), T: ast::AstNode>(\n         &mut self,\n         e: ast::MacroCall,\n         syntax_ptr: AstPtr<ast::Expr>,\n+        is_error_recoverable: bool,\n         mut collector: F,\n     ) {\n         // File containing the macro call. Expansion errors will be attached here.\n@@ -567,7 +579,7 @@ impl ExprCollector<'_> {\n             Some((mark, expansion)) => {\n                 // FIXME: Statements are too complicated to recover from error for now.\n                 // It is because we don't have any hygiene for local variable expansion right now.\n-                if T::can_cast(syntax::SyntaxKind::MACRO_STMTS) && res.err.is_some() {\n+                if !is_error_recoverable && res.err.is_some() {\n                     self.expander.exit(self.db, mark);\n                     collector(self, None);\n                 } else {\n@@ -591,56 +603,55 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Vec<Statement>> {\n-        let stmt =\n-            match s {\n-                ast::Stmt::LetStmt(stmt) => {\n-                    self.check_cfg(&stmt)?;\n-\n-                    let pat = self.collect_pat_opt(stmt.pat());\n-                    let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n-                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    vec![Statement::Let { pat, type_ref, initializer }]\n-                }\n-                ast::Stmt::ExprStmt(stmt) => {\n-                    self.check_cfg(&stmt)?;\n-\n-                    // Note that macro could be expended to multiple statements\n-                    if let Some(ast::Expr::MacroCall(m)) = stmt.expr() {\n-                        let syntax_ptr = AstPtr::new(&stmt.expr().unwrap());\n-                        let mut stmts = vec![];\n-\n-                        self.collect_macro_call(m, syntax_ptr.clone(), |this, expansion| {\n-                            match expansion {\n-                                Some(expansion) => {\n-                                    let statements: ast::MacroStmts = expansion;\n-\n-                                    statements.statements().for_each(|stmt| {\n-                                        if let Some(mut r) = this.collect_stmt(stmt) {\n-                                            stmts.append(&mut r);\n-                                        }\n-                                    });\n-                                    if let Some(expr) = statements.expr() {\n-                                        stmts.push(Statement::Expr(this.collect_expr(expr)));\n+        let stmt = match s {\n+            ast::Stmt::LetStmt(stmt) => {\n+                self.check_cfg(&stmt)?;\n+\n+                let pat = self.collect_pat_opt(stmt.pat());\n+                let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n+                let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                vec![Statement::Let { pat, type_ref, initializer }]\n+            }\n+            ast::Stmt::ExprStmt(stmt) => {\n+                self.check_cfg(&stmt)?;\n+\n+                // Note that macro could be expended to multiple statements\n+                if let Some(ast::Expr::MacroCall(m)) = stmt.expr() {\n+                    let syntax_ptr = AstPtr::new(&stmt.expr().unwrap());\n+                    let mut stmts = vec![];\n+\n+                    self.collect_macro_call(m, syntax_ptr.clone(), false, |this, expansion| {\n+                        match expansion {\n+                            Some(expansion) => {\n+                                let statements: ast::MacroStmts = expansion;\n+\n+                                statements.statements().for_each(|stmt| {\n+                                    if let Some(mut r) = this.collect_stmt(stmt) {\n+                                        stmts.append(&mut r);\n                                     }\n-                                }\n-                                None => {\n-                                    stmts.push(Statement::Expr(\n-                                        this.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n-                                    ));\n+                                });\n+                                if let Some(expr) = statements.expr() {\n+                                    stmts.push(Statement::Expr(this.collect_expr(expr)));\n                                 }\n                             }\n-                        });\n-                        stmts\n-                    } else {\n-                        vec![Statement::Expr(self.collect_expr_opt(stmt.expr()))]\n-                    }\n+                            None => {\n+                                stmts.push(Statement::Expr(\n+                                    this.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n+                                ));\n+                            }\n+                        }\n+                    });\n+                    stmts\n+                } else {\n+                    vec![Statement::Expr(self.collect_expr_opt(stmt.expr()))]\n                 }\n-                ast::Stmt::Item(item) => {\n-                    self.check_cfg(&item)?;\n+            }\n+            ast::Stmt::Item(item) => {\n+                self.check_cfg(&item)?;\n \n-                    return None;\n-                }\n-            };\n+                return None;\n+            }\n+        };\n \n         Some(stmt)\n     }"}, {"sha": "86239d903ce629543980d1d13ad40d4198dae62e", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -110,6 +110,11 @@ impl ItemTree {\n                     // still need to collect inner items.\n                     ctx.lower_inner_items(e.syntax())\n                 },\n+                ast::ExprStmt(stmt) => {\n+                    // Macros can expand to stmt. We return an empty item tree in this case, but\n+                    // still need to collect inner items.\n+                    ctx.lower_inner_items(stmt.syntax())\n+                },\n                 _ => {\n                     panic!(\"cannot create item tree from {:?} {}\", syntax, syntax);\n                 },"}, {"sha": "a3070f1f94b58404bb4628ea64645a1c0e3f32f0", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -401,13 +401,14 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n \n     match parent.kind() {\n         MACRO_ITEMS | SOURCE_FILE => FragmentKind::Items,\n+        MACRO_STMTS => FragmentKind::Statement,\n         ITEM_LIST => FragmentKind::Items,\n         LET_STMT => {\n             // FIXME: Handle Pattern\n             FragmentKind::Expr\n         }\n         EXPR_STMT => FragmentKind::Statements,\n-        BLOCK_EXPR => FragmentKind::Expr,\n+        BLOCK_EXPR => FragmentKind::Statements,\n         ARG_LIST => FragmentKind::Expr,\n         TRY_EXPR => FragmentKind::Expr,\n         TUPLE_EXPR => FragmentKind::Expr,"}, {"sha": "af4f8bb11513558da805553036edc3ca4ed92d52", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -215,6 +215,22 @@ fn expr_macro_expanded_in_various_places() {\n     );\n }\n \n+#[test]\n+fn expr_macro_expanded_in_stmts() {\n+    check_infer(\n+        r#\"\n+        macro_rules! id { ($($es:tt)*) => { $($es)* } }\n+        fn foo() {\n+            id! { let a = (); }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..8 'leta=();': ()\n+            57..84 '{     ...); } }': ()\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn infer_type_value_macro_having_same_name() {\n     check_infer("}, {"sha": "eca0bcc18b6212c172819e3828594c6252b2da4c", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -662,12 +662,11 @@ fn test_tt_to_stmts() {\n         LITERAL@12..13\n           INT_NUMBER@12..13 \"1\"\n     SEMICOLON@13..14 \";\"\n-  EXPR_STMT@14..15\n-    PATH_EXPR@14..15\n-      PATH@14..15\n-        PATH_SEGMENT@14..15\n-          NAME_REF@14..15\n-            IDENT@14..15 \"a\"\"#,\n+  PATH_EXPR@14..15\n+    PATH@14..15\n+      PATH_SEGMENT@14..15\n+        NAME_REF@14..15\n+          IDENT@14..15 \"a\"\"#,\n     );\n }\n "}, {"sha": "cebb8f400803c84e6f01c120d06c36605ac591ed", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -63,11 +63,11 @@ pub(crate) mod fragments {\n     }\n \n     pub(crate) fn stmt(p: &mut Parser) {\n-        expressions::stmt(p, expressions::StmtWithSemi::No)\n+        expressions::stmt(p, expressions::StmtWithSemi::No, true)\n     }\n \n     pub(crate) fn stmt_optional_semi(p: &mut Parser) {\n-        expressions::stmt(p, expressions::StmtWithSemi::Optional)\n+        expressions::stmt(p, expressions::StmtWithSemi::Optional, false)\n     }\n \n     pub(crate) fn opt_visibility(p: &mut Parser) {\n@@ -133,7 +133,7 @@ pub(crate) mod fragments {\n                 continue;\n             }\n \n-            expressions::stmt(p, expressions::StmtWithSemi::Optional);\n+            expressions::stmt(p, expressions::StmtWithSemi::Optional, true);\n         }\n \n         m.complete(p, MACRO_STMTS);"}, {"sha": "0d9dc934899aeff910107e3e9aaf8205da0f4ccc", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -54,7 +54,7 @@ fn is_expr_stmt_attr_allowed(kind: SyntaxKind) -> bool {\n     !forbid\n }\n \n-pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n+pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi, prefer_expr: bool) {\n     let m = p.start();\n     // test attr_on_expr_stmt\n     // fn foo() {\n@@ -90,7 +90,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n         p.error(format!(\"attributes are not allowed on {:?}\", kind));\n     }\n \n-    if p.at(T!['}']) {\n+    if p.at(T!['}']) || (prefer_expr && p.at(EOF)) {\n         // test attr_on_last_expr_in_block\n         // fn foo() {\n         //     { #[A] bar!()? }\n@@ -198,7 +198,7 @@ pub(super) fn expr_block_contents(p: &mut Parser) {\n             continue;\n         }\n \n-        stmt(p, StmtWithSemi::Yes)\n+        stmt(p, StmtWithSemi::Yes, false)\n     }\n }\n "}, {"sha": "6097178b6fa7fffc28abe5e7709d5d853509ab64", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -1336,6 +1336,7 @@ pub enum Expr {\n     Literal(Literal),\n     LoopExpr(LoopExpr),\n     MacroCall(MacroCall),\n+    MacroStmts(MacroStmts),\n     MatchExpr(MatchExpr),\n     MethodCallExpr(MethodCallExpr),\n     ParenExpr(ParenExpr),\n@@ -3034,6 +3035,9 @@ impl From<LoopExpr> for Expr {\n impl From<MacroCall> for Expr {\n     fn from(node: MacroCall) -> Expr { Expr::MacroCall(node) }\n }\n+impl From<MacroStmts> for Expr {\n+    fn from(node: MacroStmts) -> Expr { Expr::MacroStmts(node) }\n+}\n impl From<MatchExpr> for Expr {\n     fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }\n }\n@@ -3078,8 +3082,8 @@ impl AstNode for Expr {\n         match kind {\n             ARRAY_EXPR | AWAIT_EXPR | BIN_EXPR | BLOCK_EXPR | BOX_EXPR | BREAK_EXPR | CALL_EXPR\n             | CAST_EXPR | CLOSURE_EXPR | CONTINUE_EXPR | EFFECT_EXPR | FIELD_EXPR | FOR_EXPR\n-            | IF_EXPR | INDEX_EXPR | LITERAL | LOOP_EXPR | MACRO_CALL | MATCH_EXPR\n-            | METHOD_CALL_EXPR | PAREN_EXPR | PATH_EXPR | PREFIX_EXPR | RANGE_EXPR\n+            | IF_EXPR | INDEX_EXPR | LITERAL | LOOP_EXPR | MACRO_CALL | MACRO_STMTS\n+            | MATCH_EXPR | METHOD_CALL_EXPR | PAREN_EXPR | PATH_EXPR | PREFIX_EXPR | RANGE_EXPR\n             | RECORD_EXPR | REF_EXPR | RETURN_EXPR | TRY_EXPR | TUPLE_EXPR | WHILE_EXPR\n             | YIELD_EXPR => true,\n             _ => false,\n@@ -3105,6 +3109,7 @@ impl AstNode for Expr {\n             LITERAL => Expr::Literal(Literal { syntax }),\n             LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n             MACRO_CALL => Expr::MacroCall(MacroCall { syntax }),\n+            MACRO_STMTS => Expr::MacroStmts(MacroStmts { syntax }),\n             MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n             METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),\n             PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n@@ -3142,6 +3147,7 @@ impl AstNode for Expr {\n             Expr::Literal(it) => &it.syntax,\n             Expr::LoopExpr(it) => &it.syntax,\n             Expr::MacroCall(it) => &it.syntax,\n+            Expr::MacroStmts(it) => &it.syntax,\n             Expr::MatchExpr(it) => &it.syntax,\n             Expr::MethodCallExpr(it) => &it.syntax,\n             Expr::ParenExpr(it) => &it.syntax,"}, {"sha": "ad93fbe3bd58e28f0897273c58b736d25d0d3a28", "filename": "xtask/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/152f385055510c65bd94238878be23a258f5cc19/xtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/152f385055510c65bd94238878be23a258f5cc19/xtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2FCargo.toml?ref=152f385055510c65bd94238878be23a258f5cc19", "patch": "@@ -11,7 +11,7 @@ anyhow = \"1.0.26\"\n flate2 = \"1.0\"\n proc-macro2 = \"1.0.8\"\n quote = \"1.0.2\"\n-ungrammar = \"=1.11\"\n+ungrammar = \"=1.12\"\n walkdir = \"2.3.1\"\n write-json = \"0.1.0\"\n xshell = \"0.1\""}]}