{"sha": "ae8a2ff37976b069b24bd0558c7af3474dab5854", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlOGEyZmYzNzk3NmIwNjliMjRiZDA1NThjN2FmMzQ3NGRhYjU4NTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-27T10:31:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-27T10:31:13Z"}, "message": "auto merge of #9538 : thestinger/rust/type_use, r=pcwalton\n\nThis is broken, and results in poor performance due to the undefined\r\nbehaviour in the LLVM IR. LLVM's `mergefunc` is a *much* better way of\r\ndoing this since it merges based on the equality of the bytecode.\r\n\r\nFor example, consider `std::repr`. It generates different code per\r\ntype, but is not included in the type bounds of generics.\r\n\r\nThe `mergefunc` pass works for most of our code but currently hits an\r\nassert on libstd. It is receiving attention upstream so it will be\r\nready soon, but I don't think removing this broken code should wait any\r\nlonger. I've opened #9536 about enabling it by default.\r\n\r\nCloses #8651\r\nCloses #3547\r\nCloses #2537\r\nCloses #6971\r\nCloses #9222", "tree": {"sha": "4fee08276da05f00cb46c17f799e926ab596d89b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fee08276da05f00cb46c17f799e926ab596d89b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae8a2ff37976b069b24bd0558c7af3474dab5854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae8a2ff37976b069b24bd0558c7af3474dab5854", "html_url": "https://github.com/rust-lang/rust/commit/ae8a2ff37976b069b24bd0558c7af3474dab5854", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae8a2ff37976b069b24bd0558c7af3474dab5854/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afbc242a20ec871dfeda84cf1412b34f756e9f7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/afbc242a20ec871dfeda84cf1412b34f756e9f7a", "html_url": "https://github.com/rust-lang/rust/commit/afbc242a20ec871dfeda84cf1412b34f756e9f7a"}, {"sha": "c3e4e068416438e91e3e9809ee8553a764d8e26e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e4e068416438e91e3e9809ee8553a764d8e26e", "html_url": "https://github.com/rust-lang/rust/commit/c3e4e068416438e91e3e9809ee8553a764d8e26e"}], "stats": {"total": 647, "additions": 21, "deletions": 626}, "files": [{"sha": "a2d27591cad939f189b96e0561a771494509b83f", "filename": "src/etc/monodebug.pl", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/afbc242a20ec871dfeda84cf1412b34f756e9f7a/src%2Fetc%2Fmonodebug.pl", "raw_url": "https://github.com/rust-lang/rust/raw/afbc242a20ec871dfeda84cf1412b34f756e9f7a/src%2Fetc%2Fmonodebug.pl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmonodebug.pl?ref=afbc242a20ec871dfeda84cf1412b34f756e9f7a", "patch": "@@ -1,79 +0,0 @@\n-#!/usr/bin/perl\n-\n-#\n-# This is a tool that helps with debugging incorrect monomorphic instance collapse.\n-#\n-# To use:\n-#    $ RUST_LOG=rustc::middle::trans::monomorphize rustc ARGS 2>&1 >log.txt\n-#    $ ./monodebug.pl log.txt\n-#\n-# This will show all generics that got collapsed. You can inspect this list to find the instances\n-# that were mistakenly combined into one. Fixes will (most likely) be applied to type_use.rs.\n-#\n-# Questions about this tool go to pcwalton.\n-#\n-\n-use strict;\n-use warnings;\n-use Data::Dumper qw(Dumper);\n-use Text::Balanced qw(extract_bracketed);\n-\n-my %funcs;\n-while (<>) {\n-    chomp;\n-    /^rust: ~\"monomorphic_fn\\((.*)\"$/ or next;\n-    my $text = $1;\n-    $text =~ /fn_id=(\\{ crate: \\d+, node: \\d+ \\} \\([^)]+\\)), real_substs=(.*?), substs=(.*?), hash_id = \\@\\{ (.*) \\}$/ or next;\n-    my ($fn_id, $real_substs, $substs, $hash_id) = ($1, $2, $3, $4);\n-\n-    #print \"$hash_id\\n\";\n-    $hash_id =~ /^def: { crate: \\d+, node: \\d+ }, params: ~\\[ (.*) \\], impl_did_opt: (?:None|Some\\({ crate: \\d+, node: \\d+ }\\))$/ or next;\n-    my $params = $1;\n-\n-    my @real_substs;\n-    @real_substs = $real_substs =~ /\\\\\"(.*?)\\\\\"/g;\n-\n-    my @mono_params;\n-    while (1) {\n-        $params =~ s/^, //;\n-        if ($params =~ s/^mono_precise//) {\n-            extract_bracketed($params, '()');\n-            push @mono_params, 'precise';\n-            next;\n-        }\n-        if ($params =~ s/^mono_repr//) {\n-            my $sub = extract_bracketed($params, '()');\n-            push @mono_params, \"repr($sub)\";\n-            next;\n-        }\n-        if ($params =~ s/^mono_any//) {\n-            push @mono_params, \"any\";\n-            next;\n-        }\n-        last;\n-    }\n-\n-    my @key_params;\n-    for (my $i = 0; $i < @mono_params; ++$i) {\n-        if ($mono_params[$i] eq 'precise') {\n-            push @key_params, 'precise(' . $real_substs[$i] . ')';\n-        } else {\n-            push @key_params, $mono_params[$i];\n-        }\n-    }\n-\n-    my $key = \"$fn_id with \" . (join ', ', @key_params);\n-    $funcs{$key}{$real_substs} = 1;\n-}\n-\n-while (my ($key, $substs) = each %funcs) {\n-    my @params = keys %$substs;\n-    next if @params == 1;\n-\n-    print \"$key\\n\";\n-    print(('-' x (length $key)), $/);\n-    for my $param (@params) {\n-        print \"$param\\n\";\n-    }\n-    print \"\\n\";\n-}"}, {"sha": "a4b1bc629d1dc2694fea4b51093d4908f67cee2f", "filename": "src/etc/zsh/_rust", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Fetc%2Fzsh%2F_rust", "raw_url": "https://github.com/rust-lang/rust/raw/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Fetc%2Fzsh%2F_rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fzsh%2F_rust?ref=ae8a2ff37976b069b24bd0558c7af3474dab5854", "patch": "@@ -71,7 +71,6 @@ _rustc_opts_debug=(\n     'count-type-sizes:count the sizes of aggregate types'\n     'meta-stats:gather metadata statistics'\n     'no-opt:do not optimize, even if -O is passed'\n-    'no-monomorphic-collapse:do not collapse template instantiations'\n     'print-link-args:Print the arguments passed to the linker'\n     'gc:Garbage collect shared data (experimental)'\n     'jit:Execute using JIT (experimental)'"}, {"sha": "df3a40c228942e57abefc4f9a1ffe9bc9682b86b", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=ae8a2ff37976b069b24bd0558c7af3474dab5854", "patch": "@@ -748,13 +748,6 @@ pub fn build_session_options(binary: @str,\n     let debuginfo = debugging_opts & session::debug_info != 0 ||\n         extra_debuginfo;\n \n-    // If debugging info is generated, do not collapse monomorphized function instances.\n-    // Functions with equivalent llvm code still need separate debugging descriptions because names\n-    // might differ.\n-    if debuginfo {\n-        debugging_opts |= session::no_monomorphic_collapse;\n-    }\n-\n     let statik = debugging_opts & session::statik != 0;\n \n     let addl_lib_search_paths = matches.opt_strs(\"L\").map(|s| Path(*s));"}, {"sha": "19e866c70a3fe64314b4822ce2125b3e44d19f4b", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=ae8a2ff37976b069b24bd0558c7af3474dab5854", "patch": "@@ -67,20 +67,19 @@ pub static debug_llvm:              uint = 1 << 13;\n pub static count_type_sizes:        uint = 1 << 14;\n pub static meta_stats:              uint = 1 << 15;\n pub static no_opt:                  uint = 1 << 16;\n-pub static no_monomorphic_collapse: uint = 1 << 17;\n-pub static gc:                      uint = 1 << 18;\n-pub static jit:                     uint = 1 << 19;\n-pub static debug_info:              uint = 1 << 20;\n-pub static extra_debug_info:        uint = 1 << 21;\n-pub static statik:                  uint = 1 << 22;\n-pub static print_link_args:         uint = 1 << 23;\n-pub static no_debug_borrows:        uint = 1 << 24;\n-pub static lint_llvm:               uint = 1 << 25;\n-pub static once_fns:                uint = 1 << 26;\n-pub static print_llvm_passes:       uint = 1 << 27;\n-pub static no_vectorize_loops:      uint = 1 << 28;\n-pub static no_vectorize_slp:        uint = 1 << 29;\n-pub static no_prepopulate_passes:   uint = 1 << 30;\n+pub static gc:                      uint = 1 << 17;\n+pub static jit:                     uint = 1 << 18;\n+pub static debug_info:              uint = 1 << 19;\n+pub static extra_debug_info:        uint = 1 << 20;\n+pub static statik:                  uint = 1 << 21;\n+pub static print_link_args:         uint = 1 << 22;\n+pub static no_debug_borrows:        uint = 1 << 23;\n+pub static lint_llvm:               uint = 1 << 24;\n+pub static once_fns:                uint = 1 << 25;\n+pub static print_llvm_passes:       uint = 1 << 26;\n+pub static no_vectorize_loops:      uint = 1 << 27;\n+pub static no_vectorize_slp:        uint = 1 << 28;\n+pub static no_prepopulate_passes:   uint = 1 << 29;\n \n pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ~[(~\"verbose\", ~\"in general, enable more debug printouts\", verbose),\n@@ -106,8 +105,6 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n       count_type_sizes),\n      (~\"meta-stats\", ~\"gather metadata statistics\", meta_stats),\n      (~\"no-opt\", ~\"do not optimize, even if -O is passed\", no_opt),\n-     (~\"no-monomorphic-collapse\", ~\"do not collapse template instantiations\",\n-      no_monomorphic_collapse),\n      (~\"print-link-args\", ~\"Print the arguments passed to the linker\", print_link_args),\n      (~\"gc\", ~\"Garbage collect shared data (experimental)\", gc),\n      (~\"jit\", ~\"Execute using JIT (experimental)\", jit),\n@@ -326,9 +323,6 @@ impl Session_ {\n     pub fn borrowck_note_loan(&self) -> bool {\n         self.debugging_opt(borrowck_note_loan)\n     }\n-    pub fn no_monomorphic_collapse(&self) -> bool {\n-        self.debugging_opt(no_monomorphic_collapse)\n-    }\n     pub fn debug_borrows(&self) -> bool {\n         self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n     }"}, {"sha": "36757374b0b0632824c8498ce479edfc77b1c91c", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=ae8a2ff37976b069b24bd0558c7af3474dab5854", "patch": "@@ -22,7 +22,6 @@ use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::builder::Builder;\n use middle::trans::debuginfo;\n-use middle::trans::type_use;\n use middle::trans::common::{C_i32, C_null};\n use middle::ty;\n \n@@ -73,8 +72,6 @@ pub struct CrateContext {\n      // Cache instances of monomorphized functions\n      monomorphized: HashMap<mono_id, ValueRef>,\n      monomorphizing: HashMap<ast::DefId, uint>,\n-     // Cache computed type parameter uses (see type_use.rs)\n-     type_use_cache: HashMap<ast::DefId, @~[type_use::type_uses]>,\n      // Cache generated vtables\n      vtables: HashMap<(ty::t, mono_id), ValueRef>,\n      // Cache of constant strings,\n@@ -204,7 +201,6 @@ impl CrateContext {\n                   non_inlineable_statics: HashSet::new(),\n                   monomorphized: HashMap::new(),\n                   monomorphizing: HashMap::new(),\n-                  type_use_cache: HashMap::new(),\n                   vtables: HashMap::new(),\n                   const_cstr_cache: HashMap::new(),\n                   const_globals: HashMap::new(),"}, {"sha": "ce4c1011e8064e9844e67e077e0f412d1fc90724", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=ae8a2ff37976b069b24bd0558c7af3474dab5854", "patch": "@@ -520,8 +520,7 @@ pub fn vtable_id(ccx: @mut CrateContext,\n             monomorphize::make_mono_id(\n                 ccx,\n                 impl_id,\n-                &psubsts,\n-                None)\n+                &psubsts)\n         }\n \n         // can't this be checked at the callee?"}, {"sha": "f55360213c6f6b429acb97b82a198ee7d0e7ce6f", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=ae8a2ff37976b069b24bd0558c7af3474dab5854", "patch": "@@ -38,7 +38,6 @@ pub mod foreign;\n pub mod intrinsic;\n pub mod reflect;\n pub mod debuginfo;\n-pub mod type_use;\n pub mod machine;\n pub mod adt;\n pub mod asm;"}, {"sha": "034320008cd14aa748cd91ab60b23556d994609d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 7, "deletions": 64, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8a2ff37976b069b24bd0558c7af3474dab5854/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=ae8a2ff37976b069b24bd0558c7af3474dab5854", "patch": "@@ -18,15 +18,11 @@ use middle::trans::base::{trans_fn, decl_internal_rust_fn};\n use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n use middle::trans::common::*;\n-use middle::trans::datum;\n-use middle::trans::machine;\n use middle::trans::meth;\n-use middle::trans::type_of;\n-use middle::trans::type_use;\n use middle::trans::intrinsic;\n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{Repr,ty_to_str};\n+use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::ast_map;\n@@ -65,10 +61,8 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n \n     for s in real_substs.tps.iter() { assert!(!ty::type_has_params(*s)); }\n     for s in psubsts.tys.iter() { assert!(!ty::type_has_params(*s)); }\n-    let param_uses = type_use::type_uses_for(ccx, fn_id, psubsts.tys.len());\n \n-\n-    let hash_id = make_mono_id(ccx, fn_id, &*psubsts, Some(param_uses));\n+    let hash_id = make_mono_id(ccx, fn_id, &*psubsts);\n     if hash_id.params.iter().any(\n                 |p| match *p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n@@ -302,8 +296,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n \n pub fn make_mono_id(ccx: @mut CrateContext,\n                     item: ast::DefId,\n-                    substs: &param_substs,\n-                    param_uses: Option<@~[type_use::type_uses]>) -> mono_id {\n+                    substs: &param_substs) -> mono_id {\n     // FIXME (possibly #5801): Need a lot of type hints to get\n     // .collect() to work.\n     let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n@@ -321,59 +314,9 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n     };\n \n \n-    let param_ids = match param_uses {\n-      Some(ref uses) => {\n-        // param_uses doesn't include a use for the self type.\n-        // We just say it is fully used.\n-        let self_use =\n-            substs.self_ty.map(|_| type_use::use_repr|type_use::use_tydesc);\n-        let uses_iter = self_use.iter().chain(uses.iter());\n-\n-        precise_param_ids.iter().zip(uses_iter).map(|(id, uses)| {\n-            if ccx.sess.no_monomorphic_collapse() {\n-                match *id {\n-                    (a, b) => mono_precise(a, b)\n-                }\n-            } else {\n-                match *id {\n-                    (a, b@Some(_)) => mono_precise(a, b),\n-                    (subst, None) => {\n-                        if *uses == 0 {\n-                            mono_any\n-                        } else if *uses == type_use::use_repr &&\n-                            !ty::type_needs_drop(ccx.tcx, subst)\n-                        {\n-                            let llty = type_of::type_of(ccx, subst);\n-                            let size = machine::llbitsize_of_real(ccx, llty);\n-                            let align = machine::llalign_of_min(ccx, llty);\n-                            let mode = datum::appropriate_mode(ccx.tcx, subst);\n-                            let data_class = mono_data_classify(subst);\n-\n-                            debug!(\"make_mono_id: type %s -> size %u align %u mode %? class %?\",\n-                                  ty_to_str(ccx.tcx, subst),\n-                                  size, align, mode, data_class);\n-\n-                            // Special value for nil to prevent problems\n-                            // with undef return pointers.\n-                            if size <= 8u && ty::type_is_nil(subst) {\n-                                mono_repr(0u, 0u, data_class, mode)\n-                            } else {\n-                                mono_repr(size, align, data_class, mode)\n-                            }\n-                        } else {\n-                            mono_precise(subst, None)\n-                        }\n-                    }\n-                }\n-            }\n-        }).collect()\n-      }\n-      None => {\n-          precise_param_ids.iter().map(|x| {\n-              let (a, b) = *x;\n-              mono_precise(a, b)\n-          }).collect()\n-      }\n-    };\n+    let param_ids = precise_param_ids.iter().map(|x| {\n+        let (a, b) = *x;\n+        mono_precise(a, b)\n+    }).collect();\n     @mono_id_ {def: item, params: param_ids}\n }"}, {"sha": "6ae196226d575c0e029f5dda804452c522c7e20e", "filename": "src/librustc/middle/trans/type_use.rs", "status": "removed", "additions": 0, "deletions": 449, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/afbc242a20ec871dfeda84cf1412b34f756e9f7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afbc242a20ec871dfeda84cf1412b34f756e9f7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=afbc242a20ec871dfeda84cf1412b34f756e9f7a", "patch": "@@ -1,449 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Determines the ways in which a generic function body depends\n-// on its type parameters. Used to aggressively reuse compiled\n-// function bodies for different types.\n-\n-// This unfortunately depends on quite a bit of knowledge about the\n-// details of the language semantics, and is likely to accidentally go\n-// out of sync when something is changed. It could be made more\n-// powerful by distinguishing between functions that only need to know\n-// the size and alignment of a type, and those that also use its\n-// drop/take glue. But this would increase the fragility of the code\n-// to a ridiculous level, and probably not catch all that many extra\n-// opportunities for reuse.\n-\n-// (An other approach to doing what this code does is to instrument\n-// the translation code to set flags whenever it does something like\n-// alloca a type or get a tydesc. This would not duplicate quite as\n-// much information, but have the disadvantage of being very\n-// invasive.)\n-\n-use middle::freevars;\n-use middle::trans::common::*;\n-use middle::trans::inline;\n-use middle::ty;\n-use middle::typeck;\n-\n-use std::option::{Some, None};\n-use std::vec;\n-use extra::list::{List, Cons, Nil};\n-use extra::list;\n-use syntax::ast;\n-use syntax::ast::*;\n-use syntax::ast_map;\n-use syntax::ast_util;\n-use syntax::parse::token;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n-\n-pub type type_uses = uint; // Bitmask\n-pub static use_repr: uint = 1;   /* Dependency on size/alignment/mode and\n-                                     take/drop glue */\n-pub static use_tydesc: uint = 2; /* Takes the tydesc, or compares */\n-pub static use_all: uint = use_repr|use_tydesc;\n-\n-#[deriving(Clone)]\n-pub struct Context {\n-    ccx: @mut CrateContext,\n-    uses: @mut ~[type_uses]\n-}\n-\n-pub fn type_uses_for(ccx: @mut CrateContext, fn_id: DefId, n_tps: uint)\n-    -> @~[type_uses] {\n-\n-    fn store_type_uses(cx: Context, fn_id: DefId) -> @~[type_uses] {\n-        let Context { uses, ccx } = cx;\n-        let uses = @(*uses).clone(); // freeze\n-        ccx.type_use_cache.insert(fn_id, uses);\n-        uses\n-    }\n-\n-    match ccx.type_use_cache.find(&fn_id) {\n-      Some(uses) => return *uses,\n-      None => ()\n-    }\n-\n-    let fn_id_loc = if fn_id.crate == LOCAL_CRATE {\n-        fn_id\n-    } else {\n-        inline::maybe_instantiate_inline(ccx, fn_id)\n-    };\n-\n-    // Conservatively assume full use for recursive loops\n-    ccx.type_use_cache.insert(fn_id, @vec::from_elem(n_tps, use_all));\n-\n-    let mut cx = Context {\n-        ccx: ccx,\n-        uses: @mut vec::from_elem(n_tps, 0u)\n-    };\n-\n-    // If the method is a default method, we mark all of the types as\n-    // used.  This is imprecise, but simple. Getting it right is\n-    // tricky because the substs on the call and the substs on the\n-    // default method differ, because of substs on the trait/impl.\n-    let is_default = ty::provided_source(ccx.tcx, fn_id_loc).is_some();\n-    // We also mark all of the params as used if it is an extern thing\n-    // that we haven't been able to inline yet.\n-    if is_default || fn_id_loc.crate != LOCAL_CRATE {\n-        for n in range(0u, n_tps) { cx.uses[n] |= use_all; }\n-        return store_type_uses(cx, fn_id);\n-    }\n-\n-    let map_node = match ccx.tcx.items.find(&fn_id_loc.node) {\n-        Some(x) => {\n-            (*x).clone()\n-        }\n-        None => {\n-            ccx.sess.bug(fmt!(\"type_uses_for: unbound item ID %?\",\n-                              fn_id_loc))\n-        }\n-    };\n-\n-    match map_node {\n-      ast_map::node_item(@ast::item { node: item_fn(_, _, _, _, ref body),\n-                                      _ }, _) |\n-      ast_map::node_method(@ast::method {body: ref body, _}, _, _) => {\n-        handle_body(&mut cx, body);\n-      }\n-      ast_map::node_trait_method(*) => {\n-        // This will be a static trait method. For now, we just assume\n-        // it fully depends on all of the type information. (Doing\n-        // otherwise would require finding the actual implementation).\n-        for n in range(0u, n_tps) { cx.uses[n] |= use_all;}\n-        // We need to return early, before the arguments are processed,\n-        // because of difficulties in the handling of Self.\n-        return store_type_uses(cx, fn_id);\n-      }\n-      ast_map::node_variant(_, _, _) => {\n-        for n in range(0u, n_tps) { cx.uses[n] |= use_repr;}\n-      }\n-      ast_map::node_foreign_item(i@@foreign_item {\n-            node: foreign_item_fn(*),\n-            _\n-        },\n-        abi,\n-        _,\n-        _) => {\n-        if abi.is_intrinsic() {\n-            let nm = cx.ccx.sess.str_of(i.ident);\n-            let name = nm.as_slice();\n-            let flags = if name.starts_with(\"atomic_\") {\n-                0\n-            } else {\n-                match name {\n-                    \"size_of\"  | \"pref_align_of\" | \"min_align_of\" |\n-                    \"uninit\"   | \"init\" | \"transmute\" | \"move_val\" |\n-                    \"move_val_init\" => use_repr,\n-\n-                    \"get_tydesc\" | \"needs_drop\" | \"contains_managed\" => use_tydesc,\n-\n-                    \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n-                    \"morestack_addr\" => 0,\n-\n-                    \"offset\" |\n-                    \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n-                    \"memset32\" | \"memset64\" => use_repr,\n-\n-                    \"sqrtf32\" | \"sqrtf64\" | \"powif32\" | \"powif64\" |\n-                    \"sinf32\"  | \"sinf64\"  | \"cosf32\"  | \"cosf64\"  |\n-                    \"powf32\"  | \"powf64\"  | \"expf32\"  | \"expf64\"  |\n-                    \"exp2f32\" | \"exp2f64\" | \"logf32\"  | \"logf64\"  |\n-                    \"log10f32\"| \"log10f64\"| \"log2f32\" | \"log2f64\" |\n-                    \"fmaf32\"  | \"fmaf64\"  | \"fabsf32\" | \"fabsf64\" |\n-                    \"floorf32\"| \"floorf64\"| \"ceilf32\" | \"ceilf64\" |\n-                    \"truncf32\"| \"truncf64\" => 0,\n-\n-                    \"ctpop8\" | \"ctpop16\" | \"ctpop32\" | \"ctpop64\" => 0,\n-\n-                    \"ctlz8\" | \"ctlz16\" | \"ctlz32\" | \"ctlz64\" => 0,\n-                    \"cttz8\" | \"cttz16\" | \"cttz32\" | \"cttz64\" => 0,\n-\n-                    \"bswap16\" | \"bswap32\" | \"bswap64\" => 0,\n-\n-\n-                    \"i8_add_with_overflow\"  | \"u8_add_with_overflow\" |\n-                    \"i16_add_with_overflow\" | \"u16_add_with_overflow\" |\n-                    \"i32_add_with_overflow\" | \"u32_add_with_overflow\" |\n-                    \"i64_add_with_overflow\" | \"u64_add_with_overflow\" => 0,\n-\n-                    \"i8_sub_with_overflow\"  | \"u8_sub_with_overflow\" |\n-                    \"i16_sub_with_overflow\" | \"u16_sub_with_overflow\" |\n-                    \"i32_sub_with_overflow\" | \"u32_sub_with_overflow\" |\n-                    \"i64_sub_with_overflow\" | \"u64_sub_with_overflow\" => 0,\n-\n-                    \"i8_mul_with_overflow\"  | \"u8_mul_with_overflow\" |\n-                    \"i16_mul_with_overflow\" | \"u16_mul_with_overflow\" |\n-                    \"i32_mul_with_overflow\" | \"u32_mul_with_overflow\" |\n-                    \"i64_mul_with_overflow\" | \"u64_mul_with_overflow\" => 0,\n-\n-                    // would be cool to make these an enum instead of\n-                    // strings!\n-                    _ => fail!(\"unknown intrinsic in type_use\")\n-                }\n-            };\n-            for n in range(0u, n_tps) { cx.uses[n] |= flags;}\n-        }\n-      }\n-      ast_map::node_struct_ctor(*) => {\n-        // Similarly to node_variant, this monomorphized function just\n-        // uses the representations of all of its type parameters.\n-        for n in range(0u, n_tps) { cx.uses[n] |= use_repr; }\n-      }\n-      _ => {\n-        ccx.tcx.sess.bug(fmt!(\"unknown node type in type_use: %s\",\n-                              ast_map::node_id_to_str(\n-                                ccx.tcx.items,\n-                                fn_id_loc.node,\n-                                token::get_ident_interner())));\n-      }\n-    }\n-\n-    // Now handle arguments\n-    match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n-        ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n-        ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n-            for arg in sig.inputs.iter() {\n-                type_needs(&cx, use_repr, *arg);\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    store_type_uses(cx, fn_id)\n-}\n-\n-pub fn type_needs(cx: &Context, use_: uint, ty: ty::t) {\n-    // Optimization -- don't descend type if all params already have this use\n-    if cx.uses.iter().any(|&elt| elt & use_ != use_) {\n-        type_needs_inner(cx, use_, ty, @Nil);\n-    }\n-}\n-\n-pub fn type_needs_inner(cx: &Context,\n-                        use_: uint,\n-                        ty: ty::t,\n-                        enums_seen: @List<DefId>) {\n-    do ty::maybe_walk_ty(ty) |ty| {\n-        if ty::type_has_params(ty) {\n-            match ty::get(ty).sty {\n-                /*\n-                 This previously included ty_box -- that was wrong\n-                 because if we cast an @T to an trait (for example) and return\n-                 it, we depend on the drop glue for T (we have to write the\n-                 right tydesc into the result)\n-                 */\n-                ty::ty_closure(*) |\n-                ty::ty_bare_fn(*) |\n-                ty::ty_ptr(_) |\n-                ty::ty_rptr(_, _) |\n-                ty::ty_trait(*) => false,\n-\n-              ty::ty_enum(did, ref substs) => {\n-                if list::find(enums_seen, |id| *id == did).is_none() {\n-                    let seen = @Cons(did, enums_seen);\n-                    let r = ty::enum_variants(cx.ccx.tcx, did);\n-                    for v in r.iter() {\n-                        for aty in v.args.iter() {\n-                            let t = ty::subst(cx.ccx.tcx, &(*substs), *aty);\n-                            type_needs_inner(cx, use_, t, seen);\n-                        }\n-                    }\n-                }\n-                false\n-              }\n-              ty::ty_param(p) => {\n-                cx.uses[p.idx] |= use_;\n-                false\n-              }\n-              _ => true\n-            }\n-        } else { false }\n-    }\n-}\n-\n-pub fn node_type_needs(cx: &Context, use_: uint, id: NodeId) {\n-    type_needs(cx, use_, ty::node_id_to_type(cx.ccx.tcx, id));\n-}\n-\n-pub fn mark_for_method_call(cx: &Context, e_id: NodeId, callee_id: NodeId) {\n-    let mut opt_static_did = None;\n-    {\n-        let r = cx.ccx.maps.method_map.find(&e_id);\n-        for mth in r.iter() {\n-            match mth.origin {\n-              typeck::method_static(did) => {\n-                  opt_static_did = Some(did);\n-              }\n-              typeck::method_param(typeck::method_param {\n-                  param_num: typeck::param_numbered(param),\n-                  _\n-              }) => {\n-                cx.uses[param] |= use_tydesc;\n-              }\n-              _ => (),\n-            }\n-        }\n-    }\n-\n-    // Note: we do not execute this code from within the each() call\n-    // above because the recursive call to `type_needs` can trigger\n-    // inlining and hence can cause `method_map` and\n-    // `node_type_substs` to be modified.\n-    for &did in opt_static_did.iter() {\n-        {\n-            let r = cx.ccx.tcx.node_type_substs.find_copy(&callee_id);\n-            for ts in r.iter() {\n-                let type_uses = type_uses_for(cx.ccx, did, ts.len());\n-                for (uses, subst) in type_uses.iter().zip(ts.iter()) {\n-                    type_needs(cx, *uses, *subst)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub fn mark_for_expr(cx: &Context, e: &Expr) {\n-    match e.node {\n-      ExprVstore(_, _) | ExprVec(_, _) | ExprStruct(*) | ExprTup(_) |\n-      ExprUnary(_, UnBox(_), _) | ExprUnary(_, UnUniq, _) |\n-      ExprBinary(_, BiAdd, _, _) | ExprRepeat(*) => {\n-        node_type_needs(cx, use_repr, e.id);\n-      }\n-      ExprCast(base, _) => {\n-        let result_t = ty::node_id_to_type(cx.ccx.tcx, e.id);\n-        match ty::get(result_t).sty {\n-            ty::ty_trait(*) => {\n-              // When we're casting to an trait, we need the\n-              // tydesc for the expr that's being cast.\n-              node_type_needs(cx, use_tydesc, base.id);\n-            }\n-            _ => ()\n-        }\n-      }\n-      ExprBinary(_, op, lhs, _) => {\n-        match op {\n-          BiEq | BiLt | BiLe | BiNe | BiGe | BiGt => {\n-            node_type_needs(cx, use_tydesc, lhs.id)\n-          }\n-          _ => ()\n-        }\n-      }\n-      ExprPath(_) | ExprSelf => {\n-        let opt_ts = cx.ccx.tcx.node_type_substs.find_copy(&e.id);\n-        for ts in opt_ts.iter() {\n-            let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get_copy(&e.id));\n-            let uses_for_ts = type_uses_for(cx.ccx, id, ts.len());\n-            for (uses, subst) in uses_for_ts.iter().zip(ts.iter()) {\n-                type_needs(cx, *uses, *subst)\n-            }\n-        }\n-      }\n-      ExprFnBlock(*) => {\n-          match ty::ty_closure_sigil(ty::expr_ty(cx.ccx.tcx, e)) {\n-              ast::OwnedSigil => {}\n-              ast::BorrowedSigil | ast::ManagedSigil => {\n-                  for fv in freevars::get_freevars(cx.ccx.tcx, e.id).iter() {\n-                      let node_id = ast_util::def_id_of_def(fv.def).node;\n-                      node_type_needs(cx, use_repr, node_id);\n-                  }\n-              }\n-          }\n-      }\n-      ExprAssign(val, _) | ExprAssignOp(_, _, val, _) |\n-      ExprRet(Some(val)) => {\n-        node_type_needs(cx, use_repr, val.id);\n-      }\n-      ExprIndex(callee_id, base, _) => {\n-        // FIXME (#2537): could be more careful and not count fields after\n-        // the chosen field.\n-        let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n-        type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n-        mark_for_method_call(cx, e.id, callee_id);\n-      }\n-      ExprField(base, _, _) => {\n-        // Method calls are now a special syntactic form,\n-        // so `a.b` should always be a field.\n-        assert!(!cx.ccx.maps.method_map.contains_key(&e.id));\n-\n-        let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n-        type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n-      }\n-      ExprCall(f, _, _) => {\n-          let r = ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id));\n-          for a in r.iter() {\n-              type_needs(cx, use_repr, *a);\n-          }\n-      }\n-      ExprMethodCall(callee_id, rcvr, _, _, _, _) => {\n-        let base_ty = ty::node_id_to_type(cx.ccx.tcx, rcvr.id);\n-        type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n-\n-        let r = ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, callee_id));\n-        for a in r.iter() {\n-            type_needs(cx, use_repr, *a);\n-        }\n-        mark_for_method_call(cx, e.id, callee_id);\n-      }\n-\n-      ExprInlineAsm(ref ia) => {\n-        for &(_, input) in ia.inputs.iter() {\n-          node_type_needs(cx, use_repr, input.id);\n-        }\n-        for &(_, out) in ia.outputs.iter() {\n-          node_type_needs(cx, use_repr, out.id);\n-        }\n-      }\n-\n-      ExprParen(e) => mark_for_expr(cx, e),\n-\n-      ExprMatch(*) | ExprBlock(_) | ExprIf(*) | ExprWhile(*) |\n-      ExprBreak(_) | ExprAgain(_) | ExprUnary(*) | ExprLit(_) |\n-      ExprMac(_) | ExprAddrOf(*) | ExprRet(_) | ExprLoop(*) |\n-      ExprDoBody(_) | ExprLogLevel => (),\n-\n-      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n-    }\n-}\n-\n-impl Visitor<()> for Context {\n-\n-    fn visit_expr(&mut self, e:@Expr, _: ()) {\n-            visit::walk_expr(self, e, ());\n-            mark_for_expr(self, e);\n-    }\n-\n-    fn visit_local(&mut self, l:@Local, _:()) {\n-            visit::walk_local(self, l, ());\n-            node_type_needs(self, use_repr, l.id);\n-    }\n-\n-    fn visit_pat(&mut self, p:@Pat, _: ()) {\n-            visit::walk_pat(self, p, ());\n-            node_type_needs(self, use_repr, p.id);\n-    }\n-\n-   fn visit_block(&mut self, b:&Block, _: ()) {\n-            visit::walk_block(self, b, ());\n-            for e in b.expr.iter() {\n-                node_type_needs(self, use_repr, e.id);\n-            }\n-    }\n-\n-    fn visit_item(&mut self, _:@item, _: ()) {\n-        // do nothing\n-    }\n-\n-}\n-\n-pub fn handle_body(cx: &mut Context, body: &Block) {\n-    cx.visit_block(body, ());\n-}"}]}