{"sha": "267fb90b55736dc2362e8621a247f54da5fd8d40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2N2ZiOTBiNTU3MzZkYzIzNjJlODYyMWEyNDdmNTRkYTVmZDhkNDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-27T05:25:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-27T05:25:50Z"}, "message": "Auto merge of #59447 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #59004 ([rustdoc] Improve \"in parameters\" search and search more generally)\n - #59026 (Fix moving text in search tabs headers)\n - #59197 (Exclude old book redirect stubs from search engines)\n - #59330 (Improve the documentation for std::convert (From, Into, AsRef and AsMut))\n - #59424 (Fix code block display in portability element in dark theme)\n - #59427 (Link to PhantomData in NonNull documentation)\n - #59432 (Improve some compiletest documentation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9f048d997dd524095580f4b5e6f511072ab3ba79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f048d997dd524095580f4b5e6f511072ab3ba79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/267fb90b55736dc2362e8621a247f54da5fd8d40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/267fb90b55736dc2362e8621a247f54da5fd8d40", "html_url": "https://github.com/rust-lang/rust/commit/267fb90b55736dc2362e8621a247f54da5fd8d40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/267fb90b55736dc2362e8621a247f54da5fd8d40/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd363d14ae842ab5aae3ee81b337f26aabcb8875", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd363d14ae842ab5aae3ee81b337f26aabcb8875", "html_url": "https://github.com/rust-lang/rust/commit/dd363d14ae842ab5aae3ee81b337f26aabcb8875"}, {"sha": "cbb13f496c99eb905baa21aed46a491737a8a522", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbb13f496c99eb905baa21aed46a491737a8a522", "html_url": "https://github.com/rust-lang/rust/commit/cbb13f496c99eb905baa21aed46a491737a8a522"}], "stats": {"total": 559, "additions": 433, "deletions": 126}, "files": [{"sha": "2ea6be552106b3671c2abedd8ee645ac95bae7b9", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -331,7 +331,7 @@ fn invoke_rustdoc(\n \n     let path = builder.src.join(\"src/doc\").join(markdown);\n \n-    let favicon = builder.src.join(\"src/doc/favicon.inc\");\n+    let header = builder.src.join(\"src/doc/redirect.inc\");\n     let footer = builder.src.join(\"src/doc/footer.inc\");\n     let version_info = out.join(\"version_info.html\");\n \n@@ -341,7 +341,7 @@ fn invoke_rustdoc(\n \n     cmd.arg(\"--html-after-content\").arg(&footer)\n         .arg(\"--html-before-content\").arg(&version_info)\n-        .arg(\"--html-in-header\").arg(&favicon)\n+        .arg(\"--html-in-header\").arg(&header)\n         .arg(\"--markdown-no-toc\")\n         .arg(\"--markdown-playground-url\")\n         .arg(\"https://play.rust-lang.org/\")"}, {"sha": "33e3860c2a4340ba428e789a980bafeeb7982b02", "filename": "src/doc/redirect.inc", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Fdoc%2Fredirect.inc", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Fdoc%2Fredirect.inc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fredirect.inc?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -0,0 +1,2 @@\n+<meta name=\"robots\" content=\"noindex,follow\">\n+<link rel=\"shortcut icon\" href=\"https://www.rust-lang.org/favicon.ico\">"}, {"sha": "cee4fc6f49a713cdfb8ae38350154d5628e226eb", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 89, "deletions": 78, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -1,26 +1,25 @@\n //! Traits for conversions between types.\n //!\n-//! The traits in this module provide a general way to talk about conversions\n-//! from one type to another. They follow the standard Rust conventions of\n-//! `as`/`into`/`from`.\n+//! The traits in this module provide a way to convert from one type to another type.\n+//! Each trait serves a different purpose:\n //!\n-//! Like many traits, these are often used as bounds for generic functions, to\n-//! support arguments of multiple types.\n+//! - Implement the [`AsRef`] trait for cheap reference-to-reference conversions\n+//! - Implement the [`AsMut`] trait for cheap mutable-to-mutable conversions\n+//! - Implement the [`From`] trait for consuming value-to-value conversions\n+//! - Implement the [`Into`] trait for consuming value-to-value conversions to types\n+//!   outside the current crate\n+//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`],\n+//!   but should be implemented when the conversion can fail.\n //!\n-//! - Implement the `As*` traits for reference-to-reference conversions\n-//! - Implement the [`Into`] trait when you want to consume the value in the conversion\n-//! - The [`From`] trait is the most flexible, useful for value _and_ reference conversions\n-//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`], but allow for the\n-//!   conversion to fail\n+//! The traits in this module are often used as trait bounds for generic functions such that to\n+//! arguments of multiple types are supported. See the documentation of each trait for examples.\n //!\n-//! As a library author, you should prefer implementing [`From<T>`][`From`] or\n+//! As a library author, you should always prefer implementing [`From<T>`][`From`] or\n //! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n //! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n //! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n-//! blanket implementation in the standard library.  However, there are some cases\n-//! where this is not possible, such as creating conversions into a type defined\n-//! outside your library, so implementing [`Into`] instead of [`From`] is\n-//! sometimes necessary.\n+//! blanket implementation in the standard library. Only implement [`Into`] or [`TryInto`]\n+//! when a conversion to a type outside the current crate is required.\n //!\n //! # Generic Implementations\n //!\n@@ -99,28 +98,22 @@ use fmt;\n #[inline]\n pub const fn identity<T>(x: T) -> T { x }\n \n-/// A cheap reference-to-reference conversion. Used to convert a value to a\n-/// reference value within generic code.\n+/// Used to do a cheap reference-to-reference conversion.\n ///\n-/// `AsRef` is very similar to, but serves a slightly different purpose than,\n-/// [`Borrow`].\n+/// This trait is similar to [`AsMut`] which is used for converting between mutable references.\n+/// If you need to do a costly conversion it is better to implement [`From`] with type\n+/// `&T` or write a custom function.\n ///\n-/// `AsRef` is to be used when wishing to convert to a reference of another\n-/// type.\n-/// `Borrow` is more related to the notion of taking the reference. It is\n-/// useful when wishing to abstract over the type of reference\n-/// (`&T`, `&mut T`) or allow both the referenced and owned type to be treated\n-/// in the same manner.\n ///\n-/// The key difference between the two traits is the intention:\n+/// `AsRef` is very similar to, but serves a slightly different purpose than [`Borrow`]:\n ///\n /// - Use `AsRef` when the goal is to simply convert into a reference\n /// - Use `Borrow` when the goal is related to writing code that is agnostic to\n ///   the type of borrow and whether it is a reference or value\n ///\n /// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a\n+/// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n@@ -134,7 +127,12 @@ pub const fn identity<T>(x: T) -> T { x }\n ///\n /// # Examples\n ///\n-/// Both [`String`] and `&str` implement `AsRef<str>`:\n+/// By using trait bounds we can accept arguments of different types as long as they can be\n+/// converted a the specified type `T`.\n+///\n+/// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n+/// want to accept all references that can be converted to &str as an argument.\n+/// Since both [`String`] and `&str` implement `AsRef<str>` we can accept both as input argument.\n ///\n /// [`String`]: ../../std/string/struct.String.html\n ///\n@@ -157,12 +155,13 @@ pub trait AsRef<T: ?Sized> {\n     fn as_ref(&self) -> &T;\n }\n \n-/// A cheap, mutable reference-to-mutable reference conversion.\n+/// Used to do a cheap mutable-to-mutable reference conversion.\n ///\n-/// This trait is similar to `AsRef` but used for converting between mutable\n-/// references.\n+/// This trait is similar to [`AsRef`] but used for converting between mutable\n+/// references. If you need to do a costly conversion it is better to\n+/// implement [`From`] with type `&mut T` or write a custom function.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a\n+/// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n@@ -176,10 +175,11 @@ pub trait AsRef<T: ?Sized> {\n ///\n /// # Examples\n ///\n-/// [`Box<T>`] implements `AsMut<T>`:\n-///\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n-///\n+/// Using `AsMut` as trait bound for a generic function we can accept all mutable references\n+/// that can be converted to type `&mut T`. Because [`Box<T>`] implements `AsMut<T>` we can\n+/// write a function `add_one`that takes all arguments that can be converted to `&mut u64`.\n+/// Because [`Box<T>`] implements `AsMut<T>` `add_one` accepts arguments of type\n+/// `&mut Box<u64>` as well:\n /// ```\n /// fn add_one<T: AsMut<u64>>(num: &mut T) {\n ///     *num.as_mut() += 1;\n@@ -189,7 +189,7 @@ pub trait AsRef<T: ?Sized> {\n /// add_one(&mut boxed_num);\n /// assert_eq!(*boxed_num, 1);\n /// ```\n-///\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n ///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsMut<T: ?Sized> {\n@@ -198,29 +198,27 @@ pub trait AsMut<T: ?Sized> {\n     fn as_mut(&mut self) -> &mut T;\n }\n \n-/// A conversion that consumes `self`, which may or may not be expensive. The\n-/// reciprocal of [`From`][From].\n+/// A value-to-value conversion that consumes the input value. The\n+/// opposite of [`From`].\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use\n-/// [`TryInto`] or a dedicated method which returns an [`Option<T>`] or a\n-/// [`Result<T, E>`].\n+/// One should only implement [`Into`] if a conversion to a type outside the current crate is\n+/// required. Otherwise one should always prefer implementing [`From`] over [`Into`] because\n+/// implementing [`From`] automatically provides one with a implementation of [`Into`] thanks to\n+/// the blanket implementation in the standard library. [`From`] cannot do these type of\n+/// conversions because of Rust's orphaning rules.\n ///\n-/// Library authors should not directly implement this trait, but should prefer\n-/// implementing the [`From`][From] trait, which offers greater flexibility and\n-/// provides an equivalent `Into` implementation for free, thanks to a blanket\n-/// implementation in the standard library.\n+/// **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n ///\n /// # Generic Implementations\n ///\n-/// - [`From<T>`][From]` for U` implies `Into<U> for T`\n-/// - [`into`] is reflexive, which means that `Into<T> for T` is implemented\n+/// - [`From<T>`]` for U` implies `Into<U> for T`\n+/// - [`Into`]` is reflexive, which means that `Into<T> for T` is implemented\n ///\n-/// # Implementing `Into`\n+/// # Implementing `Into` for conversions to external types\n ///\n-/// There is one exception to implementing `Into`, and it's kind of esoteric.\n-/// If the destination type is not part of the current crate, and it uses a\n-/// generic variable, then you can't implement `From` directly. For example,\n-/// take this crate:\n+/// If the destination type is not part of the current crate\n+/// then you can't implement [`From`] directly.\n+/// For example, take this code:\n ///\n /// ```compile_fail\n /// struct Wrapper<T>(Vec<T>);\n@@ -230,8 +228,9 @@ pub trait AsMut<T: ?Sized> {\n ///     }\n /// }\n /// ```\n-///\n-/// To fix this, you can implement `Into` directly:\n+/// This will fail to compile because we cannot implement a trait for a type\n+/// if both the trait and the type are not defined by the current crate.\n+/// This is due to Rust's orphaning rules. To bypass this, you can implement `Into` directly:\n ///\n /// ```\n /// struct Wrapper<T>(Vec<T>);\n@@ -242,17 +241,22 @@ pub trait AsMut<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// This won't always allow the conversion: for example, `try!` and `?`\n-/// always use `From`. However, in most cases, people use `Into` to do the\n-/// conversions, and this will allow that.\n+/// It is important to understand that `Into` does not provide a [`From`] implementation\n+/// (as [`From`] does with `Into`). Therefore, you should always try to implement [`From`]\n+/// and then fall back to `Into` if [`From`] can't be implemented.\n ///\n-/// In almost all cases, you should try to implement `From`, then fall back\n-/// to `Into` if `From` can't be implemented.\n+/// Prefer using `Into` over [`From`] when specifying trait bounds on a generic function\n+/// to ensure that types that only implement `Into` can be used as well.\n ///\n /// # Examples\n ///\n /// [`String`] implements `Into<Vec<u8>>`:\n ///\n+/// In order to express that we want a generic function to take all arguments that can be\n+/// converted to a specified type `T`, we can use a trait bound of `Into<T>`.\n+/// For example: The function `is_hello` takes all arguments that can be converted into a\n+/// `Vec<u8>`.\n+///\n /// ```\n /// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n ///    let bytes = b\"hello\".to_vec();\n@@ -276,44 +280,51 @@ pub trait Into<T>: Sized {\n     fn into(self) -> T;\n }\n \n-/// Simple and safe type conversions in to `Self`. It is the reciprocal of\n-/// `Into`.\n+/// Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n+/// [`Into`].\n ///\n-/// This trait is useful when performing error handling as described by\n-/// [the book][book] and is closely related to the `?` operator.\n+/// One should always prefer implementing [`From`] over [`Into`]\n+/// because implementing [`From`] automatically provides one with a implementation of [`Into`]\n+/// thanks to the blanket implementation in the standard library.\n ///\n-/// When constructing a function that is capable of failing the return type\n-/// will generally be of the form `Result<T, E>`.\n+/// Only implement [`Into`] if a conversion to a type outside the current crate is required.\n+/// [`From`] cannot do these type of conversions because of Rust's orphaning rules.\n+/// See [`Into`] for more details.\n ///\n-/// The `From` trait allows for simplification of error handling by providing a\n-/// means of returning a single error type that encapsulates numerous possible\n-/// erroneous situations.\n+/// Prefer using [`Into`] over using [`From`] when specifying trait bounds on a generic function.\n+/// This way, types that directly implement [`Into`] can be used as arguments as well.\n ///\n-/// This trait is not limited to error handling, rather the general case for\n-/// this trait would be in any type conversions to have an explicit definition\n-/// of how they are performed.\n+/// The [`From`] is also very useful when performing error handling. When constructing a function\n+/// that is capable of failing, the return type will generally be of the form `Result<T, E>`.\n+/// The `From` trait simplifies error handling by allowing a function to return a single error type\n+/// that encapsulate multiple error types. See the \"Examples\" section and [the book][book] for more\n+/// details.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use\n-/// [`TryFrom`] or a dedicated method which returns an [`Option<T>`] or a\n-/// [`Result<T, E>`].\n+/// **Note: This trait must not fail**. If the conversion can fail, use [`TryFrom`].\n ///\n /// # Generic Implementations\n ///\n-/// - `From<T> for U` implies [`Into<U>`]` for T`\n-/// - [`from`] is reflexive, which means that `From<T> for T` is implemented\n+/// - [`From<T>`]` for U` implies [`Into<U>`]` for T`\n+/// - [`From`] is reflexive, which means that `From<T> for T` is implemented\n ///\n /// # Examples\n ///\n /// [`String`] implements `From<&str>`:\n ///\n+/// An explicit conversion from a &str to a String is done as follows:\n /// ```\n /// let string = \"hello\".to_string();\n /// let other_string = String::from(\"hello\");\n ///\n /// assert_eq!(string, other_string);\n /// ```\n ///\n-/// An example usage for error handling:\n+/// While performing error handling it is often useful to implement `From` for your own error type.\n+/// By converting underlying error types to our own custom error type that encapsulates the\n+/// underlying error type, we can return a single error type without losing information on the\n+/// underlying cause. The '?' operator automatically converts the underlying error type to our\n+/// custom error type by calling `Into<CliError>::into` which is automatically provided when\n+/// implementing `From`. The compiler then infers which implementation of `Into` should be used.\n ///\n /// ```\n /// use std::fs;"}, {"sha": "1897caa5aa53f520318b8ec9b468105ed2afb5e8", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -2869,10 +2869,10 @@ impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n /// However the pointer may still dangle if it isn't dereferenced.\n ///\n /// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n-/// for your use case, you should include some PhantomData in your type to\n+/// for your use case, you should include some [`PhantomData`] in your type to\n /// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n /// Usually this won't be necessary; covariance is correct for most safe abstractions,\n-/// such as Box, Rc, Arc, Vec, and LinkedList. This is the case because they\n+/// such as `Box`, `Rc`, `Arc`, `Vec`, and `LinkedList`. This is the case because they\n /// provide a public API that follows the normal shared XOR mutable rules of Rust.\n ///\n /// Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n@@ -2883,6 +2883,7 @@ impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n /// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n /// is never used for mutation.\n ///\n+/// [`PhantomData`]: ../marker/struct.PhantomData.html\n /// [`UnsafeCell<T>`]: ../cell/struct.UnsafeCell.html\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n #[repr(transparent)]"}, {"sha": "8960c9acafa6e87852041dd26ed4500aad0deefb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -1134,20 +1134,43 @@ fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span:\n }\n \n fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+    checked_type_of(tcx, def_id, true).unwrap()\n+}\n+\n+/// Same as [`type_of`] but returns [`Option`] instead of failing.\n+///\n+/// If you want to fail anyway, you can set the `fail` parameter to true, but in this case,\n+/// you'd better just call [`type_of`] directly.\n+pub fn checked_type_of<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    fail: bool,\n+) -> Option<Ty<'tcx>> {\n     use rustc::hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n+        Some(hir_id) => hir_id,\n+        None => {\n+            if !fail {\n+                return None;\n+            }\n+            bug!(\"invalid node\");\n+        }\n+    };\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    match tcx.hir().get_by_hir_id(hir_id) {\n+    Some(match tcx.hir().get_by_hir_id(hir_id) {\n         Node::TraitItem(item) => match item.node {\n             TraitItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n             }\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n             TraitItemKind::Type(_, None) => {\n+                if !fail {\n+                    return None;\n+                }\n                 span_bug!(item.span, \"associated type missing default\");\n             }\n         },\n@@ -1229,6 +1252,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                 | ItemKind::GlobalAsm(..)\n                 | ItemKind::ExternCrate(..)\n                 | ItemKind::Use(..) => {\n+                    if !fail {\n+                        return None;\n+                    }\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n@@ -1267,7 +1293,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ..\n         }) => {\n             if gen.is_some() {\n-                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n+                return Some(tcx.typeck_tables_of(def_id).node_type(hir_id));\n             }\n \n             let substs = ty::ClosureSubsts {\n@@ -1345,6 +1371,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                             }\n                             // Sanity check to make sure everything is as expected.\n                             if !found_const {\n+                                if !fail {\n+                                    return None;\n+                                }\n                                 bug!(\"no arg matching AnonConst in path\")\n                             }\n                             match path.def {\n@@ -1360,24 +1389,37 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                                     for param in &generics.params {\n                                         if let ty::GenericParamDefKind::Const = param.kind {\n                                             if param_index == arg_index {\n-                                                return tcx.type_of(param.def_id);\n+                                                return Some(tcx.type_of(param.def_id));\n                                             }\n                                             param_index += 1;\n                                         }\n                                     }\n                                     // This is no generic parameter associated with the arg. This is\n                                     // probably from an extra arg where one is not needed.\n-                                    return tcx.types.err;\n+                                    return Some(tcx.types.err);\n                                 }\n                                 Def::Err => tcx.types.err,\n-                                x => bug!(\"unexpected const parent path def {:?}\", x),\n+                                x => {\n+                                    if !fail {\n+                                        return None;\n+                                    }\n+                                    bug!(\"unexpected const parent path def {:?}\", x);\n+                                }\n+                            }\n+                        }\n+                        x => {\n+                            if !fail {\n+                                return None;\n                             }\n+                            bug!(\"unexpected const parent path {:?}\", x);\n                         }\n-                        x => bug!(\"unexpected const parent path {:?}\", x),\n                     }\n                 }\n \n                 x => {\n+                    if !fail {\n+                        return None;\n+                    }\n                     bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n                 }\n             }\n@@ -1388,13 +1430,21 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             hir::GenericParamKind::Const { ref ty, .. } => {\n                 icx.to_ty(ty)\n             }\n-            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n+            x => {\n+                if !fail {\n+                    return None;\n+                }\n+                bug!(\"unexpected non-type Node::GenericParam: {:?}\", x)\n+            },\n         },\n \n         x => {\n+            if !fail {\n+                return None;\n+            }\n             bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n         }\n-    }\n+    })\n }\n \n fn find_existential_constraints<'a, 'tcx>("}, {"sha": "3ddc18284b302a9bc7ef36eda6ddc14096f2d1e6", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -115,6 +115,8 @@ use util::common::time;\n \n use std::iter;\n \n+pub use collect::checked_type_of;\n+\n pub struct TypeAndSubsts<'tcx> {\n     substs: SubstsRef<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "d9a63969fec972c9eb212979570649c4f852b9c3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -210,15 +210,20 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     };\n \n     let predicates = cx.tcx.predicates_of(did);\n+    let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n+    let decl = (did, sig).clean(cx);\n+    let (all_types, ret_types) = clean::get_all_types(&generics, &decl, cx);\n     clean::Function {\n-        decl: (did, sig).clean(cx),\n-        generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n+        decl,\n+        generics,\n         header: hir::FnHeader {\n             unsafety: sig.unsafety(),\n             abi: sig.abi(),\n             constness,\n             asyncness: hir::IsAsync::NotAsync,\n-        }\n+        },\n+        all_types,\n+        ret_types,\n     }\n }\n "}, {"sha": "31f757c87b23e6586c3b9480bea361744eb63670", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 188, "deletions": 7, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -1084,9 +1084,10 @@ impl GenericBound {\n \n     fn get_trait_type(&self) -> Option<Type> {\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n-            return Some(trait_.clone());\n+            Some(trait_.clone())\n+        } else {\n+            None\n         }\n-        None\n     }\n }\n \n@@ -1325,6 +1326,16 @@ pub enum WherePredicate {\n     EqPredicate { lhs: Type, rhs: Type },\n }\n \n+impl WherePredicate {\n+    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+        match *self {\n+            WherePredicate::BoundPredicate { ref bounds, .. } => Some(bounds),\n+            WherePredicate::RegionPredicate { ref bounds, .. } => Some(bounds),\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl Clean<WherePredicate> for hir::WherePredicate {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n         match *self {\n@@ -1461,6 +1472,25 @@ pub enum GenericParamDefKind {\n     },\n }\n \n+impl GenericParamDefKind {\n+    pub fn is_type(&self) -> bool {\n+        match *self {\n+            GenericParamDefKind::Type { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n+        match *self {\n+            GenericParamDefKind::Type { did, .. } => {\n+                rustc_typeck::checked_type_of(cx.tcx, did, false).map(|t| t.clean(cx))\n+            }\n+            GenericParamDefKind::Const { ref ty, .. } => Some(ty.clone()),\n+            GenericParamDefKind::Lifetime => None,\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct GenericParamDef {\n     pub name: String,\n@@ -1472,12 +1502,25 @@ impl GenericParamDef {\n     pub fn is_synthetic_type_param(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime |\n-            GenericParamDefKind::Const { .. } => {\n-                false\n-            }\n+            GenericParamDefKind::Const { .. } => false,\n             GenericParamDefKind::Type { ref synthetic, .. } => synthetic.is_some(),\n         }\n     }\n+\n+    pub fn is_type(&self) -> bool {\n+        self.kind.is_type()\n+    }\n+\n+    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n+        self.kind.get_type(cx)\n+    }\n+\n+    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+        match self.kind {\n+            GenericParamDefKind::Type { ref bounds, .. } => Some(bounds),\n+            _ => None,\n+        }\n+    }\n }\n \n impl Clean<GenericParamDef> for ty::GenericParamDef {\n@@ -1714,12 +1757,122 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n     }\n }\n \n+/// The point of this function is to replace bounds with types.\n+///\n+/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n+/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n+/// wrapped types in here).\n+fn get_real_types(\n+    generics: &Generics,\n+    arg: &Type,\n+    cx: &DocContext<'_>,\n+) -> FxHashSet<Type> {\n+    let arg_s = arg.to_string();\n+    let mut res = FxHashSet::default();\n+    if arg.is_full_generic() {\n+        if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n+            match g {\n+                &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n+                _ => false,\n+            }\n+        }) {\n+            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n+            for bound in bounds.iter() {\n+                match *bound {\n+                    GenericBound::TraitBound(ref poly_trait, _) => {\n+                        for x in poly_trait.generic_params.iter() {\n+                            if !x.is_type() {\n+                                continue\n+                            }\n+                            if let Some(ty) = x.get_type(cx) {\n+                                let adds = get_real_types(generics, &ty, cx);\n+                                if !adds.is_empty() {\n+                                    res.extend(adds);\n+                                } else if !ty.is_full_generic() {\n+                                    res.insert(ty);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        if let Some(bound) = generics.params.iter().find(|g| {\n+            g.is_type() && g.name == arg_s\n+        }) {\n+            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n+                if let Some(ty) = bound.get_trait_type() {\n+                    let adds = get_real_types(generics, &ty, cx);\n+                    if !adds.is_empty() {\n+                        res.extend(adds);\n+                    } else if !ty.is_full_generic() {\n+                        res.insert(ty.clone());\n+                    }\n+                }\n+            }\n+        }\n+    } else {\n+        res.insert(arg.clone());\n+        if let Some(gens) = arg.generics() {\n+            for gen in gens.iter() {\n+                if gen.is_full_generic() {\n+                    let adds = get_real_types(generics, gen, cx);\n+                    if !adds.is_empty() {\n+                        res.extend(adds);\n+                    }\n+                } else {\n+                    res.insert(gen.clone());\n+                }\n+            }\n+        }\n+    }\n+    res\n+}\n+\n+/// Return the full list of types when bounds have been resolved.\n+///\n+/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n+/// `[u32, Display, Option]`.\n+pub fn get_all_types(\n+    generics: &Generics,\n+    decl: &FnDecl,\n+    cx: &DocContext<'_>,\n+) -> (Vec<Type>, Vec<Type>) {\n+    let mut all_types = FxHashSet::default();\n+    for arg in decl.inputs.values.iter() {\n+        if arg.type_.is_self_type() {\n+            continue;\n+        }\n+        let args = get_real_types(generics, &arg.type_, cx);\n+        if !args.is_empty() {\n+            all_types.extend(args);\n+        } else {\n+            all_types.insert(arg.type_.clone());\n+        }\n+    }\n+\n+    let ret_types = match decl.output {\n+        FunctionRetTy::Return(ref return_type) => {\n+            let mut ret = get_real_types(generics, &return_type, cx);\n+            if ret.is_empty() {\n+                ret.insert(return_type.clone());\n+            }\n+            ret.into_iter().collect()\n+        }\n+        _ => Vec::new(),\n+    };\n+    (all_types.into_iter().collect(), ret_types)\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Method {\n     pub generics: Generics,\n     pub decl: FnDecl,\n     pub header: hir::FnHeader,\n     pub defaultness: Option<hir::Defaultness>,\n+    pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n }\n \n impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId,\n@@ -1728,11 +1881,14 @@ impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId,\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx))\n         });\n+        let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n         Method {\n             decl,\n             generics,\n             header: self.0.header,\n             defaultness: self.3,\n+            all_types,\n+            ret_types,\n         }\n     }\n }\n@@ -1742,13 +1898,17 @@ pub struct TyMethod {\n     pub header: hir::FnHeader,\n     pub decl: FnDecl,\n     pub generics: Generics,\n+    pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub header: hir::FnHeader,\n+    pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -1763,6 +1923,7 @@ impl Clean<Item> for doctree::Function {\n         } else {\n             hir::Constness::NotConst\n         };\n+        let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -1775,6 +1936,8 @@ impl Clean<Item> for doctree::Function {\n                 decl,\n                 generics,\n                 header: hir::FnHeader { constness, ..self.header },\n+                all_types,\n+                ret_types,\n             }),\n         }\n     }\n@@ -1862,7 +2025,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n         FnDecl {\n             inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n-            attrs: Attributes::default()\n+            attrs: Attributes::default(),\n         }\n     }\n }\n@@ -2044,10 +2207,13 @@ impl Clean<Item> for hir::TraitItem {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                 });\n+                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 TyMethodItem(TyMethod {\n                     header: sig.header,\n                     decl,\n                     generics,\n+                    all_types,\n+                    ret_types,\n                 })\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n@@ -2145,6 +2311,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     ty::ImplContainer(_) => true,\n                     ty::TraitContainer(_) => self.defaultness.has_value()\n                 };\n+                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 if provided {\n                     let constness = if cx.tcx.is_min_const_fn(self.def_id) {\n                         hir::Constness::Const\n@@ -2161,6 +2328,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n                         defaultness: Some(self.defaultness),\n+                        all_types,\n+                        ret_types,\n                     })\n                 } else {\n                     TyMethodItem(TyMethod {\n@@ -2171,7 +2340,9 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                             abi: sig.abi(),\n                             constness: hir::Constness::NotConst,\n                             asyncness: hir::IsAsync::NotAsync,\n-                        }\n+                        },\n+                        all_types,\n+                        ret_types,\n                     })\n                 }\n             }\n@@ -2420,6 +2591,13 @@ impl Type {\n             _ => None\n         }\n     }\n+\n+    pub fn is_full_generic(&self) -> bool {\n+        match *self {\n+            Type::Generic(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl GetDefId for Type {\n@@ -3849,6 +4027,7 @@ impl Clean<Item> for hir::ForeignItem {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                 });\n+                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 ForeignFunctionItem(Function {\n                     decl,\n                     generics,\n@@ -3858,6 +4037,8 @@ impl Clean<Item> for hir::ForeignItem {\n                         constness: hir::Constness::NotConst,\n                         asyncness: hir::IsAsync::NotAsync,\n                     },\n+                    all_types,\n+                    ret_types,\n                 })\n             }\n             hir::ForeignItemKind::Static(ref ty, mutbl) => {"}, {"sha": "866d8fe682a7b4a71b04cf4a59d42b2fce80600b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -446,7 +446,7 @@ impl ToJson for Type {\n                 }\n                 Json::Array(data)\n             }\n-            None => Json::Null\n+            None => Json::Null,\n         }\n     }\n }\n@@ -455,19 +455,27 @@ impl ToJson for Type {\n #[derive(Debug)]\n struct IndexItemFunctionType {\n     inputs: Vec<Type>,\n-    output: Option<Type>,\n+    output: Option<Vec<Type>>,\n }\n \n impl ToJson for IndexItemFunctionType {\n     fn to_json(&self) -> Json {\n         // If we couldn't figure out a type, just write `null`.\n-        if self.inputs.iter().chain(self.output.iter()).any(|ref i| i.name.is_none()) {\n+        let mut iter = self.inputs.iter();\n+        if match self.output {\n+            Some(ref output) => iter.chain(output.iter()).any(|ref i| i.name.is_none()),\n+            None => iter.any(|ref i| i.name.is_none()),\n+        } {\n             Json::Null\n         } else {\n             let mut data = Vec::with_capacity(2);\n             data.push(self.inputs.to_json());\n             if let Some(ref output) = self.output {\n-                data.push(output.to_json());\n+                if output.len() > 1 {\n+                    data.push(output.to_json());\n+                } else {\n+                    data.push(output[0].to_json());\n+                }\n             }\n             Json::Array(data)\n         }\n@@ -5025,20 +5033,26 @@ fn make_item_keywords(it: &clean::Item) -> String {\n }\n \n fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let decl = match item.inner {\n-        clean::FunctionItem(ref f) => &f.decl,\n-        clean::MethodItem(ref m) => &m.decl,\n-        clean::TyMethodItem(ref m) => &m.decl,\n-        _ => return None\n+    let (all_types, ret_types) = match item.inner {\n+        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n+        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        _ => return None,\n     };\n \n-    let inputs = decl.inputs.values.iter().map(|arg| get_index_type(&arg.type_)).collect();\n-    let output = match decl.output {\n-        clean::FunctionRetTy::Return(ref return_type) => Some(get_index_type(return_type)),\n-        _ => None\n+    let inputs = all_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect();\n+    let output = ret_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect::<Vec<_>>();\n+    let output = if output.is_empty() {\n+        None\n+    } else {\n+        Some(output)\n     };\n \n-    Some(IndexItemFunctionType { inputs: inputs, output: output })\n+    Some(IndexItemFunctionType { inputs, output })\n }\n \n fn get_index_type(clean_type: &clean::Type) -> Type {"}, {"sha": "aad7eb627bfe2603a463789a504ef879f579b541", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -714,7 +714,10 @@ if (!DOMTokenList.prototype.remove) {\n                 }\n                 lev_distance = Math.min(levenshtein(obj[NAME], val.name), lev_distance);\n                 if (lev_distance <= MAX_LEV_DISTANCE) {\n-                    lev_distance = Math.min(checkGenerics(obj, val), lev_distance);\n+                    // The generics didn't match but the name kinda did so we give it\n+                    // a levenshtein distance value that isn't *this* good so it goes\n+                    // into the search results but not too high.\n+                    lev_distance = Math.ceil((checkGenerics(obj, val) + lev_distance) / 2);\n                 } else if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n                     // We can check if the type we're looking for is inside the generics!\n                     var olength = obj[GENERICS_DATA].length;\n@@ -752,13 +755,26 @@ if (!DOMTokenList.prototype.remove) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n \n                 if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n-                    var tmp = checkType(obj.type[OUTPUT_DATA], val, literalSearch);\n-                    if (literalSearch === true && tmp === true) {\n-                        return true;\n+                    var ret = obj.type[OUTPUT_DATA];\n+                    if (!obj.type[OUTPUT_DATA].length) {\n+                        ret = [ret];\n                     }\n-                    lev_distance = Math.min(tmp, lev_distance);\n-                    if (lev_distance === 0) {\n-                        return 0;\n+                    for (var x = 0; x < ret.length; ++x) {\n+                        var r = ret[x];\n+                        if (typeof r === \"string\") {\n+                            r = [r];\n+                        }\n+                        var tmp = checkType(r, val, literalSearch);\n+                        if (literalSearch === true) {\n+                            if (tmp === true) {\n+                                return true;\n+                            }\n+                            continue;\n+                        }\n+                        lev_distance = Math.min(tmp, lev_distance);\n+                        if (lev_distance === 0) {\n+                            return 0;\n+                        }\n                     }\n                 }\n                 return literalSearch === true ? false : lev_distance;"}, {"sha": "5314255ac322b9d58b221c898e792dc68a48d270", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -1195,7 +1195,7 @@ pre.rust {\n \tborder-top: 2px solid;\n }\n \n-#titles > div:not(:last-child):not(.selected) {\n+#titles > div:not(:last-child) {\n \tmargin-right: 1px;\n \twidth: calc(33.3% - 1px);\n }"}, {"sha": "e3bb41ae672f450f2dcd50b1e5edc6d65a3bcc66", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -189,6 +189,10 @@ a.test-arrow {\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; color: #2f2f2f; }\n .stab.portability { background: #C4ECFF; border-color: #7BA5DB; color: #2f2f2f; }\n \n+.stab > code {\n+\tcolor: #ddd;\n+}\n+\n #help > div {\n \tbackground: #4d4d4d;\n \tborder-color: #bfbfbf;"}, {"sha": "dd4d028c6c9bee60d6d0a3a09cc158c3161709a8", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -190,6 +190,10 @@ a.test-arrow {\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n .stab.portability { background: #C4ECFF; border-color: #7BA5DB; }\n \n+.stab > code {\n+\tcolor: #000;\n+}\n+\n #help > div {\n \tbackground: #e9e9e9;\n \tborder-color: #bfbfbf;"}, {"sha": "c1920dde5b1fe059b3ac14cc6c5886fecfbee4c9", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -117,6 +117,7 @@ impl CompareMode {\n     }\n }\n \n+/// Configuration for compiletest\n #[derive(Clone)]\n pub struct Config {\n     /// `true` to to overwrite stderr/stdout files instead of complaining about changes in output.\n@@ -254,6 +255,8 @@ pub struct Config {\n     pub linker: Option<String>,\n     pub llvm_components: String,\n     pub llvm_cxxflags: String,\n+\n+    /// Path to a NodeJS executable. Used for JS doctests, emscripten and WASM tests\n     pub nodejs: Option<String>,\n }\n "}, {"sha": "d735d3351e6669bd862e2af872f65b0ccf26ce76", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -333,7 +333,10 @@ pub struct TestProps {\n     pub normalize_stdout: Vec<(String, String)>,\n     pub normalize_stderr: Vec<(String, String)>,\n     pub failure_status: i32,\n+    // Whether or not `rustfix` should apply the `CodeSuggestion`s of this test and compile the\n+    // resulting Rust code.\n     pub run_rustfix: bool,\n+    // If true, `rustfix` will only apply `MachineApplicable` suggestions.\n     pub rustfix_only_machine_applicable: bool,\n     pub assembly_output: Option<String>,\n }"}, {"sha": "15d449260efa0b445ac123ae28632db5ff5d3560", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -1,12 +1,12 @@\n+//! These structs are a subset of the ones found in `syntax::json`.\n+//! They are only used for deserialization of JSON output provided by libtest.\n+\n use crate::errors::{Error, ErrorKind};\n use crate::runtest::ProcRes;\n use serde_json;\n use std::path::Path;\n use std::str::FromStr;\n \n-// These structs are a subset of the ones found in\n-// `syntax::json`.\n-\n #[derive(Deserialize)]\n struct Diagnostic {\n     message: String,"}, {"sha": "d91710dda52397f9bd94153eb67fda0331c0071c", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267fb90b55736dc2362e8621a247f54da5fd8d40/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=267fb90b55736dc2362e8621a247f54da5fd8d40", "patch": "@@ -598,6 +598,8 @@ fn collect_tests_from_dir(\n     Ok(())\n }\n \n+\n+/// Returns true if `file_name` looks like a proper test file name.\n pub fn is_test(file_name: &OsString) -> bool {\n     let file_name = file_name.to_str().unwrap();\n \n@@ -1048,3 +1050,12 @@ fn test_extract_gdb_version() {\n         7012050: \"GNU gdb (GDB) 7.12.50.20161027-git\",\n     }\n }\n+\n+#[test]\n+fn is_test_test() {\n+    assert_eq!(true, is_test(&OsString::from(\"a_test.rs\")));\n+    assert_eq!(false, is_test(&OsString::from(\".a_test.rs\")));\n+    assert_eq!(false, is_test(&OsString::from(\"a_cat.gif\")));\n+    assert_eq!(false, is_test(&OsString::from(\"#a_dog_gif\")));\n+    assert_eq!(false, is_test(&OsString::from(\"~a_temp_file\")));\n+}"}]}