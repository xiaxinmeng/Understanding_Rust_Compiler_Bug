{"sha": "028e57ba1dcb95481dee4744a101e75a13cc6482", "node_id": "C_kwDOAAsO6NoAKDAyOGU1N2JhMWRjYjk1NDgxZGVlNDc0NGExMDFlNzVhMTNjYzY0ODI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-04T03:27:17Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-15T04:50:29Z"}, "message": "Rename `Interned` as `InternedInSet`.\n\nThis will let us introduce a more widely-used `Interned` type in the\nnext commit.", "tree": {"sha": "1505edb7ae933baebc50cc9395fe23e8b56a3fa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1505edb7ae933baebc50cc9395fe23e8b56a3fa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/028e57ba1dcb95481dee4744a101e75a13cc6482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/028e57ba1dcb95481dee4744a101e75a13cc6482", "html_url": "https://github.com/rust-lang/rust/commit/028e57ba1dcb95481dee4744a101e75a13cc6482", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/028e57ba1dcb95481dee4744a101e75a13cc6482/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c3f0cddde337ef596b45a8ac53aae4c8845237b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c3f0cddde337ef596b45a8ac53aae4c8845237b", "html_url": "https://github.com/rust-lang/rust/commit/0c3f0cddde337ef596b45a8ac53aae4c8845237b"}], "stats": {"total": 71, "additions": 36, "deletions": 35}, "files": [{"sha": "0842dae94260f69c0df101f985679f363e98c040", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/028e57ba1dcb95481dee4744a101e75a13cc6482/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028e57ba1dcb95481dee4744a101e75a13cc6482/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=028e57ba1dcb95481dee4744a101e75a13cc6482", "patch": "@@ -91,7 +91,7 @@ pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n #[derive(TyEncodable, TyDecodable, HashStable)]\n pub struct DelaySpanBugEmitted(());\n \n-type InternedSet<'tcx, T> = ShardedHashMap<Interned<'tcx, T>, ()>;\n+type InternedSet<'tcx, T> = ShardedHashMap<InternedInSet<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc. are allocated from.\n@@ -161,7 +161,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n                     outer_exclusive_binder: flags.outer_exclusive_binder,\n                 };\n \n-                Interned(self.arena.alloc(ty_struct))\n+                InternedInSet(self.arena.alloc(ty_struct))\n             })\n             .0\n     }\n@@ -181,7 +181,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n                     outer_exclusive_binder: flags.outer_exclusive_binder,\n                 };\n \n-                Interned(self.arena.alloc(predicate_struct))\n+                InternedInSet(self.arena.alloc(predicate_struct))\n             })\n             .0\n     }\n@@ -928,7 +928,7 @@ impl<'tcx> CommonTypes<'tcx> {\n \n impl<'tcx> CommonLifetimes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonLifetimes<'tcx> {\n-        let mk = |r| interners.region.intern(r, |r| Interned(interners.arena.alloc(r))).0;\n+        let mk = |r| interners.region.intern(r, |r| InternedInSet(interners.arena.alloc(r))).0;\n \n         CommonLifetimes {\n             re_root_empty: mk(RegionKind::ReEmpty(ty::UniverseIndex::ROOT)),\n@@ -940,7 +940,8 @@ impl<'tcx> CommonLifetimes<'tcx> {\n \n impl<'tcx> CommonConsts<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>, types: &CommonTypes<'tcx>) -> CommonConsts<'tcx> {\n-        let mk_const = |c| interners.const_.intern(c, |c| Interned(interners.arena.alloc(c))).0;\n+        let mk_const =\n+            |c| interners.const_.intern(c, |c| InternedInSet(interners.arena.alloc(c))).0;\n \n         CommonConsts {\n             unit: mk_const(ty::Const {\n@@ -1632,7 +1633,7 @@ macro_rules! nop_lift {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n             fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.$set.contains_pointer_to(&Interned(self)) {\n+                if tcx.interners.$set.contains_pointer_to(&InternedInSet(self)) {\n                     Some(unsafe { mem::transmute(self) })\n                 } else {\n                     None\n@@ -1650,7 +1651,7 @@ macro_rules! nop_list_lift {\n                 if self.is_empty() {\n                     return Some(List::empty());\n                 }\n-                if tcx.interners.$set.contains_pointer_to(&Interned(self)) {\n+                if tcx.interners.$set.contains_pointer_to(&InternedInSet(self)) {\n                     Some(unsafe { mem::transmute(self) })\n                 } else {\n                     None\n@@ -1857,7 +1858,7 @@ macro_rules! sty_debug_print {\n         #[allow(non_snake_case)]\n         mod inner {\n             use crate::ty::{self, TyCtxt};\n-            use crate::ty::context::Interned;\n+            use crate::ty::context::InternedInSet;\n \n             #[derive(Copy, Clone)]\n             struct DebugStat {\n@@ -1880,7 +1881,7 @@ macro_rules! sty_debug_print {\n \n                 let shards = tcx.interners.type_.lock_shards();\n                 let types = shards.iter().flat_map(|shard| shard.keys());\n-                for &Interned(t) in types {\n+                for &InternedInSet(t) in types {\n                     let variant = match t.kind() {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n@@ -1980,86 +1981,86 @@ impl<'tcx> TyCtxt<'tcx> {\n // this type just holds a pointer to it, but it still effectively owns it. It\n // impls `Borrow` so that it can be looked up using the original\n // (non-arena-memory-owning) types.\n-struct Interned<'tcx, T: ?Sized>(&'tcx T);\n+struct InternedInSet<'tcx, T: ?Sized>(&'tcx T);\n \n-impl<'tcx, T: 'tcx + ?Sized> Clone for Interned<'tcx, T> {\n+impl<'tcx, T: 'tcx + ?Sized> Clone for InternedInSet<'tcx, T> {\n     fn clone(&self) -> Self {\n-        Interned(self.0)\n+        InternedInSet(self.0)\n     }\n }\n \n-impl<'tcx, T: 'tcx + ?Sized> Copy for Interned<'tcx, T> {}\n+impl<'tcx, T: 'tcx + ?Sized> Copy for InternedInSet<'tcx, T> {}\n \n-impl<'tcx, T: 'tcx + ?Sized> IntoPointer for Interned<'tcx, T> {\n+impl<'tcx, T: 'tcx + ?Sized> IntoPointer for InternedInSet<'tcx, T> {\n     fn into_pointer(&self) -> *const () {\n         self.0 as *const _ as *const ()\n     }\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n+impl<'tcx> Borrow<TyKind<'tcx>> for InternedInSet<'tcx, TyS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n         &self.0.kind()\n     }\n }\n \n-impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n-    fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n+impl<'tcx> PartialEq for InternedInSet<'tcx, TyS<'tcx>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, TyS<'tcx>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n         self.0.kind() == other.0.kind()\n     }\n }\n \n-impl<'tcx> Eq for Interned<'tcx, TyS<'tcx>> {}\n+impl<'tcx> Eq for InternedInSet<'tcx, TyS<'tcx>> {}\n \n-impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n+impl<'tcx> Hash for InternedInSet<'tcx, TyS<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n         self.0.kind().hash(s)\n     }\n }\n \n-impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>> for Interned<'tcx, PredicateInner<'tcx>> {\n+impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>> for InternedInSet<'tcx, PredicateInner<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n         &self.0.kind\n     }\n }\n \n-impl<'tcx> PartialEq for Interned<'tcx, PredicateInner<'tcx>> {\n-    fn eq(&self, other: &Interned<'tcx, PredicateInner<'tcx>>) -> bool {\n+impl<'tcx> PartialEq for InternedInSet<'tcx, PredicateInner<'tcx>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, PredicateInner<'tcx>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n         self.0.kind == other.0.kind\n     }\n }\n \n-impl<'tcx> Eq for Interned<'tcx, PredicateInner<'tcx>> {}\n+impl<'tcx> Eq for InternedInSet<'tcx, PredicateInner<'tcx>> {}\n \n-impl<'tcx> Hash for Interned<'tcx, PredicateInner<'tcx>> {\n+impl<'tcx> Hash for InternedInSet<'tcx, PredicateInner<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n         self.0.kind.hash(s)\n     }\n }\n \n-impl<'tcx, T> Borrow<[T]> for Interned<'tcx, List<T>> {\n+impl<'tcx, T> Borrow<[T]> for InternedInSet<'tcx, List<T>> {\n     fn borrow<'a>(&'a self) -> &'a [T] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, List<T>> {\n-    fn eq(&self, other: &Interned<'tcx, List<T>>) -> bool {\n+impl<'tcx, T: PartialEq> PartialEq for InternedInSet<'tcx, List<T>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, List<T>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n         self.0[..] == other.0[..]\n     }\n }\n \n-impl<'tcx, T: Eq> Eq for Interned<'tcx, List<T>> {}\n+impl<'tcx, T: Eq> Eq for InternedInSet<'tcx, List<T>> {}\n \n-impl<'tcx, T: Hash> Hash for Interned<'tcx, List<T>> {\n+impl<'tcx, T: Hash> Hash for InternedInSet<'tcx, List<T>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n         self.0[..].hash(s)\n@@ -2068,23 +2069,23 @@ impl<'tcx, T: Hash> Hash for Interned<'tcx, List<T>> {\n \n macro_rules! direct_interners {\n     ($($name:ident: $method:ident($ty:ty),)+) => {\n-        $(impl<'tcx> Borrow<$ty> for Interned<'tcx, $ty> {\n+        $(impl<'tcx> Borrow<$ty> for InternedInSet<'tcx, $ty> {\n             fn borrow<'a>(&'a self) -> &'a $ty {\n                 &self.0\n             }\n         }\n \n-        impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n+        impl<'tcx> PartialEq for InternedInSet<'tcx, $ty> {\n             fn eq(&self, other: &Self) -> bool {\n                 // The `Borrow` trait requires that `x.borrow() == y.borrow()`\n                 // equals `x == y`.\n                 self.0 == other.0\n             }\n         }\n \n-        impl<'tcx> Eq for Interned<'tcx, $ty> {}\n+        impl<'tcx> Eq for InternedInSet<'tcx, $ty> {}\n \n-        impl<'tcx> Hash for Interned<'tcx, $ty> {\n+        impl<'tcx> Hash for InternedInSet<'tcx, $ty> {\n             fn hash<H: Hasher>(&self, s: &mut H) {\n                 // The `Borrow` trait requires that `x.borrow().hash(s) ==\n                 // x.hash(s)`.\n@@ -2095,7 +2096,7 @@ macro_rules! direct_interners {\n         impl<'tcx> TyCtxt<'tcx> {\n             pub fn $method(self, v: $ty) -> &'tcx $ty {\n                 self.interners.$name.intern(v, |v| {\n-                    Interned(self.interners.arena.alloc(v))\n+                    InternedInSet(self.interners.arena.alloc(v))\n                 }).0\n             }\n         })+\n@@ -2117,7 +2118,7 @@ macro_rules! slice_interners {\n         impl<'tcx> TyCtxt<'tcx> {\n             $(pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n                 self.interners.$field.intern_ref(v, || {\n-                    Interned(List::from_arena(&*self.arena, v))\n+                    InternedInSet(List::from_arena(&*self.arena, v))\n                 }).0\n             })+\n         }"}]}