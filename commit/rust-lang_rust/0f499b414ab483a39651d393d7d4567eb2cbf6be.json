{"sha": "0f499b414ab483a39651d393d7d4567eb2cbf6be", "node_id": "C_kwDOAAsO6NoAKDBmNDk5YjQxNGFiNDgzYTM5NjUxZDM5M2Q3ZDQ1NjdlYjJjYmY2YmU", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2023-03-20T06:31:01Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2023-03-20T06:31:01Z"}, "message": ":arrow_up: rust-analyzer", "tree": {"sha": "5e5850b5a541f35cce04eab6f2537498a10ba47e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e5850b5a541f35cce04eab6f2537498a10ba47e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f499b414ab483a39651d393d7d4567eb2cbf6be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f499b414ab483a39651d393d7d4567eb2cbf6be", "html_url": "https://github.com/rust-lang/rust/commit/0f499b414ab483a39651d393d7d4567eb2cbf6be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f499b414ab483a39651d393d7d4567eb2cbf6be/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d0eac4d02da8a1b139ff3dca7fc4b458fb99eb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d0eac4d02da8a1b139ff3dca7fc4b458fb99eb6", "html_url": "https://github.com/rust-lang/rust/commit/9d0eac4d02da8a1b139ff3dca7fc4b458fb99eb6"}, {"sha": "825833c26938d25a95f4c77f0e7011cffc34e15c", "url": "https://api.github.com/repos/rust-lang/rust/commits/825833c26938d25a95f4c77f0e7011cffc34e15c", "html_url": "https://github.com/rust-lang/rust/commit/825833c26938d25a95f4c77f0e7011cffc34e15c"}], "stats": {"total": 2830, "additions": 2220, "deletions": 610}, "files": [{"sha": "25242c6028a476fbbc51560e1cbe486d7f489642", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -169,9 +169,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.88.0\"\n+version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4df80a3fbc1f0e59f560eeeebca94bf655566a8ad3023c210a109deb6056455a\"\n+checksum = \"ea176c50987dc4765961aa165001e8eb5a722a26308c5797a47303ea91686aab\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -181,9 +181,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.88.0\"\n+version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f39e5272016916956298cceea5147006f897972c274a768ed4d6e074efe5d3fb\"\n+checksum = \"473b480241695428c14e8f84f1c9a47ef232450a50faf3a4041e5c9dc11e0a3b\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -192,9 +192,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.88.0\"\n+version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d9d60b42ad7478d3e027e2f9ea4e99fbbb8fdee0c8c3cf068be269f57e603618\"\n+checksum = \"6764b4fe67cac3a3758185084efbfbd39bf0352795824ba849ddd2b64cd4bb28\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -205,9 +205,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.88.0\"\n+version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab30620ea5b36819525eaab2204f4b8e1842fc7ee36826424a28bef59ae7fecf\"\n+checksum = \"55a7e6160966eceb6e7dcc2f479a2af4c477aaf5bccbc640d82515995ab1a6cc\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\","}, {"sha": "7610a3ae1e3cb5237504e9697a8064a1fac96b46", "filename": "src/tools/rust-analyzer/bench_data/numerous_macro_rules", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fnumerous_macro_rules", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fnumerous_macro_rules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fnumerous_macro_rules?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -341,8 +341,8 @@ macro_rules! __ra_macro_fixture339 {($name :  ident )=>{ impl  Clone  for $name\n macro_rules! __ra_macro_fixture340 {([$($stack :  tt )*])=>{$($stack )* }; ([$($stack :  tt )*]{$($tail :  tt )* })=>{$($stack )* { remove_sections_inner ! ([]$($tail )*); }}; ([$($stack :  tt )*]$t :  tt $($tail :  tt )*)=>{ remove_sections ! ([$($stack )* $t ]$($tail )*); }; }\n macro_rules! __ra_macro_fixture341 {($t :  ty ,$z :  expr )=>{ impl  Zero  for $t { fn  zero ()->  Self {$z  as $t } fn  is_zero (&  self )->  bool { self == &  Self ::  zero ()}}}; }\n macro_rules! __ra_macro_fixture342 {($($ident :  ident ),* $(,)?)=>{$(# [ allow ( bad_style )] pub  const $ident :  super ::  Name =  super ::  Name ::  new_inline ( stringify ! ($ident )); )* }; }\n-macro_rules! __ra_macro_fixture343 {($($trait :  ident =>$expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinDeriveExpander {$($trait ),* } impl  BuiltinDeriveExpander { pub  fn  expand (&  self ,  db : &  dyn  AstDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  Result <  tt ::  Subtree ,  mbe ::  ExpandError > { let  expander =  match *  self {$(BuiltinDeriveExpander ::$trait =>$expand , )* };  expander ( db ,  id ,  tt )} fn  find_by_name ( name : &  name ::  Name )->  Option <  Self > { match  name {$(id  if  id == &  name ::  name ! [$trait ]=> Some ( BuiltinDeriveExpander ::$trait ), )* _ => None , }}}}; }\n-macro_rules! __ra_macro_fixture344 {( LAZY : $(($name :  ident , $kind :  ident )=>$expand :  ident ),* ,  EAGER : $(($e_name :  ident , $e_kind :  ident )=>$e_expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinFnLikeExpander {$($kind ),* }# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  EagerExpander {$($e_kind ),* } impl  BuiltinFnLikeExpander { pub  fn  expand (&  self ,  db : &  dyn  AstDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  tt ::  Subtree > { let  expander =  match *  self {$(BuiltinFnLikeExpander ::$kind =>$expand , )* };  expander ( db ,  id ,  tt )}} impl  EagerExpander { pub  fn  expand (&  self ,  db : &  dyn  AstDatabase ,  arg_id :  EagerMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  Option < ( tt ::  Subtree ,  FragmentKind )>> { let  expander =  match *  self {$(EagerExpander ::$e_kind =>$e_expand , )* };  expander ( db ,  arg_id ,  tt )}} fn  find_by_name ( ident : &  name ::  Name )->  Option <  Either <  BuiltinFnLikeExpander ,  EagerExpander >> { match  ident {$(id  if  id == &  name ::  name ! [$name ]=> Some ( Either ::  Left ( BuiltinFnLikeExpander ::$kind )), )* $(id  if  id == &  name ::  name ! [$e_name ]=> Some ( Either ::  Right ( EagerExpander ::$e_kind )), )* _ => return  None , }}}; }\n+macro_rules! __ra_macro_fixture343 {($($trait :  ident =>$expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinDeriveExpander {$($trait ),* } impl  BuiltinDeriveExpander { pub  fn  expand (&  self ,  db : &  dyn  ExpandDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  Result <  tt ::  Subtree ,  mbe ::  ExpandError > { let  expander =  match *  self {$(BuiltinDeriveExpander ::$trait =>$expand , )* };  expander ( db ,  id ,  tt )} fn  find_by_name ( name : &  name ::  Name )->  Option <  Self > { match  name {$(id  if  id == &  name ::  name ! [$trait ]=> Some ( BuiltinDeriveExpander ::$trait ), )* _ => None , }}}}; }\n+macro_rules! __ra_macro_fixture344 {( LAZY : $(($name :  ident , $kind :  ident )=>$expand :  ident ),* ,  EAGER : $(($e_name :  ident , $e_kind :  ident )=>$e_expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinFnLikeExpander {$($kind ),* }# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  EagerExpander {$($e_kind ),* } impl  BuiltinFnLikeExpander { pub  fn  expand (&  self ,  db : &  dyn  ExpandDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  tt ::  Subtree > { let  expander =  match *  self {$(BuiltinFnLikeExpander ::$kind =>$expand , )* };  expander ( db ,  id ,  tt )}} impl  EagerExpander { pub  fn  expand (&  self ,  db : &  dyn  ExpandDatabase ,  arg_id :  EagerMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  Option < ( tt ::  Subtree ,  FragmentKind )>> { let  expander =  match *  self {$(EagerExpander ::$e_kind =>$e_expand , )* };  expander ( db ,  arg_id ,  tt )}} fn  find_by_name ( ident : &  name ::  Name )->  Option <  Either <  BuiltinFnLikeExpander ,  EagerExpander >> { match  ident {$(id  if  id == &  name ::  name ! [$name ]=> Some ( Either ::  Left ( BuiltinFnLikeExpander ::$kind )), )* $(id  if  id == &  name ::  name ! [$e_name ]=> Some ( Either ::  Right ( EagerExpander ::$e_kind )), )* _ => return  None , }}}; }\n macro_rules! __ra_macro_fixture345 {($($ty :  ty =>$this :  ident $im :  block );*)=>{$(impl  ToTokenTree  for $ty { fn  to_token ($this )->  tt ::  TokenTree { let  leaf :  tt ::  Leaf = $im .  into ();  leaf .  into ()}} impl  ToTokenTree  for &$ty { fn  to_token ($this )->  tt ::  TokenTree { let  leaf :  tt ::  Leaf = $im .  clone ().  into ();  leaf .  into ()}})* }}\n macro_rules! __ra_macro_fixture346 {($name :  ident )=>{ impl $crate ::  salsa ::  InternKey  for $name { fn  from_intern_id ( v : $crate ::  salsa ::  InternId )->  Self {$name ( v )} fn  as_intern_id (&  self )-> $crate ::  salsa ::  InternId { self .  0 }}}; }\n macro_rules! __ra_macro_fixture347 {($($var :  ident ($t :  ty )),+ )=>{$(impl  From <$t >  for  AttrOwner { fn  from ( t : $t )->  AttrOwner { AttrOwner ::$var ( t )}})+ }; }"}, {"sha": "b336f59ffee312f08c1128e71fcbd6f5e8ce1dde", "filename": "src/tools/rust-analyzer/crates/hir-def/src/adt.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -40,6 +40,7 @@ pub struct StructData {\n     pub repr: Option<ReprOptions>,\n     pub visibility: RawVisibility,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub fundamental: bool,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -173,10 +174,10 @@ impl StructData {\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let fundamental = attrs.by_key(\"fundamental\").exists();\n \n         let strukt = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -196,6 +197,7 @@ impl StructData {\n                 repr,\n                 visibility: item_tree[strukt.visibility].clone(),\n                 rustc_has_incoherent_inherent_impls,\n+                fundamental,\n             }),\n             diagnostics.into(),\n         )\n@@ -215,10 +217,10 @@ impl StructData {\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let fundamental = attrs.by_key(\"fundamental\").exists();\n \n         let union = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -238,6 +240,7 @@ impl StructData {\n                 repr,\n                 visibility: item_tree[union.visibility].clone(),\n                 rustc_has_incoherent_inherent_impls,\n+                fundamental,\n             }),\n             diagnostics.into(),\n         )"}, {"sha": "b70e658efd79cd6a64df12a14f37dcbe8f4f0b1f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -24,7 +24,9 @@ use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    expr::{dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId},\n+    expr::{\n+        dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId, RecordFieldPat,\n+    },\n     item_scope::BuiltinShadowMode,\n     macro_id_to_def_id,\n     nameres::DefMap,\n@@ -432,6 +434,44 @@ impl Body {\n         pats.shrink_to_fit();\n         bindings.shrink_to_fit();\n     }\n+\n+    pub fn walk_bindings_in_pat(&self, pat_id: PatId, mut f: impl FnMut(BindingId)) {\n+        self.walk_pats(pat_id, &mut |pat| {\n+            if let Pat::Bind { id, .. } = pat {\n+                f(*id);\n+            }\n+        });\n+    }\n+\n+    pub fn walk_pats(&self, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n+        let pat = &self[pat_id];\n+        f(pat);\n+        match pat {\n+            Pat::Range { .. }\n+            | Pat::Lit(..)\n+            | Pat::Path(..)\n+            | Pat::ConstBlock(..)\n+            | Pat::Wild\n+            | Pat::Missing => {}\n+            &Pat::Bind { subpat, .. } => {\n+                if let Some(subpat) = subpat {\n+                    self.walk_pats(subpat, f);\n+                }\n+            }\n+            Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n+                args.iter().copied().for_each(|p| self.walk_pats(p, f));\n+            }\n+            Pat::Ref { pat, .. } => self.walk_pats(*pat, f),\n+            Pat::Slice { prefix, slice, suffix } => {\n+                let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n+                total_iter.copied().for_each(|p| self.walk_pats(p, f));\n+            }\n+            Pat::Record { args, .. } => {\n+                args.iter().for_each(|RecordFieldPat { pat, .. }| self.walk_pats(*pat, f));\n+            }\n+            Pat::Box { inner } => self.walk_pats(*inner, f),\n+        }\n+    }\n }\n \n impl Default for Body {"}, {"sha": "fedaf39559858099094328286961bf44b7842bf2", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -499,6 +499,8 @@ impl ExprCollector<'_> {\n                         Movability::Movable\n                     };\n                     ClosureKind::Generator(movability)\n+                } else if e.async_token().is_some() {\n+                    ClosureKind::Async\n                 } else {\n                     ClosureKind::Closure\n                 };"}, {"sha": "5a9b825a2530bd5c7bf7bd8d15f5fd444b4f84b5", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -360,8 +360,14 @@ impl<'a> Printer<'a> {\n                 w!(self, \"]\");\n             }\n             Expr::Closure { args, arg_types, ret_type, body, closure_kind } => {\n-                if let ClosureKind::Generator(Movability::Static) = closure_kind {\n-                    w!(self, \"static \");\n+                match closure_kind {\n+                    ClosureKind::Generator(Movability::Static) => {\n+                        w!(self, \"static \");\n+                    }\n+                    ClosureKind::Async => {\n+                        w!(self, \"async \");\n+                    }\n+                    _ => (),\n                 }\n                 w!(self, \"|\");\n                 for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {"}, {"sha": "1633a33bedde87d1d7a0cf6c63df9e17dec1b5b3", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -35,6 +35,7 @@ pub struct FunctionData {\n     pub visibility: RawVisibility,\n     pub abi: Option<Interned<str>>,\n     pub legacy_const_generics_indices: Box<[u32]>,\n+    pub rustc_allow_incoherent_impl: bool,\n     flags: FnFlags,\n }\n \n@@ -84,13 +85,14 @@ impl FunctionData {\n             }\n         }\n \n-        let legacy_const_generics_indices = item_tree\n-            .attrs(db, krate, ModItem::from(loc.id.value).into())\n+        let attrs = item_tree.attrs(db, krate, ModItem::from(loc.id.value).into());\n+        let legacy_const_generics_indices = attrs\n             .by_key(\"rustc_legacy_const_generics\")\n             .tt_values()\n             .next()\n             .map(parse_rustc_legacy_const_generics)\n             .unwrap_or_default();\n+        let rustc_allow_incoherent_impl = attrs.by_key(\"rustc_allow_incoherent_impl\").exists();\n \n         Arc::new(FunctionData {\n             name: func.name.clone(),\n@@ -108,6 +110,7 @@ impl FunctionData {\n             abi: func.abi.clone(),\n             legacy_const_generics_indices,\n             flags,\n+            rustc_allow_incoherent_impl,\n         })\n     }\n \n@@ -171,6 +174,7 @@ pub struct TypeAliasData {\n     pub visibility: RawVisibility,\n     pub is_extern: bool,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub rustc_allow_incoherent_impl: bool,\n     /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n     pub bounds: Vec<Interned<TypeBound>>,\n }\n@@ -189,17 +193,22 @@ impl TypeAliasData {\n             item_tree[typ.visibility].clone()\n         };\n \n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(\n+            db,\n+            loc.container.module(db).krate(),\n+            ModItem::from(loc.id.value).into(),\n+        );\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let rustc_allow_incoherent_impl = attrs.by_key(\"rustc_allow_incoherent_impl\").exists();\n \n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n             type_ref: typ.type_ref.clone(),\n             visibility,\n             is_extern: matches!(loc.container, ItemContainerId::ExternBlockId(_)),\n             rustc_has_incoherent_inherent_impls,\n+            rustc_allow_incoherent_impl,\n             bounds: typ.bounds.to_vec(),\n         })\n     }\n@@ -212,11 +221,12 @@ pub struct TraitData {\n     pub is_auto: bool,\n     pub is_unsafe: bool,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub skip_array_during_method_dispatch: bool,\n+    pub fundamental: bool,\n     pub visibility: RawVisibility,\n     /// Whether the trait has `#[rust_skip_array_during_method_dispatch]`. `hir_ty` will ignore\n     /// method calls to this trait's methods when the receiver is an array and the crate edition is\n     /// 2015 or 2018.\n-    pub skip_array_during_method_dispatch: bool,\n     // box it as the vec is usually empty anyways\n     pub attribute_calls: Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n }\n@@ -245,6 +255,7 @@ impl TraitData {\n             attrs.by_key(\"rustc_skip_array_during_method_dispatch\").exists();\n         let rustc_has_incoherent_inherent_impls =\n             attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let fundamental = attrs.by_key(\"fundamental\").exists();\n         let mut collector =\n             AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n         collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n@@ -260,6 +271,7 @@ impl TraitData {\n                 visibility,\n                 skip_array_during_method_dispatch,\n                 rustc_has_incoherent_inherent_impls,\n+                fundamental,\n             }),\n             diagnostics.into(),\n         )\n@@ -450,6 +462,7 @@ pub struct ConstData {\n     pub name: Option<Name>,\n     pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n+    pub rustc_allow_incoherent_impl: bool,\n }\n \n impl ConstData {\n@@ -463,10 +476,16 @@ impl ConstData {\n             item_tree[konst.visibility].clone()\n         };\n \n+        let rustc_allow_incoherent_impl = item_tree\n+            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_allow_incoherent_impl\")\n+            .exists();\n+\n         Arc::new(ConstData {\n             name: konst.name.clone(),\n             type_ref: konst.type_ref.clone(),\n             visibility,\n+            rustc_allow_incoherent_impl,\n         })\n     }\n }"}, {"sha": "9371fc14dd8a0d3bd27e355c69cf69dd2a66066f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use base_db::{salsa, CrateId, SourceDatabase, Upcast};\n use either::Either;\n-use hir_expand::{db::AstDatabase, HirFileId};\n+use hir_expand::{db::ExpandDatabase, HirFileId};\n use intern::Interned;\n use la_arena::ArenaMap;\n use syntax::{ast, AstPtr};\n@@ -64,7 +64,7 @@ pub trait InternDatabase: SourceDatabase {\n }\n \n #[salsa::query_group(DefDatabaseStorage)]\n-pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n+pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDatabase> {\n     #[salsa::input]\n     fn enable_proc_attr_macros(&self) -> bool;\n "}, {"sha": "19fa6b25419e112cc92987a85d9a1308112b0bfd", "filename": "src/tools/rust-analyzer/crates/hir-def/src/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -245,6 +245,7 @@ pub enum Expr {\n pub enum ClosureKind {\n     Closure,\n     Generator(Movability),\n+    Async,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]"}, {"sha": "314bf22b95ee76428066b412da9574ee5f09a6e4", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -20,7 +20,7 @@ use ::mbe::TokenMap;\n use base_db::{fixture::WithFixture, ProcMacro, SourceDatabase};\n use expect_test::Expect;\n use hir_expand::{\n-    db::{AstDatabase, TokenExpander},\n+    db::{ExpandDatabase, TokenExpander},\n     AstId, InFile, MacroDefId, MacroDefKind, MacroFile,\n };\n use stdx::format_to;"}, {"sha": "4efe8c58a69e3b8f74b81672a6fce169cd699349", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -120,6 +120,8 @@ pub struct DefMap {\n     registered_tools: Vec<SmolStr>,\n     /// Unstable features of Rust enabled with `#![feature(A, B)]`.\n     unstable_features: FxHashSet<SmolStr>,\n+    /// #[rustc_coherence_is_core]\n+    rustc_coherence_is_core: bool,\n \n     edition: Edition,\n     recursion_limit: Option<u32>,\n@@ -215,7 +217,7 @@ pub struct ModuleData {\n     pub origin: ModuleOrigin,\n     /// Declared visibility of this module.\n     pub visibility: Visibility,\n-\n+    /// Always [`None`] for block modules\n     pub parent: Option<LocalModuleId>,\n     pub children: FxHashMap<Name, LocalModuleId>,\n     pub scope: ItemScope,\n@@ -292,6 +294,7 @@ impl DefMap {\n             registered_tools: Vec::new(),\n             unstable_features: FxHashSet::default(),\n             diagnostics: Vec::new(),\n+            rustc_coherence_is_core: false,\n         }\n     }\n \n@@ -325,6 +328,10 @@ impl DefMap {\n         self.unstable_features.contains(feature)\n     }\n \n+    pub fn is_rustc_coherence_is_core(&self) -> bool {\n+        self.rustc_coherence_is_core\n+    }\n+\n     pub fn root(&self) -> LocalModuleId {\n         self.root\n     }\n@@ -337,7 +344,7 @@ impl DefMap {\n         self.proc_macro_loading_error.as_deref()\n     }\n \n-    pub(crate) fn krate(&self) -> CrateId {\n+    pub fn krate(&self) -> CrateId {\n         self.krate\n     }\n \n@@ -425,7 +432,7 @@ impl DefMap {\n         Some(self.block?.parent)\n     }\n \n-    /// Returns the module containing `local_mod`, either the parent `mod`, or the module containing\n+    /// Returns the module containing `local_mod`, either the parent `mod`, or the module (or block) containing\n     /// the block, if `self` corresponds to a block expression.\n     pub fn containing_module(&self, local_mod: LocalModuleId) -> Option<ModuleId> {\n         match self[local_mod].parent {\n@@ -498,6 +505,7 @@ impl DefMap {\n             krate: _,\n             prelude: _,\n             root: _,\n+            rustc_coherence_is_core: _,\n         } = self;\n \n         extern_prelude.shrink_to_fit();"}, {"sha": "ddcee77ec4ccfa3327c4d56cf024243878df7b41", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -87,10 +87,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n                     // FIXME: a hacky way to create a Name from string.\n                     let name =\n                         tt::Ident { text: it.name.clone(), span: tt::TokenId::unspecified() };\n-                    (\n-                        name.as_name(),\n-                        ProcMacroExpander::new(def_map.krate, base_db::ProcMacroId(idx as u32)),\n-                    )\n+                    (name.as_name(), ProcMacroExpander::new(base_db::ProcMacroId(idx as u32)))\n                 })\n                 .collect()\n         }\n@@ -299,6 +296,11 @@ impl DefCollector<'_> {\n                     continue;\n                 }\n \n+                if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n+                    self.def_map.rustc_coherence_is_core = true;\n+                    continue;\n+                }\n+\n                 if *attr_name == hir_expand::name![feature] {\n                     let features =\n                         attr.parse_path_comma_token_tree().into_iter().flatten().filter_map(\n@@ -581,7 +583,7 @@ impl DefCollector<'_> {\n         let kind = def.kind.to_basedb_kind();\n         let (expander, kind) = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n             Some(&(_, expander)) => (expander, kind),\n-            None => (ProcMacroExpander::dummy(self.def_map.krate), kind),\n+            None => (ProcMacroExpander::dummy(), kind),\n         };\n \n         let proc_macro_id ="}, {"sha": "ee143b19ae5b38e7bbd32712a79590ac5e775205", "filename": "src/tools/rust-analyzer/crates/hir-def/src/test_db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -9,7 +9,7 @@ use base_db::{\n     salsa, AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, FilePosition,\n     SourceDatabase, Upcast,\n };\n-use hir_expand::{db::AstDatabase, InFile};\n+use hir_expand::{db::ExpandDatabase, InFile};\n use stdx::hash::NoHashHashSet;\n use syntax::{algo, ast, AstNode};\n \n@@ -23,7 +23,7 @@ use crate::{\n #[salsa::database(\n     base_db::SourceDatabaseExtStorage,\n     base_db::SourceDatabaseStorage,\n-    hir_expand::db::AstDatabaseStorage,\n+    hir_expand::db::ExpandDatabaseStorage,\n     crate::db::InternDatabaseStorage,\n     crate::db::DefDatabaseStorage\n )]\n@@ -40,8 +40,8 @@ impl Default for TestDB {\n     }\n }\n \n-impl Upcast<dyn AstDatabase> for TestDB {\n-    fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n+impl Upcast<dyn ExpandDatabase> for TestDB {\n+    fn upcast(&self) -> &(dyn ExpandDatabase + 'static) {\n         &*self\n     }\n }"}, {"sha": "ab76ed43d3a0e558a86e3eea66e4d5f83231ca0a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/visibility.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -131,21 +131,23 @@ impl Visibility {\n         // visibility as the containing module (even though no items are directly nameable from\n         // there, getting this right is important for method resolution).\n         // In that case, we adjust the visibility of `to_module` to point to the containing module.\n+\n         // Additional complication: `to_module` might be in `from_module`'s `DefMap`, which we're\n         // currently computing, so we must not call the `def_map` query for it.\n-        let arc;\n-        let to_module_def_map =\n-            if to_module.krate == def_map.krate() && to_module.block == def_map.block_id() {\n-                cov_mark::hit!(is_visible_from_same_block_def_map);\n-                def_map\n-            } else {\n-                arc = to_module.def_map(db);\n-                &arc\n-            };\n-        let is_block_root =\n-            to_module.block.is_some() && to_module_def_map[to_module.local_id].parent.is_none();\n-        if is_block_root {\n-            to_module = to_module_def_map.containing_module(to_module.local_id).unwrap();\n+        let mut arc;\n+        loop {\n+            let to_module_def_map =\n+                if to_module.krate == def_map.krate() && to_module.block == def_map.block_id() {\n+                    cov_mark::hit!(is_visible_from_same_block_def_map);\n+                    def_map\n+                } else {\n+                    arc = to_module.def_map(db);\n+                    &arc\n+                };\n+            match to_module_def_map.parent() {\n+                Some(parent) => to_module = parent,\n+                None => break,\n+            }\n         }\n \n         // from_module needs to be a descendant of to_module"}, {"sha": "8d1e88725ecbf2509abb9b12ffc54f3982da35a0", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/attrs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -10,7 +10,7 @@ use smallvec::{smallvec, SmallVec};\n use syntax::{ast, match_ast, AstNode, SmolStr, SyntaxNode};\n \n use crate::{\n-    db::AstDatabase,\n+    db::ExpandDatabase,\n     hygiene::Hygiene,\n     mod_path::{ModPath, PathKind},\n     name::AsName,\n@@ -38,7 +38,7 @@ impl ops::Deref for RawAttrs {\n impl RawAttrs {\n     pub const EMPTY: Self = Self { entries: None };\n \n-    pub fn new(db: &dyn AstDatabase, owner: &dyn ast::HasAttrs, hygiene: &Hygiene) -> Self {\n+    pub fn new(db: &dyn ExpandDatabase, owner: &dyn ast::HasAttrs, hygiene: &Hygiene) -> Self {\n         let entries = collect_attrs(owner)\n             .filter_map(|(id, attr)| match attr {\n                 Either::Left(attr) => {\n@@ -55,7 +55,7 @@ impl RawAttrs {\n         Self { entries: if entries.is_empty() { None } else { Some(entries) } }\n     }\n \n-    pub fn from_attrs_owner(db: &dyn AstDatabase, owner: InFile<&dyn ast::HasAttrs>) -> Self {\n+    pub fn from_attrs_owner(db: &dyn ExpandDatabase, owner: InFile<&dyn ast::HasAttrs>) -> Self {\n         let hygiene = Hygiene::new(db, owner.file_id);\n         Self::new(db, owner.value, &hygiene)\n     }\n@@ -87,7 +87,7 @@ impl RawAttrs {\n \n     /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n     // FIXME: This should return a different type\n-    pub fn filter(self, db: &dyn AstDatabase, krate: CrateId) -> RawAttrs {\n+    pub fn filter(self, db: &dyn ExpandDatabase, krate: CrateId) -> RawAttrs {\n         let has_cfg_attrs = self\n             .iter()\n             .any(|attr| attr.path.as_ident().map_or(false, |name| *name == crate::name![cfg_attr]));\n@@ -199,7 +199,7 @@ impl fmt::Display for AttrInput {\n \n impl Attr {\n     fn from_src(\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         ast: ast::Meta,\n         hygiene: &Hygiene,\n         id: AttrId,\n@@ -221,7 +221,7 @@ impl Attr {\n     }\n \n     fn from_tt(\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         tt: &tt::Subtree,\n         hygiene: &Hygiene,\n         id: AttrId,"}, {"sha": "277ecd93994225ba4ffa3ed5e26cf718ca0cd334", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,6 +1,6 @@\n //! Builtin attributes.\n \n-use crate::{db::AstDatabase, name, tt, ExpandResult, MacroCallId, MacroCallKind};\n+use crate::{db::ExpandDatabase, name, tt, ExpandResult, MacroCallId, MacroCallKind};\n \n macro_rules! register_builtin {\n     ( $(($name:ident, $variant:ident) => $expand:ident),* ) => {\n@@ -12,7 +12,7 @@ macro_rules! register_builtin {\n         impl BuiltinAttrExpander {\n             pub fn expand(\n                 &self,\n-                db: &dyn AstDatabase,\n+                db: &dyn ExpandDatabase,\n                 id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<tt::Subtree> {\n@@ -60,7 +60,7 @@ pub fn find_builtin_attr(ident: &name::Name) -> Option<BuiltinAttrExpander> {\n }\n \n fn dummy_attr_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -90,7 +90,7 @@ fn dummy_attr_expand(\n /// So this hacky approach is a lot more friendly for us, though it does require a bit of support in\n /// [`hir::Semantics`] to make this work.\n fn derive_attr_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {"}, {"sha": "5c1a75132ee94f19bd42e4c144003969d8fbb10e", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -9,7 +9,7 @@ use syntax::{\n     match_ast,\n };\n \n-use crate::{db::AstDatabase, name, quote, ExpandError, ExpandResult, MacroCallId};\n+use crate::{db::ExpandDatabase, name, quote, ExpandError, ExpandResult, MacroCallId};\n \n macro_rules! register_builtin {\n     ( $($trait:ident => $expand:ident),* ) => {\n@@ -21,7 +21,7 @@ macro_rules! register_builtin {\n         impl BuiltinDeriveExpander {\n             pub fn expand(\n                 &self,\n-                db: &dyn AstDatabase,\n+                db: &dyn ExpandDatabase,\n                 id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<tt::Subtree> {\n@@ -141,7 +141,7 @@ fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResu\n     ExpandResult::ok(expanded)\n }\n \n-fn find_builtin_crate(db: &dyn AstDatabase, id: MacroCallId) -> tt::TokenTree {\n+fn find_builtin_crate(db: &dyn ExpandDatabase, id: MacroCallId) -> tt::TokenTree {\n     // FIXME: make hygiene works for builtin derive macro\n     // such that $crate can be used here.\n     let cg = db.crate_graph();\n@@ -158,7 +158,7 @@ fn find_builtin_crate(db: &dyn AstDatabase, id: MacroCallId) -> tt::TokenTree {\n }\n \n fn copy_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -167,7 +167,7 @@ fn copy_expand(\n }\n \n fn clone_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -176,7 +176,7 @@ fn clone_expand(\n }\n \n fn default_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -185,7 +185,7 @@ fn default_expand(\n }\n \n fn debug_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -194,21 +194,25 @@ fn debug_expand(\n }\n \n fn hash_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n     expand_simple_derive(tt, quote! { #krate::hash::Hash })\n }\n \n-fn eq_expand(db: &dyn AstDatabase, id: MacroCallId, tt: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n+fn eq_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n     expand_simple_derive(tt, quote! { #krate::cmp::Eq })\n }\n \n fn partial_eq_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -217,7 +221,7 @@ fn partial_eq_expand(\n }\n \n fn ord_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -226,7 +230,7 @@ fn ord_expand(\n }\n \n fn partial_ord_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {"}, {"sha": "44510f2b7ff680c765d73055d2ecf470b9deefb4", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -10,7 +10,7 @@ use syntax::{\n };\n \n use crate::{\n-    db::AstDatabase, name, quote, tt, ExpandError, ExpandResult, MacroCallId, MacroCallLoc,\n+    db::ExpandDatabase, name, quote, tt, ExpandError, ExpandResult, MacroCallId, MacroCallLoc,\n };\n \n macro_rules! register_builtin {\n@@ -28,7 +28,7 @@ macro_rules! register_builtin {\n         impl BuiltinFnLikeExpander {\n             pub fn expand(\n                 &self,\n-                db: &dyn AstDatabase,\n+                db: &dyn ExpandDatabase,\n                 id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<tt::Subtree> {\n@@ -42,7 +42,7 @@ macro_rules! register_builtin {\n         impl EagerExpander {\n             pub fn expand(\n                 &self,\n-                db: &dyn AstDatabase,\n+                db: &dyn ExpandDatabase,\n                 arg_id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<ExpandedEager> {\n@@ -121,7 +121,7 @@ const DOLLAR_CRATE: tt::Ident =\n     tt::Ident { text: SmolStr::new_inline(\"$crate\"), span: tt::TokenId::unspecified() };\n \n fn module_path_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -130,7 +130,7 @@ fn module_path_expand(\n }\n \n fn line_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -144,23 +144,23 @@ fn line_expand(\n }\n \n fn log_syntax_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     ExpandResult::ok(quote! {})\n }\n \n fn trace_macros_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     ExpandResult::ok(quote! {})\n }\n \n fn stringify_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -174,7 +174,7 @@ fn stringify_expand(\n }\n \n fn column_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -188,7 +188,7 @@ fn column_expand(\n }\n \n fn assert_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -218,7 +218,7 @@ fn assert_expand(\n }\n \n fn file_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -234,7 +234,7 @@ fn file_expand(\n }\n \n fn format_args_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -276,7 +276,7 @@ fn format_args_expand(\n }\n \n fn asm_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -304,7 +304,7 @@ fn asm_expand(\n }\n \n fn global_asm_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -313,7 +313,7 @@ fn global_asm_expand(\n }\n \n fn cfg_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -325,7 +325,7 @@ fn cfg_expand(\n }\n \n fn panic_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -343,7 +343,7 @@ fn panic_expand(\n }\n \n fn unreachable_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -379,7 +379,7 @@ fn unquote_byte_string(lit: &tt::Literal) -> Option<Vec<u8>> {\n }\n \n fn compile_error_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -395,7 +395,7 @@ fn compile_error_expand(\n }\n \n fn concat_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -441,7 +441,7 @@ fn concat_expand(\n }\n \n fn concat_bytes_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -507,7 +507,7 @@ fn concat_bytes_expand_subtree(\n }\n \n fn concat_idents_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -529,7 +529,7 @@ fn concat_idents_expand(\n }\n \n fn relative_file(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     call_id: MacroCallId,\n     path_str: &str,\n     allow_recursion: bool,\n@@ -558,7 +558,7 @@ fn parse_string(tt: &tt::Subtree) -> Result<String, ExpandError> {\n }\n \n fn include_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -583,7 +583,7 @@ fn include_expand(\n }\n \n fn include_bytes_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -606,7 +606,7 @@ fn include_bytes_expand(\n }\n \n fn include_str_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -637,13 +637,13 @@ fn include_str_expand(\n     ExpandResult::ok(ExpandedEager::new(quote!(#text)))\n }\n \n-fn get_env_inner(db: &dyn AstDatabase, arg_id: MacroCallId, key: &str) -> Option<String> {\n+fn get_env_inner(db: &dyn ExpandDatabase, arg_id: MacroCallId, key: &str) -> Option<String> {\n     let krate = db.lookup_intern_macro_call(arg_id).krate;\n     db.crate_graph()[krate].env.get(key)\n }\n \n fn env_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -679,7 +679,7 @@ fn env_expand(\n }\n \n fn option_env_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {"}, {"sha": "45572499e84264cdf8ed44c4431e1c655ec0db43", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/db.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -44,7 +44,7 @@ pub enum TokenExpander {\n impl TokenExpander {\n     fn expand(\n         &self,\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         id: MacroCallId,\n         tt: &tt::Subtree,\n     ) -> ExpandResult<tt::Subtree> {\n@@ -83,9 +83,8 @@ impl TokenExpander {\n     }\n }\n \n-// FIXME: rename to ExpandDatabase\n-#[salsa::query_group(AstDatabaseStorage)]\n-pub trait AstDatabase: SourceDatabase {\n+#[salsa::query_group(ExpandDatabaseStorage)]\n+pub trait ExpandDatabase: SourceDatabase {\n     fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n \n     /// Main public API -- parses a hir file, not caring whether it's a real\n@@ -138,7 +137,7 @@ pub trait AstDatabase: SourceDatabase {\n /// token. The `token_to_map` mapped down into the expansion, with the mapped\n /// token returned.\n pub fn expand_speculative(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     actual_macro_call: MacroCallId,\n     speculative_args: &SyntaxNode,\n     token_to_map: SyntaxToken,\n@@ -211,7 +210,7 @@ pub fn expand_speculative(\n     let mut speculative_expansion = match loc.def.kind {\n         MacroDefKind::ProcMacro(expander, ..) => {\n             tt.delimiter = tt::Delimiter::unspecified();\n-            expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n+            expander.expand(db, loc.def.krate, loc.krate, &tt, attr_arg.as_ref())\n         }\n         MacroDefKind::BuiltInAttr(BuiltinAttrExpander::Derive, _) => {\n             pseudo_derive_attr_expansion(&tt, attr_arg.as_ref()?)\n@@ -236,12 +235,12 @@ pub fn expand_speculative(\n     Some((node.syntax_node(), token))\n }\n \n-fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n+fn ast_id_map(db: &dyn ExpandDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n     let map = db.parse_or_expand(file_id).map(|it| AstIdMap::from_source(&it)).unwrap_or_default();\n     Arc::new(map)\n }\n \n-fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n+fn parse_or_expand(db: &dyn ExpandDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n     match file_id.repr() {\n         HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n         HirFileIdRepr::MacroFile(macro_file) => {\n@@ -253,13 +252,13 @@ fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNod\n }\n \n fn parse_macro_expansion(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     macro_file: MacroFile,\n ) -> ExpandResult<Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>> {\n     let _p = profile::span(\"parse_macro_expansion\");\n-    let result = db.macro_expand(macro_file.macro_call_id);\n+    let mbe::ValueResult { value, err } = db.macro_expand(macro_file.macro_call_id);\n \n-    if let Some(err) = &result.err {\n+    if let Some(err) = &err {\n         // Note:\n         // The final goal we would like to make all parse_macro success,\n         // such that the following log will not call anyway.\n@@ -280,9 +279,9 @@ fn parse_macro_expansion(\n             parents\n         );\n     }\n-    let tt = match result.value {\n+    let tt = match value {\n         Some(tt) => tt,\n-        None => return ExpandResult { value: None, err: result.err },\n+        None => return ExpandResult { value: None, err },\n     };\n \n     let expand_to = macro_expand_to(db, macro_file.macro_call_id);\n@@ -292,11 +291,11 @@ fn parse_macro_expansion(\n \n     let (parse, rev_token_map) = token_tree_to_syntax_node(&tt, expand_to);\n \n-    ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err: result.err }\n+    ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err }\n }\n \n fn macro_arg(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n ) -> Option<Arc<(tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupUndoInfo)>> {\n     let arg = db.macro_arg_text(id)?;\n@@ -357,7 +356,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n     .unwrap_or_default()\n }\n \n-fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n+fn macro_arg_text(db: &dyn ExpandDatabase, id: MacroCallId) -> Option<GreenNode> {\n     let loc = db.lookup_intern_macro_call(id);\n     let arg = loc.kind.arg(db)?;\n     if matches!(loc.kind, MacroCallKind::FnLike { .. }) {\n@@ -380,7 +379,10 @@ fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n     Some(arg.green().into())\n }\n \n-fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError> {\n+fn macro_def(\n+    db: &dyn ExpandDatabase,\n+    id: MacroDefId,\n+) -> Result<Arc<TokenExpander>, mbe::ParseError> {\n     match id.kind {\n         MacroDefKind::Declarative(ast_id) => {\n             let (mac, def_site_token_map) = match ast_id.to_node(db) {\n@@ -419,7 +421,10 @@ fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Result<Arc<TokenExpander>,\n     }\n }\n \n-fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n+fn macro_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n     let _p = profile::span(\"macro_expand\");\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     if let Some(eager) = &loc.eager {\n@@ -469,11 +474,11 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n     ExpandResult { value: Some(Arc::new(tt)), err }\n }\n \n-fn macro_expand_error(db: &dyn AstDatabase, macro_call: MacroCallId) -> Option<ExpandError> {\n+fn macro_expand_error(db: &dyn ExpandDatabase, macro_call: MacroCallId) -> Option<ExpandError> {\n     db.macro_expand(macro_call).err\n }\n \n-fn expand_proc_macro(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<tt::Subtree> {\n+fn expand_proc_macro(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandResult<tt::Subtree> {\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     let macro_arg = match db.macro_arg(id) {\n         Some(it) => it,\n@@ -499,14 +504,14 @@ fn expand_proc_macro(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<tt::\n         _ => None,\n     };\n \n-    expander.expand(db, loc.krate, &macro_arg.0, attr_arg.as_ref())\n+    expander.expand(db, loc.def.krate, loc.krate, &macro_arg.0, attr_arg.as_ref())\n }\n \n-fn hygiene_frame(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<HygieneFrame> {\n+fn hygiene_frame(db: &dyn ExpandDatabase, file_id: HirFileId) -> Arc<HygieneFrame> {\n     Arc::new(HygieneFrame::new(db, file_id))\n }\n \n-fn macro_expand_to(db: &dyn AstDatabase, id: MacroCallId) -> ExpandTo {\n+fn macro_expand_to(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandTo {\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     loc.kind.expand_to()\n }"}, {"sha": "aca41b11f926eb3e6152ad95a1edf4bb36d2a779", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/eager.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -25,7 +25,7 @@ use syntax::{ted, SyntaxNode};\n \n use crate::{\n     ast::{self, AstNode},\n-    db::AstDatabase,\n+    db::ExpandDatabase,\n     hygiene::Hygiene,\n     mod_path::ModPath,\n     EagerCallInfo, ExpandError, ExpandResult, ExpandTo, InFile, MacroCallId, MacroCallKind,\n@@ -96,7 +96,7 @@ impl ErrorSink for &'_ mut dyn FnMut(ExpandError) {\n }\n \n pub fn expand_eager_macro(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     krate: CrateId,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n@@ -172,7 +172,7 @@ fn to_subtree(node: &SyntaxNode) -> crate::tt::Subtree {\n }\n \n fn lazy_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     def: &MacroDefId,\n     macro_call: InFile<ast::MacroCall>,\n     krate: CrateId,\n@@ -193,7 +193,7 @@ fn lazy_expand(\n }\n \n fn eager_macro_recur(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     hygiene: &Hygiene,\n     curr: InFile<SyntaxNode>,\n     krate: CrateId,"}, {"sha": "b273f21768c686772c70d11ba6b67c43cb1bd67a", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -636,9 +636,8 @@ fn foo() {\n     if {}\n }\n \"#,\n-            // the {} gets parsed as the condition, I think?\n             expect![[r#\"\n-fn foo () {if {} {}}\n+fn foo () {if __ra_fixup {} {}}\n \"#]],\n         )\n     }"}, {"sha": "2eb56fc9e8b266124fc4b244faa91fe492597ffb", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/hygiene.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n };\n \n use crate::{\n-    db::{self, AstDatabase},\n+    db::{self, ExpandDatabase},\n     fixup,\n     name::{AsName, Name},\n     HirFileId, InFile, MacroCallKind, MacroCallLoc, MacroDefKind, MacroFile,\n@@ -26,7 +26,7 @@ pub struct Hygiene {\n }\n \n impl Hygiene {\n-    pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Hygiene {\n+    pub fn new(db: &dyn ExpandDatabase, file_id: HirFileId) -> Hygiene {\n         Hygiene { frames: Some(HygieneFrames::new(db, file_id)) }\n     }\n \n@@ -37,7 +37,7 @@ impl Hygiene {\n     // FIXME: this should just return name\n     pub fn name_ref_to_name(\n         &self,\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         name_ref: ast::NameRef,\n     ) -> Either<Name, CrateId> {\n         if let Some(frames) = &self.frames {\n@@ -51,7 +51,7 @@ impl Hygiene {\n         Either::Left(name_ref.as_name())\n     }\n \n-    pub fn local_inner_macros(&self, db: &dyn AstDatabase, path: ast::Path) -> Option<CrateId> {\n+    pub fn local_inner_macros(&self, db: &dyn ExpandDatabase, path: ast::Path) -> Option<CrateId> {\n         let mut token = path.syntax().first_token()?.text_range();\n         let frames = self.frames.as_ref()?;\n         let mut current = &frames.0;\n@@ -87,13 +87,13 @@ pub struct HygieneFrame {\n }\n \n impl HygieneFrames {\n-    fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Self {\n+    fn new(db: &dyn ExpandDatabase, file_id: HirFileId) -> Self {\n         // Note that this intentionally avoids the `hygiene_frame` query to avoid blowing up memory\n         // usage. The query is only helpful for nested `HygieneFrame`s as it avoids redundant work.\n         HygieneFrames(Arc::new(HygieneFrame::new(db, file_id)))\n     }\n \n-    fn root_crate(&self, db: &dyn AstDatabase, node: &SyntaxNode) -> Option<CrateId> {\n+    fn root_crate(&self, db: &dyn ExpandDatabase, node: &SyntaxNode) -> Option<CrateId> {\n         let mut token = node.first_token()?.text_range();\n         let mut result = self.0.krate;\n         let mut current = self.0.clone();\n@@ -136,7 +136,7 @@ struct HygieneInfo {\n impl HygieneInfo {\n     fn map_ident_up(\n         &self,\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         token: TextRange,\n     ) -> Option<(InFile<TextRange>, Origin)> {\n         let token_id = self.exp_map.token_by_range(token)?;\n@@ -175,7 +175,7 @@ impl HygieneInfo {\n }\n \n fn make_hygiene_info(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     macro_file: MacroFile,\n     loc: &MacroCallLoc,\n ) -> Option<HygieneInfo> {\n@@ -215,7 +215,7 @@ fn make_hygiene_info(\n }\n \n impl HygieneFrame {\n-    pub(crate) fn new(db: &dyn AstDatabase, file_id: HirFileId) -> HygieneFrame {\n+    pub(crate) fn new(db: &dyn ExpandDatabase, file_id: HirFileId) -> HygieneFrame {\n         let (info, krate, local_inner) = match file_id.macro_file() {\n             None => (None, None, false),\n             Some(macro_file) => {"}, {"sha": "5e99eacc1b619696d59aa11ecb7f356338cae4a5", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -198,7 +198,7 @@ impl HirFileId {\n \n     /// For macro-expansion files, returns the file original source file the\n     /// expansion originated from.\n-    pub fn original_file(self, db: &dyn db::AstDatabase) -> FileId {\n+    pub fn original_file(self, db: &dyn db::ExpandDatabase) -> FileId {\n         let mut file_id = self;\n         loop {\n             match file_id.repr() {\n@@ -214,7 +214,7 @@ impl HirFileId {\n         }\n     }\n \n-    pub fn expansion_level(self, db: &dyn db::AstDatabase) -> u32 {\n+    pub fn expansion_level(self, db: &dyn db::ExpandDatabase) -> u32 {\n         let mut level = 0;\n         let mut curr = self;\n         while let Some(macro_file) = curr.macro_file() {\n@@ -227,14 +227,14 @@ impl HirFileId {\n     }\n \n     /// If this is a macro call, returns the syntax node of the call.\n-    pub fn call_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n+    pub fn call_node(self, db: &dyn db::ExpandDatabase) -> Option<InFile<SyntaxNode>> {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n         Some(loc.kind.to_node(db))\n     }\n \n     /// If this is a macro call, returns the syntax node of the very first macro call this file resides in.\n-    pub fn original_call_node(self, db: &dyn db::AstDatabase) -> Option<(FileId, SyntaxNode)> {\n+    pub fn original_call_node(self, db: &dyn db::ExpandDatabase) -> Option<(FileId, SyntaxNode)> {\n         let mut call =\n             db.lookup_intern_macro_call(self.macro_file()?.macro_call_id).kind.to_node(db);\n         loop {\n@@ -248,7 +248,7 @@ impl HirFileId {\n     }\n \n     /// Return expansion information if it is a macro-expansion file\n-    pub fn expansion_info(self, db: &dyn db::AstDatabase) -> Option<ExpansionInfo> {\n+    pub fn expansion_info(self, db: &dyn db::ExpandDatabase) -> Option<ExpansionInfo> {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n \n@@ -294,7 +294,7 @@ impl HirFileId {\n     }\n \n     /// Indicate it is macro file generated for builtin derive\n-    pub fn is_builtin_derive(&self, db: &dyn db::AstDatabase) -> Option<InFile<ast::Attr>> {\n+    pub fn is_builtin_derive(&self, db: &dyn db::ExpandDatabase) -> Option<InFile<ast::Attr>> {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n         let attr = match loc.def.kind {\n@@ -304,7 +304,7 @@ impl HirFileId {\n         Some(attr.with_value(ast::Attr::cast(attr.value.clone())?))\n     }\n \n-    pub fn is_custom_derive(&self, db: &dyn db::AstDatabase) -> bool {\n+    pub fn is_custom_derive(&self, db: &dyn db::ExpandDatabase) -> bool {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n@@ -315,7 +315,7 @@ impl HirFileId {\n     }\n \n     /// Return whether this file is an include macro\n-    pub fn is_include_macro(&self, db: &dyn db::AstDatabase) -> bool {\n+    pub fn is_include_macro(&self, db: &dyn db::ExpandDatabase) -> bool {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n@@ -326,7 +326,7 @@ impl HirFileId {\n     }\n \n     /// Return whether this file is an attr macro\n-    pub fn is_attr_macro(&self, db: &dyn db::AstDatabase) -> bool {\n+    pub fn is_attr_macro(&self, db: &dyn db::ExpandDatabase) -> bool {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n@@ -338,7 +338,7 @@ impl HirFileId {\n \n     /// Return whether this file is the pseudo expansion of the derive attribute.\n     /// See [`crate::builtin_attr_macro::derive_attr_expand`].\n-    pub fn is_derive_attr_pseudo_expansion(&self, db: &dyn db::AstDatabase) -> bool {\n+    pub fn is_derive_attr_pseudo_expansion(&self, db: &dyn db::ExpandDatabase) -> bool {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n@@ -384,7 +384,7 @@ impl HirFileId {\n impl MacroDefId {\n     pub fn as_lazy_macro(\n         self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n         krate: CrateId,\n         kind: MacroCallKind,\n     ) -> MacroCallId {\n@@ -427,7 +427,7 @@ impl MacroCallKind {\n         }\n     }\n \n-    pub fn to_node(&self, db: &dyn db::AstDatabase) -> InFile<SyntaxNode> {\n+    pub fn to_node(&self, db: &dyn db::ExpandDatabase) -> InFile<SyntaxNode> {\n         match self {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n@@ -465,7 +465,7 @@ impl MacroCallKind {\n     /// Returns the original file range that best describes the location of this macro call.\n     ///\n     /// Unlike `MacroCallKind::original_call_range`, this also spans the item of attributes and derives.\n-    pub fn original_call_range_with_body(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_call_range_with_body(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         let mut kind = self;\n         let file_id = loop {\n             match kind.file_id().repr() {\n@@ -490,7 +490,7 @@ impl MacroCallKind {\n     /// Here we try to roughly match what rustc does to improve diagnostics: fn-like macros\n     /// get the whole `ast::MacroCall`, attribute macros get the attribute's range, and derives\n     /// get only the specific derive that is being referred to.\n-    pub fn original_call_range(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_call_range(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         let mut kind = self;\n         let file_id = loop {\n             match kind.file_id().repr() {\n@@ -529,7 +529,7 @@ impl MacroCallKind {\n         FileRange { range, file_id }\n     }\n \n-    fn arg(&self, db: &dyn db::AstDatabase) -> Option<SyntaxNode> {\n+    fn arg(&self, db: &dyn db::ExpandDatabase) -> Option<SyntaxNode> {\n         match self {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 Some(ast_id.to_node(db).token_tree()?.syntax().clone())\n@@ -597,7 +597,7 @@ impl ExpansionInfo {\n     ///     Both of these only have one simple call site input so no special handling is required here.\n     pub fn map_token_down(\n         &self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n         item: Option<ast::Item>,\n         token: InFile<&SyntaxToken>,\n     ) -> Option<impl Iterator<Item = InFile<SyntaxToken>> + '_> {\n@@ -666,7 +666,7 @@ impl ExpansionInfo {\n     /// Map a token up out of the expansion it resides in into the arguments of the macro call of the expansion.\n     pub fn map_token_up(\n         &self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n         token: InFile<&SyntaxToken>,\n     ) -> Option<(InFile<SyntaxToken>, Origin)> {\n         // Fetch the id through its text range,\n@@ -717,7 +717,7 @@ impl ExpansionInfo {\n pub type AstId<N> = InFile<FileAstId<N>>;\n \n impl<N: AstNode> AstId<N> {\n-    pub fn to_node(&self, db: &dyn db::AstDatabase) -> N {\n+    pub fn to_node(&self, db: &dyn db::ExpandDatabase) -> N {\n         let root = db.parse_or_expand(self.file_id).unwrap();\n         db.ast_id_map(self.file_id).get(self.value).to_node(&root)\n     }\n@@ -753,7 +753,7 @@ impl<T> InFile<T> {\n         self.with_value(&self.value)\n     }\n \n-    pub fn file_syntax(&self, db: &dyn db::AstDatabase) -> SyntaxNode {\n+    pub fn file_syntax(&self, db: &dyn db::ExpandDatabase) -> SyntaxNode {\n         db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n     }\n }\n@@ -783,7 +783,7 @@ impl<L, R> InFile<Either<L, R>> {\n impl<'a> InFile<&'a SyntaxNode> {\n     pub fn ancestors_with_macros(\n         self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + Clone + '_ {\n         iter::successors(Some(self.cloned()), move |node| match node.value.parent() {\n             Some(parent) => Some(node.with_value(parent)),\n@@ -794,7 +794,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     /// Skips the attributed item that caused the macro invocation we are climbing up\n     pub fn ancestors_with_macros_skip_attr_item(\n         self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + '_ {\n         let succ = move |node: &InFile<SyntaxNode>| match node.value.parent() {\n             Some(parent) => Some(node.with_value(parent)),\n@@ -816,7 +816,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     ///\n     /// For attributes and derives, this will point back to the attribute only.\n     /// For the entire item use [`InFile::original_file_range_full`].\n-    pub fn original_file_range(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_file_range(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n             HirFileIdRepr::MacroFile(mac_file) => {\n@@ -831,7 +831,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     }\n \n     /// Falls back to the macro call range if the node cannot be mapped up fully.\n-    pub fn original_file_range_full(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_file_range_full(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n             HirFileIdRepr::MacroFile(mac_file) => {\n@@ -846,7 +846,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     }\n \n     /// Attempts to map the syntax node back up its macro calls.\n-    pub fn original_file_range_opt(self, db: &dyn db::AstDatabase) -> Option<FileRange> {\n+    pub fn original_file_range_opt(self, db: &dyn db::ExpandDatabase) -> Option<FileRange> {\n         match ascend_node_border_tokens(db, self) {\n             Some(InFile { file_id, value: (first, last) }) => {\n                 let original_file = file_id.original_file(db);\n@@ -865,7 +865,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n         }\n     }\n \n-    pub fn original_syntax_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n+    pub fn original_syntax_node(self, db: &dyn db::ExpandDatabase) -> Option<InFile<SyntaxNode>> {\n         // This kind of upmapping can only be achieved in attribute expanded files,\n         // as we don't have node inputs otherwise and therefore can't find an `N` node in the input\n         if !self.file_id.is_macro() {\n@@ -892,13 +892,13 @@ impl<'a> InFile<&'a SyntaxNode> {\n }\n \n impl InFile<SyntaxToken> {\n-    pub fn upmap(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxToken>> {\n+    pub fn upmap(self, db: &dyn db::ExpandDatabase) -> Option<InFile<SyntaxToken>> {\n         let expansion = self.file_id.expansion_info(db)?;\n         expansion.map_token_up(db, self.as_ref()).map(|(it, _)| it)\n     }\n \n     /// Falls back to the macro call range if the node cannot be mapped up fully.\n-    pub fn original_file_range(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_file_range(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n             HirFileIdRepr::MacroFile(mac_file) => {\n@@ -913,7 +913,7 @@ impl InFile<SyntaxToken> {\n     }\n \n     /// Attempts to map the syntax node back up its macro calls.\n-    pub fn original_file_range_opt(self, db: &dyn db::AstDatabase) -> Option<FileRange> {\n+    pub fn original_file_range_opt(self, db: &dyn db::ExpandDatabase) -> Option<FileRange> {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => {\n                 Some(FileRange { file_id, range: self.value.text_range() })\n@@ -932,7 +932,7 @@ impl InFile<SyntaxToken> {\n \n     pub fn ancestors_with_macros(\n         self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + '_ {\n         self.value.parent().into_iter().flat_map({\n             let file_id = self.file_id;\n@@ -942,7 +942,7 @@ impl InFile<SyntaxToken> {\n }\n \n fn ascend_node_border_tokens(\n-    db: &dyn db::AstDatabase,\n+    db: &dyn db::ExpandDatabase,\n     InFile { file_id, value: node }: InFile<&SyntaxNode>,\n ) -> Option<InFile<(SyntaxToken, SyntaxToken)>> {\n     let expansion = file_id.expansion_info(db)?;\n@@ -958,7 +958,7 @@ fn ascend_node_border_tokens(\n }\n \n fn ascend_call_token(\n-    db: &dyn db::AstDatabase,\n+    db: &dyn db::ExpandDatabase,\n     expansion: &ExpansionInfo,\n     token: InFile<SyntaxToken>,\n ) -> Option<InFile<SyntaxToken>> {\n@@ -977,7 +977,7 @@ impl<N: AstNode> InFile<N> {\n         self.value.syntax().descendants().filter_map(T::cast).map(move |n| self.with_value(n))\n     }\n \n-    pub fn original_ast_node(self, db: &dyn db::AstDatabase) -> Option<InFile<N>> {\n+    pub fn original_ast_node(self, db: &dyn db::ExpandDatabase) -> Option<InFile<N>> {\n         // This kind of upmapping can only be achieved in attribute expanded files,\n         // as we don't have node inputs otherwise and therefore can't find an `N` node in the input\n         if !self.file_id.is_macro() {"}, {"sha": "e9393cc89aedf021ad3a6533fd79d0be6537fc7e", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -6,7 +6,7 @@ use std::{\n };\n \n use crate::{\n-    db::AstDatabase,\n+    db::ExpandDatabase,\n     hygiene::Hygiene,\n     name::{known, Name},\n };\n@@ -37,7 +37,11 @@ pub enum PathKind {\n }\n \n impl ModPath {\n-    pub fn from_src(db: &dyn AstDatabase, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n+    pub fn from_src(\n+        db: &dyn ExpandDatabase,\n+        path: ast::Path,\n+        hygiene: &Hygiene,\n+    ) -> Option<ModPath> {\n         convert_path(db, None, path, hygiene)\n     }\n \n@@ -162,7 +166,7 @@ impl From<Name> for ModPath {\n }\n \n fn convert_path(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     prefix: Option<ModPath>,\n     path: ast::Path,\n     hygiene: &Hygiene,"}, {"sha": "d758e9302cd87d90a8d20b048353fcd5af723499", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/proc_macro.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -3,22 +3,20 @@\n use base_db::{CrateId, ProcMacroExpansionError, ProcMacroId, ProcMacroKind};\n use stdx::never;\n \n-use crate::{db::AstDatabase, tt, ExpandError, ExpandResult};\n+use crate::{db::ExpandDatabase, tt, ExpandError, ExpandResult};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n-    krate: CrateId,\n     proc_macro_id: Option<ProcMacroId>,\n }\n \n impl ProcMacroExpander {\n-    pub fn new(krate: CrateId, proc_macro_id: ProcMacroId) -> Self {\n-        Self { krate, proc_macro_id: Some(proc_macro_id) }\n+    pub fn new(proc_macro_id: ProcMacroId) -> Self {\n+        Self { proc_macro_id: Some(proc_macro_id) }\n     }\n \n-    pub fn dummy(krate: CrateId) -> Self {\n-        // FIXME: Should store the name for better errors\n-        Self { krate, proc_macro_id: None }\n+    pub fn dummy() -> Self {\n+        Self { proc_macro_id: None }\n     }\n \n     pub fn is_dummy(&self) -> bool {\n@@ -27,15 +25,16 @@ impl ProcMacroExpander {\n \n     pub fn expand(\n         self,\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n+        def_crate: CrateId,\n         calling_crate: CrateId,\n         tt: &tt::Subtree,\n         attr_arg: Option<&tt::Subtree>,\n     ) -> ExpandResult<tt::Subtree> {\n         match self.proc_macro_id {\n             Some(id) => {\n                 let krate_graph = db.crate_graph();\n-                let proc_macros = match &krate_graph[self.krate].proc_macro {\n+                let proc_macros = match &krate_graph[def_crate].proc_macro {\n                     Ok(proc_macros) => proc_macros,\n                     Err(_) => {\n                         never!(\"Non-dummy expander even though there are no proc macros\");\n@@ -84,7 +83,7 @@ impl ProcMacroExpander {\n             }\n             None => ExpandResult::with_err(\n                 tt::Subtree::empty(),\n-                ExpandError::UnresolvedProcMacro(self.krate),\n+                ExpandError::UnresolvedProcMacro(def_crate),\n             ),\n         }\n     }"}, {"sha": "9b3296df2508a4ba684afb05291ceb82e07f2b1c", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -22,10 +22,10 @@ either = \"1.7.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1.0.0\"\n-chalk-solve = { version = \"0.88.0\", default-features = false }\n-chalk-ir = \"0.88.0\"\n-chalk-recursive = { version = \"0.88.0\", default-features = false }\n-chalk-derive = \"0.88.0\"\n+chalk-solve = { version = \"0.89.0\", default-features = false }\n+chalk-ir = \"0.89.0\"\n+chalk-recursive = { version = \"0.89.0\", default-features = false }\n+chalk-derive = \"0.89.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.17.0\"\n typed-arena = \"2.0.1\""}, {"sha": "2141894922f7b78c1a07f386148cdbeb5579f999", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -12,7 +12,7 @@ use hir_def::{\n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n     from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n-    CallableDefId, CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n+    CallableDefId, CallableSig, DynTy, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n     QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags, WhereClause,\n };\n \n@@ -378,6 +378,19 @@ impl ProjectionTyExt for ProjectionTy {\n     }\n }\n \n+pub trait DynTyExt {\n+    fn principal(&self) -> Option<&TraitRef>;\n+}\n+\n+impl DynTyExt for DynTy {\n+    fn principal(&self) -> Option<&TraitRef> {\n+        self.bounds.skip_binders().interned().get(0).and_then(|b| match b.skip_binders() {\n+            crate::WhereClause::Implemented(trait_ref) => Some(trait_ref),\n+            _ => None,\n+        })\n+    }\n+}\n+\n pub trait TraitRefExt {\n     fn hir_trait_id(&self) -> TraitId;\n }"}, {"sha": "4b147b99707c15ad6c71a171307b605cec108fe6", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -11,3 +11,9 @@ pub use crate::diagnostics::{\n     },\n     unsafe_check::{missing_unsafe, unsafe_expressions, UnsafeExpr},\n };\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct IncoherentImpl {\n+    pub file_id: hir_expand::HirFileId,\n+    pub impl_: syntax::AstPtr<syntax::ast::Impl>,\n+}"}, {"sha": "ee186673ee130ab8d13daca76e82319c47aac6c0", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -275,7 +275,23 @@ impl<'a> InferenceContext<'a> {\n                     Some(type_ref) => self.make_ty(type_ref),\n                     None => self.table.new_type_var(),\n                 };\n-                sig_tys.push(ret_ty.clone());\n+                if let ClosureKind::Async = closure_kind {\n+                    // Use the first type parameter as the output type of future.\n+                    // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n+                    let impl_trait_id =\n+                        crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n+                    let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n+                    sig_tys.push(\n+                        TyKind::OpaqueType(\n+                            opaque_ty_id,\n+                            Substitution::from1(Interner, ret_ty.clone()),\n+                        )\n+                        .intern(Interner),\n+                    );\n+                } else {\n+                    sig_tys.push(ret_ty.clone());\n+                }\n+\n                 let sig_ty = TyKind::Function(FnPointer {\n                     num_binders: 0,\n                     sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n@@ -286,33 +302,38 @@ impl<'a> InferenceContext<'a> {\n                 })\n                 .intern(Interner);\n \n-                let (ty, resume_yield_tys) = if matches!(closure_kind, ClosureKind::Generator(_)) {\n-                    // FIXME: report error when there are more than 1 parameter.\n-                    let resume_ty = match sig_tys.first() {\n-                        // When `sig_tys.len() == 1` the first type is the return type, not the\n-                        // first parameter type.\n-                        Some(ty) if sig_tys.len() > 1 => ty.clone(),\n-                        _ => self.result.standard_types.unit.clone(),\n-                    };\n-                    let yield_ty = self.table.new_type_var();\n-\n-                    let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n-                        .push(resume_ty.clone())\n-                        .push(yield_ty.clone())\n-                        .push(ret_ty.clone())\n-                        .build();\n+                let (ty, resume_yield_tys) = match closure_kind {\n+                    ClosureKind::Generator(_) => {\n+                        // FIXME: report error when there are more than 1 parameter.\n+                        let resume_ty = match sig_tys.first() {\n+                            // When `sig_tys.len() == 1` the first type is the return type, not the\n+                            // first parameter type.\n+                            Some(ty) if sig_tys.len() > 1 => ty.clone(),\n+                            _ => self.result.standard_types.unit.clone(),\n+                        };\n+                        let yield_ty = self.table.new_type_var();\n+\n+                        let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n+                            .push(resume_ty.clone())\n+                            .push(yield_ty.clone())\n+                            .push(ret_ty.clone())\n+                            .build();\n \n-                    let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n-                    let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n+                        let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n+                        let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n \n-                    (generator_ty, Some((resume_ty, yield_ty)))\n-                } else {\n-                    let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n-                    let closure_ty =\n-                        TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n-                            .intern(Interner);\n+                        (generator_ty, Some((resume_ty, yield_ty)))\n+                    }\n+                    ClosureKind::Closure | ClosureKind::Async => {\n+                        let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n+                        let closure_ty = TyKind::Closure(\n+                            closure_id,\n+                            Substitution::from1(Interner, sig_ty.clone()),\n+                        )\n+                        .intern(Interner);\n \n-                    (closure_ty, None)\n+                        (closure_ty, None)\n+                    }\n                 };\n \n                 // Eagerly try to relate the closure type with the expected\n@@ -321,7 +342,7 @@ impl<'a> InferenceContext<'a> {\n                 self.deduce_closure_type_from_expectations(tgt_expr, &ty, &sig_ty, expected);\n \n                 // Now go through the argument patterns\n-                for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n+                for (arg_pat, arg_ty) in args.iter().zip(&sig_tys) {\n                     self.infer_top_pat(*arg_pat, &arg_ty);\n                 }\n "}, {"sha": "5f839fc307aabf79191f9b27c81d513f0f77d696", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -5,10 +5,7 @@ use std::iter::repeat_with;\n use chalk_ir::Mutability;\n use hir_def::{\n     body::Body,\n-    expr::{\n-        Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId,\n-        RecordFieldPat,\n-    },\n+    expr::{Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId},\n     path::Path,\n };\n use hir_expand::name::Name;\n@@ -439,38 +436,8 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n \n pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {\n     let mut res = false;\n-    walk_pats(body, pat_id, &mut |pat| {\n+    body.walk_pats(pat_id, &mut |pat| {\n         res |= matches!(pat, Pat::Bind { id, .. } if body.bindings[*id].mode == BindingAnnotation::Ref);\n     });\n     res\n }\n-\n-fn walk_pats(body: &Body, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n-    let pat = &body[pat_id];\n-    f(pat);\n-    match pat {\n-        Pat::Range { .. }\n-        | Pat::Lit(..)\n-        | Pat::Path(..)\n-        | Pat::ConstBlock(..)\n-        | Pat::Wild\n-        | Pat::Missing => {}\n-        &Pat::Bind { subpat, .. } => {\n-            if let Some(subpat) = subpat {\n-                walk_pats(body, subpat, f);\n-            }\n-        }\n-        Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n-            args.iter().copied().for_each(|p| walk_pats(body, p, f));\n-        }\n-        Pat::Ref { pat, .. } => walk_pats(body, *pat, f),\n-        Pat::Slice { prefix, slice, suffix } => {\n-            let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n-            total_iter.copied().for_each(|p| walk_pats(body, p, f));\n-        }\n-        Pat::Record { args, .. } => {\n-            args.iter().for_each(|RecordFieldPat { pat, .. }| walk_pats(body, *pat, f));\n-        }\n-        Pat::Box { inner } => walk_pats(body, *inner, f),\n-    }\n-}"}, {"sha": "f3a27632bf545f9c578bb1a8bcd9673fb9186e75", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 83, "deletions": 9, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -19,13 +19,13 @@ use stdx::never;\n use crate::{\n     autoderef::{self, AutoderefKind},\n     db::HirDatabase,\n-    from_foreign_def_id,\n+    from_chalk_trait_id, from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n-    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n-    Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt,\n+    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, DynTyExt, ForeignDefId, InEnvironment,\n+    Interner, Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt,\n };\n \n /// This is used as a key for indexing impls.\n@@ -266,11 +266,12 @@ impl TraitImpls {\n #[derive(Debug, Eq, PartialEq)]\n pub struct InherentImpls {\n     map: FxHashMap<TyFingerprint, Vec<ImplId>>,\n+    invalid_impls: Vec<ImplId>,\n }\n \n impl InherentImpls {\n     pub(crate) fn inherent_impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n-        let mut impls = Self { map: FxHashMap::default() };\n+        let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n \n         let crate_def_map = db.crate_def_map(krate);\n         impls.collect_def_map(db, &crate_def_map);\n@@ -283,7 +284,7 @@ impl InherentImpls {\n         db: &dyn HirDatabase,\n         block: BlockId,\n     ) -> Option<Arc<Self>> {\n-        let mut impls = Self { map: FxHashMap::default() };\n+        let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n         if let Some(block_def_map) = db.block_def_map(block) {\n             impls.collect_def_map(db, &block_def_map);\n             impls.shrink_to_fit();\n@@ -306,11 +307,17 @@ impl InherentImpls {\n                 }\n \n                 let self_ty = db.impl_self_ty(impl_id);\n-                let fp = TyFingerprint::for_inherent_impl(self_ty.skip_binders());\n-                if let Some(fp) = fp {\n-                    self.map.entry(fp).or_default().push(impl_id);\n+                let self_ty = self_ty.skip_binders();\n+\n+                match is_inherent_impl_coherent(db, def_map, &data, self_ty) {\n+                    true => {\n+                        // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n+                        if let Some(fp) = TyFingerprint::for_inherent_impl(self_ty) {\n+                            self.map.entry(fp).or_default().push(impl_id);\n+                        }\n+                    }\n+                    false => self.invalid_impls.push(impl_id),\n                 }\n-                // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n             }\n \n             // To better support custom derives, collect impls in all unnamed const items.\n@@ -334,6 +341,10 @@ impl InherentImpls {\n     pub fn all_impls(&self) -> impl Iterator<Item = ImplId> + '_ {\n         self.map.values().flat_map(|v| v.iter().copied())\n     }\n+\n+    pub fn invalid_impls(&self) -> &[ImplId] {\n+        &self.invalid_impls\n+    }\n }\n \n pub(crate) fn incoherent_inherent_impl_crates(\n@@ -775,6 +786,69 @@ fn find_matching_impl(\n     }\n }\n \n+fn is_inherent_impl_coherent(\n+    db: &dyn HirDatabase,\n+    def_map: &DefMap,\n+    impl_data: &ImplData,\n+    self_ty: &Ty,\n+) -> bool {\n+    let self_ty = self_ty.kind(Interner);\n+    let impl_allowed = match self_ty {\n+        TyKind::Tuple(_, _)\n+        | TyKind::FnDef(_, _)\n+        | TyKind::Array(_, _)\n+        | TyKind::Never\n+        | TyKind::Raw(_, _)\n+        | TyKind::Ref(_, _, _)\n+        | TyKind::Slice(_)\n+        | TyKind::Str\n+        | TyKind::Scalar(_) => def_map.is_rustc_coherence_is_core(),\n+\n+        &TyKind::Adt(AdtId(adt), _) => adt.module(db.upcast()).krate() == def_map.krate(),\n+        TyKind::Dyn(it) => it.principal().map_or(false, |trait_ref| {\n+            from_chalk_trait_id(trait_ref.trait_id).module(db.upcast()).krate() == def_map.krate()\n+        }),\n+\n+        _ => true,\n+    };\n+    impl_allowed || {\n+        let rustc_has_incoherent_inherent_impls = match self_ty {\n+            TyKind::Tuple(_, _)\n+            | TyKind::FnDef(_, _)\n+            | TyKind::Array(_, _)\n+            | TyKind::Never\n+            | TyKind::Raw(_, _)\n+            | TyKind::Ref(_, _, _)\n+            | TyKind::Slice(_)\n+            | TyKind::Str\n+            | TyKind::Scalar(_) => true,\n+\n+            &TyKind::Adt(AdtId(adt), _) => match adt {\n+                hir_def::AdtId::StructId(it) => {\n+                    db.struct_data(it).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::UnionId(it) => {\n+                    db.union_data(it).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::EnumId(it) => db.enum_data(it).rustc_has_incoherent_inherent_impls,\n+            },\n+            TyKind::Dyn(it) => it.principal().map_or(false, |trait_ref| {\n+                db.trait_data(from_chalk_trait_id(trait_ref.trait_id))\n+                    .rustc_has_incoherent_inherent_impls\n+            }),\n+\n+            _ => false,\n+        };\n+        rustc_has_incoherent_inherent_impls\n+            && !impl_data.items.is_empty()\n+            && impl_data.items.iter().copied().all(|assoc| match assoc {\n+                AssocItemId::FunctionId(it) => db.function_data(it).rustc_allow_incoherent_impl,\n+                AssocItemId::ConstId(it) => db.const_data(it).rustc_allow_incoherent_impl,\n+                AssocItemId::TypeAliasId(it) => db.type_alias_data(it).rustc_allow_incoherent_impl,\n+            })\n+    }\n+}\n+\n pub fn iterate_path_candidates(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,"}, {"sha": "c4dd7c0ace46c150663cb5641c72d21d630a6dcf", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1113,7 +1113,7 @@ impl MirLowerCtx<'_> {\n                 if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n                     binding_mode = mode;\n                 }\n-                self.push_storage_live(*id, current)?;\n+                self.push_storage_live(*id, current);\n                 self.push_assignment(\n                     current,\n                     target_place.into(),\n@@ -1327,8 +1327,9 @@ impl MirLowerCtx<'_> {\n         is_ty_uninhabited_from(&self.infer[expr_id], self.owner.module(self.db.upcast()), self.db)\n     }\n \n-    /// This function push `StorageLive` statements for each binding in the pattern.\n-    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) -> Result<()> {\n+    /// This function push `StorageLive` statement for the binding, and applies changes to add `StorageDead` in\n+    /// the appropriated places.\n+    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) {\n         // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n         // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeeded in\n         // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n@@ -1356,7 +1357,6 @@ impl MirLowerCtx<'_> {\n         let l = self.result.binding_locals[b];\n         self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n         self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n-        Ok(())\n     }\n \n     fn resolve_lang_item(&self, item: LangItem) -> Result<LangItemTarget> {\n@@ -1381,10 +1381,10 @@ impl MirLowerCtx<'_> {\n                     if let Some(expr_id) = initializer {\n                         let else_block;\n                         let Some((init_place, c)) =\n-                        self.lower_expr_as_place(current, *expr_id, true)?\n-                    else {\n-                        return Ok(None);\n-                    };\n+                            self.lower_expr_as_place(current, *expr_id, true)?\n+                        else {\n+                            return Ok(None);\n+                        };\n                         current = c;\n                         (current, else_block) = self.pattern_match(\n                             current,\n@@ -1407,6 +1407,10 @@ impl MirLowerCtx<'_> {\n                                 }\n                             }\n                         }\n+                    } else {\n+                        self.body.walk_bindings_in_pat(*pat, |b| {\n+                            self.push_storage_live(b, current);\n+                        });\n                     }\n                 }\n                 hir_def::expr::Statement::Expr { expr, has_semi: _ } => {"}, {"sha": "8c48331b94b53769721fe7688813545aecd0a8b3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/test_db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -9,15 +9,15 @@ use base_db::{\n     salsa, AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast,\n };\n use hir_def::{db::DefDatabase, ModuleId};\n-use hir_expand::db::AstDatabase;\n+use hir_expand::db::ExpandDatabase;\n use stdx::hash::{NoHashHashMap, NoHashHashSet};\n use syntax::TextRange;\n use test_utils::extract_annotations;\n \n #[salsa::database(\n     base_db::SourceDatabaseExtStorage,\n     base_db::SourceDatabaseStorage,\n-    hir_expand::db::AstDatabaseStorage,\n+    hir_expand::db::ExpandDatabaseStorage,\n     hir_def::db::InternDatabaseStorage,\n     hir_def::db::DefDatabaseStorage,\n     crate::db::HirDatabaseStorage\n@@ -41,8 +41,8 @@ impl fmt::Debug for TestDB {\n     }\n }\n \n-impl Upcast<dyn AstDatabase> for TestDB {\n-    fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n+impl Upcast<dyn ExpandDatabase> for TestDB {\n+    fn upcast(&self) -> &(dyn ExpandDatabase + 'static) {\n         &*self\n     }\n }"}, {"sha": "83d31f002a1dcae6b336cac179ac8e97eddf16cf", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -23,7 +23,7 @@ use hir_def::{\n     src::HasSource,\n     AssocItemId, DefWithBodyId, HasModule, LocalModuleId, Lookup, ModuleDefId,\n };\n-use hir_expand::{db::AstDatabase, InFile};\n+use hir_expand::{db::ExpandDatabase, InFile};\n use once_cell::race::OnceBool;\n use stdx::format_to;\n use syntax::{"}, {"sha": "378d478336102f0c2399e7d2b2aedfd7531a0503", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -9,6 +9,7 @@ fn infer_slice_method() {\n     check_types(\n         r#\"\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     fn foo(&self) -> T {\n         loop {}\n     }\n@@ -35,6 +36,7 @@ fn test() {\n //- /lib.rs crate:other_crate\n mod foo {\n     impl f32 {\n+        #[rustc_allow_incoherent_impl]\n         pub fn foo(self) -> f32 { 0. }\n     }\n }\n@@ -47,6 +49,7 @@ fn infer_array_inherent_impl() {\n     check_types(\n         r#\"\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     fn foo(&self) -> T {\n         loop {}\n     }\n@@ -1437,6 +1440,7 @@ fn resolve_const_generic_array_methods() {\n         r#\"\n #[lang = \"array\"]\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn map<F, U>(self, f: F) -> [U; N]\n     where\n         F: FnMut(T) -> U,\n@@ -1445,6 +1449,7 @@ impl<T, const N: usize> [T; N] {\n \n #[lang = \"slice\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn map<F, U>(self, f: F) -> &[U]\n     where\n         F: FnMut(T) -> U,\n@@ -1468,6 +1473,7 @@ struct Const<const N: usize>;\n \n #[lang = \"array\"]\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn my_map<F, U, const X: usize>(self, f: F, c: Const<X>) -> [U; X]\n     where\n         F: FnMut(T) -> U,\n@@ -1476,6 +1482,7 @@ impl<T, const N: usize> [T; N] {\n \n #[lang = \"slice\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn my_map<F, const X: usize, U>(self, f: F, c: Const<X>) -> &[U]\n     where\n         F: FnMut(T) -> U,\n@@ -1874,14 +1881,14 @@ fn incoherent_impls() {\n pub struct Box<T>(T);\n use core::error::Error;\n \n-#[rustc_allow_incoherent_impl]\n impl dyn Error {\n+    #[rustc_allow_incoherent_impl]\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n         loop {}\n     }\n }\n-#[rustc_allow_incoherent_impl]\n impl dyn Error + Send {\n+    #[rustc_allow_incoherent_impl]\n     /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {\n         let err: Box<dyn Error> = self;"}, {"sha": "689f0da44f68036178bf666b6ef8b6ac76a2fe13", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1756,3 +1756,35 @@ const C: usize = 2 + 2;\n \"#,\n     );\n }\n+\n+#[test]\n+fn regression_14164() {\n+    check_types(\n+        r#\"\n+trait Rec {\n+    type K;\n+    type Rebind<Tok>: Rec<K = Tok>;\n+}\n+\n+trait Expr<K> {\n+    type Part: Rec<K = K>;\n+    fn foo(_: <Self::Part as Rec>::Rebind<i32>) {}\n+}\n+\n+struct Head<K>(K);\n+impl<K> Rec for Head<K> {\n+    type K = K;\n+    type Rebind<Tok> = Head<Tok>;\n+}\n+\n+fn test<E>()\n+where\n+    E: Expr<usize, Part = Head<usize>>,\n+{\n+    let head;\n+      //^^^^ Head<i32>\n+    E::foo(head);\n+}\n+\"#,\n+    );\n+}"}, {"sha": "13cc3fea52d16281c33419c4788ab94f27f38222", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1116,21 +1116,22 @@ fn infer_inherent_method() {\n fn infer_inherent_method_str() {\n     check_infer(\n         r#\"\n-        #[lang = \"str\"]\n-        impl str {\n-            fn foo(&self) -> i32 {}\n-        }\n+#![rustc_coherence_is_core]\n+#[lang = \"str\"]\n+impl str {\n+    fn foo(&self) -> i32 {}\n+}\n \n-        fn test() {\n-            \"foo\".foo();\n-        }\n-        \"#,\n+fn test() {\n+    \"foo\".foo();\n+}\n+\"#,\n         expect![[r#\"\n-            39..43 'self': &str\n-            52..54 '{}': i32\n-            68..88 '{     ...o(); }': ()\n-            74..79 '\"foo\"': &str\n-            74..85 '\"foo\".foo()': i32\n+            67..71 'self': &str\n+            80..82 '{}': i32\n+            96..116 '{     ...o(); }': ()\n+            102..107 '\"foo\"': &str\n+            102..113 '\"foo\".foo()': i32\n         \"#]],\n     );\n }\n@@ -2640,6 +2641,7 @@ impl<T> [T] {}\n \n #[lang = \"slice_alloc\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn into_vec<A: Allocator>(self: Box<Self, A>) -> Vec<T, A> {\n         unimplemented!()\n     }\n@@ -2655,22 +2657,22 @@ struct Astruct;\n impl B for Astruct {}\n \"#,\n         expect![[r#\"\n-            569..573 'self': Box<[T], A>\n-            602..634 '{     ...     }': Vec<T, A>\n-            648..761 '{     ...t]); }': ()\n-            658..661 'vec': Vec<i32, Global>\n-            664..679 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>\n-            664..691 '<[_]>:...1i32])': Vec<i32, Global>\n-            680..690 'box [1i32]': Box<[i32; 1], Global>\n-            684..690 '[1i32]': [i32; 1]\n-            685..689 '1i32': i32\n-            701..702 'v': Vec<Box<dyn B, Global>, Global>\n-            722..739 '<[_]> ...to_vec': fn into_vec<Box<dyn B, Global>, Global>(Box<[Box<dyn B, Global>], Global>) -> Vec<Box<dyn B, Global>, Global>\n-            722..758 '<[_]> ...ruct])': Vec<Box<dyn B, Global>, Global>\n-            740..757 'box [b...truct]': Box<[Box<dyn B, Global>; 1], Global>\n-            744..757 '[box Astruct]': [Box<dyn B, Global>; 1]\n-            745..756 'box Astruct': Box<Astruct, Global>\n-            749..756 'Astruct': Astruct\n+            604..608 'self': Box<[T], A>\n+            637..669 '{     ...     }': Vec<T, A>\n+            683..796 '{     ...t]); }': ()\n+            693..696 'vec': Vec<i32, Global>\n+            699..714 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>\n+            699..726 '<[_]>:...1i32])': Vec<i32, Global>\n+            715..725 'box [1i32]': Box<[i32; 1], Global>\n+            719..725 '[1i32]': [i32; 1]\n+            720..724 '1i32': i32\n+            736..737 'v': Vec<Box<dyn B, Global>, Global>\n+            757..774 '<[_]> ...to_vec': fn into_vec<Box<dyn B, Global>, Global>(Box<[Box<dyn B, Global>], Global>) -> Vec<Box<dyn B, Global>, Global>\n+            757..793 '<[_]> ...ruct])': Vec<Box<dyn B, Global>, Global>\n+            775..792 'box [b...truct]': Box<[Box<dyn B, Global>; 1], Global>\n+            779..792 '[box Astruct]': [Box<dyn B, Global>; 1]\n+            780..791 'box Astruct': Box<Astruct, Global>\n+            784..791 'Astruct': Astruct\n         \"#]],\n     )\n }"}, {"sha": "da76d7fd83f76a0987f0d27284dbe49e8a409acc", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -82,6 +82,46 @@ async fn test() {\n     );\n }\n \n+#[test]\n+fn infer_async_closure() {\n+    check_types(\n+        r#\"\n+//- minicore: future, option\n+async fn test() {\n+    let f = async move |x: i32| x + 42;\n+    f;\n+//  ^ |i32| -> impl Future<Output = i32>\n+    let a = f(4);\n+    a;\n+//  ^ impl Future<Output = i32>\n+    let x = a.await;\n+    x;\n+//  ^ i32\n+    let f = async move || 42;\n+    f;\n+//  ^ || -> impl Future<Output = i32>\n+    let a = f();\n+    a;\n+//  ^ impl Future<Output = i32>\n+    let x = a.await;\n+    x;\n+//  ^ i32\n+    let b = ((async move || {})()).await;\n+    b;\n+//  ^ ()\n+    let c = async move || {\n+        let y = None;\n+        y\n+    //  ^ Option<u64>\n+    };\n+    let _: Option<u64> = c().await;\n+    c;\n+//  ^ || -> impl Future<Output = Option<u64>>\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn auto_sized_async_block() {\n     check_no_mismatches(\n@@ -493,29 +533,30 @@ fn tuple_struct_with_fn() {\n         r#\"\n struct S(fn(u32) -> u64);\n fn test() -> u64 {\n-    let a = S(|i| 2*i);\n+    let a = S(|i| 2*i as u64);\n     let b = a.0(4);\n     a.0(2)\n }\"#,\n         expect![[r#\"\n-            43..101 '{     ...0(2) }': u64\n+            43..108 '{     ...0(2) }': u64\n             53..54 'a': S\n             57..58 'S': S(fn(u32) -> u64) -> S\n-            57..67 'S(|i| 2*i)': S\n-            59..66 '|i| 2*i': |u32| -> u64\n+            57..74 'S(|i| ...s u64)': S\n+            59..73 '|i| 2*i as u64': |u32| -> u64\n             60..61 'i': u32\n-            63..64 '2': u32\n-            63..66 '2*i': u32\n+            63..64 '2': u64\n+            63..73 '2*i as u64': u64\n             65..66 'i': u32\n-            77..78 'b': u64\n-            81..82 'a': S\n-            81..84 'a.0': fn(u32) -> u64\n-            81..87 'a.0(4)': u64\n-            85..86 '4': u32\n-            93..94 'a': S\n-            93..96 'a.0': fn(u32) -> u64\n-            93..99 'a.0(2)': u64\n-            97..98 '2': u32\n+            65..73 'i as u64': u64\n+            84..85 'b': u64\n+            88..89 'a': S\n+            88..91 'a.0': fn(u32) -> u64\n+            88..94 'a.0(4)': u64\n+            92..93 '4': u32\n+            100..101 'a': S\n+            100..103 'a.0': fn(u32) -> u64\n+            100..106 'a.0(2)': u64\n+            104..105 '2': u32\n         \"#]],\n     );\n }"}, {"sha": "0935b5ea51945de6557d07af7a7aff41e1974151", "filename": "src/tools/rust-analyzer/crates/hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -5,7 +5,7 @@\n //! But we need this for at least LRU caching at the query level.\n pub use hir_def::db::*;\n pub use hir_expand::db::{\n-    AstDatabase, AstDatabaseStorage, AstIdMapQuery, ExpandProcMacroQuery, HygieneFrameQuery,\n+    AstIdMapQuery, ExpandDatabase, ExpandDatabaseStorage, ExpandProcMacroQuery, HygieneFrameQuery,\n     InternMacroCallQuery, MacroArgTextQuery, MacroDefQuery, MacroExpandErrorQuery,\n     MacroExpandQuery, ParseMacroExpansionQuery,\n };"}, {"sha": "253d62dafc60b20ec3845e7cd7c189112d6a8e48", "filename": "src/tools/rust-analyzer/crates/hir/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -3,6 +3,8 @@\n //!\n //! This probably isn't the best way to do this -- ideally, diagnostics should\n //! be expressed in terms of hir types themselves.\n+pub use hir_ty::diagnostics::{IncoherentImpl, IncorrectCase};\n+\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n@@ -35,6 +37,7 @@ diagnostics![\n     InactiveCode,\n     IncorrectCase,\n     InvalidDeriveTarget,\n+    IncoherentImpl,\n     MacroError,\n     MalformedDerive,\n     MismatchedArgCount,\n@@ -220,5 +223,3 @@ pub struct NeedMut {\n pub struct UnusedMut {\n     pub local: Local,\n }\n-\n-pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "35424feec8b29b294220be299c6ecaab1e1594cf", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -85,10 +85,10 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncorrectCase,\n-        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n-        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncoherentImpl,\n+        IncorrectCase, InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount,\n+        MissingFields, MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem,\n+        PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n         UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n         UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n     },\n@@ -604,11 +604,23 @@ impl Module {\n             }\n         }\n \n+        let inherent_impls = db.inherent_impls_in_crate(self.id.krate());\n+\n         for impl_def in self.impl_defs(db) {\n             for diag in db.impl_data_with_diagnostics(impl_def.id).1.iter() {\n                 emit_def_diagnostic(db, acc, diag);\n             }\n \n+            if inherent_impls.invalid_impls().contains(&impl_def.id) {\n+                let loc = impl_def.id.lookup(db.upcast());\n+                let tree = loc.id.item_tree(db.upcast());\n+                let node = &tree[loc.id.value];\n+                let file_id = loc.id.file_id();\n+                let ast_id_map = db.ast_id_map(file_id);\n+\n+                acc.push(IncoherentImpl { impl_: ast_id_map.get(node.ast_id()), file_id }.into())\n+            }\n+\n             for item in impl_def.items(db) {\n                 let def: DefWithBody = match item {\n                     AssocItem::Function(it) => it.into(),\n@@ -3210,6 +3222,14 @@ impl Type {\n         matches!(self.ty.kind(Interner), TyKind::Scalar(Scalar::Uint(UintTy::Usize)))\n     }\n \n+    pub fn is_float(&self) -> bool {\n+        matches!(self.ty.kind(Interner), TyKind::Scalar(Scalar::Float(_)))\n+    }\n+\n+    pub fn is_char(&self) -> bool {\n+        matches!(self.ty.kind(Interner), TyKind::Scalar(Scalar::Char))\n+    }\n+\n     pub fn is_int_or_uint(&self) -> bool {\n         match self.ty.kind(Interner) {\n             TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)) => true,\n@@ -3224,6 +3244,13 @@ impl Type {\n         }\n     }\n \n+    pub fn as_slice(&self) -> Option<Type> {\n+        match &self.ty.kind(Interner) {\n+            TyKind::Slice(ty) => Some(self.derived(ty.clone())),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn strip_references(&self) -> Type {\n         self.derived(self.ty.strip_references().clone())\n     }"}, {"sha": "407ba6f65844e7b426450a81c4e001985b9ffa8e", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -15,7 +15,7 @@ use hir_def::{\n     AsMacroCall, DefWithBodyId, FieldId, FunctionId, MacroId, TraitId, VariantId,\n };\n use hir_expand::{\n-    db::AstDatabase,\n+    db::ExpandDatabase,\n     name::{known, AsName},\n     ExpansionInfo, MacroCallId,\n };\n@@ -411,7 +411,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_record_field(field)\n     }\n \n-    pub fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<Field> {\n+    pub fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<(Field, Type)> {\n         self.imp.resolve_record_pat_field(field)\n     }\n \n@@ -1201,7 +1201,7 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(field.syntax())?.resolve_record_field(self.db, field)\n     }\n \n-    fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<Field> {\n+    fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<(Field, Type)> {\n         self.analyze(field.syntax())?.resolve_record_pat_field(self.db, field)\n     }\n \n@@ -1536,7 +1536,7 @@ impl<'db> SemanticsImpl<'db> {\n \n fn macro_call_to_macro_id(\n     ctx: &mut SourceToDefCtx<'_, '_>,\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     macro_call_id: MacroCallId,\n ) -> Option<MacroId> {\n     let loc = db.lookup_intern_macro_call(macro_call_id);"}, {"sha": "c24d196e1b6247857764f9898fd17c623069bdc0", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -441,14 +441,17 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         field: &ast::RecordPatField,\n-    ) -> Option<Field> {\n+    ) -> Option<(Field, Type)> {\n         let field_name = field.field_name()?.as_name();\n         let record_pat = ast::RecordPat::cast(field.syntax().parent().and_then(|p| p.parent())?)?;\n         let pat_id = self.pat_id(&record_pat.into())?;\n         let variant = self.infer.as_ref()?.variant_resolution_for_pat(pat_id)?;\n         let variant_data = variant.variant_data(db.upcast());\n         let field = FieldId { parent: variant, local_id: variant_data.field(&field_name)? };\n-        Some(field.into())\n+        let (_, subst) = self.infer.as_ref()?.type_of_pat.get(pat_id)?.as_adt()?;\n+        let field_ty =\n+            db.field_types(variant).get(field.local_id)?.clone().substitute(Interner, subst);\n+        Some((field.into(), Type::new_with_resolver(db, &self.resolver, field_ty)))\n     }\n \n     pub(crate) fn resolve_macro_call("}, {"sha": "0768389281ca303826e574c430cf1d5a9e584158", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1027,7 +1027,7 @@ fn next_space_for_fn_after_call_site(expr: ast::CallableExpr) -> Option<Generate\n }\n \n fn next_space_for_fn_in_module(\n-    db: &dyn hir::db::AstDatabase,\n+    db: &dyn hir::db::ExpandDatabase,\n     module_source: &hir::InFile<hir::ModuleSource>,\n ) -> Option<(FileId, GeneratedFunctionTarget)> {\n     let file = module_source.file_id.original_file(db);"}, {"sha": "28d815e81b49d88d07fa3e19cac12c4f6a88b2dc", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -363,10 +363,10 @@ fn inline(\n         .collect();\n \n     if function.self_param(sema.db).is_some() {\n-        let this = || make::name_ref(\"this\").syntax().clone_for_update();\n+        let this = || make::name_ref(\"this\").syntax().clone_for_update().first_token().unwrap();\n         if let Some(self_local) = params[0].2.as_local(sema.db) {\n             usages_for_locals(self_local)\n-                .flat_map(|FileReference { name, range, .. }| match name {\n+                .filter_map(|FileReference { name, range, .. }| match name {\n                     ast::NameLike::NameRef(_) => Some(body.syntax().covering_element(range)),\n                     _ => None,\n                 })\n@@ -680,6 +680,42 @@ impl Foo {\n     }\n }\n \n+fn main() {\n+    let x = {\n+        let ref this = Foo(3);\n+        Foo(this.0 + 2)\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn generic_method_by_ref() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add<T>(&self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo(3).add$0::<usize>(2);\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add<T>(&self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n fn main() {\n     let x = {\n         let ref this = Foo(3);"}, {"sha": "a403d5bc672d2b9ca40e81a9fc2853e8d3a25207", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -46,7 +46,7 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n     acc.add(\n         AssistId(\"remove_dbg\", AssistKind::Refactor),\n         \"Remove dbg!()\",\n-        ctx.selection_trimmed(),\n+        replacements.iter().map(|&(range, _)| range).reduce(|acc, range| acc.cover(range)).unwrap(),\n         |builder| {\n             for (range, expr) in replacements {\n                 if let Some(expr) = expr {"}, {"sha": "8b07e29a5879fba4621b53e3dd105de51b271d9f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -265,7 +265,6 @@ mod handlers {\n             inline_local_variable::inline_local_variable,\n             inline_type_alias::inline_type_alias,\n             inline_type_alias::inline_type_alias_uses,\n-            inline_macro::inline_macro,\n             introduce_named_generic::introduce_named_generic,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,\n@@ -286,7 +285,6 @@ mod handlers {\n             raw_string::add_hash,\n             raw_string::make_usual_string,\n             raw_string::remove_hash,\n-            remove_dbg::remove_dbg,\n             remove_mut::remove_mut,\n             remove_unused_param::remove_unused_param,\n             remove_parentheses::remove_parentheses,\n@@ -335,6 +333,9 @@ mod handlers {\n             generate_setter::generate_setter,\n             generate_delegate_methods::generate_delegate_methods,\n             generate_deref::generate_deref,\n+            //\n+            remove_dbg::remove_dbg,\n+            inline_macro::inline_macro,\n             // Are you sure you want to add new assist here, and not to the\n             // sorted list above?\n         ]"}, {"sha": "c3136f6df4b391a1f6951f17491ccab6e29d9819", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -23,7 +23,7 @@ pub(crate) mod env_vars;\n \n use std::iter;\n \n-use hir::{known, ScopeDef};\n+use hir::{known, ScopeDef, Variant};\n use ide_db::{imports::import_assets::LocatedImport, SymbolKind};\n use syntax::ast;\n \n@@ -537,17 +537,20 @@ fn enum_variants_with_paths(\n     impl_: &Option<ast::Impl>,\n     cb: impl Fn(&mut Completions, &CompletionContext<'_>, hir::Variant, hir::ModPath),\n ) {\n+    let mut process_variant = |variant: Variant| {\n+        let self_path = hir::ModPath::from_segments(\n+            hir::PathKind::Plain,\n+            iter::once(known::SELF_TYPE).chain(iter::once(variant.name(ctx.db))),\n+        );\n+\n+        cb(acc, ctx, variant, self_path);\n+    };\n+\n     let variants = enum_.variants(ctx.db);\n \n     if let Some(impl_) = impl_.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n         if impl_.self_ty(ctx.db).as_adt() == Some(hir::Adt::Enum(enum_)) {\n-            for &variant in &variants {\n-                let self_path = hir::ModPath::from_segments(\n-                    hir::PathKind::Plain,\n-                    iter::once(known::SELF_TYPE).chain(iter::once(variant.name(ctx.db))),\n-                );\n-                cb(acc, ctx, variant, self_path);\n-            }\n+            variants.iter().for_each(|variant| process_variant(*variant));\n         }\n     }\n "}, {"sha": "77246379e7bd98a436dbae9f598260369318f275", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -415,7 +415,6 @@ fn foo(a: lib::A) { a.$0 }\n     fn test_local_impls() {\n         check(\n             r#\"\n-//- /lib.rs crate:lib\n pub struct A {}\n mod m {\n     impl super::A {\n@@ -427,9 +426,8 @@ mod m {\n         }\n     }\n }\n-//- /main.rs crate:main deps:lib\n-fn foo(a: lib::A) {\n-    impl lib::A {\n+fn foo(a: A) {\n+    impl A {\n         fn local_method(&self) {}\n     }\n     a.$0"}, {"sha": "8cbf89e9c301954e83b32ba23cc88179ff31e07e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -220,6 +220,8 @@ pub(super) struct PatternContext {\n     /// The record pattern this name or ref is a field of\n     pub(super) record_pat: Option<ast::RecordPat>,\n     pub(super) impl_: Option<ast::Impl>,\n+    /// List of missing variants in a match expr\n+    pub(super) missing_variants: Vec<hir::Variant>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "a94c404586b11b4923762ca5f5a7a0659caa7d45", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,7 +1,7 @@\n //! Module responsible for analyzing the code surrounding the cursor for completion.\n use std::iter;\n \n-use hir::{Semantics, Type, TypeInfo};\n+use hir::{Semantics, Type, TypeInfo, Variant};\n use ide_db::{active_parameter::ActiveParameter, RootDatabase};\n use syntax::{\n     algo::{find_node_at_offset, non_trivia_sibling},\n@@ -353,7 +353,7 @@ fn expected_type_and_name(\n         _ => ty,\n     };\n \n-    loop {\n+    let (ty, name) = loop {\n         break match_ast! {\n             match node {\n                 ast::LetStmt(it) => {\n@@ -385,9 +385,7 @@ fn expected_type_and_name(\n                        token.clone(),\n                     ).map(|ap| {\n                         let name = ap.ident().map(NameOrNameRef::Name);\n-\n-                        let ty = strip_refs(ap.ty);\n-                        (Some(ty), name)\n+                        (Some(ap.ty), name)\n                     })\n                     .unwrap_or((None, None))\n                 },\n@@ -489,7 +487,8 @@ fn expected_type_and_name(\n                 },\n             }\n         };\n-    }\n+    };\n+    (ty.map(strip_refs), name)\n }\n \n fn classify_lifetime(\n@@ -1133,6 +1132,9 @@ fn pattern_context_for(\n     pat: ast::Pat,\n ) -> PatternContext {\n     let mut param_ctx = None;\n+\n+    let mut missing_variants = vec![];\n+\n     let (refutability, has_type_ascription) =\n     pat\n         .syntax()\n@@ -1162,7 +1164,52 @@ fn pattern_context_for(\n                         })();\n                         return (PatternRefutability::Irrefutable, has_type_ascription)\n                     },\n-                    ast::MatchArm(_) => PatternRefutability::Refutable,\n+                    ast::MatchArm(match_arm) => {\n+                       let missing_variants_opt = match_arm\n+                            .syntax()\n+                            .parent()\n+                            .and_then(ast::MatchArmList::cast)\n+                            .and_then(|match_arm_list| {\n+                                match_arm_list\n+                                .syntax()\n+                                .parent()\n+                                .and_then(ast::MatchExpr::cast)\n+                                .and_then(|match_expr| {\n+                                    let expr_opt = find_opt_node_in_file(&original_file, match_expr.expr());\n+\n+                                    expr_opt.and_then(|expr| {\n+                                        sema.type_of_expr(&expr)?\n+                                        .adjusted()\n+                                        .autoderef(sema.db)\n+                                        .find_map(|ty| match ty.as_adt() {\n+                                            Some(hir::Adt::Enum(e)) => Some(e),\n+                                            _ => None,\n+                                        }).and_then(|enum_| {\n+                                            Some(enum_.variants(sema.db))\n+                                        })\n+                                    })\n+                                }).and_then(|variants| {\n+                                   Some(variants.iter().filter_map(|variant| {\n+                                        let variant_name = variant.name(sema.db).to_string();\n+\n+                                        let variant_already_present = match_arm_list.arms().any(|arm| {\n+                                            arm.pat().and_then(|pat| {\n+                                                let pat_already_present = pat.syntax().to_string().contains(&variant_name);\n+                                                pat_already_present.then(|| pat_already_present)\n+                                            }).is_some()\n+                                        });\n+\n+                                        (!variant_already_present).then_some(variant.clone())\n+                                    }).collect::<Vec<Variant>>())\n+                                })\n+                        });\n+\n+                        if let Some(missing_variants_) = missing_variants_opt {\n+                            missing_variants = missing_variants_;\n+                        };\n+\n+                        PatternRefutability::Refutable\n+                    },\n                     ast::LetExpr(_) => PatternRefutability::Refutable,\n                     ast::ForExpr(_) => PatternRefutability::Irrefutable,\n                     _ => PatternRefutability::Irrefutable,\n@@ -1184,6 +1231,7 @@ fn pattern_context_for(\n         ref_token,\n         record_pat: None,\n         impl_: fetch_immediate_impl(sema, original_file, pat.syntax()),\n+        missing_variants,\n     }\n }\n "}, {"sha": "82a1c10c5314f2a6661d8ee56b96677b85ed586e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -411,3 +411,15 @@ fn main() {\n         expect![\"ty: i32, name: ?\"],\n     );\n }\n+\n+#[test]\n+fn expected_type_ref_return_pos() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn f(thing: u32) -> &u32 {\n+    &thin$0\n+}\n+\"#,\n+        expect![\"ty: u32, name: ?\"],\n+    );\n+}"}, {"sha": "9225c91bebf51897c871798075457def5d4c780d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -37,7 +37,9 @@ pub(crate) fn render_struct_pat(\n     let lookup = format_literal_lookup(name.as_str(), kind);\n     let pat = render_pat(&ctx, pattern_ctx, &escaped_name, kind, &visible_fields, fields_omitted)?;\n \n-    Some(build_completion(ctx, label, lookup, pat, strukt))\n+    let db = ctx.db();\n+\n+    Some(build_completion(ctx, label, lookup, pat, strukt, strukt.ty(db), false))\n }\n \n pub(crate) fn render_variant_pat(\n@@ -52,6 +54,7 @@ pub(crate) fn render_variant_pat(\n \n     let fields = variant.fields(ctx.db());\n     let (visible_fields, fields_omitted) = visible_fields(ctx.completion, &fields, variant)?;\n+    let enum_ty = variant.parent_enum(ctx.db()).ty(ctx.db());\n \n     let (name, escaped_name) = match path {\n         Some(path) => (path.unescaped().to_string().into(), path.to_string().into()),\n@@ -81,7 +84,15 @@ pub(crate) fn render_variant_pat(\n         }\n     };\n \n-    Some(build_completion(ctx, label, lookup, pat, variant))\n+    Some(build_completion(\n+        ctx,\n+        label,\n+        lookup,\n+        pat,\n+        variant,\n+        enum_ty,\n+        pattern_ctx.missing_variants.contains(&variant),\n+    ))\n }\n \n fn build_completion(\n@@ -90,13 +101,22 @@ fn build_completion(\n     lookup: SmolStr,\n     pat: String,\n     def: impl HasAttrs + Copy,\n+    adt_ty: hir::Type,\n+    // Missing in context of match statement completions\n+    is_variant_missing: bool,\n ) -> CompletionItem {\n+    let mut relevance = ctx.completion_relevance();\n+\n+    if is_variant_missing {\n+        relevance.type_match = super::compute_type_match(ctx.completion, &adt_ty);\n+    }\n+\n     let mut item = CompletionItem::new(CompletionItemKind::Binding, ctx.source_range(), label);\n     item.set_documentation(ctx.docs(def))\n         .set_deprecated(ctx.is_deprecated(def))\n         .detail(&pat)\n         .lookup_by(lookup)\n-        .set_relevance(ctx.completion_relevance());\n+        .set_relevance(relevance);\n     match ctx.snippet_cap() {\n         Some(snippet_cap) => item.insert_snippet(snippet_cap, pat),\n         None => item.insert_text(pat),"}, {"sha": "c0e485c36fdd11c13aaabc2e92b4d13e4abfb8bf", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -614,6 +614,7 @@ fn f(u: U) {\n \n     check_empty(\n         r#\"\n+#![rustc_coherence_is_core]\n #[lang = \"u32\"]\n impl u32 {\n     pub const MIN: Self = 0;"}, {"sha": "65cefdb0856d214106fba77f20b26118bfb42fe7", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/record.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -46,6 +46,66 @@ fn foo(s: Struct) {\n     );\n }\n \n+#[test]\n+fn record_pattern_field_enum() {\n+    check(\n+        r#\"\n+//- minicore:result\n+enum Baz { Foo, Bar }\n+\n+fn foo(baz: Baz) {\n+    match baz {\n+        Baz::Foo => (),\n+        $0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            en Baz\n+            en Result\n+            md core\n+            ev Err\n+            ev Ok\n+            bn Baz::Bar Baz::Bar$0\n+            bn Baz::Foo Baz::Foo$0\n+            bn Err(\u2026)   Err($1)$0\n+            bn Ok(\u2026)    Ok($1)$0\n+            kw mut\n+            kw ref\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+//- minicore:result\n+enum Baz { Foo, Bar }\n+\n+fn foo(baz: Baz) {\n+    use Baz::*;\n+    match baz {\n+        Foo => (),\n+        $0\n+    }\n+}\n+ \"#,\n+        expect![[r#\"\n+         en Baz\n+         en Result\n+         md core\n+         ev Bar\n+         ev Err\n+         ev Foo\n+         ev Ok\n+         bn Bar    Bar$0\n+         bn Err(\u2026) Err($1)$0\n+         bn Foo    Foo$0\n+         bn Ok(\u2026)  Ok($1)$0\n+         kw mut\n+         kw ref\n+         \"#]],\n+    );\n+}\n+\n #[test]\n fn pattern_enum_variant() {\n     check("}, {"sha": "f8a6f6cd3ed065824f3943ca13aaefbf8c92ced8", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -608,6 +608,7 @@ fn f() {\n }\n \n //- /core.rs crate:core\n+#![rustc_coherence_is_core]\n #[lang = \"u8\"]\n impl u8 {\n     pub const MAX: Self = 255;"}, {"sha": "ea1d9cc4919d37648b94df09f628eadc08dacc48", "filename": "src/tools/rust-analyzer/crates/ide-db/src/apply_change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -71,7 +71,7 @@ impl RootDatabase {\n             base_db::SourceRootQuery\n             base_db::SourceRootCratesQuery\n \n-            // AstDatabase\n+            // ExpandDatabase\n             hir::db::AstIdMapQuery\n             hir::db::ParseMacroExpansionQuery\n             hir::db::InternMacroCallQuery"}, {"sha": "4071c490b7fc39546812ad04375c17b292305f54", "filename": "src/tools/rust-analyzer/crates/ide-db/src/defs.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -327,7 +327,7 @@ impl NameClass {\n             let pat_parent = ident_pat.syntax().parent();\n             if let Some(record_pat_field) = pat_parent.and_then(ast::RecordPatField::cast) {\n                 if record_pat_field.name_ref().is_none() {\n-                    if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n+                    if let Some((field, _)) = sema.resolve_record_pat_field(&record_pat_field) {\n                         return Some(NameClass::PatFieldShorthand {\n                             local_def: local,\n                             field_ref: field,\n@@ -483,6 +483,13 @@ impl NameRefClass {\n                 },\n                 ast::RecordPatField(record_pat_field) => {\n                     sema.resolve_record_pat_field(&record_pat_field)\n+                        .map(|(field, ..)|field)\n+                        .map(Definition::Field)\n+                        .map(NameRefClass::Definition)\n+                },\n+                ast::RecordExprField(record_expr_field) => {\n+                    sema.resolve_record_field(&record_expr_field)\n+                        .map(|(field, ..)|field)\n                         .map(Definition::Field)\n                         .map(NameRefClass::Definition)\n                 },"}, {"sha": "b1df11bf911722433036e1aa9e5c71f831337228", "filename": "src/tools/rust-analyzer/crates/ide-db/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -50,7 +50,7 @@ use base_db::{\n     AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast,\n };\n use hir::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n+    db::{DefDatabase, ExpandDatabase, HirDatabase},\n     symbols::FileSymbolKind,\n };\n use stdx::hash::NoHashHashSet;\n@@ -68,7 +68,7 @@ pub type FxIndexMap<K, V> =\n #[salsa::database(\n     base_db::SourceDatabaseExtStorage,\n     base_db::SourceDatabaseStorage,\n-    hir::db::AstDatabaseStorage,\n+    hir::db::ExpandDatabaseStorage,\n     hir::db::DefDatabaseStorage,\n     hir::db::HirDatabaseStorage,\n     hir::db::InternDatabaseStorage,\n@@ -95,8 +95,8 @@ impl fmt::Debug for RootDatabase {\n     }\n }\n \n-impl Upcast<dyn AstDatabase> for RootDatabase {\n-    fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n+impl Upcast<dyn ExpandDatabase> for RootDatabase {\n+    fn upcast(&self) -> &(dyn ExpandDatabase + 'static) {\n         &*self\n     }\n }"}, {"sha": "72af9ebfcbb62e48a6c110bfaa5bbcca21b2b2cc", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/incoherent_impl.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -0,0 +1,77 @@\n+use hir::InFile;\n+\n+use crate::{Diagnostic, DiagnosticsContext, Severity};\n+\n+// Diagnostic: incoherent-impl\n+//\n+// This diagnostic is triggered if the targe type of an impl is from a foreign crate.\n+pub(crate) fn incoherent_impl(ctx: &DiagnosticsContext<'_>, d: &hir::IncoherentImpl) -> Diagnostic {\n+    Diagnostic::new(\n+        \"incoherent-impl\",\n+        format!(\"cannot define inherent `impl` for foreign type\"),\n+        ctx.sema.diagnostics_display_range(InFile::new(d.file_id, d.impl_.clone().into())).range,\n+    )\n+    .severity(Severity::Error)\n+}\n+\n+#[cfg(test)]\n+mod change_case {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn primitive() {\n+        check_diagnostics(\n+            r#\"\n+  impl bool {}\n+//^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn primitive_rustc_allow_incoherent_impl() {\n+        check_diagnostics(\n+            r#\"\n+impl bool {\n+    #[rustc_allow_incoherent_impl]\n+    fn falsch(self) -> Self { false }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn rustc_allow_incoherent_impl() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+#[rustc_has_incoherent_inherent_impls]\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+impl foo::S {\n+    #[rustc_allow_incoherent_impl]\n+    fn func(self) {}\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+  impl foo::S { #[rustc_allow_incoherent_impl] fn func(self) {} }\n+//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+#[rustc_has_incoherent_inherent_impls]\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+  impl foo::S { fn func(self) {} }\n+//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "db88bf7b9313dad008a423c3f7c134b24b6dde4e", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/incorrect_case.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, InFile};\n+use hir::{db::ExpandDatabase, InFile};\n use ide_db::{assists::Assist, defs::NameClass};\n use syntax::AstNode;\n "}, {"sha": "5c4327ff93413b17af3ac26c7191c82218f0e8b3", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,6 +1,6 @@\n use either::Either;\n use hir::{\n-    db::{AstDatabase, HirDatabase},\n+    db::{ExpandDatabase, HirDatabase},\n     known, AssocItem, HirDisplay, InFile, Type,\n };\n use ide_db::{"}, {"sha": "eb32db250656c1dac5deb0563d3c7146b9f85d18", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_unsafe.rs", "status": "modified", "additions": 374, "deletions": 7, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,4 +1,10 @@\n-use crate::{Diagnostic, DiagnosticsContext};\n+use hir::db::ExpandDatabase;\n+use ide_db::{assists::Assist, source_change::SourceChange};\n+use syntax::{ast, SyntaxNode};\n+use syntax::{match_ast, AstNode};\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: missing-unsafe\n //\n@@ -9,11 +15,83 @@ pub(crate) fn missing_unsafe(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsaf\n         \"this operation is unsafe and requires an unsafe function or block\",\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Option<Vec<Assist>> {\n+    // The fixit will not work correctly for macro expansions, so we don't offer it in that case.\n+    if d.expr.file_id.is_macro() {\n+        return None;\n+    }\n+\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+    let expr = d.expr.value.to_node(&root);\n+\n+    let node_to_add_unsafe_block = pick_best_node_to_add_unsafe_block(&expr)?;\n+\n+    let replacement = format!(\"unsafe {{ {} }}\", node_to_add_unsafe_block.text());\n+    let edit = TextEdit::replace(node_to_add_unsafe_block.text_range(), replacement);\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+    Some(vec![fix(\"add_unsafe\", \"Add unsafe block\", source_change, expr.syntax().text_range())])\n+}\n+\n+// Pick the first ancestor expression of the unsafe `expr` that is not a\n+// receiver of a method call, a field access, the left-hand side of an\n+// assignment, or a reference. As all of those cases would incur a forced move\n+// if wrapped which might not be wanted. That is:\n+// - `unsafe_expr.foo` -> `unsafe { unsafe_expr.foo }`\n+// - `unsafe_expr.foo.bar` -> `unsafe { unsafe_expr.foo.bar }`\n+// - `unsafe_expr.foo()` -> `unsafe { unsafe_expr.foo() }`\n+// - `unsafe_expr.foo.bar()` -> `unsafe { unsafe_expr.foo.bar() }`\n+// - `unsafe_expr += 1` -> `unsafe { unsafe_expr += 1 }`\n+// - `&unsafe_expr` -> `unsafe { &unsafe_expr }`\n+// - `&&unsafe_expr` -> `unsafe { &&unsafe_expr }`\n+fn pick_best_node_to_add_unsafe_block(unsafe_expr: &ast::Expr) -> Option<SyntaxNode> {\n+    // The `unsafe_expr` might be:\n+    // - `ast::CallExpr`: call an unsafe function\n+    // - `ast::MethodCallExpr`: call an unsafe method\n+    // - `ast::PrefixExpr`: dereference a raw pointer\n+    // - `ast::PathExpr`: access a static mut variable\n+    for (node, parent) in\n+        unsafe_expr.syntax().ancestors().zip(unsafe_expr.syntax().ancestors().skip(1))\n+    {\n+        match_ast! {\n+            match parent {\n+                // If the `parent` is a `MethodCallExpr`, that means the `node`\n+                // is the receiver of the method call, because only the receiver\n+                // can be a direct child of a method call. The method name\n+                // itself is not an expression but a `NameRef`, and an argument\n+                // is a direct child of an `ArgList`.\n+                ast::MethodCallExpr(_) => continue,\n+                ast::FieldExpr(_) => continue,\n+                ast::RefExpr(_) => continue,\n+                ast::BinExpr(it) => {\n+                    // Check if the `node` is the left-hand side of an\n+                    // assignment, if so, we don't want to wrap it in an unsafe\n+                    // block, e.g. `unsafe_expr += 1`\n+                    let is_left_hand_side_of_assignment = {\n+                        if let Some(ast::BinaryOp::Assignment { .. }) = it.op_kind() {\n+                            it.lhs().map(|lhs| lhs.syntax().text_range().contains_range(node.text_range())).unwrap_or(false)\n+                        } else {\n+                            false\n+                        }\n+                    };\n+                    if !is_left_hand_side_of_assignment {\n+                        return Some(node);\n+                    }\n+                },\n+                _ => { return Some(node); }\n+\n+            }\n+        }\n+    }\n+    None\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::check_diagnostics;\n+    use crate::tests::{check_diagnostics, check_fix, check_no_fix};\n \n     #[test]\n     fn missing_unsafe_diagnostic_with_raw_ptr() {\n@@ -23,7 +101,7 @@ fn main() {\n     let x = &5 as *const usize;\n     unsafe { let y = *x; }\n     let z = *x;\n-}         //^^ error: this operation is unsafe and requires an unsafe function or block\n+}         //^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n \"#,\n         )\n     }\n@@ -48,9 +126,9 @@ unsafe fn unsafe_fn() {\n \n fn main() {\n     unsafe_fn();\n-  //^^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+  //^^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n     HasUnsafe.unsafe_fn();\n-  //^^^^^^^^^^^^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+  //^^^^^^^^^^^^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n     unsafe {\n         unsafe_fn();\n         HasUnsafe.unsafe_fn();\n@@ -72,7 +150,7 @@ static mut STATIC_MUT: Ty = Ty { a: 0 };\n \n fn main() {\n     let x = STATIC_MUT.a;\n-          //^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+          //^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n     unsafe {\n         let x = STATIC_MUT.a;\n     }\n@@ -94,9 +172,298 @@ extern \"rust-intrinsic\" {\n fn main() {\n     let _ = bitreverse(12);\n     let _ = floorf32(12.0);\n-          //^^^^^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+          //^^^^^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n }\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn add_unsafe_block_when_dereferencing_a_raw_pointer() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    let z = *x$0;\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    let z = unsafe { *x };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_calling_unsafe_function() {\n+        check_fix(\n+            r#\"\n+unsafe fn func() {\n+    let x = &5 as *const usize;\n+    let z = *x;\n+}\n+fn main() {\n+    func$0();\n+}\n+\"#,\n+            r#\"\n+unsafe fn func() {\n+    let x = &5 as *const usize;\n+    let z = *x;\n+}\n+fn main() {\n+    unsafe { func() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_calling_unsafe_method() {\n+        check_fix(\n+            r#\"\n+struct S(usize);\n+impl S {\n+    unsafe fn func(&self) {\n+        let x = &self.0 as *const usize;\n+        let z = *x;\n+    }\n+}\n+fn main() {\n+    let s = S(5);\n+    s.func$0();\n+}\n+\"#,\n+            r#\"\n+struct S(usize);\n+impl S {\n+    unsafe fn func(&self) {\n+        let x = &self.0 as *const usize;\n+        let z = *x;\n+    }\n+}\n+fn main() {\n+    let s = S(5);\n+    unsafe { s.func() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_accessing_mutable_static() {\n+        check_fix(\n+            r#\"\n+struct Ty {\n+    a: u8,\n+}\n+\n+static mut STATIC_MUT: Ty = Ty { a: 0 };\n+\n+fn main() {\n+    let x = STATIC_MUT$0.a;\n+}\n+\"#,\n+            r#\"\n+struct Ty {\n+    a: u8,\n+}\n+\n+static mut STATIC_MUT: Ty = Ty { a: 0 };\n+\n+fn main() {\n+    let x = unsafe { STATIC_MUT.a };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_calling_unsafe_intrinsic() {\n+        check_fix(\n+            r#\"\n+extern \"rust-intrinsic\" {\n+    pub fn floorf32(x: f32) -> f32;\n+}\n+\n+fn main() {\n+    let _ = floorf32$0(12.0);\n+}\n+\"#,\n+            r#\"\n+extern \"rust-intrinsic\" {\n+    pub fn floorf32(x: f32) -> f32;\n+}\n+\n+fn main() {\n+    let _ = unsafe { floorf32(12.0) };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_a_receiver_of_a_method_call() {\n+        check_fix(\n+            r#\"\n+unsafe fn foo() -> String {\n+    \"string\".to_string()\n+}\n+\n+fn main() {\n+    foo$0().len();\n+}\n+\"#,\n+            r#\"\n+unsafe fn foo() -> String {\n+    \"string\".to_string()\n+}\n+\n+fn main() {\n+    unsafe { foo().len() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_an_argument_of_a_method_call() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let mut v = vec![];\n+    v.push(STATIC_MUT$0);\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let mut v = vec![];\n+    v.push(unsafe { STATIC_MUT });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_left_hand_side_of_assignment() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    STATIC_MUT$0 = 1;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    unsafe { STATIC_MUT = 1 };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_right_hand_side_of_assignment() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x;\n+    x = STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x;\n+    x = unsafe { STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_in_binary_plus() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = STATIC_MUT$0 + 1;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { STATIC_MUT } + 1;\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn ref_to_unsafe_expr() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = &STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { &STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn ref_ref_to_unsafe_expr() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = &&STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { &&STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_in_macro_call() {\n+        check_no_fix(\n+            r#\"\n+unsafe fn foo() -> u8 {\n+    0\n+}\n+\n+fn main() {\n+    let x = format!(\"foo: {}\", foo$0());\n+}\n+            \"#,\n+        )\n+    }\n }"}, {"sha": "96470265d11d1f67644f8782b0060474308c5d7f", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -505,6 +505,30 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn initialization_is_not_mutation_in_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let a;\n+    loop {\n+        let c @ (\n+            mut b,\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            mut d\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        );\n+        a = 1;\n+      //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `a`\n+        b = 1;\n+        c = (2, 3);\n+        d = 3;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn function_arguments_are_initialized() {\n         check_diagnostics("}, {"sha": "24c521ed1a8a41827b23726b90046e90a9de39a9", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/no_such_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, HasSource, HirDisplay, Semantics};\n+use hir::{db::ExpandDatabase, HasSource, HirDisplay, Semantics};\n use ide_db::{base_db::FileId, source_change::SourceChange, RootDatabase};\n use syntax::{\n     ast::{self, edit::IndentLevel, make},"}, {"sha": "be83ad6aaadaaef139df7b08fb593a8ca8f83167", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/private_field.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -62,6 +62,26 @@ mod module {\n fn main(s: module::Struct) {\n     s.field;\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn block_module_madness() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let strukt = {\n+        use crate as ForceParentBlockDefMap;\n+        {\n+            pub struct Struct {\n+                field: (),\n+            }\n+            Struct { field: () }\n+        }\n+    };\n+    strukt.field;\n+}\n \"#,\n         );\n     }"}, {"sha": "9b1c65983e615fd18b55d6380dfb090a16484231", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, InFile};\n+use hir::{db::ExpandDatabase, InFile};\n use ide_db::source_change::SourceChange;\n use syntax::{\n     ast::{self, HasArgList},"}, {"sha": "4abc25a28fbc040f4130899ae0bcf7f9d8af17da", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::{db::AstDatabase, HirDisplay, InFile, Type};\n+use hir::{db::ExpandDatabase, HirDisplay, InFile, Type};\n use ide_db::{famous_defs::FamousDefs, source_change::SourceChange};\n use syntax::{\n     ast::{self, BlockExpr, ExprStmt},"}, {"sha": "cefa74e523e8f13a37d206e18700ff779f9fab8d", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, HirDisplay, InFile};\n+use hir::{db::ExpandDatabase, HirDisplay, InFile};\n use ide_db::{\n     assists::{Assist, AssistId, AssistKind},\n     base_db::FileRange,"}, {"sha": "f3ec6efa75215c9c132d4935420047057226ed70", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, HirDisplay};\n+use hir::{db::ExpandDatabase, HirDisplay};\n use ide_db::{\n     assists::{Assist, AssistId, AssistKind},\n     base_db::FileRange,"}, {"sha": "94614f11c33497d65733dbf306be3d65f5918ebd", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,4 +1,4 @@\n-use hir::db::AstDatabase;\n+use hir::db::ExpandDatabase;\n use ide_db::{assists::Assist, base_db::AnchoredPathBuf, source_change::FileSystemEdit};\n use itertools::Itertools;\n use syntax::AstNode;"}, {"sha": "71f136b8c9030c0e85f9de909eb11b18368496e7", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -29,6 +29,7 @@ mod handlers {\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod expected_function;\n     pub(crate) mod inactive_code;\n+    pub(crate) mod incoherent_impl;\n     pub(crate) mod incorrect_case;\n     pub(crate) mod invalid_derive_target;\n     pub(crate) mod macro_error;\n@@ -254,6 +255,7 @@ pub fn diagnostics(\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::ExpectedFunction(d) => handlers::expected_function::expected_function(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::IncoherentImpl(d) => handlers::incoherent_impl::incoherent_impl(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),"}, {"sha": "a1a119629a94e43b814b95efb59ff7a0160bc123", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -297,6 +297,7 @@ impl Foo<str> {}\n //- /lib.rs crate:main deps:core\n fn foo(_: bool$0) {{}}\n //- /libcore.rs crate:core\n+#![rustc_coherence_is_core]\n #[lang = \"bool\"]\n impl bool {}\n    //^^^^"}, {"sha": "6d2d0bd635165b2bba55a7ff4fccd6b74fbe03d4", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -55,7 +55,7 @@ pub(crate) fn goto_type_definition(\n                                 ty\n                             } else {\n                                 let record_field = ast::RecordPatField::for_field_name_ref(&it)?;\n-                                sema.resolve_record_pat_field(&record_field)?.ty(db)\n+                                sema.resolve_record_pat_field(&record_field)?.1\n                             }\n                         },\n                         _ => return None,"}, {"sha": "46505b30441090bff30d9bbd36865209c482a1f5", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/adjustment.rs", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -31,19 +31,31 @@ pub(super) fn hints(\n         return None;\n     }\n \n-    // These inherit from the inner expression which would result in duplicate hints\n-    if let ast::Expr::ParenExpr(_)\n-    | ast::Expr::IfExpr(_)\n-    | ast::Expr::BlockExpr(_)\n-    | ast::Expr::MatchExpr(_) = expr\n-    {\n+    // ParenExpr resolve to their contained expressions HIR so they will dupe these hints\n+    if let ast::Expr::ParenExpr(_) = expr {\n         return None;\n     }\n+    if let ast::Expr::BlockExpr(b) = expr {\n+        if !b.is_standalone() {\n+            return None;\n+        }\n+    }\n \n     let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n     let desc_expr = descended.as_ref().unwrap_or(expr);\n     let adjustments = sema.expr_adjustments(desc_expr).filter(|it| !it.is_empty())?;\n \n+    if let ast::Expr::BlockExpr(_) | ast::Expr::IfExpr(_) | ast::Expr::MatchExpr(_) = desc_expr {\n+        if let [Adjustment { kind: Adjust::Deref(_), source, .. }, Adjustment { kind: Adjust::Borrow(_), source: _, target }] =\n+            &*adjustments\n+        {\n+            // Don't show unnecessary reborrows for these, they will just repeat the inner ones again\n+            if source == target {\n+                return None;\n+            }\n+        }\n+    }\n+\n     let (postfix, needs_outer_parens, needs_inner_parens) =\n         mode_and_needs_parens_for_adjustment_hints(expr, config.adjustment_hints_mode);\n \n@@ -67,6 +79,7 @@ pub(super) fn hints(\n \n     for Adjustment { source, target, kind } in iter {\n         if source == target {\n+            cov_mark::hit!(same_type_adjustment);\n             continue;\n         }\n \n@@ -251,7 +264,7 @@ mod tests {\n         check_with_config(\n             InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n             r#\"\n-//- minicore: coerce_unsized, fn\n+//- minicore: coerce_unsized, fn, eq\n fn main() {\n     let _: u32         = loop {};\n                        //^^^^^^^<never-to-any>\n@@ -332,7 +345,7 @@ fn main() {\n         loop {}\n       //^^^^^^^<never-to-any>\n     };\n-    let _: &mut [u32] = match () { () => &mut [] }\n+    let _: &mut [u32] = match () { () => &mut [] };\n                                        //^^^^^^^<unsize>\n                                        //^^^^^^^&mut $\n                                        //^^^^^^^*\n@@ -341,6 +354,12 @@ fn main() {\n                          //^^^^^^^^^^<unsize>\n                          //^^^^^^^^^^&mut $\n                          //^^^^^^^^^^*\n+    () == ();\n+ // ^^&\n+       // ^^&\n+    (()) == {()};\n+  // ^^&\n+         // ^^^^&\n }\n \n #[derive(Copy, Clone)]\n@@ -363,7 +382,7 @@ impl Struct {\n                 ..DISABLED_CONFIG\n             },\n             r#\"\n-//- minicore: coerce_unsized, fn\n+//- minicore: coerce_unsized, fn, eq\n fn main() {\n \n     Struct.consume();\n@@ -419,7 +438,7 @@ fn main() {\n         loop {}\n       //^^^^^^^.<never-to-any>\n     };\n-    let _: &mut [u32] = match () { () => &mut [] }\n+    let _: &mut [u32] = match () { () => &mut [] };\n                                        //^^^^^^^(\n                                        //^^^^^^^)\n                                        //^^^^^^^.*\n@@ -432,6 +451,12 @@ fn main() {\n                          //^^^^^^^^^^.*\n                          //^^^^^^^^^^.&mut\n                          //^^^^^^^^^^.<unsize>\n+    () == ();\n+ // ^^.&\n+       // ^^.&\n+    (()) == {()};\n+  // ^^.&\n+         // ^^^^.&\n }\n \n #[derive(Copy, Clone)]\n@@ -499,6 +524,7 @@ fn main() {\n \n     #[test]\n     fn never_to_never_is_never_shown() {\n+        cov_mark::check!(same_type_adjustment);\n         check_with_config(\n             InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n             r#\""}, {"sha": "1e1771259b1ba624101e1b911886ce3b5e2c7518", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -435,7 +435,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3386..3394,\n+                                        range: 3415..3423,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -448,7 +448,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3418..3422,\n+                                        range: 3447..3451,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -468,7 +468,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3386..3394,\n+                                        range: 3415..3423,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -481,7 +481,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3418..3422,\n+                                        range: 3447..3451,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -501,7 +501,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3386..3394,\n+                                        range: 3415..3423,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -514,7 +514,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3418..3422,\n+                                        range: 3447..3451,\n                                     },\n                                 ),\n                                 tooltip: \"\","}, {"sha": "4b2c139f6f455b3f8fa5ad462c6343d5d9faaeed", "filename": "src/tools/rust-analyzer/crates/ide/src/signature_help.rs", "status": "modified", "additions": 257, "deletions": 6, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -16,7 +16,7 @@ use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxElementChildren, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -102,6 +102,20 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                     }\n                     return signature_help_for_record_lit(&sema, record, token);\n                 },\n+                ast::RecordPat(record) => {\n+                    let cursor_outside = record.record_pat_field_list().and_then(|list| list.r_curly_token()).as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_record_pat(&sema, record, token);\n+                },\n+                ast::TupleStructPat(tuple_pat) => {\n+                    let cursor_outside = tuple_pat.r_paren_token().as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_tuple_struct_pat(&sema, tuple_pat, token);\n+                },\n                 _ => (),\n             }\n         }\n@@ -346,10 +360,111 @@ fn signature_help_for_record_lit(\n     record: ast::RecordExpr,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let active_parameter = record\n-        .record_expr_field_list()?\n+    signature_help_for_record_(\n+        sema,\n+        record.record_expr_field_list()?.syntax().children_with_tokens(),\n+        &record.path()?,\n+        record\n+            .record_expr_field_list()?\n+            .fields()\n+            .filter_map(|field| sema.resolve_record_field(&field))\n+            .map(|(field, _, ty)| (field, ty)),\n+        token,\n+    )\n+}\n+\n+fn signature_help_for_record_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    record: ast::RecordPat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    signature_help_for_record_(\n+        sema,\n+        record.record_pat_field_list()?.syntax().children_with_tokens(),\n+        &record.path()?,\n+        record\n+            .record_pat_field_list()?\n+            .fields()\n+            .filter_map(|field| sema.resolve_record_pat_field(&field)),\n+        token,\n+    )\n+}\n+\n+fn signature_help_for_tuple_struct_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    pat: ast::TupleStructPat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let rest_pat = pat.fields().find(|it| matches!(it, ast::Pat::RestPat(_)));\n+    let is_left_of_rest_pat =\n+        rest_pat.map_or(true, |it| token.text_range().start() < it.syntax().text_range().end());\n+\n+    let mut res = SignatureHelp {\n+        doc: None,\n+        signature: String::new(),\n+        parameters: vec![],\n+        active_parameter: None,\n+    };\n+\n+    let db = sema.db;\n+    let path_res = sema.resolve_path(&pat.path()?)?;\n+    let fields: Vec<_> = if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n+        let en = variant.parent_enum(db);\n+\n+        res.doc = en.docs(db).map(|it| it.into());\n+        format_to!(res.signature, \"enum {}::{} (\", en.name(db), variant.name(db));\n+        variant.fields(db)\n+    } else {\n+        let adt = match path_res {\n+            PathResolution::SelfType(imp) => imp.self_ty(db).as_adt()?,\n+            PathResolution::Def(ModuleDef::Adt(adt)) => adt,\n+            _ => return None,\n+        };\n+\n+        match adt {\n+            hir::Adt::Struct(it) => {\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"struct {} (\", it.name(db));\n+                it.fields(db)\n+            }\n+            _ => return None,\n+        }\n+    };\n+    let commas = pat\n         .syntax()\n         .children_with_tokens()\n+        .filter_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.kind() == syntax::T![,]);\n+    res.active_parameter = Some(if is_left_of_rest_pat {\n+        commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()\n+    } else {\n+        let n_commas = commas\n+            .collect::<Vec<_>>()\n+            .into_iter()\n+            .rev()\n+            .take_while(|t| t.text_range().start() > token.text_range().start())\n+            .count();\n+        fields.len().saturating_sub(1).saturating_sub(n_commas)\n+    });\n+\n+    let mut buf = String::new();\n+    for ty in fields.into_iter().map(|it| it.ty(db)) {\n+        format_to!(buf, \"{}\", ty.display_truncated(db, Some(20)));\n+        res.push_call_param(&buf);\n+        buf.clear();\n+    }\n+    res.signature.push_str(\")\");\n+    Some(res)\n+}\n+\n+fn signature_help_for_record_(\n+    sema: &Semantics<'_, RootDatabase>,\n+    field_list_children: SyntaxElementChildren,\n+    path: &ast::Path,\n+    fields2: impl Iterator<Item = (hir::Field, hir::Type)>,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let active_parameter = field_list_children\n         .filter_map(syntax::NodeOrToken::into_token)\n         .filter(|t| t.kind() == syntax::T![,])\n         .take_while(|t| t.text_range().start() <= token.text_range().start())\n@@ -365,7 +480,7 @@ fn signature_help_for_record_lit(\n     let fields;\n \n     let db = sema.db;\n-    let path_res = sema.resolve_path(&record.path()?)?;\n+    let path_res = sema.resolve_path(path)?;\n     if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n         fields = variant.fields(db);\n         let en = variant.parent_enum(db);\n@@ -397,8 +512,7 @@ fn signature_help_for_record_lit(\n     let mut fields =\n         fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();\n     let mut buf = String::new();\n-    for field in record.record_expr_field_list()?.fields() {\n-        let Some((field, _, ty)) = sema.resolve_record_field(&field) else { continue };\n+    for (field, ty) in fields2 {\n         let name = field.name(db);\n         format_to!(buf, \"{name}: {}\", ty.display_truncated(db, Some(20)));\n         res.push_record_field(&buf);\n@@ -439,6 +553,7 @@ mod tests {\n         (database, FilePosition { file_id, offset })\n     }\n \n+    #[track_caller]\n     fn check(ra_fixture: &str, expect: Expect) {\n         let fixture = format!(\n             r#\"\n@@ -890,6 +1005,119 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn tuple_struct_pat() {\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32);\n+fn main() {\n+    let S(0, $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32)\n+                          ---  ^^^\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct_pat_rest() {\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(0, .., $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ---  ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16, u8);\n+fn main() {\n+    let S(0, .., $0, 0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16, u8)\n+                          ---  ---  ---  ^^^  --\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S($0, .., 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ^^^  ---  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16, u8);\n+fn main() {\n+    let S(1, .., 1, $0, 2);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16, u8)\n+                          ---  ---  ---  ^^^  --\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(1, $0.., 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(1, ..$0, 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn generic_struct() {\n         check(\n@@ -1550,6 +1778,29 @@ impl S {\n         );\n     }\n \n+    #[test]\n+    fn record_pat() {\n+        check(\n+            r#\"\n+struct Strukt<T, U = ()> {\n+    t: T,\n+    u: U,\n+    unit: (),\n+}\n+fn f() {\n+    let Strukt {\n+        u: 0,\n+        $0\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Strukt { u: i32, t: T, unit: () }\n+                                ------  ^^^^  --------\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_enum_in_nested_method_in_lambda() {\n         check("}, {"sha": "5f4977886f6ebe076fde8f190af25ac50af95d0c", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -431,14 +431,15 @@ fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {\n \n fn pat_list(p: &mut Parser<'_>, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n-        if !p.at_ts(PAT_TOP_FIRST) {\n-            p.error(\"expected a pattern\");\n-            break;\n-        }\n-\n         pattern_top(p);\n-        if !p.at(ket) {\n-            p.expect(T![,]);\n+        if !p.at(T![,]) {\n+            if p.at_ts(PAT_TOP_FIRST) {\n+                p.error(format!(\"expected {:?}, got {:?}\", T![,], p.current()));\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(T![,]);\n         }\n     }\n }"}, {"sha": "4e5d640f175e461c8971ce023d99641da8dab02b", "filename": "src/tools/rust-analyzer/crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -429,8 +429,9 @@ impl WorkspaceBuildScripts {\n             for p in rustc.packages() {\n                 let package = &rustc[p];\n                 if package.targets.iter().any(|&it| rustc[it].is_proc_macro) {\n-                    if let Some((_, path)) =\n-                        proc_macro_dylibs.iter().find(|(name, _)| *name == package.name)\n+                    if let Some((_, path)) = proc_macro_dylibs\n+                        .iter()\n+                        .find(|(name, _)| *name.trim_start_matches(\"lib\") == package.name)\n                     {\n                         bs.outputs[p].proc_macro_dylib_path = Some(path.clone());\n                     }"}, {"sha": "01162b1a8ba0cd8bed2c641cfbe6ce25fc7aa881", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -50,7 +50,7 @@ impl ops::Index<Target> for CargoWorkspace {\n \n /// Describes how to set the rustc source directory.\n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub enum RustcSource {\n+pub enum RustLibSource {\n     /// Explicit path for the rustc source directory.\n     Path(AbsPathBuf),\n     /// Try to automatically detect where the rustc source directory is.\n@@ -95,10 +95,10 @@ pub struct CargoConfig {\n     /// rustc target\n     pub target: Option<String>,\n     /// Sysroot loading behavior\n-    pub sysroot: Option<RustcSource>,\n+    pub sysroot: Option<RustLibSource>,\n     pub sysroot_src: Option<AbsPathBuf>,\n     /// rustc private crate source\n-    pub rustc_source: Option<RustcSource>,\n+    pub rustc_source: Option<RustLibSource>,\n     /// crates to disable `#[cfg(test)]` on\n     pub unset_test_crates: UnsetTestCrates,\n     /// Invoke `cargo check` through the RUSTC_WRAPPER."}, {"sha": "70cb71ae3bde8438478f21b14b3c2cfb5922f02d", "filename": "src/tools/rust-analyzer/crates/project-model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -44,7 +44,7 @@ pub use crate::{\n     build_scripts::WorkspaceBuildScripts,\n     cargo_workspace::{\n         CargoConfig, CargoFeatures, CargoWorkspace, Package, PackageData, PackageDependency,\n-        RustcSource, Target, TargetData, TargetKind, UnsetTestCrates,\n+        RustLibSource, Target, TargetData, TargetKind, UnsetTestCrates,\n     },\n     manifest_path::ManifestPath,\n     project_json::{ProjectJson, ProjectJsonData},"}, {"sha": "3754accbb03d8ad591f106bbfb953dca28ff19fa", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -24,8 +24,8 @@ fn load_cargo_with_overrides(file: &str, cfg_overrides: CfgOverrides) -> CrateGr\n     let project_workspace = ProjectWorkspace::Cargo {\n         cargo: cargo_workspace,\n         build_scripts: WorkspaceBuildScripts::default(),\n-        sysroot: None,\n-        rustc: None,\n+        sysroot: Err(None),\n+        rustc: Err(None),\n         rustc_cfg: Vec::new(),\n         cfg_overrides,\n         toolchain: None,\n@@ -37,7 +37,7 @@ fn load_cargo_with_overrides(file: &str, cfg_overrides: CfgOverrides) -> CrateGr\n fn load_rust_project(file: &str) -> CrateGraph {\n     let data = get_test_json_file(file);\n     let project = rooted_project_json(data);\n-    let sysroot = Some(get_fake_sysroot());\n+    let sysroot = Ok(get_fake_sysroot());\n     let project_workspace = ProjectWorkspace::Json { project, sysroot, rustc_cfg: Vec::new() };\n     to_crate_graph(project_workspace)\n }"}, {"sha": "d1e53e12eebb5691cce40bd4e0cf87b078ba1bde", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 110, "deletions": 114, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -17,7 +17,7 @@ use stdx::{always, hash::NoHashHashMap};\n \n use crate::{\n     build_scripts::BuildScriptOutput,\n-    cargo_workspace::{DepKind, PackageData, RustcSource},\n+    cargo_workspace::{DepKind, PackageData, RustLibSource},\n     cfg_flag::CfgFlag,\n     rustc_cfg,\n     sysroot::SysrootCrate,\n@@ -69,8 +69,8 @@ pub enum ProjectWorkspace {\n     Cargo {\n         cargo: CargoWorkspace,\n         build_scripts: WorkspaceBuildScripts,\n-        sysroot: Option<Sysroot>,\n-        rustc: Option<(CargoWorkspace, WorkspaceBuildScripts)>,\n+        sysroot: Result<Sysroot, Option<String>>,\n+        rustc: Result<(CargoWorkspace, WorkspaceBuildScripts), Option<String>>,\n         /// Holds cfg flags for the current target. We get those by running\n         /// `rustc --print cfg`.\n         ///\n@@ -82,7 +82,7 @@ pub enum ProjectWorkspace {\n         target_layout: Result<String, String>,\n     },\n     /// Project workspace was manually specified using a `rust-project.json` file.\n-    Json { project: ProjectJson, sysroot: Option<Sysroot>, rustc_cfg: Vec<CfgFlag> },\n+    Json { project: ProjectJson, sysroot: Result<Sysroot, Option<String>>, rustc_cfg: Vec<CfgFlag> },\n     // FIXME: The primary limitation of this approach is that the set of detached files needs to be fixed at the beginning.\n     // That's not the end user experience we should strive for.\n     // Ideally, you should be able to just open a random detached file in existing cargo projects, and get the basic features working.\n@@ -93,7 +93,11 @@ pub enum ProjectWorkspace {\n     // //\n     /// Project with a set of disjoint files, not belonging to any particular workspace.\n     /// Backed by basic sysroot crates for basic completion and highlighting.\n-    DetachedFiles { files: Vec<AbsPathBuf>, sysroot: Option<Sysroot>, rustc_cfg: Vec<CfgFlag> },\n+    DetachedFiles {\n+        files: Vec<AbsPathBuf>,\n+        sysroot: Result<Sysroot, Option<String>>,\n+        rustc_cfg: Vec<CfgFlag>,\n+    },\n }\n \n impl fmt::Debug for ProjectWorkspace {\n@@ -113,7 +117,7 @@ impl fmt::Debug for ProjectWorkspace {\n                 .debug_struct(\"Cargo\")\n                 .field(\"root\", &cargo.workspace_root().file_name())\n                 .field(\"n_packages\", &cargo.packages().len())\n-                .field(\"sysroot\", &sysroot.is_some())\n+                .field(\"sysroot\", &sysroot.is_ok())\n                 .field(\n                     \"n_rustc_compiler_crates\",\n                     &rustc.as_ref().map_or(0, |(rc, _)| rc.packages().len()),\n@@ -126,7 +130,7 @@ impl fmt::Debug for ProjectWorkspace {\n             ProjectWorkspace::Json { project, sysroot, rustc_cfg } => {\n                 let mut debug_struct = f.debug_struct(\"Json\");\n                 debug_struct.field(\"n_crates\", &project.n_crates());\n-                if let Some(sysroot) = sysroot {\n+                if let Ok(sysroot) = sysroot {\n                     debug_struct.field(\"n_sysroot_crates\", &sysroot.crates().len());\n                 }\n                 debug_struct.field(\"n_rustc_cfg\", &rustc_cfg.len());\n@@ -135,7 +139,7 @@ impl fmt::Debug for ProjectWorkspace {\n             ProjectWorkspace::DetachedFiles { files, sysroot, rustc_cfg } => f\n                 .debug_struct(\"DetachedFiles\")\n                 .field(\"n_files\", &files.len())\n-                .field(\"sysroot\", &sysroot.is_some())\n+                .field(\"sysroot\", &sysroot.is_ok())\n                 .field(\"n_rustc_cfg\", &rustc_cfg.len())\n                 .finish(),\n         }\n@@ -191,93 +195,81 @@ impl ProjectWorkspace {\n                 let cargo = CargoWorkspace::new(meta);\n \n                 let sysroot = match (&config.sysroot, &config.sysroot_src) {\n-                    (Some(RustcSource::Path(path)), None) => {\n-                        match Sysroot::with_sysroot_dir(path.clone()) {\n-                            Ok(it) => Some(it),\n-                            Err(e) => {\n-                                tracing::error!(%e, \"Failed to find sysroot at {}.\", path.display());\n-                                None\n-                            }\n-                        }\n+                    (Some(RustLibSource::Path(path)), None) => {\n+                        Sysroot::with_sysroot_dir(path.clone()).map_err(|e| {\n+                          Some(format!(\"Failed to find sysroot at {}:{e}\", path.display()))\n+                        })\n                     }\n-                    (Some(RustcSource::Discover), None) => {\n-                        match Sysroot::discover(cargo_toml.parent(), &config.extra_env) {\n-                            Ok(it) => Some(it),\n-                            Err(e) => {\n-                                tracing::error!(\n-                                    %e,\n-                                    \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n-                                    cargo_toml.display()\n-                                );\n-                                None\n-                            }\n-                        }\n+                    (Some(RustLibSource::Discover), None) => {\n+                        Sysroot::discover(cargo_toml.parent(), &config.extra_env).map_err(|e| {\n+                            Some(format!(\"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed? {e}\", cargo_toml.display()))\n+                        })\n                     }\n-                    (Some(RustcSource::Path(sysroot)), Some(sysroot_src)) => {\n-                        Some(Sysroot::load(sysroot.clone(), sysroot_src.clone()))\n+                    (Some(RustLibSource::Path(sysroot)), Some(sysroot_src)) => {\n+                        Ok(Sysroot::load(sysroot.clone(), sysroot_src.clone()))\n                     }\n-                    (Some(RustcSource::Discover), Some(sysroot_src)) => {\n-                        match Sysroot::discover_with_src_override(\n+                    (Some(RustLibSource::Discover), Some(sysroot_src)) => {\n+                        Sysroot::discover_with_src_override(\n                             cargo_toml.parent(),\n                             &config.extra_env,\n                             sysroot_src.clone(),\n-                        ) {\n-                            Ok(it) => Some(it),\n-                            Err(e) => {\n-                                tracing::error!(\n-                                    %e,\n-                                    \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n-                                    cargo_toml.display()\n-                                );\n-                                None\n-                            }\n-                        }\n+                        ).map_err(|e| {\n+                            Some(format!(\"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed? {e}\", cargo_toml.display()))\n+                        })\n                     }\n-                    (None, _) => None,\n+                    (None, _) => Err(None),\n                 };\n \n-                if let Some(sysroot) = &sysroot {\n+                if let Ok(sysroot) = &sysroot {\n                     tracing::info!(workspace = %cargo_toml.display(), src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n                 }\n \n                 let rustc_dir = match &config.rustc_source {\n-                    Some(RustcSource::Path(path)) => ManifestPath::try_from(path.clone()).ok(),\n-                    Some(RustcSource::Discover) => {\n-                        sysroot.as_ref().and_then(Sysroot::discover_rustc)\n+                    Some(RustLibSource::Path(path)) => ManifestPath::try_from(path.clone())\n+                        .map_err(|p| {\n+                            Some(format!(\"rustc source path is not absolute: {}\", p.display()))\n+                        }),\n+                    Some(RustLibSource::Discover) => {\n+                        sysroot.as_ref().ok().and_then(Sysroot::discover_rustc).ok_or_else(|| {\n+                            Some(format!(\"Failed to discover rustc source for sysroot.\"))\n+                        })\n                     }\n-                    None => None,\n+                    None => Err(None),\n                 };\n \n-                let rustc = match rustc_dir {\n-                    Some(rustc_dir) => {\n-                        tracing::info!(workspace = %cargo_toml.display(), rustc_dir = %rustc_dir.display(), \"Using rustc source\");\n-                        match CargoWorkspace::fetch_metadata(\n-                            &rustc_dir,\n-                            cargo_toml.parent(),\n-                            config,\n-                            progress,\n-                        ) {\n-                            Ok(meta) => {\n-                                let workspace = CargoWorkspace::new(meta);\n-                                let buildscripts = WorkspaceBuildScripts::rustc_crates(\n-                                    &workspace,\n-                                    cargo_toml.parent(),\n-                                    &config.extra_env,\n-                                );\n-                                Some((workspace, buildscripts))\n-                            }\n-                            Err(e) => {\n-                                tracing::error!(\n-                                    %e,\n-                                    \"Failed to read Cargo metadata from rustc source at {}\",\n-                                    rustc_dir.display()\n-                                );\n-                                None\n-                            }\n+                let rustc =  rustc_dir.and_then(|rustc_dir| {\n+                    tracing::info!(workspace = %cargo_toml.display(), rustc_dir = %rustc_dir.display(), \"Using rustc source\");\n+                    match CargoWorkspace::fetch_metadata(\n+                        &rustc_dir,\n+                        cargo_toml.parent(),\n+                        &CargoConfig {\n+                            features: crate::CargoFeatures::default(),\n+                            ..config.clone()\n+                        },\n+                        progress,\n+                    ) {\n+                        Ok(meta) => {\n+                            let workspace = CargoWorkspace::new(meta);\n+                            let buildscripts = WorkspaceBuildScripts::rustc_crates(\n+                                &workspace,\n+                                cargo_toml.parent(),\n+                                &config.extra_env,\n+                            );\n+                            Ok((workspace, buildscripts))\n+                        }\n+                        Err(e) => {\n+                            tracing::error!(\n+                                %e,\n+                                \"Failed to read Cargo metadata from rustc source at {}\",\n+                                rustc_dir.display()\n+                            );\n+                            Err(Some(format!(\n+                                \"Failed to read Cargo metadata from rustc source at {}: {e}\",\n+                                rustc_dir.display())\n+                            ))\n                         }\n                     }\n-                    None => None,\n-                };\n+                });\n \n                 let rustc_cfg =\n                     rustc_cfg::get(Some(&cargo_toml), config.target.as_deref(), &config.extra_env);\n@@ -313,24 +305,24 @@ impl ProjectWorkspace {\n         extra_env: &FxHashMap<String, String>,\n     ) -> ProjectWorkspace {\n         let sysroot = match (project_json.sysroot.clone(), project_json.sysroot_src.clone()) {\n-            (Some(sysroot), Some(sysroot_src)) => Some(Sysroot::load(sysroot, sysroot_src)),\n+            (Some(sysroot), Some(sysroot_src)) => Ok(Sysroot::load(sysroot, sysroot_src)),\n             (Some(sysroot), None) => {\n                 // assume sysroot is structured like rustup's and guess `sysroot_src`\n                 let sysroot_src =\n                     sysroot.join(\"lib\").join(\"rustlib\").join(\"src\").join(\"rust\").join(\"library\");\n-                Some(Sysroot::load(sysroot, sysroot_src))\n+                Ok(Sysroot::load(sysroot, sysroot_src))\n             }\n             (None, Some(sysroot_src)) => {\n                 // assume sysroot is structured like rustup's and guess `sysroot`\n                 let mut sysroot = sysroot_src.clone();\n                 for _ in 0..5 {\n                     sysroot.pop();\n                 }\n-                Some(Sysroot::load(sysroot, sysroot_src))\n+                Ok(Sysroot::load(sysroot, sysroot_src))\n             }\n-            (None, None) => None,\n+            (None, None) => Err(None),\n         };\n-        if let Some(sysroot) = &sysroot {\n+        if let Ok(sysroot) = &sysroot {\n             tracing::info!(src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n         }\n \n@@ -343,33 +335,23 @@ impl ProjectWorkspace {\n         config: &CargoConfig,\n     ) -> Result<ProjectWorkspace> {\n         let sysroot = match &config.sysroot {\n-            Some(RustcSource::Path(path)) => match Sysroot::with_sysroot_dir(path.clone()) {\n-                Ok(it) => Some(it),\n-                Err(e) => {\n-                    tracing::error!(%e, \"Failed to find sysroot at {}.\", path.display());\n-                    None\n-                }\n-            },\n-            Some(RustcSource::Discover) => {\n+            Some(RustLibSource::Path(path)) => Sysroot::with_sysroot_dir(path.clone())\n+                .map_err(|e| Some(format!(\"Failed to find sysroot at {}:{e}\", path.display()))),\n+            Some(RustLibSource::Discover) => {\n                 let dir = &detached_files\n                     .first()\n                     .and_then(|it| it.parent())\n                     .ok_or_else(|| format_err!(\"No detached files to load\"))?;\n-                match Sysroot::discover(dir, &config.extra_env) {\n-                    Ok(it) => Some(it),\n-                    Err(e) => {\n-                        tracing::error!(\n-                            %e,\n-                            \"Failed to find sysroot for {}. Is rust-src installed?\",\n-                            dir.display()\n-                        );\n-                        None\n-                    }\n-                }\n+                Sysroot::discover(dir, &config.extra_env).map_err(|e| {\n+                    Some(format!(\n+                        \"Failed to find sysroot for {}. Is rust-src installed? {e}\",\n+                        dir.display()\n+                    ))\n+                })\n             }\n-            None => None,\n+            None => Err(None),\n         };\n-        if let Some(sysroot) = &sysroot {\n+        if let Ok(sysroot) = &sysroot {\n             tracing::info!(src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n         }\n         let rustc_cfg = rustc_cfg::get(None, None, &Default::default());\n@@ -450,10 +432,18 @@ impl ProjectWorkspace {\n         }\n     }\n \n+    pub fn workspace_definition_path(&self) -> Option<&AbsPath> {\n+        match self {\n+            ProjectWorkspace::Cargo { cargo, .. } => Some(cargo.workspace_root()),\n+            ProjectWorkspace::Json { project, .. } => Some(project.path()),\n+            ProjectWorkspace::DetachedFiles { .. } => None,\n+        }\n+    }\n+\n     pub fn find_sysroot_proc_macro_srv(&self) -> Option<AbsPathBuf> {\n         match self {\n-            ProjectWorkspace::Cargo { sysroot: Some(sysroot), .. }\n-            | ProjectWorkspace::Json { sysroot: Some(sysroot), .. } => {\n+            ProjectWorkspace::Cargo { sysroot: Ok(sysroot), .. }\n+            | ProjectWorkspace::Json { sysroot: Ok(sysroot), .. } => {\n                 let standalone_server_name =\n                     format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n                 [\"libexec\", \"lib\"]\n@@ -469,7 +459,7 @@ impl ProjectWorkspace {\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n     pub fn to_roots(&self) -> Vec<PackageRoot> {\n-        let mk_sysroot = |sysroot: Option<&Sysroot>, project_root: Option<&AbsPath>| {\n+        let mk_sysroot = |sysroot: Result<&Sysroot, _>, project_root: Option<&AbsPath>| {\n             sysroot.map(|sysroot| PackageRoot {\n                 // mark the sysroot as mutable if it is located inside of the project\n                 is_local: project_root\n@@ -592,7 +582,7 @@ impl ProjectWorkspace {\n                 load_proc_macro,\n                 load,\n                 project,\n-                sysroot.as_ref(),\n+                sysroot.as_ref().ok(),\n                 extra_env,\n                 Err(\"rust-project.json projects have no target layout set\".into()),\n             ),\n@@ -608,9 +598,9 @@ impl ProjectWorkspace {\n             } => cargo_to_crate_graph(\n                 load_proc_macro,\n                 load,\n-                rustc,\n+                rustc.as_ref().ok(),\n                 cargo,\n-                sysroot.as_ref(),\n+                sysroot.as_ref().ok(),\n                 rustc_cfg.clone(),\n                 cfg_overrides,\n                 build_scripts,\n@@ -624,7 +614,7 @@ impl ProjectWorkspace {\n                     rustc_cfg.clone(),\n                     load,\n                     files,\n-                    sysroot,\n+                    sysroot.as_ref().ok(),\n                     Err(\"detached file projects have no target layout set\".into()),\n                 )\n             }\n@@ -786,7 +776,7 @@ fn project_json_to_crate_graph(\n fn cargo_to_crate_graph(\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    rustc: &Option<(CargoWorkspace, WorkspaceBuildScripts)>,\n+    rustc: Option<&(CargoWorkspace, WorkspaceBuildScripts)>,\n     cargo: &CargoWorkspace,\n     sysroot: Option<&Sysroot>,\n     rustc_cfg: Vec<CfgFlag>,\n@@ -932,7 +922,7 @@ fn cargo_to_crate_graph(\n     if has_private {\n         // If the user provided a path to rustc sources, we add all the rustc_private crates\n         // and create dependencies on them for the crates which opt-in to that\n-        if let Some((rustc_workspace, build_scripts)) = rustc {\n+        if let Some((rustc_workspace, rustc_build_scripts)) = rustc {\n             handle_rustc_crates(\n                 &mut crate_graph,\n                 &mut pkg_to_lib_crate,\n@@ -945,7 +935,13 @@ fn cargo_to_crate_graph(\n                 &pkg_crates,\n                 &cfg_options,\n                 override_cfg,\n-                build_scripts,\n+                if rustc_workspace.workspace_root() == cargo.workspace_root() {\n+                    // the rustc workspace does not use the installed toolchain's proc-macro server\n+                    // so we need to make sure we don't use the pre compiled proc-macros there either\n+                    build_scripts\n+                } else {\n+                    rustc_build_scripts\n+                },\n                 target_layout,\n             );\n         }\n@@ -957,7 +953,7 @@ fn detached_files_to_crate_graph(\n     rustc_cfg: Vec<CfgFlag>,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     detached_files: &[AbsPathBuf],\n-    sysroot: &Option<Sysroot>,\n+    sysroot: Option<&Sysroot>,\n     target_layout: TargetLayoutLoadResult,\n ) -> CrateGraph {\n     let _p = profile::span(\"detached_files_to_crate_graph\");"}, {"sha": "6ce1de5d32bcac068df2e40d3f9a98ae323e30c7", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -7,7 +7,7 @@ use std::{\n };\n \n use hir::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n+    db::{DefDatabase, ExpandDatabase, HirDatabase},\n     AssocItem, Crate, Function, HasSource, HirDisplay, ModuleDef,\n };\n use hir_def::{\n@@ -24,7 +24,7 @@ use ide_db::base_db::{\n use itertools::Itertools;\n use oorandom::Rand32;\n use profile::{Bytes, StopWatch};\n-use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustcSource};\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustLibSource};\n use rayon::prelude::*;\n use rustc_hash::FxHashSet;\n use stdx::format_to;\n@@ -57,7 +57,7 @@ impl flags::AnalysisStats {\n         let mut cargo_config = CargoConfig::default();\n         cargo_config.sysroot = match self.no_sysroot {\n             true => None,\n-            false => Some(RustcSource::Discover),\n+            false => Some(RustLibSource::Discover),\n         };\n         let no_progress = &|_| ();\n "}, {"sha": "4006d023def52be059fa3310a4091fa65a6229b7", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,7 +1,7 @@\n //! Analyze all modules in a project for diagnostics. Exits with a non-zero\n //! status code if any errors are found.\n \n-use project_model::{CargoConfig, RustcSource};\n+use project_model::{CargoConfig, RustLibSource};\n use rustc_hash::FxHashSet;\n \n use hir::{db::HirDatabase, Crate, Module};\n@@ -16,7 +16,7 @@ use crate::cli::{\n impl flags::Diagnostics {\n     pub fn run(self) -> anyhow::Result<()> {\n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.sysroot = Some(RustcSource::Discover);\n+        cargo_config.sysroot = Some(RustLibSource::Discover);\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: !self.disable_build_scripts,\n             with_proc_macro_server: ProcMacroServerChoice::Sysroot,"}, {"sha": "7f5d084496714d08d51d6a17fb82806ff08e8366", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -13,7 +13,7 @@ use ide_db::LineIndexDatabase;\n use ide_db::base_db::salsa::{self, ParallelDatabase};\n use ide_db::line_index::WideEncoding;\n use lsp_types::{self, lsif};\n-use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustcSource};\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustLibSource};\n use vfs::{AbsPathBuf, Vfs};\n \n use crate::cli::load_cargo::ProcMacroServerChoice;\n@@ -290,7 +290,7 @@ impl flags::Lsif {\n         eprintln!(\"Generating LSIF started...\");\n         let now = Instant::now();\n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.sysroot = Some(RustcSource::Discover);\n+        cargo_config.sysroot = Some(RustLibSource::Discover);\n         let no_progress = &|_| ();\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: true,"}, {"sha": "3e5e40750e9cac931a7ce391e2ef52a8bfbed57b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -15,7 +15,7 @@ use ide::{\n     TokenStaticData,\n };\n use ide_db::LineIndexDatabase;\n-use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustcSource};\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustLibSource};\n use scip::types as scip_types;\n use std::env;\n \n@@ -30,7 +30,7 @@ impl flags::Scip {\n         eprintln!(\"Generating SCIP start...\");\n         let now = Instant::now();\n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.sysroot = Some(RustcSource::Discover);\n+        cargo_config.sysroot = Some(RustLibSource::Discover);\n \n         let no_progress = &|s| (eprintln!(\"rust-analyzer: Loading {s}\"));\n         let load_cargo_config = LoadCargoConfig {"}, {"sha": "82a769347df04fe356ce95702c1b30a6e5c8c5e4", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/ssr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -1,7 +1,7 @@\n //! Applies structured search replace rules from the command line.\n \n use ide_ssr::MatchFinder;\n-use project_model::{CargoConfig, RustcSource};\n+use project_model::{CargoConfig, RustLibSource};\n \n use crate::cli::{\n     flags,\n@@ -13,7 +13,7 @@ impl flags::Ssr {\n     pub fn run(self) -> Result<()> {\n         use ide_db::base_db::SourceDatabaseExt;\n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.sysroot = Some(RustcSource::Discover);\n+        cargo_config.sysroot = Some(RustLibSource::Discover);\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: true,\n             with_proc_macro_server: ProcMacroServerChoice::Sysroot,"}, {"sha": "c35cce103fab60ce138e643dcbf318a19a990a39", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -22,7 +22,7 @@ use ide_db::{\n use itertools::Itertools;\n use lsp_types::{ClientCapabilities, MarkupKind};\n use project_model::{\n-    CargoConfig, CargoFeatures, ProjectJson, ProjectJsonData, ProjectManifest, RustcSource,\n+    CargoConfig, CargoFeatures, ProjectJson, ProjectJsonData, ProjectManifest, RustLibSource,\n     UnsetTestCrates,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -272,7 +272,6 @@ config_data! {\n         /// The warnings will be indicated by a blue squiggly underline in code\n         /// and a blue icon in the `Problems Panel`.\n         diagnostics_warningsAsInfo: Vec<String> = \"[]\",\n-\n         /// These directories will be ignored by rust-analyzer. They are\n         /// relative to the workspace root, and globs are not supported. You may\n         /// also need to add the folders to Code's `files.watcherExclude`.\n@@ -895,6 +894,15 @@ impl Config {\n         }\n     }\n \n+    pub fn add_linked_projects(&mut self, linked_projects: Vec<ProjectJsonData>) {\n+        let mut linked_projects = linked_projects\n+            .into_iter()\n+            .map(ManifestOrProjectJson::ProjectJson)\n+            .collect::<Vec<ManifestOrProjectJson>>();\n+\n+        self.data.linkedProjects.append(&mut linked_projects);\n+    }\n+\n     pub fn did_save_text_document_dynamic_registration(&self) -> bool {\n         let caps = try_or_def!(self.caps.text_document.as_ref()?.synchronization.clone()?);\n         caps.did_save == Some(true) && caps.dynamic_registration == Some(true)\n@@ -1129,16 +1137,16 @@ impl Config {\n     pub fn cargo(&self) -> CargoConfig {\n         let rustc_source = self.data.rustc_source.as_ref().map(|rustc_src| {\n             if rustc_src == \"discover\" {\n-                RustcSource::Discover\n+                RustLibSource::Discover\n             } else {\n-                RustcSource::Path(self.root_path.join(rustc_src))\n+                RustLibSource::Path(self.root_path.join(rustc_src))\n             }\n         });\n         let sysroot = self.data.cargo_sysroot.as_ref().map(|sysroot| {\n             if sysroot == \"discover\" {\n-                RustcSource::Discover\n+                RustLibSource::Discover\n             } else {\n-                RustcSource::Path(self.root_path.join(sysroot))\n+                RustLibSource::Path(self.root_path.join(sysroot))\n             }\n         });\n         let sysroot_src ="}, {"sha": "313bb2ec8dffa8dfa3583331a2c76db8bfc60f3a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -87,6 +87,42 @@ impl<'a> RequestDispatcher<'a> {\n         self\n     }\n \n+    /// Dispatches the request onto thread pool\n+    pub(crate) fn on_no_retry<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> &mut Self\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,\n+        R::Result: Serialize,\n+    {\n+        let (req, params, panic_context) = match self.parse::<R>() {\n+            Some(it) => it,\n+            None => return self,\n+        };\n+\n+        self.global_state.task_pool.handle.spawn({\n+            let world = self.global_state.snapshot();\n+            move || {\n+                let result = panic::catch_unwind(move || {\n+                    let _pctx = stdx::panic_context::enter(panic_context);\n+                    f(world, params)\n+                });\n+                match thread_result_to_response::<R>(req.id.clone(), result) {\n+                    Ok(response) => Task::Response(response),\n+                    Err(_) => Task::Response(lsp_server::Response::new_err(\n+                        req.id,\n+                        lsp_server::ErrorCode::ContentModified as i32,\n+                        \"content modified\".to_string(),\n+                    )),\n+                }\n+            }\n+        });\n+\n+        self\n+    }\n+\n     /// Dispatches the request onto thread pool\n     pub(crate) fn on<R>(\n         &mut self,"}, {"sha": "2fca2ab851d416ec75998236fa45ef323a0aa286", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -29,7 +29,7 @@ use project_model::{ManifestPath, ProjectWorkspace, TargetKind};\n use serde_json::json;\n use stdx::{format_to, never};\n use syntax::{algo, ast, AstNode, TextRange, TextSize};\n-use vfs::AbsPathBuf;\n+use vfs::{AbsPath, AbsPathBuf};\n \n use crate::{\n     cargo_target_spec::CargoTargetSpec,\n@@ -46,6 +46,7 @@ use crate::{\n pub(crate) fn handle_workspace_reload(state: &mut GlobalState, _: ()) -> Result<()> {\n     state.proc_macro_clients.clear();\n     state.proc_macro_changed = false;\n+\n     state.fetch_workspaces_queue.request_op(\"reload workspace request\".to_string());\n     state.fetch_build_data_queue.request_op(\"reload workspace request\".to_string());\n     Ok(())\n@@ -84,6 +85,15 @@ pub(crate) fn handle_analyzer_status(\n             snap.workspaces.len(),\n             if snap.workspaces.len() == 1 { \"\" } else { \"s\" }\n         );\n+\n+        format_to!(\n+            buf,\n+            \"Workspace root folders: {:?}\",\n+            snap.workspaces\n+                .iter()\n+                .flat_map(|ws| ws.workspace_definition_path())\n+                .collect::<Vec<&AbsPath>>()\n+        );\n     }\n     buf.push_str(\"\\nAnalysis:\\n\");\n     buf.push_str("}, {"sha": "12e5caf2cc9e43f0b0830cfaae8d3b28401dcd4a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -36,11 +36,41 @@ impl Progress {\n }\n \n impl GlobalState {\n-    pub(crate) fn show_message(&mut self, typ: lsp_types::MessageType, message: String) {\n-        let message = message;\n-        self.send_notification::<lsp_types::notification::ShowMessage>(\n-            lsp_types::ShowMessageParams { typ, message },\n-        )\n+    pub(crate) fn show_message(\n+        &mut self,\n+        typ: lsp_types::MessageType,\n+        message: String,\n+        show_open_log_button: bool,\n+    ) {\n+        match self.config.open_server_logs() && show_open_log_button  {\n+            true => self.send_request::<lsp_types::request::ShowMessageRequest>(\n+                lsp_types::ShowMessageRequestParams {\n+                    typ,\n+                    message,\n+                    actions: Some(vec![lsp_types::MessageActionItem {\n+                        title: \"Open server logs\".to_owned(),\n+                        properties: Default::default(),\n+                    }]),\n+                },\n+                |this, resp| {\n+                    let lsp_server::Response { error: None, result: Some(result), .. } = resp\n+                    else { return };\n+                    if let Ok(Some(_item)) = crate::from_json::<\n+                        <lsp_types::request::ShowMessageRequest as lsp_types::request::Request>::Result,\n+                    >(\n+                        lsp_types::request::ShowMessageRequest::METHOD, &result\n+                    ) {\n+                        this.send_notification::<lsp_ext::OpenServerLogs>(());\n+                    }\n+                },\n+            ),\n+            false => self.send_notification::<lsp_types::notification::ShowMessage>(\n+                lsp_types::ShowMessageParams {\n+                    typ,\n+                    message,\n+                },\n+            ),\n+        }\n     }\n \n     /// Sends a notification to the client containing the error `message`."}, {"sha": "67a54cde68c6f9aa586aeb1b1ea09e7939eb4022", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -406,9 +406,19 @@ impl GlobalState {\n \n             if self.config.server_status_notification() {\n                 self.send_notification::<lsp_ext::ServerStatusNotification>(status);\n-            } else if let (lsp_ext::Health::Error, Some(message)) = (status.health, &status.message)\n-            {\n-                self.show_and_log_error(message.clone(), None);\n+            } else if let (health, Some(message)) = (status.health, &status.message) {\n+                let open_log_button = tracing::enabled!(tracing::Level::ERROR)\n+                    && (self.fetch_build_data_error().is_err()\n+                        || self.fetch_workspace_error().is_err());\n+                self.show_message(\n+                    match health {\n+                        lsp_ext::Health::Ok => lsp_types::MessageType::INFO,\n+                        lsp_ext::Health::Warning => lsp_types::MessageType::WARNING,\n+                        lsp_ext::Health::Error => lsp_types::MessageType::ERROR,\n+                    },\n+                    message.clone(),\n+                    open_log_button,\n+                );\n             }\n         }\n     }\n@@ -653,7 +663,7 @@ impl GlobalState {\n             .on::<lsp_types::request::GotoDeclaration>(handlers::handle_goto_declaration)\n             .on::<lsp_types::request::GotoImplementation>(handlers::handle_goto_implementation)\n             .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)\n-            .on::<lsp_types::request::InlayHintRequest>(handlers::handle_inlay_hints)\n+            .on_no_retry::<lsp_types::request::InlayHintRequest>(handlers::handle_inlay_hints)\n             .on::<lsp_types::request::InlayHintResolveRequest>(handlers::handle_inlay_hints_resolve)\n             .on::<lsp_types::request::Completion>(handlers::handle_completion)\n             .on::<lsp_types::request::ResolveCompletionItem>(handlers::handle_completion_resolve)\n@@ -919,6 +929,7 @@ impl GlobalState {\n                                         this.show_message(\n                                             lsp_types::MessageType::WARNING,\n                                             error.to_string(),\n+                                            false,\n                                         );\n                                     }\n                                     this.update_configuration(config);"}, {"sha": "1a6e1af2eb7edd86fe66fbed80d267daa3c9d4b5", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -90,38 +90,55 @@ impl GlobalState {\n             quiescent: self.is_quiescent(),\n             message: None,\n         };\n+        let mut message = String::new();\n \n         if self.proc_macro_changed {\n             status.health = lsp_ext::Health::Warning;\n-            status.message =\n-                Some(\"Reload required due to source changes of a procedural macro.\".into())\n+            message.push_str(\"Reload required due to source changes of a procedural macro.\\n\\n\");\n         }\n         if let Err(_) = self.fetch_build_data_error() {\n             status.health = lsp_ext::Health::Warning;\n-            status.message =\n-                Some(\"Failed to run build scripts of some packages, check the logs.\".to_string());\n+            message.push_str(\"Failed to run build scripts of some packages.\\n\\n\");\n         }\n         if !self.config.cargo_autoreload()\n             && self.is_quiescent()\n             && self.fetch_workspaces_queue.op_requested()\n         {\n             status.health = lsp_ext::Health::Warning;\n-            status.message = Some(\"Workspace reload required\".to_string())\n+            message.push_str(\"Auto-reloading is disabled and the workspace has changed, a manual workspace reload is required.\\n\\n\");\n         }\n-\n-        if let Err(_) = self.fetch_workspace_error() {\n-            status.health = lsp_ext::Health::Error;\n-            status.message = Some(\"Failed to load workspaces\".to_string())\n-        }\n-\n         if self.config.linked_projects().is_empty()\n             && self.config.detached_files().is_empty()\n             && self.config.notifications().cargo_toml_not_found\n         {\n             status.health = lsp_ext::Health::Warning;\n-            status.message = Some(\"Failed to discover workspace\".to_string())\n+            message.push_str(\"Failed to discover workspace.\\n\\n\");\n+        }\n+\n+        for ws in self.workspaces.iter() {\n+            let (ProjectWorkspace::Cargo { sysroot, .. }\n+            | ProjectWorkspace::Json { sysroot, .. }\n+            | ProjectWorkspace::DetachedFiles { sysroot, .. }) = ws;\n+            if let Err(Some(e)) = sysroot {\n+                status.health = lsp_ext::Health::Warning;\n+                message.push_str(e);\n+                message.push_str(\"\\n\\n\");\n+            }\n+            if let ProjectWorkspace::Cargo { rustc: Err(Some(e)), .. } = ws {\n+                status.health = lsp_ext::Health::Warning;\n+                message.push_str(e);\n+                message.push_str(\"\\n\\n\");\n+            }\n         }\n \n+        if let Err(_) = self.fetch_workspace_error() {\n+            status.health = lsp_ext::Health::Error;\n+            message.push_str(\"Failed to load workspaces.\\n\\n\");\n+        }\n+\n+        if !message.is_empty() {\n+            status.message = Some(message.trim_end().to_owned());\n+        }\n         status\n     }\n "}, {"sha": "c43d0830b9e24864ff3148879cab369d6dadc968", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -48,23 +48,30 @@ impl From<ast::IfExpr> for ElseBranch {\n }\n \n impl ast::IfExpr {\n-    pub fn then_branch(&self) -> Option<ast::BlockExpr> {\n-        self.children_after_condition().next()\n+    pub fn condition(&self) -> Option<ast::Expr> {\n+        // If the condition is a BlockExpr, check if the then body is missing.\n+        // If it is assume the condition is the expression that is missing instead.\n+        let mut exprs = support::children(self.syntax());\n+        let first = exprs.next();\n+        match first {\n+            Some(ast::Expr::BlockExpr(_)) => exprs.next().and(first),\n+            first => first,\n+        }\n     }\n \n-    pub fn else_branch(&self) -> Option<ElseBranch> {\n-        let res = match self.children_after_condition().nth(1) {\n-            Some(block) => ElseBranch::Block(block),\n-            None => {\n-                let elif = self.children_after_condition().next()?;\n-                ElseBranch::IfExpr(elif)\n-            }\n-        };\n-        Some(res)\n+    pub fn then_branch(&self) -> Option<ast::BlockExpr> {\n+        match support::children(self.syntax()).nth(1)? {\n+            ast::Expr::BlockExpr(block) => Some(block),\n+            _ => None,\n+        }\n     }\n \n-    fn children_after_condition<N: AstNode>(&self) -> impl Iterator<Item = N> {\n-        self.syntax().children().skip(1).filter_map(N::cast)\n+    pub fn else_branch(&self) -> Option<ElseBranch> {\n+        match support::children(self.syntax()).nth(2)? {\n+            ast::Expr::BlockExpr(block) => Some(ElseBranch::Block(block)),\n+            ast::Expr::IfExpr(elif) => Some(ElseBranch::IfExpr(elif)),\n+            _ => None,\n+        }\n     }\n }\n \n@@ -356,7 +363,15 @@ impl ast::BlockExpr {\n             Some(it) => it,\n             None => return true,\n         };\n-        !matches!(parent.kind(), FN | IF_EXPR | WHILE_EXPR | LOOP_EXPR)\n+        match parent.kind() {\n+            FOR_EXPR | IF_EXPR => parent\n+                .children()\n+                .filter(|it| ast::Expr::can_cast(it.kind()))\n+                .next()\n+                .map_or(true, |it| it == *self.syntax()),\n+            LET_ELSE | FN | WHILE_EXPR | LOOP_EXPR | CONST_BLOCK_PAT => false,\n+            _ => true,\n+        }\n     }\n }\n "}, {"sha": "3308077da5b12457a7f129cac2b5ad56d73d675e", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -937,12 +937,6 @@ impl From<ast::Adt> for ast::Item {\n     }\n }\n \n-impl ast::IfExpr {\n-    pub fn condition(&self) -> Option<ast::Expr> {\n-        support::child(&self.syntax)\n-    }\n-}\n-\n impl ast::MatchGuard {\n     pub fn condition(&self) -> Option<ast::Expr> {\n         support::child(&self.syntax)"}, {"sha": "ca6de4061a4b8d24c8ced00e423c72e9e9d511f2", "filename": "src/tools/rust-analyzer/crates/test-utils/src/minicore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -44,6 +44,8 @@\n //!     try: infallible\n //!     unsize: sized\n \n+#![rustc_coherence_is_core]\n+\n pub mod marker {\n     // region:sized\n     #[lang = \"sized\"]"}, {"sha": "c5eb08748bfab5176592a9f4c4bfccf1c60ddbc6", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -199,6 +199,11 @@\n                 \"title\": \"Reload workspace\",\n                 \"category\": \"rust-analyzer\"\n             },\n+            {\n+                \"command\": \"rust-analyzer.addProject\",\n+                \"title\": \"Add current file's crate to workspace\",\n+                \"category\": \"rust-analyzer\"\n+            },\n             {\n                 \"command\": \"rust-analyzer.reload\",\n                 \"title\": \"Restart server\",\n@@ -428,6 +433,17 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.discoverProjectCommand\": {\n+                    \"markdownDescription\": \"Sets the command that rust-analyzer uses to generate `rust-project.json` files. This command should only be used\\n if a build system like Buck or Bazel is also in use. The command must accept files as arguments and return \\n a rust-project.json over stdout.\",\n+                    \"default\": null,\n+                    \"type\": [\n+                        \"null\",\n+                        \"array\"\n+                    ],\n+                    \"items\": {\n+                        \"type\": \"string\"\n+                    }\n+                },\n                 \"$generated-start\": {},\n                 \"rust-analyzer.assist.emitMustUse\": {\n                     \"markdownDescription\": \"Whether to insert #[must_use] when generating `as_` methods\\nfor enum variants.\","}, {"sha": "565cb9c6432f426aca5c7319e227001b141bda52", "filename": "src/tools/rust-analyzer/editors/code/src/client.ts", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -6,7 +6,7 @@ import * as Is from \"vscode-languageclient/lib/common/utils/is\";\n import { assert } from \"./util\";\n import * as diagnostics from \"./diagnostics\";\n import { WorkspaceEdit } from \"vscode\";\n-import { Config, substituteVSCodeVariables } from \"./config\";\n+import { Config, prepareVSCodeConfig } from \"./config\";\n import { randomUUID } from \"crypto\";\n \n export interface Env {\n@@ -95,7 +95,16 @@ export async function createClient(\n                     const resp = await next(params, token);\n                     if (resp && Array.isArray(resp)) {\n                         return resp.map((val) => {\n-                            return substituteVSCodeVariables(val);\n+                            return prepareVSCodeConfig(val, (key, cfg) => {\n+                                // we only want to set discovered workspaces on the right key\n+                                // and if a workspace has been discovered.\n+                                if (\n+                                    key === \"linkedProjects\" &&\n+                                    config.discoveredWorkspaces.length > 0\n+                                ) {\n+                                    cfg[key] = config.discoveredWorkspaces;\n+                                }\n+                            });\n                         });\n                     } else {\n                         return resp;"}, {"sha": "8a953577e99d368d8ead2bf5f03714a3447d6f93", "filename": "src/tools/rust-analyzer/editors/code/src/commands.ts", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -3,7 +3,7 @@ import * as lc from \"vscode-languageclient\";\n import * as ra from \"./lsp_ext\";\n import * as path from \"path\";\n \n-import { Ctx, Cmd, CtxInit } from \"./ctx\";\n+import { Ctx, Cmd, CtxInit, discoverWorkspace } from \"./ctx\";\n import { applySnippetWorkspaceEdit, applySnippetTextEdits } from \"./snippets\";\n import { spawnSync } from \"child_process\";\n import { RunnableQuickPick, selectRunnable, createTask, createArgs } from \"./run\";\n@@ -749,6 +749,33 @@ export function reloadWorkspace(ctx: CtxInit): Cmd {\n     return async () => ctx.client.sendRequest(ra.reloadWorkspace);\n }\n \n+export function addProject(ctx: CtxInit): Cmd {\n+    return async () => {\n+        const discoverProjectCommand = ctx.config.discoverProjectCommand;\n+        if (!discoverProjectCommand) {\n+            return;\n+        }\n+\n+        const workspaces: JsonProject[] = await Promise.all(\n+            vscode.workspace.workspaceFolders!.map(async (folder): Promise<JsonProject> => {\n+                const rustDocuments = vscode.workspace.textDocuments.filter(isRustDocument);\n+                return discoverWorkspace(rustDocuments, discoverProjectCommand, {\n+                    cwd: folder.uri.fsPath,\n+                });\n+            })\n+        );\n+\n+        ctx.addToDiscoveredWorkspaces(workspaces);\n+\n+        // this is a workaround to avoid needing writing the `rust-project.json` into\n+        // a workspace-level VS Code-specific settings folder. We'd like to keep the\n+        // `rust-project.json` entirely in-memory.\n+        await ctx.client?.sendNotification(lc.DidChangeConfigurationNotification.type, {\n+            settings: \"\",\n+        });\n+    };\n+}\n+\n async function showReferencesImpl(\n     client: LanguageClient | undefined,\n     uri: string,"}, {"sha": "da7c74c28bae901a8a3dcb3cb0924da57a53ec5b", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -34,6 +34,7 @@ export class Config {\n \n     constructor(ctx: vscode.ExtensionContext) {\n         this.globalStorageUri = ctx.globalStorageUri;\n+        this.discoveredWorkspaces = [];\n         vscode.workspace.onDidChangeConfiguration(\n             this.onDidChangeConfiguration,\n             this,\n@@ -55,6 +56,8 @@ export class Config {\n         log.info(\"Using configuration\", Object.fromEntries(cfg));\n     }\n \n+    public discoveredWorkspaces: JsonProject[];\n+\n     private async onDidChangeConfiguration(event: vscode.ConfigurationChangeEvent) {\n         this.refreshLogging();\n \n@@ -191,7 +194,7 @@ export class Config {\n      * So this getter handles this quirk by not requiring the caller to use postfix `!`\n      */\n     private get<T>(path: string): T | undefined {\n-        return substituteVSCodeVariables(this.cfg.get<T>(path));\n+        return prepareVSCodeConfig(this.cfg.get<T>(path));\n     }\n \n     get serverPath() {\n@@ -214,6 +217,10 @@ export class Config {\n         return this.get<boolean>(\"trace.extension\");\n     }\n \n+    get discoverProjectCommand() {\n+        return this.get<string[] | undefined>(\"discoverProjectCommand\");\n+    }\n+\n     get cargoRunner() {\n         return this.get<string | undefined>(\"cargoRunner\");\n     }\n@@ -280,18 +287,32 @@ export class Config {\n     }\n }\n \n-export function substituteVSCodeVariables<T>(resp: T): T {\n+// the optional `cb?` parameter is meant to be used to add additional\n+// key/value pairs to the VS Code configuration. This needed for, e.g.,\n+// including a `rust-project.json` into the `linkedProjects` key as part\n+// of the configuration/InitializationParams _without_ causing VS Code\n+// configuration to be written out to workspace-level settings. This is\n+// undesirable behavior because rust-project.json files can be tens of\n+// thousands of lines of JSON, most of which is not meant for humans\n+// to interact with.\n+export function prepareVSCodeConfig<T>(\n+    resp: T,\n+    cb?: (key: Extract<keyof T, string>, res: { [key: string]: any }) => void\n+): T {\n     if (Is.string(resp)) {\n         return substituteVSCodeVariableInString(resp) as T;\n     } else if (resp && Is.array<any>(resp)) {\n         return resp.map((val) => {\n-            return substituteVSCodeVariables(val);\n+            return prepareVSCodeConfig(val);\n         }) as T;\n     } else if (resp && typeof resp === \"object\") {\n         const res: { [key: string]: any } = {};\n         for (const key in resp) {\n             const val = resp[key];\n-            res[key] = substituteVSCodeVariables(val);\n+            res[key] = prepareVSCodeConfig(val);\n+            if (cb) {\n+                cb(key, res);\n+            }\n         }\n         return res as T;\n     }"}, {"sha": "c2dca733df8f53aeb2d457cfaf15b9973b9990ab", "filename": "src/tools/rust-analyzer/editors/code/src/ctx.ts", "status": "modified", "additions": 63, "deletions": 6, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -2,12 +2,20 @@ import * as vscode from \"vscode\";\n import * as lc from \"vscode-languageclient/node\";\n import * as ra from \"./lsp_ext\";\n \n-import { Config, substituteVSCodeVariables } from \"./config\";\n+import { Config, prepareVSCodeConfig } from \"./config\";\n import { createClient } from \"./client\";\n-import { isRustDocument, isRustEditor, LazyOutputChannel, log, RustEditor } from \"./util\";\n+import {\n+    executeDiscoverProject,\n+    isRustDocument,\n+    isRustEditor,\n+    LazyOutputChannel,\n+    log,\n+    RustEditor,\n+} from \"./util\";\n import { ServerStatusParams } from \"./lsp_ext\";\n import { PersistentState } from \"./persistent_state\";\n import { bootstrap } from \"./bootstrap\";\n+import { ExecOptions } from \"child_process\";\n \n // We only support local folders, not eg. Live Share (`vlsl:` scheme), so don't activate if\n // only those are in use. We use \"Empty\" to represent these scenarios\n@@ -41,6 +49,17 @@ export function fetchWorkspace(): Workspace {\n         : { kind: \"Workspace Folder\" };\n }\n \n+export async function discoverWorkspace(\n+    files: readonly vscode.TextDocument[],\n+    command: string[],\n+    options: ExecOptions\n+): Promise<JsonProject> {\n+    const paths = files.map((f) => `\"${f.uri.fsPath}\"`).join(\" \");\n+    const joinedCommand = command.join(\" \");\n+    const data = await executeDiscoverProject(`${joinedCommand} ${paths}`, options);\n+    return JSON.parse(data) as JsonProject;\n+}\n+\n export type CommandFactory = {\n     enabled: (ctx: CtxInit) => Cmd;\n     disabled?: (ctx: Ctx) => Cmd;\n@@ -52,7 +71,7 @@ export type CtxInit = Ctx & {\n \n export class Ctx {\n     readonly statusBar: vscode.StatusBarItem;\n-    readonly config: Config;\n+    config: Config;\n     readonly workspace: Workspace;\n \n     private _client: lc.LanguageClient | undefined;\n@@ -169,7 +188,30 @@ export class Ctx {\n                 };\n             }\n \n-            const initializationOptions = substituteVSCodeVariables(rawInitializationOptions);\n+            const discoverProjectCommand = this.config.discoverProjectCommand;\n+            if (discoverProjectCommand) {\n+                const workspaces: JsonProject[] = await Promise.all(\n+                    vscode.workspace.workspaceFolders!.map(async (folder): Promise<JsonProject> => {\n+                        const rustDocuments = vscode.workspace.textDocuments.filter(isRustDocument);\n+                        return discoverWorkspace(rustDocuments, discoverProjectCommand, {\n+                            cwd: folder.uri.fsPath,\n+                        });\n+                    })\n+                );\n+\n+                this.addToDiscoveredWorkspaces(workspaces);\n+            }\n+\n+            const initializationOptions = prepareVSCodeConfig(\n+                rawInitializationOptions,\n+                (key, obj) => {\n+                    // we only want to set discovered workspaces on the right key\n+                    // and if a workspace has been discovered.\n+                    if (key === \"linkedProjects\" && this.config.discoveredWorkspaces.length > 0) {\n+                        obj[\"linkedProjects\"] = this.config.discoveredWorkspaces;\n+                    }\n+                }\n+            );\n \n             this._client = await createClient(\n                 this.traceOutputChannel,\n@@ -251,6 +293,17 @@ export class Ctx {\n         return this._serverPath;\n     }\n \n+    addToDiscoveredWorkspaces(workspaces: JsonProject[]) {\n+        for (const workspace of workspaces) {\n+            const index = this.config.discoveredWorkspaces.indexOf(workspace);\n+            if (~index) {\n+                this.config.discoveredWorkspaces[index] = workspace;\n+            } else {\n+                this.config.discoveredWorkspaces.push(workspace);\n+            }\n+        }\n+    }\n+\n     private updateCommands(forceDisable?: \"disable\") {\n         this.commandDisposables.forEach((disposable) => disposable.dispose());\n         this.commandDisposables = [];\n@@ -289,6 +342,7 @@ export class Ctx {\n                 statusBar.tooltip.appendText(status.message ?? \"Ready\");\n                 statusBar.color = undefined;\n                 statusBar.backgroundColor = undefined;\n+                statusBar.command = \"rust-analyzer.stopServer\";\n                 break;\n             case \"warning\":\n                 if (status.message) {\n@@ -298,6 +352,7 @@ export class Ctx {\n                 statusBar.backgroundColor = new vscode.ThemeColor(\n                     \"statusBarItem.warningBackground\"\n                 );\n+                statusBar.command = \"rust-analyzer.openLogs\";\n                 icon = \"$(warning) \";\n                 break;\n             case \"error\":\n@@ -306,6 +361,7 @@ export class Ctx {\n                 }\n                 statusBar.color = new vscode.ThemeColor(\"statusBarItem.errorForeground\");\n                 statusBar.backgroundColor = new vscode.ThemeColor(\"statusBarItem.errorBackground\");\n+                statusBar.command = \"rust-analyzer.openLogs\";\n                 icon = \"$(error) \";\n                 break;\n             case \"stopped\":\n@@ -315,18 +371,19 @@ export class Ctx {\n                 );\n                 statusBar.color = undefined;\n                 statusBar.backgroundColor = undefined;\n+                statusBar.command = \"rust-analyzer.startServer\";\n                 statusBar.text = `$(stop-circle) rust-analyzer`;\n                 return;\n         }\n         if (statusBar.tooltip.value) {\n             statusBar.tooltip.appendText(\"\\n\\n\");\n         }\n-        statusBar.tooltip.appendMarkdown(\"[Stop server](command:rust-analyzer.stopServer)\");\n         statusBar.tooltip.appendMarkdown(\n             \"\\n\\n[Reload Workspace](command:rust-analyzer.reloadWorkspace)\"\n         );\n-        statusBar.tooltip.appendMarkdown(\"\\n\\n[Restart server](command:rust-analyzer.startServer)\");\n         statusBar.tooltip.appendMarkdown(\"\\n\\n[Open logs](command:rust-analyzer.openLogs)\");\n+        statusBar.tooltip.appendMarkdown(\"\\n\\n[Restart server](command:rust-analyzer.startServer)\");\n+        statusBar.tooltip.appendMarkdown(\"[Stop server](command:rust-analyzer.stopServer)\");\n         if (!status.quiescent) icon = \"$(sync~spin) \";\n         statusBar.text = `${icon}rust-analyzer`;\n     }"}, {"sha": "872d7199b838a9926ee529a329f650d6938ba6f0", "filename": "src/tools/rust-analyzer/editors/code/src/lsp_ext.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -43,6 +43,7 @@ export const relatedTests = new lc.RequestType<lc.TextDocumentPositionParams, Te\n     \"rust-analyzer/relatedTests\"\n );\n export const reloadWorkspace = new lc.RequestType0<null, void>(\"rust-analyzer/reloadWorkspace\");\n+\n export const runFlycheck = new lc.NotificationType<{\n     textDocument: lc.TextDocumentIdentifier | null;\n }>(\"rust-analyzer/runFlycheck\");"}, {"sha": "d5de00561b1235f4e8c9071a15e33d53a763a017", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -153,6 +153,7 @@ function createCommands(): Record<string, CommandFactory> {\n         memoryUsage: { enabled: commands.memoryUsage },\n         shuffleCrateGraph: { enabled: commands.shuffleCrateGraph },\n         reloadWorkspace: { enabled: commands.reloadWorkspace },\n+        addProject: { enabled: commands.addProject },\n         matchingBrace: { enabled: commands.matchingBrace },\n         joinLines: { enabled: commands.joinLines },\n         parentModule: { enabled: commands.parentModule },"}, {"sha": "187a1a96c10c5c39874b0be3bc6bdf74b48d2d8d", "filename": "src/tools/rust-analyzer/editors/code/src/rust_project.ts", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frust_project.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frust_project.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frust_project.ts?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -0,0 +1,91 @@\n+interface JsonProject {\n+    /// Path to the directory with *source code* of\n+    /// sysroot crates.\n+    ///\n+    /// It should point to the directory where std,\n+    /// core, and friends can be found:\n+    ///\n+    /// https://github.com/rust-lang/rust/tree/master/library.\n+    ///\n+    /// If provided, rust-analyzer automatically adds\n+    /// dependencies on sysroot crates. Conversely,\n+    /// if you omit this path, you can specify sysroot\n+    /// dependencies yourself and, for example, have\n+    /// several different \"sysroots\" in one graph of\n+    /// crates.\n+    sysroot_src?: string;\n+    /// The set of crates comprising the current\n+    /// project. Must include all transitive\n+    /// dependencies as well as sysroot crate (libstd,\n+    /// libcore and such).\n+    crates: Crate[];\n+}\n+\n+interface Crate {\n+    /// Optional crate name used for display purposes,\n+    /// without affecting semantics. See the `deps`\n+    /// key for semantically-significant crate names.\n+    display_name?: string;\n+    /// Path to the root module of the crate.\n+    root_module: string;\n+    /// Edition of the crate.\n+    edition: \"2015\" | \"2018\" | \"2021\";\n+    /// Dependencies\n+    deps: Dep[];\n+    /// Should this crate be treated as a member of\n+    /// current \"workspace\".\n+    ///\n+    /// By default, inferred from the `root_module`\n+    /// (members are the crates which reside inside\n+    /// the directory opened in the editor).\n+    ///\n+    /// Set this to `false` for things like standard\n+    /// library and 3rd party crates to enable\n+    /// performance optimizations (rust-analyzer\n+    /// assumes that non-member crates don't change).\n+    is_workspace_member?: boolean;\n+    /// Optionally specify the (super)set of `.rs`\n+    /// files comprising this crate.\n+    ///\n+    /// By default, rust-analyzer assumes that only\n+    /// files under `root_module.parent` can belong\n+    /// to a crate. `include_dirs` are included\n+    /// recursively, unless a subdirectory is in\n+    /// `exclude_dirs`.\n+    ///\n+    /// Different crates can share the same `source`.\n+    ///\n+    /// If two crates share an `.rs` file in common,\n+    /// they *must* have the same `source`.\n+    /// rust-analyzer assumes that files from one\n+    /// source can't refer to files in another source.\n+    source?: {\n+        include_dirs: string[];\n+        exclude_dirs: string[];\n+    };\n+    /// The set of cfgs activated for a given crate, like\n+    /// `[\"unix\", \"feature=\\\"foo\\\"\", \"feature=\\\"bar\\\"\"]`.\n+    cfg: string[];\n+    /// Target triple for this Crate.\n+    ///\n+    /// Used when running `rustc --print cfg`\n+    /// to get target-specific cfgs.\n+    target?: string;\n+    /// Environment variables, used for\n+    /// the `env!` macro\n+    env: { [key: string]: string };\n+\n+    /// Whether the crate is a proc-macro crate.\n+    is_proc_macro: boolean;\n+    /// For proc-macro crates, path to compiled\n+    /// proc-macro (.so file).\n+    proc_macro_dylib_path?: string;\n+}\n+\n+interface Dep {\n+    /// Index of a crate in the `crates` array.\n+    crate: number;\n+    /// Name as should appear in the (implicit)\n+    /// `extern crate name` declaration.\n+    name: string;\n+}"}, {"sha": "922fbcbcf35a5037ca624c9c72f34cf59de238e0", "filename": "src/tools/rust-analyzer/editors/code/src/util.ts", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Futil.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0f499b414ab483a39651d393d7d4567eb2cbf6be/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Futil.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Futil.ts?ref=0f499b414ab483a39651d393d7d4567eb2cbf6be", "patch": "@@ -150,9 +150,11 @@ export function memoizeAsync<Ret, TThis, Param extends string>(\n \n /** Awaitable wrapper around `child_process.exec` */\n export function execute(command: string, options: ExecOptions): Promise<string> {\n+    log.info(`running command: ${command}`);\n     return new Promise((resolve, reject) => {\n         exec(command, options, (err, stdout, stderr) => {\n             if (err) {\n+                log.error(err);\n                 reject(err);\n                 return;\n             }\n@@ -167,6 +169,21 @@ export function execute(command: string, options: ExecOptions): Promise<string>\n     });\n }\n \n+export function executeDiscoverProject(command: string, options: ExecOptions): Promise<string> {\n+    log.info(`running command: ${command}`);\n+    return new Promise((resolve, reject) => {\n+        exec(command, options, (err, stdout, _) => {\n+            if (err) {\n+                log.error(err);\n+                reject(err);\n+                return;\n+            }\n+\n+            resolve(stdout.trimEnd());\n+        });\n+    });\n+}\n+\n export class LazyOutputChannel implements vscode.OutputChannel {\n     constructor(name: string) {\n         this.name = name;"}]}