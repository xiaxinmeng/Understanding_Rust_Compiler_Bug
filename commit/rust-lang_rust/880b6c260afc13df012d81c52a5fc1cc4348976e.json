{"sha": "880b6c260afc13df012d81c52a5fc1cc4348976e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MGI2YzI2MGFmYzEzZGYwMTJkODFjNTJhNWZjMWNjNDM0ODk3NmU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-02-11T13:38:52Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-02-19T23:54:58Z"}, "message": "fix a few remaining bugs - make check runs!", "tree": {"sha": "b656db7b0494a1bd28f2ba750086c5cea8c15fc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b656db7b0494a1bd28f2ba750086c5cea8c15fc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/880b6c260afc13df012d81c52a5fc1cc4348976e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/880b6c260afc13df012d81c52a5fc1cc4348976e", "html_url": "https://github.com/rust-lang/rust/commit/880b6c260afc13df012d81c52a5fc1cc4348976e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/880b6c260afc13df012d81c52a5fc1cc4348976e/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c6f41026bea2a99ab09d15f3dbed838af1ebcac", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c6f41026bea2a99ab09d15f3dbed838af1ebcac", "html_url": "https://github.com/rust-lang/rust/commit/3c6f41026bea2a99ab09d15f3dbed838af1ebcac"}], "stats": {"total": 237, "additions": 220, "deletions": 17}, "files": [{"sha": "b446dec96fbfb622882e9392fcfc0567fb39c212", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/880b6c260afc13df012d81c52a5fc1cc4348976e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880b6c260afc13df012d81c52a5fc1cc4348976e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=880b6c260afc13df012d81c52a5fc1cc4348976e", "patch": "@@ -844,6 +844,18 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"match checking\",\n              || middle::check_match::check_crate(tcx));\n \n+        // this must run before MIR dump, because\n+        // \"not all control paths return a value\" is reported here.\n+        //\n+        // maybe move the check to a MIR pass?\n+        time(time_passes,\n+             \"liveness checking\",\n+             || middle::liveness::check_crate(tcx));\n+\n+        time(time_passes,\n+             \"rvalue checking\",\n+             || rvalues::check_crate(tcx));\n+\n         let mut mir_map =\n             time(time_passes,\n                  \"MIR dump\",\n@@ -853,18 +865,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"MIR passes\",\n              || mir_map.run_passes(&mut sess.plugin_mir_passes.borrow_mut(), tcx));\n \n-        time(time_passes,\n-             \"liveness checking\",\n-             || middle::liveness::check_crate(tcx));\n-\n         time(time_passes,\n              \"borrow checking\",\n              || borrowck::check_crate(tcx));\n \n-        time(time_passes,\n-             \"rvalue checking\",\n-             || rvalues::check_crate(tcx));\n-\n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids\n         // a"}, {"sha": "ac1cff527fe91f68cf6976db76b5ed4e5a7034aa", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/880b6c260afc13df012d81c52a5fc1cc4348976e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880b6c260afc13df012d81c52a5fc1cc4348976e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=880b6c260afc13df012d81c52a5fc1cc4348976e", "patch": "@@ -32,6 +32,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let expr_ty = cx.tcx.expr_ty(self); // note: no adjustments (yet)!\n+        let temp_lifetime = cx.tcx.region_maps.temporary_scope(self.id);\n+        let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n \n         let kind = match self.node {\n             // Here comes the interesting stuff:\n@@ -72,7 +74,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n                     let tupled_args = Expr {\n                         ty: sig.inputs[1],\n-                        temp_lifetime: cx.tcx.region_maps.temporary_scope(self.id),\n+                        temp_lifetime: temp_lifetime,\n                         span: self.span,\n                         kind: ExprKind::Tuple {\n                             fields: args.iter().map(ToRef::to_ref).collect()\n@@ -146,11 +148,20 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             }\n \n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                let op = bin_op(op.node);\n-                ExprKind::AssignOp {\n-                    op: op,\n-                    lhs: lhs.to_ref(),\n-                    rhs: rhs.to_ref(),\n+                if cx.tcx.is_method_call(self.id) {\n+                    let pass_args = if hir_util::is_by_value_binop(op.node) {\n+                        PassArgs::ByValue\n+                    } else {\n+                        PassArgs::ByRef\n+                    };\n+                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n+                                        pass_args, lhs.to_ref(), vec![rhs])\n+                } else {\n+                    ExprKind::AssignOp {\n+                        op: bin_op(op.node),\n+                        lhs: lhs.to_ref(),\n+                        rhs: rhs.to_ref(),\n+                    }\n                 }\n             }\n \n@@ -416,9 +427,6 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 ExprKind::Tuple { fields: fields.to_ref() },\n         };\n \n-        let temp_lifetime = cx.tcx.region_maps.temporary_scope(self.id);\n-        let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n-\n         let mut expr = Expr {\n             temp_lifetime: temp_lifetime,\n             ty: expr_ty,"}, {"sha": "b2c7478ead5fe877b177fb5d40242e24244ef996", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/880b6c260afc13df012d81c52a5fc1cc4348976e/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880b6c260afc13df012d81c52a5fc1cc4348976e/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=880b6c260afc13df012d81c52a5fc1cc4348976e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n //! This pass type-checks the MIR to ensure it is not broken.\n+#![allow(unreachable_code)]\n \n use rustc::middle::infer;\n use rustc::middle::ty::{self, Ty};\n@@ -322,6 +323,13 @@ impl<'a, 'tcx> MirPass for TypeckMir<'a, 'tcx> {\n                          _tcx: &ty::ctxt<'tcx_>) {\n         // FIXME: pass param_env to run_on_mir\n         let mir: &mut Mir<'tcx> = unsafe { ::std::mem::transmute(mir) };\n+\n+        if self.tcx().sess.err_count() > 0 {\n+            // compiling a broken program can obviously result in a\n+            // broken MIR, so try not to report duplicate errors.\n+            return;\n+        }\n+\n         let mut type_verifier = TypeVerifier::new(self.infcx, mir);\n         type_verifier.visit_mir(mir);\n "}, {"sha": "cadfce367a4260293f0e54998aeb944f89e8b995", "filename": "src/test/run-pass/mir_augmented_assignments.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/880b6c260afc13df012d81c52a5fc1cc4348976e/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880b6c260afc13df012d81c52a5fc1cc4348976e/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs?ref=880b6c260afc13df012d81c52a5fc1cc4348976e", "patch": "@@ -0,0 +1,183 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(augmented_assignments)]\n+#![feature(op_assign_traits)]\n+#![feature(rustc_attrs)]\n+\n+use std::mem;\n+use std::ops::{\n+    AddAssign, BitAndAssign, BitOrAssign, BitXorAssign, DivAssign, MulAssign, RemAssign,\n+    ShlAssign, ShrAssign, SubAssign,\n+};\n+\n+#[derive(Debug, PartialEq)]\n+struct Int(i32);\n+\n+struct Slice([i32]);\n+\n+impl Slice {\n+    fn new(slice: &mut [i32]) -> &mut Slice {\n+        unsafe {\n+            mem::transmute(slice)\n+        }\n+    }\n+}\n+\n+fn main() {\n+    main_mir();\n+}\n+\n+#[rustc_mir]\n+fn main_mir() {\n+    let mut x = Int(1);\n+\n+    x += Int(2);\n+    assert_eq!(x, Int(0b11));\n+\n+    x &= Int(0b01);\n+    assert_eq!(x, Int(0b01));\n+\n+    x |= Int(0b10);\n+    assert_eq!(x, Int(0b11));\n+\n+    x ^= Int(0b01);\n+    assert_eq!(x, Int(0b10));\n+\n+    x /= Int(2);\n+    assert_eq!(x, Int(1));\n+\n+    x *= Int(3);\n+    assert_eq!(x, Int(3));\n+\n+    x %= Int(2);\n+    assert_eq!(x, Int(1));\n+\n+    // overloaded RHS\n+    x <<= 1u8;\n+    assert_eq!(x, Int(2));\n+\n+    x <<= 1u16;\n+    assert_eq!(x, Int(4));\n+\n+    x >>= 1u8;\n+    assert_eq!(x, Int(2));\n+\n+    x >>= 1u16;\n+    assert_eq!(x, Int(1));\n+\n+    x -= Int(1);\n+    assert_eq!(x, Int(0));\n+\n+    // indexed LHS\n+    let mut v = vec![Int(1), Int(2)];\n+    v[0] += Int(2);\n+    assert_eq!(v[0], Int(3));\n+\n+    // unsized RHS\n+    let mut array = [0, 1, 2];\n+    *Slice::new(&mut array) += 1;\n+    assert_eq!(array[0], 1);\n+    assert_eq!(array[1], 2);\n+    assert_eq!(array[2], 3);\n+}\n+\n+impl AddAssign for Int {\n+    #[rustc_mir]\n+    fn add_assign(&mut self, rhs: Int) {\n+        self.0 += rhs.0;\n+    }\n+}\n+\n+impl BitAndAssign for Int {\n+    #[rustc_mir]\n+    fn bitand_assign(&mut self, rhs: Int) {\n+        self.0 &= rhs.0;\n+    }\n+}\n+\n+impl BitOrAssign for Int {\n+    #[rustc_mir]\n+    fn bitor_assign(&mut self, rhs: Int) {\n+        self.0 |= rhs.0;\n+    }\n+}\n+\n+impl BitXorAssign for Int {\n+    #[rustc_mir]\n+    fn bitxor_assign(&mut self, rhs: Int) {\n+        self.0 ^= rhs.0;\n+    }\n+}\n+\n+impl DivAssign for Int {\n+    #[rustc_mir]\n+    fn div_assign(&mut self, rhs: Int) {\n+        self.0 /= rhs.0;\n+    }\n+}\n+\n+impl MulAssign for Int {\n+    #[rustc_mir]\n+    fn mul_assign(&mut self, rhs: Int) {\n+        self.0 *= rhs.0;\n+    }\n+}\n+\n+impl RemAssign for Int {\n+    #[rustc_mir]\n+    fn rem_assign(&mut self, rhs: Int) {\n+        self.0 %= rhs.0;\n+    }\n+}\n+\n+impl ShlAssign<u8> for Int {\n+    #[rustc_mir]\n+    fn shl_assign(&mut self, rhs: u8) {\n+        self.0 <<= rhs;\n+    }\n+}\n+\n+impl ShlAssign<u16> for Int {\n+    #[rustc_mir]\n+    fn shl_assign(&mut self, rhs: u16) {\n+        self.0 <<= rhs;\n+    }\n+}\n+\n+impl ShrAssign<u8> for Int {\n+    #[rustc_mir]\n+    fn shr_assign(&mut self, rhs: u8) {\n+        self.0 >>= rhs;\n+    }\n+}\n+\n+impl ShrAssign<u16> for Int {\n+    #[rustc_mir]\n+    fn shr_assign(&mut self, rhs: u16) {\n+        self.0 >>= rhs;\n+    }\n+}\n+\n+impl SubAssign for Int {\n+    #[rustc_mir]\n+    fn sub_assign(&mut self, rhs: Int) {\n+        self.0 -= rhs.0;\n+    }\n+}\n+\n+impl AddAssign<i32> for Slice {\n+    #[rustc_mir]\n+    fn add_assign(&mut self, rhs: i32) {\n+        for lhs in &mut self.0 {\n+            *lhs += rhs;\n+        }\n+    }\n+}"}]}