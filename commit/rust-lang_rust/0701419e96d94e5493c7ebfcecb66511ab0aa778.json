{"sha": "0701419e96d94e5493c7ebfcecb66511ab0aa778", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MDE0MTllOTZkOTRlNTQ5M2M3ZWJmY2VjYjY2NTExYWIwYWE3Nzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-19T04:03:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-19T04:03:54Z"}, "message": "Auto merge of #74493 - Manishearth:rollup-ust7yr4, r=Manishearth\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #70817 (Add core::task::ready! macro)\n - #73762 (Document the trait keyword)\n - #74021 (impl Index<RangeFrom> for CStr)\n - #74071 (rustc_metadata: Make crate loading fully speculative)\n - #74445 (add test for #62878)\n - #74459 (Make unreachable_unchecked a const fn)\n - #74478 (Revert \"Use an UTF-8 locale for the linker.\")\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c8c859bd81bc547333c6f68d56990b9a859c4d20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8c859bd81bc547333c6f68d56990b9a859c4d20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0701419e96d94e5493c7ebfcecb66511ab0aa778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0701419e96d94e5493c7ebfcecb66511ab0aa778", "html_url": "https://github.com/rust-lang/rust/commit/0701419e96d94e5493c7ebfcecb66511ab0aa778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0701419e96d94e5493c7ebfcecb66511ab0aa778/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fa54ad9680cc82e7301f8ed4e9b7402dfd6ce0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa54ad9680cc82e7301f8ed4e9b7402dfd6ce0e", "html_url": "https://github.com/rust-lang/rust/commit/1fa54ad9680cc82e7301f8ed4e9b7402dfd6ce0e"}, {"sha": "a83e294f7778c3643005dc0567fe47767fab6508", "url": "https://api.github.com/repos/rust-lang/rust/commits/a83e294f7778c3643005dc0567fe47767fab6508", "html_url": "https://github.com/rust-lang/rust/commit/a83e294f7778c3643005dc0567fe47767fab6508"}], "stats": {"total": 1442, "additions": 892, "deletions": 550}, "files": [{"sha": "3116815f5d655a03461d6cfbc19f19a056aa78ec", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -45,7 +45,8 @@ use crate::intrinsics;\n /// ```\n #[inline]\n #[stable(feature = \"unreachable\", since = \"1.27.0\")]\n-pub unsafe fn unreachable_unchecked() -> ! {\n+#[rustc_const_unstable(feature = \"const_unreachable_unchecked\", issue = \"53188\")]\n+pub const unsafe fn unreachable_unchecked() -> ! {\n     // SAFETY: the safety contract for `intrinsics::unreachable` must\n     // be upheld by the caller.\n     unsafe { intrinsics::unreachable() }"}, {"sha": "8f0cf4361e708c87b6d9fee3ce184897a83e7e52", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -932,6 +932,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::hint::unreachable_unchecked`](../../std/hint/fn.unreachable_unchecked.html).\n+    #[rustc_const_unstable(feature = \"const_unreachable_unchecked\", issue = \"53188\")]\n     pub fn unreachable() -> !;\n \n     /// Informs the optimizer that a condition is always true."}, {"sha": "2e443064706d239117b7890ee3f74ff07daaa3bd", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -92,6 +92,7 @@\n #![feature(const_slice_ptr_len)]\n #![feature(const_type_name)]\n #![feature(const_likely)]\n+#![feature(const_unreachable_unchecked)]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]\n #![feature(doc_cfg)]"}, {"sha": "3d6f4f5971a62db2a88b3657a26008ade27732c4", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -9,3 +9,7 @@ pub use self::poll::Poll;\n mod wake;\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};\n+\n+mod ready;\n+#[unstable(feature = \"ready_macro\", issue = \"70922\")]\n+pub use ready::ready;"}, {"sha": "d4e733eb2bcf52668466933ba6555b92d77a29cb", "filename": "src/libcore/task/ready.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Ftask%2Fready.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibcore%2Ftask%2Fready.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fready.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -0,0 +1,60 @@\n+/// Extracts the successful type of a `Poll<T>`.\n+///\n+/// This macro bakes in propagation of `Pending` signals by returning early.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(future_readiness_fns)]\n+/// #![feature(ready_macro)]\n+///\n+/// use core::task::{ready, Context, Poll};\n+/// use core::future::{self, Future};\n+/// use core::pin::Pin;\n+///\n+/// pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n+///     let mut fut = future::ready(42);\n+///     let fut = Pin::new(&mut fut);\n+///\n+///     let num = ready!(fut.poll(cx));\n+///     # drop(num);\n+///     // ... use num\n+///\n+///     Poll::Ready(())\n+/// }\n+/// ```\n+///\n+/// The `ready!` call expands to:\n+///\n+/// ```\n+/// # #![feature(future_readiness_fns)]\n+/// # #![feature(ready_macro)]\n+/// #\n+/// # use core::task::{Context, Poll};\n+/// # use core::future::{self, Future};\n+/// # use core::pin::Pin;\n+/// #\n+/// # pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n+///     # let mut fut = future::ready(42);\n+///     # let fut = Pin::new(&mut fut);\n+///     #\n+/// let num = match fut.poll(cx) {\n+///     Poll::Ready(t) => t,\n+///     Poll::Pending => return Poll::Pending,\n+/// };\n+///     # drop(num);\n+///     # // ... use num\n+///     #\n+///     # Poll::Ready(())\n+/// # }\n+/// ```\n+#[unstable(feature = \"ready_macro\", issue = \"70922\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro ready($e:expr) {\n+    match $e {\n+        $crate::task::Poll::Ready(t) => t,\n+        $crate::task::Poll::Pending => {\n+            return $crate::task::Poll::Pending;\n+        }\n+    }\n+}"}, {"sha": "e64aafa599fd8ae39d63af34fbb8808cd810090e", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -28,9 +28,7 @@ use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n pub fn disable_localization(linker: &mut Command) {\n     // No harm in setting both env vars simultaneously.\n     // Unix-style linkers.\n-    // We use an UTF-8 locale, as the generic C locale disables support for non-ASCII\n-    // bytes in filenames on some platforms.\n-    linker.env(\"LC_ALL\", \"en_US.UTF-8\");\n+    linker.env(\"LC_ALL\", \"C\");\n     // MSVC's `link.exe`.\n     linker.env(\"VSLANG\", \"1033\");\n }"}, {"sha": "bbbd8359f0126b229ccf8f6f9bd79082a8819c2b", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -554,7 +554,7 @@ E0770: include_str!(\"./error_codes/E0770.md\"),\n //  E0420, merged into 532\n //  E0421, merged into 531\n //  E0427, merged into 530\n-    E0456, // plugin `..` is not available for triple `..`\n+//  E0456, // plugin `..` is not available for triple `..`\n     E0457, // plugin `..` only found in rlib format, but must be available...\n     E0460, // found possibly newer version of crate `..`\n     E0461, // couldn't find crate `..` with expected target triple .."}, {"sha": "0d2101cb2cb0821f5bec673e3580f00f6291f4b1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 78, "deletions": 105, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -1,22 +1,20 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::locator::{CrateLocator, CratePaths};\n+use crate::dynamic_lib::DynamicLibrary;\n+use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n use rustc_ast::expand::allocator::{global_allocator_spans, AllocatorKind};\n use rustc_ast::{ast, attr};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::struct_span_err;\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::cstore::DepKind;\n-use rustc_middle::middle::cstore::{\n-    CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn,\n-};\n+use rustc_middle::middle::cstore::{CrateSource, DepKind, ExternCrate};\n+use rustc_middle::middle::cstore::{ExternCrateSource, MetadataLoaderDyn};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, CrateType, ExternLocation};\n use rustc_session::lint;\n@@ -31,7 +29,7 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n use std::path::Path;\n-use std::{cmp, fs};\n+use std::{cmp, env, fs};\n \n #[derive(Clone)]\n pub struct CStore {\n@@ -69,18 +67,6 @@ enum LoadResult {\n     Loaded(Library),\n }\n \n-enum LoadError<'a> {\n-    LocatorError(CrateLocator<'a>),\n-}\n-\n-impl<'a> LoadError<'a> {\n-    fn report(self) -> ! {\n-        match self {\n-            LoadError::LocatorError(locator) => locator.report_errs(),\n-        }\n-    }\n-}\n-\n /// A reference to `CrateMetadata` that can also give access to whole crate store when necessary.\n #[derive(Clone, Copy)]\n crate struct CrateMetadataRef<'a> {\n@@ -280,60 +266,43 @@ impl<'a> CrateLoader<'a> {\n         ret\n     }\n \n-    fn verify_no_symbol_conflicts(&self, span: Span, root: &CrateRoot<'_>) {\n+    fn verify_no_symbol_conflicts(&self, root: &CrateRoot<'_>) -> Result<(), CrateError> {\n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == root.name()\n             && self.sess.local_crate_disambiguator() == root.disambiguator()\n         {\n-            struct_span_err!(\n-                self.sess,\n-                span,\n-                E0519,\n-                \"the current crate is indistinguishable from one of its \\\n-                         dependencies: it has the same crate-name `{}` and was \\\n-                         compiled with the same `-C metadata` arguments. This \\\n-                         will result in symbol conflicts between the two.\",\n-                root.name()\n-            )\n-            .emit()\n+            return Err(CrateError::SymbolConflictsCurrent(root.name()));\n         }\n \n         // Check for conflicts with any crate loaded so far\n+        let mut res = Ok(());\n         self.cstore.iter_crate_data(|_, other| {\n             if other.name() == root.name() && // same crate-name\n-               other.disambiguator() == root.disambiguator() &&  // same crate-disambiguator\n+               other.disambiguator() == root.disambiguator() && // same crate-disambiguator\n                other.hash() != root.hash()\n             {\n                 // but different SVH\n-                struct_span_err!(\n-                    self.sess,\n-                    span,\n-                    E0523,\n-                    \"found two different crates with name `{}` that are \\\n-                         not distinguished by differing `-C metadata`. This \\\n-                         will result in symbol conflicts between the two.\",\n-                    root.name()\n-                )\n-                .emit();\n+                res = Err(CrateError::SymbolConflictsOthers(root.name()));\n             }\n         });\n+\n+        res\n     }\n \n     fn register_crate(\n         &mut self,\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n-        span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n         name: Symbol,\n-    ) -> CrateNum {\n+    ) -> Result<CrateNum, CrateError> {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n         let Library { source, metadata } = lib;\n         let crate_root = metadata.get_root();\n         let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());\n-        self.verify_no_symbol_conflicts(span, &crate_root);\n+        self.verify_no_symbol_conflicts(&crate_root)?;\n \n         let private_dep =\n             self.sess.opts.externs.get(&name.as_str()).map(|e| e.is_private_dep).unwrap_or(false);\n@@ -353,7 +322,7 @@ impl<'a> CrateLoader<'a> {\n             &crate_paths\n         };\n \n-        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n+        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, dep_kind)?;\n \n         let raw_proc_macros = if crate_root.is_proc_macro_crate() {\n             let temp_root;\n@@ -365,7 +334,7 @@ impl<'a> CrateLoader<'a> {\n                 None => (&source, &crate_root),\n             };\n             let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n-            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator(), span))\n+            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator())?)\n         } else {\n             None\n         };\n@@ -386,14 +355,14 @@ impl<'a> CrateLoader<'a> {\n             ),\n         );\n \n-        cnum\n+        Ok(cnum)\n     }\n \n     fn load_proc_macro<'b>(\n         &self,\n         locator: &mut CrateLocator<'b>,\n         path_kind: PathKind,\n-    ) -> Option<(LoadResult, Option<Library>)>\n+    ) -> Result<Option<(LoadResult, Option<Library>)>, CrateError>\n     where\n         'a: 'b,\n     {\n@@ -408,8 +377,11 @@ impl<'a> CrateLoader<'a> {\n         let (locator, target_result) = if self.sess.opts.debugging_opts.dual_proc_macros {\n             proc_macro_locator.reset();\n             let result = match self.load(&mut proc_macro_locator)? {\n-                LoadResult::Previous(cnum) => return Some((LoadResult::Previous(cnum), None)),\n-                LoadResult::Loaded(library) => Some(LoadResult::Loaded(library)),\n+                Some(LoadResult::Previous(cnum)) => {\n+                    return Ok(Some((LoadResult::Previous(cnum), None)));\n+                }\n+                Some(LoadResult::Loaded(library)) => Some(LoadResult::Loaded(library)),\n+                None => return Ok(None),\n             };\n             locator.hash = locator.host_hash;\n             // Use the locator when looking for the host proc macro crate, as that is required\n@@ -427,9 +399,12 @@ impl<'a> CrateLoader<'a> {\n         locator.triple = TargetTriple::from_triple(config::host_triple());\n         locator.filesearch = self.sess.host_filesearch(path_kind);\n \n-        let host_result = self.load(locator)?;\n+        let host_result = match self.load(locator)? {\n+            Some(host_result) => host_result,\n+            None => return Ok(None),\n+        };\n \n-        Some(if self.sess.opts.debugging_opts.dual_proc_macros {\n+        Ok(Some(if self.sess.opts.debugging_opts.dual_proc_macros {\n             let host_result = match host_result {\n                 LoadResult::Previous(..) => {\n                     panic!(\"host and target proc macros must be loaded in lock-step\")\n@@ -439,7 +414,7 @@ impl<'a> CrateLoader<'a> {\n             (target_result.unwrap(), Some(host_result))\n         } else {\n             (host_result, None)\n-        })\n+        }))\n     }\n \n     fn resolve_crate<'b>(\n@@ -452,25 +427,20 @@ impl<'a> CrateLoader<'a> {\n         if dep.is_none() {\n             self.used_extern_options.insert(name);\n         }\n-        if !name.as_str().is_ascii() {\n-            self.sess\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"cannot load a crate with a non-ascii name `{}`\", name,),\n-                )\n-                .emit();\n-        }\n-        self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n+        self.maybe_resolve_crate(name, dep_kind, dep)\n+            .unwrap_or_else(|err| err.report(self.sess, span))\n     }\n \n     fn maybe_resolve_crate<'b>(\n         &'b mut self,\n         name: Symbol,\n-        span: Span,\n         mut dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> Result<CrateNum, LoadError<'b>> {\n+    ) -> Result<CrateNum, CrateError> {\n         info!(\"resolving crate `{}`\", name);\n+        if !name.as_str().is_ascii() {\n+            return Err(CrateError::NonAsciiName(name));\n+        }\n         let (root, hash, host_hash, extra_filename, path_kind) = match dep {\n             Some((root, dep)) => (\n                 Some(root),\n@@ -494,18 +464,20 @@ impl<'a> CrateLoader<'a> {\n                 extra_filename,\n                 false, // is_host\n                 path_kind,\n-                span,\n                 root,\n                 Some(false), // is_proc_macro\n             );\n \n-            self.load(&mut locator)\n-                .map(|r| (r, None))\n-                .or_else(|| {\n+            match self.load(&mut locator)? {\n+                Some(res) => (res, None),\n+                None => {\n                     dep_kind = DepKind::MacrosOnly;\n-                    self.load_proc_macro(&mut locator, path_kind)\n-                })\n-                .ok_or_else(move || LoadError::LocatorError(locator))?\n+                    match self.load_proc_macro(&mut locator, path_kind)? {\n+                        Some(res) => res,\n+                        None => return Err(locator.into_error()),\n+                    }\n+                }\n+            }\n         };\n \n         match result {\n@@ -518,14 +490,17 @@ impl<'a> CrateLoader<'a> {\n                 Ok(cnum)\n             }\n             (LoadResult::Loaded(library), host_library) => {\n-                Ok(self.register_crate(host_library, root, span, library, dep_kind, name))\n+                self.register_crate(host_library, root, library, dep_kind, name)\n             }\n             _ => panic!(),\n         }\n     }\n \n-    fn load(&self, locator: &mut CrateLocator<'_>) -> Option<LoadResult> {\n-        let library = locator.maybe_load_library_crate()?;\n+    fn load(&self, locator: &mut CrateLocator<'_>) -> Result<Option<LoadResult>, CrateError> {\n+        let library = match locator.maybe_load_library_crate()? {\n+            Some(library) => library,\n+            None => return Ok(None),\n+        };\n \n         // In the case that we're loading a crate, but not matching\n         // against a hash, we could load a crate which has the same hash\n@@ -536,7 +511,7 @@ impl<'a> CrateLoader<'a> {\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n         let root = library.metadata.get_root();\n-        if locator.triple == self.sess.opts.target_triple {\n+        Ok(Some(if locator.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n                 if data.name() == root.name() && root.hash() == data.hash() {\n@@ -545,10 +520,10 @@ impl<'a> CrateLoader<'a> {\n                     result = LoadResult::Previous(cnum);\n                 }\n             });\n-            Some(result)\n+            result\n         } else {\n-            Some(LoadResult::Loaded(library))\n-        }\n+            LoadResult::Loaded(library)\n+        }))\n     }\n \n     fn update_extern_crate(&self, cnum: CrateNum, extern_crate: ExternCrate) {\n@@ -569,53 +544,51 @@ impl<'a> CrateLoader<'a> {\n         crate_root: &CrateRoot<'_>,\n         metadata: &MetadataBlob,\n         krate: CrateNum,\n-        span: Span,\n         dep_kind: DepKind,\n-    ) -> CrateNumMap {\n+    ) -> Result<CrateNumMap, CrateError> {\n         debug!(\"resolving deps of external crate\");\n         if crate_root.is_proc_macro_crate() {\n-            return CrateNumMap::new();\n+            return Ok(CrateNumMap::new());\n         }\n \n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        std::iter::once(krate)\n-            .chain(crate_root.decode_crate_deps(metadata).map(|dep| {\n-                info!(\n-                    \"resolving dep crate {} hash: `{}` extra filename: `{}`\",\n-                    dep.name, dep.hash, dep.extra_filename\n-                );\n-                let dep_kind = match dep_kind {\n-                    DepKind::MacrosOnly => DepKind::MacrosOnly,\n-                    _ => dep.kind,\n-                };\n-                self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep)))\n-            }))\n-            .collect()\n+        let deps = crate_root.decode_crate_deps(metadata);\n+        let mut crate_num_map = CrateNumMap::with_capacity(1 + deps.len());\n+        crate_num_map.push(krate);\n+        for dep in deps {\n+            info!(\n+                \"resolving dep crate {} hash: `{}` extra filename: `{}`\",\n+                dep.name, dep.hash, dep.extra_filename\n+            );\n+            let dep_kind = match dep_kind {\n+                DepKind::MacrosOnly => DepKind::MacrosOnly,\n+                _ => dep.kind,\n+            };\n+            let cnum = self.maybe_resolve_crate(dep.name, dep_kind, Some((root, &dep)))?;\n+            crate_num_map.push(cnum);\n+        }\n+        Ok(crate_num_map)\n     }\n \n     fn dlsym_proc_macros(\n         &self,\n         path: &Path,\n         disambiguator: CrateDisambiguator,\n-        span: Span,\n-    ) -> &'static [ProcMacro] {\n-        use crate::dynamic_lib::DynamicLibrary;\n-        use std::env;\n-\n+    ) -> Result<&'static [ProcMacro], CrateError> {\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(&path) {\n             Ok(lib) => lib,\n-            Err(err) => self.sess.span_fatal(span, &err),\n+            Err(s) => return Err(CrateError::DlOpen(s)),\n         };\n \n         let sym = self.sess.generate_proc_macro_decls_symbol(disambiguator);\n         let decls = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n-                Err(err) => self.sess.span_fatal(span, &err),\n+                Err(s) => return Err(CrateError::DlSym(s)),\n             };\n             *(sym as *const &[ProcMacro])\n         };\n@@ -624,7 +597,7 @@ impl<'a> CrateLoader<'a> {\n         // since the library can make things that will live arbitrarily long.\n         std::mem::forget(lib);\n \n-        decls\n+        Ok(decls)\n     }\n \n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n@@ -952,7 +925,7 @@ impl<'a> CrateLoader<'a> {\n         cnum\n     }\n \n-    pub fn maybe_process_path_extern(&mut self, name: Symbol, span: Span) -> Option<CrateNum> {\n-        self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()\n+    pub fn maybe_process_path_extern(&mut self, name: Symbol) -> Option<CrateNum> {\n+        self.maybe_resolve_crate(name, DepKind::Explicit, None).ok()\n     }\n }"}, {"sha": "371ec4cd91148686345129677de65ed4b2735503", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 372, "deletions": 382, "changes": 754, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -216,9 +216,10 @@ use crate::creader::Library;\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder};\n+use rustc_errors::struct_span_err;\n use rustc_middle::middle::cstore::{CrateSource, MetadataLoader};\n use rustc_session::config::{self, CrateType};\n use rustc_session::filesearch::{FileDoesntMatch, FileMatches, FileSearch};\n@@ -228,25 +229,12 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::{Target, TargetTriple};\n \n-use std::cmp;\n-use std::fmt;\n-use std::fs;\n-use std::io::{self, Read};\n-use std::ops::Deref;\n-use std::path::{Path, PathBuf};\n-use std::time::Instant;\n-\n use flate2::read::DeflateDecoder;\n-\n-use rustc_data_structures::owning_ref::OwningRef;\n-\n use log::{debug, info, warn};\n-\n-#[derive(Clone)]\n-struct CrateMismatch {\n-    path: PathBuf,\n-    got: String,\n-}\n+use std::io::{Read, Result as IoResult, Write};\n+use std::ops::Deref;\n+use std::path::{Path, PathBuf};\n+use std::{cmp, fmt, fs};\n \n #[derive(Clone)]\n crate struct CrateLocator<'a> {\n@@ -263,7 +251,6 @@ crate struct CrateLocator<'a> {\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n-    span: Span,\n     root: Option<&'a CratePaths>,\n     pub is_proc_macro: Option<bool>,\n \n@@ -275,6 +262,7 @@ crate struct CrateLocator<'a> {\n     rejected_via_filename: Vec<CrateMismatch>,\n }\n \n+#[derive(Clone)]\n crate struct CratePaths {\n     name: Symbol,\n     source: CrateSource,\n@@ -287,7 +275,7 @@ impl CratePaths {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum CrateFlavor {\n+crate enum CrateFlavor {\n     Rlib,\n     Rmeta,\n     Dylib,\n@@ -313,7 +301,6 @@ impl<'a> CrateLocator<'a> {\n         extra_filename: Option<&'a str>,\n         is_host: bool,\n         path_kind: PathKind,\n-        span: Span,\n         root: Option<&'a CratePaths>,\n         is_proc_macro: Option<bool>,\n     ) -> CrateLocator<'a> {\n@@ -349,7 +336,6 @@ impl<'a> CrateLocator<'a> {\n             } else {\n                 sess.target_filesearch(path_kind)\n             },\n-            span,\n             root,\n             is_proc_macro,\n             rejected_via_hash: Vec::new(),\n@@ -368,166 +354,30 @@ impl<'a> CrateLocator<'a> {\n         self.rejected_via_filename.clear();\n     }\n \n-    crate fn maybe_load_library_crate(&mut self) -> Option<Library> {\n+    crate fn maybe_load_library_crate(&mut self) -> Result<Option<Library>, CrateError> {\n         if !self.exact_paths.is_empty() {\n             return self.find_commandline_library();\n         }\n         let mut seen_paths = FxHashSet::default();\n-        match self.extra_filename {\n-            Some(s) => self\n-                .find_library_crate(s, &mut seen_paths)\n-                .or_else(|| self.find_library_crate(\"\", &mut seen_paths)),\n-            None => self.find_library_crate(\"\", &mut seen_paths),\n-        }\n-    }\n-\n-    crate fn report_errs(self) -> ! {\n-        let add = match self.root {\n-            None => String::new(),\n-            Some(r) => format!(\" which `{}` depends on\", r.name),\n-        };\n-        let mut msg = \"the following crate versions were found:\".to_string();\n-        let mut err = if !self.rejected_via_hash.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0460,\n-                \"found possibly newer version of crate `{}`{}\",\n-                self.crate_name,\n-                add\n-            );\n-            err.note(\"perhaps that crate needs to be recompiled?\");\n-            let mismatches = self.rejected_via_hash.iter();\n-            for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n-            }\n-            match self.root {\n-                None => {}\n-                Some(r) => {\n-                    for path in r.source.paths() {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n-                    }\n-                }\n-            }\n-            err.note(&msg);\n-            err\n-        } else if !self.rejected_via_triple.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0461,\n-                \"couldn't find crate `{}` \\\n-                                            with expected target triple {}{}\",\n-                self.crate_name,\n-                self.triple,\n-                add\n-            );\n-            let mismatches = self.rejected_via_triple.iter();\n-            for &CrateMismatch { ref path, ref got } in mismatches {\n-                msg.push_str(&format!(\n-                    \"\\ncrate `{}`, target triple {}: {}\",\n-                    self.crate_name,\n-                    got,\n-                    path.display()\n-                ));\n-            }\n-            err.note(&msg);\n-            err\n-        } else if !self.rejected_via_kind.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0462,\n-                \"found staticlib `{}` instead of rlib or dylib{}\",\n-                self.crate_name,\n-                add\n-            );\n-            err.help(\"please recompile that crate using --crate-type lib\");\n-            let mismatches = self.rejected_via_kind.iter();\n-            for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n-            }\n-            err.note(&msg);\n-            err\n-        } else if !self.rejected_via_version.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0514,\n-                \"found crate `{}` compiled by an incompatible version \\\n-                                            of rustc{}\",\n-                self.crate_name,\n-                add\n-            );\n-            err.help(&format!(\n-                \"please recompile that crate using this compiler ({})\",\n-                rustc_version()\n-            ));\n-            let mismatches = self.rejected_via_version.iter();\n-            for &CrateMismatch { ref path, ref got } in mismatches {\n-                msg.push_str(&format!(\n-                    \"\\ncrate `{}` compiled by {}: {}\",\n-                    self.crate_name,\n-                    got,\n-                    path.display()\n-                ));\n-            }\n-            err.note(&msg);\n-            err\n-        } else {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0463,\n-                \"can't find crate for `{}`{}\",\n-                self.crate_name,\n-                add\n-            );\n-\n-            if (self.crate_name == sym::std || self.crate_name == sym::core)\n-                && self.triple != TargetTriple::from_triple(config::host_triple())\n-            {\n-                err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n-            } else if self.crate_name == sym::profiler_builtins {\n-                err.note(&\"the compiler may have been built without the profiler runtime\");\n-            }\n-            err.span_label(self.span, \"can't find crate\");\n-            err\n-        };\n-\n-        if !self.rejected_via_filename.is_empty() {\n-            let dylibname = self.dylibname();\n-            let mismatches = self.rejected_via_filename.iter();\n-            for &CrateMismatch { ref path, .. } in mismatches {\n-                err.note(&format!(\n-                    \"extern location for {} is of an unknown type: {}\",\n-                    self.crate_name,\n-                    path.display()\n-                ))\n-                .help(&format!(\n-                    \"file name should be lib*.rlib or {}*.{}\",\n-                    dylibname.0, dylibname.1\n-                ));\n+        if let Some(extra_filename) = self.extra_filename {\n+            if let library @ Some(_) = self.find_library_crate(extra_filename, &mut seen_paths)? {\n+                return Ok(library);\n             }\n         }\n-\n-        err.emit();\n-        self.sess.abort_if_errors();\n-        unreachable!();\n+        self.find_library_crate(\"\", &mut seen_paths)\n     }\n \n     fn find_library_crate(\n         &mut self,\n         extra_prefix: &str,\n         seen_paths: &mut FxHashSet<PathBuf>,\n-    ) -> Option<Library> {\n-        let dypair = self.dylibname();\n-        let staticpair = self.staticlibname();\n-\n+    ) -> Result<Option<Library>, CrateError> {\n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}{}\", dypair.0, self.crate_name, extra_prefix);\n+        let dylib_prefix =\n+            format!(\"{}{}{}\", self.target.options.dll_prefix, self.crate_name, extra_prefix);\n         let rlib_prefix = format!(\"lib{}{}\", self.crate_name, extra_prefix);\n-        let staticlib_prefix = format!(\"{}{}{}\", staticpair.0, self.crate_name, extra_prefix);\n+        let staticlib_prefix =\n+            format!(\"{}{}{}\", self.target.options.staticlib_prefix, self.crate_name, extra_prefix);\n \n         let mut candidates: FxHashMap<_, (FxHashMap<_, _>, FxHashMap<_, _>, FxHashMap<_, _>)> =\n             Default::default();\n@@ -555,10 +405,18 @@ impl<'a> CrateLocator<'a> {\n                 (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n             } else if file.starts_with(&rlib_prefix) && file.ends_with(\".rmeta\") {\n                 (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n-            } else if file.starts_with(&dylib_prefix) && file.ends_with(&dypair.1) {\n-                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n+            } else if file.starts_with(&dylib_prefix)\n+                && file.ends_with(&self.target.options.dll_suffix)\n+            {\n+                (\n+                    &file\n+                        [(dylib_prefix.len())..(file.len() - self.target.options.dll_suffix.len())],\n+                    CrateFlavor::Dylib,\n+                )\n             } else {\n-                if file.starts_with(&staticlib_prefix) && file.ends_with(&staticpair.1) {\n+                if file.starts_with(&staticlib_prefix)\n+                    && file.ends_with(&self.target.options.staticlib_suffix)\n+                {\n                     staticlibs\n                         .push(CrateMismatch { path: spf.path.clone(), got: \"static\".to_string() });\n                 }\n@@ -567,26 +425,18 @@ impl<'a> CrateLocator<'a> {\n \n             info!(\"lib candidate: {}\", spf.path.display());\n \n-            let hash_str = hash.to_string();\n-            let slot = candidates.entry(hash_str).or_default();\n-            let (ref mut rlibs, ref mut rmetas, ref mut dylibs) = *slot;\n+            let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n             fs::canonicalize(&spf.path)\n                 .map(|p| {\n                     if seen_paths.contains(&p) {\n                         return FileDoesntMatch;\n                     };\n                     seen_paths.insert(p.clone());\n                     match found_kind {\n-                        CrateFlavor::Rlib => {\n-                            rlibs.insert(p, kind);\n-                        }\n-                        CrateFlavor::Rmeta => {\n-                            rmetas.insert(p, kind);\n-                        }\n-                        CrateFlavor::Dylib => {\n-                            dylibs.insert(p, kind);\n-                        }\n-                    }\n+                        CrateFlavor::Rlib => rlibs.insert(p, kind),\n+                        CrateFlavor::Rmeta => rmetas.insert(p, kind),\n+                        CrateFlavor::Dylib => dylibs.insert(p, kind),\n+                    };\n                     FileMatches\n                 })\n                 .unwrap_or(FileDoesntMatch)\n@@ -603,7 +453,7 @@ impl<'a> CrateLocator<'a> {\n         // search is being performed for.\n         let mut libraries = FxHashMap::default();\n         for (_hash, (rlibs, rmetas, dylibs)) in candidates {\n-            if let Some((svh, lib)) = self.extract_lib(rlibs, rmetas, dylibs) {\n+            if let Some((svh, lib)) = self.extract_lib(rlibs, rmetas, dylibs)? {\n                 libraries.insert(svh, lib);\n             }\n         }\n@@ -612,39 +462,9 @@ impl<'a> CrateLocator<'a> {\n         // what we've got and figure out if we found multiple candidates for\n         // libraries or not.\n         match libraries.len() {\n-            0 => None,\n-            1 => Some(libraries.into_iter().next().unwrap().1),\n-            _ => {\n-                let mut err = struct_span_err!(\n-                    self.sess,\n-                    self.span,\n-                    E0464,\n-                    \"multiple matching crates for `{}`\",\n-                    self.crate_name\n-                );\n-                let candidates = libraries\n-                    .iter()\n-                    .filter_map(|(_, lib)| {\n-                        let crate_name = &lib.metadata.get_root().name().as_str();\n-                        match &(&lib.source.dylib, &lib.source.rlib) {\n-                            &(&Some((ref pd, _)), &Some((ref pr, _))) => Some(format!(\n-                                \"\\ncrate `{}`: {}\\n{:>padding$}\",\n-                                crate_name,\n-                                pd.display(),\n-                                pr.display(),\n-                                padding = 8 + crate_name.len()\n-                            )),\n-                            &(&Some((ref p, _)), &None) | &(&None, &Some((ref p, _))) => {\n-                                Some(format!(\"\\ncrate `{}`: {}\", crate_name, p.display()))\n-                            }\n-                            &(&None, &None) => None,\n-                        }\n-                    })\n-                    .collect::<String>();\n-                err.note(&format!(\"candidates:{}\", candidates));\n-                err.emit();\n-                None\n-            }\n+            0 => Ok(None),\n+            1 => Ok(Some(libraries.into_iter().next().unwrap().1)),\n+            _ => Err(CrateError::MultipleMatchingCrates(self.crate_name, libraries)),\n         }\n     }\n \n@@ -653,16 +473,16 @@ impl<'a> CrateLocator<'a> {\n         rlibs: FxHashMap<PathBuf, PathKind>,\n         rmetas: FxHashMap<PathBuf, PathKind>,\n         dylibs: FxHashMap<PathBuf, PathKind>,\n-    ) -> Option<(Svh, Library)> {\n+    ) -> Result<Option<(Svh, Library)>, CrateError> {\n         let mut slot = None;\n         // Order here matters, rmeta should come first. See comment in\n         // `extract_one` below.\n         let source = CrateSource {\n-            rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot),\n-            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot),\n-            dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot),\n+            rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot)?,\n+            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot)?,\n+            dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot)?,\n         };\n-        slot.map(|(svh, metadata)| (svh, Library { source, metadata }))\n+        Ok(slot.map(|(svh, metadata)| (svh, Library { source, metadata })))\n     }\n \n     fn needs_crate_flavor(&self, flavor: CrateFlavor) -> bool {\n@@ -698,10 +518,7 @@ impl<'a> CrateLocator<'a> {\n         m: FxHashMap<PathBuf, PathKind>,\n         flavor: CrateFlavor,\n         slot: &mut Option<(Svh, MetadataBlob)>,\n-    ) -> Option<(PathBuf, PathKind)> {\n-        let mut ret: Option<(PathBuf, PathKind)> = None;\n-        let mut error = 0;\n-\n+    ) -> Result<Option<(PathBuf, PathKind)>, CrateError> {\n         // If we are producing an rlib, and we've already loaded metadata, then\n         // we should not attempt to discover further crate sources (unless we're\n         // locating a proc macro; exact logic is in needs_crate_flavor). This means\n@@ -718,13 +535,14 @@ impl<'a> CrateLocator<'a> {\n         // from the other crate sources.\n         if slot.is_some() {\n             if m.is_empty() || !self.needs_crate_flavor(flavor) {\n-                return None;\n+                return Ok(None);\n             } else if m.len() == 1 {\n-                return Some(m.into_iter().next().unwrap());\n+                return Ok(Some(m.into_iter().next().unwrap()));\n             }\n         }\n \n-        let mut err: Option<DiagnosticBuilder<'_>> = None;\n+        let mut ret: Option<(PathBuf, PathKind)> = None;\n+        let mut err_data: Option<Vec<PathBuf>> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let (hash, metadata) =\n@@ -744,30 +562,18 @@ impl<'a> CrateLocator<'a> {\n                 };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n             if slot.as_ref().map_or(false, |s| s.0 != hash) {\n-                let mut e = struct_span_err!(\n-                    self.sess,\n-                    self.span,\n-                    E0465,\n-                    \"multiple {} candidates for `{}` found\",\n-                    flavor,\n-                    self.crate_name\n-                );\n-                e.span_note(\n-                    self.span,\n-                    &format!(r\"candidate #1: {}\", ret.as_ref().unwrap().0.display()),\n-                );\n-                if let Some(ref mut e) = err {\n-                    e.emit();\n+                if let Some(candidates) = err_data {\n+                    return Err(CrateError::MultipleCandidates(\n+                        self.crate_name,\n+                        flavor,\n+                        candidates,\n+                    ));\n                 }\n-                err = Some(e);\n-                error = 1;\n+                err_data = Some(vec![ret.as_ref().unwrap().0.clone()]);\n                 *slot = None;\n             }\n-            if error > 0 {\n-                error += 1;\n-                err.as_mut()\n-                    .unwrap()\n-                    .span_note(self.span, &format!(r\"candidate #{}: {}\", error, lib.display()));\n+            if let Some(candidates) = &mut err_data {\n+                candidates.push(lib);\n                 continue;\n             }\n \n@@ -790,7 +596,7 @@ impl<'a> CrateLocator<'a> {\n             // As a result, we favor the sysroot crate here. Note that the\n             // candidates are all canonicalized, so we canonicalize the sysroot\n             // as well.\n-            if let Some((ref prev, _)) = ret {\n+            if let Some((prev, _)) = &ret {\n                 let sysroot = &self.sess.sysroot;\n                 let sysroot = sysroot.canonicalize().unwrap_or_else(|_| sysroot.to_path_buf());\n                 if prev.starts_with(&sysroot) {\n@@ -801,11 +607,10 @@ impl<'a> CrateLocator<'a> {\n             ret = Some((lib, kind));\n         }\n \n-        if error > 0 {\n-            err.unwrap().emit();\n-            None\n+        if let Some(candidates) = err_data {\n+            Err(CrateError::MultipleCandidates(self.crate_name, flavor, candidates))\n         } else {\n-            ret\n+            Ok(ret)\n         }\n     }\n \n@@ -860,97 +665,60 @@ impl<'a> CrateLocator<'a> {\n         Some(hash)\n     }\n \n-    // Returns the corresponding (prefix, suffix) that files need to have for\n-    // dynamic libraries\n-    fn dylibname(&self) -> (String, String) {\n-        let t = &self.target;\n-        (t.options.dll_prefix.clone(), t.options.dll_suffix.clone())\n-    }\n-\n-    // Returns the corresponding (prefix, suffix) that files need to have for\n-    // static libraries\n-    fn staticlibname(&self) -> (String, String) {\n-        let t = &self.target;\n-        (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n-    }\n-\n-    fn find_commandline_library(&mut self) -> Option<Library> {\n+    fn find_commandline_library(&mut self) -> Result<Option<Library>, CrateError> {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n         // rlibs/dylibs.\n-        let sess = self.sess;\n-        let dylibname = self.dylibname();\n         let mut rlibs = FxHashMap::default();\n         let mut rmetas = FxHashMap::default();\n         let mut dylibs = FxHashMap::default();\n-        {\n-            let crate_name = self.crate_name;\n-            let rejected_via_filename = &mut self.rejected_via_filename;\n-            let locs = self.exact_paths.iter().filter(|loc| {\n-                if !loc.exists() {\n-                    sess.err(&format!(\n-                        \"extern location for {} does not exist: {}\",\n-                        crate_name,\n-                        loc.display()\n-                    ));\n-                    return false;\n-                }\n-                let file = match loc.file_name().and_then(|s| s.to_str()) {\n-                    Some(file) => file,\n-                    None => {\n-                        sess.err(&format!(\n-                            \"extern location for {} is not a file: {}\",\n-                            crate_name,\n-                            loc.display()\n-                        ));\n-                        return false;\n-                    }\n-                };\n-                if file.starts_with(\"lib\") && (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\"))\n-                {\n-                    return true;\n-                } else {\n-                    let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(&prefix[..]) && file.ends_with(&suffix[..]) {\n-                        return true;\n-                    }\n+        for loc in &self.exact_paths {\n+            if !loc.exists() {\n+                return Err(CrateError::ExternLocationNotExist(self.crate_name, loc.clone()));\n+            }\n+            let file = match loc.file_name().and_then(|s| s.to_str()) {\n+                Some(file) => file,\n+                None => {\n+                    return Err(CrateError::ExternLocationNotFile(self.crate_name, loc.clone()));\n                 }\n+            };\n \n-                rejected_via_filename\n-                    .push(CrateMismatch { path: (*loc).clone(), got: String::new() });\n-\n-                false\n-            });\n-\n-            // Now that we have an iterator of good candidates, make sure\n-            // there's at most one rlib and at most one dylib.\n-            for loc in locs {\n+            if file.starts_with(\"lib\") && (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\"))\n+                || file.starts_with(&self.target.options.dll_prefix)\n+                    && file.ends_with(&self.target.options.dll_suffix)\n+            {\n+                // Make sure there's at most one rlib and at most one dylib.\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n                     rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n                     rmetas.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else {\n                     dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 }\n+            } else {\n+                self.rejected_via_filename\n+                    .push(CrateMismatch { path: loc.clone(), got: String::new() });\n             }\n-        };\n+        }\n \n         // Extract the dylib/rlib/rmeta triple.\n-        self.extract_lib(rlibs, rmetas, dylibs).map(|(_, lib)| lib)\n+        Ok(self.extract_lib(rlibs, rmetas, dylibs)?.map(|(_, lib)| lib))\n     }\n-}\n \n-// Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(\n-    target: &Target,\n-    flavor: CrateFlavor,\n-    filename: &Path,\n-    loader: &dyn MetadataLoader,\n-) -> Result<MetadataBlob, String> {\n-    let start = Instant::now();\n-    let ret = get_metadata_section_imp(target, flavor, filename, loader);\n-    info!(\"reading {:?} => {:?}\", filename.file_name().unwrap(), start.elapsed());\n-    ret\n+    crate fn into_error(self) -> CrateError {\n+        CrateError::LocatorCombined(CombinedLocatorError {\n+            crate_name: self.crate_name,\n+            root: self.root.cloned(),\n+            triple: self.triple,\n+            dll_prefix: self.target.options.dll_prefix.clone(),\n+            dll_suffix: self.target.options.dll_suffix.clone(),\n+            rejected_via_hash: self.rejected_via_hash,\n+            rejected_via_triple: self.rejected_via_triple,\n+            rejected_via_kind: self.rejected_via_kind,\n+            rejected_via_version: self.rejected_via_version,\n+            rejected_via_filename: self.rejected_via_filename,\n+        })\n+    }\n }\n \n /// A trivial wrapper for `Mmap` that implements `StableDeref`.\n@@ -966,7 +734,7 @@ impl Deref for StableDerefMmap {\n \n unsafe impl stable_deref_trait::StableDeref for StableDerefMmap {}\n \n-fn get_metadata_section_imp(\n+fn get_metadata_section(\n     target: &Target,\n     flavor: CrateFlavor,\n     filename: &Path,\n@@ -1026,12 +794,19 @@ pub fn find_plugin_registrar(\n     metadata_loader: &dyn MetadataLoader,\n     span: Span,\n     name: Symbol,\n-) -> Option<(PathBuf, CrateDisambiguator)> {\n+) -> (PathBuf, CrateDisambiguator) {\n+    match find_plugin_registrar_impl(sess, metadata_loader, name) {\n+        Ok(res) => res,\n+        Err(err) => err.report(sess, span),\n+    }\n+}\n+\n+fn find_plugin_registrar_impl<'a>(\n+    sess: &'a Session,\n+    metadata_loader: &dyn MetadataLoader,\n+    name: Symbol,\n+) -> Result<(PathBuf, CrateDisambiguator), CrateError> {\n     info!(\"find plugin registrar `{}`\", name);\n-    let target_triple = sess.opts.target_triple.clone();\n-    let host_triple = TargetTriple::from_triple(config::host_triple());\n-    let is_cross = target_triple != host_triple;\n-    let mut target_only = false;\n     let mut locator = CrateLocator::new(\n         sess,\n         metadata_loader,\n@@ -1041,57 +816,16 @@ pub fn find_plugin_registrar(\n         None, // extra_filename\n         true, // is_host\n         PathKind::Crate,\n-        span,\n         None, // root\n         None, // is_proc_macro\n     );\n \n-    let library = locator.maybe_load_library_crate().or_else(|| {\n-        if !is_cross {\n-            return None;\n-        }\n-        // Try loading from target crates. This will abort later if we\n-        // try to load a plugin registrar function,\n-        target_only = true;\n-\n-        locator.target = &sess.target.target;\n-        locator.triple = target_triple;\n-        locator.filesearch = sess.target_filesearch(PathKind::Crate);\n-\n-        locator.maybe_load_library_crate()\n-    });\n-    let library = match library {\n-        Some(l) => l,\n-        None => locator.report_errs(),\n-    };\n-\n-    if target_only {\n-        let message = format!(\n-            \"plugin `{}` is not available for triple `{}` (only found {})\",\n-            name,\n-            config::host_triple(),\n-            sess.opts.target_triple\n-        );\n-        struct_span_err!(sess, span, E0456, \"{}\", &message).emit();\n-        return None;\n-    }\n-\n-    match library.source.dylib {\n-        Some(dylib) => Some((dylib.0, library.metadata.get_root().disambiguator())),\n-        None => {\n-            struct_span_err!(\n-                sess,\n-                span,\n-                E0457,\n-                \"plugin `{}` only found in rlib format, but must be available \\\n-                        in dylib format\",\n-                name\n-            )\n-            .emit();\n-            // No need to abort because the loading code will just ignore this\n-            // empty dylib.\n-            None\n-        }\n+    match locator.maybe_load_library_crate()? {\n+        Some(library) => match library.source.dylib {\n+            Some(dylib) => Ok((dylib.0, library.metadata.get_root().disambiguator())),\n+            None => Err(CrateError::NonDylibPlugin(name)),\n+        },\n+        None => Err(locator.into_error()),\n     }\n }\n \n@@ -1100,8 +834,8 @@ pub fn list_file_metadata(\n     target: &Target,\n     path: &Path,\n     metadata_loader: &dyn MetadataLoader,\n-    out: &mut dyn io::Write,\n-) -> io::Result<()> {\n+    out: &mut dyn Write,\n+) -> IoResult<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n@@ -1115,3 +849,259 @@ pub fn list_file_metadata(\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }\n }\n+\n+// ------------------------------------------ Error reporting -------------------------------------\n+\n+#[derive(Clone)]\n+struct CrateMismatch {\n+    path: PathBuf,\n+    got: String,\n+}\n+\n+/// Candidate rejection reasons collected during crate search.\n+/// If no candidate is accepted, then these reasons are presented to the user,\n+/// otherwise they are ignored.\n+crate struct CombinedLocatorError {\n+    crate_name: Symbol,\n+    root: Option<CratePaths>,\n+    triple: TargetTriple,\n+    dll_prefix: String,\n+    dll_suffix: String,\n+    rejected_via_hash: Vec<CrateMismatch>,\n+    rejected_via_triple: Vec<CrateMismatch>,\n+    rejected_via_kind: Vec<CrateMismatch>,\n+    rejected_via_version: Vec<CrateMismatch>,\n+    rejected_via_filename: Vec<CrateMismatch>,\n+}\n+\n+crate enum CrateError {\n+    NonAsciiName(Symbol),\n+    ExternLocationNotExist(Symbol, PathBuf),\n+    ExternLocationNotFile(Symbol, PathBuf),\n+    MultipleCandidates(Symbol, CrateFlavor, Vec<PathBuf>),\n+    MultipleMatchingCrates(Symbol, FxHashMap<Svh, Library>),\n+    SymbolConflictsCurrent(Symbol),\n+    SymbolConflictsOthers(Symbol),\n+    DlOpen(String),\n+    DlSym(String),\n+    LocatorCombined(CombinedLocatorError),\n+    NonDylibPlugin(Symbol),\n+}\n+\n+impl CrateError {\n+    crate fn report(self, sess: &Session, span: Span) -> ! {\n+        let mut err = match self {\n+            CrateError::NonAsciiName(crate_name) => sess.struct_span_err(\n+                span,\n+                &format!(\"cannot load a crate with a non-ascii name `{}`\", crate_name),\n+            ),\n+            CrateError::ExternLocationNotExist(crate_name, loc) => sess.struct_span_err(\n+                span,\n+                &format!(\"extern location for {} does not exist: {}\", crate_name, loc.display()),\n+            ),\n+            CrateError::ExternLocationNotFile(crate_name, loc) => sess.struct_span_err(\n+                span,\n+                &format!(\"extern location for {} is not a file: {}\", crate_name, loc.display()),\n+            ),\n+            CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n+                let mut err = struct_span_err!(\n+                    sess,\n+                    span,\n+                    E0465,\n+                    \"multiple {} candidates for `{}` found\",\n+                    flavor,\n+                    crate_name,\n+                );\n+                for (i, candidate) in candidates.iter().enumerate() {\n+                    err.span_note(span, &format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n+                }\n+                err\n+            }\n+            CrateError::MultipleMatchingCrates(crate_name, libraries) => {\n+                let mut err = struct_span_err!(\n+                    sess,\n+                    span,\n+                    E0464,\n+                    \"multiple matching crates for `{}`\",\n+                    crate_name\n+                );\n+                let candidates = libraries\n+                    .iter()\n+                    .filter_map(|(_, lib)| {\n+                        let crate_name = &lib.metadata.get_root().name().as_str();\n+                        match (&lib.source.dylib, &lib.source.rlib) {\n+                            (Some((pd, _)), Some((pr, _))) => Some(format!(\n+                                \"\\ncrate `{}`: {}\\n{:>padding$}\",\n+                                crate_name,\n+                                pd.display(),\n+                                pr.display(),\n+                                padding = 8 + crate_name.len()\n+                            )),\n+                            (Some((p, _)), None) | (None, Some((p, _))) => {\n+                                Some(format!(\"\\ncrate `{}`: {}\", crate_name, p.display()))\n+                            }\n+                            (None, None) => None,\n+                        }\n+                    })\n+                    .collect::<String>();\n+                err.note(&format!(\"candidates:{}\", candidates));\n+                err\n+            }\n+            CrateError::SymbolConflictsCurrent(root_name) => struct_span_err!(\n+                sess,\n+                span,\n+                E0519,\n+                \"the current crate is indistinguishable from one of its dependencies: it has the \\\n+                 same crate-name `{}` and was compiled with the same `-C metadata` arguments. \\\n+                 This will result in symbol conflicts between the two.\",\n+                root_name,\n+            ),\n+            CrateError::SymbolConflictsOthers(root_name) => struct_span_err!(\n+                sess,\n+                span,\n+                E0523,\n+                \"found two different crates with name `{}` that are not distinguished by differing \\\n+                 `-C metadata`. This will result in symbol conflicts between the two.\",\n+                root_name,\n+            ),\n+            CrateError::DlOpen(s) | CrateError::DlSym(s) => sess.struct_span_err(span, &s),\n+            CrateError::LocatorCombined(locator) => {\n+                let crate_name = locator.crate_name;\n+                let add = match &locator.root {\n+                    None => String::new(),\n+                    Some(r) => format!(\" which `{}` depends on\", r.name),\n+                };\n+                let mut msg = \"the following crate versions were found:\".to_string();\n+                let mut err = if !locator.rejected_via_hash.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0460,\n+                        \"found possibly newer version of crate `{}`{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+                    err.note(\"perhaps that crate needs to be recompiled?\");\n+                    let mismatches = locator.rejected_via_hash.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                    }\n+                    if let Some(r) = locator.root {\n+                        for path in r.source.paths() {\n+                            msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n+                        }\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else if !locator.rejected_via_triple.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0461,\n+                        \"couldn't find crate `{}` with expected target triple {}{}\",\n+                        crate_name,\n+                        locator.triple,\n+                        add,\n+                    );\n+                    let mismatches = locator.rejected_via_triple.iter();\n+                    for CrateMismatch { path, got } in mismatches {\n+                        msg.push_str(&format!(\n+                            \"\\ncrate `{}`, target triple {}: {}\",\n+                            crate_name,\n+                            got,\n+                            path.display(),\n+                        ));\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else if !locator.rejected_via_kind.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0462,\n+                        \"found staticlib `{}` instead of rlib or dylib{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+                    err.help(\"please recompile that crate using --crate-type lib\");\n+                    let mismatches = locator.rejected_via_kind.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else if !locator.rejected_via_version.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0514,\n+                        \"found crate `{}` compiled by an incompatible version of rustc{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+                    err.help(&format!(\n+                        \"please recompile that crate using this compiler ({})\",\n+                        rustc_version(),\n+                    ));\n+                    let mismatches = locator.rejected_via_version.iter();\n+                    for CrateMismatch { path, got } in mismatches {\n+                        msg.push_str(&format!(\n+                            \"\\ncrate `{}` compiled by {}: {}\",\n+                            crate_name,\n+                            got,\n+                            path.display(),\n+                        ));\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0463,\n+                        \"can't find crate for `{}`{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+\n+                    if (crate_name == sym::std || crate_name == sym::core)\n+                        && locator.triple != TargetTriple::from_triple(config::host_triple())\n+                    {\n+                        err.note(&format!(\"the `{}` target may not be installed\", locator.triple));\n+                    } else if crate_name == sym::profiler_builtins {\n+                        err.note(&\"the compiler may have been built without the profiler runtime\");\n+                    }\n+                    err.span_label(span, \"can't find crate\");\n+                    err\n+                };\n+\n+                if !locator.rejected_via_filename.is_empty() {\n+                    let mismatches = locator.rejected_via_filename.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        err.note(&format!(\n+                            \"extern location for {} is of an unknown type: {}\",\n+                            crate_name,\n+                            path.display(),\n+                        ))\n+                        .help(&format!(\n+                            \"file name should be lib*.rlib or {}*.{}\",\n+                            locator.dll_prefix, locator.dll_suffix\n+                        ));\n+                    }\n+                }\n+                err\n+            }\n+            CrateError::NonDylibPlugin(crate_name) => struct_span_err!(\n+                sess,\n+                span,\n+                E0457,\n+                \"plugin `{}` only found in rlib format, but must be available in dylib format\",\n+                crate_name,\n+            ),\n+        };\n+\n+        err.emit();\n+        sess.abort_if_errors();\n+        unreachable!();\n+    }\n+}"}, {"sha": "5836fc9c95a80af6cb330c332a4446f3094665e6", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -95,6 +95,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let (dest, ret) = match ret {\n             None => match intrinsic_name {\n                 sym::transmute => throw_ub_format!(\"transmuting to uninhabited type\"),\n+                sym::unreachable => throw_ub!(Unreachable),\n                 sym::abort => M::abort(self)?,\n                 // Unsupported diverging intrinsic.\n                 _ => return Ok(false),"}, {"sha": "62a87b47a2f74e7215a85d1310841273289f7a16", "filename": "src/librustc_plugin_impl/load.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_plugin_impl%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_plugin_impl%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fload.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -55,13 +55,11 @@ fn load_plugin(\n     metadata_loader: &dyn MetadataLoader,\n     ident: Ident,\n ) {\n-    let registrar = locator::find_plugin_registrar(sess, metadata_loader, ident.span, ident.name);\n-\n-    if let Some((lib, disambiguator)) = registrar {\n-        let symbol = sess.generate_plugin_registrar_symbol(disambiguator);\n-        let fun = dylink_registrar(sess, ident.span, lib, symbol);\n-        plugins.push(fun);\n-    }\n+    let (lib, disambiguator) =\n+        locator::find_plugin_registrar(sess, metadata_loader, ident.span, ident.name);\n+    let symbol = sess.generate_plugin_registrar_symbol(disambiguator);\n+    let fun = dylink_registrar(sess, ident.span, lib, symbol);\n+    plugins.push(fun);\n }\n \n // Dynamically link a registrar function into the compiler process."}, {"sha": "a7a005bdeb9f2e3b59b2d0796c2947bc6ae6dddd", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -859,9 +859,7 @@ impl<'a> Resolver<'a> {\n                     // otherwise cause duplicate suggestions.\n                     continue;\n                 }\n-                if let Some(crate_id) =\n-                    self.crate_loader.maybe_process_path_extern(ident.name, ident.span)\n-                {\n+                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name) {\n                     let crate_root =\n                         self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                     suggestions.extend(self.lookup_import_candidates_from_module("}, {"sha": "9323c15a94109b9cdb6ad278051bcc451719cb8d", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -760,10 +760,8 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                         if !module.no_implicit_prelude {\n                             let extern_prelude = self.r.extern_prelude.clone();\n                             names.extend(extern_prelude.iter().flat_map(|(ident, _)| {\n-                                self.r\n-                                    .crate_loader\n-                                    .maybe_process_path_extern(ident.name, ident.span)\n-                                    .and_then(|crate_id| {\n+                                self.r.crate_loader.maybe_process_path_extern(ident.name).and_then(\n+                                    |crate_id| {\n                                         let crate_mod = Res::Def(\n                                             DefKind::Mod,\n                                             DefId { krate: crate_id, index: CRATE_DEF_INDEX },\n@@ -774,7 +772,8 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                                         } else {\n                                             None\n                                         }\n-                                    })\n+                                    },\n+                                )\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {"}, {"sha": "da39f79efcd3bc487d8889a90a4d4bab146e8b29", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -2957,7 +2957,7 @@ impl<'a> Resolver<'a> {\n                 let crate_id = if !speculative {\n                     self.crate_loader.process_path_extern(ident.name, ident.span)\n                 } else {\n-                    self.crate_loader.maybe_process_path_extern(ident.name, ident.span)?\n+                    self.crate_loader.maybe_process_path_extern(ident.name)?\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 Some("}, {"sha": "da25a0ede729d1fd3c66b1819fda6e91d17aa3bb", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -1551,6 +1551,27 @@ impl ops::Index<ops::RangeFull> for CString {\n     }\n }\n \n+#[stable(feature = \"cstr_range_from\", since = \"1.47.0\")]\n+impl ops::Index<ops::RangeFrom<usize>> for CStr {\n+    type Output = CStr;\n+\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &CStr {\n+        let bytes = self.to_bytes_with_nul();\n+        // we need to manually check the starting index to account for the null\n+        // byte, since otherwise we could get an empty string that doesn't end\n+        // in a null.\n+        if index.start < bytes.len() {\n+            unsafe { CStr::from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n+        } else {\n+            panic!(\n+                \"index out of bounds: the len is {} but the index is {}\",\n+                bytes.len(),\n+                index.start\n+            );\n+        }\n+    }\n+}\n+\n #[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n impl AsRef<CStr> for CStr {\n     #[inline]\n@@ -1747,4 +1768,21 @@ mod tests {\n \n         assert_eq!(CSTR.to_str().unwrap(), \"Hello, world!\");\n     }\n+\n+    #[test]\n+    fn cstr_index_from() {\n+        let original = b\"Hello, world!\\0\";\n+        let cstr = CStr::from_bytes_with_nul(original).unwrap();\n+        let result = CStr::from_bytes_with_nul(&original[7..]).unwrap();\n+\n+        assert_eq!(&cstr[7..], result);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn cstr_index_from_empty() {\n+        let original = b\"Hello, world!\\0\";\n+        let cstr = CStr::from_bytes_with_nul(original).unwrap();\n+        let _ = &cstr[original.len()..];\n+    }\n }"}, {"sha": "d985f10ccb486489fe65680c495e9127b851dbd7", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 180, "deletions": 3, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -1497,11 +1497,188 @@ mod super_keyword {}\n \n #[doc(keyword = \"trait\")]\n //\n-/// A common interface for a class of types.\n+/// A common interface for a group of types.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// A `trait` is like an interface that data types can implement. When a type\n+/// implements a trait it can be treated abstractly as that trait using generics\n+/// or trait objects.\n ///\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// Traits can be made up of three varieties of associated items:\n+///\n+/// - functions and methods\n+/// - types\n+/// - constants\n+///\n+/// Traits may also contain additional type parameters. Those type parameters\n+/// or the trait itself can be constrained by other traits.\n+///\n+/// Traits can serve as markers or carry other logical semantics that\n+/// aren't expressed through their items. When a type implements that\n+/// trait it is promising to uphold its contract. [`Send`] and [`Sync`] are two\n+/// such marker traits present in the standard library.\n+///\n+/// See the [Reference][Ref-Traits] for a lot more information on traits.\n+///\n+/// # Examples\n+///\n+/// Traits are declared using the `trait` keyword. Types can implement them\n+/// using [`impl`] `Trait` [`for`] `Type`:\n+///\n+/// ```rust\n+/// trait Zero {\n+///     const ZERO: Self;\n+///     fn is_zero(&self) -> bool;\n+/// }\n+///\n+/// impl Zero for i32 {\n+///     const ZERO: Self = 0;\n+///\n+///     fn is_zero(&self) -> bool {\n+///         *self == Self::ZERO\n+///     }\n+/// }\n+///\n+/// assert_eq!(i32::ZERO, 0);\n+/// assert!(i32::ZERO.is_zero());\n+/// assert!(!4.is_zero());\n+/// ```\n+///\n+/// With an associated type:\n+///\n+/// ```rust\n+/// trait Builder {\n+///     type Built;\n+///\n+///     fn build(&self) -> Self::Built;\n+/// }\n+/// ```\n+///\n+/// Traits can be generic, with constraints or without:\n+///\n+/// ```rust\n+/// trait MaybeFrom<T> {\n+///     fn maybe_from(value: T) -> Option<Self>\n+///     where\n+///         Self: Sized;\n+/// }\n+/// ```\n+///\n+/// Traits can build upon the requirements of other traits. In the example\n+/// below `Iterator` is a **supertrait** and `ThreeIterator` is a **subtrait**:\n+///\n+/// ```rust\n+/// trait ThreeIterator: std::iter::Iterator {\n+///     fn next_three(&mut self) -> Option<[Self::Item; 3]>;\n+/// }\n+/// ```\n+///\n+/// Traits can be used in functions, as parameters:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// fn debug_iter<I: Iterator>(it: I) where I::Item: std::fmt::Debug {\n+///     for elem in it {\n+///         println!(\"{:#?}\", elem);\n+///     }\n+/// }\n+///\n+/// // u8_len_1, u8_len_2 and u8_len_3 are equivalent\n+///\n+/// fn u8_len_1(val: impl Into<Vec<u8>>) -> usize {\n+///     val.into().len()\n+/// }\n+///\n+/// fn u8_len_2<T: Into<Vec<u8>>>(val: T) -> usize {\n+///     val.into().len()\n+/// }\n+///\n+/// fn u8_len_3<T>(val: T) -> usize\n+/// where\n+///     T: Into<Vec<u8>>,\n+/// {\n+///     val.into().len()\n+/// }\n+/// ```\n+///\n+/// Or as return types:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// fn from_zero_to(v: u8) -> impl Iterator<Item = u8> {\n+///     (0..v).into_iter()\n+/// }\n+/// ```\n+///\n+/// The use of the [`impl`] keyword in this position allows the function writer\n+/// to hide the concrete type as an implementation detail which can change\n+/// without breaking user's code.\n+///\n+/// # Trait objects\n+///\n+/// A *trait object* is an opaque value of another type that implements a set of\n+/// traits. A trait object implements all specified traits as well as their\n+/// supertraits (if any).\n+///\n+/// The syntax is the following: `dyn BaseTrait + AutoTrait1 + ... AutoTraitN`.\n+/// Only one `BaseTrait` can be used so this will not compile:\n+///\n+/// ```rust,compile_fail,E0225\n+/// trait A {}\n+/// trait B {}\n+///\n+/// let _: Box<dyn A + B>;\n+/// ```\n+///\n+/// Neither will this, which is a syntax error:\n+///\n+/// ```rust,compile_fail\n+/// trait A {}\n+/// trait B {}\n+///\n+/// let _: Box<dyn A + dyn B>;\n+/// ```\n+///\n+/// On the other hand, this is correct:\n+///\n+/// ```rust\n+/// trait A {}\n+///\n+/// let _: Box<dyn A + Send + Sync>;\n+/// ```\n+///\n+/// The [Reference][Ref-Trait-Objects] has more information about trait objects,\n+/// their limitations and the differences between editions.\n+///\n+/// # Unsafe traits\n+///\n+/// Some traits may be unsafe to implement. Using the [`unsafe`] keyword in\n+/// front of the trait's declaration is used to mark this:\n+///\n+/// ```rust\n+/// unsafe trait UnsafeTrait {}\n+///\n+/// unsafe impl UnsafeTrait for i32 {}\n+/// ```\n+///\n+/// # Differences between the 2015 and 2018 editions\n+///\n+/// In the 2015 edition parameters pattern where not needed for traits:\n+///\n+/// ```rust,edition2015\n+/// trait Tr {\n+///     fn f(i32);\n+/// }\n+/// ```\n+///\n+/// This behavior is no longer valid in edition 2018.\n+///\n+/// [`for`]: keyword.for.html\n+/// [`impl`]: keyword.impl.html\n+/// [`unsafe`]: keyword.unsafe.html\n+/// [`Send`]: marker/trait.Send.html\n+/// [`Sync`]: marker/trait.Sync.html\n+/// [Ref-Traits]: ../reference/items/traits.html\n+/// [Ref-Trait-Objects]: ../reference/types/trait-object.html\n mod trait_keyword {}\n \n #[doc(keyword = \"true\")]"}, {"sha": "11b8f953be46008c0a8cd05c3e62da77e8a4ea03", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -305,6 +305,7 @@\n #![feature(ptr_internals)]\n #![feature(raw)]\n #![feature(raw_ref_macros)]\n+#![feature(ready_macro)]\n #![feature(renamed_spin_loop)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]"}, {"sha": "d3cb5aaaeba89095fed6fbae4ac5cdfc7427d8ac", "filename": "src/test/compile-fail/empty-extern-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -1,4 +1,4 @@\n // compile-flags: --extern std=\n-// error-pattern: can't find crate for `std`\n+// error-pattern: extern location for std does not exist\n \n fn main() {}"}, {"sha": "1fd514c6173290945a775d5873b56f72124593a8", "filename": "src/test/ui-fulldeps/macro-crate-rlib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -1,10 +1,8 @@\n // aux-build:rlib-crate-test.rs\n-// ignore-tidy-linelength\n // ignore-cross-compile gives a different error message\n \n #![feature(plugin)]\n #![plugin(rlib_crate_test)]\n-//~^ ERROR: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib format\n-//~| WARN use of deprecated attribute `plugin`: compiler plugins are deprecated\n+//~^ ERROR: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib\n \n fn main() {}"}, {"sha": "7b31f28a26e7d3555411b265c23af8d0fd6fb50c", "filename": "src/test/ui-fulldeps/macro-crate-rlib.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.stderr?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -1,16 +1,8 @@\n error[E0457]: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib format\n-  --> $DIR/macro-crate-rlib.rs:6:11\n+  --> $DIR/macro-crate-rlib.rs:5:11\n    |\n LL | #![plugin(rlib_crate_test)]\n    |           ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/macro-crate-rlib.rs:6:1\n-   |\n-LL | #![plugin(rlib_crate_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "ccc05fdf100e7872e8b195c594a77707425020c6", "filename": "src/test/ui/const-generics/issues/issue-62878.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -0,0 +1,11 @@\n+#![feature(const_generics)] //~ WARN the feature `const_generics` is incomplete\n+\n+fn foo<const N: usize, const A: [u8; N]>() {}\n+//~^ ERROR the type of const parameters must not\n+\n+fn main() {\n+    foo::<_, {[1]}>();\n+    //~^ ERROR wrong number of const arguments\n+    //~| ERROR wrong number of type arguments\n+    //~| ERROR mismatched types\n+}"}, {"sha": "fe0990d8241fa6a7cbe414e73b29c98b97483f66", "filename": "src/test/ui/const-generics/issues/issue-62878.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.stderr?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -0,0 +1,37 @@\n+error[E0770]: the type of const parameters must not depend on other generic parameters\n+  --> $DIR/issue-62878.rs:3:38\n+   |\n+LL | fn foo<const N: usize, const A: [u8; N]>() {}\n+   |                                      ^ the type must not depend on the parameter `N`\n+\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-62878.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+error[E0107]: wrong number of const arguments: expected 2, found 1\n+  --> $DIR/issue-62878.rs:7:5\n+   |\n+LL |     foo::<_, {[1]}>();\n+   |     ^^^^^^^^^^^^^^^ expected 2 const arguments\n+\n+error[E0107]: wrong number of type arguments: expected 0, found 1\n+  --> $DIR/issue-62878.rs:7:11\n+   |\n+LL |     foo::<_, {[1]}>();\n+   |           ^ unexpected type argument\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-62878.rs:7:15\n+   |\n+LL |     foo::<_, {[1]}>();\n+   |               ^^^ expected `usize`, found array `[{integer}; 1]`\n+\n+error: aborting due to 4 previous errors; 1 warning emitted\n+\n+Some errors have detailed explanations: E0107, E0308, E0770.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "cfed6e5deb99956864ba0a861a01cb0520e0b366", "filename": "src/test/ui/consts/const_unsafe_unreachable.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(const_fn)]\n+#![feature(const_unreachable_unchecked)]\n+\n+const unsafe fn foo(x: bool) -> bool {\n+    match x {\n+        true => true,\n+        false => std::hint::unreachable_unchecked(),\n+    }\n+}\n+\n+const BAR: bool = unsafe { foo(true) };\n+\n+fn main() {\n+  assert_eq!(BAR, true);\n+}"}, {"sha": "11920d852e02feaffc2c6d0d8c05f06399084d3a", "filename": "src/test/ui/consts/const_unsafe_unreachable_ub.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -0,0 +1,20 @@\n+// build-fail\n+\n+#![feature(const_fn)]\n+#![feature(const_unreachable_unchecked)]\n+\n+const unsafe fn foo(x: bool) -> bool {\n+    match x {\n+        true => true,\n+        false => std::hint::unreachable_unchecked(),\n+    }\n+}\n+\n+#[warn(const_err)]\n+const BAR: bool = unsafe { foo(false) };\n+\n+fn main() {\n+  assert_eq!(BAR, true);\n+  //~^ ERROR E0080\n+  //~| ERROR erroneous constant\n+}"}, {"sha": "3ef8043a54d8877d503e9e8be65a55ef26223d31", "filename": "src/test/ui/consts/const_unsafe_unreachable_ub.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -0,0 +1,44 @@\n+warning: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/hint.rs:LL:COL\n+   |\n+LL |     unsafe { intrinsics::unreachable() }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |              |\n+   |              entering unreachable code\n+   |              inside `std::hint::unreachable_unchecked` at $SRC_DIR/libcore/hint.rs:LL:COL\n+   |              inside `foo` at $DIR/const_unsafe_unreachable_ub.rs:9:18\n+   |              inside `BAR` at $DIR/const_unsafe_unreachable_ub.rs:14:28\n+   | \n+  ::: $DIR/const_unsafe_unreachable_ub.rs:14:1\n+   |\n+LL | const BAR: bool = unsafe { foo(false) };\n+   | ----------------------------------------\n+   |\n+note: the lint level is defined here\n+  --> $DIR/const_unsafe_unreachable_ub.rs:13:8\n+   |\n+LL | #[warn(const_err)]\n+   |        ^^^^^^^^^\n+\n+error[E0080]: evaluation of constant expression failed\n+  --> $DIR/const_unsafe_unreachable_ub.rs:17:3\n+   |\n+LL |   assert_eq!(BAR, true);\n+   |   ^^^^^^^^^^^---^^^^^^^^\n+   |              |\n+   |              referenced constant has errors\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: erroneous constant used\n+  --> $DIR/const_unsafe_unreachable_ub.rs:17:3\n+   |\n+LL |   assert_eq!(BAR, true);\n+   |   ^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "3ba124159e0002d41d448fa6bc885da5ffc118ad", "filename": "src/test/ui/extern/extern-prelude-no-speculative.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fextern%2Fextern-prelude-no-speculative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Fextern%2Fextern-prelude-no-speculative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-prelude-no-speculative.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n #![allow(unused_variables)]\n-// compile-flags: --extern LooksLikeExternCrate\n+// compile-flags: --extern LooksLikeExternCrate=/path/to/nowhere\n \n mod m {\n     pub struct LooksLikeExternCrate;"}, {"sha": "310545b92d5492d23f7d698790a9dfdcbe47001e", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -1,6 +1,5 @@\n #![feature(non_ascii_idents)]\n \n extern crate \u044c\u0430\u0433; //~ ERROR cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n-//~| ERROR can't find crate for `\u044c\u0430\u0433`\n \n fn main() {}"}, {"sha": "11108f2fb86789ce88b273be499e3a7c0a54b750", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -4,12 +4,5 @@ error: cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n LL | extern crate \u044c\u0430\u0433;\n    | ^^^^^^^^^^^^^^^^^\n \n-error[E0463]: can't find crate for `\u044c\u0430\u0433`\n-  --> $DIR/crate_name_nonascii_forbidden-1.rs:3:1\n-   |\n-LL | extern crate \u044c\u0430\u0433;\n-   | ^^^^^^^^^^^^^^^^^ can't find crate\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0463`."}, {"sha": "0249848b35ac0b12621a0b0739ba1e1dcd72f53f", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -3,7 +3,5 @@\n #![feature(non_ascii_idents)]\n \n use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz; //~  ERROR cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n-                   //~| can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n-\n \n fn main() {}"}, {"sha": "8d3548ed33dcf8a70047df8c8cb1cbbe97382eab", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -4,12 +4,5 @@ error: cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n    |     ^^^^^^^^\n \n-error[E0463]: can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n-  --> $DIR/crate_name_nonascii_forbidden-2.rs:5:5\n-   |\n-LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n-   |     ^^^^^^^^ can't find crate\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0463`."}, {"sha": "51f135d37616125ad1b2e4a18aacf28631327c30", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701419e96d94e5493c7ebfcecb66511ab0aa778/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=0701419e96d94e5493c7ebfcecb66511ab0aa778", "patch": "@@ -8,11 +8,11 @@ use std::path::Path;\n \n // A few of those error codes can't be tested but all the others can and *should* be tested!\n const EXEMPTED_FROM_TEST: &[&str] = &[\n-    \"E0183\", \"E0227\", \"E0279\", \"E0280\", \"E0311\", \"E0313\", \"E0314\", \"E0315\", \"E0377\", \"E0456\",\n-    \"E0461\", \"E0462\", \"E0464\", \"E0465\", \"E0472\", \"E0473\", \"E0474\", \"E0475\", \"E0476\", \"E0479\",\n-    \"E0480\", \"E0481\", \"E0482\", \"E0483\", \"E0484\", \"E0485\", \"E0486\", \"E0487\", \"E0488\", \"E0489\",\n-    \"E0514\", \"E0519\", \"E0523\", \"E0553\", \"E0554\", \"E0570\", \"E0629\", \"E0630\", \"E0640\", \"E0717\",\n-    \"E0727\", \"E0729\",\n+    \"E0183\", \"E0227\", \"E0279\", \"E0280\", \"E0311\", \"E0313\", \"E0314\", \"E0315\", \"E0377\", \"E0461\",\n+    \"E0462\", \"E0464\", \"E0465\", \"E0472\", \"E0473\", \"E0474\", \"E0475\", \"E0476\", \"E0479\", \"E0480\",\n+    \"E0481\", \"E0482\", \"E0483\", \"E0484\", \"E0485\", \"E0486\", \"E0487\", \"E0488\", \"E0489\", \"E0514\",\n+    \"E0519\", \"E0523\", \"E0553\", \"E0554\", \"E0570\", \"E0629\", \"E0630\", \"E0640\", \"E0717\", \"E0727\",\n+    \"E0729\",\n ];\n \n // Some error codes don't have any tests apparently..."}]}