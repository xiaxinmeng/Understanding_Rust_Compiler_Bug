{"sha": "007af36bb38266953fd14e4136858b6e1f7aa703", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwN2FmMzZiYjM4MjY2OTUzZmQxNGU0MTM2ODU4YjZlMWY3YWE3MDM=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-10T20:10:38Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-10T22:11:32Z"}, "message": "Comments, cleanup, whitespace, refactoring.", "tree": {"sha": "963d96ef8ba0ac8904d23f947b31cae300bee519", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/963d96ef8ba0ac8904d23f947b31cae300bee519"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/007af36bb38266953fd14e4136858b6e1f7aa703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/007af36bb38266953fd14e4136858b6e1f7aa703", "html_url": "https://github.com/rust-lang/rust/commit/007af36bb38266953fd14e4136858b6e1f7aa703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/007af36bb38266953fd14e4136858b6e1f7aa703/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b23360ec8e58277a5e1685df60c02399522a5e58", "url": "https://api.github.com/repos/rust-lang/rust/commits/b23360ec8e58277a5e1685df60c02399522a5e58", "html_url": "https://github.com/rust-lang/rust/commit/b23360ec8e58277a5e1685df60c02399522a5e58"}], "stats": {"total": 151, "additions": 74, "deletions": 77}, "files": [{"sha": "de42ca05d3529ba9f71741e68c1c038fcbb52751", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/007af36bb38266953fd14e4136858b6e1f7aa703/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007af36bb38266953fd14e4136858b6e1f7aa703/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=007af36bb38266953fd14e4136858b6e1f7aa703", "patch": "@@ -23,26 +23,26 @@ import trans::*;\n export trans_anon_obj;\n export trans_obj;\n \n-// trans_obj: creates an LLVM function that is the object constructor for the\n+// trans_obj: create an LLVM function that is the object constructor for the\n // object being translated.\n fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n              ctor_id: ast::node_id, ty_params: &[ast::ty_param]) {\n+\n     // To make a function, we have to create a function context and, inside\n     // that, a number of block contexts for which code is generated.\n-\n     let ccx = cx.ccx;\n     let llctor_decl;\n     alt ccx.item_ids.find(ctor_id) {\n       some(x) { llctor_decl = x; }\n       _ { cx.ccx.sess.span_fatal(sp, \"unbound llctor_decl in trans_obj\"); }\n     }\n+\n     // Much like trans_fn, we must create an LLVM function, but since we're\n     // starting with an ast::_obj rather than an ast::_fn, we have some setup\n     // work to do.\n \n     // The fields of our object will become the arguments to the function\n     // we're creating.\n-\n     let fn_args: [ast::arg] = ~[];\n     for f: ast::obj_field  in ob.fields {\n         fn_args +=\n@@ -93,10 +93,6 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n     // typarams, and fields.\n-\n-    // FIXME: What about inner_obj?  Do we have to think about it here?\n-    // (Pertains to issues #538/#539/#540/#543.)\n-\n     let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n \n     if std::ivec::len[ast::ty_param](ty_params) == 0u &&\n@@ -122,7 +118,8 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         // Tuple type for typarams: [typaram, ...]\n         let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, tps);\n \n-        // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n+        // Tuple type for body:\n+        // [tydesc_ty, [typaram, ...], [field, ...]]\n         let body_ty: ty::t =\n             ty::mk_imm_tup(ccx.tcx, ~[tydesc_ty, typarams_ty, fields_ty]);\n \n@@ -215,12 +212,10 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n                   id: ast::node_id) -> result {\n \n-\n     let ccx = bcx_ccx(bcx);\n \n-    // Fields.\n-    // FIXME (part of issue #538): Where do we fill in the field *values* from\n-    // the outer object?\n+    // Fields.  FIXME (part of issue #538): Where do we fill in the field\n+    // *values* from the outer object?\n     let additional_fields: [ast::anon_obj_field] = ~[];\n     let additional_field_vals: [result] = ~[];\n     let additional_field_tys: [ty::t] = ~[];\n@@ -254,32 +249,31 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     let vtbl;\n     alt anon_obj.inner_obj {\n       none. {\n-        // We need a dummy inner_obj_ty for setting up the object body\n-        // later.\n+        // We need a dummy inner_obj_ty for setting up the object body later.\n         inner_obj_ty = ty::mk_type(ccx.tcx);\n \n-        // If there's no inner_obj -- that is, if we're just adding new\n-        // fields rather than extending an existing object -- then we just\n-        // pass the outer object to create_vtbl().  Our vtable won't need\n+        // If there's no inner_obj -- that is, if we're creating a new object\n+        // from nothing rather than extending an existing object -- then we\n+        // just pass the outer object to create_vtbl().  Our vtable won't need\n         // to have any forwarding slots.\n         vtbl =\n             create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[], none,\n                         additional_field_tys);\n       }\n       some(e) {\n-        // TODO: What makes more sense to get the type of an expr --\n-        // calling ty::expr_ty(ccx.tcx, e) on it or calling\n+        // TODO: What makes more sense to get the type of an expr -- calling\n+        // ty::expr_ty(ccx.tcx, e) on it or calling\n         // ty::node_id_to_type(ccx.tcx, id) on its id?\n         inner_obj_ty = ty::expr_ty(ccx.tcx, e);\n         //inner_obj_ty = ty::node_id_to_type(ccx.tcx, e.id);\n \n         // If there's a inner_obj, we pass its type along to create_vtbl().\n-        // Part of what create_vtbl() will do is take the set difference\n-        // of methods defined on the original and methods being added.\n-        // For every method defined on the original that does *not* have\n-        // one with a matching name and type being added, we'll need to\n-        // create a forwarding slot.  And, of course, we need to create a\n-        // normal vtable entry for every method being added.\n+        // Part of what create_vtbl() will do is take the set difference of\n+        // methods defined on the original and methods being added.  For every\n+        // method defined on the original that does *not* have one with a\n+        // matching name and type being added, we'll need to create a\n+        // forwarding slot.  And, of course, we need to create a normal vtable\n+        // entry for every method being added.\n         vtbl =\n             create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[],\n                         some(inner_obj_ty), additional_field_tys);\n@@ -294,8 +288,6 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     add_clean_temp(bcx, pair, t);\n \n     // Grab onto the first and second elements of the pair.\n-    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n-    // of 'pair'.\n     let pair_vtbl =\n         bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n     let pair_box =\n@@ -414,8 +406,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n // Used only inside create_vtbl and create_backwarding_vtbl to distinguish\n // different kinds of slots we'll have to create.\n tag vtbl_mthd {\n-    // Normal methods are complete AST nodes, but for forwarding methods,\n-    // the only information we'll have about them is their type.\n+    // Normal methods are complete AST nodes, but for forwarding methods, the\n+    // only information we'll have about them is their type.\n     normal_mthd(@ast::method);\n     fwding_mthd(@ty::method);\n }\n@@ -443,8 +435,8 @@ fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n     }\n }\n \n-// Used by create_vtbl to filter a list of methods to remove the ones that we\n-// don't need forwarding slots for.\n+// filtering_fn: Used by create_vtbl to filter a list of methods to remove the\n+// ones that we don't need forwarding slots for.\n fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n                 addtl_meths: [@ast::method]) ->\n     option::t[vtbl_mthd] {\n@@ -468,8 +460,8 @@ fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n     }\n }\n \n-// Create a vtable for an object being translated.  Returns a pointer into\n-// read-only memory.\n+// create_vtbl: Create a vtable for a regular object or for an outer anonymous\n+// object, and return a pointer to it.\n fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n                ob: &ast::_obj, ty_params: &[ast::ty_param],\n                inner_obj_ty: option::t[ty::t],\n@@ -479,6 +471,9 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n \n     alt inner_obj_ty {\n       none. {\n+        // We're creating a vtable for a regular object, or for an anonymous\n+        // object that doesn't extend an existing one.\n+\n         // Sort and process all the methods.\n         let meths =\n             std::sort::ivector::merge_sort[@ast::method]\n@@ -490,24 +485,18 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n         }\n       }\n       some(inner_obj_ty) {\n-        // If this vtable is being created for an extended object, then the\n-        // vtable needs to contain 'forwarding slots' for methods that were on\n-        // the original object and are not being overridden by the extended\n-        // one.  So, to find the set of methods that we need forwarding slots\n-        // for, we need to take the set difference of inner_obj_methods\n-        // (methods on the original object) and ob.methods (methods being\n-        // added, whether entirely new or overriding).\n-\n-        // inner_obj_ty is the type of the inner object being forwarded to,\n-        // and \"ob\" is the wrapper object.  We need to take apart\n-        // inner_obj_ty, which is the type of the object being forwarded to\n-        // (it had better have an object type with methods!) and put those\n-        // original methods onto the list of methods we need forwarding\n-        // methods for.\n+        // We're creating a vtable for an anonymous object that extends an\n+        // existing one.\n+\n+        // The vtable needs to contain 'forwarding slots' for any methods that\n+        // were on the inner object and are not being overridden by the outer\n+        // one.  To find the set of methods that we need forwarding slots for,\n+        // we take the set difference of { methods on the original object }\n+        // and { methods being added, whether entirely new or overriding }.\n \n         let meths: [vtbl_mthd] = ~[];\n \n-        // Gather up methods on the original object in 'meths'.\n+        // Gather up methods on the inner object.\n         alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n           ty::ty_obj(inner_obj_methods) {\n             for m: ty::method  in inner_obj_methods {\n@@ -520,8 +509,8 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n           }\n         }\n \n-        // Now, filter out any methods that we don't need forwarding slots\n-        // for, because they're being overridden.\n+        // Filter out any methods that we don't need forwarding slots for\n+        // because they're being overridden.\n         let f = bind filtering_fn(cx, _, ob.methods);\n         meths = std::ivec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n \n@@ -534,6 +523,8 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n             std::sort::ivector::merge_sort[vtbl_mthd]\n             (bind vtbl_mthd_lteq(_, _), meths);\n \n+        // To create forwarding methods, we'll need a \"backwarding\" vtbl.  See\n+        // create_backwarding_vtbl and process_bkwding_method for details.\n         let backwarding_vtbl: ValueRef =\n             create_backwarding_vtbl(cx, sp, inner_obj_ty, outer_obj_ty);\n \n@@ -554,17 +545,12 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n       }\n     }\n \n-    let vtbl = C_struct(llmethods);\n-    let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + ~[\"vtbl\"]);\n-    let gvar =\n-        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n-    llvm::LLVMSetInitializer(gvar, vtbl);\n-    llvm::LLVMSetGlobalConstant(gvar, True);\n-    llvm::LLVMSetLinkage(gvar,\n-                         lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    ret gvar;\n+    ret finish_vtbl(cx, llmethods, \"vtbl\");\n }\n \n+// create_backwarding_vtbl: Create a vtable for the inner object of an\n+// anonymous object, so that any self-calls made from the inner object's\n+// methods get redirected appropriately.\n fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n                            outer_obj_ty: ty::t) -> ValueRef {\n \n@@ -591,28 +577,30 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n \n     // Methods should have already been sorted, so no need to do so again.\n     for m: ty::method in meths {\n-        // We pass outer_obj_ty to process_fwding_mthd() because it's\n-        // the one being forwarded to.\n+        // We pass outer_obj_ty to process_fwding_mthd() because it's the one\n+        // being forwarded to.\n         llmethods += ~[process_bkwding_mthd(\n             cx, sp, @m, ~[], outer_obj_ty, ~[])];\n     }\n \n+    ret finish_vtbl(cx, llmethods, \"backwarding_vtbl\");\n+}\n+\n+// finish_vtbl: Given a vector of vtable entries, create the table in\n+// read-only memory and return a pointer to it.\n+fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str)\n+    -> ValueRef {\n     let vtbl = C_struct(llmethods);\n-    let vtbl_name =\n-        mangle_internal_name_by_path(cx.ccx,\n-                                     cx.path + ~[\"backwarding_vtbl\"]);\n+    let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + ~[name]);\n     let gvar =\n         llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n     llvm::LLVMSetInitializer(gvar, vtbl);\n     llvm::LLVMSetGlobalConstant(gvar, True);\n     llvm::LLVMSetLinkage(gvar,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-\n     ret gvar;\n-\n }\n \n-\n // process_bkwding_mthd: Create the backwarding function that appears in a\n // backwarding vtable slot.\n //\n@@ -653,9 +641,9 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n \n-    // The self-object will arrive in the backwarding function via the llenv\n-    // argument, but we need to jump past the first item in the self-stack to\n-    // get to the one we really want.\n+    // The self-object will arrive in the backwarding function via the\n+    // llenv argument, but we need to jump past the first item in the\n+    // self-stack to get to the one we really want.\n \n     // Cast to self-stack's type.\n     let llenv = bcx.build.PointerCast(\n@@ -717,8 +705,8 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         bcx.build.PointerCast(llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n     llouter_mthd = bcx.build.Load(llouter_mthd);\n \n-    // Set up the three implicit arguments to the outer method we'll need\n-    // to call.\n+    // Set up the three implicit arguments to the outer method we'll need to\n+    // call.\n     let self_arg = llself_obj_ptr;\n     let llouter_mthd_args: [ValueRef] = ~[llretptr, fcx.lltaskptr, self_arg];\n \n@@ -831,8 +819,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Placeholder for non-existent typarams, since anon objs don't have them.\n     let typarams_ty: ty::t = ty::mk_imm_tup(cx.ccx.tcx, ~[]);\n \n-    // Tuple type for body:\n-    // [tydesc, [typaram, ...], [field, ...], inner_obj]\n+    // Tuple type for body: [tydesc, [typaram, ...], [field, ...], inner_obj]\n \n     let body_ty: ty::t =\n         ty::mk_imm_tup(cx.ccx.tcx,\n@@ -951,9 +938,9 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n     let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n \n-    // Every method on an object gets its node_id inserted into the\n-    // crate-wide item_ids map, together with the ValueRef that points to\n-    // where that method's definition will be in the executable.\n+    // Every method on an object gets its node_id inserted into the crate-wide\n+    // item_ids map, together with the ValueRef that points to where that\n+    // method's definition will be in the executable.\n     cx.ccx.item_ids.insert(m.node.id, llfn);\n     cx.ccx.item_symbols.insert(m.node.id, s);\n     trans_fn(mcx, m.span, m.node.meth, llfn, some(self_ty), ty_params,\n@@ -999,3 +986,13 @@ fn populate_self_stack(bcx: @block_ctxt,\n \n     ret self_stack;\n }\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}]}