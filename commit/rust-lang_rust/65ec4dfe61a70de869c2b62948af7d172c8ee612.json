{"sha": "65ec4dfe61a70de869c2b62948af7d172c8ee612", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZWM0ZGZlNjFhNzBkZTg2OWMyYjYyOTQ4YWY3ZDE3MmM4ZWU2MTI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-16T05:20:58Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-16T08:52:31Z"}, "message": "Improve diagnostics for duplicate names", "tree": {"sha": "a63682c83db117a4471931c2b738411242f18e0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a63682c83db117a4471931c2b738411242f18e0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65ec4dfe61a70de869c2b62948af7d172c8ee612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65ec4dfe61a70de869c2b62948af7d172c8ee612", "html_url": "https://github.com/rust-lang/rust/commit/65ec4dfe61a70de869c2b62948af7d172c8ee612", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65ec4dfe61a70de869c2b62948af7d172c8ee612/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5880fff990ced4815130582e68c9036d7cf7dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5880fff990ced4815130582e68c9036d7cf7dcb", "html_url": "https://github.com/rust-lang/rust/commit/d5880fff990ced4815130582e68c9036d7cf7dcb"}], "stats": {"total": 167, "additions": 63, "deletions": 104}, "files": [{"sha": "08b5e51729013dab28172b63fd54c8d8303c4087", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/65ec4dfe61a70de869c2b62948af7d172c8ee612/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ec4dfe61a70de869c2b62948af7d172c8ee612/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=65ec4dfe61a70de869c2b62948af7d172c8ee612", "patch": "@@ -105,36 +105,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// otherwise, reports an error.\n     fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n         let binding = def.to_name_binding();\n-        let old_binding = match parent.try_define_child(name, ns, binding.clone()) {\n-            Ok(()) => return,\n-            Err(old_binding) => old_binding,\n-        };\n-\n-        let span = binding.span.unwrap_or(DUMMY_SP);\n-        if !old_binding.is_extern_crate() && !binding.is_extern_crate() {\n-            // Record an error here by looking up the namespace that had the duplicate\n-            let ns_str = match ns { TypeNS => \"type or module\", ValueNS => \"value\" };\n-            let resolution_error = ResolutionError::DuplicateDefinition(ns_str, name);\n-            let mut err = resolve_struct_error(self, span, resolution_error);\n-\n-            if let Some(sp) = old_binding.span {\n-                let note = format!(\"first definition of {} `{}` here\", ns_str, name);\n-                err.span_note(sp, &note);\n-            }\n-            err.emit();\n-        } else if old_binding.is_extern_crate() && binding.is_extern_crate() {\n-            span_err!(self.session,\n-                      span,\n-                      E0259,\n-                      \"an external crate named `{}` has already been imported into this module\",\n-                      name);\n-        } else {\n-            span_err!(self.session,\n-                      span,\n-                      E0260,\n-                      \"the name `{}` conflicts with an external crate \\\n-                      that has been imported into this module\",\n-                      name);\n+        if let Err(old_binding) = parent.try_define_child(name, ns, binding.clone()) {\n+            self.report_conflict(parent, name, ns, old_binding, &binding);\n         }\n     }\n "}, {"sha": "6313d7b70366a9c9ee516fa7023babea92c81a2c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/65ec4dfe61a70de869c2b62948af7d172c8ee612/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ec4dfe61a70de869c2b62948af7d172c8ee612/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=65ec4dfe61a70de869c2b62948af7d172c8ee612", "patch": "@@ -183,8 +183,6 @@ pub enum ResolutionError<'a> {\n     UndeclaredLabel(&'a str),\n     /// error E0427: cannot use `ref` binding mode with ...\n     CannotUseRefBindingModeWith(&'a str),\n-    /// error E0428: duplicate definition\n-    DuplicateDefinition(&'a str, Name),\n     /// error E0429: `self` imports are only allowed within a { } list\n     SelfImportsOnlyAllowedWithin,\n     /// error E0430: `self` import can only appear once in the list\n@@ -490,14 +488,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                              \"cannot use `ref` binding mode with {}\",\n                              descr)\n         }\n-        ResolutionError::DuplicateDefinition(namespace, name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0428,\n-                             \"duplicate definition of {} `{}`\",\n-                             namespace,\n-                             name)\n-        }\n         ResolutionError::SelfImportsOnlyAllowedWithin => {\n             struct_span_err!(resolver.session,\n                              span,\n@@ -3530,8 +3520,62 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n     }\n-}\n \n+    fn report_conflict(&self,\n+                       parent: Module,\n+                       name: Name,\n+                       ns: Namespace,\n+                       binding: &NameBinding,\n+                       old_binding: &NameBinding) {\n+        // Error on the second of two conflicting names\n+        if old_binding.span.unwrap().lo > binding.span.unwrap().lo {\n+            return self.report_conflict(parent, name, ns, old_binding, binding);\n+        }\n+\n+        let container = match parent.def {\n+            Some(Def::Mod(_)) => \"module\",\n+            Some(Def::Trait(_)) => \"trait\",\n+            None => \"block\",\n+            _ => \"enum\",\n+        };\n+\n+        let (participle, noun) = match old_binding.is_import() || old_binding.is_extern_crate() {\n+            true => (\"imported\", \"import\"),\n+            false => (\"defined\", \"definition\"),\n+        };\n+\n+        let span = binding.span.unwrap();\n+        let msg = {\n+            let kind = match (ns, old_binding.module()) {\n+                (ValueNS, _) => \"a value\",\n+                (TypeNS, Some(module)) if module.extern_crate_id.is_some() => \"an extern crate\",\n+                (TypeNS, Some(module)) if module.is_normal() => \"a module\",\n+                (TypeNS, Some(module)) if module.is_trait() => \"a trait\",\n+                (TypeNS, _) => \"a type\",\n+            };\n+            format!(\"{} named `{}` has already been {} in this {}\",\n+                    kind, name, participle, container)\n+        };\n+\n+        let mut err = match (old_binding.is_extern_crate(), binding.is_extern_crate()) {\n+            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n+            (true, _) | (_, true) if binding.is_import() || old_binding.is_import() =>\n+                struct_span_err!(self.session, span, E0254, \"{}\", msg),\n+            (true, _) | (_, true) => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n+            _ => match (old_binding.is_import(), binding.is_import()) {\n+                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n+                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n+                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n+            },\n+        };\n+\n+        let span = old_binding.span.unwrap();\n+        if span != codemap::DUMMY_SP {\n+            err.span_note(span, &format!(\"previous {} of `{}` here\", noun, name));\n+        }\n+        err.emit();\n+    }\n+}\n \n fn names_to_string(names: &[Name]) -> String {\n     let mut first = true;"}, {"sha": "bca79df7a9194240095aab0c585c8668e76c51d6", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 6, "deletions": 63, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/65ec4dfe61a70de869c2b62948af7d172c8ee612/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ec4dfe61a70de869c2b62948af7d172c8ee612/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=65ec4dfe61a70de869c2b62948af7d172c8ee612", "patch": "@@ -513,7 +513,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 let imported_binding = directive.import(binding, privacy_error);\n                 let conflict = module_.try_define_child(target, ns, imported_binding);\n                 if let Err(old_binding) = conflict {\n-                    self.report_conflict(target, ns, &directive.import(binding, None), old_binding);\n+                    let binding = &directive.import(binding, None);\n+                    self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n                 }\n             }\n \n@@ -650,67 +651,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         return Success(());\n     }\n \n-    fn report_conflict(&mut self,\n-                       name: Name,\n-                       ns: Namespace,\n-                       binding: &NameBinding,\n-                       old_binding: &NameBinding) {\n-        // Error on the second of two conflicting imports\n-        if old_binding.is_import() && binding.is_import() &&\n-           old_binding.span.unwrap().lo > binding.span.unwrap().lo {\n-            self.report_conflict(name, ns, old_binding, binding);\n-            return;\n-        }\n-\n-        if old_binding.is_extern_crate() {\n-            let msg = format!(\"import `{0}` conflicts with imported crate \\\n-                               in this module (maybe you meant `use {0}::*`?)\",\n-                              name);\n-            span_err!(self.resolver.session, binding.span.unwrap(), E0254, \"{}\", &msg);\n-        } else if old_binding.is_import() {\n-            let ns_word = match (ns, old_binding.module()) {\n-                (ValueNS, _) => \"value\",\n-                (TypeNS, Some(module)) if module.is_normal() => \"module\",\n-                (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n-                (TypeNS, _) => \"type\",\n-            };\n-            let mut err = struct_span_err!(self.resolver.session,\n-                                           binding.span.unwrap(),\n-                                           E0252,\n-                                           \"a {} named `{}` has already been imported \\\n-                                            in this module\",\n-                                           ns_word,\n-                                           name);\n-            err.span_note(old_binding.span.unwrap(),\n-                          &format!(\"previous import of `{}` here\", name));\n-            err.emit();\n-        } else if ns == ValueNS { // Check for item conflicts in the value namespace\n-            let mut err = struct_span_err!(self.resolver.session,\n-                                           binding.span.unwrap(),\n-                                           E0255,\n-                                           \"import `{}` conflicts with value in this module\",\n-                                           name);\n-            err.span_note(old_binding.span.unwrap(), \"conflicting value here\");\n-            err.emit();\n-        } else { // Check for item conflicts in the type namespace\n-            let (what, note) = match old_binding.module() {\n-                Some(ref module) if module.is_normal() =>\n-                    (\"existing submodule\", \"note conflicting module here\"),\n-                Some(ref module) if module.is_trait() =>\n-                    (\"trait in this module\", \"note conflicting trait here\"),\n-                _ => (\"type in this module\", \"note conflicting type here\"),\n-            };\n-            let mut err = struct_span_err!(self.resolver.session,\n-                                           binding.span.unwrap(),\n-                                           E0256,\n-                                           \"import `{}` conflicts with {}\",\n-                                           name,\n-                                           what);\n-            err.span_note(old_binding.span.unwrap(), note);\n-            err.emit();\n-        }\n-    }\n-\n     // Miscellaneous post-processing, including recording reexports, recording shadowed traits,\n     // reporting conflicts, reporting the PRIVATE_IN_PUBLIC lint, and reporting unresolved imports.\n     fn finalize_resolutions(&mut self, module: Module<'b>, report_unresolved_imports: bool) {\n@@ -720,7 +660,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         let mut reexports = Vec::new();\n         for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n-            resolution.report_conflicts(|b1, b2| self.report_conflict(name, ns, b1, b2));\n+            resolution.report_conflicts(|b1, b2| {\n+                self.resolver.report_conflict(module, name, ns, b1, b2)\n+            });\n+\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n                 None => continue,"}]}