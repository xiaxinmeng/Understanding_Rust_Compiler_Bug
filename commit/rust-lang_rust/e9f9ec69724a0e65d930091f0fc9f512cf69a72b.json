{"sha": "e9f9ec69724a0e65d930091f0fc9f512cf69a72b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZjllYzY5NzI0YTBlNjVkOTMwMDkxZjBmYzlmNTEyY2Y2OWE3MmI=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-24T00:30:59Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-26T01:12:39Z"}, "message": "Update docs for macro-related stuff.", "tree": {"sha": "8ba70a4fc50532467b57b5b3f219a94eca6fb7c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ba70a4fc50532467b57b5b3f219a94eca6fb7c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9f9ec69724a0e65d930091f0fc9f512cf69a72b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9f9ec69724a0e65d930091f0fc9f512cf69a72b", "html_url": "https://github.com/rust-lang/rust/commit/e9f9ec69724a0e65d930091f0fc9f512cf69a72b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9f9ec69724a0e65d930091f0fc9f512cf69a72b/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aae212727d40140181ca6f481b7e4bc75a64c796", "url": "https://api.github.com/repos/rust-lang/rust/commits/aae212727d40140181ca6f481b7e4bc75a64c796", "html_url": "https://github.com/rust-lang/rust/commit/aae212727d40140181ca6f481b7e4bc75a64c796"}], "stats": {"total": 131, "additions": 78, "deletions": 53}, "files": [{"sha": "3cf28c03e0087bca8793f5f1de0b28df7653908b", "filename": "doc/rust.texi", "status": "modified", "additions": 78, "deletions": 53, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/e9f9ec69724a0e65d930091f0fc9f512cf69a72b/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/e9f9ec69724a0e65d930091f0fc9f512cf69a72b/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=e9f9ec69724a0e65d930091f0fc9f512cf69a72b", "patch": "@@ -512,7 +512,7 @@ of St. Andrews (St. Andrews, Fife, UK).\n Additional specific influences can be seen from the following languages:\n @itemize\n @item The structural algebraic types and compilation manager of SML.\n-@item The syntax-extension systems of Camlp4 and the Common Lisp readtable.\n+@c @item The syntax-extension systems of Camlp4 and the Common Lisp readtable.\n @item The deterministic destructor system of C++.\n @end itemize\n \n@@ -599,12 +599,12 @@ U+0009 (tab, @code{'\\t'}), U+000A (LF, @code{'\\n'}), U+000D (CR, @code{'\\r'}).\n A @dfn{single-line comment} is any sequence of Unicode characters beginning\n with U+002F U+002F (@code{\"//\"}) and extending to the next U+000A character,\n @emph{excluding} cases in which such a sequence occurs within a string literal\n-token or a syntactic extension token.\n+token.\n \n A @dfn{multi-line comments} is any sequence of Unicode characters beginning\n with U+002F U+002A (@code{\"/*\"}) and ending with U+002A U+002F (@code{\"*/\"}),\n @emph{excluding} cases in which such a sequence occurs within a string literal\n-token or a syntactic extension token.  Multi-line comments may be nested.\n+token.  Multi-line comments may be nested.\n \n @node       Ref.Lex.Ident\n @subsection Ref.Lex.Ident\n@@ -875,11 +875,11 @@ escaped in order to denote @emph{itself}.\n @c * Ref.Lex.Syntax::              Syntactic extension tokens.\n \n Syntactic extensions are marked with the @emph{pound} sigil U+0023 (@code{#}),\n-followed by a qualified name of a compile-time imported module item, an\n-optional parenthesized list of @emph{parsed expressions}, and an optional\n-brace-enclosed region of free-form text (with brace-matching and\n-brace-escaping used to determine the limit of the\n-region). @xref{Ref.Comp.Syntax}.\n+followed by an identifier, one of @code{fmt}, @code{env},\n+@code{concat_idents}, @code{ident_to_str}, @code{log_syntax}, @code{macro}, or\n+the name of a user-defined macro. This is followed by a vector literal. (Its\n+value will be interpreted syntactically; in particular, it need not be\n+well-typed.)\n \n @emph{TODO: formalize those terms more}.\n \n@@ -1039,7 +1039,6 @@ Compilation Manager, a @emph{unit} in the Owens and Flatt module system, or a\n @itemize\n @item Metadata about the crate, such as author, name, version, and copyright.\n @item The source-file and directory modules that make up the crate.\n-@item The set of syntax extensions to enable for the crate.\n @item Any external crates or native modules that the crate imports to its top level.\n @item The organization of the crate's internal namespace.\n @item The set of names exported from the crate.\n@@ -1086,11 +1085,13 @@ or Mach-O. The loadable object contains extensive DWARF metadata, describing:\n derived from the same @code{use} directives that guided compile-time imports.\n @end itemize\n \n-The @code{syntax} directives of a crate are similar to the @code{use}\n-directives, except they govern the syntax extension namespace (accessed\n-through the syntax-extension sigil @code{#}, @pxref{Ref.Comp.Syntax})\n-available only at compile time. A @code{syntax} directive also makes its\n-extension available to all subsequent directives in the crate file.\n+@c This might come along sometime in the future.\n+\n+@c The @code{syntax} directives of a crate are similar to the @code{use}\n+@c directives, except they govern the syntax extension namespace (accessed\n+@c through the syntax-extension sigil @code{#}, @pxref{Ref.Comp.Syntax})\n+@c available only at compile time. A @code{syntax} directive also makes its\n+@c extension available to all subsequent directives in the crate file.\n \n An example of a crate:\n \n@@ -1104,9 +1105,6 @@ meta (author = \"Jane Doe\",\n // Import a module.\n use std (ver = \"1.0\");\n \n-// Activate a syntax-extension.\n-syntax re;\n-\n // Define some modules.\n mod foo = \"foo.rs\";\n mod bar @{\n@@ -1123,8 +1121,8 @@ mod bar @{\n \n In a crate, a @code{meta} directive associates free form key-value metadata\n with the crate. This metadata can, in turn, be used in providing partial\n-matching parameters to syntax-extension loading and crate importing\n-directives, denoted by @code{syntax} and @code{use} keywords respectively.\n+matching parameters to crate importing directives, denoted by the @code{use}\n+keyword.\n \n Alternatively, metadata can serve as a simple form of documentation.\n \n@@ -1133,49 +1131,76 @@ Alternatively, metadata can serve as a simple form of documentation.\n @c * Ref.Comp.Syntax::        Syntax extension.\n @cindex Syntax extension\n \n+@c , statement or item\n Rust provides a notation for @dfn{syntax extension}. The notation is a marked\n-syntactic form that can appear as an expression, statement or item in the body\n-of a Rust program, or as a directive in a Rust crate, and which causes the\n-text enclosed within the marked form to be translated through a named\n-extension function loaded into the compiler at compile-time.\n-\n-The compile-time extension function must return a value of the corresponding\n-Rust AST type, either an expression node, a statement node or an item\n-node. @footnote{The syntax-extension system is analogous to the extensible\n-reader system provided by Lisp @emph{readtables}, or the Camlp4 system of\n-Objective Caml.}  @xref{Ref.Lex.Syntax}.\n-\n-A syntax extension is enabled by a @code{syntax} directive, which must occur\n-in a crate file. When the Rust compiler encounters a @code{syntax} directive\n-in a crate file, it immediately loads the named syntax extension, and makes it\n-available for all subsequent crate directives within the enclosing block scope\n-of the crate file, and all Rust source files referenced as modules from the\n-enclosing block scope of the crate file.\n-\n-For example, this extension might provide a syntax for regular\n-expression literals:\n+syntactic form that can appear as an expression in the body of a Rust\n+program. Syntax extensions make use of bracketed lists, which are\n+syntactically vector literals, but which have no run-time semantics. After\n+parsing, the notation is translated into Rust expressions. The name of the\n+extension determines the translation performed. The name may be one of the\n+built-in extensions listed below, or a user-defined extension, defined using\n+@code{macro}.\n \n-@example\n-// In a crate file:\n+@itemize\n+@item @code{fmt} expands into code to produce a formatted string, similar to \n+      @code{printf} from C.\n+@item @code{env} expands into a string literal containing the value of that\n+      environment variable at compile-time.\n+@item @code{concat_idents} expands into an identifier which is the \n+      concatenation of its arguments.\n+@item @code{ident_to_str} expands into a string literal containing the name of\n+      its argument (which must be a literal).\n+@item @code{log_syntax} causes the compiler to pretty-print its arguments.\n+@end itemize\n \n-// Requests the 're' syntax extension from the compilation environment.\n-syntax re;\n+Finally, @code{macro} is used to define a new macro. A macro can abstract over\n+second-class Rust concepts that are present in syntax. The arguments to\n+@code{macro} are a bracketed list of pairs (two-element lists). The pairs\n+consist of an invocation and the syntax to expand into. An example:\n \n-// Also declares an import dependency on the module 're'.\n-use re;\n+@example\n+#macro[[#apply[fn, [args, ...]], fn(args, ...)]];\n+@end example\n \n-// Reference to a Rust source file as a module in the crate.\n-mod foo = \"foo.rs\";\n+In this case, the invocation @code{#apply[sum, 5, 8, 6]} expands to\n+@code{sum(5,8,6)}. If @code{...} follows an expression (which need not be as\n+simple as a single identifier) in the input syntax, the matcher will expect an\n+arbitrary number of occurences of the thing preceeding it, and bind syntax to\n+the identifiers it contains. If it follows an expression in the output syntax,\n+it will transcribe that expression repeatedly, according to the identifiers\n+(bound to syntax) that it contains.\n \n-@dots{}\n+The behavior of @code{...} is known as Macro By Example. It allows you to\n+write a macro with arbitrary repetition by specifying only one case of that\n+repetition, and following it by @code{...}, both where the repeated input is\n+matched, and where the repeated output must be transcribed. A more\n+sophisticated example:\n \n-// In the source file \"foo.rs\", use the #re syntax extension and\n-// the re module at run-time.\n-let s: str = get_string();\n-let pattern: regex = #re.pat@{ aa+b? @};\n-let matched: bool = re.match(pattern, s);\n+@example\n+#macro[#zip_literals[[x, ...], [y, ...]], \n+       [[x, y], ...]];\n+#macro[#unzip_literals[[x, y], ...],\n+       [[x, ...], [y, ...]]];\n @end example\n \n+In this case, @code{#zip_literals[[1,2,3], [1,2,3]]} expands to\n+@code{[[1,1],[2,2],[3,3]]}, and @code{#unzip_literals[[1,1], [2,2], [3,3]]}\n+expands to @code{[[1,2,3],[1,2,3]]}.\n+\n+Macro expansion takes place outside-in: that is,\n+@code{#unzip_literals[#zip_literals[[1,2,3],[1,2,3]]]} will fail because\n+@code{unzip_literals} expects a list, not a macro invocation, as an\n+argument.\n+\n+@c \n+The macro system currently has some limitations. It's not possible to\n+destructure anything other than vector literals (therefore, the arguments to\n+complicated macros will tend to be an ocean of square brackets). Macro\n+invocations and @code{...} can only appear in expression positions. Finally,\n+macro expansion is currently unhygienic. That is, name collisions between\n+macro-generated and user-written code can cause unintentional capture.\n+\n+\n @page\n @node    Ref.Mem\n @section Ref.Mem"}]}