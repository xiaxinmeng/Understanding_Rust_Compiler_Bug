{"sha": "60388303c770a6e9409f3afa75d31d9125f871e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMzg4MzAzYzc3MGE2ZTk0MDlmM2FmYTc1ZDMxZDkxMjVmODcxZTM=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-05T16:46:41Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T17:23:58Z"}, "message": "Fixes warnings and errors introduced while moving code around", "tree": {"sha": "bc5a7ed9e9e243a982588c5d7070a13297cc5534", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc5a7ed9e9e243a982588c5d7070a13297cc5534"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60388303c770a6e9409f3afa75d31d9125f871e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60388303c770a6e9409f3afa75d31d9125f871e3", "html_url": "https://github.com/rust-lang/rust/commit/60388303c770a6e9409f3afa75d31d9125f871e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60388303c770a6e9409f3afa75d31d9125f871e3/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd3dd803a7b10e89253068202890a200d4b88eb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd3dd803a7b10e89253068202890a200d4b88eb5", "html_url": "https://github.com/rust-lang/rust/commit/cd3dd803a7b10e89253068202890a200d4b88eb5"}], "stats": {"total": 412, "additions": 199, "deletions": 213}, "files": [{"sha": "c210f80431bd7d10681fea9e111eb0e88f2295b3", "filename": "src/Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -137,6 +137,9 @@ dependencies = [\n  \"libc 0.2.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n "}, {"sha": "f557dcc476381c23b2dd080ac99f80f619d66352", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -38,3 +38,6 @@ getopts = \"0.2\"\n rustc-serialize = \"0.3\"\n gcc = \"0.3.50\"\n libc = \"0.2\"\n+serde = \"1.0\"\n+serde_json = \"1.0\"\n+serde_derive = \"1.0\""}, {"sha": "b5ae6aa1d2700023cb13b594ca956618bbb524b8", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -11,10 +11,10 @@\n use serde::{Serialize, Deserialize};\n \n use std::cell::RefCell;\n-use std::collections::HashSet;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::fs;\n+use std::ops::Deref;\n \n use compile;\n use install;\n@@ -26,6 +26,8 @@ use check;\n use flags::Subcommand;\n use doc;\n \n+pub use Compiler;\n+\n pub struct Builder<'a> {\n     pub build: &'a Build,\n     pub top_stage: u32,\n@@ -44,7 +46,6 @@ impl<'a> Deref for Builder<'a> {\n \n pub trait Step<'a>: Sized {\n     type Output: Serialize + Deserialize<'a>;\n-    const NAME: &'static str;\n \n     const DEFAULT: bool = false;\n \n@@ -164,7 +165,7 @@ impl<'a> Builder<'a> {\n                 compile::StartupObjects),\n             Kind::Test => check!(builder, paths, check::Tidy, check::Bootstrap, check::Compiletest,\n                 check::Krate, check::KrateLibrustc, check::Linkcheck, check::Cargotest,\n-                check::TestCargo, check::Docs, check::ErrorIndex, check::Distcheck),\n+                check::Cargo, check::Docs, check::ErrorIndex, check::Distcheck),\n             Kind::Bench => check!(builder, paths, check::Krate, check::KrateLibrustc),\n             Kind::Doc => builder.default_doc(Some(paths)),\n             Kind::Dist => check!(builder, paths, dist::Docs, dist::Mingw, dist::Rustc,\n@@ -177,7 +178,7 @@ impl<'a> Builder<'a> {\n \n     pub fn default_doc(&self, paths: Option<&[PathBuf]>) {\n         let paths = paths.unwrap_or(&[]);\n-        check!(self, paths, doc::UnstableBook, doc::UnstableBookGen, doc::Rustbook, doc::Book,\n+        check!(self, paths, doc::UnstableBook, doc::UnstableBookGen, doc::Rustbook, doc::TheBook,\n             doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex,\n             doc::Nomicon, doc::Reference);\n     }\n@@ -216,7 +217,6 @@ impl<'a> Builder<'a> {\n         }\n         impl<'a> Step<'a> for Libdir<'a> {\n             type Output = PathBuf;\n-            const NAME: &'static str = \"sysroot libdir\";\n             fn run(self, builder: &Builder) -> PathBuf {\n                 let sysroot = builder.sysroot(self.compiler)\n                     .join(\"lib\").join(\"rustlib\").join(self.target).join(\"lib\");"}, {"sha": "0d838a507ce95dd9c2758d5423badf38ec43bd48", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -37,7 +37,7 @@ use tool::Tool;\n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n /// The two modes of the test runner; tests or benchmarks.\n-#[derive(Copy, Clone)]\n+#[derive(Serialize, Copy, Clone)]\n pub enum TestKind {\n     /// Run `cargo test`\n     Test,\n@@ -157,7 +157,7 @@ impl<'a> Step<'a> for Cargotest<'a> {\n     /// test` to ensure that we don't regress the test suites there.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let compiler = builder.compiler(self.stage, host);\n+        let compiler = builder.compiler(self.stage, self.host);\n         builder.ensure(compile::Rustc { compiler, target: compiler.host });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n@@ -170,8 +170,8 @@ impl<'a> Step<'a> for Cargotest<'a> {\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n         try_run(build, cmd.arg(&build.initial_cargo)\n                           .arg(&out_dir)\n-                          .env(\"RUSTC\", build.compiler_path(&compiler))\n-                          .env(\"RUSTDOC\", build.rustdoc(&compiler)));\n+                          .env(\"RUSTC\", build.compiler_path(compiler))\n+                          .env(\"RUSTDOC\", build.rustdoc(compiler)));\n     }\n }\n \n@@ -194,10 +194,10 @@ impl<'a> Step<'a> for Cargo<'a> {\n         path.ends_with(\"cargo\") // FIXME: Why is this not src/tools/cargo?\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n-        builder.ensure(TestCargo {\n-            compiler: builder.compiler(builder.top_stage, host),\n-            target,\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+        builder.ensure(Cargotest {\n+            stage: builder.top_stage,\n+            host: target,\n         });\n     }\n \n@@ -209,7 +209,7 @@ impl<'a> Step<'a> for Cargo<'a> {\n         // Configure PATH to find the right rustc. NB. we have to use PATH\n         // and not RUSTC because the Cargo test suite has tests that will\n         // fail if rustc is not spelled `rustc`.\n-        let path = build.sysroot(compiler).join(\"bin\");\n+        let path = builder.sysroot(compiler).join(\"bin\");\n         let old_path = env::var_os(\"PATH\").unwrap_or_default();\n         let newpath = env::join_paths(\n             iter::once(path).chain(env::split_paths(&old_path))\n@@ -312,7 +312,7 @@ impl<'a> Step<'a> for Tidy<'a> {\n \n         let _folder = build.fold_output(|| \"tidy\");\n         println!(\"tidy check ({})\", host);\n-        let mut cmd = build.tool_cmd(Tool::Tidy);\n+        let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(build.src.join(\"src\"));\n         if !build.config.vendor {\n             cmd.arg(\"--no-vendor\");\n@@ -585,7 +585,7 @@ impl<'a> Step<'a> for Compiletest<'a> {\n         // of them!\n \n         cmd.arg(\"--compile-lib-path\").arg(build.rustc_libdir(compiler));\n-        cmd.arg(\"--run-lib-path\").arg(build.sysroot_libdir(compiler, target));\n+        cmd.arg(\"--run-lib-path\").arg(builder.sysroot_libdir(compiler, target));\n         cmd.arg(\"--rustc-path\").arg(build.compiler_path(compiler));\n         cmd.arg(\"--rustdoc-path\").arg(build.rustdoc(compiler));\n         cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n@@ -608,7 +608,7 @@ impl<'a> Step<'a> for Compiletest<'a> {\n             flags.push(\"-g\".to_string());\n         }\n \n-        let mut hostflags = build.rustc_flags(&compiler.host);\n+        let mut hostflags = build.rustc_flags(compiler.host);\n         hostflags.extend(flags.clone());\n         cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n@@ -801,7 +801,7 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n         let output = dir.join(\"error-index.md\");\n \n         let _time = util::timeit();\n-        build.run(build.tool_cmd(Tool::ErrorIndex)\n+        build.run(builder.tool_cmd(Tool::ErrorIndex)\n                     .arg(\"markdown\")\n                     .arg(&output)\n                     .env(\"CFG_BUILD\", &build.build));\n@@ -810,7 +810,7 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n     }\n }\n \n-fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n+fn markdown_test(build: &Build, compiler: Compiler, markdown: &Path) {\n     let mut file = t!(File::open(markdown));\n     let mut contents = String::new();\n     t!(file.read_to_string(&mut contents));\n@@ -862,7 +862,6 @@ pub struct KrateLibrustc<'a> {\n \n impl<'a> Step<'a> for KrateLibrustc<'a> {\n     type Output = ();\n-    const NAME: &'static str = \"check librustc\";\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -1072,7 +1071,7 @@ impl<'a> Step<'a> for Krate<'a> {\n         // Pass in some standard flags then iterate over the graph we've discovered\n         // in `cargo metadata` with the maps above and figure out what `-p`\n         // arguments need to get passed.\n-        let mut cargo = build.cargo(&compiler, mode, target, test_kind.subcommand());\n+        let mut cargo = build.cargo(compiler, mode, target, test_kind.subcommand());\n         cargo.arg(\"--manifest-path\")\n             .arg(build.src.join(path).join(\"Cargo.toml\"))\n             .arg(\"--features\").arg(features);\n@@ -1115,7 +1114,7 @@ impl<'a> Step<'a> for Krate<'a> {\n         // Note that to run the compiler we need to run with the *host* libraries,\n         // but our wrapper scripts arrange for that to be the case anyway.\n         let mut dylib_path = dylib_path();\n-        dylib_path.insert(0, build.sysroot_libdir(&compiler, target));\n+        dylib_path.insert(0, builder.sysroot_libdir(compiler, target));\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n         if target.contains(\"emscripten\") || build.remote_tested(target) {\n@@ -1132,10 +1131,10 @@ impl<'a> Step<'a> for Krate<'a> {\n \n         if target.contains(\"emscripten\") {\n             build.run(&mut cargo);\n-            krate_emscripten(build, &compiler, target, mode);\n+            krate_emscripten(build, compiler, target, mode);\n         } else if build.remote_tested(target) {\n             build.run(&mut cargo);\n-            krate_remote(builder, &compiler, target, mode);\n+            krate_remote(builder, compiler, target, mode);\n         } else {\n             cargo.args(&build.flags.cmd.test_args());\n             try_run(build, &mut cargo);\n@@ -1144,7 +1143,7 @@ impl<'a> Step<'a> for Krate<'a> {\n }\n \n fn krate_emscripten(build: &Build,\n-                    compiler: &Compiler,\n+                    compiler: Compiler,\n                     target: &str,\n                     mode: Mode) {\n     let out_dir = build.cargo_out(compiler, mode, target);\n@@ -1162,10 +1161,11 @@ fn krate_emscripten(build: &Build,\n     }\n }\n \n-fn krate_remote(build: &Builder,\n-                compiler: &Compiler,\n+fn krate_remote(builder: &Builder,\n+                compiler: Compiler,\n                 target: &str,\n                 mode: Mode) {\n+    let build = builder.build;\n     let out_dir = build.cargo_out(compiler, mode, target);\n     let tests = find_tests(&out_dir.join(\"deps\"), target);\n \n@@ -1269,7 +1269,7 @@ impl<'a> Step<'a> for RemoteCopyLibs<'a> {\n         build.run(&mut cmd);\n \n         // Push all our dylibs to the emulator\n-        for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {\n+        for f in t!(builder.sysroot_libdir(compiler, target).read_dir()) {\n             let f = t!(f);\n             let name = f.file_name().into_string().unwrap();\n             if util::is_dylib(&name) {\n@@ -1359,7 +1359,7 @@ impl<'a> Step<'a> for Distcheck {\n #[derive(Serialize)]\n pub struct Bootstrap;\n \n-impl<'a> for Step<'a> Bootstrap {\n+impl<'a> Step<'a> for Bootstrap {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;"}, {"sha": "f64aa636da10d189de12847a9e199f8e14319ae7", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -28,9 +28,11 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use rustc_serialize::json;\n \n-use channel::GitInfo;\n use util::{exe, libdir, is_dylib, copy};\n use {Build, Compiler, Mode};\n+use native;\n+\n+use builder::{Step, Builder};\n \n //\n //    // Crates which have build scripts need to rely on this rule to ensure that\n@@ -95,39 +97,39 @@ use {Build, Compiler, Mode};\n // different compiler, or from actually building the crate itself (the `dep`\n // rule). The `run` rule then mirrors these three cases and links the cases\n // forward into the compiler sysroot specified from the correct location.\n-fn crate_rule<'a, 'b>(build: &'a Build,\n-                        rules: &'b mut Rules<'a>,\n-                        krate: &'a str,\n-                        dep: &'a str,\n-                        link: fn(&Build, &Compiler, &Compiler, &str))\n-                        -> RuleBuilder<'a, 'b> {\n-    let mut rule = rules.build(&krate, \"path/to/nowhere\");\n-    rule.dep(move |s| {\n-            if build.force_use_stage1(&s.compiler(), s.target) {\n-                s.host(&build.build).stage(1)\n-            } else if s.host == build.build {\n-                s.name(dep)\n-            } else {\n-                s.host(&build.build)\n-            }\n-        })\n-        .run(move |s| {\n-            if build.force_use_stage1(&s.compiler(), s.target) {\n-                link(build,\n-                        &s.stage(1).host(&build.build).compiler(),\n-                        &s.compiler(),\n-                        s.target)\n-            } else if s.host == build.build {\n-                link(build, &s.compiler(), &s.compiler(), s.target)\n-            } else {\n-                link(build,\n-                        &s.host(&build.build).compiler(),\n-                        &s.compiler(),\n-                        s.target)\n-            }\n-        });\n-        rule\n-}\n+// fn crate_rule<'a, 'b>(build: &'a Build,\n+//                         rules: &'b mut Rules<'a>,\n+//                         krate: &'a str,\n+//                         dep: &'a str,\n+//                         link: fn(&Build, compiler, compiler, &str))\n+//                         -> RuleBuilder<'a, 'b> {\n+//     let mut rule = rules.build(&krate, \"path/to/nowhere\");\n+//     rule.dep(move |s| {\n+//             if build.force_use_stage1(&s.compiler(), s.target) {\n+//                 s.host(&build.build).stage(1)\n+//             } else if s.host == build.build {\n+//                 s.name(dep)\n+//             } else {\n+//                 s.host(&build.build)\n+//             }\n+//         })\n+//         .run(move |s| {\n+//             if build.force_use_stage1(&s.compiler(), s.target) {\n+//                 link(build,\n+//                         &s.stage(1).host(&build.build).compiler(),\n+//                         &s.compiler(),\n+//                         s.target)\n+//             } else if s.host == build.build {\n+//                 link(build, &s.compiler(), &s.compiler(), s.target)\n+//             } else {\n+//                 link(build,\n+//                         &s.host(&build.build).compiler(),\n+//                         &s.compiler(),\n+//                         s.target)\n+//             }\n+//         });\n+//         rule\n+// }\n \n //        rules.build(\"libstd\", \"src/libstd\")\n //             .dep(|s| s.name(\"rustc\").target(s.host))\n@@ -141,7 +143,7 @@ fn crate_rule<'a, 'b>(build: &'a Build,\n #[derive(Serialize)]\n pub struct Std<'a> {\n     pub target: &'a str,\n-    pub compiler: &'a Compiler<'a>,\n+    pub compiler: Compiler<'a>,\n }\n \n impl<'a> Step<'a> for Std<'a> {\n@@ -239,7 +241,7 @@ impl<'a> Step<'a> for Std<'a> {\n \n         run_cargo(build,\n                 &mut cargo,\n-                &libstd_stamp(build, &compiler, target));\n+                &libstd_stamp(build, compiler, target));\n \n         builder.ensure(StdLink {\n             compiler: builder.compiler(compiler.stage, &build.build),\n@@ -287,7 +289,7 @@ impl<'a> Step<'a> for StdLink<'a> {\n                 compiler.host,\n                 target_compiler.host,\n                 target);\n-        let libdir = build.sysroot_libdir(target_compiler, target);\n+        let libdir = builder.sysroot_libdir(target_compiler, target);\n         add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n \n         if target.contains(\"musl\") && !target.contains(\"mips\") {\n@@ -330,7 +332,7 @@ fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n \n #[derive(Serialize)]\n pub struct StartupObjects<'a> {\n-    pub for_compiler: Compiler<'a>,\n+    pub compiler: Compiler<'a>,\n     pub target: &'a str,\n }\n \n@@ -356,17 +358,17 @@ impl<'a> Step<'a> for StartupObjects<'a> {\n     /// no other compilers are guaranteed to be available).\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let for_compiler = self.for_compiler;\n+        let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"pc-windows-gnu\") {\n             return\n         }\n \n-        let compiler = Compiler::new(0, &build.build);\n-        let compiler_path = build.compiler_path(&compiler);\n+        let compiler = builder.compiler(0, &build.build);\n+        let compiler_path = build.compiler_path(compiler);\n         let src_dir = &build.src.join(\"src/rtstartup\");\n         let dst_dir = &build.native_dir(target).join(\"rtstartup\");\n-        let sysroot_dir = &build.sysroot_libdir(for_compiler, target);\n+        let sysroot_dir = &builder.sysroot_libdir(for_compiler, target);\n         t!(fs::create_dir_all(dst_dir));\n         t!(fs::create_dir_all(sysroot_dir));\n \n@@ -485,7 +487,7 @@ pub struct TestLink<'a> {\n     pub target: &'a str,\n }\n \n-impl<'a> Step<'a> for Step<'a> {\n+impl<'a> Step<'a> for TestLink<'a> {\n     type Output = ();\n \n     /// Same as `std_link`, only for libtest\n@@ -500,7 +502,7 @@ impl<'a> Step<'a> for Step<'a> {\n                 compiler.host,\n                 target_compiler.host,\n                 target);\n-        add_to_sysroot(&build.sysroot_libdir(target_compiler, target),\n+        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n                     &libtest_stamp(build, compiler, target));\n     }\n }\n@@ -682,26 +684,26 @@ impl<'a> Step<'a> for RustcLink<'a> {\n                  compiler.host,\n                  target_compiler.host,\n                  target);\n-        add_to_sysroot(&build.sysroot_libdir(target_compiler, target),\n+        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n                        &librustc_stamp(build, compiler, target));\n     }\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+pub fn libstd_stamp(build: &Build, compiler: Compiler, target: &str) -> PathBuf {\n     build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn libtest_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+pub fn libtest_stamp(build: &Build, compiler: Compiler, target: &str) -> PathBuf {\n     build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+pub fn librustc_stamp(build: &Build, compiler: Compiler, target: &str) -> PathBuf {\n     build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n }\n \n@@ -766,14 +768,14 @@ pub struct Assemble<'a> {\n }\n \n impl<'a> Step<'a> for Assemble<'a> {\n-    type Output = ();\n+    type Output = Compiler<'a>;\n \n     /// Prepare a new compiler from the artifacts in `stage`\n     ///\n     /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n     /// must have been previously produced by the `stage - 1` build.build\n     /// compiler.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> Compiler<'a> {\n         let build = builder.build;\n         let target_compiler = self.target_compiler;\n \n@@ -819,24 +821,24 @@ impl<'a> Step<'a> for Assemble<'a> {\n         println!(\"Assembling stage{} compiler ({})\", stage, host);\n \n         // Link in all dylibs to the libdir\n-        let sysroot = build.sysroot(&target_compiler);\n+        let sysroot = builder.sysroot(target_compiler);\n         let sysroot_libdir = sysroot.join(libdir(host));\n         t!(fs::create_dir_all(&sysroot_libdir));\n-        let src_libdir = build.sysroot_libdir(&build_compiler, host);\n+        let src_libdir = builder.sysroot_libdir(build_compiler, host);\n         for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n             let filename = f.file_name().into_string().unwrap();\n             if is_dylib(&filename) {\n                 copy(&f.path(), &sysroot_libdir.join(&filename));\n             }\n         }\n \n-        let out_dir = build.cargo_out(&build_compiler, Mode::Librustc, host);\n+        let out_dir = build.cargo_out(build_compiler, Mode::Librustc, host);\n \n         // Link the compiler binary itself into place\n         let rustc = out_dir.join(exe(\"rustc\", host));\n         let bindir = sysroot.join(\"bin\");\n         t!(fs::create_dir_all(&bindir));\n-        let compiler = build.compiler_path(&target_compiler);\n+        let compiler = build.compiler_path(target_compiler);\n         let _ = fs::remove_file(&compiler);\n         copy(&rustc, &compiler);\n \n@@ -848,6 +850,8 @@ impl<'a> Step<'a> for Assemble<'a> {\n             let _ = fs::remove_file(&rustdoc_dst);\n             copy(&rustdoc_src, &rustdoc_dst);\n         }\n+\n+        target_compiler\n     }\n }\n "}, {"sha": "4a93e50425d4af863bbd57e0eb081a6f57ed46ce", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -37,6 +37,9 @@ use build_helper::output;\n use {Build, Compiler, Mode};\n use channel;\n use util::{cp_r, libdir, is_dylib, cp_filtered, copy, exe};\n+use builder::{Builder, Step};\n+use compile;\n+use tool::{self, Tool};\n \n pub fn pkgname(build: &Build, component: &str) -> String {\n     if component == \"cargo\" {\n@@ -57,8 +60,8 @@ pub fn tmpdir(build: &Build) -> PathBuf {\n     build.out.join(\"tmp/dist\")\n }\n \n-fn rust_installer(build: &Build) -> Command {\n-    build.tool_cmd(&Compiler::new(0, &build.build), \"rust-installer\")\n+fn rust_installer(builder: &Builder) -> Command {\n+    builder.tool_cmd(Tool::RustInstaller)\n }\n \n // rules.dist(\"dist-docs\", \"src/doc\")\n@@ -70,8 +73,8 @@ fn rust_installer(build: &Build) -> Command {\n \n #[derive(Serialize)]\n pub struct Docs<'a> {\n-    stage: u32,\n-    host: &'a str,\n+    pub stage: u32,\n+    pub host: &'a str,\n }\n \n impl<'a> Step<'a> for Docs<'a> {\n@@ -115,7 +118,7 @@ impl<'a> Step<'a> for Docs<'a> {\n         let src = build.out.join(host).join(\"doc\");\n         cp_r(&src, &dst);\n \n-        let mut cmd = rust_installer(build);\n+        let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust-Documentation\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n@@ -320,7 +323,7 @@ impl<'a> Step<'a> for Mingw<'a> {\n         // (which is what we want).\n         make_win_dist(&tmpdir(build), &image, host, &build);\n \n-        let mut cmd = rust_installer(build);\n+        let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust-MinGW\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n@@ -346,8 +349,8 @@ impl<'a> Step<'a> for Mingw<'a> {\n \n #[derive(Serialize)]\n pub struct Rustc<'a> {\n-    stage: u32,\n-    host: &'a str,\n+    pub stage: u32,\n+    pub host: &'a str,\n }\n \n impl<'a> Step<'a> for Rustc<'a> {\n@@ -368,7 +371,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n     }\n \n     /// Creates the `rustc` installer component.\n-    fn run(self, builder: &builder) {\n+    fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let stage = self.stage;\n         let host = self.host;\n@@ -414,7 +417,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n         }\n \n         // Finally, wrap everything up in a nice tarball!\n-        let mut cmd = rust_installer(build);\n+        let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n@@ -432,7 +435,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n \n         fn prepare_image(builder: &Builder, stage: u32, host: &str, image: &Path) {\n             let build = builder.build;\n-            let src = build.sysroot(builder.compiler(stage, host));\n+            let src = builder.sysroot(builder.compiler(stage, host));\n             let libdir = libdir(host);\n \n             // Copy rustc/rustdoc binaries\n@@ -474,13 +477,13 @@ impl<'a> Step<'a> for Rustc<'a> {\n }\n \n //rules.test(\"debugger-scripts\", \"src/etc/lldb_batchmode.py\")\n-//     .run(move |s| dist::debugger_scripts(build, &build.sysroot(&s.compiler()),\n+//     .run(move |s| dist::debugger_scripts(build, &builder.sysroot(&s.compiler()),\n //                                     s.target));\n \n #[derive(Serialize)]\n pub struct DebuggerScripts<'a> {\n-    sysroot: &'a Path,\n-    host: &'a str,\n+    pub sysroot: &'a Path,\n+    pub host: &'a str,\n }\n \n impl<'a> Step<'a> for DebuggerScripts<'a> {\n@@ -596,8 +599,8 @@ pub fn rust_src_installer(build: &Build) -> PathBuf {\n \n #[derive(Serialize)]\n pub struct Analysis<'a> {\n-    compiler: Compiler<'a>,\n-    target: &'a str,\n+    pub compiler: Compiler<'a>,\n+    pub target: &'a str,\n }\n \n impl<'a> Step<'a> for Analysis<'a> {\n@@ -652,7 +655,7 @@ impl<'a> Step<'a> for Analysis<'a> {\n         println!(\"image_src: {:?}, dst: {:?}\", image_src, dst);\n         cp_r(&image_src, &dst);\n \n-        let mut cmd = rust_installer(build);\n+        let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n@@ -784,7 +787,7 @@ impl<'a> Step<'a> for Src {\n         copy_src_dirs(build, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n \n         // Create source tarball in rust-installer format\n-        let mut cmd = rust_installer(build);\n+        let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n@@ -903,7 +906,7 @@ impl<'a> Step<'a> for PlainSourceTarball {\n         if let Some(dir) = tarball.parent() {\n             t!(fs::create_dir_all(dir));\n         }\n-        let mut cmd = rust_installer(build);\n+        let mut cmd = rust_installer(builder);\n         cmd.arg(\"tarball\")\n            .arg(\"--input\").arg(&plain_name)\n            .arg(\"--output\").arg(&tarball)\n@@ -961,8 +964,8 @@ fn write_file(path: &Path, data: &[u8]) {\n \n #[derive(Serialize)]\n pub struct Cargo<'a> {\n-    stage: u32,\n-    target: &'a str,\n+    pub stage: u32,\n+    pub target: &'a str,\n }\n \n impl<'a> Step<'a> for Cargo<'a> {\n@@ -1005,7 +1008,7 @@ impl<'a> Step<'a> for Cargo<'a> {\n         // Prepare the image directory\n         t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n         t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n-        let cargo = build.cargo_out(&compiler, Mode::Tool, target)\n+        let cargo = build.cargo_out(compiler, Mode::Tool, target)\n                          .join(exe(\"cargo\", target));\n         install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n@@ -1032,7 +1035,7 @@ impl<'a> Step<'a> for Cargo<'a> {\n         t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n \n         // Generate the installer tarball\n-        let mut cmd = rust_installer(build);\n+        let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n@@ -1056,8 +1059,8 @@ impl<'a> Step<'a> for Cargo<'a> {\n //      .run(move |s| dist::rls(build, s.stage, s.target));\n #[derive(Serialize)]\n pub struct Rls<'a> {\n-    stage: u32,\n-    target: &'a str,\n+    pub stage: u32,\n+    pub target: &'a str,\n }\n \n impl<'a> Step<'a> for Rls<'a> {\n@@ -1098,7 +1101,7 @@ impl<'a> Step<'a> for Rls<'a> {\n         t!(fs::create_dir_all(&image));\n \n         // Prepare the image directory\n-        let rls = build.cargo_out(&compiler, Mode::Tool, target)\n+        let rls = build.cargo_out(compiler, Mode::Tool, target)\n                          .join(exe(\"rls\", target));\n         install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n@@ -1116,7 +1119,7 @@ impl<'a> Step<'a> for Rls<'a> {\n         t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n \n         // Generate the installer tarball\n-        let mut cmd = rust_installer(build);\n+        let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n@@ -1162,12 +1165,12 @@ impl<'a> Step<'a> for Extended<'a> {\n         path.ends_with(\"cargo\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n         if path.is_none() && !builder.build.config.extended {\n             return;\n         }\n         builder.ensure(Extended {\n-            compiler: builder.compiler(builder.top_stage, host),\n+            stage: builder.top_stage,\n             target: target,\n         });\n     }\n@@ -1180,9 +1183,9 @@ impl<'a> Step<'a> for Extended<'a> {\n         let compiler = builder.compiler(stage, &build.build);\n \n         builder.ensure(Std { compiler, target });\n-        builder.ensure(Rustc { stage, host });\n-        builder.ensure(Mingw { host });\n-        builder.ensure(Docs { stage, host });\n+        builder.ensure(Rustc { stage, host: target });\n+        builder.ensure(Mingw { host: target });\n+        builder.ensure(Docs { stage, host: target });\n         builder.ensure(Cargo { stage, target });\n         builder.ensure(Rls { stage, target });\n         builder.ensure(Analysis { compiler, target });\n@@ -1240,7 +1243,7 @@ impl<'a> Step<'a> for Extended<'a> {\n             input_tarballs.push(tarball);\n         }\n \n-        let mut cmd = rust_installer(build);\n+        let mut cmd = rust_installer(builder);\n         cmd.arg(\"combine\")\n             .arg(\"--product-name=Rust\")\n             .arg(\"--rel-manifest-dir=rustlib\")"}, {"sha": "000ab101d85d51cd0e77b1f915c5141d010c58bd", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -23,10 +23,14 @@ use std::io;\n use std::path::Path;\n use std::process::Command;\n \n-use {Build, Compiler, Mode};\n+use Mode;\n use util::{cp_r, symlink_dir};\n use build_helper::up_to_date;\n \n+use builder::{Builder, Step};\n+use tool::Tool;\n+use compile;\n+\n macro_rules! book {\n     ($($name:ident, $path:expr, $book_name:expr;)+) => {\n         $(\n@@ -37,7 +41,6 @@ macro_rules! book {\n \n         impl<'a> Step<'a> for $name<'a> {\n             type Output = ();\n-            const NAME: &'static str = concat!(stringify!($book_name), \" - book\");\n             const DEFAULT: bool = true;\n \n             fn should_run(_builder: &Builder, path: &Path) -> bool {\n@@ -90,7 +93,7 @@ book!(\n );\n \n #[derive(Serialize)]\n-struct Rustbook<'a> {\n+pub struct Rustbook<'a> {\n     target: &'a str,\n     name: &'a str,\n }\n@@ -132,7 +135,6 @@ pub struct UnstableBook<'a> {\n \n impl<'a> Step<'a> for UnstableBook<'a> {\n     type Output = ();\n-    const NAME: &'static str = \"unstable book documentation\";\n     const DEFAULT: bool = true;\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n@@ -247,7 +249,7 @@ impl<'a> Step<'a> for TheBook<'a> {\n         // build the index page\n         let index = format!(\"{}/index.md\", name);\n         println!(\"Documenting book index ({})\", target);\n-        invoke_rustdoc(build, target, &index);\n+        invoke_rustdoc(builder, target, &index);\n \n         // build the redirect pages\n         println!(\"Documenting book redirect pages ({})\", target);\n@@ -256,19 +258,20 @@ impl<'a> Step<'a> for TheBook<'a> {\n             let path = file.path();\n             let path = path.to_str().unwrap();\n \n-            invoke_rustdoc(build, target, path);\n+            invoke_rustdoc(builder, target, path);\n         }\n     }\n }\n \n-fn invoke_rustdoc(build: &Build, target: &str, markdown: &str) {\n+fn invoke_rustdoc(builder: &Builder, target: &str, markdown: &str) {\n+    let build = builder.build;\n     let out = build.doc_out(target);\n \n-    let compiler = Compiler::new(0, &build.build);\n+    let compiler = builder.compiler(0, &build.build);\n \n     let path = build.src.join(\"src/doc\").join(markdown);\n \n-    let rustdoc = build.rustdoc(&compiler);\n+    let rustdoc = build.rustdoc(compiler);\n \n     let favicon = build.src.join(\"src/doc/favicon.inc\");\n     let footer = build.src.join(\"src/doc/footer.inc\");\n@@ -287,7 +290,7 @@ fn invoke_rustdoc(build: &Build, target: &str, markdown: &str) {\n \n     let mut cmd = Command::new(&rustdoc);\n \n-    build.add_rustc_lib_path(&compiler, &mut cmd);\n+    build.add_rustc_lib_path(compiler, &mut cmd);\n \n     let out = out.join(\"book\");\n \n@@ -383,7 +386,7 @@ impl<'a> Step<'a> for Standalone<'a> {\n             }\n \n             let html = out.join(filename).with_extension(\"html\");\n-            let rustdoc = build.rustdoc(&compiler);\n+            let rustdoc = build.rustdoc(compiler);\n             if up_to_date(&path, &html) &&\n                up_to_date(&footer, &html) &&\n                up_to_date(&favicon, &html) &&\n@@ -394,7 +397,7 @@ impl<'a> Step<'a> for Standalone<'a> {\n             }\n \n             let mut cmd = Command::new(&rustdoc);\n-            build.add_rustc_lib_path(&compiler, &mut cmd);\n+            build.add_rustc_lib_path(compiler, &mut cmd);\n             cmd.arg(\"--html-after-content\").arg(&footer)\n                .arg(\"--html-before-content\").arg(&version_info)\n                .arg(\"--html-in-header\").arg(&favicon)\n@@ -478,9 +481,9 @@ impl<'a> Step<'a> for Std<'a> {\n         };\n \n         builder.ensure(compile::Std { compiler, target });\n-        let out_dir = build.stage_out(&compiler, Mode::Libstd)\n+        let out_dir = build.stage_out(compiler, Mode::Libstd)\n                            .join(target).join(\"doc\");\n-        let rustdoc = build.rustdoc(&compiler);\n+        let rustdoc = build.rustdoc(compiler);\n \n         // Here what we're doing is creating a *symlink* (directory junction on\n         // Windows) to the final output location. This is not done as an\n@@ -499,7 +502,7 @@ impl<'a> Step<'a> for Std<'a> {\n         build.clear_if_dirty(&my_out, &rustdoc);\n         t!(symlink_dir_force(&my_out, &out_dir));\n \n-        let mut cargo = build.cargo(&compiler, Mode::Libstd, target, \"doc\");\n+        let mut cargo = build.cargo(compiler, Mode::Libstd, target, \"doc\");\n         cargo.arg(\"--manifest-path\")\n              .arg(build.src.join(\"src/libstd/Cargo.toml\"))\n              .arg(\"--features\").arg(build.std_features());\n@@ -536,7 +539,7 @@ impl<'a> Step<'a> for Std<'a> {\n #[derive(Serialize)]\n pub struct Test<'a> {\n     stage: u32,\n-    test: &'a str,\n+    target: &'a str,\n }\n \n impl<'a> Step<'a> for Test<'a> {\n@@ -592,16 +595,16 @@ impl<'a> Step<'a> for Test<'a> {\n         builder.ensure(Std { stage, target });\n \n         builder.ensure(compile::Test { compiler, target });\n-        let out_dir = build.stage_out(&compiler, Mode::Libtest)\n+        let out_dir = build.stage_out(compiler, Mode::Libtest)\n                            .join(target).join(\"doc\");\n-        let rustdoc = build.rustdoc(&compiler);\n+        let rustdoc = build.rustdoc(compiler);\n \n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n         t!(symlink_dir_force(&my_out, &out_dir));\n \n-        let mut cargo = build.cargo(&compiler, Mode::Libtest, target, \"doc\");\n+        let mut cargo = build.cargo(compiler, Mode::Libtest, target, \"doc\");\n         cargo.arg(\"--manifest-path\")\n              .arg(build.src.join(\"src/libtest/Cargo.toml\"));\n         build.run(&mut cargo);\n@@ -680,16 +683,16 @@ impl<'a> Step<'a> for Rustc<'a> {\n         builder.ensure(Std { stage, target });\n \n         builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = build.stage_out(&compiler, Mode::Librustc)\n+        let out_dir = build.stage_out(compiler, Mode::Librustc)\n                            .join(target).join(\"doc\");\n-        let rustdoc = build.rustdoc(&compiler);\n+        let rustdoc = build.rustdoc(compiler);\n \n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n         t!(symlink_dir_force(&my_out, &out_dir));\n \n-        let mut cargo = build.cargo(&compiler, Mode::Librustc, target, \"doc\");\n+        let mut cargo = build.cargo(compiler, Mode::Librustc, target, \"doc\");\n         cargo.arg(\"--manifest-path\")\n              .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n              .arg(\"--features\").arg(build.rustc_features());\n@@ -749,7 +752,7 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n     /// Generates the HTML rendered error-index by running the\n     /// `error_index_generator` tool.\n     fn run(self, builder: &Builder) {\n-        let builder = builder.build;\n+        let build = builder.build;\n         let target = self.target;\n \n         builder.ensure(compile::Rustc {\n@@ -760,7 +763,6 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n         println!(\"Documenting error index ({})\", target);\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = Compiler::new(0, &build.build);\n         let mut index = builder.tool_cmd(Tool::ErrorIndex);\n         index.arg(\"html\");\n         index.arg(out.join(\"error-index.html\"));\n@@ -822,8 +824,7 @@ impl<'a> Step<'a> for UnstableBookGen<'a> {\n         let out = build.md_doc_out(target).join(\"unstable-book\");\n         t!(fs::create_dir_all(&out));\n         t!(fs::remove_dir_all(&out));\n-        let compiler = Compiler::new(0, &build.build);\n-        let mut cmd = build.tool_cmd(&compiler, \"unstable-book-gen\");\n+        let mut cmd = builder.tool_cmd(Tool::UnstableBookGen);\n         cmd.arg(build.src.join(\"src\"));\n         cmd.arg(out);\n "}, {"sha": "30bc8cdef4ad22b1f120d2262e4ebe1b3b9a1ed6", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -23,7 +23,6 @@ use getopts::Options;\n use Build;\n use config::Config;\n use metadata;\n-use step;\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n@@ -246,10 +245,12 @@ Arguments:\n             config.build = flags.build.clone();\n             let mut build = Build::new(flags, config);\n             metadata::build(&mut build);\n-            let maybe_rules_help = step::build_rules(&build).get_help(subcommand);\n-            if maybe_rules_help.is_some() {\n-                extra_help.push_str(maybe_rules_help.unwrap().as_str());\n-            }\n+\n+            // FIXME: How should this happen now? Not super clear...\n+            // let maybe_rules_help = step::build_rules(&build).get_help(subcommand);\n+            // if maybe_rules_help.is_some() {\n+            //     extra_help.push_str(maybe_rules_help.unwrap().as_str());\n+            // }\n         } else {\n             extra_help.push_str(format!(\"Run `./x.py {} -h -v` to see a list of available paths.\",\n                      subcommand).as_str());"}, {"sha": "4361a4d369a4661301582fcefe12fbe0d9634dc1", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -18,8 +18,10 @@ use std::fs;\n use std::path::{Path, PathBuf, Component};\n use std::process::Command;\n \n+use dist::{self, pkgname, sanitize_sh, tmpdir};\n+\n use Build;\n-use dist::{pkgname, sanitize_sh, tmpdir};\n+use builder::{Builder, Step};\n \n pub struct Installer<'a> {\n     build: &'a Build,\n@@ -165,7 +167,6 @@ macro_rules! install {\n \n         impl<'a> Step<'a> for $name<'a> {\n             type Output = ();\n-            const NAME: &'static str = concat!(\"install \", stringify!($name));\n             const DEFAULT: bool = true;\n             const ONLY_BUILD_TARGETS: bool = true;\n             const ONLY_HOSTS: bool = $only_hosts;"}, {"sha": "b58b46eb8f251a36b4a6b6fe951932fbd3420dd3", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 25, "deletions": 53, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -65,9 +65,15 @@\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n #![deny(warnings)]\n+#![feature(associated_consts)]\n+#![feature(core_intrinsics)]\n \n #[macro_use]\n extern crate build_helper;\n+#[macro_use]\n+extern crate serde_derive;\n+extern crate serde;\n+extern crate serde_json;\n extern crate cmake;\n extern crate filetime;\n extern crate gcc;\n@@ -81,9 +87,8 @@ extern crate libc;\n \n use std::cell::Cell;\n use std::cmp;\n-use std::collections::HashMap;\n+use std::collections::{HashSet, HashMap};\n use std::env;\n-use std::ffi::OsString;\n use std::fs::{self, File};\n use std::io::Read;\n use std::path::{PathBuf, Path};\n@@ -93,8 +98,6 @@ use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppresse\n \n use util::{exe, libdir, add_lib_path, OutputFolder, CiEnv};\n \n-use builder::Builder;\n-\n mod cc;\n mod channel;\n mod check;\n@@ -110,6 +113,8 @@ mod native;\n mod sanity;\n pub mod util;\n mod builder;\n+mod cache;\n+mod tool;\n \n #[cfg(windows)]\n mod job;\n@@ -139,7 +144,7 @@ pub use flags::{Flags, Subcommand};\n /// Each compiler has a `stage` that it is associated with and a `host` that\n /// corresponds to the platform the compiler runs on. This structure is used as\n /// a parameter to many methods below.\n-#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n+#[derive(Serialize, Deserialize, Eq, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct Compiler<'a> {\n     stage: u32,\n     host: &'a str,\n@@ -212,7 +217,7 @@ struct Crate {\n ///\n /// These entries currently correspond to the various output directories of the\n /// build system, with each mod generating output in a different directory.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Serialize, Clone, Copy, PartialEq, Eq)]\n pub enum Mode {\n     /// Build the standard library, placing output in the \"stageN-std\" directory.\n     Libstd,\n@@ -301,12 +306,6 @@ impl Build {\n         }\n     }\n \n-    fn build_slice(&self) -> &[String] {\n-        unsafe {\n-            std::slice::from_raw_parts(&self.build, 1)\n-        }\n-    }\n-\n     /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n         unsafe {\n@@ -335,7 +334,7 @@ impl Build {\n         self.verbose(\"learning about cargo\");\n         metadata::build(self);\n \n-        step::run(self);\n+        builder::Builder::run(&self);\n     }\n \n     /// Clear out `dir` if `input` is newer.\n@@ -361,7 +360,7 @@ impl Build {\n     /// it will pass the `--target` flag for the specified `target`, and will be\n     /// executing the Cargo command `cmd`.\n     fn cargo(&self,\n-             compiler: &Compiler,\n+             compiler: Compiler,\n              mode: Mode,\n              target: &str,\n              cmd: &str) -> Command {\n@@ -528,7 +527,7 @@ impl Build {\n     }\n \n     /// Get a path to the compiler specified.\n-    fn compiler_path(&self, compiler: &Compiler) -> PathBuf {\n+    fn compiler_path(&self, compiler: Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n         } else {\n@@ -537,13 +536,13 @@ impl Build {\n     }\n \n     /// Get the specified tool built by the specified compiler\n-    fn tool(&self, compiler: &Compiler, tool: &str) -> PathBuf {\n+    fn tool(&self, compiler: Compiler, tool: &str) -> PathBuf {\n         self.cargo_out(compiler, Mode::Tool, compiler.host)\n             .join(exe(tool, compiler.host))\n     }\n \n     /// Get the `rustdoc` executable next to the specified compiler\n-    fn rustdoc(&self, compiler: &Compiler) -> PathBuf {\n+    fn rustdoc(&self, compiler: Compiler) -> PathBuf {\n         let mut rustdoc = self.compiler_path(compiler);\n         rustdoc.pop();\n         rustdoc.push(exe(\"rustdoc\", compiler.host));\n@@ -552,8 +551,8 @@ impl Build {\n \n     /// Get a `Command` which is ready to run `tool` in `stage` built for\n     /// `host`.\n-    fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n-        let mut cmd = Command::new(self.tool(&compiler, tool));\n+    fn tool_cmd(&self, compiler: Compiler, tool: &str) -> Command {\n+        let mut cmd = Command::new(self.tool(compiler, tool));\n         self.prepare_tool_cmd(compiler, &mut cmd);\n         cmd\n     }\n@@ -562,7 +561,7 @@ impl Build {\n     ///\n     /// Notably this munges the dynamic library lookup path to point to the\n     /// right location to run `compiler`.\n-    fn prepare_tool_cmd(&self, compiler: &Compiler, cmd: &mut Command) {\n+    fn prepare_tool_cmd(&self, compiler: Compiler, cmd: &mut Command) {\n         let host = compiler.host;\n         let mut paths = vec![\n             self.sysroot_libdir(compiler, compiler.host),\n@@ -624,23 +623,9 @@ impl Build {\n         if self.config.rust_optimize {\"release\"} else {\"debug\"}\n     }\n \n-    /// Returns the sysroot for the `compiler` specified that *this build system\n-    /// generates*.\n-    ///\n-    /// That is, the sysroot for the stage0 compiler is not what the compiler\n-    /// thinks it is by default, but it's the same as the default for stages\n-    /// 1-3.\n-    fn sysroot(&self, compiler: &Compiler) -> PathBuf {\n-        if compiler.stage == 0 {\n-            self.out.join(compiler.host).join(\"stage0-sysroot\")\n-        } else {\n-            self.out.join(compiler.host).join(format!(\"stage{}\", compiler.stage))\n-        }\n-    }\n-\n     /// Get the directory for incremental by-products when using the\n     /// given compiler.\n-    fn incremental_dir(&self, compiler: &Compiler) -> PathBuf {\n+    fn incremental_dir(&self, compiler: Compiler) -> PathBuf {\n         self.out.join(compiler.host).join(format!(\"stage{}-incremental\", compiler.stage))\n     }\n \n@@ -661,7 +646,7 @@ impl Build {\n     /// stage when running with a particular host compiler.\n     ///\n     /// The mode indicates what the root directory is for.\n-    fn stage_out(&self, compiler: &Compiler, mode: Mode) -> PathBuf {\n+    fn stage_out(&self, compiler: Compiler, mode: Mode) -> PathBuf {\n         let suffix = match mode {\n             Mode::Libstd => \"-std\",\n             Mode::Libtest => \"-test\",\n@@ -676,7 +661,7 @@ impl Build {\n     /// running a particular compiler, wehther or not we're building the\n     /// standard library, and targeting the specified architecture.\n     fn cargo_out(&self,\n-                 compiler: &Compiler,\n+                 compiler: Compiler,\n                  mode: Mode,\n                  target: &str) -> PathBuf {\n         self.stage_out(compiler, mode).join(target).join(self.cargo_dir())\n@@ -759,19 +744,6 @@ impl Build {\n         self.native_dir(target).join(\"rust-test-helpers\")\n     }\n \n-    /// Adds the compiler's directory of dynamic libraries to `cmd`'s dynamic\n-    /// library lookup path.\n-    fn add_rustc_lib_path(&self, compiler: &Compiler, cmd: &mut Command) {\n-        // Windows doesn't need dylib path munging because the dlls for the\n-        // compiler live next to the compiler and the system will find them\n-        // automatically.\n-        if cfg!(windows) {\n-            return\n-        }\n-\n-        add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n-    }\n-\n     /// Adds the `RUST_TEST_THREADS` env var if necessary\n     fn add_rust_test_threads(&self, cmd: &mut Command) {\n         if env::var_os(\"RUST_TEST_THREADS\").is_none() {\n@@ -784,7 +756,7 @@ impl Build {\n     ///\n     /// For example this returns `<sysroot>/lib` on Unix and `<sysroot>/bin` on\n     /// Windows.\n-    fn rustc_libdir(&self, compiler: &Compiler) -> PathBuf {\n+    fn rustc_libdir(&self, compiler: Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n             self.rustc_snapshot_libdir()\n         } else {\n@@ -960,7 +932,7 @@ impl Build {\n     ///\n     /// When all of these conditions are met the build will lift artifacts from\n     /// the previous stage forward.\n-    fn force_use_stage1(&self, compiler: &Compiler, target: &str) -> bool {\n+    fn force_use_stage1(&self, compiler: Compiler, target: &str) -> bool {\n         !self.config.full_bootstrap &&\n             compiler.stage >= 2 &&\n             self.config.host.iter().any(|h| h == target)\n@@ -1110,7 +1082,7 @@ impl<'a> Compiler<'a> {\n     }\n \n     /// Returns whether this is a snapshot compiler for `build`'s configuration\n-    pub fn is_snapshot(&self, builder: &Build) -> bool {\n+    pub fn is_snapshot(&self, build: &Build) -> bool {\n         self.stage == 0 && self.host == build.build\n     }\n "}, {"sha": "06af4ceac12e2ef06db8b3ba197604abd2a2bdb1", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -32,6 +32,7 @@ use gcc;\n use Build;\n use util;\n use build_helper::up_to_date;\n+use builder::{Builder, Step};\n \n // rules.build(\"llvm\", \"src/llvm\")\n //      .host(true)\n@@ -245,7 +246,7 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n \n #[derive(Serialize)]\n pub struct TestHelpers<'a> {\n-    target: &'a str,\n+    pub target: &'a str,\n }\n \n impl<'a> Step<'a> for TestHelpers<'a> {\n@@ -316,7 +317,7 @@ impl<'a> Step<'a> for Openssl<'a> {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = bulder.build;\n+        let build = builder.build;\n         let target = self.target;\n         let out = match build.openssl_dir(target) {\n             Some(dir) => dir,"}, {"sha": "234a903ee6cf19d0261e7bb5465f392e413cc321", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60388303c770a6e9409f3afa75d31d9125f871e3/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=60388303c770a6e9409f3afa75d31d9125f871e3", "patch": "@@ -66,12 +66,12 @@ impl<'a> Step<'a> for CleanTools<'a> {\n         let compiler = builder.compiler(stage, &build.build);\n \n         let stamp = match mode {\n-            Mode::Libstd => libstd_stamp(build, &compiler, target),\n-            Mode::Libtest => libtest_stamp(build, &compiler, target),\n-            Mode::Librustc => librustc_stamp(build, &compiler, target),\n+            Mode::Libstd => libstd_stamp(build, compiler, target),\n+            Mode::Libtest => libtest_stamp(build, compiler, target),\n+            Mode::Librustc => librustc_stamp(build, compiler, target),\n             _ => panic!(),\n         };\n-        let out_dir = build.cargo_out(&compiler, Mode::Tool, target);\n+        let out_dir = build.cargo_out(compiler, Mode::Tool, target);\n         build.clear_if_dirty(&out_dir, &stamp);\n     }\n }\n@@ -109,7 +109,7 @@ impl<'a> Step<'a> for ToolBuild<'a> {\n         let _folder = build.fold_output(|| format!(\"stage{}-{}\", stage, tool));\n         println!(\"Building stage{} tool {} ({})\", stage, tool, target);\n \n-        let mut cargo = build.cargo(&compiler, Mode::Tool, target, \"build\");\n+        let mut cargo = build.cargo(compiler, Mode::Tool, target, \"build\");\n         let dir = build.src.join(\"src/tools\").join(tool);\n         cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n \n@@ -172,7 +172,6 @@ macro_rules! tool {\n \n         impl<'a> Step<'a> for $name<'a> {\n             type Output = PathBuf;\n-            const NAME: &'static str = concat!(stringify!($name), \" tool\");\n \n             fn should_run(_builder: &Builder, path: &Path) -> bool {\n                 path.ends_with($path)\n@@ -213,7 +212,7 @@ tool!(\n     //      .dep(|s| s.name(\"maybe-clean-tools\"))\n     //      .dep(|s| s.name(\"libstd-tool\"))\n     //      .run(move |s| compile::tool(build, s.stage, s.target, \"unstable-book-gen\"));\n-    UnstableBook, \"src/tools/unstable-book-gen\", \"unstable-book-gen\", Mode::Libstd;\n+    UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\", Mode::Libstd;\n     // rules.build(\"tool-tidy\", \"src/tools/tidy\")\n     //      .dep(|s| s.name(\"maybe-clean-tools\"))\n     //      .dep(|s| s.name(\"libstd-tool\"))\n@@ -278,7 +277,6 @@ pub struct Cargo<'a> {\n \n impl<'a> Step<'a> for Cargo<'a> {\n     type Output = PathBuf;\n-    const NAME: &'static str = \"cargo tool\";\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -336,7 +334,6 @@ pub struct Rls<'a> {\n \n impl<'a> Step<'a> for Rls<'a> {\n     type Output = PathBuf;\n-    const NAME: &'static str = \"RLS tool\";\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n "}]}