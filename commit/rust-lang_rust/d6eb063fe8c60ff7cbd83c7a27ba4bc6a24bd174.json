{"sha": "d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZWIwNjNmZThjNjBmZjdjYmQ4M2M3YTI3YmE0YmM2YTI0YmQxNzQ=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2015-12-08T02:40:25Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2015-12-08T02:55:00Z"}, "message": "Fix unsized structs with destructors\n\nThe presence of the drop flag caused the offset calculation to be\nincorrect, leading to the pointer being incorrect. This has been fixed\nby calculating the offset based on the field index (and not assuming\nthat the field is always the last one).\n\nHowever, I've also stopped the drop flag from being added to the end of\nunsized structs to begin with. Since it's not actually accessed for\nunsized structs, and isn't actually where we would say it is, this made\nmore sense.", "tree": {"sha": "13fd695a427e86970ea7f16ee9ed2165fc58e321", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13fd695a427e86970ea7f16ee9ed2165fc58e321"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174", "html_url": "https://github.com/rust-lang/rust/commit/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2557d472e570559caf18d9b042cd941f5002398", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2557d472e570559caf18d9b042cd941f5002398", "html_url": "https://github.com/rust-lang/rust/commit/a2557d472e570559caf18d9b042cd941f5002398"}], "stats": {"total": 40, "additions": 33, "deletions": 7}, "files": [{"sha": "f6f1918fd074168ec94ea82befa3bddae3e59b1b", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174", "patch": "@@ -275,7 +275,11 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 monomorphize::field_ty(cx.tcx(), substs, field)\n             }).collect::<Vec<_>>();\n             let packed = cx.tcx().lookup_packed(def.did);\n-            let dtor = def.dtor_kind().has_drop_flag();\n+            // FIXME(16758) don't add a drop flag to unsized structs, as it\n+            // won't actually be in the location we say it is because it'll be after\n+            // the unsized field. Several other pieces of code assume that the unsized\n+            // field is definitely the last one.\n+            let dtor = def.dtor_kind().has_drop_flag() && type_is_sized(cx.tcx(), t);\n             if dtor {\n                 ftys.push(cx.tcx().dtor_type());\n             }\n@@ -1105,8 +1109,8 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n \n pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, val: MaybeSizedValue,\n                                     ix: usize, needs_cast: bool) -> ValueRef {\n+    let ccx = bcx.ccx();\n     let ptr_val = if needs_cast {\n-        let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| {\n             type_of::in_memory_type_of(ccx, ty)\n         }).collect::<Vec<_>>();\n@@ -1147,7 +1151,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     // We need to get the pointer manually now.\n     // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n     // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n-    // because the the field may have an arbitrary alignment in the LLVM representation\n+    // because the field may have an arbitrary alignment in the LLVM representation\n     // anyway.\n     //\n     // To demonstrate:\n@@ -1161,9 +1165,15 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n \n     let meta = val.meta;\n \n-    // st.size is the size of the sized portion of the struct. So the position\n-    // exactly after it is the offset for unaligned data.\n-    let unaligned_offset = C_uint(bcx.ccx(), st.size);\n+    // Calculate the unaligned offset of the the unsized field.\n+    let mut offset = 0;\n+    for &ty in &st.fields[0..ix] {\n+        let llty = type_of::sizing_type_of(ccx, ty);\n+        let type_align = type_of::align_of(ccx, ty);\n+        offset = roundup(offset, type_align);\n+        offset += machine::llsize_of_alloc(ccx, llty);\n+    }\n+    let unaligned_offset = C_uint(bcx.ccx(), offset);\n \n     // Get the alignment of the field\n     let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);"}, {"sha": "cf2acfe986c2155b4276613b65882ece9bf5770d", "filename": "src/test/run-pass/dst-field-align.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174/src%2Ftest%2Frun-pass%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174/src%2Ftest%2Frun-pass%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-field-align.rs?ref=d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct Foo<T: ?Sized> {\n-    a: u8,\n+    a: u16,\n     b: T\n }\n \n@@ -31,6 +31,11 @@ struct Packed<T: ?Sized> {\n     b: T\n }\n \n+struct HasDrop<T: ?Sized> {\n+    ptr: Box<usize>,\n+    data: T\n+}\n+\n fn main() {\n     // Test that zero-offset works properly\n     let b : Baz<usize> = Baz { a: 7 };\n@@ -68,4 +73,15 @@ fn main() {\n     let f : &Foo<Bar> = &f;\n     let &Foo { a: _, b: ref bar } = f;\n     assert_eq!(bar.get(), 11);\n+\n+    // Make sure that drop flags don't screw things up\n+\n+    let d : HasDrop<Baz<[i32; 4]>> = HasDrop {\n+        ptr: Box::new(0),\n+        data: Baz { a: [1,2,3,4] }\n+    };\n+    assert_eq!([1,2,3,4], d.data.a);\n+\n+    let d : &HasDrop<Baz<[i32]>> = &d;\n+    assert_eq!(&[1,2,3,4], &d.data.a);\n }"}]}