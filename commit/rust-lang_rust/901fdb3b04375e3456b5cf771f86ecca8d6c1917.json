{"sha": "901fdb3b04375e3456b5cf771f86ecca8d6c1917", "node_id": "C_kwDOAAsO6NoAKDkwMWZkYjNiMDQzNzVlMzQ1NmI1Y2Y3NzFmODZlY2NhOGQ2YzE5MTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-27T13:38:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-27T13:38:19Z"}, "message": "Auto merge of #110896 - matthiaskrgr:rollup-h8fetzd, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #110426 (docs(style): add more let-else examples)\n - #110804 (Remove repeated definite articles)\n - #110814 (Sprinkle some `#[inline]` in `rustc_data_structures::tagged_ptr`)\n - #110816 (Migrate `rustc_passes` to translatable diagnostics)\n - #110864 (`IntoFuture::into_future` is no longer unstable)\n - #110866 (Make `method-not-found-generic-arg-elision.rs` error message not path dependent)\n - #110872 (Nicer ICE for #67981)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c839aa495a143234447b43187b00bfa2e019aa3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c839aa495a143234447b43187b00bfa2e019aa3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/901fdb3b04375e3456b5cf771f86ecca8d6c1917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/901fdb3b04375e3456b5cf771f86ecca8d6c1917", "html_url": "https://github.com/rust-lang/rust/commit/901fdb3b04375e3456b5cf771f86ecca8d6c1917", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/901fdb3b04375e3456b5cf771f86ecca8d6c1917/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ce22733b973355573efd1e6294e585460e90e17", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce22733b973355573efd1e6294e585460e90e17", "html_url": "https://github.com/rust-lang/rust/commit/6ce22733b973355573efd1e6294e585460e90e17"}, {"sha": "52d550b20ee1a327565b2002ac7f02243d0fa12e", "url": "https://api.github.com/repos/rust-lang/rust/commits/52d550b20ee1a327565b2002ac7f02243d0fa12e", "html_url": "https://github.com/rust-lang/rust/commit/52d550b20ee1a327565b2002ac7f02243d0fa12e"}], "stats": {"total": 584, "additions": 375, "deletions": 209}, "files": [{"sha": "7a0a7da969572565c54e6b48241d30f5fa8508da", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -858,13 +858,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let awaitee_arm = self.arm(awaitee_pat, loop_expr);\n \n         // `match ::std::future::IntoFuture::into_future(<expr>) { ... }`\n-        let into_future_span = self.mark_span_with_reason(\n-            DesugaringKind::Await,\n-            dot_await_span,\n-            self.allow_into_future.clone(),\n-        );\n         let into_future_expr = self.expr_call_lang_item_fn(\n-            into_future_span,\n+            span,\n             hir::LangItem::IntoFutureIntoFuture,\n             arena_vec![self; expr],\n             Some(expr_hir_id),"}, {"sha": "3d154a93fb2dafc99291af802ce53ead521e8ed7", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -83,7 +83,6 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             impl_trait_bounds: Vec::new(),\n             allow_try_trait: Some([sym::try_trait_v2, sym::yeet_desugar_details][..].into()),\n             allow_gen_future: Some([sym::gen_future, sym::closure_track_caller][..].into()),\n-            allow_into_future: Some([sym::into_future][..].into()),\n             generics_def_id_map: Default::default(),\n         };\n         lctx.with_hir_id_owner(owner, |lctx| f(lctx));"}, {"sha": "b5b28bf8e31e5416b651dc06779a2e54b60eb59f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -136,7 +136,6 @@ struct LoweringContext<'a, 'hir> {\n \n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n-    allow_into_future: Option<Lrc<[Symbol]>>,\n \n     /// Mapping from generics `def_id`s to TAIT generics `def_id`s.\n     /// For each captured lifetime (e.g., 'a), we create a new lifetime parameter that is a generic"}, {"sha": "f706ecea97512f1c62b357d670757b4d2673543d", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -304,7 +304,17 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     bug!(\"spread argument isn't a tuple?!\");\n                 };\n \n-                let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n+                let layout = bx.layout_of(arg_ty);\n+\n+                // FIXME: support unsized params in \"rust-call\" ABI\n+                if layout.is_unsized() {\n+                    span_bug!(\n+                        arg_decl.source_info.span,\n+                        \"\\\"rust-call\\\" ABI does not support unsized params\",\n+                    );\n+                }\n+\n+                let place = PlaceRef::alloca(bx, layout);\n                 for i in 0..tupled_arg_tys.len() {\n                     let arg = &fx.fn_abi.args[idx];\n                     idx += 1;"}, {"sha": "e893a2c7813469e745d53766674c6ea1a8d25329", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -82,11 +82,13 @@ where\n     /// drop, use [`TaggedPtr`] instead.\n     ///\n     /// [`TaggedPtr`]: crate::tagged_ptr::TaggedPtr\n+    #[inline]\n     pub fn new(pointer: P, tag: T) -> Self {\n         Self { packed: Self::pack(P::into_ptr(pointer), tag), tag_ghost: PhantomData }\n     }\n \n     /// Retrieves the pointer.\n+    #[inline]\n     pub fn pointer(self) -> P\n     where\n         P: Copy,\n@@ -123,6 +125,7 @@ where\n     /// according to `self.packed` encoding scheme.\n     ///\n     /// [`P::into_ptr`]: Pointer::into_ptr\n+    #[inline]\n     fn pack(ptr: NonNull<P::Target>, tag: T) -> NonNull<P::Target> {\n         // Trigger assert!\n         let () = Self::ASSERTION;\n@@ -145,6 +148,7 @@ where\n     }\n \n     /// Retrieves the original raw pointer from `self.packed`.\n+    #[inline]\n     pub(super) fn pointer_raw(&self) -> NonNull<P::Target> {\n         self.packed.map_addr(|addr| unsafe { NonZeroUsize::new_unchecked(addr.get() << T::BITS) })\n     }\n@@ -184,6 +188,7 @@ where\n     P: Pointer + Copy,\n     T: Tag,\n {\n+    #[inline]\n     fn clone(&self) -> Self {\n         *self\n     }\n@@ -196,6 +201,7 @@ where\n {\n     type Target = P::Target;\n \n+    #[inline]\n     fn deref(&self) -> &Self::Target {\n         // Safety:\n         // `pointer_raw` returns the original pointer from `P::into_ptr` which,\n@@ -209,6 +215,7 @@ where\n     P: Pointer + DerefMut,\n     T: Tag,\n {\n+    #[inline]\n     fn deref_mut(&mut self) -> &mut Self::Target {\n         // Safety:\n         // `pointer_raw` returns the original pointer from `P::into_ptr` which,\n@@ -235,6 +242,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n+    #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.packed == other.packed\n     }\n@@ -252,6 +260,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n+    #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.packed.hash(state);\n     }"}, {"sha": "4e42b5b4afe8a87ee5f6ef3cb928f1991df762f3", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -30,16 +30,19 @@ where\n     T: Tag,\n {\n     /// Tags `pointer` with `tag`.\n+    #[inline]\n     pub fn new(pointer: P, tag: T) -> Self {\n         TaggedPtr { raw: CopyTaggedPtr::new(pointer, tag) }\n     }\n \n     /// Retrieves the tag.\n+    #[inline]\n     pub fn tag(&self) -> T {\n         self.raw.tag()\n     }\n \n     /// Sets the tag to a new value.\n+    #[inline]\n     pub fn set_tag(&mut self, tag: T) {\n         self.raw.set_tag(tag)\n     }\n@@ -63,6 +66,8 @@ where\n     T: Tag,\n {\n     type Target = P::Target;\n+\n+    #[inline]\n     fn deref(&self) -> &Self::Target {\n         self.raw.deref()\n     }\n@@ -73,6 +78,7 @@ where\n     P: Pointer + DerefMut,\n     T: Tag,\n {\n+    #[inline]\n     fn deref_mut(&mut self) -> &mut Self::Target {\n         self.raw.deref_mut()\n     }\n@@ -108,6 +114,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n+    #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.raw.eq(&other.raw)\n     }\n@@ -125,6 +132,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n+    #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.raw.hash(state);\n     }"}, {"sha": "406801506013b0174ebe295279fbdaffd4fe4836", "filename": "compiler/rustc_passes/messages.ftl", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fmessages.ftl?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -139,7 +139,6 @@ passes_doc_attr_not_crate_level =\n passes_attr_crate_level =\n     this attribute can only be applied at the crate level\n     .suggestion = to apply to the crate, use an inner attribute\n-    .help = to apply to the crate, use an inner attribute\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n passes_doc_test_unknown =\n@@ -724,3 +723,45 @@ passes_skipping_const_checks = skipping const checks\n passes_invalid_macro_export_arguments = `{$name}` isn't a valid `#[macro_export]` argument\n \n passes_invalid_macro_export_arguments_too_many_items = `#[macro_export]` can only take 1 or 0 arguments\n+\n+passes_unreachable_due_to_uninhabited = unreachable {$descr}\n+    .label = unreachable {$descr}\n+    .label_orig = any code following this expression is unreachable\n+    .note = this expression has type `{$ty}`, which is uninhabited\n+\n+passes_unused_var_maybe_capture_ref = unused variable: `{$name}`\n+    .help = did you mean to capture by reference instead?\n+\n+passes_unused_capture_maybe_capture_ref = value captured by `{$name}` is never read\n+    .help = did you mean to capture by reference instead?\n+\n+passes_unused_var_remove_field = unused variable: `{$name}`\n+passes_unused_var_remove_field_suggestion = try removing the field\n+\n+passes_unused_var_assigned_only = variable `{$name}` is assigned to, but never used\n+    .note = consider using `_{$name}` instead\n+\n+passes_unnecessary_stable_feature = the feature `{$feature}` has been stable since {$since} and no longer requires an attribute to enable\n+\n+passes_unnecessary_partial_stable_feature = the feature `{$feature}` has been partially stabilized since {$since} and is succeeded by the feature `{$implies}`\n+    .suggestion = if you are using features which are still unstable, change to using `{$implies}`\n+    .suggestion_remove = if you are using features which are now stable, remove this line\n+\n+passes_ineffective_unstable_impl = an `#[unstable]` annotation here has no effect\n+    .note = see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\n+\n+passes_unused_assign = value assigned to `{$name}` is never read\n+    .help = maybe it is overwritten before being read?\n+\n+passes_unused_assign_passed = value passed to `{$name}` is never read\n+    .help = maybe it is overwritten before being read?\n+\n+passes_maybe_string_interpolation = you might have meant to use string interpolation in this string literal\n+passes_string_interpolation_only_works = string interpolation only works in `format!` invocations\n+\n+passes_unused_variable_try_prefix = unused variable: `{$name}`\n+    .label = unused variable\n+    .suggestion = if this is intentional, prefix it with an underscore\n+\n+passes_unused_variable_try_ignore = unused variable: `{$name}`\n+    .suggestion = try ignoring the field"}, {"sha": "3f28ac26f8617c6adb43cee80a7518ea597a8cef", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -29,7 +29,7 @@ use rustc_session::lint::builtin::{\n };\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::{TyCtxtInferExt, ValuePairs};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -927,30 +927,18 @@ impl CheckAttrVisitor<'_> {\n         hir_id: HirId,\n     ) -> bool {\n         if hir_id != CRATE_HIR_ID {\n-            self.tcx.struct_span_lint_hir(\n+            // insert a bang between `#` and `[...`\n+            let bang_span = attr.span.lo() + BytePos(1);\n+            let sugg = (attr.style == AttrStyle::Outer\n+                && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID)\n+                .then_some(errors::AttrCrateLevelOnlySugg {\n+                    attr: attr.span.with_lo(bang_span).with_hi(bang_span),\n+                });\n+            self.tcx.emit_spanned_lint(\n                 INVALID_DOC_ATTRIBUTES,\n                 hir_id,\n                 meta.span(),\n-                fluent::passes_attr_crate_level,\n-                |err| {\n-                    if attr.style == AttrStyle::Outer\n-                        && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID\n-                    {\n-                        if let Ok(mut src) = self.tcx.sess.source_map().span_to_snippet(attr.span) {\n-                            src.insert(1, '!');\n-                            err.span_suggestion_verbose(\n-                                attr.span,\n-                                fluent::passes_suggestion,\n-                                src,\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        } else {\n-                            err.span_help(attr.span, fluent::passes_help);\n-                        }\n-                    }\n-                    err.note(fluent::passes_note);\n-                    err\n-                },\n+                errors::AttrCrateLevelOnly { sugg },\n             );\n             return false;\n         }"}, {"sha": "99fc69d1bec7b842cc2fd55928e40f57fc03df43", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 159, "deletions": 1, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -6,7 +6,8 @@ use std::{\n use crate::fluent_generated as fluent;\n use rustc_ast::Label;\n use rustc_errors::{\n-    error_code, Applicability, DiagnosticSymbolList, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+    error_code, AddToDiagnostic, Applicability, Diagnostic, DiagnosticSymbolList, ErrorGuaranteed,\n+    IntoDiagnostic, MultiSpan,\n };\n use rustc_hir::{self as hir, ExprKind, Target};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n@@ -1555,3 +1556,160 @@ pub struct SkippingConstChecks {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unreachable_due_to_uninhabited)]\n+pub struct UnreachableDueToUninhabited<'desc, 'tcx> {\n+    pub descr: &'desc str,\n+    #[label]\n+    pub expr: Span,\n+    #[label(passes_label_orig)]\n+    #[note]\n+    pub orig: Span,\n+    pub ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_var_maybe_capture_ref)]\n+#[help]\n+pub struct UnusedVarMaybeCaptureRef {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_capture_maybe_capture_ref)]\n+#[help]\n+pub struct UnusedCaptureMaybeCaptureRef {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_var_remove_field)]\n+pub struct UnusedVarRemoveField {\n+    pub name: String,\n+    #[subdiagnostic]\n+    pub sugg: UnusedVarRemoveFieldSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    passes_unused_var_remove_field_suggestion,\n+    applicability = \"machine-applicable\"\n+)]\n+pub struct UnusedVarRemoveFieldSugg {\n+    #[suggestion_part(code = \"\")]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_var_assigned_only)]\n+#[note]\n+pub struct UnusedVarAssignedOnly {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unnecessary_stable_feature)]\n+pub struct UnnecessaryStableFeature {\n+    pub feature: Symbol,\n+    pub since: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unnecessary_partial_stable_feature)]\n+pub struct UnnecessaryPartialStableFeature {\n+    #[suggestion(code = \"{implies}\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    #[suggestion(passes_suggestion_remove, code = \"\", applicability = \"maybe-incorrect\")]\n+    pub line: Span,\n+    pub feature: Symbol,\n+    pub since: Symbol,\n+    pub implies: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_ineffective_unstable_impl)]\n+#[note]\n+pub struct IneffectiveUnstableImpl;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_assign)]\n+#[help]\n+pub struct UnusedAssign {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_assign_passed)]\n+#[help]\n+pub struct UnusedAssignPassed {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_variable_try_prefix)]\n+pub struct UnusedVariableTryPrefix {\n+    #[label]\n+    pub label: Option<Span>,\n+    #[subdiagnostic]\n+    pub string_interp: Vec<UnusedVariableStringInterp>,\n+    #[subdiagnostic]\n+    pub sugg: UnusedVariableTryPrefixSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(passes_suggestion, applicability = \"machine-applicable\")]\n+pub struct UnusedVariableTryPrefixSugg {\n+    #[suggestion_part(code = \"_{name}\")]\n+    pub spans: Vec<Span>,\n+    pub name: String,\n+}\n+\n+pub struct UnusedVariableStringInterp {\n+    pub lit: Span,\n+    pub lo: Span,\n+    pub hi: Span,\n+}\n+\n+impl AddToDiagnostic for UnusedVariableStringInterp {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F) {\n+        diag.span_label(self.lit, crate::fluent_generated::passes_maybe_string_interpolation);\n+        diag.multipart_suggestion(\n+            crate::fluent_generated::passes_string_interpolation_only_works,\n+            vec![(self.lo, String::from(\"format!(\")), (self.hi, String::from(\")\"))],\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_variable_try_ignore)]\n+pub struct UnusedVarTryIgnore {\n+    #[subdiagnostic]\n+    pub sugg: UnusedVarTryIgnoreSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(passes_suggestion, applicability = \"machine-applicable\")]\n+pub struct UnusedVarTryIgnoreSugg {\n+    #[suggestion_part(code = \"{name}: _\")]\n+    pub shorthands: Vec<Span>,\n+    #[suggestion_part(code = \"_\")]\n+    pub non_shorthands: Vec<Span>,\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_attr_crate_level)]\n+#[note]\n+pub struct AttrCrateLevelOnly {\n+    #[subdiagnostic]\n+    pub sugg: Option<AttrCrateLevelOnlySugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(passes_suggestion, applicability = \"maybe-incorrect\", code = \"!\", style = \"verbose\")]\n+pub struct AttrCrateLevelOnlySugg {\n+    #[primary_span]\n+    pub attr: Span,\n+}"}, {"sha": "8b7338e29aa07e0c8c6e7900793807f40bb07fbc", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -12,6 +12,8 @@\n #![feature(min_specialization)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;"}, {"sha": "6758024419d3119fbcf804588cf855cfec74c04d", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 80, "deletions": 124, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -81,13 +81,13 @@\n //! We generate various special nodes for various, well, special purposes.\n //! These are described in the `Liveness` struct.\n \n+use crate::errors;\n+\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxIndexMap;\n-use rustc_errors::Applicability;\n-use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def::*;\n use rustc_hir::def_id::LocalDefId;\n@@ -1297,13 +1297,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.exit_ln\n     }\n \n-    fn warn_about_unreachable(\n+    fn warn_about_unreachable<'desc>(\n         &mut self,\n         orig_span: Span,\n         orig_ty: Ty<'tcx>,\n         expr_span: Span,\n         expr_id: HirId,\n-        descr: &str,\n+        descr: &'desc str,\n     ) {\n         if !orig_ty.is_never() {\n             // Unreachable code warnings are already emitted during type checking.\n@@ -1316,22 +1316,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             // that we do not emit the same warning twice if the uninhabited type\n             // is indeed `!`.\n \n-            let msg = format!(\"unreachable {}\", descr);\n-            self.ir.tcx.struct_span_lint_hir(\n+            self.ir.tcx.emit_spanned_lint(\n                 lint::builtin::UNREACHABLE_CODE,\n                 expr_id,\n                 expr_span,\n-                &msg,\n-                |diag| {\n-                    diag.span_label(expr_span, &msg)\n-                        .span_label(orig_span, \"any code following this expression is unreachable\")\n-                        .span_note(\n-                            orig_span,\n-                            &format!(\n-                                \"this expression has type `{}`, which is uninhabited\",\n-                                orig_ty\n-                            ),\n-                        )\n+                errors::UnreachableDueToUninhabited {\n+                    expr: expr_span,\n+                    orig: orig_span,\n+                    descr,\n+                    ty: orig_ty,\n                 },\n             );\n         }\n@@ -1483,23 +1476,21 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 if self.used_on_entry(entry_ln, var) {\n                     if !self.live_on_entry(entry_ln, var) {\n                         if let Some(name) = self.should_warn(var) {\n-                            self.ir.tcx.struct_span_lint_hir(\n+                            self.ir.tcx.emit_spanned_lint(\n                                 lint::builtin::UNUSED_ASSIGNMENTS,\n                                 var_hir_id,\n                                 vec![span],\n-                                format!(\"value captured by `{}` is never read\", name),\n-                                |lint| lint.help(\"did you mean to capture by reference instead?\"),\n+                                errors::UnusedCaptureMaybeCaptureRef { name },\n                             );\n                         }\n                     }\n                 } else {\n                     if let Some(name) = self.should_warn(var) {\n-                        self.ir.tcx.struct_span_lint_hir(\n+                        self.ir.tcx.emit_spanned_lint(\n                             lint::builtin::UNUSED_VARIABLES,\n                             var_hir_id,\n                             vec![span],\n-                            format!(\"unused variable: `{}`\", name),\n-                            |lint| lint.help(\"did you mean to capture by reference instead?\"),\n+                            errors::UnusedVarMaybeCaptureRef { name },\n                         );\n                     }\n                 }\n@@ -1514,11 +1505,14 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 Some(entry_ln),\n                 Some(body),\n                 |spans, hir_id, ln, var| {\n-                    if !self.live_on_entry(ln, var) {\n-                        self.report_unused_assign(hir_id, spans, var, |name| {\n-                            format!(\"value passed to `{}` is never read\", name)\n-                        });\n-                    }\n+                    if !self.live_on_entry(ln, var)\n+                        && let Some(name) = self.should_warn(var) {\n+                            self.ir.tcx.emit_spanned_lint(\n+                                lint::builtin::UNUSED_ASSIGNMENTS,\n+                                hir_id,\n+                                spans,\n+                                errors::UnusedAssignPassed { name },\n+                            );                    }\n                 },\n             );\n         }\n@@ -1587,39 +1581,35 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 if ln == self.exit_ln { false } else { self.assigned_on_exit(ln, var) };\n \n             if is_assigned {\n-                self.ir.tcx.struct_span_lint_hir(\n+                self.ir.tcx.emit_spanned_lint(\n                     lint::builtin::UNUSED_VARIABLES,\n                     first_hir_id,\n                     hir_ids_and_spans\n                         .into_iter()\n                         .map(|(_, _, ident_span)| ident_span)\n                         .collect::<Vec<_>>(),\n-                    format!(\"variable `{}` is assigned to, but never used\", name),\n-                    |lint| lint.note(&format!(\"consider using `_{}` instead\", name)),\n+                    errors::UnusedVarAssignedOnly { name },\n                 )\n             } else if can_remove {\n-                self.ir.tcx.struct_span_lint_hir(\n+                let spans = hir_ids_and_spans\n+                    .iter()\n+                    .map(|(_, pat_span, _)| {\n+                        let span = self\n+                            .ir\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_extend_to_next_char(*pat_span, ',', true);\n+                        span.with_hi(BytePos(span.hi().0 + 1))\n+                    })\n+                    .collect();\n+                self.ir.tcx.emit_spanned_lint(\n                     lint::builtin::UNUSED_VARIABLES,\n                     first_hir_id,\n                     hir_ids_and_spans.iter().map(|(_, pat_span, _)| *pat_span).collect::<Vec<_>>(),\n-                    format!(\"unused variable: `{}`\", name),\n-                    |lint| {\n-                        lint.multipart_suggestion(\n-                            \"try removing the field\",\n-                            hir_ids_and_spans\n-                                .iter()\n-                                .map(|(_, pat_span, _)| {\n-                                    let span = self\n-                                        .ir\n-                                        .tcx\n-                                        .sess\n-                                        .source_map()\n-                                        .span_extend_to_next_char(*pat_span, ',', true);\n-                                    (span.with_hi(BytePos(span.hi().0 + 1)), String::new())\n-                                })\n-                                .collect(),\n-                            Applicability::MachineApplicable,\n-                        )\n+                    errors::UnusedVarRemoveField {\n+                        name,\n+                        sugg: errors::UnusedVarRemoveFieldSugg { spans },\n                     },\n                 );\n             } else {\n@@ -1633,121 +1623,87 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 // the field\" message, and suggest `_` for the non-shorthands. If we only\n                 // have non-shorthand, then prefix with an underscore instead.\n                 if !shorthands.is_empty() {\n-                    let shorthands = shorthands\n-                        .into_iter()\n-                        .map(|(_, pat_span, _)| (pat_span, format!(\"{}: _\", name)))\n-                        .chain(\n-                            non_shorthands\n-                                .into_iter()\n-                                .map(|(_, pat_span, _)| (pat_span, \"_\".to_string())),\n-                        )\n-                        .collect::<Vec<_>>();\n+                    let shorthands =\n+                        shorthands.into_iter().map(|(_, pat_span, _)| pat_span).collect();\n+                    let non_shorthands =\n+                        non_shorthands.into_iter().map(|(_, pat_span, _)| pat_span).collect();\n \n-                    self.ir.tcx.struct_span_lint_hir(\n+                    self.ir.tcx.emit_spanned_lint(\n                         lint::builtin::UNUSED_VARIABLES,\n                         first_hir_id,\n                         hir_ids_and_spans\n                             .iter()\n                             .map(|(_, pat_span, _)| *pat_span)\n                             .collect::<Vec<_>>(),\n-                        format!(\"unused variable: `{}`\", name),\n-                        |lint| {\n-                            lint.multipart_suggestion(\n-                                \"try ignoring the field\",\n+                        errors::UnusedVarTryIgnore {\n+                            sugg: errors::UnusedVarTryIgnoreSugg {\n                                 shorthands,\n-                                Applicability::MachineApplicable,\n-                            )\n+                                non_shorthands,\n+                                name,\n+                            },\n                         },\n                     );\n                 } else {\n                     let non_shorthands = non_shorthands\n                         .into_iter()\n-                        .map(|(_, _, ident_span)| (ident_span, format!(\"_{}\", name)))\n+                        .map(|(_, _, ident_span)| ident_span)\n                         .collect::<Vec<_>>();\n-\n-                    self.ir.tcx.struct_span_lint_hir(\n+                    let suggestions = self.string_interp_suggestions(&name, opt_body);\n+                    self.ir.tcx.emit_spanned_lint(\n                         lint::builtin::UNUSED_VARIABLES,\n                         first_hir_id,\n                         hir_ids_and_spans\n                             .iter()\n                             .map(|(_, _, ident_span)| *ident_span)\n                             .collect::<Vec<_>>(),\n-                        format!(\"unused variable: `{}`\", name),\n-                        |lint| {\n-                            if self.has_added_lit_match_name_span(&name, opt_body, lint) {\n-                                lint.span_label(pat.span, \"unused variable\");\n-                            }\n-                            lint.multipart_suggestion(\n-                                \"if this is intentional, prefix it with an underscore\",\n-                                non_shorthands,\n-                                Applicability::MachineApplicable,\n-                            )\n+                        errors::UnusedVariableTryPrefix {\n+                            label: if !suggestions.is_empty() { Some(pat.span) } else { None },\n+                            sugg: errors::UnusedVariableTryPrefixSugg {\n+                                spans: non_shorthands,\n+                                name,\n+                            },\n+                            string_interp: suggestions,\n                         },\n                     );\n                 }\n             }\n         }\n     }\n \n-    fn has_added_lit_match_name_span(\n+    fn string_interp_suggestions(\n         &self,\n         name: &str,\n         opt_body: Option<&hir::Body<'_>>,\n-        err: &mut Diagnostic,\n-    ) -> bool {\n-        let mut has_litstring = false;\n-        let Some(opt_body) = opt_body else {return false;};\n+    ) -> Vec<errors::UnusedVariableStringInterp> {\n+        let mut suggs = Vec::new();\n+        let Some(opt_body) = opt_body else { return suggs; };\n         let mut visitor = CollectLitsVisitor { lit_exprs: vec![] };\n         intravisit::walk_body(&mut visitor, opt_body);\n         for lit_expr in visitor.lit_exprs {\n             let hir::ExprKind::Lit(litx) = &lit_expr.kind else { continue };\n             let rustc_ast::LitKind::Str(syb, _) = litx.node else{ continue; };\n             let name_str: &str = syb.as_str();\n-            let mut name_pa = String::from(\"{\");\n-            name_pa.push_str(&name);\n-            name_pa.push('}');\n+            let name_pa = format!(\"{{{name}}}\");\n             if name_str.contains(&name_pa) {\n-                err.span_label(\n-                    lit_expr.span,\n-                    \"you might have meant to use string interpolation in this string literal\",\n-                );\n-                err.multipart_suggestion(\n-                    \"string interpolation only works in `format!` invocations\",\n-                    vec![\n-                        (lit_expr.span.shrink_to_lo(), \"format!(\".to_string()),\n-                        (lit_expr.span.shrink_to_hi(), \")\".to_string()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-                has_litstring = true;\n+                suggs.push(errors::UnusedVariableStringInterp {\n+                    lit: lit_expr.span,\n+                    lo: lit_expr.span.shrink_to_lo(),\n+                    hi: lit_expr.span.shrink_to_hi(),\n+                });\n             }\n         }\n-        has_litstring\n+        suggs\n     }\n \n     fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n-        if !self.live_on_exit(ln, var) {\n-            self.report_unused_assign(hir_id, spans, var, |name| {\n-                format!(\"value assigned to `{}` is never read\", name)\n-            });\n-        }\n-    }\n-\n-    fn report_unused_assign(\n-        &self,\n-        hir_id: HirId,\n-        spans: Vec<Span>,\n-        var: Variable,\n-        message: impl Fn(&str) -> String,\n-    ) {\n-        if let Some(name) = self.should_warn(var) {\n-            self.ir.tcx.struct_span_lint_hir(\n-                lint::builtin::UNUSED_ASSIGNMENTS,\n-                hir_id,\n-                spans,\n-                message(&name),\n-                |lint| lint.help(\"maybe it is overwritten before being read?\"),\n-            )\n-        }\n+        if !self.live_on_exit(ln, var)\n+            && let Some(name) = self.should_warn(var) {\n+                self.ir.tcx.emit_spanned_lint(\n+                    lint::builtin::UNUSED_ASSIGNMENTS,\n+                    hir_id,\n+                    spans,\n+                    errors::UnusedAssign { name },\n+                );\n+            }\n     }\n }"}, {"sha": "9615f283ff423d1819d065e90ff5a3d24f03922f", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -7,7 +7,6 @@ use rustc_attr::{\n     UnstableReason, VERSION_PLACEHOLDER,\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -759,12 +758,11 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                         // do not lint when the trait isn't resolved, since resolution error should\n                         // be fixed first\n                         if t.path.res != Res::Err && c.fully_stable {\n-                            self.tcx.struct_span_lint_hir(\n+                            self.tcx.emit_spanned_lint(\n                                 INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n                                 item.hir_id(),\n                                 span,\n-                                \"an `#[unstable]` annotation here has no effect\",\n-                                |lint| lint.note(\"see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\")\n+                                errors::IneffectiveUnstableImpl,\n                             );\n                         }\n                     }\n@@ -1095,29 +1093,16 @@ fn unnecessary_partially_stable_feature_lint(\n     implies: Symbol,\n     since: Symbol,\n ) {\n-    tcx.struct_span_lint_hir(\n+    tcx.emit_spanned_lint(\n         lint::builtin::STABLE_FEATURES,\n         hir::CRATE_HIR_ID,\n         span,\n-        format!(\n-            \"the feature `{feature}` has been partially stabilized since {since} and is succeeded \\\n-             by the feature `{implies}`\"\n-        ),\n-        |lint| {\n-            lint.span_suggestion(\n-                span,\n-                &format!(\n-                \"if you are using features which are still unstable, change to using `{implies}`\"\n-            ),\n-                implies,\n-                Applicability::MaybeIncorrect,\n-            )\n-            .span_suggestion(\n-                tcx.sess.source_map().span_extend_to_line(span),\n-                \"if you are using features which are now stable, remove this line\",\n-                \"\",\n-                Applicability::MaybeIncorrect,\n-            )\n+        errors::UnnecessaryPartialStableFeature {\n+            span,\n+            line: tcx.sess.source_map().span_extend_to_line(span),\n+            feature,\n+            since,\n+            implies,\n         },\n     );\n }\n@@ -1131,7 +1116,10 @@ fn unnecessary_stable_feature_lint(\n     if since.as_str() == VERSION_PLACEHOLDER {\n         since = rust_version_symbol();\n     }\n-    tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, format!(\"the feature `{feature}` has been stable since {since} and no longer requires an attribute to enable\"), |lint| {\n-        lint\n-    });\n+    tcx.emit_spanned_lint(\n+        lint::builtin::STABLE_FEATURES,\n+        hir::CRATE_HIR_ID,\n+        span,\n+        errors::UnnecessaryStableFeature { feature, since },\n+    );\n }"}, {"sha": "671e6d31a5775aeb25196da84044adc90a61c80e", "filename": "src/doc/style-guide/src/statements.md", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -138,18 +138,31 @@ Otherwise, the `else` keyword and opening brace should be placed on the next lin\n For example:\n \n ```rust\n-let Some(x) = abcdef()\n-    .foo(\n-        \"abc\",\n-        some_really_really_really_long_ident,\n-        \"ident\",\n-        \"123456\",\n-    )\n-    .bar()\n-    .baz()\n-    .qux(\"fffffffffffffffff\")\n-else {\n-    foo_bar()\n+fn main() {\n+    let Some(x) = abcdef()\n+        .foo(\n+            \"abc\",\n+            some_really_really_really_long_ident,\n+            \"ident\",\n+            \"123456\",\n+        )\n+        .bar()\n+        .baz()\n+        .qux(\"fffffffffffffffff\")\n+    else {\n+        return\n+    };\n+\n+    let Some(x) = some_really_really_really_really_really_really_really_really_really_long_name\n+    else {\n+        return;\n+    };\n+\n+    let Some(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) =\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n+    else {\n+        return;\n+    };\n }\n ```\n "}, {"sha": "e7e83c7aacd477d16d452b7edf74fc483089bb99", "filename": "tests/debuginfo/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fdebuginfo%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fdebuginfo%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Fthread.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -1,4 +1,4 @@\n-// Testing the the display of JoinHandle and Thread in cdb.\n+// Testing the display of JoinHandle and Thread in cdb.\n \n // cdb-only\n // min-cdb-version: 10.0.18317.1001"}, {"sha": "9bced25a5957d89b9eae3772dce9a45037b8d4d4", "filename": "tests/mir-opt/building/async_await.b-{closure#0}.generator_resume.0.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fmir-opt%2Fbuilding%2Fasync_await.b-%7Bclosure%230%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fmir-opt%2Fbuilding%2Fasync_await.b-%7Bclosure%230%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fasync_await.b-%7Bclosure%230%7D.generator_resume.0.mir?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -12,7 +12,7 @@\n         _1: GeneratorSavedTy {\n             ty: impl std::future::Future<Output = ()>,\n             source_info: SourceInfo {\n-                span: $DIR/async_await.rs:16:8: 16:14 (#11),\n+                span: $DIR/async_await.rs:16:8: 16:14 (#10),\n                 scope: scope[0],\n             },\n             ignore_for_traits: false,"}, {"sha": "b7e8870fdf548a0318078a24e832264f87230932", "filename": "tests/rustdoc-ui/doc_cfg_hide.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Frustdoc-ui%2Fdoc_cfg_hide.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Frustdoc-ui%2Fdoc_cfg_hide.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fdoc_cfg_hide.stderr?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -16,7 +16,7 @@ LL | #![deny(warnings)]\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(cfg_hide(doc))]\n-   | ~~~~~~~~~~~~~~~~~~~~~~\n+   |  +\n \n error: `#[doc(cfg_hide(...)]` takes a list of attributes\n   --> $DIR/doc_cfg_hide.rs:4:8"}, {"sha": "c231e43b35caff712fb2a7f91c26ac1e6e7e05e5", "filename": "tests/rustdoc-ui/invalid-doc-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Frustdoc-ui%2Finvalid-doc-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Frustdoc-ui%2Finvalid-doc-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finvalid-doc-attr.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -5,7 +5,7 @@\n //~^ ERROR can only be applied at the crate level\n //~| WARN is being phased out\n //~| HELP to apply to the crate, use an inner attribute\n-//~| SUGGESTION #![doc(test(no_crate_inject))]\n+//~| SUGGESTION !\n #[doc(inline)]\n //~^ ERROR can only be applied to a `use` item\n //~| WARN is being phased out"}, {"sha": "b23b8ded8674bf1dda2aee60cf47398e66d0f61b", "filename": "tests/rustdoc-ui/invalid-doc-attr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Frustdoc-ui%2Finvalid-doc-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Frustdoc-ui%2Finvalid-doc-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finvalid-doc-attr.stderr?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -16,7 +16,7 @@ LL | #![deny(warnings)]\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(test(no_crate_inject))]\n-   |\n+   |  +\n \n error: this attribute can only be applied to a `use` item\n   --> $DIR/invalid-doc-attr.rs:9:7"}, {"sha": "c231e43b35caff712fb2a7f91c26ac1e6e7e05e5", "filename": "tests/ui/attributes/invalid-doc-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fattributes%2Finvalid-doc-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fattributes%2Finvalid-doc-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid-doc-attr.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -5,7 +5,7 @@\n //~^ ERROR can only be applied at the crate level\n //~| WARN is being phased out\n //~| HELP to apply to the crate, use an inner attribute\n-//~| SUGGESTION #![doc(test(no_crate_inject))]\n+//~| SUGGESTION !\n #[doc(inline)]\n //~^ ERROR can only be applied to a `use` item\n //~| WARN is being phased out"}, {"sha": "b23b8ded8674bf1dda2aee60cf47398e66d0f61b", "filename": "tests/ui/attributes/invalid-doc-attr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fattributes%2Finvalid-doc-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fattributes%2Finvalid-doc-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid-doc-attr.stderr?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -16,7 +16,7 @@ LL | #![deny(warnings)]\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(test(no_crate_inject))]\n-   |\n+   |  +\n \n error: this attribute can only be applied to a `use` item\n   --> $DIR/invalid-doc-attr.rs:9:7"}, {"sha": "0ea81b5aecb9e9757020012941400743eaa33d84", "filename": "tests/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -189,7 +189,7 @@ trait MultipleMethods {\n }\n \n // We would normally require `Self: 'a`, but we can prove that `Self: 'static`\n-// because of the the bounds on the trait, so the bound is proven\n+// because of the bounds on the trait, so the bound is proven\n trait Trait: 'static {\n     type Assoc<'a>;\n     fn make_assoc(_: &u32) -> Self::Assoc<'_>;"}, {"sha": "538eeadae0836ff80d794727141959a2be39f4c9", "filename": "tests/ui/methods/method-not-found-generic-arg-elision.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.rs?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -83,8 +83,8 @@ fn main() {\n     //~^ ERROR no method named `distance` found for struct `Point<i32>\n     let d = point_i32.other();\n     //~^ ERROR no method named `other` found for struct `Point\n-    let v = vec![1_i32, 2, 3];\n-    v.iter().map(|x| x * x).extend(std::iter::once(100));\n+    let v = vec![1, 2, 3];\n+    v.iter().map(Box::new(|x| x * x) as Box<dyn Fn(&i32) -> i32>).extend(std::iter::once(100));\n     //~^ ERROR no method named `extend` found for struct `Map\n     let wrapper = Wrapper(true);\n     wrapper.method();"}, {"sha": "b97688d3868b8069a75d3b014eaff45dd7f43c19", "filename": "tests/ui/methods/method-not-found-generic-arg-elision.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/901fdb3b04375e3456b5cf771f86ecca8d6c1917/tests%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr?ref=901fdb3b04375e3456b5cf771f86ecca8d6c1917", "patch": "@@ -20,10 +20,10 @@ LL |     let d = point_i32.other();\n    |                       ^^^^^ method not found in `Point<i32>`\n \n error[E0599]: no method named `extend` found for struct `Map` in the current scope\n-  --> $DIR/method-not-found-generic-arg-elision.rs:87:29\n+  --> $DIR/method-not-found-generic-arg-elision.rs:87:67\n    |\n-LL |     v.iter().map(|x| x * x).extend(std::iter::once(100));\n-   |                             ^^^^^^ method not found in `Map<Iter<'_, i32>, [closure@method-not-found-generic-arg-elision.rs:87:18]>`\n+LL |     v.iter().map(Box::new(|x| x * x) as Box<dyn Fn(&i32) -> i32>).extend(std::iter::once(100));\n+   |                                                                   ^^^^^^ method not found in `Map<Iter<'_, i32>, Box<dyn Fn(&i32) -> i32>>`\n \n error[E0599]: no method named `method` found for struct `Wrapper<bool>` in the current scope\n   --> $DIR/method-not-found-generic-arg-elision.rs:90:13"}]}