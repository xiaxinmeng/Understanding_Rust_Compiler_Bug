{"sha": "cd1fa91d2bf97a6331e1d0265eec0f3324191f89", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMWZhOTFkMmJmOTdhNjMzMWUxZDAyNjVlZWMwZjMzMjQxOTFmODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-11T18:37:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-11T18:37:13Z"}, "message": "auto merge of #17801 : Gankro/rust/collections-stuff, r=sfackler\n\nI previously avoided `#[inline]`ing anything assuming someone would come in and explain to me where this would be appropriate. Apparently no one *really* knows, so I'll just go the opposite way an inline everything assuming someone will come in and yell at me that such-and-such shouldn't be `#[inline]`.\r\n\r\n==================\r\n\r\nFor posterity, iteration comparisons:\r\n\r\n```\r\ntest btree::map::bench::iter_20                            ... bench:       971 ns/iter (+/- 30)\r\ntest btree::map::bench::iter_1000                          ... bench:     29445 ns/iter (+/- 480)\r\ntest btree::map::bench::iter_100000                        ... bench:   2929035 ns/iter (+/- 21551)\r\n\r\ntest treemap::bench::iter_20                               ... bench:       530 ns/iter (+/- 66)\r\ntest treemap::bench::iter_1000                             ... bench:     26287 ns/iter (+/- 825)\r\ntest treemap::bench::iter_100000                           ... bench:   7650084 ns/iter (+/- 356711)\r\n\r\ntest trie::bench_map::iter_20                              ... bench:       646 ns/iter (+/- 265)\r\ntest trie::bench_map::iter_1000                            ... bench:     43556 ns/iter (+/- 5014)\r\ntest trie::bench_map::iter_100000                          ... bench:  12988002 ns/iter (+/- 139676)\r\n```\r\n\r\nAs you can see `btree` \"scales\" much better than `treemap`. `triemap` scales quite poorly.\r\n\r\nNote that *completely* different results are given if the elements are inserted in order from the range [0, size]. In particular, TrieMap *completely* dominates in the sorted case. This suggests adding benches for both might be worthwhile. However unsorted is *probably* the more \"normal\" case, so I consider this \"good enough\" for now.", "tree": {"sha": "ee50ddbe24299b1a263167a9b00a0075561c08f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee50ddbe24299b1a263167a9b00a0075561c08f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd1fa91d2bf97a6331e1d0265eec0f3324191f89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd1fa91d2bf97a6331e1d0265eec0f3324191f89", "html_url": "https://github.com/rust-lang/rust/commit/cd1fa91d2bf97a6331e1d0265eec0f3324191f89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd1fa91d2bf97a6331e1d0265eec0f3324191f89/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d031d7f86a66270d3cfc28a2ecf75706a67054b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d031d7f86a66270d3cfc28a2ecf75706a67054b", "html_url": "https://github.com/rust-lang/rust/commit/4d031d7f86a66270d3cfc28a2ecf75706a67054b"}, {"sha": "f91c680e95bdb855c4086d9db0477a057b9f49f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f91c680e95bdb855c4086d9db0477a057b9f49f6", "html_url": "https://github.com/rust-lang/rust/commit/f91c680e95bdb855c4086d9db0477a057b9f49f6"}], "stats": {"total": 158, "additions": 140, "deletions": 18}, "files": [{"sha": "dbbff61b8dd50c139154eb800a05892f7a6843d3", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cd1fa91d2bf97a6331e1d0265eec0f3324191f89/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1fa91d2bf97a6331e1d0265eec0f3324191f89/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=cd1fa91d2bf97a6331e1d0265eec0f3324191f89", "patch": "@@ -29,6 +29,47 @@ use ringbuf::RingBuf;\n \n \n /// A map based on a B-Tree.\n+///\n+/// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n+/// the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal\n+/// choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of\n+/// comparisons necessary to find an element (log<sub>2</sub>n). However, in practice the way this\n+/// is done is *very* inefficient for modern computer architectures. In particular, every element\n+/// is stored in its own individually heap-allocated node. This means that every single insertion\n+/// triggers a heap-allocation, and every single comparison should be a cache-miss. Since these\n+/// are both notably expensive things to do in practice, we are forced to at very least reconsider\n+/// the BST strategy.\n+///\n+/// A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing\n+/// this, we reduce the number of allocations by a factor of B, and improve cache effeciency in\n+/// searches. However, this does mean that searches will have to do *more* comparisons on average.\n+/// The precise number of comparisons depends on the node search strategy used. For optimal cache\n+/// effeciency, one could search the nodes linearly. For optimal comparisons, one could search\n+/// the node using binary search. As a compromise, one could also perform a linear search\n+/// that initially only checks every i<sup>th</sup> element for some choice of i.\n+///\n+/// Currently, our implementation simply performs naive linear search. This provides excellent\n+/// performance on *small* nodes of elements which are cheap to compare. However in the future we\n+/// would like to further explore choosing the optimal search strategy based on the choice of B,\n+/// and possibly other factors. Using linear search, searching for a random element is expected\n+/// to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n+/// however, performance is excellent. `BTreeMap` is able to readily outperform `TreeMap` under\n+/// many workloads, and is competetive where it doesn't. BTreeMap also generally *scales* better\n+/// than TreeMap, making it more appropriate for large datasets.\n+///\n+/// However, `TreeMap` may still be more appropriate to use in many contexts. If elements are very\n+/// large or expensive to compare, `TreeMap` may be more appropriate. It won't allocate any\n+/// more space than is needed, and will perform the minimal number of comparisons necessary.\n+/// `TreeMap` also provides much better performance stability guarantees. Generally, very few\n+/// changes need to be made to update a BST, and two updates are expected to take about the same\n+/// amount of time on roughly equal sized BSTs. However a B-Tree's performance is much more\n+/// amortized. If a node is overfull, it must be split into two nodes. If a node is underfull, it\n+/// may be merged with another. Both of these operations are relatively expensive to perform, and\n+/// it's possible to force one to occur at every single level of the tree in a single insertion or\n+/// deletion. In fact, a malicious or otherwise unlucky sequence of insertions and deletions can\n+/// force this degenerate behaviour to occur on every operation. While the total amount of work\n+/// done on each operation isn't *catastrophic*, and *is* still bounded by O(B log<sub>B</sub>n),\n+/// it is certainly much slower when it does.\n #[deriving(Clone)]\n pub struct BTreeMap<K, V> {\n     root: Node<K, V>,\n@@ -93,6 +134,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n \n     /// Makes a new empty BTreeMap with the given B.\n+    ///\n+    /// B cannot be less than 2.\n     pub fn with_b(b: uint) -> BTreeMap<K, V> {\n         assert!(b > 1, \"B must be greater than 1\");\n         BTreeMap {\n@@ -1145,9 +1188,12 @@ mod test {\n \n #[cfg(test)]\n mod bench {\n-    use test::Bencher;\n+    use std::prelude::*;\n+    use std::rand::{weak_rng, Rng};\n+    use test::{Bencher, black_box};\n \n     use super::BTreeMap;\n+    use MutableMap;\n     use deque::bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n \n     #[bench]\n@@ -1200,4 +1246,34 @@ mod bench {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n         find_seq_n(10_000, &mut m, b);\n     }\n+\n+    fn bench_iter(b: &mut Bencher, size: uint) {\n+        let mut map = BTreeMap::<uint, uint>::new();\n+        let mut rng = weak_rng();\n+\n+        for _ in range(0, size) {\n+            map.swap(rng.gen(), rng.gen());\n+        }\n+\n+        b.iter(|| {\n+            for entry in map.iter() {\n+                black_box(entry);\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    pub fn iter_20(b: &mut Bencher) {\n+        bench_iter(b, 20);\n+    }\n+\n+    #[bench]\n+    pub fn iter_1000(b: &mut Bencher) {\n+        bench_iter(b, 1000);\n+    }\n+\n+    #[bench]\n+    pub fn iter_100000(b: &mut Bencher) {\n+        bench_iter(b, 100000);\n+    }\n }"}, {"sha": "8958f0ef5bee749eee1b7f391fffda60918c5e7c", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd1fa91d2bf97a6331e1d0265eec0f3324191f89/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1fa91d2bf97a6331e1d0265eec0f3324191f89/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=cd1fa91d2bf97a6331e1d0265eec0f3324191f89", "patch": "@@ -23,6 +23,9 @@ use core::fmt::Show;\n use {Mutable, Set, MutableSet, MutableMap, Map};\n \n /// A set based on a B-Tree.\n+///\n+/// See BTreeMap's documentation for a detailed discussion of this collection's performance\n+/// benefits and drawbacks.\n #[deriving(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n pub struct BTreeSet<T>{\n     map: BTreeMap<T, ()>,\n@@ -65,6 +68,8 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Makes a new BTreeSet with the given B.\n+    ///\n+    /// B cannot be less than 2.\n     pub fn with_b(b: uint) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n     }"}, {"sha": "a86e7386eddd8c07b55369721e030d07c5055f4a", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd1fa91d2bf97a6331e1d0265eec0f3324191f89/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1fa91d2bf97a6331e1d0265eec0f3324191f89/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=cd1fa91d2bf97a6331e1d0265eec0f3324191f89", "patch": "@@ -2232,9 +2232,12 @@ mod test_treemap {\n \n #[cfg(test)]\n mod bench {\n-    use test::Bencher;\n+    use std::prelude::*;\n+    use std::rand::{weak_rng, Rng};\n+    use test::{Bencher, black_box};\n \n     use super::TreeMap;\n+    use MutableMap;\n     use deque::bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n \n     // Find seq\n@@ -2288,6 +2291,36 @@ mod bench {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n         find_seq_n(10_000, &mut m, b);\n     }\n+\n+    fn bench_iter(b: &mut Bencher, size: uint) {\n+        let mut map = TreeMap::<uint, uint>::new();\n+        let mut rng = weak_rng();\n+\n+        for _ in range(0, size) {\n+            map.swap(rng.gen(), rng.gen());\n+        }\n+\n+        b.iter(|| {\n+            for entry in map.iter() {\n+                black_box(entry);\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    pub fn iter_20(b: &mut Bencher) {\n+        bench_iter(b, 20);\n+    }\n+\n+    #[bench]\n+    pub fn iter_1000(b: &mut Bencher) {\n+        bench_iter(b, 1000);\n+    }\n+\n+    #[bench]\n+    pub fn iter_100000(b: &mut Bencher) {\n+        bench_iter(b, 100000);\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "2e388a92a59f43cbea786ac94119019698e26e67", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cd1fa91d2bf97a6331e1d0265eec0f3324191f89/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1fa91d2bf97a6331e1d0265eec0f3324191f89/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=cd1fa91d2bf97a6331e1d0265eec0f3324191f89", "patch": "@@ -949,8 +949,8 @@ macro_rules! iterator_impl {\n                 // rules, and are just manipulating raw pointers like there's no\n                 // such thing as invalid pointers and memory unsafety. The\n                 // reason is performance, without doing this we can get the\n-                // bench_iter_large microbenchmark down to about 30000 ns/iter\n-                // (using .unsafe_get to index self.stack directly, 38000\n+                // (now replaced) bench_iter_large microbenchmark down to about\n+                // 30000 ns/iter (using .unsafe_get to index self.stack directly, 38000\n                 // ns/iter with [] checked indexing), but this smashes that down\n                 // to 13500 ns/iter.\n                 //\n@@ -1459,31 +1459,39 @@ mod test_map {\n mod bench_map {\n     use std::prelude::*;\n     use std::rand::{weak_rng, Rng};\n-    use test::Bencher;\n+    use test::{Bencher, black_box};\n \n     use MutableMap;\n     use super::TrieMap;\n \n-    #[bench]\n-    fn bench_iter_small(b: &mut Bencher) {\n-        let mut m = TrieMap::<uint>::new();\n+    fn bench_iter(b: &mut Bencher, size: uint) {\n+        let mut map = TrieMap::<uint>::new();\n         let mut rng = weak_rng();\n-        for _ in range(0u, 20) {\n-            m.insert(rng.gen(), rng.gen());\n+\n+        for _ in range(0, size) {\n+            map.swap(rng.gen(), rng.gen());\n         }\n \n-        b.iter(|| for _ in m.iter() {})\n+        b.iter(|| {\n+            for entry in map.iter() {\n+                black_box(entry);\n+            }\n+        });\n     }\n \n     #[bench]\n-    fn bench_iter_large(b: &mut Bencher) {\n-        let mut m = TrieMap::<uint>::new();\n-        let mut rng = weak_rng();\n-        for _ in range(0u, 1000) {\n-            m.insert(rng.gen(), rng.gen());\n-        }\n+    pub fn iter_20(b: &mut Bencher) {\n+        bench_iter(b, 20);\n+    }\n \n-        b.iter(|| for _ in m.iter() {})\n+    #[bench]\n+    pub fn iter_1000(b: &mut Bencher) {\n+        bench_iter(b, 1000);\n+    }\n+\n+    #[bench]\n+    pub fn iter_100000(b: &mut Bencher) {\n+        bench_iter(b, 100000);\n     }\n \n     #[bench]"}]}