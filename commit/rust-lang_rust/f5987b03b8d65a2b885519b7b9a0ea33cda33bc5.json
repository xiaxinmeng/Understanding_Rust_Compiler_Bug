{"sha": "f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1OTg3YjAzYjhkNjVhMmI4ODU1MTliN2I5YTBlYTMzY2RhMzNiYzU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-16T00:20:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-18T00:54:18Z"}, "message": "core::rt: implement `oneshot` and `stream`.", "tree": {"sha": "34f207d840cf8fb2c3e18d93178f7b8e6455db62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34f207d840cf8fb2c3e18d93178f7b8e6455db62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "html_url": "https://github.com/rust-lang/rust/commit/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03a8e59615f7ced4def8adaad41cfcb0fd0f9d29", "url": "https://api.github.com/repos/rust-lang/rust/commits/03a8e59615f7ced4def8adaad41cfcb0fd0f9d29", "html_url": "https://github.com/rust-lang/rust/commit/03a8e59615f7ced4def8adaad41cfcb0fd0f9d29"}], "stats": {"total": 646, "additions": 645, "deletions": 1}, "files": [{"sha": "9fcb70cfc7d66222b6497abc90f2bc7b4d472c83", "filename": "src/libcore/rt/comm.rs", "status": "added", "additions": 599, "deletions": 0, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5/src%2Flibcore%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5/src%2Flibcore%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcomm.rs?ref=f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "patch": "@@ -0,0 +1,599 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::*;\n+use cast;\n+use util;\n+use ops::Drop;\n+use kinds::Owned;\n+use rt::sched::Coroutine;\n+use rt::local_sched;\n+#[cfg(stage0)]\n+use unstable::intrinsics::{atomic_xchg};\n+#[cfg(not(stage0))]\n+use unstable::intrinsics::{atomic_xchg, atomic_load};\n+use util::Void;\n+use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n+use cell::Cell;\n+\n+/// A combined refcount / ~Task pointer.\n+///\n+/// Can be equal to the following values:\n+///\n+/// * 2 - both endpoints are alive\n+/// * 1 - either the sender or the receiver is dead, determined by context\n+/// * <ptr> - A pointer to a Task that can be transmuted to ~Task\n+type State = int;\n+\n+static STATE_BOTH: State = 2;\n+static STATE_ONE: State = 1;\n+\n+struct Packet<T> {\n+    state: State,\n+    payload: Option<T>,\n+}\n+\n+pub struct PortOne<T> {\n+    // XXX: Hack extra allocation to make by-val self work\n+    inner: ~PortOneHack<T>\n+}\n+\n+pub struct ChanOne<T> {\n+    // XXX: Hack extra allocation to make by-val self work\n+    inner: ~ChanOneHack<T>\n+}\n+\n+pub struct PortOneHack<T> {\n+    void_packet: *mut Void,\n+    suppress_finalize: bool\n+}\n+\n+pub struct ChanOneHack<T> {\n+    void_packet: *mut Void,\n+    suppress_finalize: bool\n+}\n+\n+pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+    let packet: ~Packet<T> = ~Packet {\n+        state: STATE_BOTH,\n+        payload: None\n+    };\n+\n+    unsafe {\n+        let packet: *mut Void = cast::transmute(packet);\n+        let port = PortOne {\n+            inner: ~PortOneHack {\n+                void_packet: packet,\n+                suppress_finalize: false\n+            }\n+        };\n+        let chan = ChanOne {\n+            inner: ~ChanOneHack {\n+                void_packet: packet,\n+                suppress_finalize: false\n+            }\n+        };\n+        return (port, chan);\n+    }\n+}\n+\n+impl<T> PortOne<T> {\n+    pub fn recv(self) -> T {\n+        match self.try_recv() {\n+            Some(val) => val,\n+            None => {\n+                fail!(\"receiving on closed channel\");\n+            }\n+        }\n+    }\n+\n+    pub fn try_recv(self) -> Option<T> {\n+        let mut this = self;\n+\n+        {\n+            let self_ptr: *mut PortOne<T> = &mut this;\n+\n+            // XXX: Optimize this to not require the two context switches when data is available\n+\n+            // Switch to the scheduler\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                unsafe {\n+                    let task_as_state: State = cast::transmute(task);\n+                    let oldstate = atomic_xchg(&mut (*(*self_ptr).inner.packet()).state, task_as_state);\n+                    match oldstate {\n+                        STATE_BOTH => {\n+                            // Data has not been sent. Now we're blocked.\n+                        }\n+                        STATE_ONE => {\n+                            // Channel is closed. Switch back and check the data.\n+                            let task: ~Coroutine = cast::transmute(task_as_state);\n+                            let sched = local_sched::take();\n+                            sched.resume_task_immediately(task);\n+                        }\n+                        _ => util::unreachable()\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Task resumes.\n+\n+        // No further memory barrier is needed here to access the\n+        // payload. Some scenarios:\n+        //\n+        // 1) We encountered STATE_ONE above - the atomic_xchg was the acq barrier. We're fine.\n+        // 2) We encountered STATE_BOTH above and blocked. The sending task work-stole us\n+        //    and ran on its thread. The work stealing had a memory barrier.\n+        // 3) We encountered STATE_BOTH above and blocked, but the receiving task (this task)\n+        //    is pinned to some other scheduler, so the sending task had to give us to\n+        //    a different scheduler for resuming. That send synchronized memory.\n+\n+        unsafe {\n+            let payload = util::replace(&mut (*this.inner.packet()).payload, None);\n+\n+            // The sender has closed up shop. Drop the packet.\n+            let _packet: ~Packet<T> = cast::transmute(this.inner.void_packet);\n+            // Supress the finalizer. We're done here.\n+            this.inner.suppress_finalize = true;\n+\n+            return payload;\n+        }\n+    }\n+}\n+\n+impl<T> Peekable<T> for PortOne<T> {\n+    #[cfg(stage0)]\n+    fn peek(&self) -> bool { fail!() }\n+\n+    #[cfg(not(stage0))]\n+    fn peek(&self) -> bool {\n+        unsafe {\n+            let packet: *mut Packet<T> = self.inner.packet();\n+            let oldstate = atomic_load(&mut (*packet).state);\n+            match oldstate {\n+                STATE_BOTH => false,\n+                STATE_ONE => (*packet).payload.is_some(),\n+                _ => util::unreachable()\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> ChanOne<T> {\n+\n+    pub fn send(self, val: T) {\n+        self.try_send(val);\n+    }\n+\n+    pub fn try_send(self, val: T) -> bool {\n+        let mut this = self;\n+        let mut recvr_active = true;\n+\n+        unsafe {\n+            assert!((*this.inner.packet()).payload.is_none());\n+            (*this.inner.packet()).payload = Some(val);\n+\n+            let oldstate = atomic_xchg(&mut (*this.inner.packet()).state, STATE_ONE);\n+            match oldstate {\n+                STATE_BOTH => {\n+                    // Port is not recving yet. Nothing to do\n+                }\n+                STATE_ONE => {\n+                    // Port has closed. Need to clean up.\n+                    let _packet: ~Packet<T> = cast::transmute(this.inner.void_packet);\n+                    recvr_active = false;\n+                }\n+                _ => {\n+                    // Port is blocked. Wake it up.\n+                    let recvr: ~Coroutine = cast::transmute(oldstate);\n+                    let sched = local_sched::take();\n+                    sched.schedule_task(recvr);\n+                }\n+            }\n+        }\n+\n+        // Suppress the finalizer. We're done here.\n+        this.inner.suppress_finalize = true;\n+        return recvr_active;\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for PortOneHack<T> {\n+    fn finalize(&self) {\n+        if self.suppress_finalize { return }\n+\n+        unsafe {\n+            let this = cast::transmute_mut(self);\n+            let oldstate = atomic_xchg(&mut (*this.packet()).state, STATE_ONE);\n+            match oldstate {\n+                STATE_BOTH => {\n+                    /* cleanup is the chan's responsibility */\n+                },\n+                STATE_ONE => {\n+                    let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n+                }\n+                _ => {\n+                    util::unreachable()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for ChanOneHack<T> {\n+    fn finalize(&self) {\n+        if self.suppress_finalize { return }\n+\n+        unsafe {\n+            let this = cast::transmute_mut(self);\n+            let oldstate = atomic_xchg(&mut (*this.packet()).state, STATE_ONE);\n+            match oldstate {\n+                STATE_BOTH => {\n+                    /* cleanup is the port's responsibility */\n+                },\n+                STATE_ONE => {\n+                    let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n+                },\n+                _ => {\n+                    // The port is blocked recving for a message we will never send. Wake it.\n+                    assert!((*this.packet()).payload.is_none());\n+                    let recvr: ~Coroutine = cast::transmute(oldstate);\n+                    let sched = local_sched::take();\n+                    sched.schedule_task(recvr);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> PortOneHack<T> {\n+    fn packet(&self) -> *mut Packet<T> {\n+        unsafe {\n+            let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n+            let p: *mut Packet<T> = &mut **p;\n+            return p;\n+        }\n+    }\n+}\n+\n+impl<T> ChanOneHack<T> {\n+    fn packet(&self) -> *mut Packet<T> {\n+        unsafe {\n+            let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n+            let p: *mut Packet<T> = &mut **p;\n+            return p;\n+        }\n+    }\n+}\n+\n+struct StreamPayload<T>(T, PortOne<StreamPayload<T>>);\n+\n+pub struct Port<T> {\n+    // FIXME #5372. Using Cell because we don't take &mut self\n+    next: Cell<PortOne<StreamPayload<T>>>\n+}\n+\n+pub struct Chan<T> {\n+    // FIXME #5372. Using Cell because we don't take &mut self\n+    next: Cell<ChanOne<StreamPayload<T>>>\n+}\n+\n+pub fn stream<T: Owned>() -> (Port<T>, Chan<T>) {\n+    let (pone, cone) = oneshot();\n+    let port = Port { next: Cell(pone) };\n+    let chan = Chan { next: Cell(cone) };\n+    return (port, chan);\n+}\n+\n+impl<T> GenericPort<T> for Port<T> {\n+    fn recv(&self) -> T {\n+        match self.try_recv() {\n+            Some(val) => val,\n+            None => {\n+                fail!(\"receiving on closed channel\");\n+            }\n+        }\n+    }\n+\n+    fn try_recv(&self) -> Option<T> {\n+        let pone = self.next.take();\n+        match pone.try_recv() {\n+            Some(StreamPayload(val, next)) => {\n+                self.next.put_back(next);\n+                Some(val)\n+            }\n+            None => None\n+        }\n+    }\n+}\n+\n+impl<T> Peekable<T> for Port<T> {\n+    fn peek(&self) -> bool {\n+        self.next.with_mut_ref(|p| p.peek())\n+    }\n+}\n+\n+impl<T: Owned> GenericChan<T> for Chan<T> {\n+    fn send(&self, val: T) {\n+        self.try_send(val);\n+    }\n+}\n+\n+impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+    fn try_send(&self, val: T) -> bool {\n+        let (next_pone, next_cone) = oneshot();\n+        let cone = self.next.take();\n+        self.next.put_back(next_cone);\n+        cone.try_send(StreamPayload(val, next_pone))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use option::*;\n+    use rt::test::*;\n+    use cell::Cell;\n+    use iter::Times;\n+\n+    #[test]\n+    fn oneshot_single_thread_close_port_first() {\n+        // Simple test of closing without sending\n+        do run_in_newsched_task {\n+            let (port, _chan) = oneshot::<int>();\n+            { let _p = port; }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_close_chan_first() {\n+        // Simple test of closing without sending\n+        do run_in_newsched_task {\n+            let (_port, chan) = oneshot::<int>();\n+            { let _c = chan; }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_send_port_close() {\n+        // Testing that the sender cleans up the payload if receiver is closed\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<~int>();\n+            { let _p = port; }\n+            chan.send(~0);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_recv_chan_close() {\n+        // Receiving on a closed chan will fail\n+        do run_in_newsched_task {\n+            let res = do spawntask_try {\n+                let (port, chan) = oneshot::<~int>();\n+                { let _c = chan; }\n+                port.recv();\n+            };\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_send_then_recv() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<~int>();\n+            chan.send(~10);\n+            assert!(port.recv() == ~10);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_send_open() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            assert!(chan.try_send(10));\n+            assert!(port.recv() == 10);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_send_closed() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            { let _p = port; }\n+            assert!(!chan.try_send(10));\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_recv_open() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            chan.send(10);\n+            assert!(port.try_recv() == Some(10));\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_recv_closed() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            { let _c = chan; }\n+            assert!(port.try_recv() == None);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_peek_data() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            assert!(!port.peek());\n+            chan.send(10);\n+            assert!(port.peek());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_peek_close() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            { let _c = chan; }\n+            assert!(!port.peek());\n+            assert!(!port.peek());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_peek_open() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            assert!(!port.peek());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_task_recv_then_send() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<~int>();\n+            let port_cell = Cell(port);\n+            do spawntask_immediately {\n+                assert!(port_cell.take().recv() == ~10);\n+            }\n+\n+            chan.send(~10);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_task_recv_then_close() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<~int>();\n+            let port_cell = Cell(port);\n+            let chan_cell = Cell(chan);\n+            do spawntask_later {\n+                let _cell = chan_cell.take();\n+            }\n+            let res = do spawntask_try {\n+                assert!(port_cell.take().recv() == ~10);\n+            };\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_close_stress() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = oneshot::<int>();\n+                let port_cell = Cell(port);\n+                let _thread = do spawntask_thread {\n+                    let _p = port_cell.take();\n+                };\n+                let _chan = chan;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_send_close_stress() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = oneshot::<int>();\n+                let chan_cell = Cell(chan);\n+                let port_cell = Cell(port);\n+                let _thread1 = do spawntask_thread {\n+                    let _p = port_cell.take();\n+                };\n+                let _thread2 = do spawntask_thread {\n+                    let c = chan_cell.take();\n+                    c.send(1);\n+                };\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_recv_close_stress() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = oneshot::<int>();\n+                let chan_cell = Cell(chan);\n+                let port_cell = Cell(port);\n+                let _thread1 = do spawntask_thread {\n+                    let port_cell = Cell(port_cell.take());\n+                    let res = do spawntask_try {\n+                        port_cell.take().recv();\n+                    };\n+                    assert!(res.is_err());\n+                };\n+                let _thread2 = do spawntask_thread {\n+                    let chan_cell = Cell(chan_cell.take());\n+                    do spawntask {\n+                        chan_cell.take();\n+                    }\n+                };\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_send_recv_stress() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = oneshot::<~int>();\n+                let chan_cell = Cell(chan);\n+                let port_cell = Cell(port);\n+                let _thread1 = do spawntask_thread {\n+                    chan_cell.take().send(~10);\n+                };\n+                let _thread2 = do spawntask_thread {\n+                    assert!(port_cell.take().recv() == ~10);\n+                };\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn stream_send_recv() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = stream::<~int>();\n+\n+                send(chan, 0);\n+                recv(port, 0);\n+\n+                fn send(chan: Chan<~int>, i: int) {\n+                    if i == 10 { return }\n+\n+                    let chan_cell = Cell(chan);\n+                    let _thread = do spawntask_thread {\n+                        let chan = chan_cell.take();\n+                        chan.send(~i);\n+                        send(chan, i + 1);\n+                    };\n+                }\n+\n+                fn recv(port: Port<~int>, i: int) {\n+                    if i == 10 { return }\n+\n+                    let port_cell = Cell(port);\n+                    let _thread = do spawntask_thread {\n+                        let port = port_cell.take();\n+                        assert!(port.recv() == ~i);\n+                        recv(port, i + 1);\n+                    };\n+                }\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "dab627188d0f57dd9467c365b91376a1239b6b51", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "patch": "@@ -122,6 +122,9 @@ pub mod rc;\n /// scheduler and task context\n pub mod tube;\n \n+/// Simple reimplementation of core::comm\n+pub mod comm;\n+\n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This is invoked by the `start` _language item_ (unstable::lang) to"}, {"sha": "c66f20e01b2d7546b18007081c45a867c2c76e9d", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "patch": "@@ -171,6 +171,17 @@ pub impl Scheduler {\n         }\n     }\n \n+    fn schedule_task(~self, task: ~Coroutine) {\n+        assert!(self.in_task_context());\n+\n+        do self.switch_running_tasks_and_then(task) |last_task| {\n+            let last_task = Cell(last_task);\n+            do local_sched::borrow |sched| {\n+                sched.enqueue_task(last_task.take());\n+            }\n+        }\n+    }\n+\n     // Core scheduling ops\n \n     fn resume_task_immediately(~self, task: ~Coroutine) {"}, {"sha": "d739d0110ba35683e5db3a72b459b286cfc512c6", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "patch": "@@ -8,17 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use uint;\n+use option::*;\n use cell::Cell;\n use result::{Result, Ok, Err};\n use super::io::net::ip::{IpAddr, Ipv4};\n use rt::local_services::LocalServices;\n+use rt::thread::Thread;\n \n /// Creates a new scheduler in a new thread and runs a task in it,\n /// then waits for the scheduler to exit. Failure of the task\n /// will abort the process.\n pub fn run_in_newsched_task(f: ~fn()) {\n+    use super::sched::*;\n     use unstable::run_in_bare_thread;\n-    use super::sched::Coroutine;\n     use rt::uv::uvio::UvEventLoop;\n \n     let f = Cell(f);\n@@ -144,6 +147,23 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     if !failed { Ok(()) } else { Err(()) }\n }\n \n+// Spawn a new task in a new scheduler and return a thread handle.\n+pub fn spawntask_thread(f: ~fn()) -> Thread {\n+    use rt::sched::*;\n+    use rt::uv::uvio::UvEventLoop;\n+\n+    let f = Cell(f);\n+    let thread = do Thread::start {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                          LocalServices::without_unwinding(),\n+                                          f.take());\n+        sched.enqueue_task(task);\n+        sched.run();\n+    };\n+    return thread;\n+}\n+\n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n     unsafe {\n@@ -158,3 +178,14 @@ pub fn next_test_port() -> u16 {\n pub fn next_test_ip4() -> IpAddr {\n     Ipv4(127, 0, 0, 1, next_test_port())\n }\n+\n+/// Get a constant that represents the number of times to repeat stress tests. Default 1.\n+pub fn stress_factor() -> uint {\n+    use os::getenv;\n+\n+    match getenv(\"RUST_RT_STRESS\") {\n+        Some(val) => uint::from_str(val).get(),\n+        None => 1\n+    }\n+}\n+"}]}