{"sha": "d3476f4b7694b8453cf52268880057a9df938089", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNDc2ZjRiNzY5NGI4NDUzY2Y1MjI2ODg4MDA1N2E5ZGY5MzgwODk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-23T14:43:23Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-04-23T20:09:21Z"}, "message": "cache ADT dtorck results\n\nThis avoids visiting the fields of all structs multiple times, improving\nitem-bodies checking time by 10% (!).", "tree": {"sha": "d906f9a263abe6302ee7f0a90e1f9b9b280fa0ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d906f9a263abe6302ee7f0a90e1f9b9b280fa0ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3476f4b7694b8453cf52268880057a9df938089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3476f4b7694b8453cf52268880057a9df938089", "html_url": "https://github.com/rust-lang/rust/commit/d3476f4b7694b8453cf52268880057a9df938089", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3476f4b7694b8453cf52268880057a9df938089/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5412587910f573c5d522b79a4808a1289ebea51c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5412587910f573c5d522b79a4808a1289ebea51c", "html_url": "https://github.com/rust-lang/rust/commit/5412587910f573c5d522b79a4808a1289ebea51c"}], "stats": {"total": 697, "additions": 299, "deletions": 398}, "files": [{"sha": "33133f6834b9ab70a32a3e45de54c27929363d35", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=d3476f4b7694b8453cf52268880057a9df938089", "patch": "@@ -91,6 +91,7 @@ pub enum DepNode<D: Clone + Debug> {\n     IsForeignItem(D),\n     TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n+    DtorckConstraint(D),\n     AdtDestructor(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n@@ -228,6 +229,7 @@ impl<D: Clone + Debug> DepNode<D> {\n                 Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n             }\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n+            DtorckConstraint(ref d) => op(d).map(DtorckConstraint),\n             AdtDestructor(ref d) => op(d).map(AdtDestructor),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),"}, {"sha": "30e9f502abc8c83b91c3a91a02f4b5720ef6eb42", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=d3476f4b7694b8453cf52268880057a9df938089", "patch": "@@ -1829,6 +1829,7 @@ register_diagnostics! {\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n+    E0320, // recursive overflow during dropck\n     E0473, // dereference of reference outside its lifetime\n     E0474, // captured variable `..` does not outlive the enclosing closure\n     E0475, // index of slice outside its lifetime"}, {"sha": "4595a8c4f7784161715db667abad9c2bd50c3040", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=d3476f4b7694b8453cf52268880057a9df938089", "patch": "@@ -107,6 +107,13 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     }\n }\n \n+\n+impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n+    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        Self::empty()\n+    }\n+}\n+\n pub struct CycleError<'a, 'tcx: 'a> {\n     span: Span,\n     cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n@@ -397,6 +404,7 @@ define_maps! { <'tcx>\n     pub adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n     pub adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n     pub adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n+    pub adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n \n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n     pub is_foreign_item: IsForeignItem(DefId) -> bool,"}, {"sha": "352b6ab1d356f456ef26f5e2ba4452f1d03efe6d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d3476f4b7694b8453cf52268880057a9df938089", "patch": "@@ -31,13 +31,15 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::util::IntTypeExt;\n use ty::walk::TypeWalker;\n-use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use util::common::ErrorReported;\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n \n use serialize::{self, Encodable, Encoder};\n use std::cell::{Cell, RefCell, Ref};\n use std::collections::BTreeMap;\n use std::cmp;\n use std::hash::{Hash, Hasher};\n+use std::iter::FromIterator;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::slice;\n@@ -1332,17 +1334,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n pub struct Destructor {\n     /// The def-id of the destructor method\n     pub did: DefId,\n-    /// Invoking the destructor of a dtorck type during usual cleanup\n-    /// (e.g. the glue emitted for stack unwinding) requires all\n-    /// lifetimes in the type-structure of `adt` to strictly outlive\n-    /// the adt value itself.\n-    ///\n-    /// If `adt` is not dtorck, then the adt's destructor can be\n-    /// invoked even when there are lifetimes in the type-structure of\n-    /// `adt` that do not strictly outlive the adt value itself.\n-    /// (This allows programs to make cyclic structures without\n-    /// resorting to unsafe means; see RFCs 769 and 1238).\n-    pub is_dtorck: bool,\n }\n \n bitflags! {\n@@ -1609,14 +1600,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n-    /// Returns whether this is a dtorck type. If this returns\n-    /// true, this type being safe for destruction requires it to be\n-    /// alive; Otherwise, only the contents are required to be.\n-    #[inline]\n-    pub fn is_dtorck(&'gcx self, tcx: TyCtxt) -> bool {\n-        self.destructor(tcx).map_or(false, |d| d.is_dtorck)\n-    }\n-\n     /// Returns whether this type is #[fundamental] for the purposes\n     /// of coherence checking.\n     #[inline]\n@@ -2708,6 +2691,38 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result\n }\n \n+/// Calculates the dtorck constraint for a type.\n+fn adt_dtorck_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   def_id: DefId)\n+                                   -> DtorckConstraint<'tcx> {\n+    let def = tcx.lookup_adt_def(def_id);\n+    let span = tcx.def_span(def_id);\n+    debug!(\"dtorck_constraint: {:?}\", def);\n+\n+    if def.is_phantom_data() {\n+        let result = DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![\n+                tcx.mk_param_from_def(&tcx.item_generics(def_id).types[0])\n+           ]\n+        };\n+        debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n+        return result;\n+    }\n+\n+    let mut result = def.all_fields()\n+        .map(|field| tcx.item_type(field.did))\n+        .map(|fty| tcx.dtorck_constraint_for_ty(span, fty, 0, fty))\n+        .collect::<Result<DtorckConstraint, ErrorReported>>()\n+        .unwrap_or(DtorckConstraint::empty());\n+    result.outlives.extend(tcx.destructor_constraints(def));\n+    result.dedup();\n+\n+    debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n+\n+    result\n+}\n+\n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      def_id: DefId)\n                                      -> Rc<Vec<DefId>> {\n@@ -2736,13 +2751,15 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         associated_item,\n         associated_item_def_ids,\n         adt_sized_constraint,\n+        adt_dtorck_constraint,\n         ..*providers\n     };\n }\n \n pub fn provide_extern(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         adt_sized_constraint,\n+        adt_dtorck_constraint,\n         ..*providers\n     };\n }\n@@ -2758,3 +2775,46 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Rc<Vec<DefId>>>,\n }\n+\n+/// A set of constraints that need to be satisfied in order for\n+/// a type to be valid for destruction.\n+#[derive(Clone, Debug)]\n+pub struct DtorckConstraint<'tcx> {\n+    /// Types that are required to be alive in order for this\n+    /// type to be valid for destruction.\n+    pub outlives: Vec<ty::subst::Kind<'tcx>>,\n+    /// Types that could not be resolved: projections and params.\n+    pub dtorck_types: Vec<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx>\n+{\n+    fn from_iter<I: IntoIterator<Item=DtorckConstraint<'tcx>>>(iter: I) -> Self {\n+        let mut result = Self::empty();\n+\n+        for constraint in iter {\n+            result.outlives.extend(constraint.outlives);\n+            result.dtorck_types.extend(constraint.dtorck_types);\n+        }\n+\n+        result\n+    }\n+}\n+\n+\n+impl<'tcx> DtorckConstraint<'tcx> {\n+    fn empty() -> DtorckConstraint<'tcx> {\n+        DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![]\n+        }\n+    }\n+\n+    fn dedup<'a>(&mut self) {\n+        let mut outlives = FxHashSet();\n+        let mut dtorck_types = FxHashSet();\n+\n+        self.outlives.retain(|&val| outlives.replace(val).is_none());\n+        self.dtorck_types.retain(|&val| dtorck_types.replace(val).is_none());\n+    }\n+}"}, {"sha": "f68cf6f97f857d77bf9bfcaf2e7c516d79035f6a", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 161, "deletions": 3, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d3476f4b7694b8453cf52268880057a9df938089", "patch": "@@ -19,6 +19,7 @@ use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::ParameterEnvironment;\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n+use ty::subst::{Subst, Kind};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n use util::nodemap::{FxHashMap, FxHashSet};\n@@ -385,6 +386,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             None => return None,\n         };\n \n+        Some(ty::Destructor { did: dtor_did })\n+    }\n+\n+    /// Return the set of types that are required to be alive in\n+    /// order to run the destructor of `def` (see RFCs 769 and\n+    /// 1238).\n+    ///\n+    /// Note that this returns only the constraints for the\n+    /// destructor of `def` itself. For the destructors of the\n+    /// contents, you need `adt_dtorck_constraint`.\n+    pub fn destructor_constraints(self, def: &'tcx ty::AdtDef)\n+                                  -> Vec<ty::subst::Kind<'tcx>>\n+    {\n+        let dtor = match def.destructor(self) {\n+            None => {\n+                debug!(\"destructor_constraints({:?}) - no dtor\", def.did);\n+                return vec![]\n+            }\n+            Some(dtor) => dtor.did\n+        };\n+\n         // RFC 1238: if the destructor method is tagged with the\n         // attribute `unsafe_destructor_blind_to_params`, then the\n         // compiler is being instructed to *assume* that the\n@@ -394,11 +416,147 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Such access can be in plain sight (e.g. dereferencing\n         // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n         // (e.g. calling `foo.0.clone()` of `Foo<T:Clone>`).\n-        let is_dtorck = !self.has_attr(dtor_did, \"unsafe_destructor_blind_to_params\");\n-        Some(ty::Destructor { did: dtor_did, is_dtorck: is_dtorck })\n+        if self.has_attr(dtor, \"unsafe_destructor_blind_to_params\") {\n+            debug!(\"destructor_constraint({:?}) - blind\", def.did);\n+            return vec![];\n+        }\n+\n+        let impl_def_id = self.associated_item(dtor).container.id();\n+        let impl_generics = self.item_generics(impl_def_id);\n+\n+        // We have a destructor - all the parameters that are not\n+        // pure_wrt_drop (i.e, don't have a #[may_dangle] attribute)\n+        // must be live.\n+\n+        // We need to return the list of parameters from the ADTs\n+        // generics/substs that correspond to impure parameters on the\n+        // impl's generics. This is a bit ugly, but conceptually simple:\n+        //\n+        // Suppose our ADT looks like the following\n+        //\n+        //     struct S<X, Y, Z>(X, Y, Z);\n+        //\n+        // and the impl is\n+        //\n+        //     impl<#[may_dangle] P0, P1, P2> Drop for S<P1, P2, P0>\n+        //\n+        // We want to return the parameters (X, Y). For that, we match\n+        // up the item-substs <X, Y, Z> with the substs on the impl ADT,\n+        // <P1, P2, P0>, and then look up which of the impl substs refer to\n+        // parameters marked as pure.\n+\n+        let impl_substs = match self.item_type(impl_def_id).sty {\n+            ty::TyAdt(def_, substs) if def_ == def => substs,\n+            _ => bug!()\n+        };\n+\n+        let item_substs = match self.item_type(def.did).sty {\n+            ty::TyAdt(def_, substs) if def_ == def => substs,\n+            _ => bug!()\n+        };\n+\n+        let result = item_substs.iter().zip(impl_substs.iter())\n+            .filter(|&(_, &k)| {\n+                if let Some(&ty::Region::ReEarlyBound(ref ebr)) = k.as_region() {\n+                    !impl_generics.region_param(ebr).pure_wrt_drop\n+                } else if let Some(&ty::TyS {\n+                    sty: ty::TypeVariants::TyParam(ref pt), ..\n+                }) = k.as_type() {\n+                    !impl_generics.type_param(pt).pure_wrt_drop\n+                } else {\n+                    // not a type or region param - this should be reported\n+                    // as an error.\n+                    false\n+                }\n+            }).map(|(&item_param, _)| item_param).collect();\n+        debug!(\"destructor_constraint({:?}) = {:?}\", def.did, result);\n+        result\n+    }\n+\n+    /// Return a set of constraints that needs to be satisfied in\n+    /// order for `ty` to be valid for destruction.\n+    pub fn dtorck_constraint_for_ty(self,\n+                                    span: Span,\n+                                    for_ty: Ty<'tcx>,\n+                                    depth: usize,\n+                                    ty: Ty<'tcx>)\n+                                    -> Result<ty::DtorckConstraint<'tcx>, ErrorReported>\n+    {\n+        debug!(\"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\",\n+               span, for_ty, depth, ty);\n+\n+        if depth >= self.sess.recursion_limit.get() {\n+            let mut err = struct_span_err!(\n+                self.sess, span, E0320,\n+                \"overflow while adding drop-check rules for {}\", for_ty);\n+            err.note(&format!(\"overflowed on {}\", ty));\n+            err.emit();\n+            return Err(ErrorReported);\n+        }\n+\n+        let result = match ty.sty {\n+            ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n+            ty::TyFloat(_) | ty::TyStr | ty::TyNever |\n+            ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                // these types never have a destructor\n+                Ok(ty::DtorckConstraint::empty())\n+            }\n+\n+            ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+                // single-element containers, behave like their element\n+                self.dtorck_constraint_for_ty(span, for_ty, depth+1, ety)\n+            }\n+\n+            ty::TyTuple(tys, _) => {\n+                tys.iter().map(|ty| {\n+                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n+                }).collect()\n+            }\n+\n+            ty::TyClosure(def_id, substs) => {\n+                substs.upvar_tys(def_id, self).map(|ty| {\n+                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n+                }).collect()\n+            }\n+\n+            ty::TyAdt(def, substs) => {\n+                let ty::DtorckConstraint {\n+                    dtorck_types, outlives\n+                } = ty::queries::adt_dtorck_constraint::get(self, span, def.did);\n+                Ok(ty::DtorckConstraint {\n+                    // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n+                    // there, but that needs some way to handle cycles.\n+                    dtorck_types: dtorck_types.subst(self, substs),\n+                    outlives: outlives.subst(self, substs)\n+                })\n+            }\n+\n+            // Objects must be alive in order for their destructor\n+            // to be called.\n+            ty::TyDynamic(..) => Ok(ty::DtorckConstraint {\n+                outlives: vec![Kind::from(ty)],\n+                dtorck_types: vec![],\n+            }),\n+\n+            // Types that can't be resolved. Pass them forward.\n+            ty::TyProjection(..) | ty::TyAnon(..) | ty::TyParam(..) => {\n+                Ok(ty::DtorckConstraint {\n+                    outlives: vec![],\n+                    dtorck_types: vec![ty],\n+                })\n+            }\n+\n+            ty::TyInfer(..) | ty::TyError => {\n+                self.sess.delay_span_bug(span, \"unresolved type in dtorck\");\n+                Err(ErrorReported)\n+            }\n+        };\n+\n+        debug!(\"dtorck_constraint_for_ty({:?}) = {:?}\", ty, result);\n+        result\n     }\n \n-    pub fn closure_base_def_id(&self, def_id: DefId) -> DefId {\n+    pub fn closure_base_def_id(self, def_id: DefId) -> DefId {\n         let mut def_id = def_id;\n         while self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr {\n             def_id = self.parent_def_id(def_id).unwrap_or_else(|| {"}, {"sha": "c125d7c02556fb2e67c317dc0ef70871113669ee", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 43, "deletions": 369, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=d3476f4b7694b8453cf52268880057a9df938089", "patch": "@@ -15,12 +15,11 @@ use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk};\n use middle::region;\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, ObligationCause, Reveal};\n use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n /// check_drop_impl confirms that the Drop implementation identfied by\n@@ -270,389 +269,64 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n ///\n pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n-    typ: ty::Ty<'tcx>,\n+    ty: ty::Ty<'tcx>,\n     span: Span,\n     scope: region::CodeExtent)\n+    -> Result<(), ErrorReported>\n {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n-           typ, scope);\n+           ty, scope);\n \n \n     let parent_scope = match rcx.tcx.region_maps.opt_encl_scope(scope) {\n-      Some(parent_scope) => parent_scope,\n-      // If no enclosing scope, then it must be the root scope which cannot be outlived.\n-      None => return\n+        Some(parent_scope) => parent_scope,\n+        // If no enclosing scope, then it must be the root scope\n+        // which cannot be outlived.\n+        None => return Ok(())\n     };\n-\n-    let result = iterate_over_potentially_unsafe_regions_in_type(\n-        &mut DropckContext {\n-            rcx: rcx,\n-            span: span,\n-            parent_scope: parent_scope,\n-            breadcrumbs: FxHashSet()\n-        },\n-        TypeContext::Root,\n-        typ,\n-        0);\n-    match result {\n-        Ok(()) => {}\n-        Err(Error::Overflow(ref ctxt, ref detected_on_typ)) => {\n-            let tcx = rcx.tcx;\n-            let mut err = struct_span_err!(tcx.sess, span, E0320,\n-                                           \"overflow while adding drop-check rules for {}\", typ);\n-            match *ctxt {\n-                TypeContext::Root => {\n-                    // no need for an additional note if the overflow\n-                    // was somehow on the root.\n-                }\n-                TypeContext::ADT { def_id, variant, field } => {\n-                    let adt = tcx.lookup_adt_def(def_id);\n-                    let variant_name = match adt.adt_kind() {\n-                        AdtKind::Enum => format!(\"enum {} variant {}\",\n-                                                 tcx.item_path_str(def_id),\n-                                                 variant),\n-                        AdtKind::Struct => format!(\"struct {}\",\n-                                                   tcx.item_path_str(def_id)),\n-                        AdtKind::Union => format!(\"union {}\",\n-                                                  tcx.item_path_str(def_id)),\n-                    };\n-                    span_note!(\n-                        &mut err,\n-                        span,\n-                        \"overflowed on {} field {} type: {}\",\n-                        variant_name,\n-                        field,\n-                        detected_on_typ);\n+    let parent_scope = rcx.tcx.mk_region(ty::ReScope(parent_scope));\n+    let origin = || infer::SubregionOrigin::SafeDestructor(span);\n+\n+    let ty = rcx.fcx.resolve_type_vars_if_possible(&ty);\n+    let for_ty = ty;\n+    let mut types = vec![(ty, 0)];\n+    let mut known = FxHashSet();\n+    while let Some((ty, depth)) = types.pop() {\n+        let ty::DtorckConstraint {\n+            dtorck_types, outlives\n+        } = rcx.tcx.dtorck_constraint_for_ty(span, for_ty, depth, ty)?;\n+\n+        for ty in dtorck_types {\n+            let ty = rcx.fcx.normalize_associated_types_in(span, &ty);\n+            let ty = rcx.fcx.resolve_type_vars_with_obligations(ty);\n+            let ty = rcx.fcx.resolve_type_and_region_vars_if_possible(&ty);\n+            match ty.sty {\n+                // All parameters live for the duration of the\n+                // function.\n+                ty::TyParam(..) => {}\n+\n+                // A projection that we couldn't resolve - it\n+                // might have a destructor.\n+                ty::TyProjection(..) | ty::TyAnon(..) => {\n+                    rcx.type_must_outlive(origin(), ty, parent_scope);\n                 }\n-            }\n-            err.emit();\n-        }\n-    }\n-}\n-\n-enum Error<'tcx> {\n-    Overflow(TypeContext, ty::Ty<'tcx>),\n-}\n-\n-#[derive(Copy, Clone)]\n-enum TypeContext {\n-    Root,\n-    ADT {\n-        def_id: DefId,\n-        variant: ast::Name,\n-        field: ast::Name,\n-    }\n-}\n-\n-struct DropckContext<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n-    rcx: &'a mut RegionCtxt<'b, 'gcx, 'tcx>,\n-    /// types that have already been traversed\n-    breadcrumbs: FxHashSet<Ty<'tcx>>,\n-    /// span for error reporting\n-    span: Span,\n-    /// the scope reachable dtorck types must outlive\n-    parent_scope: region::CodeExtent\n-}\n-\n-// `context` is used for reporting overflow errors\n-fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n-    cx: &mut DropckContext<'a, 'b, 'gcx, 'tcx>,\n-    context: TypeContext,\n-    ty: Ty<'tcx>,\n-    depth: usize)\n-    -> Result<(), Error<'tcx>>\n-{\n-    let tcx = cx.rcx.tcx;\n-    // Issue #22443: Watch out for overflow. While we are careful to\n-    // handle regular types properly, non-regular ones cause problems.\n-    let recursion_limit = tcx.sess.recursion_limit.get();\n-    if depth / 4 >= recursion_limit {\n-        // This can get into rather deep recursion, especially in the\n-        // presence of things like Vec<T> -> Unique<T> -> PhantomData<T> -> T.\n-        // use a higher recursion limit to avoid errors.\n-        return Err(Error::Overflow(context, ty))\n-    }\n \n-    // canoncialize the regions in `ty` before inserting - infinitely many\n-    // region variables can refer to the same region.\n-    let ty = cx.rcx.resolve_type_and_region_vars_if_possible(&ty);\n-\n-    if !cx.breadcrumbs.insert(ty) {\n-        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-               {}ty: {} scope: {:?} - cached\",\n-               (0..depth).map(|_| ' ').collect::<String>(),\n-               ty, cx.parent_scope);\n-        return Ok(()); // we already visited this type\n-    }\n-    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-           {}ty: {} scope: {:?}\",\n-           (0..depth).map(|_| ' ').collect::<String>(),\n-           ty, cx.parent_scope);\n-\n-    // If `typ` has a destructor, then we must ensure that all\n-    // borrowed data reachable via `typ` must outlive the parent\n-    // of `scope`. This is handled below.\n-    //\n-    // However, there is an important special case: for any Drop\n-    // impl that is tagged as \"blind\" to their parameters,\n-    // we assume that data borrowed via such type parameters\n-    // remains unreachable via that Drop impl.\n-    //\n-    // For example, consider:\n-    //\n-    // ```rust\n-    // #[unsafe_destructor_blind_to_params]\n-    // impl<T> Drop for Vec<T> { ... }\n-    // ```\n-    //\n-    // which does have to be able to drop instances of `T`, but\n-    // otherwise cannot read data from `T`.\n-    //\n-    // Of course, for the type expression passed in for any such\n-    // unbounded type parameter `T`, we must resume the recursive\n-    // analysis on `T` (since it would be ignored by\n-    // type_must_outlive).\n-    let dropck_kind = has_dtor_of_interest(tcx, ty);\n-    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-            ty: {:?} dropck_kind: {:?}\", ty, dropck_kind);\n-    match dropck_kind {\n-        DropckKind::NoBorrowedDataAccessedInMyDtor => {\n-            // The maximally blind attribute.\n-        }\n-        DropckKind::BorrowedDataMustStrictlyOutliveSelf => {\n-            cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n-                                     ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n-            return Ok(());\n-        }\n-        DropckKind::RevisedSelf(revised_ty) => {\n-            cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n-                                     revised_ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n-            // Do not return early from this case; we want\n-            // to recursively process the internal structure of Self\n-            // (because even though the Drop for Self has been asserted\n-            //  safe, the types instantiated for the generics of Self\n-            //  may themselves carry dropck constraints.)\n-        }\n-    }\n-\n-    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-           {}ty: {} scope: {:?} - checking interior\",\n-           (0..depth).map(|_| ' ').collect::<String>(),\n-           ty, cx.parent_scope);\n-\n-    // We still need to ensure all referenced data is safe.\n-    match ty.sty {\n-        ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n-        ty::TyFloat(_) | ty::TyStr | ty::TyNever => {\n-            // primitive - definitely safe\n-            Ok(())\n-        }\n-\n-        ty::TyArray(ity, _) | ty::TySlice(ity) => {\n-            // single-element containers, behave like their element\n-            iterate_over_potentially_unsafe_regions_in_type(\n-                cx, context, ity, depth+1)\n-        }\n-\n-        ty::TyAdt(def, substs) if def.is_phantom_data() => {\n-            // PhantomData<T> - behaves identically to T\n-            let ity = substs.type_at(0);\n-            iterate_over_potentially_unsafe_regions_in_type(\n-                cx, context, ity, depth+1)\n-        }\n-\n-        ty::TyAdt(def, substs) => {\n-            let did = def.did;\n-            for variant in &def.variants {\n-                for field in variant.fields.iter() {\n-                    let fty = field.ty(tcx, substs);\n-                    let fty = cx.rcx.fcx.resolve_type_vars_with_obligations(\n-                        cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n-                    iterate_over_potentially_unsafe_regions_in_type(\n-                        cx,\n-                        TypeContext::ADT {\n-                            def_id: did,\n-                            field: field.name,\n-                            variant: variant.name,\n-                        },\n-                        fty,\n-                        depth+1)?\n+                _ => {\n+                    if let None = known.replace(ty) {\n+                        types.push((ty, depth+1));\n+                    }\n                 }\n             }\n-            Ok(())\n-        }\n-\n-        ty::TyClosure(def_id, substs) => {\n-            for ty in substs.upvar_tys(def_id, tcx) {\n-                iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n-            }\n-            Ok(())\n-        }\n-\n-        ty::TyTuple(tys, _) => {\n-            for ty in tys {\n-                iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n-            }\n-            Ok(())\n-        }\n-\n-        ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyParam(..) => {\n-            // these always come with a witness of liveness (references\n-            // explicitly, pointers implicitly, parameters by the\n-            // caller).\n-            Ok(())\n         }\n \n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-            // FIXME(#26656): this type is always destruction-safe, but\n-            // it implicitly witnesses Self: Fn, which can be false.\n-            Ok(())\n-        }\n-\n-        ty::TyInfer(..) | ty::TyError => {\n-            tcx.sess.delay_span_bug(cx.span, \"unresolved type in regionck\");\n-            Ok(())\n-        }\n-\n-        // these are always dtorck\n-        ty::TyDynamic(..) | ty::TyProjection(_) | ty::TyAnon(..) => bug!(),\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum DropckKind<'tcx> {\n-    /// The \"safe\" kind; i.e. conservatively assume any borrow\n-    /// accessed by dtor, and therefore such data must strictly\n-    /// outlive self.\n-    ///\n-    /// Equivalent to RevisedTy with no change to the self type.\n-    BorrowedDataMustStrictlyOutliveSelf,\n-\n-    /// The nearly completely-unsafe kind.\n-    ///\n-    /// Equivalent to RevisedSelf with *all* parameters remapped to ()\n-    /// (maybe...?)\n-    NoBorrowedDataAccessedInMyDtor,\n-\n-    /// Assume all borrowed data access by dtor occurs as if Self has the\n-    /// type carried by this variant. In practice this means that some\n-    /// of the type parameters are remapped to `()` (and some lifetime\n-    /// parameters remapped to `'static`), because the developer has asserted\n-    /// that the destructor will not access their contents.\n-    RevisedSelf(Ty<'tcx>),\n-}\n-\n-/// Returns the classification of what kind of check should be applied\n-/// to `ty`, which may include a revised type where some of the type\n-/// parameters are re-mapped to `()` to reflect the destructor's\n-/// \"purity\" with respect to their actual contents.\n-fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        ty: Ty<'tcx>)\n-                                        -> DropckKind<'tcx> {\n-    match ty.sty {\n-        ty::TyAdt(adt_def, substs) => {\n-            if !adt_def.is_dtorck(tcx) {\n-                return DropckKind::NoBorrowedDataAccessedInMyDtor;\n+        for outlive in outlives {\n+            if let Some(r) = outlive.as_region() {\n+                rcx.sub_regions(origin(), parent_scope, r);\n+            } else if let Some(ty) = outlive.as_type() {\n+                rcx.type_must_outlive(origin(), ty, parent_scope);\n             }\n-\n-            // Find the `impl<..> Drop for _` to inspect any\n-            // attributes attached to the impl's generics.\n-            let dtor_method = adt_def.destructor(tcx)\n-                .expect(\"dtorck type without destructor impossible\");\n-            let method = tcx.associated_item(dtor_method.did);\n-            let impl_def_id = method.container.id();\n-            let revised_ty = revise_self_ty(tcx, adt_def, impl_def_id, substs);\n-            return DropckKind::RevisedSelf(revised_ty);\n-        }\n-        ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-            debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n-            return DropckKind::BorrowedDataMustStrictlyOutliveSelf;\n-        },\n-        _ => {\n-            return DropckKind::NoBorrowedDataAccessedInMyDtor;\n         }\n     }\n-}\n \n-// Constructs new Ty just like the type defined by `adt_def` coupled\n-// with `substs`, except each type and lifetime parameter marked as\n-// `#[may_dangle]` in the Drop impl (identified by `impl_def_id`) is\n-// respectively mapped to `()` or `'static`.\n-//\n-// For example: If the `adt_def` maps to:\n-//\n-//   enum Foo<'a, X, Y> { ... }\n-//\n-// and the `impl_def_id` maps to:\n-//\n-//   impl<#[may_dangle] 'a, X, #[may_dangle] Y> Drop for Foo<'a, X, Y> { ... }\n-//\n-// then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n-fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  adt_def: &'tcx ty::AdtDef,\n-                                  impl_def_id: DefId,\n-                                  substs: &Substs<'tcx>)\n-                                  -> Ty<'tcx> {\n-    // Get generics for `impl Drop` to query for `#[may_dangle]` attr.\n-    let impl_bindings = tcx.item_generics(impl_def_id);\n-\n-    // Get Substs attached to Self on `impl Drop`; process in parallel\n-    // with `substs`, replacing dangling entries as appropriate.\n-    let self_substs = {\n-        let impl_self_ty: Ty<'tcx> = tcx.item_type(impl_def_id);\n-        if let ty::TyAdt(self_adt_def, self_substs) = impl_self_ty.sty {\n-            assert_eq!(adt_def, self_adt_def);\n-            self_substs\n-        } else {\n-            bug!(\"Self in `impl Drop for _` must be an Adt.\");\n-        }\n-    };\n-\n-    // Walk `substs` + `self_substs`, build new substs appropriate for\n-    // `adt_def`; each non-dangling param reuses entry from `substs`.\n-    //\n-    // Note: The manner we map from a right-hand side (i.e. Region or\n-    // Ty) for a given `def` to generic parameter associated with that\n-    // right-hand side is tightly coupled to `Drop` impl constraints.\n-    //\n-    // E.g. we know such a Ty must be `TyParam`, because a destructor\n-    // for `struct Foo<X>` is defined via `impl<Y> Drop for Foo<Y>`,\n-    // and never by (for example) `impl<Z> Drop for Foo<Vec<Z>>`.\n-    let substs = Substs::for_item(\n-        tcx,\n-        adt_def.did,\n-        |def, _| {\n-            let r_orig = substs.region_for_def(def);\n-            let impl_self_orig = self_substs.region_for_def(def);\n-            let r = if let ty::Region::ReEarlyBound(ref ebr) = *impl_self_orig {\n-                if impl_bindings.region_param(ebr).pure_wrt_drop {\n-                    tcx.types.re_static\n-                } else {\n-                    r_orig\n-                }\n-            } else {\n-                bug!(\"substs for an impl must map regions to ReEarlyBound\");\n-            };\n-            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} to {:?}\",\n-                   def, r_orig, r);\n-            r\n-        },\n-        |def, _| {\n-            let t_orig = substs.type_for_def(def);\n-            let impl_self_orig = self_substs.type_for_def(def);\n-            let t = if let ty::TypeVariants::TyParam(ref pt) = impl_self_orig.sty {\n-                if impl_bindings.type_param(pt).pure_wrt_drop {\n-                    tcx.mk_nil()\n-                } else {\n-                    t_orig\n-                }\n-            } else {\n-                bug!(\"substs for an impl must map types to TyParam\");\n-            };\n-            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} {:?} to {:?} {:?}\",\n-                   def, t_orig, t_orig.sty, t, t.sty);\n-            t\n-        });\n-\n-    tcx.mk_adt(adt_def, &substs)\n+    Ok(())\n }"}, {"sha": "dcef22da879646e6c4df0858d57d03f8ca948fae", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d3476f4b7694b8453cf52268880057a9df938089", "patch": "@@ -457,7 +457,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.type_of_node_must_outlive(origin, id, var_region);\n \n             let typ = self.resolve_node_type(id);\n-            dropck::check_safety_of_destructor_if_necessary(self, typ, span, var_scope);\n+            let _ = dropck::check_safety_of_destructor_if_necessary(\n+                self, typ, span, var_scope);\n         })\n     }\n }\n@@ -995,10 +996,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 match *region {\n                     ty::ReScope(rvalue_scope) => {\n                         let typ = self.resolve_type(cmt.ty);\n-                        dropck::check_safety_of_destructor_if_necessary(self,\n-                                                                        typ,\n-                                                                        span,\n-                                                                        rvalue_scope);\n+                        let _ = dropck::check_safety_of_destructor_if_necessary(\n+                            self, typ, span, rvalue_scope);\n                     }\n                     ty::ReStatic => {}\n                     _ => {"}, {"sha": "2bae6a0d9e11a7e1bfe1e7d42d4797bd6d637ebe", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3476f4b7694b8453cf52268880057a9df938089/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d3476f4b7694b8453cf52268880057a9df938089", "patch": "@@ -4154,7 +4154,6 @@ register_diagnostics! {\n //  E0248, // value used as a type, now reported earlier during resolution as E0412\n //  E0249,\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n-    E0320, // recursive overflow during dropck\n //  E0372, // coherence not object safe\n     E0377, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with the same definition"}]}