{"sha": "88323e856d01650f6477350ad1304c26497b8ff7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MzIzZTg1NmQwMTY1MGY2NDc3MzUwYWQxMzA0YzI2NDk3YjhmZjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-18T06:57:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-18T06:57:21Z"}, "message": "Auto merge of #6458 - ebroto:6022_parse_doctest, r=Manishearth\n\nneedless_doctest_main: handle correctly parse errors\n\nBefore this change, finding an error when parsing a doctest would make Clippy exit without emitting an error. Now we properly catch a fatal error and ignore it.\n\nAlso, if a doctest specifies an edition in the info line, it will be used when parsing it.\n\nchangelog: needless_doctest_main: handle correctly parse errors\n\nFixes #6022", "tree": {"sha": "4cb22d79b06c214e4c3452e8dac093119f27f6ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cb22d79b06c214e4c3452e8dac093119f27f6ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88323e856d01650f6477350ad1304c26497b8ff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88323e856d01650f6477350ad1304c26497b8ff7", "html_url": "https://github.com/rust-lang/rust/commit/88323e856d01650f6477350ad1304c26497b8ff7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88323e856d01650f6477350ad1304c26497b8ff7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c00931642357c835d5ba292d8c642ef7389021b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c00931642357c835d5ba292d8c642ef7389021b", "html_url": "https://github.com/rust-lang/rust/commit/5c00931642357c835d5ba292d8c642ef7389021b"}, {"sha": "bb68ec6cfc76a6ec69d21c0f64dbc4aa99158958", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb68ec6cfc76a6ec69d21c0f64dbc4aa99158958", "html_url": "https://github.com/rust-lang/rust/commit/bb68ec6cfc76a6ec69d21c0f64dbc4aa99158958"}], "stats": {"total": 150, "additions": 88, "deletions": 62}, "files": [{"sha": "aba655327959022632877be9d012706876adfc2b", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 79, "deletions": 60, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/88323e856d01650f6477350ad1304c26497b8ff7/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88323e856d01650f6477350ad1304c26497b8ff7/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=88323e856d01650f6477350ad1304c26497b8ff7", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty;\n use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::edition::Edition;\n use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n use rustc_span::{sym, FileName, Pos};\n use std::io;\n@@ -377,7 +378,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n     check_doc(cx, valid_idents, events, &spans)\n }\n \n-const RUST_CODE: &[&str] = &[\"rust\", \"no_run\", \"should_panic\", \"compile_fail\", \"edition2018\"];\n+const RUST_CODE: &[&str] = &[\"rust\", \"no_run\", \"should_panic\", \"compile_fail\"];\n \n fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize>)>>(\n     cx: &LateContext<'_>,\n@@ -400,13 +401,24 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     let mut in_link = None;\n     let mut in_heading = false;\n     let mut is_rust = false;\n+    let mut edition = None;\n     for (event, range) in events {\n         match event {\n             Start(CodeBlock(ref kind)) => {\n                 in_code = true;\n                 if let CodeBlockKind::Fenced(lang) = kind {\n-                    is_rust =\n-                        lang.is_empty() || !lang.contains(\"ignore\") && lang.split(',').any(|i| RUST_CODE.contains(&i));\n+                    for item in lang.split(',') {\n+                        if item == \"ignore\" {\n+                            is_rust = false;\n+                            break;\n+                        }\n+                        if let Some(stripped) = item.strip_prefix(\"edition\") {\n+                            is_rust = true;\n+                            edition = stripped.parse::<Edition>().ok();\n+                        } else if item.is_empty() || RUST_CODE.contains(&item) {\n+                            is_rust = true;\n+                        }\n+                    }\n                 }\n             },\n             End(CodeBlock(_)) => {\n@@ -436,7 +448,8 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n                 let (begin, span) = spans[index];\n                 if in_code {\n                     if is_rust {\n-                        check_code(cx, &text, span);\n+                        let edition = edition.unwrap_or_else(|| cx.tcx.sess.edition());\n+                        check_code(cx, &text, edition, span);\n                     }\n                 } else {\n                     // Adjust for the beginning of the current `Event`\n@@ -450,67 +463,73 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     headers\n }\n \n-fn check_code(cx: &LateContext<'_>, text: &str, span: Span) {\n-    fn has_needless_main(code: &str) -> bool {\n-        let filename = FileName::anon_source_code(code);\n-\n-        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n-        let handler = Handler::with_emitter(false, None, box emitter);\n-        let sess = ParseSess::with_span_handler(handler, sm);\n-\n-        let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n-            Ok(p) => p,\n-            Err(errs) => {\n-                for mut err in errs {\n-                    err.cancel();\n-                }\n-                return false;\n-            },\n-        };\n-\n-        let mut relevant_main_found = false;\n-        loop {\n-            match parser.parse_item() {\n-                Ok(Some(item)) => match &item.kind {\n-                    // Tests with one of these items are ignored\n-                    ItemKind::Static(..)\n-                    | ItemKind::Const(..)\n-                    | ItemKind::ExternCrate(..)\n-                    | ItemKind::ForeignMod(..) => return false,\n-                    // We found a main function ...\n-                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n-                        let is_async = matches!(sig.header.asyncness, Async::Yes { .. });\n-                        let returns_nothing = match &sig.decl.output {\n-                            FnRetTy::Default(..) => true,\n-                            FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n-                            _ => false,\n-                        };\n-\n-                        if returns_nothing && !is_async && !block.stmts.is_empty() {\n-                            // This main function should be linted, but only if there are no other functions\n-                            relevant_main_found = true;\n-                        } else {\n-                            // This main function should not be linted, we're done\n-                            return false;\n+fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n+    fn has_needless_main(code: &str, edition: Edition) -> bool {\n+        rustc_driver::catch_fatal_errors(|| {\n+            rustc_span::with_session_globals(edition, || {\n+                let filename = FileName::anon_source_code(code);\n+\n+                let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+                let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+                let handler = Handler::with_emitter(false, None, box emitter);\n+                let sess = ParseSess::with_span_handler(handler, sm);\n+\n+                let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n+                    Ok(p) => p,\n+                    Err(errs) => {\n+                        for mut err in errs {\n+                            err.cancel();\n                         }\n+                        return false;\n                     },\n-                    // Another function was found; this case is ignored too\n-                    ItemKind::Fn(..) => return false,\n-                    _ => {},\n-                },\n-                Ok(None) => break,\n-                Err(mut e) => {\n-                    e.cancel();\n-                    return false;\n-                },\n-            }\n-        }\n+                };\n+\n+                let mut relevant_main_found = false;\n+                loop {\n+                    match parser.parse_item() {\n+                        Ok(Some(item)) => match &item.kind {\n+                            // Tests with one of these items are ignored\n+                            ItemKind::Static(..)\n+                            | ItemKind::Const(..)\n+                            | ItemKind::ExternCrate(..)\n+                            | ItemKind::ForeignMod(..) => return false,\n+                            // We found a main function ...\n+                            ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n+                                let is_async = matches!(sig.header.asyncness, Async::Yes { .. });\n+                                let returns_nothing = match &sig.decl.output {\n+                                    FnRetTy::Default(..) => true,\n+                                    FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n+                                    _ => false,\n+                                };\n+\n+                                if returns_nothing && !is_async && !block.stmts.is_empty() {\n+                                    // This main function should be linted, but only if there are no other functions\n+                                    relevant_main_found = true;\n+                                } else {\n+                                    // This main function should not be linted, we're done\n+                                    return false;\n+                                }\n+                            },\n+                            // Another function was found; this case is ignored too\n+                            ItemKind::Fn(..) => return false,\n+                            _ => {},\n+                        },\n+                        Ok(None) => break,\n+                        Err(mut e) => {\n+                            e.cancel();\n+                            return false;\n+                        },\n+                    }\n+                }\n \n-        relevant_main_found\n+                relevant_main_found\n+            })\n+        })\n+        .ok()\n+        .unwrap_or_default()\n     }\n \n-    if has_needless_main(text) {\n+    if has_needless_main(text, edition) {\n         span_lint(cx, NEEDLESS_DOCTEST_MAIN, span, \"needless `fn main` in doctest\");\n     }\n }"}, {"sha": "02ba422a2f5b8c0287913a80aad522f5256c8152", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88323e856d01650f6477350ad1304c26497b8ff7/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88323e856d01650f6477350ad1304c26497b8ff7/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=88323e856d01650f6477350ad1304c26497b8ff7", "patch": "@@ -27,6 +27,7 @@ extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;\n extern crate rustc_data_structures;\n+extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_hir_pretty;"}, {"sha": "83e9bbaa3af43dc1bdc1f8c60f77130b42c9bcb5", "filename": "tests/ui/needless_doc_main.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88323e856d01650f6477350ad1304c26497b8ff7/tests%2Fui%2Fneedless_doc_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88323e856d01650f6477350ad1304c26497b8ff7/tests%2Fui%2Fneedless_doc_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_doc_main.rs?ref=88323e856d01650f6477350ad1304c26497b8ff7", "patch": "@@ -10,7 +10,7 @@\n /// ```\n ///\n /// With an explicit return type it should lint too\n-/// ```\n+/// ```edition2015\n /// fn main() -> () {\n ///     unimplemented!();\n /// }\n@@ -39,7 +39,7 @@ fn bad_doctests() {}\n /// ```\n ///\n /// This shouldn't lint either, because main is async:\n-/// ```\n+/// ```edition2018\n /// async fn main() {\n ///     assert_eq!(42, ANSWER);\n /// }\n@@ -128,6 +128,12 @@ fn bad_doctests() {}\n /// ```\n fn no_false_positives() {}\n \n+/// Yields a parse error when interpreted as rust code:\n+/// ```\n+/// r#\"hi\"\n+/// ```\n+fn issue_6022() {}\n+\n fn main() {\n     bad_doctests();\n     no_false_positives();"}]}