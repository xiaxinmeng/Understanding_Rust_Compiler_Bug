{"sha": "d7e43aa779f3a82614766af41adb5828d9282b5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZTQzYWE3NzlmM2E4MjYxNDc2NmFmNDFhZGI1ODI4ZDkyODJiNWE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-05-23T16:39:38Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-05-24T00:57:07Z"}, "message": "cleanup warnings from librustdoc", "tree": {"sha": "3e91a6f4366b7c7e22b65393f663b50a80b62d10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e91a6f4366b7c7e22b65393f663b50a80b62d10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7e43aa779f3a82614766af41adb5828d9282b5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e43aa779f3a82614766af41adb5828d9282b5a", "html_url": "https://github.com/rust-lang/rust/commit/d7e43aa779f3a82614766af41adb5828d9282b5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7e43aa779f3a82614766af41adb5828d9282b5a/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50f6198ee28516b81253e0c519616954a2d79606", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f6198ee28516b81253e0c519616954a2d79606", "html_url": "https://github.com/rust-lang/rust/commit/50f6198ee28516b81253e0c519616954a2d79606"}], "stats": {"total": 168, "additions": 81, "deletions": 87}, "files": [{"sha": "7366aca4c4f6f5b9f4230e80f09c9cf611b9f804", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=d7e43aa779f3a82614766af41adb5828d9282b5a", "patch": "@@ -278,102 +278,102 @@ mod test {\n \n     #[test]\n     fn should_error_with_no_crates() {\n-        let config = parse_config(~[~\"rustdoc\"]);\n+        let config = parse_config([~\"rustdoc\"]);\n         assert!(config.get_err() == ~\"no crates specified\");\n     }\n \n     #[test]\n     fn should_error_with_multiple_crates() {\n         let config =\n-            parse_config(~[~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n+            parse_config([~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n         assert!(config.get_err() == ~\"multiple crates specified\");\n     }\n \n     #[test]\n     fn should_set_output_dir_to_cwd_if_not_provided() {\n-        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n         assert!(config.get().output_dir == Path(\".\"));\n     }\n \n     #[test]\n     fn should_set_output_dir_if_provided() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n         ]);\n         assert!(config.get().output_dir == Path(\"snuggles\"));\n     }\n \n     #[test]\n     fn should_set_output_format_to_pandoc_html_if_not_provided() {\n-        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n         assert!(config.get().output_format == PandocHtml);\n     }\n \n     #[test]\n     fn should_set_output_format_to_markdown_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n         ]);\n         assert!(config.get().output_format == Markdown);\n     }\n \n     #[test]\n     fn should_set_output_format_to_pandoc_html_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n         ]);\n         assert!(config.get().output_format == PandocHtml);\n     }\n \n     #[test]\n     fn should_error_on_bogus_format() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n         ]);\n         assert!(config.get_err() == ~\"unknown output format 'bogus'\");\n     }\n \n     #[test]\n     fn should_set_output_style_to_doc_per_mod_by_default() {\n-        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n         assert!(config.get().output_style == DocPerMod);\n     }\n \n     #[test]\n     fn should_set_output_style_to_one_doc_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n         ]);\n         assert!(config.get().output_style == DocPerCrate);\n     }\n \n     #[test]\n     fn should_set_output_style_to_doc_per_mod_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n         ]);\n         assert!(config.get().output_style == DocPerMod);\n     }\n \n     #[test]\n     fn should_error_on_bogus_output_style() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n         ]);\n         assert!(config.get_err() == ~\"unknown output style 'bogus'\");\n     }\n \n     #[test]\n     fn should_set_pandoc_command_if_requested() {\n-        let config = parse_config(~[\n+        let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n         ]);\n         assert!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n     }\n \n     #[test]\n     fn should_set_pandoc_command_when_using_pandoc() {\n-        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n         assert!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n     }\n }"}, {"sha": "130cbb784ee37377aac55c5c7e3ad7b4a4446f2d", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=d7e43aa779f3a82614766af41adb5828d9282b5a", "patch": "@@ -220,13 +220,13 @@ mod test {\n \n     #[test]\n     fn test_paragraphs_1() {\n-        let paras = paragraphs(~\"1\\n\\n2\");\n+        let paras = paragraphs(\"1\\n\\n2\");\n         assert_eq!(paras, ~[~\"1\", ~\"2\"]);\n     }\n \n     #[test]\n     fn test_paragraphs_2() {\n-        let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n+        let paras = paragraphs(\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n         assert_eq!(paras, ~[~\"1\\n1\", ~\"2\"]);\n     }\n "}, {"sha": "3ef907d819d68dc82c21e9b4c2195e0391011919", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=d7e43aa779f3a82614766af41adb5828d9282b5a", "patch": "@@ -16,9 +16,7 @@ use astsrv;\n use doc::ItemUtils;\n use doc;\n \n-use core::local_data::local_data_get;\n use syntax::ast;\n-use syntax;\n use syntax::parse::token::{ident_interner};\n use syntax::parse::token;\n "}, {"sha": "8ff0aa2314647dd02bcbbd81ba4a60f141bb4c91", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=d7e43aa779f3a82614766af41adb5828d9282b5a", "patch": "@@ -193,21 +193,21 @@ mod test {\n \n     #[test]\n     fn should_remove_punctuation_from_headers() {\n-        assert!(pandoc_header_id(~\"impl foo of bar<A>\") ==\n+        assert!(pandoc_header_id(\"impl foo of bar<A>\") ==\n                 ~\"impl-foo-of-bara\");\n-        assert!(pandoc_header_id(~\"impl of num::num for int\")\n+        assert!(pandoc_header_id(\"impl of num::num for int\")\n                 == ~\"impl-of-numnum-for-int\");\n-        assert!(pandoc_header_id(~\"impl of num::num for int/&\")\n+        assert!(pandoc_header_id(\"impl of num::num for int/&\")\n                 == ~\"impl-of-numnum-for-int\");\n-        assert!(pandoc_header_id(~\"impl of num::num for ^int\")\n+        assert!(pandoc_header_id(\"impl of num::num for ^int\")\n                 == ~\"impl-of-numnum-for-int\");\n-        assert!(pandoc_header_id(~\"impl for & condvar\")\n+        assert!(pandoc_header_id(\"impl for & condvar\")\n                 == ~\"impl-for-condvar\");\n-        assert!(pandoc_header_id(~\"impl of Select<T, U> for (Left, Right)\")\n+        assert!(pandoc_header_id(\"impl of Select<T, U> for (Left, Right)\")\n                 == ~\"impl-of-selectt-u-for-left-right\");\n-        assert!(pandoc_header_id(~\"impl of Condition<'self, T, U>\")\n+        assert!(pandoc_header_id(\"impl of Condition<'self, T, U>\")\n                 == ~\"impl-of-conditionself-t-u\");\n-        assert!(pandoc_header_id(~\"impl of Condition<T: Copy + Clone>\")\n+        assert!(pandoc_header_id(\"impl of Condition<T: Copy + Clone>\")\n                 == ~\"impl-of-conditiont-copy-clone\");\n     }\n "}, {"sha": "c6f5dbefb6add595a48b6578895ecd30a1f8afe0", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 53, "deletions": 57, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=d7e43aa779f3a82614766af41adb5828d9282b5a", "patch": "@@ -587,13 +587,13 @@ mod test {\n     #[test]\n     fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n-        assert!(str::contains(markdown, ~\"# Module `moo`\"));\n+        assert!(str::contains(markdown, \"# Module `moo`\"));\n     }\n \n     #[test]\n     fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n-        assert!(str::contains(markdown, ~\"Module `morp`\\n\\n\"));\n+        assert!(str::contains(markdown, \"Module `morp`\\n\\n\"));\n     }\n \n     #[test]\n@@ -613,10 +613,10 @@ mod test {\n               fn d() { }\"\n         );\n \n-        let idx_a = str::find_str(markdown, ~\"# Module `a`\").get();\n-        let idx_b = str::find_str(markdown, ~\"## Function `b`\").get();\n-        let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n-        let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n+        let idx_a = str::find_str(markdown, \"# Module `a`\").get();\n+        let idx_b = str::find_str(markdown, \"## Function `b`\").get();\n+        let idx_c = str::find_str(markdown, \"# Module `c`\").get();\n+        let idx_d = str::find_str(markdown, \"## Function `d`\").get();\n \n         assert!(idx_b < idx_d);\n         assert!(idx_d < idx_a);\n@@ -649,7 +649,7 @@ mod test {\n             let (page, markdown) = po.recv();\n             match page {\n                 doc::CratePage(_) => {\n-                    assert!(str::contains(markdown, ~\"% Crate core\"));\n+                    assert!(str::contains(markdown, \"% Crate core\"));\n                 }\n                 doc::ItemPage(_) => {\n                     assert!(str::contains(markdown, ~\"% Module a\"));\n@@ -661,7 +661,7 @@ mod test {\n     #[test]\n     fn should_write_full_path_to_mod() {\n         let markdown = render(~\"mod a { mod b { mod c { } } }\");\n-        assert!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n+        assert!(str::contains(markdown, \"# Module `a::b::c`\"));\n     }\n \n     #[test]\n@@ -672,13 +672,13 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n+        assert!(str::contains(markdown, \"#### Header\\n\\nBody\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_crate_description() {\n         let markdown = render(~\"#[doc = \\\"this is the crate\\\"];\");\n-        assert!(str::contains(markdown, ~\"this is the crate\"));\n+        assert!(str::contains(markdown, \"this is the crate\"));\n     }\n \n \n@@ -687,62 +687,62 @@ mod test {\n         let markdown = render(~\"mod a { } mod b { }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n* [Module `a`](#module-a)\\n\\\n-              * [Module `b`](#module-b)\\n\\n\"\n+            \"\\n\\n* [Module `a`](#module-a)\\n\\\n+             * [Module `b`](#module-b)\\n\\n\"\n         ));\n     }\n \n     #[test]\n     fn should_write_index_brief() {\n         let markdown = render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-        assert!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n+        assert!(str::contains(markdown, \"(#module-a) - test\\n\"));\n     }\n \n     #[test]\n     fn should_not_write_index_if_no_entries() {\n         let markdown = render(~\"\");\n-        assert!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n+        assert!(!str::contains(markdown, \"\\n\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_index_for_foreign_mods() {\n         let markdown = render(~\"extern { fn a(); }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n+            \"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n         ));\n     }\n \n     #[test]\n     fn should_write_foreign_fns() {\n         let markdown = render(\n             ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(str::contains(markdown, ~\"test\"));\n+        assert!(str::contains(markdown, \"test\"));\n     }\n \n     #[test]\n     fn should_write_foreign_fn_headers() {\n         let markdown = render(\n             ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(str::contains(markdown, ~\"## Function `a`\"));\n+        assert!(str::contains(markdown, \"## Function `a`\"));\n     }\n \n     #[test]\n     fn write_markdown_should_write_function_header() {\n         let markdown = render(~\"fn func() { }\");\n-        assert!(str::contains(markdown, ~\"## Function `func`\"));\n+        assert!(str::contains(markdown, \"## Function `func`\"));\n     }\n \n     #[test]\n     fn should_write_the_function_signature() {\n         let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n+        assert!(str::contains(markdown, \"\\n    fn a()\\n\"));\n     }\n \n     #[test]\n     fn should_insert_blank_line_after_fn_signature() {\n         let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n+        assert!(str::contains(markdown, \"fn a()\\n\\n\"));\n     }\n \n     #[test]\n@@ -763,40 +763,39 @@ mod test {\n             ]\n         };\n         let markdown = write_markdown_str(doc);\n-        assert!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n+        assert!(str::contains(markdown, \"    line 1\\n    line 2\"));\n     }\n \n     #[test]\n     fn should_leave_blank_line_between_fn_header_and_sig() {\n         let markdown = render(~\"fn a() { }\");\n-        assert!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n+        assert!(str::contains(markdown, \"Function `a`\\n\\n    fn a()\"));\n     }\n \n     #[test]\n     fn should_write_const_header() {\n         let markdown = render(~\"static a: bool = true;\");\n-        assert!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n+        assert!(str::contains(markdown, \"## Const `a`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_const_description() {\n         let markdown = render(\n             ~\"#[doc = \\\"b\\\"]\\\n               static a: bool = true;\");\n-        assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+        assert!(str::contains(markdown, \"\\n\\nb\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_enum_header() {\n         let markdown = render(~\"enum a { b }\");\n-        assert!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n+        assert!(str::contains(markdown, \"## Enum `a`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_enum_description() {\n-        let markdown = render(\n-            ~\"#[doc = \\\"b\\\"] enum a { b }\");\n-        assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+        let markdown = render(~\"#[doc = \\\"b\\\"] enum a { b }\");\n+        assert!(str::contains(markdown, \"\\n\\nb\\n\\n\"));\n     }\n \n     #[test]\n@@ -807,120 +806,117 @@ mod test {\n               #[doc = \\\"test\\\"] c }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n#### Variants\\n\\\n-              \\n* `b` - test\\\n-              \\n* `c` - test\\n\\n\"));\n+            \"\\n\\n#### Variants\\n\\\n+             \\n* `b` - test\\\n+             \\n* `c` - test\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_variant_list_without_descs() {\n         let markdown = render(~\"enum a { b, c }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n#### Variants\\n\\\n-              \\n* `b`\\\n-              \\n* `c`\\n\\n\"));\n+            \"\\n\\n#### Variants\\n\\\n+             \\n* `b`\\\n+             \\n* `c`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_variant_list_with_signatures() {\n         let markdown = render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n         assert!(str::contains(\n             markdown,\n-            ~\"\\n\\n#### Variants\\n\\\n-              \\n* `b(int)`\\\n-              \\n* `c(int)` - a\\n\\n\"));\n+            \"\\n\\n#### Variants\\n\\\n+             \\n* `b(int)`\\\n+             \\n* `c(int)` - a\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_trait_header() {\n         let markdown = render(~\"trait i { fn a(); }\");\n-        assert!(str::contains(markdown, ~\"## Trait `i`\"));\n+        assert!(str::contains(markdown, \"## Trait `i`\"));\n     }\n \n     #[test]\n     fn should_write_trait_desc() {\n-        let markdown = render(\n-            ~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-        assert!(str::contains(markdown, ~\"desc\"));\n+        let markdown = render(~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n+        assert!(str::contains(markdown, \"desc\"));\n     }\n \n     #[test]\n     fn should_write_trait_method_header() {\n-        let markdown = render(\n-            ~\"trait i { fn a(); }\");\n-        assert!(str::contains(markdown, ~\"### Method `a`\"));\n+        let markdown = render(~\"trait i { fn a(); }\");\n+        assert!(str::contains(markdown, \"### Method `a`\"));\n     }\n \n     #[test]\n     fn should_write_trait_method_signature() {\n-        let markdown = render(\n-            ~\"trait i { fn a(&self); }\");\n-        assert!(str::contains(markdown, ~\"\\n    fn a(&self)\"));\n+        let markdown = render(~\"trait i { fn a(&self); }\");\n+        assert!(str::contains(markdown, \"\\n    fn a(&self)\"));\n     }\n \n     #[test]\n     fn should_write_impl_header() {\n         let markdown = render(~\"impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, ~\"## Implementation for `int`\"));\n+        assert!(str::contains(markdown, \"## Implementation for `int`\"));\n     }\n \n     #[test]\n     fn should_write_impl_header_with_bounds() {\n         let markdown = render(~\"impl <T> int<T> { }\");\n-        assert!(str::contains(markdown, ~\"## Implementation for `int<T>` where `<T>`\"));\n+        assert!(str::contains(markdown, \"## Implementation for `int<T>` where `<T>`\"));\n     }\n \n     #[test]\n     fn should_write_impl_header_with_trait() {\n         let markdown = render(~\"impl j for int { fn a() { } }\");\n         assert!(str::contains(markdown,\n-                              ~\"## Implementation of `j` for `int`\"));\n+                              \"## Implementation of `j` for `int`\"));\n     }\n \n     #[test]\n     fn should_write_impl_desc() {\n         let markdown = render(\n             ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, ~\"desc\"));\n+        assert!(str::contains(markdown, \"desc\"));\n     }\n \n     #[test]\n     fn should_write_impl_method_header() {\n         let markdown = render(\n             ~\"impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, ~\"### Method `a`\"));\n+        assert!(str::contains(markdown, \"### Method `a`\"));\n     }\n \n     #[test]\n     fn should_write_impl_method_signature() {\n         let markdown = render(\n             ~\"impl int { fn a(&mut self) { } }\");\n-        assert!(str::contains(markdown, ~\"\\n    fn a(&mut self)\"));\n+        assert!(str::contains(markdown, \"\\n    fn a(&mut self)\"));\n     }\n \n     #[test]\n     fn should_write_type_header() {\n         let markdown = render(~\"type t = int;\");\n-        assert!(str::contains(markdown, ~\"## Type `t`\"));\n+        assert!(str::contains(markdown, \"## Type `t`\"));\n     }\n \n     #[test]\n     fn should_write_type_desc() {\n         let markdown = render(\n             ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-        assert!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n+        assert!(str::contains(markdown, \"\\n\\ndesc\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_type_signature() {\n         let markdown = render(~\"type t = int;\");\n-        assert!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n+        assert!(str::contains(markdown, \"\\n\\n    type t = int\\n\\n\"));\n     }\n \n     #[test]\n     fn should_put_struct_header() {\n         let markdown = render(~\"struct S { field: () }\");\n-        assert!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n+        assert!(str::contains(markdown, \"## Struct `S`\\n\\n\"));\n     }\n }"}, {"sha": "1ffdd396da9d54e1f0bc229de463073b5cee3b1b", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e43aa779f3a82614766af41adb5828d9282b5a/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=d7e43aa779f3a82614766af41adb5828d9282b5a", "patch": "@@ -188,7 +188,7 @@ mod test {\n }\");\n         assert!(str::contains(\n             doc.cratemod().mods()[0].item.sections[0].header,\n-            ~\"Header\"));\n+            \"Header\"));\n     }\n \n     #[test]\n@@ -201,7 +201,7 @@ mod test {\n }\");\n         assert!(str::contains(\n             doc.cratemod().mods()[0].item.sections[0].body,\n-            ~\"Body\"));\n+            \"Body\"));\n     }\n \n     #[test]\n@@ -226,10 +226,10 @@ mod test {\n }\");\n         assert!(!str::contains(\n             doc.cratemod().mods()[0].desc().get(),\n-            ~\"Header\"));\n+            \"Header\"));\n         assert!(!str::contains(\n             doc.cratemod().mods()[0].desc().get(),\n-            ~\"Body\"));\n+            \"Body\"));\n     }\n \n     #[test]"}]}