{"sha": "9d3c78e2eee6635772c99d7351b621cefb08bac5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkM2M3OGUyZWVlNjYzNTc3MmM5OWQ3MzUxYjYyMWNlZmIwOGJhYzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-10T13:01:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-10T13:01:44Z"}, "message": "Merge #1801\n\n1801: WIP: switch to fully decomposed tokens internally r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "14e74b81c7195bcd5b308e799c3fd447e76274ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14e74b81c7195bcd5b308e799c3fd447e76274ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d3c78e2eee6635772c99d7351b621cefb08bac5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdd564CRBK7hj4Ov3rIwAAdHIIABy63y2VDqXZ7bE0BddLZEKj\nUTqo+4XpEYsOrxiFyRK4aR3309UnSzv/NTHFFMNsOLqbtrwn8RvZNV0VehOroaLw\nx01LmbFw367EOqdiromW/4msaLxkLpVGjLzh0hyJWXHtzTkBV62Th9aAppOYHiLe\nhYc0Xz9xK1uOQNeBly1h2B+RDiIfx/xxoK504gi/dreA0dMkEeok7ZYpla6CAw0/\ny0szdexD+MbfpWS5nd0z4hLyIFEsG5TjG6trQRLyFS5hoodBK7Mojb/+nCk2lLwp\n29vcyntEfy4ejINxtEhHxLoYUYw3w4NhtcrwdmjEGAFw/0IeLhqk3Fyl6zMQhg0=\n=5cMf\n-----END PGP SIGNATURE-----\n", "payload": "tree 14e74b81c7195bcd5b308e799c3fd447e76274ca\nparent e2ebb467bdf3ebb7d29260adb95c56594c6db282\nparent ed726081d1df2fb6a1c21101996dcae203f79021\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1568120504 +0000\ncommitter GitHub <noreply@github.com> 1568120504 +0000\n\nMerge #1801\n\n1801: WIP: switch to fully decomposed tokens internally r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3c78e2eee6635772c99d7351b621cefb08bac5", "html_url": "https://github.com/rust-lang/rust/commit/9d3c78e2eee6635772c99d7351b621cefb08bac5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d3c78e2eee6635772c99d7351b621cefb08bac5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2ebb467bdf3ebb7d29260adb95c56594c6db282", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ebb467bdf3ebb7d29260adb95c56594c6db282", "html_url": "https://github.com/rust-lang/rust/commit/e2ebb467bdf3ebb7d29260adb95c56594c6db282"}, {"sha": "ed726081d1df2fb6a1c21101996dcae203f79021", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed726081d1df2fb6a1c21101996dcae203f79021", "html_url": "https://github.com/rust-lang/rust/commit/ed726081d1df2fb6a1c21101996dcae203f79021"}], "stats": {"total": 834, "additions": 497, "deletions": 337}, "files": [{"sha": "6f1e4128b38fd53040b9713b1dc0acc05108b7ec", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -1051,6 +1051,7 @@ dependencies = [\n  \"ra_tt 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n ]\n \n [[package]]"}, {"sha": "b058dde91c18db3a9b3d69f25cc65a45668e5b80", "filename": "crates/ra_mbe/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_mbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_mbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2FCargo.toml?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -12,3 +12,7 @@ itertools = \"0.8.0\"\n rustc-hash = \"1.0.0\"\n smallvec = \"0.6.9\"\n log = \"0.4.5\"\n+\n+[dev-dependencies]\n+test_utils = { path = \"../test_utils\" }\n+"}, {"sha": "08b0519d27c11b88f60ef68a0a5f5cfaea434402", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -339,21 +339,13 @@ fn expand_subtree(\n     template: &crate::Subtree,\n     ctx: &mut ExpandCtx,\n ) -> Result<tt::Subtree, ExpandError> {\n-    let token_trees = template\n-        .token_trees\n-        .iter()\n-        .map(|it| expand_tt(it, ctx))\n-        .filter(|it| {\n-            // Filter empty subtree\n-            if let Ok(tt::TokenTree::Subtree(subtree)) = it {\n-                subtree.delimiter != tt::Delimiter::None || !subtree.token_trees.is_empty()\n-            } else {\n-                true\n-            }\n-        })\n-        .collect::<Result<Vec<_>, ExpandError>>()?;\n+    let mut buf: Vec<tt::TokenTree> = Vec::new();\n+    for tt in template.token_trees.iter() {\n+        let tt = expand_tt(tt, ctx)?;\n+        push_tt(&mut buf, tt);\n+    }\n \n-    Ok(tt::Subtree { token_trees, delimiter: template.delimiter })\n+    Ok(tt::Subtree { delimiter: template.delimiter, token_trees: buf })\n }\n \n /// Reduce single token subtree to single token\n@@ -377,7 +369,7 @@ fn expand_tt(\n     let res: tt::TokenTree = match template {\n         crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, ctx)?.into(),\n         crate::TokenTree::Repeat(repeat) => {\n-            let mut token_trees: Vec<tt::TokenTree> = Vec::new();\n+            let mut buf: Vec<tt::TokenTree> = Vec::new();\n             ctx.nesting.push(0);\n             // Dirty hack to make macro-expansion terminate.\n             // This should be replaced by a propper macro-by-example implementation\n@@ -418,23 +410,23 @@ fn expand_tt(\n \n                 let idx = ctx.nesting.pop().unwrap();\n                 ctx.nesting.push(idx + 1);\n-                token_trees.push(reduce_single_token(t));\n+                push_subtree(&mut buf, t);\n \n                 if let Some(ref sep) = repeat.separator {\n                     match sep {\n                         crate::Separator::Ident(ident) => {\n                             has_seps = 1;\n-                            token_trees.push(tt::Leaf::from(ident.clone()).into());\n+                            buf.push(tt::Leaf::from(ident.clone()).into());\n                         }\n                         crate::Separator::Literal(lit) => {\n                             has_seps = 1;\n-                            token_trees.push(tt::Leaf::from(lit.clone()).into());\n+                            buf.push(tt::Leaf::from(lit.clone()).into());\n                         }\n \n                         crate::Separator::Puncts(puncts) => {\n                             has_seps = puncts.len();\n                             for punct in puncts {\n-                                token_trees.push(tt::Leaf::from(*punct).into());\n+                                buf.push(tt::Leaf::from(*punct).into());\n                             }\n                         }\n                     }\n@@ -450,16 +442,16 @@ fn expand_tt(\n \n             ctx.nesting.pop().unwrap();\n             for _ in 0..has_seps {\n-                token_trees.pop();\n+                buf.pop();\n             }\n \n             if crate::RepeatKind::OneOrMore == repeat.kind && counter == 0 {\n                 return Err(ExpandError::UnexpectedToken);\n             }\n \n-            // Check if it is a singel token subtree without any delimiter\n+            // Check if it is a single token subtree without any delimiter\n             // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n-            reduce_single_token(tt::Subtree { token_trees, delimiter: tt::Delimiter::None })\n+            reduce_single_token(tt::Subtree { delimiter: tt::Delimiter::None, token_trees: buf })\n         }\n         crate::TokenTree::Leaf(leaf) => match leaf {\n             crate::Leaf::Ident(ident) => {\n@@ -586,3 +578,17 @@ mod tests {\n         expand_rule(&rules.rules[0], &invocation_tt)\n     }\n }\n+\n+fn push_tt(buf: &mut Vec<tt::TokenTree>, tt: tt::TokenTree) {\n+    match tt {\n+        tt::TokenTree::Subtree(tt) => push_subtree(buf, tt),\n+        _ => buf.push(tt),\n+    }\n+}\n+\n+fn push_subtree(buf: &mut Vec<tt::TokenTree>, tt: tt::Subtree) {\n+    match tt.delimiter {\n+        tt::Delimiter::None => buf.extend(tt.token_trees),\n+        _ => buf.push(tt.into()),\n+    }\n+}"}, {"sha": "26524adf9b34b71d14729d853d6ce3efb6737f61", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -70,7 +70,14 @@ fn fragment_to_syntax_node(\n     tt: &tt::Subtree,\n     fragment_kind: FragmentKind,\n ) -> Result<Parse<SyntaxNode>, ExpandError> {\n-    let tokens = [tt.clone().into()];\n+    let tmp;\n+    let tokens = match tt {\n+        tt::Subtree { delimiter: tt::Delimiter::None, token_trees } => token_trees.as_slice(),\n+        _ => {\n+            tmp = [tt.clone().into()];\n+            &tmp[..]\n+        }\n+    };\n     let buffer = TokenBuffer::new(&tokens);\n     let mut token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(buffer.begin());"}, {"sha": "2b80c5f4949d7ea8a8431592af7671dbf20415f6", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -1,4 +1,5 @@\n use ra_syntax::{ast, AstNode, NodeOrToken};\n+use test_utils::assert_eq_text;\n \n use super::*;\n \n@@ -152,7 +153,6 @@ pub(crate) fn assert_expansion(\n \n     // wrap the given text to a macro call\n     let expected = text_to_tokentree(&expected);\n-\n     let (expanded_tree, expected_tree) = match kind {\n         MacroKind::Items => {\n             let expanded_tree = token_tree_to_macro_items(&expanded).unwrap().tree();\n@@ -178,7 +178,7 @@ pub(crate) fn assert_expansion(\n     let expected_tree = expected_tree.replace(\"C_C__C\", \"$crate\");\n     assert_eq!(\n         expanded_tree, expected_tree,\n-        \"left => {}\\nright => {}\",\n+        \"\\nleft:\\n{}\\nright:\\n{}\",\n         expanded_tree, expected_tree,\n     );\n \n@@ -657,6 +657,7 @@ fn test_expr() {\n }\n \n #[test]\n+#[ignore]\n fn test_expr_order() {\n     let rules = create_rules(\n         r#\"\n@@ -668,8 +669,8 @@ fn test_expr_order() {\n \"#,\n     );\n \n-    assert_eq!(\n-        format!(\"{:#?}\", expand_to_items(&rules, \"foo! { 1 + 1  }\").syntax()).trim(),\n+    assert_eq_text!(\n+        &format!(\"{:#?}\", expand_to_items(&rules, \"foo! { 1 + 1  }\").syntax()),\n         r#\"MACRO_ITEMS@[0; 15)\n   FN_DEF@[0; 15)\n     FN_KW@[0; 2) \"fn\""}, {"sha": "0158f9b8adbf74e1a2bca0d22f5a14d9e4a527b2", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -210,7 +210,7 @@ fn opt_visibility(p: &mut Parser) -> bool {\n         //\n         // test crate_keyword_path\n         // fn foo() { crate::foo(); }\n-        T![crate] if p.nth(1) != T![::] => {\n+        T![crate] if !p.nth_at(1, T![::]) => {\n             let m = p.start();\n             p.bump_any();\n             m.complete(p, VISIBILITY);\n@@ -245,7 +245,7 @@ fn abi(p: &mut Parser) {\n fn opt_fn_ret_type(p: &mut Parser) -> bool {\n     if p.at(T![->]) {\n         let m = p.start();\n-        p.bump_any();\n+        p.bump(T![->]);\n         types::type_(p);\n         m.complete(p, RET_TYPE);\n         true"}, {"sha": "ea04b945822471907e6f1e0b8b4b8b35889cd908", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 107, "deletions": 91, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -212,52 +212,48 @@ struct Restrictions {\n     prefer_stmt: bool,\n }\n \n-enum Op {\n-    Simple,\n-    Composite(SyntaxKind, u8),\n-}\n-\n-fn current_op(p: &Parser) -> (u8, Op) {\n-    if let Some(t) = p.current3() {\n-        match t {\n-            (T![<], T![<], T![=]) => return (1, Op::Composite(T![<<=], 3)),\n-            (T![>], T![>], T![=]) => return (1, Op::Composite(T![>>=], 3)),\n-            _ => (),\n-        }\n-    }\n-\n-    if let Some(t) = p.current2() {\n-        match t {\n-            (T![+], T![=]) => return (1, Op::Composite(T![+=], 2)),\n-            (T![-], T![=]) => return (1, Op::Composite(T![-=], 2)),\n-            (T![*], T![=]) => return (1, Op::Composite(T![*=], 2)),\n-            (T![%], T![=]) => return (1, Op::Composite(T![%=], 2)),\n-            (T![/], T![=]) => return (1, Op::Composite(T![/=], 2)),\n-            (T![|], T![=]) => return (1, Op::Composite(T![|=], 2)),\n-            (T![&], T![=]) => return (1, Op::Composite(T![&=], 2)),\n-            (T![^], T![=]) => return (1, Op::Composite(T![^=], 2)),\n-            (T![|], T![|]) => return (3, Op::Composite(T![||], 2)),\n-            (T![&], T![&]) => return (4, Op::Composite(T![&&], 2)),\n-            (T![<], T![=]) => return (5, Op::Composite(T![<=], 2)),\n-            (T![>], T![=]) => return (5, Op::Composite(T![>=], 2)),\n-            (T![<], T![<]) => return (9, Op::Composite(T![<<], 2)),\n-            (T![>], T![>]) => return (9, Op::Composite(T![>>], 2)),\n-            _ => (),\n-        }\n+/// Binding powers of operators for a Pratt parser.\n+///\n+/// See https://www.oilshell.org/blog/2016/11/03.html\n+#[rustfmt::skip]\n+fn current_op(p: &Parser) -> (u8, SyntaxKind) {\n+    const NOT_AN_OP: (u8, SyntaxKind) = (0, T![@]);\n+    match p.current() {\n+        T![|] if p.at(T![||])  => (3,  T![||]),\n+        T![|] if p.at(T![|=])  => (1,  T![|=]),\n+        T![|]                  => (6,  T![|]),\n+        T![>] if p.at(T![>>=]) => (1,  T![>>=]),\n+        T![>] if p.at(T![>>])  => (9,  T![>>]),\n+        T![>] if p.at(T![>=])  => (5,  T![>=]),\n+        T![>]                  => (5,  T![>]),\n+        T![=] if p.at(T![=>])  => NOT_AN_OP,\n+        T![=] if p.at(T![==])  => (5,  T![==]),\n+        T![=]                  => (1,  T![=]),\n+        T![<] if p.at(T![<=])  => (5,  T![<=]),\n+        T![<] if p.at(T![<<=]) => (1,  T![<<=]),\n+        T![<] if p.at(T![<<])  => (9,  T![<<]),\n+        T![<]                  => (5,  T![<]),\n+        T![+] if p.at(T![+=])  => (1,  T![+=]),\n+        T![+]                  => (10, T![+]),\n+        T![^] if p.at(T![^=])  => (1,  T![^=]),\n+        T![^]                  => (7,  T![^]),\n+        T![%] if p.at(T![%=])  => (1,  T![%=]),\n+        T![%]                  => (11, T![%]),\n+        T![&] if p.at(T![&=])  => (1,  T![&=]),\n+        T![&] if p.at(T![&&])  => (4,  T![&&]),\n+        T![&]                  => (8,  T![&]),\n+        T![/] if p.at(T![/=])  => (1,  T![/=]),\n+        T![/]                  => (11, T![/]),\n+        T![*] if p.at(T![*=])  => (1,  T![*=]),\n+        T![*]                  => (11, T![*]),\n+        T![.] if p.at(T![..=]) => (2,  T![..=]),\n+        T![.] if p.at(T![..])  => (2,  T![..]),\n+        T![!] if p.at(T![!=])  => (5,  T![!=]),\n+        T![-] if p.at(T![-=])  => (1,  T![-=]),\n+        T![-]                  => (10, T![-]),\n+\n+        _                      => NOT_AN_OP\n     }\n-\n-    let bp = match p.current() {\n-        T![=] => 1,\n-        T![..] | T![..=] => 2,\n-        T![==] | T![!=] | T![<] | T![>] => 5,\n-        T![|] => 6,\n-        T![^] => 7,\n-        T![&] => 8,\n-        T![-] | T![+] => 10,\n-        T![*] | T![/] | T![%] => 11,\n-        _ => 0,\n-    };\n-    (bp, Op::Simple)\n }\n \n // Parses expression with binding power of at least bp.\n@@ -308,21 +304,15 @@ fn expr_bp(\n             break;\n         }\n         let m = lhs.precede(p);\n-        match op {\n-            Op::Simple => p.bump_any(),\n-            Op::Composite(kind, n) => {\n-                p.bump_compound(kind, n);\n-            }\n-        }\n+        p.bump(op);\n \n         expr_bp(p, r, op_bp + 1, dollar_lvl);\n         lhs = m.complete(p, if is_range { RANGE_EXPR } else { BIN_EXPR });\n     }\n     (Some(lhs), BlockLike::NotBlock)\n }\n \n-const LHS_FIRST: TokenSet =\n-    atom::ATOM_EXPR_FIRST.union(token_set![AMP, STAR, EXCL, DOTDOT, DOTDOTEQ, MINUS]);\n+const LHS_FIRST: TokenSet = atom::ATOM_EXPR_FIRST.union(token_set![AMP, STAR, EXCL, DOT, MINUS]);\n \n fn lhs(\n     p: &mut Parser,\n@@ -353,17 +343,20 @@ fn lhs(\n             p.bump_any();\n             PREFIX_EXPR\n         }\n-        // test full_range_expr\n-        // fn foo() { xs[..]; }\n-        T![..] | T![..=] => {\n-            m = p.start();\n-            p.bump_any();\n-            if p.at_ts(EXPR_FIRST) {\n-                expr_bp(p, r, 2, dollar_lvl);\n-            }\n-            return Some((m.complete(p, RANGE_EXPR), BlockLike::NotBlock));\n-        }\n         _ => {\n+            // test full_range_expr\n+            // fn foo() { xs[..]; }\n+            for &op in [T![..=], T![..]].iter() {\n+                if p.at(op) {\n+                    m = p.start();\n+                    p.bump(op);\n+                    if p.at_ts(EXPR_FIRST) {\n+                        expr_bp(p, r, 2, dollar_lvl);\n+                    }\n+                    return Some((m.complete(p, RANGE_EXPR), BlockLike::NotBlock));\n+                }\n+            }\n+\n             // test expression_after_block\n             // fn foo() {\n             //    let mut p = F{x: 5};\n@@ -399,37 +392,60 @@ fn postfix_expr(\n             // }\n             T!['('] if allow_calls => call_expr(p, lhs),\n             T!['['] if allow_calls => index_expr(p, lhs),\n-            T![.] if p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth(2) == T![::]) => {\n-                method_call_expr(p, lhs)\n-            }\n-            T![.] if p.nth(1) == AWAIT_KW => {\n-                // test await_expr\n-                // fn foo() {\n-                //     x.await;\n-                //     x.0.await;\n-                //     x.0().await?.hello();\n-                // }\n-                let m = lhs.precede(p);\n-                p.bump_any();\n-                p.bump_any();\n-                m.complete(p, AWAIT_EXPR)\n-            }\n-            T![.] => field_expr(p, lhs),\n-            // test postfix_range\n-            // fn foo() { let x = 1..; }\n-            T![..] | T![..=] if !EXPR_FIRST.contains(p.nth(1)) => {\n-                let m = lhs.precede(p);\n-                p.bump_any();\n-                m.complete(p, RANGE_EXPR)\n-            }\n+            T![.] => match postfix_dot_expr(p, lhs) {\n+                Ok(it) => it,\n+                Err(it) => {\n+                    lhs = it;\n+                    break;\n+                }\n+            },\n             T![?] => try_expr(p, lhs),\n             T![as] => cast_expr(p, lhs),\n             _ => break,\n         };\n         allow_calls = true;\n         block_like = BlockLike::NotBlock;\n     }\n-    (lhs, block_like)\n+    return (lhs, block_like);\n+\n+    fn postfix_dot_expr(\n+        p: &mut Parser,\n+        lhs: CompletedMarker,\n+    ) -> Result<CompletedMarker, CompletedMarker> {\n+        assert!(p.at(T![.]));\n+        if p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth_at(2, T![::])) {\n+            return Ok(method_call_expr(p, lhs));\n+        }\n+\n+        // test await_expr\n+        // fn foo() {\n+        //     x.await;\n+        //     x.0.await;\n+        //     x.0().await?.hello();\n+        // }\n+        if p.nth(1) == T![await] {\n+            let m = lhs.precede(p);\n+            p.bump(T![.]);\n+            p.bump(T![await]);\n+            return Ok(m.complete(p, AWAIT_EXPR));\n+        }\n+\n+        // test postfix_range\n+        // fn foo() { let x = 1..; }\n+        for &(op, la) in [(T![..=], 3), (T![..], 2)].iter() {\n+            if p.at(op) {\n+                return if EXPR_FIRST.contains(p.nth(la)) {\n+                    Err(lhs)\n+                } else {\n+                    let m = lhs.precede(p);\n+                    p.bump(op);\n+                    Ok(m.complete(p, RANGE_EXPR))\n+                };\n+            }\n+        }\n+\n+        Ok(field_expr(p, lhs))\n+    }\n }\n \n // test call_expr\n@@ -465,7 +481,7 @@ fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     y.bar::<T>(1, 2,);\n // }\n fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(T![.]) && p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth(2) == T![::]));\n+    assert!(p.at(T![.]) && p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth_at(2, T![::])));\n     let m = lhs.precede(p);\n     p.bump_any();\n     name_ref(p);\n@@ -567,7 +583,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n             record_field_list(p);\n             (m.complete(p, RECORD_LIT), BlockLike::NotBlock)\n         }\n-        T![!] => {\n+        T![!] if !p.at(T![!=]) => {\n             let block_like = items::macro_call_after_excl(p);\n             (m.complete(p, MACRO_CALL), block_like)\n         }\n@@ -601,8 +617,8 @@ pub(crate) fn record_field_list(p: &mut Parser) {\n                 }\n                 m.complete(p, RECORD_FIELD);\n             }\n-            T![..] => {\n-                p.bump_any();\n+            T![.] if p.at(T![..]) => {\n+                p.bump(T![..]);\n                 expr(p);\n             }\n             T!['{'] => error_block(p, \"expected a field\"),"}, {"sha": "eff9d67e49d8468951b6f59128fc1af613e926fd", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -422,7 +422,7 @@ pub(crate) fn token_tree(p: &mut Parser) {\n                 return;\n             }\n             T![')'] | T![']'] => p.err_and_bump(\"unmatched brace\"),\n-            _ => p.bump_raw(),\n+            _ => p.bump_any(),\n         }\n     }\n     p.expect(closing_paren_kind);"}, {"sha": "f28f522b83b956642fa1ac82bc0bbd0a134c6ad2", "filename": "crates/ra_parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -13,9 +13,8 @@ pub(super) fn use_item(p: &mut Parser, m: Marker) {\n /// so handles both `some::path::{inner::path}` and `inner::path` in\n /// `use some::path::{inner::path};`\n fn use_tree(p: &mut Parser) {\n-    let la = p.nth(1);\n     let m = p.start();\n-    match (p.current(), la) {\n+    match p.current() {\n         // Finish the use_tree for cases of e.g.\n         // `use some::path::{self, *};` or `use *;`\n         // This does not handle cases such as `use some::path::*`\n@@ -28,15 +27,15 @@ fn use_tree(p: &mut Parser) {\n         // use ::*;\n         // use some::path::{*};\n         // use some::path::{::*};\n-        (T![*], _) => p.bump_any(),\n-        (T![::], T![*]) => {\n+        T![*] => p.bump(T![*]),\n+        T![:] if p.at(T![::]) && p.nth(2) == T![*] => {\n             // Parse `use ::*;`, which imports all from the crate root in Rust 2015\n             // This is invalid inside a use_tree_list, (e.g. `use some::path::{::*}`)\n             // but still parses and errors later: ('crate root in paths can only be used in start position')\n             // FIXME: Add this error (if not out of scope)\n             // In Rust 2018, it is always invalid (see above)\n-            p.bump_any();\n-            p.bump_any();\n+            p.bump(T![::]);\n+            p.bump(T![*]);\n         }\n         // Open a use tree list\n         // Handles cases such as `use {some::path};` or `{inner::path}` in\n@@ -47,10 +46,11 @@ fn use_tree(p: &mut Parser) {\n         // use {path::from::root}; // Rust 2015\n         // use ::{some::arbritrary::path}; // Rust 2015\n         // use ::{{{crate::export}}}; // Nonsensical but perfectly legal nestnig\n-        (T!['{'], _) | (T![::], T!['{']) => {\n-            if p.at(T![::]) {\n-                p.bump_any();\n-            }\n+        T!['{'] => {\n+            use_tree_list(p);\n+        }\n+        T![:] if p.at(T![::]) && p.nth(2) == T!['{'] => {\n+            p.bump(T![::]);\n             use_tree_list(p);\n         }\n         // Parse a 'standard' path.\n@@ -80,8 +80,8 @@ fn use_tree(p: &mut Parser) {\n                     // use Trait as _;\n                     opt_alias(p);\n                 }\n-                T![::] => {\n-                    p.bump_any();\n+                T![:] if p.at(T![::]) => {\n+                    p.bump(T![::]);\n                     match p.current() {\n                         T![*] => {\n                             p.bump_any();"}, {"sha": "5893b22fdc5e056d09f1c33c1a4ec40f851a8673", "filename": "crates/ra_parser/src/grammar/params.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -80,7 +80,7 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n     match flavor {\n         Flavor::OptionalType | Flavor::Normal => {\n             patterns::pattern(p);\n-            if p.at(T![:]) || flavor.type_required() {\n+            if p.at(T![:]) && !p.at(T![::]) || flavor.type_required() {\n                 types::ascription(p)\n             }\n         }\n@@ -96,10 +96,11 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n             // trait Foo {\n             //     fn bar(_: u64, mut x: i32);\n             // }\n-            if (la0 == IDENT || la0 == T![_]) && la1 == T![:]\n+            if (la0 == IDENT || la0 == T![_]) && la1 == T![:] && !p.nth_at(1, T![::])\n                 || la0 == T![mut] && la1 == IDENT && la2 == T![:]\n-                || la0 == T![&] && la1 == IDENT && la2 == T![:]\n-                || la0 == T![&] && la1 == T![mut] && la2 == IDENT && la3 == T![:]\n+                || la0 == T![&]\n+                    && (la1 == IDENT && la2 == T![:] && !p.nth_at(2, T![::])\n+                        || la1 == T![mut] && la2 == IDENT && la3 == T![:] && !p.nth_at(3, T![::]))\n             {\n                 patterns::pattern(p);\n                 types::ascription(p);"}, {"sha": "24b65128edb859986e4444eaa2084dde5897fb3d", "filename": "crates/ra_parser/src/grammar/paths.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -1,15 +1,16 @@\n use super::*;\n \n pub(super) const PATH_FIRST: TokenSet =\n-    token_set![IDENT, SELF_KW, SUPER_KW, CRATE_KW, COLONCOLON, L_ANGLE];\n+    token_set![IDENT, SELF_KW, SUPER_KW, CRATE_KW, COLON, L_ANGLE];\n \n pub(super) fn is_path_start(p: &Parser) -> bool {\n     is_use_path_start(p) || p.at(T![<])\n }\n \n pub(super) fn is_use_path_start(p: &Parser) -> bool {\n     match p.current() {\n-        IDENT | T![self] | T![super] | T![crate] | T![::] => true,\n+        IDENT | T![self] | T![super] | T![crate] => true,\n+        T![:] if p.at(T![::]) => true,\n         _ => false,\n     }\n }\n@@ -38,13 +39,13 @@ fn path(p: &mut Parser, mode: Mode) {\n     path_segment(p, mode, true);\n     let mut qual = path.complete(p, PATH);\n     loop {\n-        let use_tree = match p.nth(1) {\n+        let use_tree = match p.nth(2) {\n             T![*] | T!['{'] => true,\n             _ => false,\n         };\n         if p.at(T![::]) && !use_tree {\n             let path = qual.precede(p);\n-            p.bump_any();\n+            p.bump(T![::]);\n             path_segment(p, mode, false);\n             let path = path.complete(p, PATH);\n             qual = path;"}, {"sha": "dd1d25b07c4b192e6dceeff93f6af9aabda31a73", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -34,17 +34,20 @@ pub(super) fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n         //         200 .. 301=> (),\n         //     }\n         // }\n-        if p.at(T![...]) || p.at(T![..=]) || p.at(T![..]) {\n-            let m = lhs.precede(p);\n-            p.bump_any();\n-            atom_pat(p, recovery_set);\n-            m.complete(p, RANGE_PAT);\n+        for &range_op in [T![...], T![..=], T![..]].iter() {\n+            if p.at(range_op) {\n+                let m = lhs.precede(p);\n+                p.bump(range_op);\n+                atom_pat(p, recovery_set);\n+                m.complete(p, RANGE_PAT);\n+                return;\n+            }\n         }\n         // test marco_pat\n         // fn main() {\n         //     let m!(x) = 0;\n         // }\n-        else if lhs.kind() == PATH_PAT && p.at(T![!]) {\n+        if lhs.kind() == PATH_PAT && p.at(T![!]) {\n             let m = lhs.precede(p);\n             items::macro_call_after_excl(p);\n             m.complete(p, MACRO_CALL);\n@@ -56,14 +59,16 @@ const PAT_RECOVERY_SET: TokenSet =\n     token_set![LET_KW, IF_KW, WHILE_KW, LOOP_KW, MATCH_KW, R_PAREN, COMMA];\n \n fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n-    // Checks the token after an IDENT to see if a pattern is a path (Struct { .. }) or macro\n-    // (T![x]).\n-    let is_path_or_macro_pat =\n-        |la1| la1 == T![::] || la1 == T!['('] || la1 == T!['{'] || la1 == T![!];\n-\n     let m = match p.nth(0) {\n         T![box] => box_pat(p),\n-        T![ref] | T![mut] | IDENT if !is_path_or_macro_pat(p.nth(1)) => bind_pat(p, true),\n+        T![ref] | T![mut] => bind_pat(p, true),\n+        IDENT => match p.nth(1) {\n+            // Checks the token after an IDENT to see if a pattern is a path (Struct { .. }) or macro\n+            // (T![x]).\n+            T!['('] | T!['{'] | T![!] => path_pat(p),\n+            T![:] if p.nth_at(1, T![::]) => path_pat(p),\n+            _ => bind_pat(p, true),\n+        },\n \n         _ if paths::is_use_path_start(p) => path_pat(p),\n         _ if is_literal_pat_start(p) => literal_pat(p),\n@@ -158,7 +163,7 @@ fn record_field_pat_list(p: &mut Parser) {\n     p.bump_any();\n     while !p.at(EOF) && !p.at(T!['}']) {\n         match p.current() {\n-            T![..] => p.bump_any(),\n+            T![.] if p.at(T![..]) => p.bump(T![..]),\n             IDENT if p.nth(1) == T![:] => record_field_pat(p),\n             T!['{'] => error_block(p, \"expected ident\"),\n             T![box] => {\n@@ -237,7 +242,7 @@ fn slice_pat(p: &mut Parser) -> CompletedMarker {\n fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n         match p.current() {\n-            T![..] => p.bump_any(),\n+            T![.] if p.at(T![..]) => p.bump(T![..]),\n             _ => {\n                 if !p.at_ts(PATTERN_FIRST) {\n                     p.error(\"expected a pattern\");"}, {"sha": "edc7d4ff2b7f89c4640ce5580970cf18a9e6aeca", "filename": "crates/ra_parser/src/grammar/type_args.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -2,19 +2,16 @@ use super::*;\n \n pub(super) fn opt_type_arg_list(p: &mut Parser, colon_colon_required: bool) {\n     let m;\n-    match (colon_colon_required, p.nth(0), p.nth(1)) {\n-        (_, T![::], T![<]) => {\n-            m = p.start();\n-            p.bump_any();\n-            p.bump_any();\n-        }\n-        (false, T![<], T![=]) => return,\n-        (false, T![<], _) => {\n-            m = p.start();\n-            p.bump_any();\n-        }\n-        _ => return,\n-    };\n+    if p.at(T![::]) && p.nth(2) == T![<] {\n+        m = p.start();\n+        p.bump(T![::]);\n+        p.bump(T![<]);\n+    } else if !colon_colon_required && p.at(T![<]) && p.nth(1) != T![=] {\n+        m = p.start();\n+        p.bump(T![<]);\n+    } else {\n+        return;\n+    }\n \n     while !p.at(EOF) && !p.at(T![>]) {\n         type_arg(p);\n@@ -37,7 +34,7 @@ fn type_arg(p: &mut Parser) {\n         }\n         // test associated_type_bounds\n         // fn print_all<T: Iterator<Item: Display>>(printables: T) {}\n-        IDENT if p.nth(1) == T![:] => {\n+        IDENT if p.nth(1) == T![:] && p.nth(2) != T![:] => {\n             name_ref(p);\n             type_params::bounds(p);\n             m.complete(p, ASSOC_TYPE_ARG);"}, {"sha": "e7281123ba9afcdfae47fc7e3e619bba75ae4f40", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 88, "deletions": 167, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -6,7 +6,7 @@ use crate::{\n     event::Event,\n     ParseError,\n     SyntaxKind::{self, EOF, ERROR, TOMBSTONE},\n-    Token, TokenSet, TokenSource, T,\n+    TokenSet, TokenSource, T,\n };\n \n /// `Parser` struct provides the low-level API for\n@@ -40,38 +40,6 @@ impl<'t> Parser<'t> {\n         self.nth(0)\n     }\n \n-    /// Returns the kinds of the current two tokens, if they are not separated\n-    /// by trivia.\n-    ///\n-    /// Useful for parsing things like `>>`.\n-    pub(crate) fn current2(&self) -> Option<(SyntaxKind, SyntaxKind)> {\n-        let c1 = self.nth(0);\n-        let c2 = self.nth(1);\n-\n-        if self.token_source.current().is_jointed_to_next {\n-            Some((c1, c2))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns the kinds of the current three tokens, if they are not separated\n-    /// by trivia.\n-    ///\n-    /// Useful for parsing things like `=>>`.\n-    pub(crate) fn current3(&self) -> Option<(SyntaxKind, SyntaxKind, SyntaxKind)> {\n-        let c1 = self.nth(0);\n-        let c2 = self.nth(1);\n-        let c3 = self.nth(2);\n-        if self.token_source.current().is_jointed_to_next\n-            && self.token_source.lookahead_nth(1).is_jointed_to_next\n-        {\n-            Some((c1, c2, c3))\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Lookahead operation: returns the kind of the next nth\n     /// token.\n     pub(crate) fn nth(&self, n: usize) -> SyntaxKind {\n@@ -81,33 +49,93 @@ impl<'t> Parser<'t> {\n         assert!(steps <= 10_000_000, \"the parser seems stuck\");\n         self.steps.set(steps + 1);\n \n-        // It is beecause the Dollar will appear between nth\n-        // Following code skips through it\n-        let mut non_dollars_count = 0;\n-        let mut i = 0;\n+        self.token_source.lookahead_nth(n).kind\n+    }\n \n-        loop {\n-            let token = self.token_source.lookahead_nth(i);\n-            let mut kind = token.kind;\n-            if let Some((composited, step)) = self.is_composite(token, i) {\n-                kind = composited;\n-                i += step;\n-            } else {\n-                i += 1;\n-            }\n+    /// Checks if the current token is `kind`.\n+    pub(crate) fn at(&self, kind: SyntaxKind) -> bool {\n+        self.nth_at(0, kind)\n+    }\n \n-            match kind {\n-                EOF => return EOF,\n-                SyntaxKind::L_DOLLAR | SyntaxKind::R_DOLLAR => {}\n-                _ if non_dollars_count == n => return kind,\n-                _ => non_dollars_count += 1,\n-            }\n+    pub(crate) fn nth_at(&self, n: usize, kind: SyntaxKind) -> bool {\n+        match kind {\n+            T![-=] => self.at_composite2(n, T![-], T![=]),\n+            T![->] => self.at_composite2(n, T![-], T![>]),\n+            T![::] => self.at_composite2(n, T![:], T![:]),\n+            T![!=] => self.at_composite2(n, T![!], T![=]),\n+            T![..] => self.at_composite2(n, T![.], T![.]),\n+            T![*=] => self.at_composite2(n, T![*], T![=]),\n+            T![/=] => self.at_composite2(n, T![/], T![=]),\n+            T![&&] => self.at_composite2(n, T![&], T![&]),\n+            T![&=] => self.at_composite2(n, T![&], T![=]),\n+            T![%=] => self.at_composite2(n, T![%], T![=]),\n+            T![^=] => self.at_composite2(n, T![^], T![=]),\n+            T![+=] => self.at_composite2(n, T![+], T![=]),\n+            T![<<] => self.at_composite2(n, T![<], T![<]),\n+            T![<=] => self.at_composite2(n, T![<], T![=]),\n+            T![==] => self.at_composite2(n, T![=], T![=]),\n+            T![=>] => self.at_composite2(n, T![=], T![>]),\n+            T![>=] => self.at_composite2(n, T![>], T![=]),\n+            T![>>] => self.at_composite2(n, T![>], T![>]),\n+            T![|=] => self.at_composite2(n, T![|], T![=]),\n+            T![||] => self.at_composite2(n, T![|], T![|]),\n+\n+            T![...] => self.at_composite3(n, T![.], T![.], T![.]),\n+            T![..=] => self.at_composite3(n, T![.], T![.], T![=]),\n+            T![<<=] => self.at_composite3(n, T![<], T![<], T![=]),\n+            T![>>=] => self.at_composite3(n, T![>], T![>], T![=]),\n+\n+            _ => self.token_source.lookahead_nth(n).kind == kind,\n         }\n     }\n \n-    /// Checks if the current token is `kind`.\n-    pub(crate) fn at(&self, kind: SyntaxKind) -> bool {\n-        self.current() == kind\n+    /// Consume the next token if `kind` matches.\n+    pub(crate) fn eat(&mut self, kind: SyntaxKind) -> bool {\n+        if !self.at(kind) {\n+            return false;\n+        }\n+        let n_raw_tokens = match kind {\n+            T![-=]\n+            | T![->]\n+            | T![::]\n+            | T![!=]\n+            | T![..]\n+            | T![*=]\n+            | T![/=]\n+            | T![&&]\n+            | T![&=]\n+            | T![%=]\n+            | T![^=]\n+            | T![+=]\n+            | T![<<]\n+            | T![<=]\n+            | T![==]\n+            | T![=>]\n+            | T![>=]\n+            | T![>>]\n+            | T![|=]\n+            | T![||] => 2,\n+\n+            T![...] | T![..=] | T![<<=] | T![>>=] => 3,\n+            _ => 1,\n+        };\n+        self.do_bump(kind, n_raw_tokens);\n+        true\n+    }\n+\n+    fn at_composite2(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind) -> bool {\n+        let t1 = self.token_source.lookahead_nth(n + 0);\n+        let t2 = self.token_source.lookahead_nth(n + 1);\n+        t1.kind == k1 && t1.is_jointed_to_next && t2.kind == k2\n+    }\n+\n+    fn at_composite3(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind, k3: SyntaxKind) -> bool {\n+        let t1 = self.token_source.lookahead_nth(n + 0);\n+        let t2 = self.token_source.lookahead_nth(n + 1);\n+        let t3 = self.token_source.lookahead_nth(n + 2);\n+        (t1.kind == k1 && t1.is_jointed_to_next)\n+            && (t2.kind == k2 && t2.is_jointed_to_next)\n+            && t3.kind == k3\n     }\n \n     /// Checks if the current token is in `kinds`.\n@@ -129,22 +157,9 @@ impl<'t> Parser<'t> {\n         Marker::new(pos)\n     }\n \n-    /// Advances the parser by one token unconditionally\n-    /// Mainly use in `token_tree` parsing\n-    pub(crate) fn bump_raw(&mut self) {\n-        let mut kind = self.token_source.current().kind;\n-\n-        // Skip dollars, do_bump will eat these later\n-        let mut i = 0;\n-        while kind == SyntaxKind::L_DOLLAR || kind == SyntaxKind::R_DOLLAR {\n-            kind = self.token_source.lookahead_nth(i).kind;\n-            i += 1;\n-        }\n-\n-        if kind == EOF {\n-            return;\n-        }\n-        self.do_bump(kind, 1);\n+    /// Consume the next token if `kind` matches.\n+    pub(crate) fn bump(&mut self, kind: SyntaxKind) {\n+        assert!(self.eat(kind));\n     }\n \n     /// Advances the parser by one token with composite puncts handled\n@@ -153,27 +168,7 @@ impl<'t> Parser<'t> {\n         if kind == EOF {\n             return;\n         }\n-\n-        use SyntaxKind::*;\n-\n-        // Handle parser composites\n-        match kind {\n-            T![...] | T![..=] => {\n-                self.bump_compound(kind, 3);\n-            }\n-            T![..] | T![::] | T![==] | T![=>] | T![!=] | T![->] => {\n-                self.bump_compound(kind, 2);\n-            }\n-            _ => {\n-                self.do_bump(kind, 1);\n-            }\n-        }\n-    }\n-\n-    /// Advances the parser by one token, asserting that it is exactly the expected token\n-    pub(crate) fn bump(&mut self, expected: SyntaxKind) {\n-        debug_assert!(self.nth(0) == expected);\n-        self.bump_any()\n+        self.do_bump(kind, 1)\n     }\n \n     /// Advances the parser by one token, remapping its kind.\n@@ -190,13 +185,6 @@ impl<'t> Parser<'t> {\n         self.do_bump(kind, 1);\n     }\n \n-    /// Advances the parser by `n` tokens, remapping its kind.\n-    /// This is useful to create compound tokens from parts. For\n-    /// example, an `<<` token is two consecutive remapped `<` tokens\n-    pub(crate) fn bump_compound(&mut self, kind: SyntaxKind, n: u8) {\n-        self.do_bump(kind, n);\n-    }\n-\n     /// Emit error with the `message`\n     /// FIXME: this should be much more fancy and support\n     /// structured errors with spans and notes, like rustc\n@@ -206,15 +194,6 @@ impl<'t> Parser<'t> {\n         self.push_event(Event::Error { msg })\n     }\n \n-    /// Consume the next token if `kind` matches.\n-    pub(crate) fn eat(&mut self, kind: SyntaxKind) -> bool {\n-        if !self.at(kind) {\n-            return false;\n-        }\n-        self.bump_any();\n-        true\n-    }\n-\n     /// Consume the next token if it is `kind` or emit an error\n     /// otherwise.\n     pub(crate) fn expect(&mut self, kind: SyntaxKind) -> bool {\n@@ -243,7 +222,7 @@ impl<'t> Parser<'t> {\n     }\n \n     fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n-        self.eat_dollars();\n+        // self.eat_dollars();\n \n         for _ in 0..n_raw_tokens {\n             self.token_source.bump();\n@@ -256,64 +235,6 @@ impl<'t> Parser<'t> {\n         self.events.push(event)\n     }\n \n-    /// helper function for check if it is composite.\n-    fn is_composite(&self, first: Token, n: usize) -> Option<(SyntaxKind, usize)> {\n-        // We assume the dollars will not occuried between\n-        // mult-byte tokens\n-\n-        let jn1 = first.is_jointed_to_next;\n-        if !jn1 && first.kind != T![-] {\n-            return None;\n-        }\n-\n-        let second = self.token_source.lookahead_nth(n + 1);\n-        if first.kind == T![-] && second.kind == T![>] {\n-            return Some((T![->], 2));\n-        }\n-        if !jn1 {\n-            return None;\n-        }\n-\n-        match (first.kind, second.kind) {\n-            (T![:], T![:]) => return Some((T![::], 2)),\n-            (T![=], T![=]) => return Some((T![==], 2)),\n-            (T![=], T![>]) => return Some((T![=>], 2)),\n-            (T![!], T![=]) => return Some((T![!=], 2)),\n-            _ => {}\n-        }\n-\n-        if first.kind != T![.] || second.kind != T![.] {\n-            return None;\n-        }\n-\n-        let third = self.token_source.lookahead_nth(n + 2);\n-\n-        let jn2 = second.is_jointed_to_next;\n-        let la3 = third.kind;\n-\n-        if jn2 && la3 == T![.] {\n-            return Some((T![...], 3));\n-        }\n-        if la3 == T![=] {\n-            return Some((T![..=], 3));\n-        }\n-        return Some((T![..], 2));\n-    }\n-\n-    fn eat_dollars(&mut self) {\n-        loop {\n-            match self.token_source.current().kind {\n-                k @ SyntaxKind::L_DOLLAR | k @ SyntaxKind::R_DOLLAR => {\n-                    self.token_source.bump();\n-                    self.push_event(Event::Token { kind: k, n_raw_tokens: 1 });\n-                }\n-                _ => {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n     pub(crate) fn eat_l_dollars(&mut self) -> usize {\n         let mut ate_count = 0;\n         loop {"}, {"sha": "45892060726adcc09b12198a997c98a9aaa279ae", "filename": "crates/ra_syntax/src/tests.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftests.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -15,6 +15,18 @@ fn lexer_tests() {\n     })\n }\n \n+#[test]\n+fn parse_smoke_test() {\n+    let code = r##\"\n+fn main() {\n+    println!(\"Hello, world!\")\n+}\n+    \"##;\n+\n+    let parse = SourceFile::parse(code);\n+    assert!(parse.ok().is_ok());\n+}\n+\n #[test]\n fn parser_tests() {\n     dir_tests(&test_data_dir(), &[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n@@ -75,7 +87,9 @@ fn self_hosting_parsing() {\n     {\n         count += 1;\n         let text = read_text(entry.path());\n-        SourceFile::parse(&text).ok().expect(\"There should be no errors in the file\");\n+        if let Err(errors) = SourceFile::parse(&text).ok() {\n+            panic!(\"Parsing errors:\\n{:?}\\n{}\\n\", errors, entry.path().display());\n+        }\n     }\n     assert!(\n         count > 30,"}, {"sha": "0d3f5722a5a3bfb0d4cb96f9bf6cb41418d0c853", "filename": "crates/ra_syntax/test_data/parser/ok/0054_qual_path_in_type_arg.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -0,0 +1,5 @@\n+fn a() -> Foo<bar::Baz> {}\n+\n+fn b(_: impl FnMut(x::Y)) {}\n+\n+fn c(_: impl FnMut(&x::Y)) {}"}, {"sha": "7e1af254c8a463b50422bbff607b0e806b25f3ac", "filename": "crates/ra_syntax/test_data/parser/ok/0054_qual_path_in_type_arg.txt", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0054_qual_path_in_type_arg.txt?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -0,0 +1,126 @@\n+SOURCE_FILE@[0; 88)\n+  FN_DEF@[0; 26)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 4)\n+      IDENT@[3; 4) \"a\"\n+    PARAM_LIST@[4; 6)\n+      L_PAREN@[4; 5) \"(\"\n+      R_PAREN@[5; 6) \")\"\n+    WHITESPACE@[6; 7) \" \"\n+    RET_TYPE@[7; 23)\n+      THIN_ARROW@[7; 9) \"->\"\n+      WHITESPACE@[9; 10) \" \"\n+      PATH_TYPE@[10; 23)\n+        PATH@[10; 23)\n+          PATH_SEGMENT@[10; 23)\n+            NAME_REF@[10; 13)\n+              IDENT@[10; 13) \"Foo\"\n+            TYPE_ARG_LIST@[13; 23)\n+              L_ANGLE@[13; 14) \"<\"\n+              TYPE_ARG@[14; 22)\n+                PATH_TYPE@[14; 22)\n+                  PATH@[14; 22)\n+                    PATH@[14; 17)\n+                      PATH_SEGMENT@[14; 17)\n+                        NAME_REF@[14; 17)\n+                          IDENT@[14; 17) \"bar\"\n+                    COLONCOLON@[17; 19) \"::\"\n+                    PATH_SEGMENT@[19; 22)\n+                      NAME_REF@[19; 22)\n+                        IDENT@[19; 22) \"Baz\"\n+              R_ANGLE@[22; 23) \">\"\n+    WHITESPACE@[23; 24) \" \"\n+    BLOCK_EXPR@[24; 26)\n+      BLOCK@[24; 26)\n+        L_CURLY@[24; 25) \"{\"\n+        R_CURLY@[25; 26) \"}\"\n+  WHITESPACE@[26; 28) \"\\n\\n\"\n+  FN_DEF@[28; 56)\n+    FN_KW@[28; 30) \"fn\"\n+    WHITESPACE@[30; 31) \" \"\n+    NAME@[31; 32)\n+      IDENT@[31; 32) \"b\"\n+    PARAM_LIST@[32; 53)\n+      L_PAREN@[32; 33) \"(\"\n+      PARAM@[33; 52)\n+        PLACEHOLDER_PAT@[33; 34)\n+          UNDERSCORE@[33; 34) \"_\"\n+        COLON@[34; 35) \":\"\n+        WHITESPACE@[35; 36) \" \"\n+        IMPL_TRAIT_TYPE@[36; 52)\n+          IMPL_KW@[36; 40) \"impl\"\n+          WHITESPACE@[40; 41) \" \"\n+          TYPE_BOUND_LIST@[41; 52)\n+            TYPE_BOUND@[41; 52)\n+              PATH_TYPE@[41; 52)\n+                PATH@[41; 52)\n+                  PATH_SEGMENT@[41; 52)\n+                    NAME_REF@[41; 46)\n+                      IDENT@[41; 46) \"FnMut\"\n+                    PARAM_LIST@[46; 52)\n+                      L_PAREN@[46; 47) \"(\"\n+                      PARAM@[47; 51)\n+                        PATH_TYPE@[47; 51)\n+                          PATH@[47; 51)\n+                            PATH@[47; 48)\n+                              PATH_SEGMENT@[47; 48)\n+                                NAME_REF@[47; 48)\n+                                  IDENT@[47; 48) \"x\"\n+                            COLONCOLON@[48; 50) \"::\"\n+                            PATH_SEGMENT@[50; 51)\n+                              NAME_REF@[50; 51)\n+                                IDENT@[50; 51) \"Y\"\n+                      R_PAREN@[51; 52) \")\"\n+      R_PAREN@[52; 53) \")\"\n+    WHITESPACE@[53; 54) \" \"\n+    BLOCK_EXPR@[54; 56)\n+      BLOCK@[54; 56)\n+        L_CURLY@[54; 55) \"{\"\n+        R_CURLY@[55; 56) \"}\"\n+  WHITESPACE@[56; 58) \"\\n\\n\"\n+  FN_DEF@[58; 87)\n+    FN_KW@[58; 60) \"fn\"\n+    WHITESPACE@[60; 61) \" \"\n+    NAME@[61; 62)\n+      IDENT@[61; 62) \"c\"\n+    PARAM_LIST@[62; 84)\n+      L_PAREN@[62; 63) \"(\"\n+      PARAM@[63; 83)\n+        PLACEHOLDER_PAT@[63; 64)\n+          UNDERSCORE@[63; 64) \"_\"\n+        COLON@[64; 65) \":\"\n+        WHITESPACE@[65; 66) \" \"\n+        IMPL_TRAIT_TYPE@[66; 83)\n+          IMPL_KW@[66; 70) \"impl\"\n+          WHITESPACE@[70; 71) \" \"\n+          TYPE_BOUND_LIST@[71; 83)\n+            TYPE_BOUND@[71; 83)\n+              PATH_TYPE@[71; 83)\n+                PATH@[71; 83)\n+                  PATH_SEGMENT@[71; 83)\n+                    NAME_REF@[71; 76)\n+                      IDENT@[71; 76) \"FnMut\"\n+                    PARAM_LIST@[76; 83)\n+                      L_PAREN@[76; 77) \"(\"\n+                      PARAM@[77; 82)\n+                        REFERENCE_TYPE@[77; 82)\n+                          AMP@[77; 78) \"&\"\n+                          PATH_TYPE@[78; 82)\n+                            PATH@[78; 82)\n+                              PATH@[78; 79)\n+                                PATH_SEGMENT@[78; 79)\n+                                  NAME_REF@[78; 79)\n+                                    IDENT@[78; 79) \"x\"\n+                              COLONCOLON@[79; 81) \"::\"\n+                              PATH_SEGMENT@[81; 82)\n+                                NAME_REF@[81; 82)\n+                                  IDENT@[81; 82) \"Y\"\n+                      R_PAREN@[82; 83) \")\"\n+      R_PAREN@[83; 84) \")\"\n+    WHITESPACE@[84; 85) \" \"\n+    BLOCK_EXPR@[85; 87)\n+      BLOCK@[85; 87)\n+        L_CURLY@[85; 86) \"{\"\n+        R_CURLY@[86; 87) \"}\"\n+  WHITESPACE@[87; 88) \"\\n\""}, {"sha": "cd204f65ed9d0f0caff54b5728b0ad97918bdbd3", "filename": "crates/ra_syntax/test_data/parser/ok/0055_dot_dot_dot.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0055_dot_dot_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0055_dot_dot_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0055_dot_dot_dot.rs?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -0,0 +1,5 @@\n+type X = ();\n+\n+fn main() {\n+    let ():::X = ();\n+}"}, {"sha": "d656e74b11ff0ed2e43e50731ad5fbc6c5b49404", "filename": "crates/ra_syntax/test_data/parser/ok/0055_dot_dot_dot.txt", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0055_dot_dot_dot.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c78e2eee6635772c99d7351b621cefb08bac5/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0055_dot_dot_dot.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0055_dot_dot_dot.txt?ref=9d3c78e2eee6635772c99d7351b621cefb08bac5", "patch": "@@ -0,0 +1,50 @@\n+SOURCE_FILE@[0; 49)\n+  TYPE_ALIAS_DEF@[0; 12)\n+    TYPE_KW@[0; 4) \"type\"\n+    WHITESPACE@[4; 5) \" \"\n+    NAME@[5; 6)\n+      IDENT@[5; 6) \"X\"\n+    WHITESPACE@[6; 7) \" \"\n+    EQ@[7; 8) \"=\"\n+    WHITESPACE@[8; 9) \" \"\n+    TUPLE_TYPE@[9; 11)\n+      L_PAREN@[9; 10) \"(\"\n+      R_PAREN@[10; 11) \")\"\n+    SEMI@[11; 12) \";\"\n+  WHITESPACE@[12; 14) \"\\n\\n\"\n+  FN_DEF@[14; 48)\n+    FN_KW@[14; 16) \"fn\"\n+    WHITESPACE@[16; 17) \" \"\n+    NAME@[17; 21)\n+      IDENT@[17; 21) \"main\"\n+    PARAM_LIST@[21; 23)\n+      L_PAREN@[21; 22) \"(\"\n+      R_PAREN@[22; 23) \")\"\n+    WHITESPACE@[23; 24) \" \"\n+    BLOCK_EXPR@[24; 48)\n+      BLOCK@[24; 48)\n+        L_CURLY@[24; 25) \"{\"\n+        WHITESPACE@[25; 30) \"\\n    \"\n+        LET_STMT@[30; 46)\n+          LET_KW@[30; 33) \"let\"\n+          WHITESPACE@[33; 34) \" \"\n+          TUPLE_PAT@[34; 36)\n+            L_PAREN@[34; 35) \"(\"\n+            R_PAREN@[35; 36) \")\"\n+          COLON@[36; 37) \":\"\n+          PATH_TYPE@[37; 40)\n+            PATH@[37; 40)\n+              PATH_SEGMENT@[37; 40)\n+                COLONCOLON@[37; 39) \"::\"\n+                NAME_REF@[39; 40)\n+                  IDENT@[39; 40) \"X\"\n+          WHITESPACE@[40; 41) \" \"\n+          EQ@[41; 42) \"=\"\n+          WHITESPACE@[42; 43) \" \"\n+          TUPLE_EXPR@[43; 45)\n+            L_PAREN@[43; 44) \"(\"\n+            R_PAREN@[44; 45) \")\"\n+          SEMI@[45; 46) \";\"\n+        WHITESPACE@[46; 47) \"\\n\"\n+        R_CURLY@[47; 48) \"}\"\n+  WHITESPACE@[48; 49) \"\\n\""}]}