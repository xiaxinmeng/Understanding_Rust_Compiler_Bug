{"sha": "a0f0392a6d20dda6fcf7169a81688a0f8e1b51da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZjAzOTJhNmQyMGRkYTZmY2Y3MTY5YTgxNjg4YTBmOGUxYjUxZGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-03T10:49:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-15T15:10:55Z"}, "message": "rename `copy` to `dfs` and make it customizable", "tree": {"sha": "8eb3660d7e5b9a773f769913daa49ffeb8c3140b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eb3660d7e5b9a773f769913daa49ffeb8c3140b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0f0392a6d20dda6fcf7169a81688a0f8e1b51da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f0392a6d20dda6fcf7169a81688a0f8e1b51da", "html_url": "https://github.com/rust-lang/rust/commit/a0f0392a6d20dda6fcf7169a81688a0f8e1b51da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0f0392a6d20dda6fcf7169a81688a0f8e1b51da/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86334c711648cc17bba9955f955a6710159bd6f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/86334c711648cc17bba9955f955a6710159bd6f7", "html_url": "https://github.com/rust-lang/rust/commit/86334c711648cc17bba9955f955a6710159bd6f7"}], "stats": {"total": 300, "additions": 230, "deletions": 70}, "files": [{"sha": "c8ac0fa233ffa3cade2fae0f6c0e2896c6869121", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/a0f0392a6d20dda6fcf7169a81688a0f8e1b51da/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0f0392a6d20dda6fcf7169a81688a0f8e1b51da/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=a0f0392a6d20dda6fcf7169a81688a0f8e1b51da", "patch": "@@ -0,0 +1,217 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Module defining the `dfs` method on `RegionInferenceContext`, along with\n+//! its associated helper traits.\n+\n+use rustc::mir::{Location, Mir};\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::fx::FxHashSet;\n+use super::RegionInferenceContext;\n+use super::values::{RegionElementIndex, RegionValues, RegionValueElements};\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Function used to satisfy or test a `R1: R2 @ P`\n+    /// constraint. The core idea is that it performs a DFS starting\n+    /// from `P`. The precise actions *during* that DFS depend on the\n+    /// `op` supplied, so see (e.g.) `CopyFromSourceToTarget` for more\n+    /// details.\n+    ///\n+    /// Returns:\n+    ///\n+    /// - `Ok(true)` if the walk was completed and something changed\n+    ///   along the way;\n+    /// - `Ok(false)` if the walk was completed with no changes;\n+    /// - `Err(early)` if the walk was existed early by `op`. `earlyelem` is the\n+    ///   value that `op` returned.\n+    pub(super) fn dfs<C>(&self, mir: &Mir<'tcx>, mut op: C) -> Result<bool, C::Early>\n+    where\n+        C: DfsOp,\n+    {\n+        let mut changed = false;\n+\n+        let mut stack = vec![];\n+        let mut visited = FxHashSet();\n+\n+        stack.push(op.start_point());\n+        while let Some(p) = stack.pop() {\n+            let point_index = self.elements.index(p);\n+\n+            if !op.source_region_contains(point_index) {\n+                debug!(\"            not in from-region\");\n+                continue;\n+            }\n+\n+            if !visited.insert(p) {\n+                debug!(\"            already visited\");\n+                continue;\n+            }\n+\n+            let new = op.add_to_target_region(point_index)?;\n+            changed |= new;\n+\n+            let block_data = &mir[p.block];\n+\n+            let start_stack_len = stack.len();\n+\n+            if p.statement_index < block_data.statements.len() {\n+                stack.push(Location {\n+                    statement_index: p.statement_index + 1,\n+                    ..p\n+                });\n+            } else {\n+                stack.extend(block_data.terminator().successors().iter().map(\n+                    |&basic_block| {\n+                        Location {\n+                            statement_index: 0,\n+                            block: basic_block,\n+                        }\n+                    },\n+                ));\n+            }\n+\n+            if stack.len() == start_stack_len {\n+                // If we reach the END point in the graph, then copy\n+                // over any skolemized end points in the `from_region`\n+                // and make sure they are included in the `to_region`.\n+                changed |= op.add_universal_regions_outlived_by_source_to_target()?;\n+            }\n+        }\n+\n+        Ok(changed)\n+    }\n+}\n+\n+/// Customizes the operation of the `dfs` function. This function is\n+/// used during inference to satisfy a `R1: R2 @ P` constraint.\n+pub(super) trait DfsOp {\n+    /// If this op stops the walk early, what type does it propagate?\n+    type Early;\n+\n+    /// Returns the point from which to start the DFS.\n+    fn start_point(&self) -> Location;\n+\n+    /// Returns true if the source region contains the given point.\n+    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool;\n+\n+    /// Adds the given point to the target region, returning true if\n+    /// something has changed. Returns `Err` if we should abort the\n+    /// walk early.\n+    fn add_to_target_region(\n+        &mut self,\n+        point_index: RegionElementIndex,\n+    ) -> Result<bool, Self::Early>;\n+\n+    /// Adds all universal regions in the source region to the target region, returning\n+    /// true if something has changed.\n+    fn add_universal_regions_outlived_by_source_to_target(\n+        &mut self,\n+    ) -> Result<bool, Self::Early>;\n+}\n+\n+/// Used during inference to enforce a `R1: R2 @ P` constraint.  For\n+/// each point Q we reach along the DFS, we check if Q is in R2 (the\n+/// \"source region\"). If not, we stop the walk. Otherwise, we add Q to\n+/// R1 (the \"target region\") and continue to Q's successors. If we\n+/// reach the end of the graph, then we add any universal regions from\n+/// R2 into R1.\n+pub(super) struct CopyFromSourceToTarget<'v> {\n+    pub source_region: RegionVid,\n+    pub target_region: RegionVid,\n+    pub inferred_values: &'v mut RegionValues,\n+    pub constraint_point: Location,\n+}\n+\n+impl<'v> DfsOp for CopyFromSourceToTarget<'v> {\n+    /// We never stop the walk early.\n+    type Early = !;\n+\n+    fn start_point(&self) -> Location {\n+        self.constraint_point\n+    }\n+\n+    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool {\n+        self.inferred_values\n+            .contains(self.source_region, point_index)\n+    }\n+\n+    fn add_to_target_region(\n+        &mut self,\n+        point_index: RegionElementIndex,\n+    ) -> Result<bool, !> {\n+        Ok(self.inferred_values.add(self.target_region, point_index))\n+    }\n+\n+    fn add_universal_regions_outlived_by_source_to_target(\n+        &mut self,\n+    ) -> Result<bool, !> {\n+        Ok(\n+            self.inferred_values\n+                .add_universal_regions_outlived_by(self.source_region, self.target_region),\n+        )\n+    }\n+}\n+\n+/// Used after inference to *test* a `R1: R2 @ P` constraint.  For\n+/// each point Q we reach along the DFS, we check if Q in R2 is also\n+/// contained in R1. If not, we abort the walk early with an `Err`\n+/// condition. Similarly, if we reach the end of the graph and find\n+/// that R1 contains some universal region that R2 does not contain,\n+/// we abort the walk early.\n+#[allow(dead_code)] // TODO\n+pub(super) struct TestTarget<'v> {\n+    source_region: RegionVid,\n+    target_region: RegionVid,\n+    elements: &'v RegionValueElements,\n+    inferred_values: &'v RegionValues,\n+    constraint_point: Location,\n+}\n+\n+#[allow(dead_code)] // TODO\n+impl<'v> DfsOp for TestTarget<'v> {\n+    /// The element that was not found within R2.\n+    type Early = RegionElementIndex;\n+\n+    fn start_point(&self) -> Location {\n+        self.constraint_point\n+    }\n+\n+    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool {\n+        self.inferred_values\n+            .contains(self.source_region, point_index)\n+    }\n+\n+    fn add_to_target_region(\n+        &mut self,\n+        point_index: RegionElementIndex,\n+    ) -> Result<bool, RegionElementIndex> {\n+        if !self.inferred_values\n+            .contains(self.target_region, point_index)\n+        {\n+            return Err(point_index);\n+        }\n+\n+        Ok(false)\n+    }\n+\n+    fn add_universal_regions_outlived_by_source_to_target(\n+        &mut self,\n+    ) -> Result<bool, RegionElementIndex> {\n+        for ur in self.inferred_values\n+            .universal_regions_outlived_by(self.source_region)\n+        {\n+            if !self.inferred_values.contains(self.target_region, ur) {\n+                return Err(self.elements.index(ur));\n+            }\n+        }\n+\n+        Ok(false)\n+    }\n+}"}, {"sha": "6d76398b941ed8f464c695f6ad3064962190f125", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 13, "deletions": 70, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a0f0392a6d20dda6fcf7169a81688a0f8e1b51da/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0f0392a6d20dda6fcf7169a81688a0f8e1b51da/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=a0f0392a6d20dda6fcf7169a81688a0f8e1b51da", "patch": "@@ -18,12 +18,13 @@ use rustc::infer::region_constraints::VarOrigins;\n use rustc::mir::{ClosureOutlivesRequirement, ClosureRegionRequirements, Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::fx::FxHashSet;\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::Span;\n \n mod annotation;\n+mod dfs;\n+use self::dfs::CopyFromSourceToTarget;\n mod dump_mir;\n mod graphviz;\n mod values;\n@@ -421,14 +422,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                 // Grow the value as needed to accommodate the\n                 // outlives constraint.\n-\n-                if self.copy(\n-                    &mut inferred_values,\n+                let Ok(made_changes) = self.dfs(\n                     mir,\n-                    constraint.sub,\n-                    constraint.sup,\n-                    constraint.point,\n-                ) {\n+                    CopyFromSourceToTarget {\n+                        source_region: constraint.sub,\n+                        target_region: constraint.sup,\n+                        inferred_values: &mut inferred_values,\n+                        constraint_point: constraint.point,\n+                    },\n+                );\n+\n+                if made_changes {\n                     debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n                     debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n                     changed = true;\n@@ -440,68 +444,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.inferred_values = Some(inferred_values);\n     }\n \n-    fn copy(\n-        &self,\n-        inferred_values: &mut RegionValues,\n-        mir: &Mir<'tcx>,\n-        from_region: RegionVid,\n-        to_region: RegionVid,\n-        constraint_point: Location,\n-    ) -> bool {\n-        let mut changed = false;\n-\n-        let mut stack = vec![];\n-        let mut visited = FxHashSet();\n-\n-        stack.push(constraint_point);\n-        while let Some(p) = stack.pop() {\n-            let point_index = self.elements.index(p);\n-\n-            if !inferred_values.contains(from_region, point_index) {\n-                debug!(\"            not in from-region\");\n-                continue;\n-            }\n-\n-            if !visited.insert(p) {\n-                debug!(\"            already visited\");\n-                continue;\n-            }\n-\n-            let new = inferred_values.add(to_region, point_index);\n-            changed |= new;\n-\n-            let block_data = &mir[p.block];\n-\n-            let start_stack_len = stack.len();\n-\n-            if p.statement_index < block_data.statements.len() {\n-                stack.push(Location {\n-                    statement_index: p.statement_index + 1,\n-                    ..p\n-                });\n-            } else {\n-                stack.extend(block_data.terminator().successors().iter().map(\n-                    |&basic_block| {\n-                        Location {\n-                            statement_index: 0,\n-                            block: basic_block,\n-                        }\n-                    },\n-                ));\n-            }\n-\n-            if stack.len() == start_stack_len {\n-                // If we reach the END point in the graph, then copy\n-                // over any skolemized end points in the `from_region`\n-                // and make sure they are included in the `to_region`.\n-                changed |=\n-                    inferred_values.add_universal_regions_outlived_by(from_region, to_region);\n-            }\n-        }\n-\n-        changed\n-    }\n-\n     /// Tries to finds a good span to blame for the fact that `fr1`\n     /// contains `fr2`.\n     fn blame_span(&self, fr1: RegionVid, fr2: RegionVid) -> Span {\n@@ -647,3 +589,4 @@ impl ClosureRegionRequirementsExt for ClosureRegionRequirements {\n         }\n     }\n }\n+"}]}