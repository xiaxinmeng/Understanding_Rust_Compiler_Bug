{"sha": "dc14c432f538656dc4c6e33693031fb62dfdcad7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMTRjNDMyZjUzODY1NmRjNGM2ZTMzNjkzMDMxZmI2MmRmZGNhZDc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-24T19:24:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-24T19:24:22Z"}, "message": "Merge #7741\n\n7741: Add convert_for_to_iter_for_each assist r=mattyhall a=mattyhall\n\nImplements one direction of #7681 \r\n\r\nI wonder if this tries to guess too much at the right thing here. A common pattern is:\r\n\r\n```rust\r\nlet col = vec![1, 2, 3];\r\nfor v in &mut col {\r\n  *v *= 2;\r\n}\r\n// equivalent to:\r\ncol.iter_mut().for_each(|v| *v *= 2);\r\n```\r\n\r\nI've tried to detect this case by checking if the expression after the `in` is a (mutable) reference and if not inserting iter()/iter_mut(). This is just a convention used in the stdlib however, so could sometimes be wrong. I'd be happy to make an improvement for this, but not sure what would be best. A few options spring to mind:\r\n1. Only allow this for types that are known to have iter/iter_mut (ie stdlib types)\r\n2. Try to check if iter/iter_mut exists and they return the right iterator type\r\n3. Don't try to do this and just add `.into_iter()` to whatever is after `in`\n\nCo-authored-by: Matt Hall <matthew@quickbeam.me.uk>", "tree": {"sha": "1b7a823d2acbc72312e38e259ed5a116d641ccac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b7a823d2acbc72312e38e259ed5a116d641ccac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc14c432f538656dc4c6e33693031fb62dfdcad7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgNqfmCRBK7hj4Ov3rIwAAdHIIACnEnlBoeinUkgDO9lFD9VGr\nNxp2xlOsmw5NobxECUMknTkPpq+ECxnHVSmsCH8/0e6MFCp8le2HGwtHF3t7Tkft\nCC4Nm4eHam37dpmkoLiaJDXv8jWGfIO8rDbP59MWR7WtR0mGLaOO5twGH/V3eUHo\ngTQ/sR4eBCl9UQMFATHadzeuv1kaRqiYsp/rNECjJkaa7Jl336BMXrEn2KslLPhz\nJWwwU3peCe4wnPOwbZ6p6YA15J3e58tOIZrz+4ZHmPFgHVh0GWZj5p5DnyNdd3UC\n1UJuA8z/suYLoi5thWeARXF9lCpoMddYDmtaZNY/tSGzo/iAdErRbDd32jwPOsk=\n=sQJw\n-----END PGP SIGNATURE-----\n", "payload": "tree 1b7a823d2acbc72312e38e259ed5a116d641ccac\nparent 0537510aef4059d5f79146a8dc2734ffdb27dc74\nparent a28e8628255198aa36bcde1f380763ef257beabd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614194662 +0000\ncommitter GitHub <noreply@github.com> 1614194662 +0000\n\nMerge #7741\n\n7741: Add convert_for_to_iter_for_each assist r=mattyhall a=mattyhall\n\nImplements one direction of #7681 \r\n\r\nI wonder if this tries to guess too much at the right thing here. A common pattern is:\r\n\r\n```rust\r\nlet col = vec![1, 2, 3];\r\nfor v in &mut col {\r\n  *v *= 2;\r\n}\r\n// equivalent to:\r\ncol.iter_mut().for_each(|v| *v *= 2);\r\n```\r\n\r\nI've tried to detect this case by checking if the expression after the `in` is a (mutable) reference and if not inserting iter()/iter_mut(). This is just a convention used in the stdlib however, so could sometimes be wrong. I'd be happy to make an improvement for this, but not sure what would be best. A few options spring to mind:\r\n1. Only allow this for types that are known to have iter/iter_mut (ie stdlib types)\r\n2. Try to check if iter/iter_mut exists and they return the right iterator type\r\n3. Don't try to do this and just add `.into_iter()` to whatever is after `in`\n\nCo-authored-by: Matt Hall <matthew@quickbeam.me.uk>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc14c432f538656dc4c6e33693031fb62dfdcad7", "html_url": "https://github.com/rust-lang/rust/commit/dc14c432f538656dc4c6e33693031fb62dfdcad7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc14c432f538656dc4c6e33693031fb62dfdcad7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0537510aef4059d5f79146a8dc2734ffdb27dc74", "url": "https://api.github.com/repos/rust-lang/rust/commits/0537510aef4059d5f79146a8dc2734ffdb27dc74", "html_url": "https://github.com/rust-lang/rust/commit/0537510aef4059d5f79146a8dc2734ffdb27dc74"}, {"sha": "a28e8628255198aa36bcde1f380763ef257beabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a28e8628255198aa36bcde1f380763ef257beabd", "html_url": "https://github.com/rust-lang/rust/commit/a28e8628255198aa36bcde1f380763ef257beabd"}], "stats": {"total": 327, "additions": 327, "deletions": 0}, "files": [{"sha": "c94fb580a239645ab9a0b24ecf69bd212f21e495", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc14c432f538656dc4c6e33693031fb62dfdcad7/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc14c432f538656dc4c6e33693031fb62dfdcad7/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=dc14c432f538656dc4c6e33693031fb62dfdcad7", "patch": "@@ -189,6 +189,7 @@ pub mod known {\n         // Components of known path (function name)\n         filter_map,\n         next,\n+        iter_mut,\n         // Builtin macros\n         file,\n         column,"}, {"sha": "9fddf889cf624fb84724c6d48b11a170fe834e5b", "filename": "crates/ide_assists/src/handlers/convert_for_to_iter_for_each.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/dc14c432f538656dc4c6e33693031fb62dfdcad7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_for_to_iter_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc14c432f538656dc4c6e33693031fb62dfdcad7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_for_to_iter_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_for_to_iter_for_each.rs?ref=dc14c432f538656dc4c6e33693031fb62dfdcad7", "patch": "@@ -0,0 +1,301 @@\n+use ast::LoopBodyOwner;\n+use hir::known;\n+use ide_db::helpers::FamousDefs;\n+use stdx::format_to;\n+use syntax::{ast, AstNode};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: convert_for_to_iter_for_each\n+//\n+// Converts a for loop into a for_each loop on the Iterator.\n+//\n+// ```\n+// fn main() {\n+//     let x = vec![1, 2, 3];\n+//     for $0v in x {\n+//         let y = v * 2;\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let x = vec![1, 2, 3];\n+//     x.into_iter().for_each(|v| {\n+//         let y = v * 2;\n+//     });\n+// }\n+// ```\n+pub(crate) fn convert_for_to_iter_for_each(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let for_loop = ctx.find_node_at_offset::<ast::ForExpr>()?;\n+    let iterable = for_loop.iterable()?;\n+    let pat = for_loop.pat()?;\n+    let body = for_loop.loop_body()?;\n+\n+    acc.add(\n+        AssistId(\"convert_for_to_iter_for_each\", AssistKind::RefactorRewrite),\n+        \"Convert a for loop into an Iterator::for_each\",\n+        for_loop.syntax().text_range(),\n+        |builder| {\n+            let mut buf = String::new();\n+\n+            if let Some((expr_behind_ref, method)) =\n+                is_ref_and_impls_iter_method(&ctx.sema, &iterable)\n+            {\n+                // We have either \"for x in &col\" and col implements a method called iter\n+                //             or \"for x in &mut col\" and col implements a method called iter_mut\n+                format_to!(buf, \"{}.{}()\", expr_behind_ref, method);\n+            } else if impls_core_iter(&ctx.sema, &iterable) {\n+                format_to!(buf, \"{}\", iterable);\n+            } else {\n+                if let ast::Expr::RefExpr(_) = iterable {\n+                    format_to!(buf, \"({}).into_iter()\", iterable);\n+                } else {\n+                    format_to!(buf, \"{}.into_iter()\", iterable);\n+                }\n+            }\n+\n+            format_to!(buf, \".for_each(|{}| {});\", pat, body);\n+\n+            builder.replace(for_loop.syntax().text_range(), buf)\n+        },\n+    )\n+}\n+\n+/// If iterable is a reference where the expression behind the reference implements a method\n+/// returning an Iterator called iter or iter_mut (depending on the type of reference) then return\n+/// the expression behind the reference and the method name\n+fn is_ref_and_impls_iter_method(\n+    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    iterable: &ast::Expr,\n+) -> Option<(ast::Expr, hir::Name)> {\n+    let ref_expr = match iterable {\n+        ast::Expr::RefExpr(r) => r,\n+        _ => return None,\n+    };\n+    let wanted_method = if ref_expr.mut_token().is_some() { known::iter_mut } else { known::iter };\n+    let expr_behind_ref = ref_expr.expr()?;\n+    let typ = sema.type_of_expr(&expr_behind_ref)?;\n+    let scope = sema.scope(iterable.syntax());\n+    let krate = scope.module()?.krate();\n+    let traits_in_scope = scope.traits_in_scope();\n+    let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n+    let has_wanted_method = typ.iterate_method_candidates(\n+        sema.db,\n+        krate,\n+        &traits_in_scope,\n+        Some(&wanted_method),\n+        |_, func| {\n+            if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n+                return Some(());\n+            }\n+            None\n+        },\n+    );\n+    has_wanted_method.and(Some((expr_behind_ref, wanted_method)))\n+}\n+\n+/// Whether iterable implements core::Iterator\n+fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n+    let it_typ = if let Some(i) = sema.type_of_expr(iterable) {\n+        i\n+    } else {\n+        return false;\n+    };\n+    let module = if let Some(m) = sema.scope(iterable.syntax()).module() {\n+        m\n+    } else {\n+        return false;\n+    };\n+    let krate = module.krate();\n+    if let Some(iter_trait) = FamousDefs(sema, Some(krate)).core_iter_Iterator() {\n+        return it_typ.impls_trait(sema.db, iter_trait, &[]);\n+    }\n+    false\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    const EMPTY_ITER_FIXTURE: &'static str = r\"\n+//- /lib.rs deps:core crate:empty_iter\n+pub struct EmptyIter;\n+impl Iterator for EmptyIter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n+pub struct Empty;\n+impl Empty {\n+    pub fn iter(&self) -> EmptyIter { EmptyIter }\n+    pub fn iter_mut(&self) -> EmptyIter { EmptyIter }\n+}\n+\n+pub struct NoIterMethod;\n+\";\n+\n+    fn check_assist_with_fixtures(before: &str, after: &str) {\n+        let before = &format!(\n+            \"//- /main.rs crate:main deps:core,empty_iter{}{}{}\",\n+            before,\n+            FamousDefs::FIXTURE,\n+            EMPTY_ITER_FIXTURE\n+        );\n+        check_assist(convert_for_to_iter_for_each, before, after);\n+    }\n+\n+    #[test]\n+    fn test_not_for() {\n+        check_assist_not_applicable(\n+            convert_for_to_iter_for_each,\n+            r\"\n+let mut x = vec![1, 2, 3];\n+x.iter_mut().$0for_each(|v| *v *= 2);\n+        \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_simple_for() {\n+        check_assist(\n+            convert_for_to_iter_for_each,\n+            r\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    for $0v in x {\n+        v *= 2;\n+    }\n+}\",\n+            r\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    x.into_iter().for_each(|v| {\n+        v *= 2;\n+    });\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_for_borrowed() {\n+        check_assist_with_fixtures(\n+            r\"\n+use empty_iter::*;\n+fn main() {\n+    let x = Empty;\n+    for $0v in &x {\n+        let a = v * 2;\n+    }\n+}\n+\",\n+            r\"\n+use empty_iter::*;\n+fn main() {\n+    let x = Empty;\n+    x.iter().for_each(|v| {\n+        let a = v * 2;\n+    });\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_for_borrowed_no_iter_method() {\n+        check_assist_with_fixtures(\n+            r\"\n+use empty_iter::*;\n+fn main() {\n+    let x = NoIterMethod;\n+    for $0v in &x {\n+        let a = v * 2;\n+    }\n+}\n+\",\n+            r\"\n+use empty_iter::*;\n+fn main() {\n+    let x = NoIterMethod;\n+    (&x).into_iter().for_each(|v| {\n+        let a = v * 2;\n+    });\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_for_borrowed_mut() {\n+        check_assist_with_fixtures(\n+            r\"\n+use empty_iter::*;\n+fn main() {\n+    let x = Empty;\n+    for $0v in &mut x {\n+        let a = v * 2;\n+    }\n+}\n+\",\n+            r\"\n+use empty_iter::*;\n+fn main() {\n+    let x = Empty;\n+    x.iter_mut().for_each(|v| {\n+        let a = v * 2;\n+    });\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_for_borrowed_mut_behind_var() {\n+        check_assist(\n+            convert_for_to_iter_for_each,\n+            r\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    let y = &mut x;\n+    for $0v in y {\n+        *v *= 2;\n+    }\n+}\",\n+            r\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    let y = &mut x;\n+    y.into_iter().for_each(|v| {\n+        *v *= 2;\n+    });\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_already_impls_iterator() {\n+        check_assist_with_fixtures(\n+            r#\"\n+use empty_iter::*;\n+fn main() {\n+    let x = Empty;\n+    for$0 a in x.iter().take(1) {\n+        println!(\"{}\", a);\n+    }\n+}\n+\"#,\n+            r#\"\n+use empty_iter::*;\n+fn main() {\n+    let x = Empty;\n+    x.iter().take(1).for_each(|a| {\n+        println!(\"{}\", a);\n+    });\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "f4c7e6fbf7c1226e5b1c2fedfd32b820caa2bea4", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc14c432f538656dc4c6e33693031fb62dfdcad7/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc14c432f538656dc4c6e33693031fb62dfdcad7/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=dc14c432f538656dc4c6e33693031fb62dfdcad7", "patch": "@@ -114,6 +114,7 @@ mod handlers {\n     mod apply_demorgan;\n     mod auto_import;\n     mod change_visibility;\n+    mod convert_for_to_iter_for_each;\n     mod convert_integer_literal;\n     mod early_return;\n     mod expand_glob_import;\n@@ -175,6 +176,7 @@ mod handlers {\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,\n             change_visibility::change_visibility,\n+            convert_for_to_iter_for_each::convert_for_to_iter_for_each,\n             convert_integer_literal::convert_integer_literal,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,"}, {"sha": "d4287582226131698ed4cddc3bd34491cb369b1d", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dc14c432f538656dc4c6e33693031fb62dfdcad7/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc14c432f538656dc4c6e33693031fb62dfdcad7/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=dc14c432f538656dc4c6e33693031fb62dfdcad7", "patch": "@@ -192,6 +192,29 @@ pub(crate) fn frobnicate() {}\n     )\n }\n \n+#[test]\n+fn doctest_convert_for_to_iter_for_each() {\n+    check_doc_test(\n+        \"convert_for_to_iter_for_each\",\n+        r#####\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    for $0v in x {\n+        let y = v * 2;\n+    }\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    x.into_iter().for_each(|v| {\n+        let y = v * 2;\n+    });\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_integer_literal() {\n     check_doc_test("}]}