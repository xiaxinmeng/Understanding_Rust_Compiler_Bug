{"sha": "09a1b949071cd573cd171362e9c3b894105556c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YTFiOTQ5MDcxY2Q1NzNjZDE3MTM2MmU5YzNiODk0MTA1NTU2YzE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-22T01:36:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-31T04:23:34Z"}, "message": "Various changes for self-describing vecs", "tree": {"sha": "fc5485ce24f509cdc0b5d5e6b42b0de0995c8d0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc5485ce24f509cdc0b5d5e6b42b0de0995c8d0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09a1b949071cd573cd171362e9c3b894105556c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09a1b949071cd573cd171362e9c3b894105556c1", "html_url": "https://github.com/rust-lang/rust/commit/09a1b949071cd573cd171362e9c3b894105556c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09a1b949071cd573cd171362e9c3b894105556c1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "846dfbc922b5b8c2c7de8da0cbb912bb89ff046e", "url": "https://api.github.com/repos/rust-lang/rust/commits/846dfbc922b5b8c2c7de8da0cbb912bb89ff046e", "html_url": "https://github.com/rust-lang/rust/commit/846dfbc922b5b8c2c7de8da0cbb912bb89ff046e"}], "stats": {"total": 308, "additions": 201, "deletions": 107}, "files": [{"sha": "4019c8701ac373e3f795675019f426676d418902", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=09a1b949071cd573cd171362e9c3b894105556c1", "patch": "@@ -13,7 +13,7 @@ command_line_args : public kernel_owned<command_line_args>\n     char **argv;\n \n     // [str] passed to rust_task::start.\n-    rust_vec *args;\n+    rust_vec_box *args;\n \n     command_line_args(rust_task *task,\n                       int sys_argc,\n@@ -47,7 +47,7 @@ command_line_args : public kernel_owned<command_line_args>\n \n     ~command_line_args() {\n         for (int i = 0; i < argc; ++i) {\n-            rust_vec *s = ((rust_vec**)&args->data)[i];\n+            rust_vec *s = ((rust_vec**)&args->body.data)[i];\n             kernel->free(s);\n         }\n         kernel->free(args);"}, {"sha": "ce86bc0901bda41c575ac0302250196a3a0e6ffb", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=09a1b949071cd573cd171362e9c3b894105556c1", "patch": "@@ -85,7 +85,7 @@ rust_getcwd() {\n }\n \n #if defined(__WIN32__)\n-extern \"C\" CDECL rust_vec *\n+extern \"C\" CDECL rust_vec_box *\n rust_env_pairs() {\n     rust_task *task = rust_get_current_task();\n     size_t envc = 0;\n@@ -102,7 +102,7 @@ rust_env_pairs() {\n     for (size_t i = 0; i < envc; ++i) {\n         size_t n = strlen(c);\n         rust_str *str = make_str(task->kernel, c, n, \"str\");\n-        ((rust_str**)&v->data)[i] = str;\n+        ((rust_str**)&v->body.data)[i] = str;\n         c += n + 1;\n     }\n     if (ch) {\n@@ -111,7 +111,7 @@ rust_env_pairs() {\n     return v;\n }\n #else\n-extern \"C\" CDECL rust_vec *\n+extern \"C\" CDECL rust_vec_box *\n rust_env_pairs() {\n     rust_task *task = rust_get_current_task();\n #ifdef __APPLE__\n@@ -140,14 +140,14 @@ unsupervise() {\n }\n \n extern \"C\" CDECL void\n-vec_reserve_shared(type_desc* ty, rust_vec** vp,\n+vec_reserve_shared(type_desc* ty, rust_vec_box** vp,\n                    size_t n_elts) {\n     rust_task *task = rust_get_current_task();\n     reserve_vec_exact(task, vp, n_elts * ty->size);\n }\n \n extern \"C\" CDECL void\n-str_reserve_shared(rust_vec** sp,\n+str_reserve_shared(rust_vec_box** sp,\n                    size_t n_elts) {\n     rust_task *task = rust_get_current_task();\n     reserve_vec_exact(task, sp, n_elts + 1);\n@@ -169,13 +169,13 @@ vec_from_buf_shared(type_desc *ty, void *ptr, size_t count) {\n }\n \n extern \"C\" CDECL void\n-rust_str_push(rust_vec** sp, uint8_t byte) {\n+rust_str_push(rust_vec_box** sp, uint8_t byte) {\n     rust_task *task = rust_get_current_task();\n-    size_t fill = (*sp)->fill;\n+    size_t fill = (*sp)->body.fill;\n     reserve_vec(task, sp, fill + 1);\n-    (*sp)->data[fill-1] = byte;\n-    (*sp)->data[fill] = 0;\n-    (*sp)->fill = fill + 1;\n+    (*sp)->body.data[fill-1] = byte;\n+    (*sp)->body.data[fill] = 0;\n+    (*sp)->body.fill = fill + 1;\n }\n \n extern \"C\" CDECL rust_vec*\n@@ -373,7 +373,7 @@ rust_list_files(rust_str *path) {\n     array_list<rust_str*> strings;\n #if defined(__WIN32__)\n     WIN32_FIND_DATA FindFileData;\n-    HANDLE hFind = FindFirstFile((char*)path->data, &FindFileData);\n+    HANDLE hFind = FindFirstFile((char*)path->body.data, &FindFileData);\n     if (hFind != INVALID_HANDLE_VALUE) {\n         do {\n             rust_str *str = make_str(task->kernel, FindFileData.cFileName,\n@@ -384,13 +384,13 @@ rust_list_files(rust_str *path) {\n         FindClose(hFind);\n     }\n #else\n-    DIR *dirp = opendir((char*)path->data);\n+    DIR *dirp = opendir((char*)path->body.data);\n   if (dirp) {\n       struct dirent *dp;\n       while ((dp = readdir(dirp))) {\n-          rust_vec *str = make_str(task->kernel, dp->d_name,\n-                                    strlen(dp->d_name),\n-                                    \"list_files_str\");\n+          rust_vec_box *str = make_str(task->kernel, dp->d_name,\n+                                       strlen(dp->d_name),\n+                                       \"list_files_str\");\n           strings.push(str);\n       }\n       closedir(dirp);\n@@ -520,9 +520,9 @@ void tm_to_rust_tm(tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n     if (zone != NULL) {\n         size_t size = strlen(zone);\n         str_reserve_shared(&out_tm->tm_zone, size);\n-        memcpy(out_tm->tm_zone->data, zone, size);\n-        out_tm->tm_zone->fill = size + 1;\n-        out_tm->tm_zone->data[size] = '\\0';\n+        memcpy(out_tm->tm_zone->body.data, zone, size);\n+        out_tm->tm_zone->body.fill = size + 1;\n+        out_tm->tm_zone->body.data[size] = '\\0';\n     }\n }\n "}, {"sha": "77a253d2bb76b72ee77db58b6c03c3c602aa7efa", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=09a1b949071cd573cd171362e9c3b894105556c1", "patch": "@@ -1110,9 +1110,9 @@ data<T,U>::walk_variant1(tag_info &tinfo, tag_variant_t variant_id) {\n template<typename T,typename U>\n std::pair<uint8_t *,uint8_t *>\n data<T,U>::get_vec_data_range(ptr dp) {\n-    rust_vec* ptr = bump_dp<rust_vec*>(dp);\n-    uint8_t* data = &ptr->data[0];\n-    return std::make_pair(data, data + ptr->fill);\n+    rust_vec_box* ptr = bump_dp<rust_vec_box*>(dp);\n+    uint8_t* data = &ptr->body.data[0];\n+    return std::make_pair(data, data + ptr->body.fill);\n }\n \n template<typename T,typename U>"}, {"sha": "667a511debf81f433f9e7eccda586ce387c04aa6", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=09a1b949071cd573cd171362e9c3b894105556c1", "patch": "@@ -445,10 +445,10 @@ upcall_s_str_new_shared(s_str_new_shared_args *args) {\n                              vec_size<char>(str_fill),\n                              \"str_new_shared\");\n     rust_str *str = (rust_str *)box_body(args->retval);\n-    str->fill = str_fill;\n-    str->alloc = str_alloc;\n-    memcpy(&str->data, args->cstr, args->len);\n-    str->data[args->len] = '\\0';\n+    str->body.fill = str_fill;\n+    str->body.alloc = str_alloc;\n+    memcpy(&str->body.data, args->cstr, args->len);\n+    str->body.data[args->len] = '\\0';\n }\n \n extern \"C\" CDECL rust_opaque_box*\n@@ -460,7 +460,7 @@ upcall_str_new_shared(const char *cstr, size_t len) {\n \n \n struct s_vec_grow_args {\n-    rust_vec** vp;\n+    rust_vec_box** vp;\n     size_t new_sz;\n };\n \n@@ -469,37 +469,38 @@ upcall_s_vec_grow(s_vec_grow_args *args) {\n     rust_task *task = rust_get_current_task();\n     LOG_UPCALL_ENTRY(task);\n     reserve_vec(task, args->vp, args->new_sz);\n-    (*args->vp)->fill = args->new_sz;\n+    (*args->vp)->body.fill = args->new_sz;\n }\n \n extern \"C\" CDECL void\n-upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n+upcall_vec_grow(rust_vec_box** vp, size_t new_sz) {\n     s_vec_grow_args args = {vp, new_sz};\n     UPCALL_SWITCH_STACK(&args, upcall_s_vec_grow);\n }\n \n struct s_str_concat_args {\n-    rust_vec* lhs;\n-    rust_vec* rhs;\n-    rust_vec* retval;\n+    rust_vec_box* lhs;\n+    rust_vec_box* rhs;\n+    rust_vec_box* retval;\n };\n \n extern \"C\" CDECL void\n upcall_s_str_concat(s_str_concat_args *args) {\n-    rust_vec *lhs = args->lhs;\n-    rust_vec *rhs = args->rhs;\n+    rust_vec *lhs = &args->lhs->body;\n+    rust_vec *rhs = &args->rhs->body;\n     rust_task *task = rust_get_current_task();\n     size_t fill = lhs->fill + rhs->fill - 1;\n-    rust_vec* v = (rust_vec*)task->kernel->malloc(fill + sizeof(rust_vec),\n-                                                  \"str_concat\");\n-    v->fill = v->alloc = fill;\n-    memmove(&v->data[0], &lhs->data[0], lhs->fill - 1);\n-    memmove(&v->data[lhs->fill - 1], &rhs->data[0], rhs->fill);\n+    rust_vec_box* v = (rust_vec_box*)\n+        task->kernel->malloc(fill + sizeof(rust_vec_box),\n+                             \"str_concat\");\n+    v->body.fill = v->body.alloc = fill;\n+    memmove(&v->body.data[0], &lhs->data[0], lhs->fill - 1);\n+    memmove(&v->body.data[lhs->fill - 1], &rhs->data[0], rhs->fill);\n     args->retval = v;\n }\n \n-extern \"C\" CDECL rust_vec*\n-upcall_str_concat(rust_vec* lhs, rust_vec* rhs) {\n+extern \"C\" CDECL rust_vec_box*\n+upcall_str_concat(rust_vec_box* lhs, rust_vec_box* rhs) {\n     s_str_concat_args args = {lhs, rhs, 0};\n     UPCALL_SWITCH_STACK(&args, upcall_s_str_concat);\n     return args.retval;"}, {"sha": "3a7bd0b7d71ba5fc5239fd7492e3e8b3008480d2", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=09a1b949071cd573cd171362e9c3b894105556c1", "patch": "@@ -42,9 +42,16 @@ rust_vec\n     uint8_t data[0];\n };\n \n+struct\n+rust_vec_box\n+{\n+    rust_opaque_box header;\n+    rust_vec body;\n+};\n+\n template <typename T>\n inline size_t vec_size(size_t elems) {\n-    return sizeof(rust_vec) + sizeof(T) * elems;\n+    return sizeof(rust_vec_box) + sizeof(T) * elems;\n }\n \n template <typename T>\n@@ -53,19 +60,20 @@ vec_data(rust_vec *v) {\n     return reinterpret_cast<T*>(v->data);\n }\n \n-inline void reserve_vec_exact(rust_task* task, rust_vec** vpp, size_t size) {\n-    if (size > (*vpp)->alloc) {\n-        *vpp = (rust_vec*)task->kernel\n-            ->realloc(*vpp, size + sizeof(rust_vec));\n-        (*vpp)->alloc = size;\n+inline void reserve_vec_exact(rust_task* task, rust_vec_box** vpp,\n+                              size_t size) {\n+    if (size > (*vpp)->body.alloc) {\n+        *vpp = (rust_vec_box*)task->kernel\n+            ->realloc(*vpp, size + sizeof(rust_vec_box));\n+        (*vpp)->body.alloc = size;\n     }\n }\n \n-inline void reserve_vec(rust_task* task, rust_vec** vpp, size_t size) {\n+inline void reserve_vec(rust_task* task, rust_vec_box** vpp, size_t size) {\n     reserve_vec_exact(task, vpp, next_power_of_two(size));\n }\n \n-typedef rust_vec rust_str;\n+typedef rust_vec_box rust_str;\n \n inline rust_str *\n make_str(rust_kernel* kernel, const char* c, size_t strlen,\n@@ -74,24 +82,24 @@ make_str(rust_kernel* kernel, const char* c, size_t strlen,\n     size_t str_alloc = str_fill;\n     rust_str *str = (rust_str *)\n         kernel->malloc(vec_size<char>(str_fill), name);\n-    str->fill = str_fill;\n-    str->alloc = str_alloc;\n-    memcpy(&str->data, c, strlen);\n-    str->data[strlen] = '\\0';\n+    str->body.fill = str_fill;\n+    str->body.alloc = str_alloc;\n+    memcpy(&str->body.data, c, strlen);\n+    str->body.data[strlen] = '\\0';\n     return str;\n }\n \n-inline rust_vec *\n+inline rust_vec_box *\n make_str_vec(rust_kernel* kernel, size_t nstrs, char **strs) {\n-    rust_vec *v = (rust_vec *)\n-        kernel->malloc(vec_size<rust_vec*>(nstrs),\n+    rust_vec_box *v = (rust_vec_box *)\n+        kernel->malloc(vec_size<rust_vec_box*>(nstrs),\n                        \"str vec interior\");\n-    v->fill = v->alloc = sizeof(rust_vec*) * nstrs;\n+    v->body.fill = v->body.alloc = sizeof(rust_vec_box*) * nstrs;\n     for (size_t i = 0; i < nstrs; ++i) {\n         rust_str *str = make_str(kernel, strs[i],\n                                  strlen(strs[i]),\n                                  \"str\");\n-        ((rust_str**)&v->data)[i] = str;\n+        ((rust_str**)&v->body.data)[i] = str;\n     }\n     return v;\n }"}, {"sha": "6430632d5c007bbdff1283bd021198191aca3749", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=09a1b949071cd573cd171362e9c3b894105556c1", "patch": "@@ -3,8 +3,8 @@ import driver::session;\n import middle::trans::base;\n import middle::trans::common::{T_fn, T_i1, T_i8, T_i32,\n                                T_int, T_nil,\n-                               T_opaque_vec, T_ptr,\n-                               T_size_t, T_void};\n+                               T_opaque_vec, T_ptr, T_unique_ptr,\n+                               T_size_t, T_void, T_vec2};\n import lib::llvm::{type_names, ModuleRef, ValueRef, TypeRef};\n \n type upcalls =\n@@ -13,6 +13,7 @@ type upcalls =\n      malloc: ValueRef,\n      free: ValueRef,\n      exchange_malloc: ValueRef,\n+     exchange_malloc_dyn: ValueRef,\n      exchange_free: ValueRef,\n      validate_box: ValueRef,\n      shared_malloc: ValueRef,\n@@ -51,7 +52,6 @@ fn declare_upcalls(targ_cfg: @session::config,\n \n     let int_t = T_int(targ_cfg);\n     let size_t = T_size_t(targ_cfg);\n-    let opaque_vec_t = T_opaque_vec(targ_cfg);\n \n     ret @{_fail: dv(\"fail\", [T_ptr(T_i8()),\n                              T_ptr(T_i8()),\n@@ -67,6 +67,10 @@ fn declare_upcalls(targ_cfg: @session::config,\n           exchange_malloc:\n               nothrow(d(\"exchange_malloc\", [T_ptr(tydesc_type)],\n                         T_ptr(T_i8()))),\n+          exchange_malloc_dyn:\n+              nothrow(d(\"exchange_malloc_dyn\",\n+                        [T_ptr(tydesc_type), int_t],\n+                        T_ptr(T_i8()))),\n           exchange_free:\n               nothrow(dv(\"exchange_free\", [T_ptr(T_i8())])),\n           validate_box:\n@@ -81,17 +85,17 @@ fn declare_upcalls(targ_cfg: @session::config,\n           mark:\n               d(\"mark\", [T_ptr(T_i8())], int_t),\n           vec_grow:\n-              nothrow(dv(\"vec_grow\", [T_ptr(T_ptr(opaque_vec_t)), int_t])),\n+              nothrow(dv(\"vec_grow\", [T_ptr(T_ptr(T_i8())), int_t])),\n           str_new_uniq:\n               nothrow(d(\"str_new_uniq\", [T_ptr(T_i8()), int_t],\n-                        T_ptr(opaque_vec_t))),\n+                        T_ptr(T_i8()))),\n           str_new_shared:\n               nothrow(d(\"str_new_shared\", [T_ptr(T_i8()), int_t],\n                         T_ptr(T_i8()))),\n           str_concat:\n-              nothrow(d(\"str_concat\", [T_ptr(opaque_vec_t),\n-                                       T_ptr(opaque_vec_t)],\n-                        T_ptr(opaque_vec_t))),\n+              nothrow(d(\"str_concat\", [T_ptr(T_i8()),\n+                                       T_ptr(T_i8())],\n+                        T_ptr(T_i8()))),\n           cmp_type:\n               dv(\"cmp_type\",\n                  [T_ptr(T_i1()), T_ptr(tydesc_type),"}, {"sha": "29e063342702244552dbc1fed3956eb11b28774c", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=09a1b949071cd573cd171362e9c3b894105556c1", "patch": "@@ -417,6 +417,33 @@ fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n     ret {box: box, body: body};\n }\n \n+fn malloc_unique_dyn_raw(bcx: block, t: ty::t, size: ValueRef) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_box_raw\");\n+    let ccx = bcx.ccx();\n+\n+    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n+    // wants.\n+    let box_ptr = ty::mk_imm_uniq(ccx.tcx, t);\n+    let llty = type_of(ccx, box_ptr);\n+\n+    // Get the tydesc for the body:\n+    let mut static_ti = none;\n+    let lltydesc = get_tydesc(ccx, t, static_ti);\n+    lazily_emit_all_tydesc_glue(ccx, static_ti);\n+\n+    // Allocate space:\n+    let rval = Call(bcx, ccx.upcalls.exchange_malloc_dyn, [lltydesc, size]);\n+    ret PointerCast(bcx, rval, llty);\n+}\n+\n+fn malloc_unique_dyn(bcx: block, t: ty::t, size: ValueRef\n+                    ) -> {box: ValueRef, body: ValueRef} {\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_box\");\n+    let box = malloc_unique_dyn_raw(bcx, t, size);\n+    let body = GEPi(bcx, box, [0u, abi::box_field_body]);\n+    ret {box: box, body: body};\n+}\n+\n // Type descriptor and type glue stuff\n \n fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n@@ -560,7 +587,9 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n     // the caller has no idea if it's dealing with something that can be\n     // passed by value.\n \n+    #error(\"%?\", ty::get(t));\n     let llty = T_ptr(type_of(ccx, t));\n+    #error(\"%?\", ty_str(ccx.tn, llty));\n \n     let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;"}, {"sha": "a9b78918295db751fc7766d7df555b85f9688b53", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 86, "deletions": 38, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=09a1b949071cd573cd171362e9c3b894105556c1", "patch": "@@ -21,6 +21,24 @@ fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n+\n+fn get_bodyptr(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> ValueRef {\n+    let ccx = bcx.ccx();\n+    alt ty::get(vec_ty).struct {\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq)\n+      | ty::ty_vec(_) | ty::ty_str {\n+        let boxptr = PointerCast(bcx, vptr, T_ptr(T_box_header(ccx)));\n+        let bodyptr = GEPi(bcx, boxptr, [1u]);\n+        let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n+        let llunit_ty = type_of::type_of(ccx, unit_ty);\n+        PointerCast(bcx, bodyptr, T_ptr(T_vec(ccx, llunit_ty)))\n+      }\n+      _ {\n+        vptr\n+      }\n+    }\n+}\n+\n fn get_dataptr(bcx: block, vptr: ValueRef, unit_ty: TypeRef)\n     -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n@@ -35,41 +53,55 @@ fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-fn alloc_uniq_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n+fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n+                  fill: ValueRef, alloc: ValueRef) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq_raw\");\n     let ccx = bcx.ccx();\n-    let llvecty = ccx.opaque_vec_type;\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n+    let llvecty = T_vec(ccx, llunitty);\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n-    let vecptr = shared_malloc(bcx, T_ptr(llvecty), vecsize);\n-    Store(bcx, fill, GEPi(bcx, vecptr, [0u, abi::vec_elt_fill]));\n-    Store(bcx, alloc, GEPi(bcx, vecptr, [0u, abi::vec_elt_alloc]));\n-    ret {bcx: bcx, val: vecptr};\n+    let vecbodyty = unit_ty; // FIXME: This is not the correct type\n+    let {box, body} = base::malloc_unique_dyn(bcx, vecbodyty, vecsize);\n+    let boxptr = PointerCast(bcx, box,\n+                             T_unique_ptr(T_unique(bcx.ccx(), llvecty)));\n+    let bodyptr = PointerCast(bcx, body, T_ptr(llvecty));\n+    Store(bcx, fill, GEPi(bcx, bodyptr, [0u, abi::vec_elt_fill]));\n+    Store(bcx, alloc, GEPi(bcx, bodyptr, [0u, abi::vec_elt_alloc]));\n+    ret {bcx: bcx, val: boxptr};\n }\n \n-fn alloc_uniq(bcx: block, llunitty: TypeRef, elts: uint) -> result {\n+fn alloc_uniq(bcx: block, unit_ty: ty::t, elts: uint) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n-    let llvecty = T_vec(ccx, llunitty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n     let unit_sz = llsize_of(ccx, llunitty);\n \n     let fill = Mul(bcx, C_uint(ccx, elts), unit_sz);\n     let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n                 else { fill };\n-    let {bcx: bcx, val: vptr} = alloc_uniq_raw(bcx, fill, alloc);\n-    let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n-\n+    let {bcx: bcx, val: vptr} = alloc_uniq_raw(bcx, unit_ty, fill, alloc);\n     ret {bcx: bcx, val: vptr};\n }\n \n fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n     let ccx = bcx.ccx();\n-    let fill = get_fill(bcx, vptr);\n+    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n+    let fill = get_fill(bcx, body_ptr);\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n-    let newptr = shared_malloc(bcx, val_ty(vptr), size);\n-    call_memmove(bcx, newptr, vptr, size);\n+\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    Store(bcx, fill, GEPi(bcx, newptr, [0u, abi::vec_elt_alloc]));\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n+    let llvecty = T_vec(ccx, llunitty);\n+    let vecbodyty = unit_ty; // FIXME: This is not the correct type\n+    let {box: newptr, body: new_body_ptr} =\n+        base::malloc_unique_dyn(bcx, vecbodyty, size);\n+    let newptr = PointerCast(bcx, newptr,\n+                             T_unique_ptr(T_unique(bcx.ccx(), llvecty)));\n+    let new_body_ptr = PointerCast(bcx, new_body_ptr, T_ptr(llvecty));\n+    call_memmove(bcx, new_body_ptr, body_ptr, size);\n+\n+    Store(bcx, fill, GEPi(bcx, new_body_ptr, [0u, abi::vec_elt_alloc]));\n     let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n         iter_vec(bcx, newptr, vec_ty, base::take_ty)\n     } else { bcx };\n@@ -133,9 +165,10 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n             {bcx: bcx, val: p, dataptr: vp}\n           }\n           ast::vstore_uniq {\n-            let {bcx, val} = alloc_uniq(bcx, llunitty, args.len());\n+            let {bcx, val} = alloc_uniq(bcx, unit_ty, args.len());\n             add_clean_free(bcx, val, true);\n-            let dataptr = get_dataptr(bcx, val, llunitty);\n+            let body = get_bodyptr(bcx, val, vec_ty);\n+            let dataptr = get_dataptr(bcx, body, llunitty);\n             {bcx: bcx, val: val, dataptr: dataptr}\n           }\n           ast::vstore_box {\n@@ -216,8 +249,9 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n         (base, len)\n       }\n       ty::vstore_uniq {\n-        let base = tvec::get_dataptr(cx, v, llunitty);\n-        let len = tvec::get_fill(cx, v);\n+        let body = tvec::get_bodyptr(cx, v, vec_ty);\n+        let base = tvec::get_dataptr(cx, body, llunitty);\n+        let len = tvec::get_fill(cx, body);\n         (base, len)\n       }\n       ty::vstore_box {\n@@ -249,7 +283,9 @@ fn trans_estr(bcx: block, s: str, vstore: ast::vstore,\n       ast::vstore_uniq {\n         let cs = PointerCast(bcx, C_cstr(ccx, s), T_ptr(T_i8()));\n         let len = C_uint(ccx, str::len(s));\n-        Call(bcx, ccx.upcalls.str_new_uniq, [cs, len])\n+        let c = Call(bcx, ccx.upcalls.str_new_uniq, [cs, len]);\n+        PointerCast(bcx, c,\n+                    T_unique_ptr(T_unique(ccx, T_vec(ccx, T_i8()))))\n       }\n \n       ast::vstore_box {\n@@ -274,19 +310,23 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n \n     let lhs = Load(bcx, lhsptr);\n     let self_append = ICmp(bcx, lib::llvm::IntEQ, lhs, rhs);\n-    let lfill = get_fill(bcx, lhs);\n-    let rfill = get_fill(bcx, rhs);\n+    let lbody = get_bodyptr(bcx, lhs, vec_ty);\n+    let rbody = get_bodyptr(bcx, rhs, vec_ty);\n+    let lfill = get_fill(bcx, lbody);\n+    let rfill = get_fill(bcx, rbody);\n     let mut new_fill = Add(bcx, lfill, rfill);\n     if strings { new_fill = Sub(bcx, new_fill, C_int(ccx, 1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr,\n-                                 T_ptr(T_ptr(ccx.opaque_vec_type)));\n+                                 T_ptr(T_ptr(T_i8())));\n     Call(bcx, ccx.upcalls.vec_grow,\n          [opaque_lhs, new_fill]);\n     // Was overwritten if we resized\n     let lhs = Load(bcx, lhsptr);\n     let rhs = Select(bcx, self_append, lhs, rhs);\n \n-    let lhs_data = get_dataptr(bcx, lhs, llunitty);\n+    let lbody = get_bodyptr(bcx, lhs, vec_ty);\n+\n+    let lhs_data = get_dataptr(bcx, lbody, llunitty);\n     let mut lhs_off = lfill;\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(ccx, 1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n@@ -311,18 +351,18 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n     let scratch = base::alloca(bcx, elt_llty);\n     for vec::each(vals) {|val|\n         bcx = base::trans_expr_save_in(bcx, val, scratch);\n-        let vptr = Load(bcx, vptrptr);\n+        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr), vec_ty);\n         let old_fill = get_fill(bcx, vptr);\n         let new_fill = Add(bcx, old_fill, elt_sz);\n         let do_grow = ICmp(bcx, lib::llvm::IntUGT, new_fill,\n                            get_alloc(bcx, vptr));\n         bcx = base::with_cond(bcx, do_grow) {|bcx|\n             let pt = PointerCast(bcx, vptrptr,\n-                                 T_ptr(T_ptr(ccx.opaque_vec_type)));\n+                                 T_ptr(T_ptr(T_i8())));\n             Call(bcx, ccx.upcalls.vec_grow, [pt, new_fill]);\n             bcx\n         };\n-        let vptr = Load(bcx, vptrptr);\n+        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr), vec_ty);\n         set_fill(bcx, vptr, new_fill);\n         let targetptr = pointer_add(bcx, get_dataptr(bcx, vptr, elt_llty),\n                                     old_fill);\n@@ -336,23 +376,30 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n     let _icx = bcx.insn_ctxt(\"tvec::trans_add\");\n     let ccx = bcx.ccx();\n \n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n+\n     if ty::get(vec_ty).struct == ty::ty_str {\n+        let lhs = PointerCast(bcx, lhs, T_ptr(T_i8()));\n+        let rhs = PointerCast(bcx, rhs, T_ptr(T_i8()));\n         let n = Call(bcx, ccx.upcalls.str_concat, [lhs, rhs]);\n+        let n = PointerCast(\n+            bcx, n, T_unique_ptr(T_unique(ccx, T_vec(ccx, llunitty))));\n         ret base::store_in_dest(bcx, n, dest);\n     }\n \n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n+    let lhs_body = get_bodyptr(bcx, lhs, vec_ty);\n+    let rhs_body = get_bodyptr(bcx, rhs, vec_ty);\n \n-    let lhs_fill = get_fill(bcx, lhs);\n-    let rhs_fill = get_fill(bcx, rhs);\n+    let lhs_fill = get_fill(bcx, lhs_body);\n+    let rhs_fill = get_fill(bcx, rhs_body);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n     let mut {bcx: bcx, val: new_vec_ptr} =\n-        alloc_uniq_raw(bcx, new_fill, new_fill);\n-    new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(ccx, llunitty)));\n+        alloc_uniq_raw(bcx, unit_ty, new_fill, new_fill);\n \n+    let new_vec_body_ptr = get_bodyptr(bcx, new_vec_ptr, vec_ty);\n     let write_ptr_ptr = do_spill_noroot\n-        (bcx, get_dataptr(bcx, new_vec_ptr, llunitty));\n+        (bcx, get_dataptr(bcx, new_vec_body_ptr, llunitty));\n     let copy_fn = fn@(bcx: block, addr: ValueRef,\n                       _ty: ty::t) -> block {\n         let ccx = bcx.ccx();\n@@ -408,16 +455,17 @@ fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(ccx, unit_ty);\n-    let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n-    let data_ptr = get_dataptr(bcx, vptr, llunitty);\n+    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n+    let data_ptr = get_dataptr(bcx, body_ptr, llunitty);\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec\");\n-    let vptr = PointerCast(bcx, vptr, T_ptr(bcx.ccx().opaque_vec_type));\n-    ret iter_vec_uniq(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n+    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n+    let fill = get_fill(bcx, body_ptr);\n+    ret iter_vec_uniq(bcx, vptr, vec_ty, fill, f);\n }\n \n //"}, {"sha": "fedd7c713cff7b9f71c3f11398bdac9da76e9f05", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a1b949071cd573cd171362e9c3b894105556c1/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=09a1b949071cd573cd171362e9c3b894105556c1", "patch": "@@ -85,15 +85,19 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           ty::ty_uint(t) { T_uint_ty(cx, t) }\n           ty::ty_float(t) { T_float_ty(cx, t) }\n           ty::ty_estr(ty::vstore_uniq) |\n-          ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n+          ty::ty_str {\n+            T_unique_ptr(T_unique(cx, T_vec(cx, T_i8())))\n+          }\n           ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n           ty::ty_estr(ty::vstore_box) { T_box_ptr(T_box(cx, T_i8())) }\n           ty::ty_evec(mt, ty::vstore_box) |\n           ty::ty_box(mt) { T_box_ptr(T_box(cx, type_of(cx, mt.ty))) }\n           ty::ty_opaque_box { T_box_ptr(T_box(cx, T_i8())) }\n           ty::ty_uniq(mt) { T_unique_ptr(T_unique(cx, type_of(cx, mt.ty))) }\n           ty::ty_evec(mt, ty::vstore_uniq) |\n-          ty::ty_vec(mt) { T_ptr(T_vec(cx, type_of(cx, mt.ty))) }\n+          ty::ty_vec(mt) {\n+            T_unique_ptr(T_unique(cx, T_vec(cx, type_of(cx, mt.ty))))\n+          }\n           ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n           ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n "}]}