{"sha": "b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwOTZmMDg0NmVhOTQyM2JmNDRkYjBkMmZhODdlZGU2Y2I5YTdjZjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-02T08:33:26Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-05T08:37:13Z"}, "message": "finally this actually looks like a visitor", "tree": {"sha": "1a322404962a802fadc3d5d2a0e6ddcb456fa8da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a322404962a802fadc3d5d2a0e6ddcb456fa8da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1", "html_url": "https://github.com/rust-lang/rust/commit/b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98295e9eb2e9fdc3cf1e9c819865e515a3125bc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4", "html_url": "https://github.com/rust-lang/rust/commit/98295e9eb2e9fdc3cf1e9c819865e515a3125bc4"}], "stats": {"total": 250, "additions": 118, "deletions": 132}, "files": [{"sha": "c303d2a1e67caa226c444f0138631ea1a80b7e42", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 55, "deletions": 65, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::{self, Write};\n+use std::fmt::Write;\n use std::hash::Hash;\n \n use syntax_pos::symbol::Symbol;\n use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n     Scalar, AllocType, EvalResult, EvalErrorKind\n@@ -122,24 +122,17 @@ fn path_format(path: &Vec<PathElem>) -> String {\n     out\n }\n \n-struct ValidityVisitor<'rt, 'a, 'tcx: 'a+'rt, Tag: 'static> {\n-    op: OpTy<'tcx, Tag>,\n+struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a, 'mir, 'tcx>+'rt> {\n     /// The `path` may be pushed to, but the part that is present when a function\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking: Option<&'rt mut RefTracking<'tcx, Tag>>,\n+    ref_tracking: Option<&'rt mut RefTracking<'tcx, M::PointerTag>>,\n     const_mode: bool,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ecx: &'rt mut EvalContext<'a, 'mir, 'tcx, M>,\n }\n \n-impl<Tag: fmt::Debug> fmt::Debug for ValidityVisitor<'_, '_, '_, Tag> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}, {:?}\", *self.op, self.op.layout.ty)\n-    }\n-}\n-\n-impl<'rt, 'a, 'tcx, Tag> ValidityVisitor<'rt, 'a, 'tcx, Tag> {\n+impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, 'mir, 'tcx, M> {\n     fn push_aggregate_field_path_elem(\n         &mut self,\n         layout: TyLayout<'tcx>,\n@@ -148,7 +141,7 @@ impl<'rt, 'a, 'tcx, Tag> ValidityVisitor<'rt, 'a, 'tcx, Tag> {\n         let elem = match layout.ty.sty {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                if let Some(upvar) = self.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n+                if let Some(upvar) = self.ecx.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n                     PathElem::ClosureVar(upvar.debug_name)\n                 } else {\n                     // Sometimes the index is beyond the number of freevars (seen\n@@ -190,41 +183,38 @@ impl<'rt, 'a, 'tcx, Tag> ValidityVisitor<'rt, 'a, 'tcx, Tag> {\n }\n \n impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n-    ValueVisitor<'a, 'mir, 'tcx, M> for ValidityVisitor<'rt, 'a, 'tcx, M::PointerTag>\n+    ValueVisitor<'a, 'mir, 'tcx, M> for ValidityVisitor<'rt, 'a, 'mir, 'tcx, M>\n {\n     type V = OpTy<'tcx, M::PointerTag>;\n \n     #[inline(always)]\n-    fn value(&self) -> &OpTy<'tcx, M::PointerTag> {\n-        &self.op\n+    fn ecx(&mut self) -> &mut EvalContext<'a, 'mir, 'tcx, M> {\n+        &mut self.ecx\n     }\n \n     #[inline]\n     fn visit_field(\n         &mut self,\n-        ectx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n-        val: Self::V,\n+        old_op: OpTy<'tcx, M::PointerTag>,\n         field: usize,\n+        new_op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx> {\n         // Remember the old state\n         let path_len = self.path.len();\n-        let op = self.op;\n         // Perform operation\n-        self.push_aggregate_field_path_elem(op.layout, field);\n-        self.op = val;\n-        self.visit_value(ectx)?;\n+        self.push_aggregate_field_path_elem(old_op.layout, field);\n+        self.visit_value(new_op)?;\n         // Undo changes\n         self.path.truncate(path_len);\n-        self.op = op;\n         Ok(())\n     }\n \n     #[inline]\n-    fn visit_value(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n+    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n     {\n+        trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n         // Translate enum discriminant errors to something nicer.\n-        match self.walk_value(ectx) {\n+        match self.walk_value(op) {\n             Ok(()) => Ok(()),\n             Err(err) => match err.kind {\n                 EvalErrorKind::InvalidDiscriminant(val) =>\n@@ -236,10 +226,10 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         }\n     }\n \n-    fn visit_primitive(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+    fn visit_primitive(&mut self, op: OpTy<'tcx, M::PointerTag>)\n         -> EvalResult<'tcx>\n     {\n-        let value = try_validation!(ectx.read_immediate(self.op),\n+        let value = try_validation!(self.ecx.read_immediate(op),\n             \"uninitialized or unrepresentable data\", self.path);\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n@@ -283,21 +273,21 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     \"undefined address in pointer\", self.path);\n                 let meta = try_validation!(value.to_meta(),\n                     \"uninitialized data in fat pointer metadata\", self.path);\n-                let layout = ectx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n+                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n                 if layout.is_unsized() {\n-                    let tail = ectx.tcx.struct_tail(layout.ty);\n+                    let tail = self.ecx.tcx.struct_tail(layout.ty);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n                             let vtable = try_validation!(meta.unwrap().to_ptr(),\n                                 \"non-pointer vtable in fat pointer\", self.path);\n-                            try_validation!(ectx.read_drop_type_from_vtable(vtable),\n+                            try_validation!(self.ecx.read_drop_type_from_vtable(vtable),\n                                 \"invalid drop fn in vtable\", self.path);\n-                            try_validation!(ectx.read_size_and_align_from_vtable(vtable),\n+                            try_validation!(self.ecx.read_size_and_align_from_vtable(vtable),\n                                 \"invalid size or align in vtable\", self.path);\n                             // FIXME: More checks for the vtable.\n                         }\n                         ty::Slice(..) | ty::Str => {\n-                            try_validation!(meta.unwrap().to_usize(ectx),\n+                            try_validation!(meta.unwrap().to_usize(self.ecx),\n                                 \"non-integer slice length in fat pointer\", self.path);\n                         }\n                         ty::Foreign(..) => {\n@@ -308,12 +298,12 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     }\n                 }\n                 // Make sure this is non-NULL and aligned\n-                let (size, align) = ectx.size_and_align_of(meta, layout)?\n+                let (size, align) = self.ecx.size_and_align_of(meta, layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n                     .unwrap_or_else(|| layout.size_and_align());\n-                match ectx.memory.check_align(ptr, align) {\n+                match self.ecx.memory.check_align(ptr, align) {\n                     Ok(_) => {},\n                     Err(err) => {\n                         error!(\"{:?} is not aligned to {:?}\", ptr, align);\n@@ -334,7 +324,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 // Turn ptr into place.\n                 // `ref_to_mplace` also calls the machine hook for (re)activating the tag,\n                 // which in turn will (in full miri) check if the pointer is dereferencable.\n-                let place = ectx.ref_to_mplace(value)?;\n+                let place = self.ecx.ref_to_mplace(value)?;\n                 // Recursive checking\n                 if let Some(ref mut ref_tracking) = self.ref_tracking {\n                     assert!(self.const_mode, \"We should only do recursie checking in const mode\");\n@@ -343,19 +333,19 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         let ptr = try_validation!(place.ptr.to_ptr(),\n                             \"integer pointer in non-ZST reference\", self.path);\n                         // Skip validation entirely for some external statics\n-                        let alloc_kind = ectx.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                        let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n                         if let Some(AllocType::Static(did)) = alloc_kind {\n                             // `extern static` cannot be validated as they have no body.\n                             // FIXME: Statics from other crates are also skipped.\n                             // They might be checked at a different type, but for now we\n                             // want to avoid recursing too deeply.  This is not sound!\n-                            if !did.is_local() || ectx.tcx.is_foreign_item(did) {\n+                            if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n                                 return Ok(());\n                             }\n                         }\n                         // Maintain the invariant that the place we are checking is\n                         // already verified to be in-bounds.\n-                        try_validation!(ectx.memory.check_bounds(ptr, size, false),\n+                        try_validation!(self.ecx.memory.check_bounds(ptr, size, false),\n                             \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination\n@@ -379,7 +369,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 let value = value.to_scalar_or_undef();\n                 let ptr = try_validation!(value.to_ptr(),\n                     value, self.path, \"a pointer\");\n-                let _fn = try_validation!(ectx.memory.get_fn(ptr),\n+                let _fn = try_validation!(self.ecx.memory.get_fn(ptr),\n                     value, self.path, \"a function pointer\");\n                 // FIXME: Check if the signature matches\n             }\n@@ -389,21 +379,23 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         Ok(())\n     }\n \n-    fn visit_uninhabited(&mut self, _ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+    fn visit_uninhabited(&mut self, _op: OpTy<'tcx, M::PointerTag>)\n         -> EvalResult<'tcx>\n     {\n         validation_failure!(\"a value of an uninhabited type\", self.path)\n     }\n \n-    fn visit_scalar(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, layout: &layout::Scalar)\n-        -> EvalResult<'tcx>\n-    {\n-        let value = try_validation!(ectx.read_scalar(self.op),\n+    fn visit_scalar(\n+        &mut self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        layout: &layout::Scalar,\n+    ) -> EvalResult<'tcx> {\n+        let value = try_validation!(self.ecx.read_scalar(op),\n             \"uninitialized or unrepresentable data\", self.path);\n         // Determine the allowed range\n         let (lo, hi) = layout.valid_range.clone().into_inner();\n         // `max_hi` is as big as the size fits\n-        let max_hi = u128::max_value() >> (128 - self.op.layout.size.bits());\n+        let max_hi = u128::max_value() >> (128 - op.layout.size.bits());\n         assert!(hi <= max_hi);\n         // We could also write `(hi + 1) % (max_hi + 1) == lo` but `max_hi + 1` overflows for `u128`\n         if (lo == 0 && hi == max_hi) || (hi + 1 == lo) {\n@@ -421,10 +413,10 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     // We can call `check_align` to check non-NULL-ness, but have to also look\n                     // for function pointers.\n                     let non_null =\n-                        ectx.memory.check_align(\n+                        self.ecx.memory.check_align(\n                             Scalar::Ptr(ptr), Align::from_bytes(1, 1).unwrap()\n                         ).is_ok() ||\n-                        ectx.memory.get_fn(ptr).is_ok();\n+                        self.ecx.memory.get_fn(ptr).is_ok();\n                     if !non_null {\n                         // could be NULL\n                         return validation_failure!(\"a potentially NULL pointer\", self.path);\n@@ -444,7 +436,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 }\n             }\n             Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, self.op.layout.size.bytes());\n+                assert_eq!(size as u64, op.layout.size.bytes());\n                 bits\n             }\n         };\n@@ -479,13 +471,12 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         }\n     }\n \n-    fn visit_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n+    fn visit_array(&mut self, op: OpTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n     {\n-        match self.op.layout.ty.sty {\n+        match op.layout.ty.sty {\n             ty::Str => {\n-                let mplace = self.op.to_mem_place(); // strings are never immediate\n-                try_validation!(ectx.read_str(mplace),\n+                let mplace = op.to_mem_place(); // strings are never immediate\n+                try_validation!(self.ecx.read_str(mplace),\n                     \"uninitialized or non-UTF-8 data in str\", self.path);\n             }\n             ty::Array(tys, ..) | ty::Slice(tys) if {\n@@ -496,17 +487,17 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     _ => false,\n                 }\n             } => {\n-                let mplace = if self.op.layout.is_zst() {\n+                let mplace = if op.layout.is_zst() {\n                     // it's a ZST, the memory content cannot matter\n-                    MPlaceTy::dangling(self.op.layout, ectx)\n+                    MPlaceTy::dangling(op.layout, self.ecx)\n                 } else {\n                     // non-ZST array/slice/str cannot be immediate\n-                    self.op.to_mem_place()\n+                    op.to_mem_place()\n                 };\n                 // This is the length of the array/slice.\n-                let len = mplace.len(ectx)?;\n+                let len = mplace.len(self.ecx)?;\n                 // This is the element type size.\n-                let ty_size = ectx.layout_of(tys)?.size;\n+                let ty_size = self.ecx.layout_of(tys)?.size;\n                 // This is the size in bytes of the whole array.\n                 let size = ty_size * len;\n \n@@ -519,7 +510,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept undef, for consistency with the type-based checks.\n-                match ectx.memory.check_bytes(\n+                match self.ecx.memory.check_bytes(\n                     mplace.ptr,\n                     size,\n                     /*allow_ptr_and_undef*/!self.const_mode,\n@@ -548,7 +539,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 }\n             }\n             _ => {\n-                self.walk_array(ectx)? // default handler\n+                self.walk_array(op)? // default handler\n             }\n         }\n         Ok(())\n@@ -574,14 +565,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n         // Construct a visitor\n         let mut visitor = ValidityVisitor {\n-            op,\n             path,\n             ref_tracking,\n             const_mode,\n-            tcx: *self.tcx,\n+            ecx: self,\n         };\n \n         // Run it\n-        visitor.visit_value(self)\n+        visitor.visit_value(op)\n     }\n }"}, {"sha": "f50ef96775f9d55108c758a9dbc2e85e2dbdf4ce", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 63, "deletions": 67, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=b096f0846ea9423bf44db0d2fa87ede6cb9a7cf1", "patch": "@@ -1,8 +1,6 @@\n //! Visitor for a run-time value with a given layout: Traverse enums, structs and other compound\n //! types until we arrive at the leaves, with custom handling for primitive types.\n \n-use std::fmt;\n-\n use rustc::ty::layout::{self, TyLayout};\n use rustc::ty;\n use rustc::mir::interpret::{\n@@ -166,103 +164,103 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n }\n \n // How to traverse a value and what to do when we are at the leaves.\n-pub trait ValueVisitor<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: fmt::Debug + Sized {\n+pub trait ValueVisitor<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Sized {\n     type V: Value<'a, 'mir, 'tcx, M>;\n \n-    // There's a value in here.\n-    fn value(&self) -> &Self::V;\n+    // The visitor must have an `EvalContext` in it.\n+    fn ecx(&mut self) -> &mut EvalContext<'a, 'mir, 'tcx, M>;\n \n-    // The value's layout (not meant to be overwritten).\n+    // Recursie actions, ready to be overloaded.\n+    /// Visit the given value, dispatching as appropriate to more speicalized visitors.\n     #[inline(always)]\n-    fn layout(&self) -> TyLayout<'tcx> {\n-        self.value().layout()\n+    fn visit_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n+    {\n+        self.walk_value(v)\n     }\n-\n-    // Recursie actions, ready to be overloaded.\n-    /// Visit the current value, dispatching as appropriate to more speicalized visitors.\n-    #[inline]\n-    fn visit_value(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n+    /// Visit the given value as a union.\n+    #[inline(always)]\n+    fn visit_union(&mut self, _v: Self::V) -> EvalResult<'tcx>\n     {\n-        self.walk_value(ectx)\n+        Ok(())\n     }\n-    /// Visit the current value as an array.\n-    #[inline]\n-    fn visit_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n+    /// Visit the given value as an array.\n+    #[inline(always)]\n+    fn visit_array(&mut self, v: Self::V) -> EvalResult<'tcx>\n     {\n-        self.walk_array(ectx)\n+        self.walk_array(v)\n     }\n-    /// Called each time we recurse down to a field of the value, to (a) let\n-    /// the visitor change its internal state (recording the new current value),\n-    /// and (b) let the visitor track the \"stack\" of fields that we descended below.\n+    /// Called each time we recurse down to a field, passing in old and new value.\n+    /// This gives the visitor the chance to track the stack of nested fields that\n+    /// we are descending through.\n+    #[inline(always)]\n     fn visit_field(\n         &mut self,\n-        ectx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n-        val: Self::V,\n-        field: usize,\n-    ) -> EvalResult<'tcx>;\n+        _old_val: Self::V,\n+        _field: usize,\n+        new_val: Self::V,\n+    ) -> EvalResult<'tcx> {\n+        self.visit_value(new_val)\n+    }\n \n     // Actions on the leaves, ready to be overloaded.\n-    #[inline]\n-    fn visit_uninhabited(&mut self, _ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n+    /// Called whenever we reach a value with uninhabited layout.\n+    /// Recursing to fields will continue after this!\n+    #[inline(always)]\n+    fn visit_uninhabited(&mut self, _v: Self::V) -> EvalResult<'tcx>\n     { Ok(()) }\n-    #[inline]\n-    fn visit_scalar(&mut self, _ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, _layout: &layout::Scalar)\n-        -> EvalResult<'tcx>\n+    /// Called whenever we reach a value with scalar layout.\n+    /// Recursing to fields will continue after this!\n+    #[inline(always)]\n+    fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> EvalResult<'tcx>\n     { Ok(()) }\n-    #[inline]\n-    fn visit_primitive(&mut self, _ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n+    /// Called whenever we reach a value of primitive type.  There can be no recursion\n+    /// below such a value.\n+    #[inline(always)]\n+    fn visit_primitive(&mut self, _v: Self::V) -> EvalResult<'tcx>\n     { Ok(()) }\n \n     // Default recursors. Not meant to be overloaded.\n-    fn walk_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n+    fn walk_array(&mut self, v: Self::V) -> EvalResult<'tcx>\n     {\n         // Let's get an mplace first.\n-        let mplace = if self.layout().is_zst() {\n+        let mplace = if v.layout().is_zst() {\n             // it's a ZST, the memory content cannot matter\n-            MPlaceTy::dangling(self.layout(), ectx)\n+            MPlaceTy::dangling(v.layout(), self.ecx())\n         } else {\n             // non-ZST array/slice/str cannot be immediate\n-            self.value().to_mem_place(ectx)?\n+            v.to_mem_place(self.ecx())?\n         };\n         // Now iterate over it.\n-        for (i, field) in ectx.mplace_array_fields(mplace)?.enumerate() {\n-            self.visit_field(ectx, Value::from_mem_place(field?), i)?;\n+        for (i, field) in self.ecx().mplace_array_fields(mplace)?.enumerate() {\n+            self.visit_field(v, i, Value::from_mem_place(field?))?;\n         }\n         Ok(())\n     }\n-    fn walk_value(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n+    fn walk_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n     {\n-        trace!(\"walk_value: {:?}\", self);\n-\n         // If this is a multi-variant layout, we have find the right one and proceed with that.\n         // (No benefit from making this recursion, but it is equivalent to that.)\n-        match self.layout().variants {\n+        match v.layout().variants {\n             layout::Variants::NicheFilling { .. } |\n             layout::Variants::Tagged { .. } => {\n-                let (inner, idx) = self.value().project_downcast(ectx)?;\n+                let (inner, idx) = v.project_downcast(self.ecx())?;\n                 trace!(\"variant layout: {:#?}\", inner.layout());\n                 // recurse with the inner type\n-                return self.visit_field(ectx, inner, idx);\n+                return self.visit_field(v, idx, inner);\n             }\n             layout::Variants::Single { .. } => {}\n         }\n \n         // Even for single variants, we might be able to get a more refined type:\n         // If it is a trait object, switch to the actual type that was used to create it.\n-        match self.layout().ty.sty {\n+        match v.layout().ty.sty {\n             ty::Dynamic(..) => {\n                 // immediate trait objects are not a thing\n-                let dest = self.value().to_mem_place(ectx)?;\n-                let inner = ectx.unpack_dyn_trait(dest)?.1;\n+                let dest = v.to_mem_place(self.ecx())?;\n+                let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n                 trace!(\"dyn object layout: {:#?}\", inner.layout);\n                 // recurse with the inner type\n-                return self.visit_field(ectx, Value::from_mem_place(inner), 0);\n+                return self.visit_field(v, 0, Value::from_mem_place(inner));\n             },\n             _ => {},\n         };\n@@ -274,12 +272,12 @@ pub trait ValueVisitor<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: fmt::Debug +\n         // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n         // scalars, we do the same check on every \"level\" (e.g. first we check\n         // MyNewtype and then the scalar in there).\n-        match self.layout().abi {\n+        match v.layout().abi {\n             layout::Abi::Uninhabited => {\n-                self.visit_uninhabited(ectx)?;\n+                self.visit_uninhabited(v)?;\n             }\n             layout::Abi::Scalar(ref layout) => {\n-                self.visit_scalar(ectx, layout)?;\n+                self.visit_scalar(v, layout)?;\n             }\n             // FIXME: Should we do something for ScalarPair? Vector?\n             _ => {}\n@@ -290,34 +288,32 @@ pub trait ValueVisitor<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: fmt::Debug +\n         // so we check them separately and before aggregate handling.\n         // It is CRITICAL that we get this check right, or we might be\n         // validating the wrong thing!\n-        let primitive = match self.layout().fields {\n+        let primitive = match v.layout().fields {\n             // Primitives appear as Union with 0 fields -- except for Boxes and fat pointers.\n             layout::FieldPlacement::Union(0) => true,\n-            _ => self.layout().ty.builtin_deref(true).is_some(),\n+            _ => v.layout().ty.builtin_deref(true).is_some(),\n         };\n         if primitive {\n-            return self.visit_primitive(ectx);\n+            return self.visit_primitive(v);\n         }\n \n         // Proceed into the fields.\n-        match self.layout().fields {\n+        match v.layout().fields {\n             layout::FieldPlacement::Union(fields) => {\n                 // Empty unions are not accepted by rustc. That's great, it means we can\n                 // use that as an unambiguous signal for detecting primitives.  Make sure\n                 // we did not miss any primitive.\n                 debug_assert!(fields > 0);\n-                // We can't traverse unions, their bits are allowed to be anything.\n-                // The fields don't need to correspond to any bit pattern of the union's fields.\n-                // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n+                self.visit_union(v)?;\n             },\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n                 for i in 0..offsets.len() {\n-                    let val = self.value().project_field(ectx, i as u64)?;\n-                    self.visit_field(ectx, val, i)?;\n+                    let val = v.project_field(self.ecx(), i as u64)?;\n+                    self.visit_field(v, i, val)?;\n                 }\n             },\n             layout::FieldPlacement::Array { .. } => {\n-                self.visit_array(ectx)?;\n+                self.visit_array(v)?;\n             }\n         }\n         Ok(())"}]}