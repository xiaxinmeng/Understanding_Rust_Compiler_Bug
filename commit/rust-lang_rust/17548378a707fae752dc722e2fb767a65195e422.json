{"sha": "17548378a707fae752dc722e2fb767a65195e422", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NTQ4Mzc4YTcwN2ZhZTc1MmRjNzIyZTJmYjc2N2E2NTE5NWU0MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-02T13:36:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-02T13:36:30Z"}, "message": "auto merge of #9679 : pnkfelix/rust/de-pub-resolve-code, r=huonw\n\nr? anyone\r\n\r\nFor context (and the archaeological dig that @huonw did to see how this arose), see:\r\n  https://botbot.me/mozilla/rust-internals/msg/6547222/", "tree": {"sha": "91bc31ee685b775a456519e59fcb870810e7e613", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91bc31ee685b775a456519e59fcb870810e7e613"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17548378a707fae752dc722e2fb767a65195e422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17548378a707fae752dc722e2fb767a65195e422", "html_url": "https://github.com/rust-lang/rust/commit/17548378a707fae752dc722e2fb767a65195e422", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17548378a707fae752dc722e2fb767a65195e422/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d616603c8496a96ba5a9a9ed7a21f02b79d5757d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d616603c8496a96ba5a9a9ed7a21f02b79d5757d", "html_url": "https://github.com/rust-lang/rust/commit/d616603c8496a96ba5a9a9ed7a21f02b79d5757d"}, {"sha": "55da145ab17d1c6ca5ae7d1c87cbaacf456fb8e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/55da145ab17d1c6ca5ae7d1c87cbaacf456fb8e2", "html_url": "https://github.com/rust-lang/rust/commit/55da145ab17d1c6ca5ae7d1c87cbaacf456fb8e2"}], "stats": {"total": 285, "additions": 142, "deletions": 143}, "files": [{"sha": "646c80a0a76e4407366b1e45a2dab1278258367b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 142, "deletions": 143, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/17548378a707fae752dc722e2fb767a65195e422/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17548378a707fae752dc722e2fb767a65195e422/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=17548378a707fae752dc722e2fb767a65195e422", "patch": "@@ -44,13 +44,13 @@ use std::util;\n // Definition mapping\n pub type DefMap = @mut HashMap<NodeId,Def>;\n \n-pub struct binding_info {\n+struct binding_info {\n     span: Span,\n     binding_mode: BindingMode,\n }\n \n // Map from the name in a pattern to its binding mode.\n-pub type BindingMap = HashMap<Name,binding_info>;\n+type BindingMap = HashMap<Name,binding_info>;\n \n // Trait method resolution\n pub type TraitMap = HashMap<NodeId,@mut ~[DefId]>;\n@@ -72,20 +72,20 @@ pub struct Export2 {\n }\n \n #[deriving(Eq)]\n-pub enum PatternBindingMode {\n+enum PatternBindingMode {\n     RefutableMode,\n     LocalIrrefutableMode,\n     ArgumentIrrefutableMode,\n }\n \n #[deriving(Eq)]\n-pub enum Namespace {\n+enum Namespace {\n     TypeNS,\n     ValueNS\n }\n \n #[deriving(Eq)]\n-pub enum NamespaceError {\n+enum NamespaceError {\n     NoError,\n     ModuleError,\n     TypeError,\n@@ -95,7 +95,7 @@ pub enum NamespaceError {\n /// A NamespaceResult represents the result of resolving an import in\n /// a particular namespace. The result is either definitely-resolved,\n /// definitely- unresolved, or unknown.\n-pub enum NamespaceResult {\n+enum NamespaceResult {\n     /// Means that resolve hasn't gathered enough information yet to determine\n     /// whether the name is bound in this namespace. (That is, it hasn't\n     /// resolved all `use` directives yet.)\n@@ -109,27 +109,27 @@ pub enum NamespaceResult {\n }\n \n impl NamespaceResult {\n-    pub fn is_unknown(&self) -> bool {\n+    fn is_unknown(&self) -> bool {\n         match *self {\n             UnknownResult => true,\n             _ => false\n         }\n     }\n }\n \n-pub enum NameDefinition {\n+enum NameDefinition {\n     NoNameDefinition,           //< The name was unbound.\n     ChildNameDefinition(Def),   //< The name identifies an immediate child.\n     ImportNameDefinition(Def)   //< The name identifies an import.\n }\n \n #[deriving(Eq)]\n-pub enum Mutability {\n+enum Mutability {\n     Mutable,\n     Immutable\n }\n \n-pub enum SelfBinding {\n+enum SelfBinding {\n     NoSelfBinding,\n     HasSelfBinding(NodeId)\n }\n@@ -156,33 +156,33 @@ impl Visitor<()> for Resolver {\n }\n \n /// Contains data for specific types of import directives.\n-pub enum ImportDirectiveSubclass {\n+enum ImportDirectiveSubclass {\n     SingleImport(Ident /* target */, Ident /* source */),\n     GlobImport\n }\n \n /// The context that we thread through while building the reduced graph.\n #[deriving(Clone)]\n-pub enum ReducedGraphParent {\n+enum ReducedGraphParent {\n     ModuleReducedGraphParent(@mut Module)\n }\n \n-pub enum ResolveResult<T> {\n+enum ResolveResult<T> {\n     Failed,         // Failed to resolve the name.\n     Indeterminate,  // Couldn't determine due to unresolved globs.\n     Success(T)      // Successfully resolved the import.\n }\n \n impl<T> ResolveResult<T> {\n-    pub fn failed(&self) -> bool {\n+    fn failed(&self) -> bool {\n         match *self { Failed => true, _ => false }\n     }\n-    pub fn indeterminate(&self) -> bool {\n+    fn indeterminate(&self) -> bool {\n         match *self { Indeterminate => true, _ => false }\n     }\n }\n \n-pub enum TypeParameters<'self> {\n+enum TypeParameters<'self> {\n     NoTypeParameters,                   //< No type parameters.\n     HasTypeParameters(&'self Generics,  //< Type parameters.\n                       NodeId,          //< ID of the enclosing item\n@@ -207,7 +207,7 @@ pub enum TypeParameters<'self> {\n // The rib kind controls the translation of argument or local definitions\n // (`def_arg` or `def_local`) to upvars (`def_upvar`).\n \n-pub enum RibKind {\n+enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n \n@@ -230,7 +230,7 @@ pub enum RibKind {\n }\n \n // Methods can be required or provided. Required methods only occur in traits.\n-pub enum MethodSort {\n+enum MethodSort {\n     Required,\n     Provided(NodeId)\n }\n@@ -243,28 +243,28 @@ pub enum MethodSort {\n // place. It might be better to introduce an expr_xray_path instead.\n \n #[deriving(Eq)]\n-pub enum XrayFlag {\n+enum XrayFlag {\n     NoXray,     //< Private items cannot be accessed.\n     Xray        //< Private items can be accessed.\n }\n \n-pub enum UseLexicalScopeFlag {\n+enum UseLexicalScopeFlag {\n     DontUseLexicalScope,\n     UseLexicalScope\n }\n \n-pub enum SearchThroughModulesFlag {\n+enum SearchThroughModulesFlag {\n     DontSearchThroughModules,\n     SearchThroughModules\n }\n \n-pub enum ModulePrefixResult {\n+enum ModulePrefixResult {\n     NoPrefixFound,\n     PrefixFound(@mut Module, uint)\n }\n \n #[deriving(Eq)]\n-pub enum AllowCapturingSelfFlag {\n+enum AllowCapturingSelfFlag {\n     AllowCapturingSelf,         //< The \"self\" definition can be captured.\n     DontAllowCapturingSelf,     //< The \"self\" definition cannot be captured.\n }\n@@ -287,7 +287,7 @@ enum NameSearchType {\n     PathPublicOnlySearch,\n }\n \n-pub enum BareIdentifierPatternResolution {\n+enum BareIdentifierPatternResolution {\n     FoundStructOrEnumVariant(Def),\n     FoundConst(Def),\n     BareIdentifierPatternUnresolved\n@@ -296,7 +296,7 @@ pub enum BareIdentifierPatternResolution {\n // Specifies how duplicates should be handled when adding a child item if\n // another item exists with the same name in some namespace.\n #[deriving(Eq)]\n-pub enum DuplicateCheckingMode {\n+enum DuplicateCheckingMode {\n     ForbidDuplicateModules,\n     ForbidDuplicateTypes,\n     ForbidDuplicateValues,\n@@ -305,14 +305,14 @@ pub enum DuplicateCheckingMode {\n }\n \n /// One local scope.\n-pub struct Rib {\n+struct Rib {\n     bindings: @mut HashMap<Name, DefLike>,\n     self_binding: @mut Option<DefLike>,\n     kind: RibKind,\n }\n \n impl Rib {\n-    pub fn new(kind: RibKind) -> Rib {\n+    fn new(kind: RibKind) -> Rib {\n         Rib {\n             bindings: @mut HashMap::new(),\n             self_binding: @mut None,\n@@ -322,7 +322,7 @@ impl Rib {\n }\n \n /// One import directive.\n-pub struct ImportDirective {\n+struct ImportDirective {\n     privacy: Privacy,\n     module_path: ~[Ident],\n     subclass: @ImportDirectiveSubclass,\n@@ -331,7 +331,7 @@ pub struct ImportDirective {\n }\n \n impl ImportDirective {\n-    pub fn new(privacy: Privacy,\n+    fn new(privacy: Privacy,\n                module_path: ~[Ident],\n                subclass: @ImportDirectiveSubclass,\n                span: Span,\n@@ -348,13 +348,13 @@ impl ImportDirective {\n }\n \n /// The item that an import resolves to.\n-pub struct Target {\n+struct Target {\n     target_module: @mut Module,\n     bindings: @mut NameBindings,\n }\n \n impl Target {\n-    pub fn new(target_module: @mut Module,\n+    fn new(target_module: @mut Module,\n                bindings: @mut NameBindings)\n                -> Target {\n         Target {\n@@ -365,7 +365,7 @@ impl Target {\n }\n \n /// An ImportResolution represents a particular `use` directive.\n-pub struct ImportResolution {\n+struct ImportResolution {\n     /// The privacy of this `use` directive (whether it's `use` or\n     /// `pub use`.\n     privacy: Privacy,\n@@ -389,7 +389,7 @@ pub struct ImportResolution {\n }\n \n impl ImportResolution {\n-    pub fn new(privacy: Privacy,\n+    fn new(privacy: Privacy,\n                id: NodeId) -> ImportResolution {\n         ImportResolution {\n             privacy: privacy,\n@@ -401,7 +401,7 @@ impl ImportResolution {\n         }\n     }\n \n-    pub fn target_for_namespace(&self, namespace: Namespace)\n+    fn target_for_namespace(&self, namespace: Namespace)\n                                 -> Option<Target> {\n         match namespace {\n             TypeNS      => return self.type_target,\n@@ -418,15 +418,15 @@ impl ImportResolution {\n }\n \n /// The link from a module up to its nearest parent node.\n-pub enum ParentLink {\n+enum ParentLink {\n     NoParentLink,\n     ModuleParentLink(@mut Module, Ident),\n     BlockParentLink(@mut Module, NodeId)\n }\n \n /// The type of module this is.\n #[deriving(Eq)]\n-pub enum ModuleKind {\n+enum ModuleKind {\n     NormalModuleKind,\n     ExternModuleKind,\n     TraitModuleKind,\n@@ -435,7 +435,7 @@ pub enum ModuleKind {\n }\n \n /// One node in the tree of modules.\n-pub struct Module {\n+struct Module {\n     parent_link: ParentLink,\n     def_id: Option<DefId>,\n     kind: ModuleKind,\n@@ -479,7 +479,7 @@ pub struct Module {\n }\n \n impl Module {\n-    pub fn new(parent_link: ParentLink,\n+    fn new(parent_link: ParentLink,\n                 def_id: Option<DefId>,\n                 kind: ModuleKind,\n                 external: bool)\n@@ -499,30 +499,30 @@ impl Module {\n         }\n     }\n \n-    pub fn all_imports_resolved(&self) -> bool {\n+    fn all_imports_resolved(&self) -> bool {\n         let imports = &mut *self.imports;\n         return imports.len() == self.resolved_import_count;\n     }\n }\n \n // Records a possibly-private type definition.\n-pub struct TypeNsDef {\n+struct TypeNsDef {\n     privacy: Privacy,\n     module_def: Option<@mut Module>,\n     type_def: Option<Def>,\n     type_span: Option<Span>\n }\n \n // Records a possibly-private value definition.\n-pub struct ValueNsDef {\n+struct ValueNsDef {\n     privacy: Privacy,\n     def: Def,\n     value_span: Option<Span>,\n }\n \n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n-pub struct NameBindings {\n+struct NameBindings {\n     type_def: Option<TypeNsDef>,    //< Meaning in type namespace.\n     value_def: Option<ValueNsDef>,  //< Meaning in value namespace.\n }\n@@ -536,7 +536,7 @@ enum TraitReferenceType {\n \n impl NameBindings {\n     /// Creates a new module in this set of name bindings.\n-    pub fn define_module(&mut self,\n+    fn define_module(&mut self,\n                          privacy: Privacy,\n                          parent_link: ParentLink,\n                          def_id: Option<DefId>,\n@@ -566,7 +566,7 @@ impl NameBindings {\n     }\n \n     /// Sets the kind of the module, creating a new one if necessary.\n-    pub fn set_module_kind(&mut self,\n+    fn set_module_kind(&mut self,\n                            privacy: Privacy,\n                            parent_link: ParentLink,\n                            def_id: Option<DefId>,\n@@ -604,7 +604,7 @@ impl NameBindings {\n     }\n \n     /// Records a type definition.\n-    pub fn define_type(&mut self, privacy: Privacy, def: Def, sp: Span) {\n+    fn define_type(&mut self, privacy: Privacy, def: Def, sp: Span) {\n         // Merges the type with the existing type def or creates a new one.\n         match self.type_def {\n             None => {\n@@ -627,12 +627,12 @@ impl NameBindings {\n     }\n \n     /// Records a value definition.\n-    pub fn define_value(&mut self, privacy: Privacy, def: Def, sp: Span) {\n+    fn define_value(&mut self, privacy: Privacy, def: Def, sp: Span) {\n         self.value_def = Some(ValueNsDef { privacy: privacy, def: def, value_span: Some(sp) });\n     }\n \n     /// Returns the module node if applicable.\n-    pub fn get_module_if_available(&self) -> Option<@mut Module> {\n+    fn get_module_if_available(&self) -> Option<@mut Module> {\n         match self.type_def {\n             Some(ref type_def) => (*type_def).module_def,\n             None => None\n@@ -643,7 +643,7 @@ impl NameBindings {\n      * Returns the module node. Fails if this node does not have a module\n      * definition.\n      */\n-    pub fn get_module(&mut self) -> @mut Module {\n+    fn get_module(&mut self) -> @mut Module {\n         match self.get_module_if_available() {\n             None => {\n                 fail2!(\"get_module called on a node with no module \\\n@@ -653,14 +653,14 @@ impl NameBindings {\n         }\n     }\n \n-    pub fn defined_in_namespace(&self, namespace: Namespace) -> bool {\n+    fn defined_in_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n             TypeNS   => return self.type_def.is_some(),\n             ValueNS  => return self.value_def.is_some()\n         }\n     }\n \n-    pub fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n+    fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n             TypeNS => match self.type_def {\n                 Some(def) => def.privacy != Private,\n@@ -673,7 +673,7 @@ impl NameBindings {\n         }\n     }\n \n-    pub fn def_for_namespace(&self, namespace: Namespace) -> Option<Def> {\n+    fn def_for_namespace(&self, namespace: Namespace) -> Option<Def> {\n         match namespace {\n             TypeNS => {\n                 match self.type_def {\n@@ -705,7 +705,7 @@ impl NameBindings {\n         }\n     }\n \n-    pub fn privacy_for_namespace(&self, namespace: Namespace)\n+    fn privacy_for_namespace(&self, namespace: Namespace)\n                                  -> Option<Privacy> {\n         match namespace {\n             TypeNS => {\n@@ -723,7 +723,7 @@ impl NameBindings {\n         }\n     }\n \n-    pub fn span_for_namespace(&self, namespace: Namespace) -> Option<Span> {\n+    fn span_for_namespace(&self, namespace: Namespace) -> Option<Span> {\n         if self.defined_in_namespace(namespace) {\n             match namespace {\n                 TypeNS  => {\n@@ -745,27 +745,27 @@ impl NameBindings {\n     }\n }\n \n-pub fn NameBindings() -> NameBindings {\n+fn NameBindings() -> NameBindings {\n     NameBindings {\n         type_def: None,\n         value_def: None\n     }\n }\n \n /// Interns the names of the primitive types.\n-pub struct PrimitiveTypeTable {\n+struct PrimitiveTypeTable {\n     primitive_types: HashMap<Name,prim_ty>,\n }\n \n impl PrimitiveTypeTable {\n-    pub fn intern(&mut self,\n+    fn intern(&mut self,\n                   string: &str,\n                   primitive_type: prim_ty) {\n         self.primitive_types.insert(token::intern(string), primitive_type);\n     }\n }\n \n-pub fn PrimitiveTypeTable() -> PrimitiveTypeTable {\n+fn PrimitiveTypeTable() -> PrimitiveTypeTable {\n     let mut table = PrimitiveTypeTable {\n         primitive_types: HashMap::new()\n     };\n@@ -790,7 +790,7 @@ pub fn PrimitiveTypeTable() -> PrimitiveTypeTable {\n }\n \n \n-pub fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n+fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n     match ns {\n         NoError     => \"\",\n         ModuleError => \"module\",\n@@ -799,7 +799,7 @@ pub fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n     }\n }\n \n-pub fn Resolver(session: Session,\n+fn Resolver(session: Session,\n                 lang_items: LanguageItems,\n                 crate_span: Span) -> Resolver {\n     let graph_root = @mut NameBindings();\n@@ -855,7 +855,7 @@ pub fn Resolver(session: Session,\n }\n \n /// The main resolver class.\n-pub struct Resolver {\n+struct Resolver {\n     session: @Session,\n     lang_items: LanguageItems,\n \n@@ -954,7 +954,7 @@ impl<'self> Visitor<()> for UnusedImportCheckVisitor<'self> {\n \n impl Resolver {\n     /// The main name resolution procedure.\n-    pub fn resolve(&mut self, crate: &ast::Crate) {\n+    fn resolve(&mut self, crate: &ast::Crate) {\n         self.build_reduced_graph(crate);\n         self.session.abort_if_errors();\n \n@@ -978,7 +978,7 @@ impl Resolver {\n     //\n \n     /// Constructs the reduced graph for the entire crate.\n-    pub fn build_reduced_graph(&mut self, crate: &ast::Crate) {\n+    fn build_reduced_graph(&mut self, crate: &ast::Crate) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n \n@@ -987,7 +987,7 @@ impl Resolver {\n     }\n \n     /// Returns the current module tracked by the reduced graph parent.\n-    pub fn get_module_from_parent(&mut self,\n+    fn get_module_from_parent(&mut self,\n                                   reduced_graph_parent: ReducedGraphParent)\n                                   -> @mut Module {\n         match reduced_graph_parent {\n@@ -1007,7 +1007,7 @@ impl Resolver {\n      * If this node does not have a module definition and we are not inside\n      * a block, fails.\n      */\n-    pub fn add_child(&mut self,\n+    fn add_child(&mut self,\n                      name: Ident,\n                      reduced_graph_parent: ReducedGraphParent,\n                      duplicate_checking_mode: DuplicateCheckingMode,\n@@ -1113,7 +1113,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n+    fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If the block has view items, we need an anonymous module.\n         if block.view_items.len() > 0 {\n             return true;\n@@ -1144,7 +1144,7 @@ impl Resolver {\n         return false;\n     }\n \n-    pub fn get_parent_link(&mut self, parent: ReducedGraphParent, name: Ident)\n+    fn get_parent_link(&mut self, parent: ReducedGraphParent, name: Ident)\n                            -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n@@ -1154,7 +1154,7 @@ impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    pub fn build_reduced_graph_for_item(&mut self,\n+    fn build_reduced_graph_for_item(&mut self,\n                                         item: @item,\n                                         parent: ReducedGraphParent)\n                                             -> ReducedGraphParent\n@@ -1442,7 +1442,7 @@ impl Resolver {\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n     // type and/or value namespaces.\n-    pub fn build_reduced_graph_for_variant(&mut self,\n+    fn build_reduced_graph_for_variant(&mut self,\n                                            variant: &variant,\n                                            item_id: DefId,\n                                            parent_privacy: Privacy,\n@@ -1479,7 +1479,7 @@ impl Resolver {\n \n     /// Constructs the reduced graph for one 'view item'. View items consist\n     /// of imports and use directives.\n-    pub fn build_reduced_graph_for_view_item(&mut self,\n+    fn build_reduced_graph_for_view_item(&mut self,\n                                              view_item: &view_item,\n                                              parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(view_item.vis);\n@@ -1580,7 +1580,7 @@ impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    pub fn build_reduced_graph_for_foreign_item(&mut self,\n+    fn build_reduced_graph_for_foreign_item(&mut self,\n                                                 foreign_item: @foreign_item,\n                                                 parent: ReducedGraphParent,\n                                                 f: &fn(&mut Resolver,\n@@ -1611,7 +1611,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn build_reduced_graph_for_block(&mut self,\n+    fn build_reduced_graph_for_block(&mut self,\n                                          block: &Block,\n                                          parent: ReducedGraphParent)\n                                             -> ReducedGraphParent\n@@ -1942,7 +1942,7 @@ impl Resolver {\n \n     /// Builds the reduced graph rooted at the 'use' directive for an external\n     /// crate.\n-    pub fn build_reduced_graph_for_external_crate(&mut self,\n+    fn build_reduced_graph_for_external_crate(&mut self,\n                                                   root: @mut Module) {\n         do csearch::each_top_level_item_of_crate(self.session.cstore,\n                                                  root.def_id.unwrap().crate)\n@@ -1955,7 +1955,7 @@ impl Resolver {\n     }\n \n     /// Creates and adds an import directive to the given module.\n-    pub fn build_import_directive(&mut self,\n+    fn build_import_directive(&mut self,\n                                   privacy: Privacy,\n                                   module_: @mut Module,\n                                   module_path: ~[Ident],\n@@ -2017,7 +2017,7 @@ impl Resolver {\n \n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n-    pub fn resolve_imports(&mut self) {\n+    fn resolve_imports(&mut self) {\n         let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n         loop {\n@@ -2044,7 +2044,7 @@ impl Resolver {\n \n     /// Attempts to resolve imports for the given module and all of its\n     /// submodules.\n-    pub fn resolve_imports_for_module_subtree(&mut self,\n+    fn resolve_imports_for_module_subtree(&mut self,\n                                               module_: @mut Module) {\n         debug2!(\"(resolving imports for module subtree) resolving {}\",\n                self.module_to_str(module_));\n@@ -2068,7 +2068,7 @@ impl Resolver {\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    pub fn resolve_imports_for_module(&mut self, module: @mut Module) {\n+    fn resolve_imports_for_module(&mut self, module: @mut Module) {\n         if module.all_imports_resolved() {\n             debug2!(\"(resolving imports for module) all imports resolved for \\\n                    {}\",\n@@ -2103,7 +2103,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn idents_to_str(&mut self, idents: &[Ident]) -> ~str {\n+    fn idents_to_str(&mut self, idents: &[Ident]) -> ~str {\n         let mut first = true;\n         let mut result = ~\"\";\n         for ident in idents.iter() {\n@@ -2125,7 +2125,7 @@ impl Resolver {\n         self.idents_to_str(identifiers)\n     }\n \n-    pub fn import_directive_subclass_to_str(&mut self,\n+    fn import_directive_subclass_to_str(&mut self,\n                                             subclass: ImportDirectiveSubclass)\n                                             -> @str {\n         match subclass {\n@@ -2134,7 +2134,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn import_path_to_str(&mut self,\n+    fn import_path_to_str(&mut self,\n                               idents: &[Ident],\n                               subclass: ImportDirectiveSubclass)\n                               -> @str {\n@@ -2152,7 +2152,7 @@ impl Resolver {\n     /// don't know whether the name exists at the moment due to other\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n-    pub fn resolve_import_for_module(&mut self,\n+    fn resolve_import_for_module(&mut self,\n                                      module_: @mut Module,\n                                      import_directive: @ImportDirective)\n                                      -> ResolveResult<()> {\n@@ -2242,7 +2242,7 @@ impl Resolver {\n         return resolution_result;\n     }\n \n-    pub fn create_name_bindings_from_module(module: @mut Module)\n+    fn create_name_bindings_from_module(module: @mut Module)\n                                             -> NameBindings {\n         NameBindings {\n             type_def: Some(TypeNsDef {\n@@ -2255,7 +2255,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_single_import(&mut self,\n+    fn resolve_single_import(&mut self,\n                                  module_: @mut Module,\n                                  containing_module: @mut Module,\n                                  target: Ident,\n@@ -2511,7 +2511,7 @@ impl Resolver {\n     // Resolves a glob import. Note that this function cannot fail; it either\n     // succeeds or bails out (as importing * from an empty module or a module\n     // that exports nothing is valid).\n-    pub fn resolve_glob_import(&mut self,\n+    fn resolve_glob_import(&mut self,\n                                privacy: Privacy,\n                                module_: @mut Module,\n                                containing_module: @mut Module,\n@@ -2644,7 +2644,7 @@ impl Resolver {\n     }\n \n     /// Resolves the given module path from the given root `module_`.\n-    pub fn resolve_module_path_from_root(&mut self,\n+    fn resolve_module_path_from_root(&mut self,\n                                          module_: @mut Module,\n                                          module_path: &[Ident],\n                                          index: uint,\n@@ -2753,7 +2753,7 @@ impl Resolver {\n \n     /// Attempts to resolve the module part of an import directive or path\n     /// rooted at the given module.\n-    pub fn resolve_module_path(&mut self,\n+    fn resolve_module_path(&mut self,\n                                module_: @mut Module,\n                                module_path: &[Ident],\n                                use_lexical_scope: UseLexicalScopeFlag,\n@@ -2846,7 +2846,7 @@ impl Resolver {\n \n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n-    pub fn resolve_item_in_lexical_scope(&mut self,\n+    fn resolve_item_in_lexical_scope(&mut self,\n                                          module_: @mut Module,\n                                          name: Ident,\n                                          namespace: Namespace,\n@@ -2975,7 +2975,7 @@ impl Resolver {\n     }\n \n     /// Resolves a module name in the current lexical scope.\n-    pub fn resolve_module_in_lexical_scope(&mut self,\n+    fn resolve_module_in_lexical_scope(&mut self,\n                                            module_: @mut Module,\n                                            name: Ident)\n                                            -> ResolveResult<@mut Module> {\n@@ -3021,7 +3021,7 @@ impl Resolver {\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n-    pub fn get_nearest_normal_module_parent(&mut self, module_: @mut Module)\n+    fn get_nearest_normal_module_parent(&mut self, module_: @mut Module)\n                                             -> Option<@mut Module> {\n         let mut module_ = module_;\n         loop {\n@@ -3043,7 +3043,7 @@ impl Resolver {\n \n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n-    pub fn get_nearest_normal_module_parent_or_self(&mut self,\n+    fn get_nearest_normal_module_parent_or_self(&mut self,\n                                                     module_: @mut Module)\n                                                     -> @mut Module {\n         match module_.kind {\n@@ -3063,7 +3063,7 @@ impl Resolver {\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    pub fn resolve_module_prefix(&mut self,\n+    fn resolve_module_prefix(&mut self,\n                                  module_: @mut Module,\n                                  module_path: &[Ident])\n                                  -> ResolveResult<ModulePrefixResult> {\n@@ -3106,7 +3106,7 @@ impl Resolver {\n     /// Attempts to resolve the supplied name in the given module for the\n     /// given namespace. If successful, returns the target corresponding to\n     /// the name.\n-    pub fn resolve_name_in_module(&mut self,\n+    fn resolve_name_in_module(&mut self,\n                                   module_: @mut Module,\n                                   name: Ident,\n                                   namespace: Namespace,\n@@ -3191,7 +3191,7 @@ impl Resolver {\n         return Failed;\n     }\n \n-    pub fn report_unresolved_imports(&mut self, module_: @mut Module) {\n+    fn report_unresolved_imports(&mut self, module_: @mut Module) {\n         let index = module_.resolved_import_count;\n         let imports: &mut ~[@ImportDirective] = &mut *module_.imports;\n         let import_count = imports.len();\n@@ -3233,12 +3233,12 @@ impl Resolver {\n     // Then this operation can simply be performed as part of item (or import)\n     // processing.\n \n-    pub fn record_exports(&mut self) {\n+    fn record_exports(&mut self) {\n         let root_module = self.graph_root.get_module();\n         self.record_exports_for_module_subtree(root_module);\n     }\n \n-    pub fn record_exports_for_module_subtree(&mut self,\n+    fn record_exports_for_module_subtree(&mut self,\n                                              module_: @mut Module) {\n         // If this isn't a local crate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n@@ -3284,7 +3284,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn record_exports_for_module(&mut self, module_: @mut Module) {\n+    fn record_exports_for_module(&mut self, module_: @mut Module) {\n         let mut exports2 = ~[];\n \n         self.add_exports_for_module(&mut exports2, module_);\n@@ -3298,7 +3298,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn add_exports_of_namebindings(&mut self,\n+    fn add_exports_of_namebindings(&mut self,\n                                        exports2: &mut ~[Export2],\n                                        name: Name,\n                                        namebindings: @mut NameBindings,\n@@ -3326,7 +3326,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn add_exports_for_module(&mut self,\n+    fn add_exports_for_module(&mut self,\n                                   exports2: &mut ~[Export2],\n                                   module_: @mut Module) {\n         for (name, importresolution) in module_.import_resolutions.iter() {\n@@ -3371,7 +3371,7 @@ impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    pub fn with_scope(&mut self, name: Option<Ident>, f: &fn(&mut Resolver)) {\n+    fn with_scope(&mut self, name: Option<Ident>, f: &fn(&mut Resolver)) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3411,7 +3411,7 @@ impl Resolver {\n \n     /// Wraps the given definition in the appropriate number of `def_upvar`\n     /// wrappers.\n-    pub fn upvarify(&mut self,\n+    fn upvarify(&mut self,\n                     ribs: &mut ~[@Rib],\n                     rib_index: uint,\n                     def_like: DefLike,\n@@ -3523,7 +3523,7 @@ impl Resolver {\n         return Some(DlDef(def));\n     }\n \n-    pub fn search_ribs(&mut self,\n+    fn search_ribs(&mut self,\n                        ribs: &mut ~[@Rib],\n                        name: Name,\n                        span: Span,\n@@ -3549,13 +3549,13 @@ impl Resolver {\n         return None;\n     }\n \n-    pub fn resolve_crate(&mut self, crate: &ast::Crate) {\n+    fn resolve_crate(&mut self, crate: &ast::Crate) {\n         debug2!(\"(resolving crate) starting\");\n \n         visit::walk_crate(self, crate, ());\n     }\n \n-    pub fn resolve_item(&mut self, item: @item) {\n+    fn resolve_item(&mut self, item: @item) {\n         debug2!(\"(resolving item) resolving {}\",\n                self.session.str_of(item.ident));\n \n@@ -3733,7 +3733,7 @@ impl Resolver {\n         self.xray_context = orig_xray_flag;\n     }\n \n-    pub fn with_type_parameter_rib(&mut self,\n+    fn with_type_parameter_rib(&mut self,\n                                    type_parameters: TypeParameters,\n                                    f: &fn(&mut Resolver)) {\n         match type_parameters {\n@@ -3777,19 +3777,19 @@ impl Resolver {\n         }\n     }\n \n-    pub fn with_label_rib(&mut self, f: &fn(&mut Resolver)) {\n+    fn with_label_rib(&mut self, f: &fn(&mut Resolver)) {\n         self.label_ribs.push(@Rib::new(NormalRibKind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n-    pub fn with_constant_rib(&mut self, f: &fn(&mut Resolver)) {\n+    fn with_constant_rib(&mut self, f: &fn(&mut Resolver)) {\n         self.value_ribs.push(@Rib::new(ConstantItemRibKind));\n         f(self);\n         self.value_ribs.pop();\n     }\n \n-    pub fn resolve_function(&mut self,\n+    fn resolve_function(&mut self,\n                             rib_kind: RibKind,\n                             optional_declaration: Option<&fn_decl>,\n                             type_parameters: TypeParameters,\n@@ -3860,7 +3860,7 @@ impl Resolver {\n         self.value_ribs.pop();\n     }\n \n-    pub fn resolve_type_parameters(&mut self,\n+    fn resolve_type_parameters(&mut self,\n                                    type_parameters: &OptVec<TyParam>) {\n         for type_parameter in type_parameters.iter() {\n             for bound in type_parameter.bounds.iter() {\n@@ -3869,7 +3869,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_type_parameter_bound(&mut self,\n+    fn resolve_type_parameter_bound(&mut self,\n                                         id: NodeId,\n                                         type_parameter_bound: &TyParamBound) {\n         match *type_parameter_bound {\n@@ -3880,7 +3880,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_trait_reference(&mut self,\n+    fn resolve_trait_reference(&mut self,\n                                    id: NodeId,\n                                    trait_reference: &trait_ref,\n                                    reference_type: TraitReferenceType) {\n@@ -3903,7 +3903,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_struct(&mut self,\n+    fn resolve_struct(&mut self,\n                           id: NodeId,\n                           generics: &Generics,\n                           fields: &[@struct_field]) {\n@@ -3945,7 +3945,7 @@ impl Resolver {\n \n     // Does this really need to take a RibKind or is it always going\n     // to be NormalRibKind?\n-    pub fn resolve_method(&mut self,\n+    fn resolve_method(&mut self,\n                           rib_kind: RibKind,\n                           method: @method,\n                           outer_type_parameter_count: uint) {\n@@ -3968,7 +3968,7 @@ impl Resolver {\n                               self_binding);\n     }\n \n-    pub fn resolve_implementation(&mut self,\n+    fn resolve_implementation(&mut self,\n                                   id: NodeId,\n                                   generics: &Generics,\n                                   opt_trait_reference: &Option<trait_ref>,\n@@ -4042,7 +4042,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_module(&mut self,\n+    fn resolve_module(&mut self,\n                           module_: &_mod,\n                           _span: Span,\n                           _name: Ident,\n@@ -4052,7 +4052,7 @@ impl Resolver {\n         visit::walk_mod(self, module_, ());\n     }\n \n-    pub fn resolve_local(&mut self, local: @Local) {\n+    fn resolve_local(&mut self, local: @Local) {\n         let mutability = if local.is_mutbl {Mutable} else {Immutable};\n \n         // Resolve the type.\n@@ -4076,7 +4076,7 @@ impl Resolver {\n     // this is done hygienically. This could arise for a macro\n     // that expands into an or-pattern where one 'x' was from the\n     // user and one 'x' came from the macro.\n-    pub fn binding_mode_map(&mut self, pat: @Pat) -> BindingMap {\n+    fn binding_mode_map(&mut self, pat: @Pat) -> BindingMap {\n         let mut result = HashMap::new();\n         do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n             let name = mtwt_resolve(path_to_ident(path));\n@@ -4089,7 +4089,7 @@ impl Resolver {\n \n     // check that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n-    pub fn check_consistent_bindings(&mut self, arm: &Arm) {\n+    fn check_consistent_bindings(&mut self, arm: &Arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n         for (i, p) in arm.pats.iter().enumerate() {\n@@ -4128,7 +4128,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_arm(&mut self, arm: &Arm) {\n+    fn resolve_arm(&mut self, arm: &Arm) {\n         self.value_ribs.push(@Rib::new(NormalRibKind));\n \n         let bindings_list = @mut HashMap::new();\n@@ -4147,7 +4147,7 @@ impl Resolver {\n         self.value_ribs.pop();\n     }\n \n-    pub fn resolve_block(&mut self, block: &Block) {\n+    fn resolve_block(&mut self, block: &Block) {\n         debug2!(\"(resolving block) entering block\");\n         self.value_ribs.push(@Rib::new(NormalRibKind));\n \n@@ -4172,7 +4172,7 @@ impl Resolver {\n         debug2!(\"(resolving block) leaving block\");\n     }\n \n-    pub fn resolve_type(&mut self, ty: &Ty) {\n+    fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n@@ -4278,7 +4278,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_pattern(&mut self,\n+    fn resolve_pattern(&mut self,\n                            pattern: @Pat,\n                            mode: PatternBindingMode,\n                            mutability: Mutability,\n@@ -4337,7 +4337,7 @@ impl Resolver {\n                         }\n                         FoundConst(_) => {\n                             self.resolve_error(pattern.span,\n-                                                  \"only refutable patterns \\\n+                                                  \"only irrefutable patterns \\\n                                                    allowed here\");\n                         }\n                         BareIdentifierPatternUnresolved => {\n@@ -4531,7 +4531,7 @@ impl Resolver {\n         };\n     }\n \n-    pub fn resolve_bare_identifier_pattern(&mut self, name: Ident)\n+    fn resolve_bare_identifier_pattern(&mut self, name: Ident)\n                                            ->\n                                            BareIdentifierPatternResolution {\n         match self.resolve_item_in_lexical_scope(self.current_module,\n@@ -4572,7 +4572,7 @@ impl Resolver {\n \n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n-    pub fn resolve_path(&mut self,\n+    fn resolve_path(&mut self,\n                         id: NodeId,\n                         path: &Path,\n                         namespace: Namespace,\n@@ -4617,7 +4617,7 @@ impl Resolver {\n     }\n \n     // resolve a single identifier (used as a varref)\n-    pub fn resolve_identifier(&mut self,\n+    fn resolve_identifier(&mut self,\n                               identifier: Ident,\n                               namespace: Namespace,\n                               check_ribs: bool,\n@@ -4641,7 +4641,7 @@ impl Resolver {\n     }\n \n     // FIXME #4952: Merge me with resolve_name_in_module?\n-    pub fn resolve_definition_of_name_in_module(&mut self,\n+    fn resolve_definition_of_name_in_module(&mut self,\n                                                 containing_module: @mut Module,\n                                                 name: Ident,\n                                                 namespace: Namespace,\n@@ -4717,7 +4717,7 @@ impl Resolver {\n     }\n \n     // resolve a \"module-relative\" path, e.g. a::b::c\n-    pub fn resolve_module_relative_path(&mut self,\n+    fn resolve_module_relative_path(&mut self,\n                                         path: &Path,\n                                         xray: XrayFlag,\n                                         namespace: Namespace)\n@@ -4782,7 +4782,7 @@ impl Resolver {\n \n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n-    pub fn resolve_crate_relative_path(&mut self,\n+    fn resolve_crate_relative_path(&mut self,\n                                        path: &Path,\n                                        xray: XrayFlag,\n                                        namespace: Namespace)\n@@ -4828,7 +4828,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_identifier_in_local_ribs(&mut self,\n+    fn resolve_identifier_in_local_ribs(&mut self,\n                                             ident: Ident,\n                                             namespace: Namespace,\n                                             span: Span)\n@@ -4863,7 +4863,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_self_value_in_local_ribs(&mut self, span: Span)\n+    fn resolve_self_value_in_local_ribs(&mut self, span: Span)\n                                             -> Option<Def> {\n         // FIXME #4950: This should not use a while loop.\n         let mut i = self.value_ribs.len();\n@@ -4895,7 +4895,7 @@ impl Resolver {\n         None\n     }\n \n-    pub fn resolve_item_by_identifier_in_lexical_scope(&mut self,\n+    fn resolve_item_by_identifier_in_lexical_scope(&mut self,\n                                                        ident: Ident,\n                                                        namespace: Namespace)\n                                                        -> Option<Def> {\n@@ -4941,7 +4941,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn find_best_match_for_name(&mut self,\n+    fn find_best_match_for_name(&mut self,\n                                     name: &str,\n                                     max_distance: uint)\n                                     -> Option<@str> {\n@@ -4981,7 +4981,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_expr(&mut self, expr: @Expr) {\n+    fn resolve_expr(&mut self, expr: @Expr) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -5145,7 +5145,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn record_candidate_traits_for_expr_if_necessary(&mut self,\n+    fn record_candidate_traits_for_expr_if_necessary(&mut self,\n                                                          expr: @Expr) {\n         match expr.node {\n             ExprField(_, ident, _) => {\n@@ -5230,7 +5230,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn search_for_traits_containing_method(&mut self, name: Ident)\n+    fn search_for_traits_containing_method(&mut self, name: Ident)\n                                                -> ~[DefId] {\n         debug2!(\"(searching for traits containing method) looking for '{}'\",\n                self.session.str_of(name));\n@@ -5330,7 +5330,7 @@ impl Resolver {\n         return found_traits;\n     }\n \n-    pub fn add_trait_info(&self,\n+    fn add_trait_info(&self,\n                           found_traits: &mut ~[DefId],\n                           trait_def_id: DefId,\n                           name: Ident) {\n@@ -5341,7 +5341,7 @@ impl Resolver {\n         found_traits.push(trait_def_id);\n     }\n \n-    pub fn add_fixed_trait_for_expr(&mut self,\n+    fn add_fixed_trait_for_expr(&mut self,\n                                     expr_id: NodeId,\n                                     trait_id: Option<DefId>) {\n         match trait_id {\n@@ -5352,7 +5352,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn record_def(&mut self, node_id: NodeId, def: Def) {\n+    fn record_def(&mut self, node_id: NodeId, def: Def) {\n         debug2!(\"(recording def) recording {:?} for {:?}\", def, node_id);\n         do self.def_map.insert_or_update_with(node_id, def) |_, old_value| {\n             // Resolve appears to \"resolve\" the same ID multiple\n@@ -5365,7 +5365,7 @@ impl Resolver {\n         };\n     }\n \n-    pub fn enforce_default_binding_mode(&mut self,\n+    fn enforce_default_binding_mode(&mut self,\n                                         pat: &Pat,\n                                         pat_binding_mode: BindingMode,\n                                         descr: &str) {\n@@ -5387,12 +5387,12 @@ impl Resolver {\n     // resolve data structures.\n     //\n \n-    pub fn check_for_unused_imports(&self, crate: &ast::Crate) {\n+    fn check_for_unused_imports(&self, crate: &ast::Crate) {\n         let mut visitor = UnusedImportCheckVisitor{ resolver: self };\n         visit::walk_crate(&mut visitor, crate, ());\n     }\n \n-    pub fn check_for_item_unused_imports(&self, vi: &view_item) {\n+    fn check_for_item_unused_imports(&self, vi: &view_item) {\n         // Ignore public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n@@ -5436,7 +5436,7 @@ impl Resolver {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    pub fn module_to_str(&mut self, module_: @mut Module) -> ~str {\n+    fn module_to_str(&mut self, module_: @mut Module) -> ~str {\n         let mut idents = ~[];\n         let mut current_module = module_;\n         loop {\n@@ -5461,7 +5461,7 @@ impl Resolver {\n         return self.idents_to_str(idents.move_rev_iter().collect::<~[ast::Ident]>());\n     }\n \n-    pub fn dump_module(&mut self, module_: @mut Module) {\n+    fn dump_module(&mut self, module_: @mut Module) {\n         debug2!(\"Dump of module `{}`:\", self.module_to_str(module_));\n \n         debug2!(\"Children:\");\n@@ -5515,4 +5515,3 @@ pub fn resolve_crate(session: Session,\n         trait_map: resolver.trait_map.clone(),\n     }\n }\n-"}]}