{"sha": "19402f11e12042367f2b711155cdde61a608b660", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NDAyZjExZTEyMDQyMzY3ZjJiNzExMTU1Y2RkZTYxYTYwOGI2NjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-06T08:48:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-06T08:48:11Z"}, "message": "Auto merge of #45798 - nrc:rls-bugs-3, r=eddyb\n\nA couple more save-analysis fixes\n\nr? @eddyb", "tree": {"sha": "d3e5f29340900d98dcbcb91ed44bf0ae52b60962", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3e5f29340900d98dcbcb91ed44bf0ae52b60962"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19402f11e12042367f2b711155cdde61a608b660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19402f11e12042367f2b711155cdde61a608b660", "html_url": "https://github.com/rust-lang/rust/commit/19402f11e12042367f2b711155cdde61a608b660", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19402f11e12042367f2b711155cdde61a608b660/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54bbd567153463ce81d3ff7f0ca980a7f73cd3af", "url": "https://api.github.com/repos/rust-lang/rust/commits/54bbd567153463ce81d3ff7f0ca980a7f73cd3af", "html_url": "https://github.com/rust-lang/rust/commit/54bbd567153463ce81d3ff7f0ca980a7f73cd3af"}, {"sha": "b709a7ebc53f9c61890590233ee4defc5b9b5c2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b709a7ebc53f9c61890590233ee4defc5b9b5c2c", "html_url": "https://github.com/rust-lang/rust/commit/b709a7ebc53f9c61890590233ee4defc5b9b5c2c"}], "stats": {"total": 131, "additions": 48, "deletions": 83}, "files": [{"sha": "d190ae1431fd80db73e78f9d15c27645a924f7d2", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/19402f11e12042367f2b711155cdde61a608b660/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19402f11e12042367f2b711155cdde61a608b660/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=19402f11e12042367f2b711155cdde61a608b660", "patch": "@@ -521,39 +521,41 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                       item: &'l ast::Item,\n                       def: &'l ast::VariantData,\n                       ty_params: &'l ast::Generics) {\n+        debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n-        let (value, fields) =\n-            if let ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) = item.node\n-        {\n-            let include_priv_fields = !self.save_ctxt.config.pub_only;\n-            let fields_str = fields\n-                .iter()\n-                .enumerate()\n-                .filter_map(|(i, f)| {\n-                     if include_priv_fields || f.vis == ast::Visibility::Public {\n-                         f.ident.map(|i| i.to_string()).or_else(|| Some(i.to_string()))\n-                     } else {\n-                         None\n-                     }\n-                })\n-                .collect::<Vec<_>>()\n-                .join(\", \");\n-            let value = format!(\"{} {{ {} }}\", name, fields_str);\n-            (value, fields.iter().map(|f| ::id_from_node_id(f.id, &self.save_ctxt)).collect())\n-        } else {\n-            (String::new(), vec![])\n+        let (kind, keyword) = match item.node {\n+            ast::ItemKind::Struct(_, _) => (DefKind::Struct, keywords::Struct),\n+            ast::ItemKind::Union(_, _) => (DefKind::Union, keywords::Union),\n+            _ => unreachable!(),\n+        };\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keyword);\n+        let (value, fields) = match item.node {\n+            ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) |\n+            ast::ItemKind::Union(ast::VariantData::Struct(ref fields, _), _) => {\n+                let include_priv_fields = !self.save_ctxt.config.pub_only;\n+                let fields_str = fields\n+                    .iter()\n+                    .enumerate()\n+                    .filter_map(|(i, f)| {\n+                         if include_priv_fields || f.vis == ast::Visibility::Public {\n+                             f.ident.map(|i| i.to_string()).or_else(|| Some(i.to_string()))\n+                         } else {\n+                             None\n+                         }\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                let value = format!(\"{} {{ {} }}\", name, fields_str);\n+                (value, fields.iter().map(|f| ::id_from_node_id(f.id, &self.save_ctxt)).collect())\n+            }\n+            _ => (String::new(), vec![])\n         };\n \n         if !self.span.filter_generated(sub_span, item.span) {\n             let span = self.span_from_span(sub_span.expect(\"No span found for struct\"));\n-            let kind = match item.node {\n-                ast::ItemKind::Struct(_, _) => DefKind::Struct,\n-                ast::ItemKind::Union(_, _) => DefKind::Union,\n-                _ => unreachable!(),\n-            };\n             self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n                 kind,\n                 id: ::id_from_node_id(item.id, &self.save_ctxt),\n@@ -876,6 +878,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                            ex: &'l ast::Expr,\n                            seg: &'l ast::PathSegment,\n                            args: &'l [P<ast::Expr>]) {\n+        debug!(\"process_method_call {:?} {:?}\", ex, ex.span);\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(mcd, RefData, ex.span);\n             if !generated_code(ex.span) {"}, {"sha": "edb51ae59e1b56c8b431893212f0e0fd87aa9693", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/19402f11e12042367f2b711155cdde61a608b660/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19402f11e12042367f2b711155cdde61a608b660/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=19402f11e12042367f2b711155cdde61a608b660", "patch": "@@ -546,16 +546,16 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprKind::MethodCall(..) => {\n+            ast::ExprKind::MethodCall(ref seg, ..) => {\n                 let expr_hir_id = self.tcx.hir.definitions().node_to_hir_id(expr.id);\n                 let method_id = self.tables.type_dependent_defs()[expr_hir_id].def_id();\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n-                let sub_span = self.span_utils.sub_span_for_meth_name(expr.span);\n-                filter!(self.span_utils, sub_span, expr.span, None);\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let sub_span = seg.span;\n+                filter!(self.span_utils, Some(sub_span), expr.span, None);\n+                let span = self.span_from_span(sub_span);\n                 Some(Data::RefData(Ref {\n                     kind: RefKind::Function,\n                     span,\n@@ -627,13 +627,18 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             false\n         }\n \n+        if path.segments.is_empty() {\n+            return None;\n+        }\n+\n         let def = self.get_path_def(id);\n-        let sub_span = self.span_utils.span_for_last_ident(path.span);\n-        filter!(self.span_utils, sub_span, path.span, None);\n+        let last_seg = &path.segments[path.segments.len() - 1];\n+        let sub_span = last_seg.span;\n+        filter!(self.span_utils, Some(sub_span), path.span, None);\n         match def {\n             HirDef::Upvar(id, ..) |\n             HirDef::Local(id) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n@@ -644,7 +649,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Const(..) |\n             HirDef::AssociatedConst(..) |\n             HirDef::VariantCtor(..) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n@@ -670,7 +675,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::AssociatedTy(def_id) |\n             HirDef::Trait(def_id) |\n             HirDef::TyParam(def_id) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,\n@@ -681,7 +686,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n                 Some(Ref {\n                     kind: RefKind::Type,\n@@ -690,8 +695,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 })\n             }\n             HirDef::Method(decl_id) => {\n-                let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n-                filter!(self.span_utils, sub_span, path.span, None);\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n                     self.tcx.associated_items(ti.container.id())\n@@ -700,23 +703,23 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 } else {\n                     None\n                 };\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id.unwrap_or(decl_id)),\n                 })\n             }\n             HirDef::Fn(def_id) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n             HirDef::Mod(def_id) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Mod,\n                     span,"}, {"sha": "5bfb4d1b3b20389546be7f1fba6538b64fe5165f", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/19402f11e12042367f2b711155cdde61a608b660/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19402f11e12042367f2b711155cdde61a608b660/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=19402f11e12042367f2b711155cdde61a608b660", "patch": "@@ -103,47 +103,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    // Return the span for the last ident before a `(` or `<` or '::<' and outside any\n-    // any brackets, or the last span.\n-    pub fn sub_span_for_meth_name(&self, span: Span) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.real_token();\n-        let mut result = None;\n-        let mut bracket_count = 0;\n-        let mut prev_span = None;\n-        while prev.tok != token::Eof {\n-            prev_span = None;\n-            let mut next = toks.real_token();\n-\n-            if (next.tok == token::OpenDelim(token::Paren) || next.tok == token::Lt) &&\n-               bracket_count == 0 && prev.tok.is_ident() {\n-                result = Some(prev.sp);\n-            }\n-\n-            if bracket_count == 0 && next.tok == token::ModSep {\n-                let old = prev;\n-                prev = next;\n-                next = toks.real_token();\n-                if next.tok == token::Lt && old.tok.is_ident() {\n-                    result = Some(old.sp);\n-                }\n-            }\n-\n-            bracket_count += match prev.tok {\n-                token::OpenDelim(token::Paren) | token::Lt => 1,\n-                token::CloseDelim(token::Paren) | token::Gt => -1,\n-                token::BinOp(token::Shr) => -2,\n-                _ => 0,\n-            };\n-\n-            if prev.tok.is_ident() && bracket_count == 0 {\n-                prev_span = Some(prev.sp);\n-            }\n-            prev = next;\n-        }\n-        result.or(prev_span)\n-    }\n-\n     // Return the span for the last ident before a `<` and outside any\n     // angle brackets, or the last span.\n     pub fn sub_span_for_type_name(&self, span: Span) -> Option<Span> {\n@@ -330,7 +289,7 @@ impl<'a> SpanUtils<'a> {\n }\n \n macro_rules! filter {\n-    ($util: expr, $span: ident, $parent: expr, None) => {\n+    ($util: expr, $span: expr, $parent: expr, None) => {\n         if $util.filter_generated($span, $parent) {\n             return None;\n         }"}]}