{"sha": "89c35ae76493b6ea2401d2f0271f0f35693b1198", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YzM1YWU3NjQ5M2I2ZWEyNDAxZDJmMDI3MWYwZjM1NjkzYjExOTg=", "commit": {"author": {"name": "Bryan Tan", "email": "techniux@gmail.com", "date": "2017-04-01T00:05:45Z"}, "committer": {"name": "Bryan Tan", "email": "techniux@gmail.com", "date": "2017-04-01T00:07:01Z"}, "message": "Add links and examples to std::sync::mpsc docs (#29377)\n\nThis change adds links to to `Receiver`, `Iter`, `TryIter`, `IntoIter`,\n`Sender`, `SyncSender`, `SendError`, `RecvError`, `TryRecvError`,\n`RecvTimeoutError`, `TrySendError`, `Sender::send`, `SyncSender::send`,\n`SyncSender::try_send`, `Receiver::recv`, `Receiver::recv_timeout`,\n`Receiver::iter`, and `Receiver::try_iter`.\n\nExamples added to `Receiver`, `Sender`, `Receiver::iter`.", "tree": {"sha": "1be1f43e4ec2a4fd8fcf934d65506427e0cf1d42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1be1f43e4ec2a4fd8fcf934d65506427e0cf1d42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89c35ae76493b6ea2401d2f0271f0f35693b1198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89c35ae76493b6ea2401d2f0271f0f35693b1198", "html_url": "https://github.com/rust-lang/rust/commit/89c35ae76493b6ea2401d2f0271f0f35693b1198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89c35ae76493b6ea2401d2f0271f0f35693b1198/comments", "author": {"login": "Technius", "id": 1066652, "node_id": "MDQ6VXNlcjEwNjY2NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1066652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Technius", "html_url": "https://github.com/Technius", "followers_url": "https://api.github.com/users/Technius/followers", "following_url": "https://api.github.com/users/Technius/following{/other_user}", "gists_url": "https://api.github.com/users/Technius/gists{/gist_id}", "starred_url": "https://api.github.com/users/Technius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Technius/subscriptions", "organizations_url": "https://api.github.com/users/Technius/orgs", "repos_url": "https://api.github.com/users/Technius/repos", "events_url": "https://api.github.com/users/Technius/events{/privacy}", "received_events_url": "https://api.github.com/users/Technius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Technius", "id": 1066652, "node_id": "MDQ6VXNlcjEwNjY2NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1066652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Technius", "html_url": "https://github.com/Technius", "followers_url": "https://api.github.com/users/Technius/followers", "following_url": "https://api.github.com/users/Technius/following{/other_user}", "gists_url": "https://api.github.com/users/Technius/gists{/gist_id}", "starred_url": "https://api.github.com/users/Technius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Technius/subscriptions", "organizations_url": "https://api.github.com/users/Technius/orgs", "repos_url": "https://api.github.com/users/Technius/repos", "events_url": "https://api.github.com/users/Technius/events{/privacy}", "received_events_url": "https://api.github.com/users/Technius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a6ebdfcda149fdf3093003bceacbb2e0a1682ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a6ebdfcda149fdf3093003bceacbb2e0a1682ab", "html_url": "https://github.com/rust-lang/rust/commit/5a6ebdfcda149fdf3093003bceacbb2e0a1682ab"}], "stats": {"total": 167, "additions": 136, "deletions": 31}, "files": [{"sha": "fa31c6cedd2e6065917598787435e76bd154dc99", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 136, "deletions": 31, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/89c35ae76493b6ea2401d2f0271f0f35693b1198/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c35ae76493b6ea2401d2f0271f0f35693b1198/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=89c35ae76493b6ea2401d2f0271f0f35693b1198", "patch": "@@ -298,7 +298,28 @@ mod mpsc_queue;\n mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n-/// one thread\n+/// one thread.\n+///\n+/// Messages sent to the channel can be retrieved using [`recv`].\n+///\n+/// [`recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::channel;\n+/// use std::thread;\n+/// use std::time::Duration;\n+/// let (send, recv) = channel();\n+/// thread::spawn(move || {\n+///     send.send(\"Hello world!\");\n+///     thread::sleep(Duration::from_secs(2)); // block for two seconds\n+///     send.send(\"Delayed for 2 seconds\");\n+/// });\n+/// println!(\"{:?}\", recv.recv()); // Received immediately\n+/// println!(\"Waiting...\");\n+/// println!(\"{:?}\", recv.recv()); // Received after 2 seconds\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -312,30 +333,39 @@ unsafe impl<T: Send> Send for Receiver<T> { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> !Sync for Receiver<T> { }\n \n-/// An iterator over messages on a receiver, this iterator will block\n-/// whenever `next` is called, waiting for a new message, and `None` will be\n-/// returned when the corresponding channel has hung up.\n+/// An iterator over messages on a receiver, this iterator will block whenever\n+/// [`next`] is called, waiting for a new message, and [`None`] will be returned\n+/// when the corresponding channel has hung up.\n+///\n+/// [`next`]: ../../../std/iter/trait.Iterator.html#method.next\n+/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n /// An iterator that attempts to yield all pending values for a receiver.\n-/// `None` will be returned when there are no pending values remaining or\n-/// if the corresponding channel has hung up.\n+/// [`None`] will be returned when there are no pending values remaining or if\n+/// the corresponding channel has hung up.\n ///\n /// This Iterator will never block the caller in order to wait for data to\n-/// become available. Instead, it will return `None`.\n+/// become available. Instead, it will return [`None`].\n+///\n+/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n #[derive(Debug)]\n pub struct TryIter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n /// An owning iterator over messages on a receiver, this iterator will block\n-/// whenever `next` is called, waiting for a new message, and `None` will be\n+/// whenever [`next`] is called, waiting for a new message, and [`None`] will be\n /// returned when the corresponding channel has hung up.\n+///\n+/// [`next`]: ../../../std/iter/trait.Iterator.html#method.next\n+/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+///\n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n@@ -344,6 +374,30 @@ pub struct IntoIter<T> {\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one thread, but it can be cloned to send to other threads.\n+///\n+/// Messages can be sent through this channel with [`send`].\n+///\n+/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::channel;\n+/// use std::thread;\n+/// let (sender, receiver) = channel();\n+/// let sender2 = sender.clone();\n+/// // First thread owns sender\n+/// thread::spawn(move || {\n+///     sender.send(1);\n+/// });\n+/// // Second thread owns sender2\n+/// thread::spawn(move || {\n+///     sender2.send(2);\n+/// });\n+/// let msg = receiver.recv().unwrap();\n+/// let msg2 = receiver.recv().unwrap();\n+/// assert_eq!(3, msg + msg2);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -359,6 +413,10 @@ impl<T> !Sync for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one thread, but it can be cloned to send to other threads.\n+///\n+/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+/// [`SyncSender::send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n+///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n     inner: Arc<sync::Packet<T>>,\n@@ -370,25 +428,32 @@ unsafe impl<T: Send> Send for SyncSender<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> !Sync for SyncSender<T> {}\n \n-/// An error returned from the `send` function on channels.\n+/// An error returned from the [`send`] function on channels.\n ///\n-/// A `send` operation can only fail if the receiving end of a channel is\n+/// A [`send`] operation can only fail if the receiving end of a channel is\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n+///\n+/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n-/// An error returned from the `recv` function on a `Receiver`.\n+/// An error returned from the [`recv`] function on a [`Receiver`].\n ///\n-/// The `recv` operation can only fail if the sending half of a channel is\n+/// The [`recv`] operation can only fail if the sending half of a channel is\n /// disconnected, implying that no further messages will ever be received.\n+///\n+/// [`recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv\n+/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RecvError;\n \n-/// This enumeration is the list of the possible reasons that `try_recv` could\n+/// This enumeration is the list of the possible reasons that [`try_recv`] could\n /// not return data when called.\n+///\n+/// [`try_recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.try_recv\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n@@ -403,8 +468,10 @@ pub enum TryRecvError {\n     Disconnected,\n }\n \n-/// This enumeration is the list of possible errors that `recv_timeout` could\n+/// This enumeration is the list of possible errors that [`recv_timeout`] could\n /// not return data when called.\n+///\n+/// [`recv_timeout`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv_timeout\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n pub enum RecvTimeoutError {\n@@ -419,7 +486,9 @@ pub enum RecvTimeoutError {\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n-/// `SyncSender::try_send` method.\n+/// [`SyncSender::try_send`] method.\n+///\n+/// [`SyncSender::try_send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.try_send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub enum TrySendError<T> {\n@@ -566,10 +635,13 @@ impl<T> Sender<T> {\n     /// A successful send occurs when it is determined that the other end of\n     /// the channel has not hung up already. An unsuccessful send would be one\n     /// where the corresponding receiver has already been deallocated. Note\n-    /// that a return value of `Err` means that the data will never be\n-    /// received, but a return value of `Ok` does *not* mean that the data\n+    /// that a return value of [`Err`] means that the data will never be\n+    /// received, but a return value of [`Ok`] does *not* mean that the data\n     /// will be received.  It is possible for the corresponding receiver to\n-    /// hang up immediately after this function returns `Ok`.\n+    /// hang up immediately after this function returns [`Ok`].\n+    ///\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    /// [`Ok`]: ../../../std/result/enum.Result.html#variant.Ok\n     ///\n     /// This method will never block the current thread.\n     ///\n@@ -712,23 +784,29 @@ impl<T> SyncSender<T> {\n     /// time. If the buffer size is 0, however, it can be guaranteed that the\n     /// receiver has indeed received the data if this function returns success.\n     ///\n-    /// This function will never panic, but it may return `Err` if the\n-    /// `Receiver` has disconnected and is no longer able to receive\n+    /// This function will never panic, but it may return [`Err`] if the\n+    /// [`Receiver`] has disconnected and is no longer able to receive\n     /// information.\n+    ///\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    /// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         self.inner.send(t).map_err(SendError)\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n     ///\n-    /// This method differs from `send` by returning immediately if the\n+    /// This method differs from [`send`] by returning immediately if the\n     /// channel's buffer is full or no receiver is waiting to acquire some\n-    /// data. Compared with `send`, this function has two failure cases\n+    /// data. Compared with [`send`], this function has two failure cases\n     /// instead of one (one for disconnection, one for a full buffer).\n     ///\n-    /// See `SyncSender::send` for notes about guarantees of whether the\n+    /// See [`SyncSender::send`] for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n+    ///\n+    /// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+    /// [`SyncSender::send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         self.inner.try_send(t)\n@@ -829,15 +907,18 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding `Sender`, then this receiver will wake up and\n+    /// sent to the corresponding [`Sender`], then this receiver will wake up and\n     /// return that message.\n     ///\n-    /// If the corresponding `Sender` has disconnected, or it disconnects while\n-    /// this call is blocking, this call will wake up and return `Err` to\n+    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return [`Err`] to\n     /// indicate that no more messages can ever be received on this channel.\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n+    /// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -917,15 +998,18 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding `Sender`, then this receiver will wake up and\n+    /// sent to the corresponding [`Sender`], then this receiver will wake up and\n     /// return that message.\n     ///\n-    /// If the corresponding `Sender` has disconnected, or it disconnects while\n-    /// this call is blocking, this call will wake up and return `Err` to\n+    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return [`Err`] to\n     /// indicate that no more messages can ever be received on this channel.\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n+    /// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -1003,16 +1087,37 @@ impl<T> Receiver<T> {\n     }\n \n     /// Returns an iterator that will block waiting for messages, but never\n-    /// `panic!`. It will return `None` when the channel has hung up.\n+    /// [`panic!`]. It will return [`None`] when the channel has hung up.\n+    ///\n+    /// [`panic!`]: ../../../std/macro.panic.html\n+    /// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::sync::mpsc::channel;\n+    /// use std::thread;\n+    /// let (send, recv) = channel();\n+    /// thread::spawn(move || {\n+    ///     send.send(1u8);\n+    ///     send.send(2u8);\n+    ///     send.send(3u8);\n+    /// });\n+    /// for x in recv.iter() {\n+    ///     println!(\"Got: {}\", x);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { rx: self }\n     }\n \n     /// Returns an iterator that will attempt to yield all pending values.\n     /// It will return `None` if there are no more pending values or if the\n-    /// channel has hung up. The iterator will never `panic!` or block the\n+    /// channel has hung up. The iterator will never [`panic!`] or block the\n     /// user by waiting for values.\n+    ///\n+    /// [`panic!`]: ../../../std/macro.panic.html\n     #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n     pub fn try_iter(&self) -> TryIter<T> {\n         TryIter { rx: self }"}]}