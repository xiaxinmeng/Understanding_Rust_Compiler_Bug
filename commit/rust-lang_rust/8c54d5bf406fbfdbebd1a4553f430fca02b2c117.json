{"sha": "8c54d5bf406fbfdbebd1a4553f430fca02b2c117", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNTRkNWJmNDA2ZmJmZGJlYmQxYTQ1NTNmNDMwZmNhMDJiMmMxMTc=", "commit": {"author": {"name": "Florian Zeitz", "email": "florob@babelmonkeys.de", "date": "2014-05-12T20:25:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-14T00:24:07Z"}, "message": "core: Move Hangul decomposition into unicode.rs", "tree": {"sha": "69caac0e477cd22152e15605f5c3699bdf406a95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69caac0e477cd22152e15605f5c3699bdf406a95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c54d5bf406fbfdbebd1a4553f430fca02b2c117", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c54d5bf406fbfdbebd1a4553f430fca02b2c117", "html_url": "https://github.com/rust-lang/rust/commit/8c54d5bf406fbfdbebd1a4553f430fca02b2c117", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c54d5bf406fbfdbebd1a4553f430fca02b2c117/comments", "author": {"login": "Florob", "id": 133684, "node_id": "MDQ6VXNlcjEzMzY4NA==", "avatar_url": "https://avatars.githubusercontent.com/u/133684?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Florob", "html_url": "https://github.com/Florob", "followers_url": "https://api.github.com/users/Florob/followers", "following_url": "https://api.github.com/users/Florob/following{/other_user}", "gists_url": "https://api.github.com/users/Florob/gists{/gist_id}", "starred_url": "https://api.github.com/users/Florob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Florob/subscriptions", "organizations_url": "https://api.github.com/users/Florob/orgs", "repos_url": "https://api.github.com/users/Florob/repos", "events_url": "https://api.github.com/users/Florob/events{/privacy}", "received_events_url": "https://api.github.com/users/Florob/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f71b72a12f05d3efc6b507b12102ce52c6415dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f71b72a12f05d3efc6b507b12102ce52c6415dd", "html_url": "https://github.com/rust-lang/rust/commit/2f71b72a12f05d3efc6b507b12102ce52c6415dd"}], "stats": {"total": 179, "additions": 110, "deletions": 69}, "files": [{"sha": "f079ef73cd8e2cd173405d7b232fdf79895dd7c2", "filename": "src/etc/unicode.py", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8c54d5bf406fbfdbebd1a4553f430fca02b2c117/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/8c54d5bf406fbfdbebd1a4553f430fca02b2c117/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=8c54d5bf406fbfdbebd1a4553f430fca02b2c117", "patch": "@@ -321,17 +321,24 @@ def emit_core_decomp_module(f, canon, compat):\n     format_table_content(f, data, 8)\n     f.write(\"\\n    ];\\n\\n\")\n \n-    f.write(\"    pub fn canonical(c: char, i: |char|) \"\n-        + \"{ d(c, i, false); }\\n\\n\")\n-    f.write(\"    pub fn compatibility(c: char, i: |char|) \"\n-            +\"{ d(c, i, true); }\\n\\n\")\n-    f.write(\"    fn d(c: char, i: |char|, k: bool) {\\n\")\n-    f.write(\"        use iter::Iterator;\\n\");\n+    f.write(\"\"\"\n+    pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }\n \n-    f.write(\"        if c <= '\\\\x7f' { i(c); return; }\\n\")\n+    pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }\n \n-    # First check the canonical decompositions\n-    f.write(\"\"\"\n+    fn d(c: char, i: |char|, k: bool) {\n+        use iter::Iterator;\n+\n+        // 7-bit ASCII never decomposes\n+        if c <= '\\\\x7f' { i(c); return; }\n+\n+        // Perform decomposition for Hangul\n+        if (c as u32) >= S_BASE && (c as u32) < (S_BASE + S_COUNT) {\n+            decompose_hangul(c, i);\n+            return;\n+        }\n+\n+        // First check the canonical decompositions\n         match bsearch_table(c, canonical_table) {\n             Some(canon) => {\n                 for x in canon.iter() {\n@@ -340,13 +347,12 @@ def emit_core_decomp_module(f, canon, compat):\n                 return;\n             }\n             None => ()\n-        }\\n\\n\"\"\")\n+        }\n \n-    # Bottom out if we're not doing compat.\n-    f.write(\"        if !k { i(c); return; }\\n\")\n+        // Bottom out if we're not doing compat.\n+        if !k { i(c); return; }\n \n-    # Then check the compatibility decompositions\n-    f.write(\"\"\"\n+        // Then check the compatibility decompositions\n         match bsearch_table(c, compatibility_table) {\n             Some(compat) => {\n                 for x in compat.iter() {\n@@ -355,12 +361,45 @@ def emit_core_decomp_module(f, canon, compat):\n                 return;\n             }\n             None => ()\n-        }\\n\\n\"\"\")\n+        }\n \n-    # Finally bottom out.\n-    f.write(\"        i(c);\\n\")\n-    f.write(\"    }\\n\")\n-    f.write(\"}\\n\\n\")\n+        // Finally bottom out.\n+        i(c);\n+    }\n+\n+    // Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n+    static S_BASE: u32 = 0xAC00;\n+    static L_BASE: u32 = 0x1100;\n+    static V_BASE: u32 = 0x1161;\n+    static T_BASE: u32 = 0x11A7;\n+    static L_COUNT: u32 = 19;\n+    static V_COUNT: u32 = 21;\n+    static T_COUNT: u32 = 28;\n+    static N_COUNT: u32 = (V_COUNT * T_COUNT);\n+    static S_COUNT: u32 = (L_COUNT * N_COUNT);\n+\n+    // Decompose a precomposed Hangul syllable\n+    fn decompose_hangul(s: char, f: |char|) {\n+        use cast::transmute;\n+\n+        let si = s as u32 - S_BASE;\n+\n+        let li = si / N_COUNT;\n+        unsafe {\n+            f(transmute(L_BASE + li));\n+\n+            let vi = (si % N_COUNT) / T_COUNT;\n+            f(transmute(V_BASE + vi));\n+\n+            let ti = si % T_COUNT;\n+            if ti > 0 {\n+                f(transmute(T_BASE + ti));\n+            }\n+        }\n+    }\n+}\n+\n+\"\"\")\n \n def emit_std_decomp_module(f, combine):\n     f.write(\"pub mod decompose {\\n\");"}, {"sha": "71a2d75715b5ab26459b2c9bac9b0ed5e1e4e968", "filename": "src/libcore/char.rs", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8c54d5bf406fbfdbebd1a4553f430fca02b2c117/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c54d5bf406fbfdbebd1a4553f430fca02b2c117/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=8c54d5bf406fbfdbebd1a4553f430fca02b2c117", "patch": "@@ -27,7 +27,12 @@\n use mem::transmute;\n use option::{None, Option, Some};\n use iter::{Iterator, range_step};\n-use unicode::{derived_property, property, general_category, decompose, conversions};\n+use unicode::{derived_property, property, general_category, conversions};\n+\n+/// Returns the canonical decomposition of a character.\n+pub use unicode::decompose::decompose_canonical;\n+/// Returns the compatibility decomposition of a character.\n+pub use unicode::decompose::decompose_compatible;\n \n #[cfg(not(test))] use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n #[cfg(not(test))] use default::Default;\n@@ -285,53 +290,6 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     }\n }\n \n-// Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n-static S_BASE: u32 = 0xAC00;\n-static L_BASE: u32 = 0x1100;\n-static V_BASE: u32 = 0x1161;\n-static T_BASE: u32 = 0x11A7;\n-static L_COUNT: u32 = 19;\n-static V_COUNT: u32 = 21;\n-static T_COUNT: u32 = 28;\n-static N_COUNT: u32 = (V_COUNT * T_COUNT);\n-static S_COUNT: u32 = (L_COUNT * N_COUNT);\n-\n-// Decompose a precomposed Hangul syllable\n-fn decompose_hangul(s: char, f: |char|) {\n-    let si = s as u32 - S_BASE;\n-\n-    let li = si / N_COUNT;\n-    unsafe {\n-        f(transmute(L_BASE + li));\n-\n-        let vi = (si % N_COUNT) / T_COUNT;\n-        f(transmute(V_BASE + vi));\n-\n-        let ti = si % T_COUNT;\n-        if ti > 0 {\n-            f(transmute(T_BASE + ti));\n-        }\n-    }\n-}\n-\n-/// Returns the canonical decomposition of a character\n-pub fn decompose_canonical(c: char, f: |char|) {\n-    if (c as u32) < S_BASE || (c as u32) >= (S_BASE + S_COUNT) {\n-        decompose::canonical(c, f);\n-    } else {\n-        decompose_hangul(c, f);\n-    }\n-}\n-\n-/// Returns the compatibility decomposition of a character\n-pub fn decompose_compatible(c: char, f: |char|) {\n-    if (c as u32) < S_BASE || (c as u32) >= (S_BASE + S_COUNT) {\n-        decompose::compatibility(c, f);\n-    } else {\n-        decompose_hangul(c, f);\n-    }\n-}\n-\n ///\n /// Returns the hexadecimal Unicode escape of a `char`\n ///"}, {"sha": "bffde2323bf946cabcee635b45899967f146e399", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8c54d5bf406fbfdbebd1a4553f430fca02b2c117/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c54d5bf406fbfdbebd1a4553f430fca02b2c117/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=8c54d5bf406fbfdbebd1a4553f430fca02b2c117", "patch": "@@ -2121,14 +2121,24 @@ pub mod decompose {\n         &['\\u53ef'])\n     ];\n \n-    pub fn canonical(c: char, i: |char|) { d(c, i, false); }\n \n-    pub fn compatibility(c: char, i: |char|) { d(c, i, true); }\n+    pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }\n+\n+    pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }\n \n     fn d(c: char, i: |char|, k: bool) {\n         use iter::Iterator;\n+\n+        // 7-bit ASCII never decomposes\n         if c <= '\\x7f' { i(c); return; }\n \n+        // Perform decomposition for Hangul\n+        if (c as u32) >= S_BASE && (c as u32) < (S_BASE + S_COUNT) {\n+            decompose_hangul(c, i);\n+            return;\n+        }\n+\n+        // First check the canonical decompositions\n         match bsearch_table(c, canonical_table) {\n             Some(canon) => {\n                 for x in canon.iter() {\n@@ -2139,8 +2149,10 @@ pub mod decompose {\n             None => ()\n         }\n \n+        // Bottom out if we're not doing compat.\n         if !k { i(c); return; }\n \n+        // Then check the compatibility decompositions\n         match bsearch_table(c, compatibility_table) {\n             Some(compat) => {\n                 for x in compat.iter() {\n@@ -2151,8 +2163,40 @@ pub mod decompose {\n             None => ()\n         }\n \n+        // Finally bottom out.\n         i(c);\n     }\n+\n+    // Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n+    static S_BASE: u32 = 0xAC00;\n+    static L_BASE: u32 = 0x1100;\n+    static V_BASE: u32 = 0x1161;\n+    static T_BASE: u32 = 0x11A7;\n+    static L_COUNT: u32 = 19;\n+    static V_COUNT: u32 = 21;\n+    static T_COUNT: u32 = 28;\n+    static N_COUNT: u32 = (V_COUNT * T_COUNT);\n+    static S_COUNT: u32 = (L_COUNT * N_COUNT);\n+\n+    // Decompose a precomposed Hangul syllable\n+    fn decompose_hangul(s: char, f: |char|) {\n+        use mem::transmute;\n+\n+        let si = s as u32 - S_BASE;\n+\n+        let li = si / N_COUNT;\n+        unsafe {\n+            f(transmute(L_BASE + li));\n+\n+            let vi = (si % N_COUNT) / T_COUNT;\n+            f(transmute(V_BASE + vi));\n+\n+            let ti = si % T_COUNT;\n+            if ti > 0 {\n+                f(transmute(T_BASE + ti));\n+            }\n+        }\n+    }\n }\n \n pub mod derived_property {"}]}