{"sha": "16d0205d5c161ceb2a442ce8b4a938ecc3eb687d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZDAyMDVkNWMxNjFjZWIyYTQ0MmNlOGI0YTkzOGVjYzNlYjY4N2Q=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-10-11T23:28:06Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-10-11T23:28:06Z"}, "message": "Moved the functions starting with suggest to a separate file", "tree": {"sha": "c3ba5b720bb89712ed05aebe0a19026d9e032706", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3ba5b720bb89712ed05aebe0a19026d9e032706"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d", "html_url": "https://github.com/rust-lang/rust/commit/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48291cf1d73c72523c70df009422cadc6d9e07af", "url": "https://api.github.com/repos/rust-lang/rust/commits/48291cf1d73c72523c70df009422cadc6d9e07af", "html_url": "https://github.com/rust-lang/rust/commit/48291cf1d73c72523c70df009422cadc6d9e07af"}], "stats": {"total": 1042, "additions": 529, "deletions": 513}, "files": [{"sha": "90daed976a22bf9acf0f8577064101dc8c672d5e", "filename": "compiler/rustc_typeck/src/check/fn_ctxt_impl.rs", "status": "modified", "additions": 3, "deletions": 513, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_impl.rs?ref=16d0205d5c161ceb2a442ce8b4a938ecc3eb687d", "patch": "@@ -12,18 +12,17 @@ use crate::astconv::{\n };\n \n use rustc_ast as ast;\n-use rustc_ast::util::parser::ExprPrecedence;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{ExprKind, GenericArg, ItemKind, Node, QPath};\n+use rustc_hir::{ExprKind, GenericArg, Node, QPath};\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc_infer::infer::{self, InferOk, InferResult};\n+use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n@@ -43,18 +42,13 @@ use rustc_span::{self, BytePos, MultiSpan, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, TraitEngine, TraitEngineExt};\n \n use std::collections::hash_map::Entry;\n-use std::iter;\n use std::mem::replace;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-\n     /// Produces warning on the given node, if the current point in the\n     /// function is unreachable, and there hasn't been another warning.\n     pub(super) fn warn_if_unreachable(&self, id: hir::HirId, span: Span, kind: &str) {\n@@ -1606,15 +1600,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut DiagnosticBuilder<'_>) {\n-        err.span_suggestion_short(\n-            span.shrink_to_hi(),\n-            \"consider using a semicolon here\",\n-            \";\".to_string(),\n-            Applicability::MachineApplicable,\n-        );\n-    }\n-\n     pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>) {\n         // Don't do all the complex logic below for `DeclItem`.\n         match stmt.kind {\n@@ -1886,264 +1871,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         })\n     }\n \n-    /// On implicit return expressions with mismatched types, provides the following suggestions:\n-    ///\n-    /// - Points out the method's return type as the reason for the expected type.\n-    /// - Possible missing semicolon.\n-    /// - Possible missing return type if the return type is the default, and not `fn main()`.\n-    pub fn suggest_mismatched_types_on_tail(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &'tcx hir::Expr<'tcx>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-        cause_span: Span,\n-        blk_id: hir::HirId,\n-    ) -> bool {\n-        let expr = expr.peel_drop_temps();\n-        self.suggest_missing_semicolon(err, expr, expected, cause_span);\n-        let mut pointing_at_return_type = false;\n-        if let Some((fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n-            pointing_at_return_type =\n-                self.suggest_missing_return_type(err, &fn_decl, expected, found, can_suggest);\n-        }\n-        pointing_at_return_type\n-    }\n-\n-    /// When encountering an fn-like ctor that needs to unify with a value, check whether calling\n-    /// the ctor would successfully solve the type mismatch and if so, suggest it:\n-    /// ```\n-    /// fn foo(x: usize) -> usize { x }\n-    /// let x: usize = foo;  // suggest calling the `foo` function: `foo(42)`\n-    /// ```\n-    fn suggest_fn_call(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-    ) -> bool {\n-        let hir = self.tcx.hir();\n-        let (def_id, sig) = match *found.kind() {\n-            ty::FnDef(def_id, _) => (def_id, found.fn_sig(self.tcx)),\n-            ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig()),\n-            _ => return false,\n-        };\n-\n-        let sig = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, &sig).0;\n-        let sig = self.normalize_associated_types_in(expr.span, &sig);\n-        if self.can_coerce(sig.output(), expected) {\n-            let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n-                (String::new(), Applicability::MachineApplicable)\n-            } else {\n-                (\"...\".to_string(), Applicability::HasPlaceholders)\n-            };\n-            let mut msg = \"call this function\";\n-            match hir.get_if_local(def_id) {\n-                Some(\n-                    Node::Item(hir::Item { kind: ItemKind::Fn(.., body_id), .. })\n-                    | Node::ImplItem(hir::ImplItem {\n-                        kind: hir::ImplItemKind::Fn(_, body_id), ..\n-                    })\n-                    | Node::TraitItem(hir::TraitItem {\n-                        kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Provided(body_id)),\n-                        ..\n-                    }),\n-                ) => {\n-                    let body = hir.body(*body_id);\n-                    sugg_call = body\n-                        .params\n-                        .iter()\n-                        .map(|param| match &param.pat.kind {\n-                            hir::PatKind::Binding(_, _, ident, None)\n-                                if ident.name != kw::SelfLower =>\n-                            {\n-                                ident.to_string()\n-                            }\n-                            _ => \"_\".to_string(),\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .join(\", \");\n-                }\n-                Some(Node::Expr(hir::Expr {\n-                    kind: ExprKind::Closure(_, _, body_id, _, _),\n-                    span: full_closure_span,\n-                    ..\n-                })) => {\n-                    if *full_closure_span == expr.span {\n-                        return false;\n-                    }\n-                    msg = \"call this closure\";\n-                    let body = hir.body(*body_id);\n-                    sugg_call = body\n-                        .params\n-                        .iter()\n-                        .map(|param| match &param.pat.kind {\n-                            hir::PatKind::Binding(_, _, ident, None)\n-                                if ident.name != kw::SelfLower =>\n-                            {\n-                                ident.to_string()\n-                            }\n-                            _ => \"_\".to_string(),\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .join(\", \");\n-                }\n-                Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n-                    sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                    match def_id.as_local().map(|def_id| hir.def_kind(def_id)) {\n-                        Some(DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n-                            msg = \"instantiate this tuple variant\";\n-                        }\n-                        Some(DefKind::Ctor(CtorOf::Struct, _)) => {\n-                            msg = \"instantiate this tuple struct\";\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                Some(Node::ForeignItem(hir::ForeignItem {\n-                    kind: hir::ForeignItemKind::Fn(_, idents, _),\n-                    ..\n-                })) => {\n-                    sugg_call = idents\n-                        .iter()\n-                        .map(|ident| {\n-                            if ident.name != kw::SelfLower {\n-                                ident.to_string()\n-                            } else {\n-                                \"_\".to_string()\n-                            }\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .join(\", \")\n-                }\n-                Some(Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Required(idents)),\n-                    ..\n-                })) => {\n-                    sugg_call = idents\n-                        .iter()\n-                        .map(|ident| {\n-                            if ident.name != kw::SelfLower {\n-                                ident.to_string()\n-                            } else {\n-                                \"_\".to_string()\n-                            }\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .join(\", \")\n-                }\n-                _ => {}\n-            }\n-            err.span_suggestion_verbose(\n-                expr.span.shrink_to_hi(),\n-                &format!(\"use parentheses to {}\", msg),\n-                format!(\"({})\", sugg_call),\n-                applicability,\n-            );\n-            return true;\n-        }\n-        false\n-    }\n-\n-    pub fn suggest_deref_ref_or_into(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n-    ) {\n-        if let Some((sp, msg, suggestion, applicability)) = self.check_ref(expr, found, expected) {\n-            err.span_suggestion(sp, msg, suggestion, applicability);\n-        } else if let (ty::FnDef(def_id, ..), true) =\n-            (&found.kind(), self.suggest_fn_call(err, expr, expected, found))\n-        {\n-            if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n-                let sp = self.sess().source_map().guess_head_span(sp);\n-                err.span_label(sp, &format!(\"{} defined here\", found));\n-            }\n-        } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n-            let is_struct_pat_shorthand_field =\n-                self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n-            let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n-            if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n-                let mut suggestions = iter::repeat(&expr_text)\n-                    .zip(methods.iter())\n-                    .filter_map(|(receiver, method)| {\n-                        let method_call = format!(\".{}()\", method.ident);\n-                        if receiver.ends_with(&method_call) {\n-                            None // do not suggest code that is already there (#53348)\n-                        } else {\n-                            let method_call_list = [\".to_vec()\", \".to_string()\"];\n-                            let sugg = if receiver.ends_with(\".clone()\")\n-                                && method_call_list.contains(&method_call.as_str())\n-                            {\n-                                let max_len = receiver.rfind('.').unwrap();\n-                                format!(\"{}{}\", &receiver[..max_len], method_call)\n-                            } else {\n-                                if expr.precedence().order() < ExprPrecedence::MethodCall.order() {\n-                                    format!(\"({}){}\", receiver, method_call)\n-                                } else {\n-                                    format!(\"{}{}\", receiver, method_call)\n-                                }\n-                            };\n-                            Some(if is_struct_pat_shorthand_field {\n-                                format!(\"{}: {}\", receiver, sugg)\n-                            } else {\n-                                sugg\n-                            })\n-                        }\n-                    })\n-                    .peekable();\n-                if suggestions.peek().is_some() {\n-                    err.span_suggestions(\n-                        expr.span,\n-                        \"try using a conversion method\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n-    /// in the heap by calling `Box::new()`.\n-    pub(super) fn suggest_boxing_when_appropriate(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-    ) {\n-        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n-            // Do not suggest `Box::new` in const context.\n-            return;\n-        }\n-        if !expected.is_box() || found.is_box() {\n-            return;\n-        }\n-        let boxed_found = self.tcx.mk_box(found);\n-        if let (true, Ok(snippet)) = (\n-            self.can_coerce(boxed_found, expected),\n-            self.sess().source_map().span_to_snippet(expr.span),\n-        ) {\n-            err.span_suggestion(\n-                expr.span,\n-                \"store this in the heap by calling `Box::new`\",\n-                format!(\"Box::new({})\", snippet),\n-                Applicability::MachineApplicable,\n-            );\n-            err.note(\n-                \"for more on the distinction between the stack and the heap, read \\\n-                 https://doc.rust-lang.org/book/ch15-01-box.html, \\\n-                 https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n-                 https://doc.rust-lang.org/std/boxed/index.html\",\n-            );\n-        }\n-    }\n-\n     pub(super) fn note_internal_mutation_in_method(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -2189,243 +1916,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n-    pub(super) fn suggest_calling_boxed_future_when_appropriate(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-    ) -> bool {\n-        // Handle #68197.\n-\n-        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n-            // Do not suggest `Box::new` in const context.\n-            return false;\n-        }\n-        let pin_did = self.tcx.lang_items().pin_type();\n-        match expected.kind() {\n-            ty::Adt(def, _) if Some(def.did) != pin_did => return false,\n-            // This guards the `unwrap` and `mk_box` below.\n-            _ if pin_did.is_none() || self.tcx.lang_items().owned_box().is_none() => return false,\n-            _ => {}\n-        }\n-        let boxed_found = self.tcx.mk_box(found);\n-        let new_found = self.tcx.mk_lang_item(boxed_found, LangItem::Pin).unwrap();\n-        if let (true, Ok(snippet)) = (\n-            self.can_coerce(new_found, expected),\n-            self.sess().source_map().span_to_snippet(expr.span),\n-        ) {\n-            match found.kind() {\n-                ty::Adt(def, _) if def.is_box() => {\n-                    err.help(\"use `Box::pin`\");\n-                }\n-                _ => {\n-                    err.span_suggestion(\n-                        expr.span,\n-                        \"you need to pin and box this expression\",\n-                        format!(\"Box::pin({})\", snippet),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// A common error is to forget to add a semicolon at the end of a block, e.g.,\n-    ///\n-    /// ```\n-    /// fn foo() {\n-    ///     bar_that_returns_u32()\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the return expression in a block would make sense on its own as a\n-    /// statement and the return type has been left as default or has been specified as `()`. If so,\n-    /// it suggests adding a semicolon.\n-    fn suggest_missing_semicolon(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expression: &'tcx hir::Expr<'tcx>,\n-        expected: Ty<'tcx>,\n-        cause_span: Span,\n-    ) {\n-        if expected.is_unit() {\n-            // `BlockTailExpression` only relevant if the tail expr would be\n-            // useful on its own.\n-            match expression.kind {\n-                ExprKind::Call(..)\n-                | ExprKind::MethodCall(..)\n-                | ExprKind::Loop(..)\n-                | ExprKind::Match(..)\n-                | ExprKind::Block(..) => {\n-                    err.span_suggestion(\n-                        cause_span.shrink_to_hi(),\n-                        \"try adding a semicolon\",\n-                        \";\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                _ => (),\n-            }\n-        }\n-    }\n-\n-    /// A possible error is to forget to add a return type that is needed:\n-    ///\n-    /// ```\n-    /// fn foo() {\n-    ///     bar_that_returns_u32()\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the return type is left as default, the method is not part of an\n-    /// `impl` block and that it isn't the `main` method. If so, it suggests setting the return\n-    /// type.\n-    pub(super) fn suggest_missing_return_type(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        fn_decl: &hir::FnDecl<'_>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-        can_suggest: bool,\n-    ) -> bool {\n-        // Only suggest changing the return type for methods that\n-        // haven't set a return type at all (and aren't `fn main()` or an impl).\n-        match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_unit()) {\n-            (&hir::FnRetTy::DefaultReturn(span), true, true, true) => {\n-                err.span_suggestion(\n-                    span,\n-                    \"try adding a return type\",\n-                    format!(\"-> {} \", self.resolve_vars_with_obligations(found)),\n-                    Applicability::MachineApplicable,\n-                );\n-                true\n-            }\n-            (&hir::FnRetTy::DefaultReturn(span), false, true, true) => {\n-                err.span_label(span, \"possibly return type missing here?\");\n-                true\n-            }\n-            (&hir::FnRetTy::DefaultReturn(span), _, false, true) => {\n-                // `fn main()` must return `()`, do not suggest changing return type\n-                err.span_label(span, \"expected `()` because of default return type\");\n-                true\n-            }\n-            // expectation was caused by something else, not the default return\n-            (&hir::FnRetTy::DefaultReturn(_), _, _, false) => false,\n-            (&hir::FnRetTy::Return(ref ty), _, _, _) => {\n-                // Only point to return type if the expected type is the return type, as if they\n-                // are not, the expectation must have been caused by something else.\n-                debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n-                let sp = ty.span;\n-                let ty = AstConv::ast_ty_to_ty(self, ty);\n-                debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n-                debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n-                if ty.kind() == expected.kind() {\n-                    err.span_label(sp, format!(\"expected `{}` because of return type\", expected));\n-                    return true;\n-                }\n-                false\n-            }\n-        }\n-    }\n-\n-    /// A possible error is to forget to add `.await` when using futures:\n-    ///\n-    /// ```\n-    /// async fn make_u32() -> u32 {\n-    ///     22\n-    /// }\n-    ///\n-    /// fn take_u32(x: u32) {}\n-    ///\n-    /// async fn foo() {\n-    ///     let x = make_u32();\n-    ///     take_u32(x);\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n-    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n-    /// `.await` to the tail of the expression.\n-    pub(super) fn suggest_missing_await(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-    ) {\n-        debug!(\"suggest_missing_await: expr={:?} expected={:?}, found={:?}\", expr, expected, found);\n-        // `.await` is not permitted outside of `async` bodies, so don't bother to suggest if the\n-        // body isn't `async`.\n-        let item_id = self.tcx().hir().get_parent_node(self.body_id);\n-        if let Some(body_id) = self.tcx().hir().maybe_body_owned_by(item_id) {\n-            let body = self.tcx().hir().body(body_id);\n-            if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n-                let sp = expr.span;\n-                // Check for `Future` implementations by constructing a predicate to\n-                // prove: `<T as Future>::Output == U`\n-                let future_trait = self.tcx.require_lang_item(LangItem::Future, Some(sp));\n-                let item_def_id = self\n-                    .tcx\n-                    .associated_items(future_trait)\n-                    .in_definition_order()\n-                    .next()\n-                    .unwrap()\n-                    .def_id;\n-                // `<T as Future>::Output`\n-                let projection_ty = ty::ProjectionTy {\n-                    // `T`\n-                    substs: self\n-                        .tcx\n-                        .mk_substs_trait(found, self.fresh_substs_for_item(sp, item_def_id)),\n-                    // `Future::Output`\n-                    item_def_id,\n-                };\n-\n-                let predicate = ty::PredicateAtom::Projection(ty::ProjectionPredicate {\n-                    projection_ty,\n-                    ty: expected,\n-                })\n-                .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n-                let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n-\n-                debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);\n-\n-                if self.infcx.predicate_may_hold(&obligation) {\n-                    debug!(\"suggest_missing_await: obligation held: {:?}\", obligation);\n-                    if let Ok(code) = self.sess().source_map().span_to_snippet(sp) {\n-                        err.span_suggestion(\n-                            sp,\n-                            \"consider using `.await` here\",\n-                            format!(\"{}.await\", code),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        debug!(\"suggest_missing_await: no snippet for {:?}\", sp);\n-                    }\n-                } else {\n-                    debug!(\"suggest_missing_await: obligation did not hold: {:?}\", obligation)\n-                }\n-            }\n-        }\n-    }\n-\n-    pub(super) fn suggest_missing_parentheses(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-    ) {\n-        let sp = self.tcx.sess.source_map().start_point(expr.span);\n-        if let Some(sp) = self.tcx.sess.parse_sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n-            // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`\n-            self.tcx.sess.parse_sess.expr_parentheses_needed(err, *sp, None);\n-        }\n-    }\n-\n     pub(super) fn note_need_for_fn_pointer(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "19988938a49bc1f7ed722344720a1af502470d87", "filename": "compiler/rustc_typeck/src/check/fn_ctxt_suggestions.rs", "status": "added", "additions": 524, "deletions": 0, "changes": 524, "blob_url": "https://github.com/rust-lang/rust/blob/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_suggestions.rs?ref=16d0205d5c161ceb2a442ce8b4a938ecc3eb687d", "patch": "@@ -0,0 +1,524 @@\n+use super::FnCtxt;\n+use crate::astconv::AstConv;\n+\n+use rustc_ast::util::parser::ExprPrecedence;\n+use rustc_span::{self, Span};\n+use rustc_trait_selection::traits;\n+\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def::{CtorOf, DefKind};\n+use rustc_hir::lang_items::LangItem;\n+use rustc_hir::{ExprKind, ItemKind, Node};\n+use rustc_infer::infer;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::kw;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n+\n+use std::iter;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut DiagnosticBuilder<'_>) {\n+        err.span_suggestion_short(\n+            span.shrink_to_hi(),\n+            \"consider using a semicolon here\",\n+            \";\".to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n+    /// On implicit return expressions with mismatched types, provides the following suggestions:\n+    ///\n+    /// - Points out the method's return type as the reason for the expected type.\n+    /// - Possible missing semicolon.\n+    /// - Possible missing return type if the return type is the default, and not `fn main()`.\n+    pub fn suggest_mismatched_types_on_tail(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        cause_span: Span,\n+        blk_id: hir::HirId,\n+    ) -> bool {\n+        let expr = expr.peel_drop_temps();\n+        self.suggest_missing_semicolon(err, expr, expected, cause_span);\n+        let mut pointing_at_return_type = false;\n+        if let Some((fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n+            pointing_at_return_type =\n+                self.suggest_missing_return_type(err, &fn_decl, expected, found, can_suggest);\n+        }\n+        pointing_at_return_type\n+    }\n+\n+    /// When encountering an fn-like ctor that needs to unify with a value, check whether calling\n+    /// the ctor would successfully solve the type mismatch and if so, suggest it:\n+    /// ```\n+    /// fn foo(x: usize) -> usize { x }\n+    /// let x: usize = foo;  // suggest calling the `foo` function: `foo(42)`\n+    /// ```\n+    fn suggest_fn_call(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        let hir = self.tcx.hir();\n+        let (def_id, sig) = match *found.kind() {\n+            ty::FnDef(def_id, _) => (def_id, found.fn_sig(self.tcx)),\n+            ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig()),\n+            _ => return false,\n+        };\n+\n+        let sig = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, &sig).0;\n+        let sig = self.normalize_associated_types_in(expr.span, &sig);\n+        if self.can_coerce(sig.output(), expected) {\n+            let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n+                (String::new(), Applicability::MachineApplicable)\n+            } else {\n+                (\"...\".to_string(), Applicability::HasPlaceholders)\n+            };\n+            let mut msg = \"call this function\";\n+            match hir.get_if_local(def_id) {\n+                Some(\n+                    Node::Item(hir::Item { kind: ItemKind::Fn(.., body_id), .. })\n+                    | Node::ImplItem(hir::ImplItem {\n+                        kind: hir::ImplItemKind::Fn(_, body_id), ..\n+                    })\n+                    | Node::TraitItem(hir::TraitItem {\n+                        kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Provided(body_id)),\n+                        ..\n+                    }),\n+                ) => {\n+                    let body = hir.body(*body_id);\n+                    sugg_call = body\n+                        .params\n+                        .iter()\n+                        .map(|param| match &param.pat.kind {\n+                            hir::PatKind::Binding(_, _, ident, None)\n+                                if ident.name != kw::SelfLower =>\n+                            {\n+                                ident.to_string()\n+                            }\n+                            _ => \"_\".to_string(),\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \");\n+                }\n+                Some(Node::Expr(hir::Expr {\n+                    kind: ExprKind::Closure(_, _, body_id, _, _),\n+                    span: full_closure_span,\n+                    ..\n+                })) => {\n+                    if *full_closure_span == expr.span {\n+                        return false;\n+                    }\n+                    msg = \"call this closure\";\n+                    let body = hir.body(*body_id);\n+                    sugg_call = body\n+                        .params\n+                        .iter()\n+                        .map(|param| match &param.pat.kind {\n+                            hir::PatKind::Binding(_, _, ident, None)\n+                                if ident.name != kw::SelfLower =>\n+                            {\n+                                ident.to_string()\n+                            }\n+                            _ => \"_\".to_string(),\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \");\n+                }\n+                Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n+                    sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n+                    match def_id.as_local().map(|def_id| hir.def_kind(def_id)) {\n+                        Some(DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n+                            msg = \"instantiate this tuple variant\";\n+                        }\n+                        Some(DefKind::Ctor(CtorOf::Struct, _)) => {\n+                            msg = \"instantiate this tuple struct\";\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                Some(Node::ForeignItem(hir::ForeignItem {\n+                    kind: hir::ForeignItemKind::Fn(_, idents, _),\n+                    ..\n+                })) => {\n+                    sugg_call = idents\n+                        .iter()\n+                        .map(|ident| {\n+                            if ident.name != kw::SelfLower {\n+                                ident.to_string()\n+                            } else {\n+                                \"_\".to_string()\n+                            }\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                }\n+                Some(Node::TraitItem(hir::TraitItem {\n+                    kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Required(idents)),\n+                    ..\n+                })) => {\n+                    sugg_call = idents\n+                        .iter()\n+                        .map(|ident| {\n+                            if ident.name != kw::SelfLower {\n+                                ident.to_string()\n+                            } else {\n+                                \"_\".to_string()\n+                            }\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                }\n+                _ => {}\n+            }\n+            err.span_suggestion_verbose(\n+                expr.span.shrink_to_hi(),\n+                &format!(\"use parentheses to {}\", msg),\n+                format!(\"({})\", sugg_call),\n+                applicability,\n+            );\n+            return true;\n+        }\n+        false\n+    }\n+\n+    pub fn suggest_deref_ref_or_into(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n+    ) {\n+        if let Some((sp, msg, suggestion, applicability)) = self.check_ref(expr, found, expected) {\n+            err.span_suggestion(sp, msg, suggestion, applicability);\n+        } else if let (ty::FnDef(def_id, ..), true) =\n+            (&found.kind(), self.suggest_fn_call(err, expr, expected, found))\n+        {\n+            if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n+                let sp = self.sess().source_map().guess_head_span(sp);\n+                err.span_label(sp, &format!(\"{} defined here\", found));\n+            }\n+        } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n+            let is_struct_pat_shorthand_field =\n+                self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n+            let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n+            if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n+                let mut suggestions = iter::repeat(&expr_text)\n+                    .zip(methods.iter())\n+                    .filter_map(|(receiver, method)| {\n+                        let method_call = format!(\".{}()\", method.ident);\n+                        if receiver.ends_with(&method_call) {\n+                            None // do not suggest code that is already there (#53348)\n+                        } else {\n+                            let method_call_list = [\".to_vec()\", \".to_string()\"];\n+                            let sugg = if receiver.ends_with(\".clone()\")\n+                                && method_call_list.contains(&method_call.as_str())\n+                            {\n+                                let max_len = receiver.rfind('.').unwrap();\n+                                format!(\"{}{}\", &receiver[..max_len], method_call)\n+                            } else {\n+                                if expr.precedence().order() < ExprPrecedence::MethodCall.order() {\n+                                    format!(\"({}){}\", receiver, method_call)\n+                                } else {\n+                                    format!(\"{}{}\", receiver, method_call)\n+                                }\n+                            };\n+                            Some(if is_struct_pat_shorthand_field {\n+                                format!(\"{}: {}\", receiver, sugg)\n+                            } else {\n+                                sugg\n+                            })\n+                        }\n+                    })\n+                    .peekable();\n+                if suggestions.peek().is_some() {\n+                    err.span_suggestions(\n+                        expr.span,\n+                        \"try using a conversion method\",\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n+    /// in the heap by calling `Box::new()`.\n+    pub(super) fn suggest_boxing_when_appropriate(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n+            // Do not suggest `Box::new` in const context.\n+            return;\n+        }\n+        if !expected.is_box() || found.is_box() {\n+            return;\n+        }\n+        let boxed_found = self.tcx.mk_box(found);\n+        if let (true, Ok(snippet)) = (\n+            self.can_coerce(boxed_found, expected),\n+            self.sess().source_map().span_to_snippet(expr.span),\n+        ) {\n+            err.span_suggestion(\n+                expr.span,\n+                \"store this in the heap by calling `Box::new`\",\n+                format!(\"Box::new({})\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(\n+                \"for more on the distinction between the stack and the heap, read \\\n+                 https://doc.rust-lang.org/book/ch15-01-box.html, \\\n+                 https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n+                 https://doc.rust-lang.org/std/boxed/index.html\",\n+            );\n+        }\n+    }\n+\n+    /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n+    pub(super) fn suggest_calling_boxed_future_when_appropriate(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        // Handle #68197.\n+\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n+            // Do not suggest `Box::new` in const context.\n+            return false;\n+        }\n+        let pin_did = self.tcx.lang_items().pin_type();\n+        match expected.kind() {\n+            ty::Adt(def, _) if Some(def.did) != pin_did => return false,\n+            // This guards the `unwrap` and `mk_box` below.\n+            _ if pin_did.is_none() || self.tcx.lang_items().owned_box().is_none() => return false,\n+            _ => {}\n+        }\n+        let boxed_found = self.tcx.mk_box(found);\n+        let new_found = self.tcx.mk_lang_item(boxed_found, LangItem::Pin).unwrap();\n+        if let (true, Ok(snippet)) = (\n+            self.can_coerce(new_found, expected),\n+            self.sess().source_map().span_to_snippet(expr.span),\n+        ) {\n+            match found.kind() {\n+                ty::Adt(def, _) if def.is_box() => {\n+                    err.help(\"use `Box::pin`\");\n+                }\n+                _ => {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        \"you need to pin and box this expression\",\n+                        format!(\"Box::pin({})\", snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// A common error is to forget to add a semicolon at the end of a block, e.g.,\n+    ///\n+    /// ```\n+    /// fn foo() {\n+    ///     bar_that_returns_u32()\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the return expression in a block would make sense on its own as a\n+    /// statement and the return type has been left as default or has been specified as `()`. If so,\n+    /// it suggests adding a semicolon.\n+    fn suggest_missing_semicolon(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expression: &'tcx hir::Expr<'tcx>,\n+        expected: Ty<'tcx>,\n+        cause_span: Span,\n+    ) {\n+        if expected.is_unit() {\n+            // `BlockTailExpression` only relevant if the tail expr would be\n+            // useful on its own.\n+            match expression.kind {\n+                ExprKind::Call(..)\n+                | ExprKind::MethodCall(..)\n+                | ExprKind::Loop(..)\n+                | ExprKind::Match(..)\n+                | ExprKind::Block(..) => {\n+                    err.span_suggestion(\n+                        cause_span.shrink_to_hi(),\n+                        \"try adding a semicolon\",\n+                        \";\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    /// A possible error is to forget to add a return type that is needed:\n+    ///\n+    /// ```\n+    /// fn foo() {\n+    ///     bar_that_returns_u32()\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the return type is left as default, the method is not part of an\n+    /// `impl` block and that it isn't the `main` method. If so, it suggests setting the return\n+    /// type.\n+    pub(super) fn suggest_missing_return_type(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        fn_decl: &hir::FnDecl<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        can_suggest: bool,\n+    ) -> bool {\n+        // Only suggest changing the return type for methods that\n+        // haven't set a return type at all (and aren't `fn main()` or an impl).\n+        match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_unit()) {\n+            (&hir::FnRetTy::DefaultReturn(span), true, true, true) => {\n+                err.span_suggestion(\n+                    span,\n+                    \"try adding a return type\",\n+                    format!(\"-> {} \", self.resolve_vars_with_obligations(found)),\n+                    Applicability::MachineApplicable,\n+                );\n+                true\n+            }\n+            (&hir::FnRetTy::DefaultReturn(span), false, true, true) => {\n+                err.span_label(span, \"possibly return type missing here?\");\n+                true\n+            }\n+            (&hir::FnRetTy::DefaultReturn(span), _, false, true) => {\n+                // `fn main()` must return `()`, do not suggest changing return type\n+                err.span_label(span, \"expected `()` because of default return type\");\n+                true\n+            }\n+            // expectation was caused by something else, not the default return\n+            (&hir::FnRetTy::DefaultReturn(_), _, _, false) => false,\n+            (&hir::FnRetTy::Return(ref ty), _, _, _) => {\n+                // Only point to return type if the expected type is the return type, as if they\n+                // are not, the expectation must have been caused by something else.\n+                debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n+                let sp = ty.span;\n+                let ty = AstConv::ast_ty_to_ty(self, ty);\n+                debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n+                debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n+                if ty.kind() == expected.kind() {\n+                    err.span_label(sp, format!(\"expected `{}` because of return type\", expected));\n+                    return true;\n+                }\n+                false\n+            }\n+        }\n+    }\n+\n+    /// A possible error is to forget to add `.await` when using futures:\n+    ///\n+    /// ```\n+    /// async fn make_u32() -> u32 {\n+    ///     22\n+    /// }\n+    ///\n+    /// fn take_u32(x: u32) {}\n+    ///\n+    /// async fn foo() {\n+    ///     let x = make_u32();\n+    ///     take_u32(x);\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n+    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n+    /// `.await` to the tail of the expression.\n+    pub(super) fn suggest_missing_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        debug!(\"suggest_missing_await: expr={:?} expected={:?}, found={:?}\", expr, expected, found);\n+        // `.await` is not permitted outside of `async` bodies, so don't bother to suggest if the\n+        // body isn't `async`.\n+        let item_id = self.tcx().hir().get_parent_node(self.body_id);\n+        if let Some(body_id) = self.tcx().hir().maybe_body_owned_by(item_id) {\n+            let body = self.tcx().hir().body(body_id);\n+            if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n+                let sp = expr.span;\n+                // Check for `Future` implementations by constructing a predicate to\n+                // prove: `<T as Future>::Output == U`\n+                let future_trait = self.tcx.require_lang_item(LangItem::Future, Some(sp));\n+                let item_def_id = self\n+                    .tcx\n+                    .associated_items(future_trait)\n+                    .in_definition_order()\n+                    .next()\n+                    .unwrap()\n+                    .def_id;\n+                // `<T as Future>::Output`\n+                let projection_ty = ty::ProjectionTy {\n+                    // `T`\n+                    substs: self\n+                        .tcx\n+                        .mk_substs_trait(found, self.fresh_substs_for_item(sp, item_def_id)),\n+                    // `Future::Output`\n+                    item_def_id,\n+                };\n+\n+                let predicate = ty::PredicateAtom::Projection(ty::ProjectionPredicate {\n+                    projection_ty,\n+                    ty: expected,\n+                })\n+                .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n+                let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n+\n+                debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);\n+\n+                if self.infcx.predicate_may_hold(&obligation) {\n+                    debug!(\"suggest_missing_await: obligation held: {:?}\", obligation);\n+                    if let Ok(code) = self.sess().source_map().span_to_snippet(sp) {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"consider using `.await` here\",\n+                            format!(\"{}.await\", code),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        debug!(\"suggest_missing_await: no snippet for {:?}\", sp);\n+                    }\n+                } else {\n+                    debug!(\"suggest_missing_await: obligation did not hold: {:?}\", obligation)\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(super) fn suggest_missing_parentheses(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+    ) {\n+        let sp = self.tcx.sess.source_map().start_point(expr.span);\n+        if let Some(sp) = self.tcx.sess.parse_sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+            // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`\n+            self.tcx.sess.parse_sess.expr_parentheses_needed(err, *sp, None);\n+        }\n+    }\n+}"}, {"sha": "ec6c4c89fe16946d362555676ab4e934e2fb19ef", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=16d0205d5c161ceb2a442ce8b4a938ecc3eb687d", "patch": "@@ -77,6 +77,7 @@ mod expectation;\n mod expr;\n mod fn_ctxt;\n mod fn_ctxt_impl;\n+mod fn_ctxt_suggestions;\n mod gather_locals;\n mod generator_interior;\n mod inherited;\n@@ -99,6 +100,7 @@ pub use diverges::Diverges;\n pub use expectation::Expectation;\n pub use fn_ctxt::FnCtxt;\n pub use fn_ctxt_impl::*;\n+pub use fn_ctxt_suggestions::*;\n pub use inherited::{Inherited, InheritedBuilder};\n \n use crate::astconv::AstConv;"}]}