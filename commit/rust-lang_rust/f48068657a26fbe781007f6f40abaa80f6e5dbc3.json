{"sha": "f48068657a26fbe781007f6f40abaa80f6e5dbc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ODA2ODY1N2EyNmZiZTc4MTAwN2Y2ZjQwYWJhYTgwZjZlNWRiYzM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-24T22:10:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-24T22:10:50Z"}, "message": "Merge remote-tracking branch 'sstewartgallus/cleanup_middle' into incoming", "tree": {"sha": "c904834ac458415c7955145abeb9eb68a5d7d26a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c904834ac458415c7955145abeb9eb68a5d7d26a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f48068657a26fbe781007f6f40abaa80f6e5dbc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f48068657a26fbe781007f6f40abaa80f6e5dbc3", "html_url": "https://github.com/rust-lang/rust/commit/f48068657a26fbe781007f6f40abaa80f6e5dbc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f48068657a26fbe781007f6f40abaa80f6e5dbc3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30f8621386776bfa658041c971932840d769f394", "url": "https://api.github.com/repos/rust-lang/rust/commits/30f8621386776bfa658041c971932840d769f394", "html_url": "https://github.com/rust-lang/rust/commit/30f8621386776bfa658041c971932840d769f394"}, {"sha": "0f55c9cc7ec4613bc3f85c25799b6020d57e7605", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f55c9cc7ec4613bc3f85c25799b6020d57e7605", "html_url": "https://github.com/rust-lang/rust/commit/0f55c9cc7ec4613bc3f85c25799b6020d57e7605"}], "stats": {"total": 291, "additions": 128, "deletions": 163}, "files": [{"sha": "f487c73372fad5bdf14a48a6a2579e36692021bf", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f48068657a26fbe781007f6f40abaa80f6e5dbc3/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48068657a26fbe781007f6f40abaa80f6e5dbc3/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=f48068657a26fbe781007f6f40abaa80f6e5dbc3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,7 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n+use core::prelude::*;\n+use core::cast;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n \n@@ -111,6 +112,7 @@ pub static tag_items_data_item_reexport_def_id: uint = 0x4e;\n pub static tag_items_data_item_reexport_name: uint = 0x4f;\n \n // used to encode crate_ctxt side tables\n+#[deriving(Eq)]\n pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_ast = 0x50,\n \n@@ -136,6 +138,16 @@ pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_moves_map = 0x63,\n     tag_table_capture_map = 0x64\n }\n+static first_astencode_tag : uint = tag_ast as uint;\n+static last_astencode_tag : uint = tag_table_capture_map as uint;\n+impl astencode_tag {\n+    pub fn from_uint(value : uint) -> Option<astencode_tag> {\n+        let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;\n+        if !is_a_tag { None } else {\n+            Some(unsafe { cast::transmute(value as int) })\n+        }\n+    }\n+}\n \n pub static tag_item_trait_method_sort: uint = 0x70;\n "}, {"sha": "d405dc0bc2073368739a3d2ec5b5f158c2a781b6", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 89, "deletions": 86, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f48068657a26fbe781007f6f40abaa80f6e5dbc3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48068657a26fbe781007f6f40abaa80f6e5dbc3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f48068657a26fbe781007f6f40abaa80f6e5dbc3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -319,15 +319,10 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     });\n \n     match *ii {\n-      ast::ii_item(i) => {\n-        ast::ii_item(fld.fold_item(i).get()) //hack: we're not dropping items\n-      }\n-      ast::ii_method(d, m) => {\n-        ast::ii_method(d, fld.fold_method(m))\n-      }\n-      ast::ii_foreign(i) => {\n-        ast::ii_foreign(fld.fold_foreign_item(i))\n-      }\n+        //hack: we're not dropping items\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).get()),\n+        ast::ii_method(d, m) => ast::ii_method(d, fld.fold_method(m)),\n+        ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n     }\n }\n \n@@ -346,16 +341,10 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     });\n \n     match ii {\n-      ast::ii_item(i) => {\n-        ast::ii_item(fld.fold_item(i).get())\n-      }\n-      ast::ii_method(d, m) => {\n-        ast::ii_method(xcx.tr_def_id(d), fld.fold_method(m))\n-      }\n-      ast::ii_foreign(i) => {\n-        ast::ii_foreign(fld.fold_foreign_item(i))\n-      }\n-     }\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).get()),\n+        ast::ii_method(d, m) => ast::ii_method(xcx.tr_def_id(d), fld.fold_method(m)),\n+        ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i)),\n+    }\n }\n \n // ______________________________________________________________________\n@@ -374,22 +363,22 @@ fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n impl tr for ast::def {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::def {\n         match *self {\n-          ast::def_fn(did, p) => { ast::def_fn(did.tr(xcx), p) }\n+          ast::def_fn(did, p) => ast::def_fn(did.tr(xcx), p),\n           ast::def_static_method(did, did2_opt, p) => {\n             ast::def_static_method(did.tr(xcx),\n                                    did2_opt.map(|did2| did2.tr(xcx)),\n                                    p)\n-          }\n-          ast::def_self_ty(nid) => { ast::def_self_ty(xcx.tr_id(nid)) }\n-          ast::def_self(nid, i) => { ast::def_self(xcx.tr_id(nid), i) }\n-          ast::def_mod(did) => { ast::def_mod(did.tr(xcx)) }\n-          ast::def_foreign_mod(did) => { ast::def_foreign_mod(did.tr(xcx)) }\n-          ast::def_const(did) => { ast::def_const(did.tr(xcx)) }\n-          ast::def_arg(nid, b) => { ast::def_arg(xcx.tr_id(nid), b) }\n-          ast::def_local(nid, b) => { ast::def_local(xcx.tr_id(nid), b) }\n+          },\n+          ast::def_self_ty(nid) => ast::def_self_ty(xcx.tr_id(nid)),\n+          ast::def_self(nid, i) => ast::def_self(xcx.tr_id(nid), i),\n+          ast::def_mod(did) => ast::def_mod(did.tr(xcx)),\n+          ast::def_foreign_mod(did) => ast::def_foreign_mod(did.tr(xcx)),\n+          ast::def_const(did) => ast::def_const(did.tr(xcx)),\n+          ast::def_arg(nid, b) => ast::def_arg(xcx.tr_id(nid), b),\n+          ast::def_local(nid, b) => ast::def_local(xcx.tr_id(nid), b),\n           ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n-          }\n+          },\n           ast::def_trait(did) => ast::def_trait(did.tr(xcx)),\n           ast::def_ty(did) => ast::def_ty(did.tr(xcx)),\n           ast::def_prim_ty(p) => ast::def_prim_ty(p),\n@@ -402,9 +391,7 @@ impl tr for ast::def {\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n-          ast::def_struct(did) => {\n-            ast::def_struct(did.tr(xcx))\n-          }\n+          ast::def_struct(did) => ast::def_struct(did.tr(xcx)),\n           ast::def_region(nid) => ast::def_region(xcx.tr_id(nid)),\n           ast::def_typaram_binder(nid) => {\n             ast::def_typaram_binder(xcx.tr_id(nid))\n@@ -419,12 +406,9 @@ impl tr for ast::def {\n \n impl tr for ty::AutoAdjustment {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment {\n-        match self {\n-            &ty::AutoAddEnv(r, s) => {\n-                ty::AutoAddEnv(r.tr(xcx), s)\n-            }\n-\n-            &ty::AutoDerefRef(ref adr) => {\n+        match *self {\n+            ty::AutoAddEnv(r, s) => ty::AutoAddEnv(r.tr(xcx), s),\n+            ty::AutoDerefRef(ref adr) => {\n                 ty::AutoDerefRef(ty::AutoDerefRef {\n                     autoderefs: adr.autoderefs,\n                     autoref: adr.autoref.map(|ar| ar.tr(xcx)),\n@@ -1110,56 +1094,75 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 found for id %d (orig %d)\",\n                tag, id, id0);\n \n-        if tag == (c::tag_table_moves_map as uint) {\n-            dcx.maps.moves_map.insert(id);\n-        } else {\n-            let val_doc = entry_doc.get(c::tag_table_val as uint);\n-            let mut val_dsr = reader::Decoder(val_doc);\n-            let val_dsr = &mut val_dsr;\n-            if tag == (c::tag_table_def as uint) {\n-                let def = decode_def(xcx, val_doc);\n-                dcx.tcx.def_map.insert(id, def);\n-            } else if tag == (c::tag_table_node_type as uint) {\n-                let ty = val_dsr.read_ty(xcx);\n-                debug!(\"inserting ty for node %?: %s\",\n-                       id, ty_to_str(dcx.tcx, ty));\n-                dcx.tcx.node_types.insert(id as uint, ty);\n-            } else if tag == (c::tag_table_node_type_subst as uint) {\n-                let tys = val_dsr.read_tys(xcx);\n-                dcx.tcx.node_type_substs.insert(id, tys);\n-            } else if tag == (c::tag_table_freevars as uint) {\n-                let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n-                    @val_dsr.read_freevar_entry(xcx)\n-                });\n-                dcx.tcx.freevars.insert(id, fv_info);\n-            } else if tag == (c::tag_table_tcache as uint) {\n-                let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n-                let lid = ast::def_id { crate: ast::local_crate, node: id };\n-                dcx.tcx.tcache.insert(lid, tpbt);\n-            } else if tag == (c::tag_table_param_defs as uint) {\n-                let bounds = val_dsr.read_type_param_def(xcx);\n-                dcx.tcx.ty_param_defs.insert(id, bounds);\n-            } else if tag == (c::tag_table_method_map as uint) {\n-                dcx.maps.method_map.insert(\n-                    id,\n-                    val_dsr.read_method_map_entry(xcx));\n-            } else if tag == (c::tag_table_vtable_map as uint) {\n-                dcx.maps.vtable_map.insert(id,\n-                                           val_dsr.read_vtable_res(xcx));\n-            } else if tag == (c::tag_table_adjustments as uint) {\n-                let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);\n-                adj.tr(xcx);\n-                dcx.tcx.adjustments.insert(id, adj);\n-            } else if tag == (c::tag_table_capture_map as uint) {\n-                let cvars =\n-                    at_vec::to_managed_consume(\n-                        val_dsr.read_to_vec(\n-                            |val_dsr| val_dsr.read_capture_var(xcx)));\n-                dcx.maps.capture_map.insert(id, cvars);\n-            } else {\n+        match c::astencode_tag::from_uint(tag) {\n+            None => {\n                 xcx.dcx.tcx.sess.bug(\n                     fmt!(\"unknown tag found in side tables: %x\", tag));\n             }\n+            Some(value) => if value == c::tag_table_moves_map {\n+                dcx.maps.moves_map.insert(id);\n+            } else {\n+                let val_doc = entry_doc.get(c::tag_table_val as uint);\n+                let mut val_dsr = reader::Decoder(val_doc);\n+                let val_dsr = &mut val_dsr;\n+\n+                match value {\n+                    c::tag_table_def => {\n+                        let def = decode_def(xcx, val_doc);\n+                        dcx.tcx.def_map.insert(id, def);\n+                    }\n+                    c::tag_table_node_type => {\n+                        let ty = val_dsr.read_ty(xcx);\n+                        debug!(\"inserting ty for node %?: %s\",\n+                               id, ty_to_str(dcx.tcx, ty));\n+                        dcx.tcx.node_types.insert(id as uint, ty);\n+                    }\n+                    c::tag_table_node_type_subst => {\n+                        let tys = val_dsr.read_tys(xcx);\n+                        dcx.tcx.node_type_substs.insert(id, tys);\n+                    }\n+                    c::tag_table_freevars => {\n+                        let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n+                            @val_dsr.read_freevar_entry(xcx)\n+                        });\n+                        dcx.tcx.freevars.insert(id, fv_info);\n+                    }\n+                    c::tag_table_tcache => {\n+                        let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n+                        let lid = ast::def_id { crate: ast::local_crate, node: id };\n+                        dcx.tcx.tcache.insert(lid, tpbt);\n+                    }\n+                    c::tag_table_param_defs => {\n+                        let bounds = val_dsr.read_type_param_def(xcx);\n+                        dcx.tcx.ty_param_defs.insert(id, bounds);\n+                    }\n+                    c::tag_table_method_map => {\n+                        dcx.maps.method_map.insert(\n+                            id,\n+                            val_dsr.read_method_map_entry(xcx));\n+                    }\n+                    c::tag_table_vtable_map => {\n+                        dcx.maps.vtable_map.insert(id,\n+                                                   val_dsr.read_vtable_res(xcx));\n+                    }\n+                    c::tag_table_adjustments => {\n+                        let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);\n+                        adj.tr(xcx);\n+                        dcx.tcx.adjustments.insert(id, adj);\n+                    }\n+                    c::tag_table_capture_map => {\n+                        let cvars =\n+                            at_vec::to_managed_consume(\n+                                val_dsr.read_to_vec(\n+                                    |val_dsr| val_dsr.read_capture_var(xcx)));\n+                        dcx.maps.capture_map.insert(id, cvars);\n+                    }\n+                    _ => {\n+                        xcx.dcx.tcx.sess.bug(\n+                            fmt!(\"unknown tag found in side tables: %x\", tag));\n+                    }\n+                }\n+            }\n         }\n \n         debug!(\">< Side table doc loaded\");"}, {"sha": "3f020a5b3a6a198ac335349b318ef18c3a93ee70", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f48068657a26fbe781007f6f40abaa80f6e5dbc3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48068657a26fbe781007f6f40abaa80f6e5dbc3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=f48068657a26fbe781007f6f40abaa80f6e5dbc3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -235,22 +235,17 @@ pub fn check_item_recursion(sess: Session,\n \n     fn visit_expr(e: @expr, (env, v): (env, visit::vt<env>)) {\n         match e.node {\n-          expr_path(*) => {\n-            match env.def_map.find(&e.id) {\n-              Some(&def_const(def_id)) => {\n-                if ast_util::is_local(def_id) {\n-                  match env.ast_map.get_copy(&def_id.node) {\n-                    ast_map::node_item(it, _) => {\n-                      (v.visit_item)(it, (env, v));\n-                    }\n-                    _ => fail!(\"const not bound to an item\")\n-                  }\n-                }\n-              }\n-              _ => ()\n-            }\n-          }\n-          _ => ()\n+            expr_path(*) => match env.def_map.find(&e.id) {\n+                Some(&def_const(def_id)) if ast_util::is_local(def_id) =>\n+                    match env.ast_map.get_copy(&def_id.node) {\n+                        ast_map::node_item(it, _) => {\n+                            (v.visit_item)(it, (env, v));\n+                        }\n+                        _ => fail!(\"const not bound to an item\")\n+                    },\n+                _ => ()\n+            },\n+            _ => ()\n         }\n         visit::visit_expr(e, (env, v));\n     }"}, {"sha": "78bc59c5647d96106c316f33302fb2d00f55afe4", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 13, "deletions": 58, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f48068657a26fbe781007f6f40abaa80f6e5dbc3/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48068657a26fbe781007f6f40abaa80f6e5dbc3/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=f48068657a26fbe781007f6f40abaa80f6e5dbc3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -420,73 +420,28 @@ pub fn lit_to_const(lit: @lit) -> const_val {\n     }\n }\n \n+fn compare_vals<T : Eq + Ord>(a: T, b: T) -> Option<int> {\n+    Some(if a == b { 0 } else if a < b { -1 } else { 1 })\n+}\n pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n-  match (a, b) {\n-    (&const_int(a), &const_int(b)) => {\n-        if a == b {\n-            Some(0)\n-        } else if a < b {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    (&const_uint(a), &const_uint(b)) => {\n-        if a == b {\n-            Some(0)\n-        } else if a < b {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    (&const_float(a), &const_float(b)) => {\n-        if a == b {\n-            Some(0)\n-        } else if a < b {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    (&const_str(ref a), &const_str(ref b)) => {\n-        if (*a) == (*b) {\n-            Some(0)\n-        } else if (*a) < (*b) {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    (&const_bool(a), &const_bool(b)) => {\n-        if a == b {\n-            Some(0)\n-        } else if a < b {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    _ => {\n-        None\n+    match (a, b) {\n+        (&const_int(a), &const_int(b)) => compare_vals(a, b),\n+        (&const_uint(a), &const_uint(b)) => compare_vals(a, b),\n+        (&const_float(a), &const_float(b)) => compare_vals(a, b),\n+        (&const_str(a), &const_str(b)) => compare_vals(a, b),\n+        (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n+        _ => None\n     }\n-  }\n }\n \n pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> Option<int> {\n     compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n \n pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> Option<bool> {\n-    match compare_lit_exprs(tcx, a, b) {\n-        Some(val) => Some(val == 0),\n-        None =>  None,\n-    }\n+    compare_lit_exprs(tcx, a, b).map(|&val| val == 0)\n }\n \n pub fn lit_eq(a: @lit, b: @lit) -> Option<bool> {\n-    match compare_const_vals(&lit_to_const(a), &lit_to_const(b)) {\n-        Some(val) => Some(val == 0),\n-        None =>  None,\n-    }\n+    compare_const_vals(&lit_to_const(a), &lit_to_const(b)).map(|&val| val == 0)\n }"}]}