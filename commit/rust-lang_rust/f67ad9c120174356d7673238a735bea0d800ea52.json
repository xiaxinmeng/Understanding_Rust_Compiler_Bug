{"sha": "f67ad9c120174356d7673238a735bea0d800ea52", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2N2FkOWMxMjAxNzQzNTZkNzY3MzIzOGE3MzViZWEwZDgwMGVhNTI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-14T16:52:43Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-14T17:42:22Z"}, "message": "Refactoring", "tree": {"sha": "9197a84e7badaece2d62dcf75410f11ec2903a24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9197a84e7badaece2d62dcf75410f11ec2903a24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f67ad9c120174356d7673238a735bea0d800ea52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f67ad9c120174356d7673238a735bea0d800ea52", "html_url": "https://github.com/rust-lang/rust/commit/f67ad9c120174356d7673238a735bea0d800ea52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f67ad9c120174356d7673238a735bea0d800ea52/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0978710ffdddd37b647d65b014d6f348d6fd96e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0978710ffdddd37b647d65b014d6f348d6fd96e8", "html_url": "https://github.com/rust-lang/rust/commit/0978710ffdddd37b647d65b014d6f348d6fd96e8"}], "stats": {"total": 188, "additions": 98, "deletions": 90}, "files": [{"sha": "036ea80d7ee169566763e6812a098562eaa34281", "filename": "src/abi.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f67ad9c120174356d7673238a735bea0d800ea52/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67ad9c120174356d7673238a735bea0d800ea52/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=f67ad9c120174356d7673238a735bea0d800ea52", "patch": "@@ -163,19 +163,6 @@ pub fn get_function_name_and_sig<'a, 'tcx>(\n     (tcx.symbol_name(inst).as_str().to_string(), sig)\n }\n \n-impl<'a, 'tcx: 'a> CodegenCx<'a, 'tcx, CurrentBackend> {\n-    pub fn predefine_function(&mut self, inst: Instance<'tcx>) -> (FuncId, Function) {\n-        let (name, sig) = crate::abi::get_function_name_and_sig(self.tcx, inst);\n-        let func_id = self\n-            .module\n-            .declare_function(&name, Linkage::Export, &sig)\n-            .unwrap();\n-        let func =\n-            Function::with_name_signature(ExternalName::user(0, func_id.index() as u32), sig);\n-        (func_id, func)\n-    }\n-}\n-\n impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n     /// Instance must be monomorphized\n     pub fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n@@ -315,6 +302,8 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, start_ebb\n             }\n         }).collect::<Vec<(Local, ArgKind, Ty)>>();\n \n+    fx.bcx.switch_to_block(start_ebb);\n+\n     match output_pass_mode {\n         PassMode::NoPass => {\n             let null = fx.bcx.ins().iconst(types::I64, 0);\n@@ -418,6 +407,10 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, start_ebb\n \n         fx.local_map.insert(local, place);\n     }\n+\n+    fx.bcx\n+        .ins()\n+        .jump(*fx.ebb_map.get(&START_BLOCK).unwrap(), &[]);\n }\n \n pub fn codegen_call<'a, 'tcx: 'a>("}, {"sha": "1c14c94065ccfb19859a5f6c967befc69112d39c", "filename": "src/base.rs", "status": "modified", "additions": 68, "deletions": 55, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f67ad9c120174356d7673238a735bea0d800ea52/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67ad9c120174356d7673238a735bea0d800ea52/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=f67ad9c120174356d7673238a735bea0d800ea52", "patch": "@@ -2,7 +2,6 @@ use crate::prelude::*;\n \n pub fn trans_mono_item<'a, 'tcx: 'a>(\n     cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>,\n-    context: &mut Context,\n     mono_item: MonoItem<'tcx>,\n ) {\n     let tcx = cx.tcx;\n@@ -21,41 +20,8 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(\n                     String::from_utf8_lossy(&mir.into_inner())\n                 ));\n \n-                let (func_id, mut func) = cx.predefine_function(inst);\n-\n-                let comments = trans_fn(cx, &mut func, inst);\n-\n-                let mut writer = crate::pretty_clif::CommentWriter(comments);\n-                let mut cton = String::new();\n-                ::cranelift::codegen::write::decorate_function(&mut writer, &mut cton, &func, None)\n-                    .unwrap();\n-                tcx.sess.warn(&cton);\n-\n-                let flags = settings::Flags::new(settings::builder());\n-                match ::cranelift::codegen::verify_function(&func, &flags) {\n-                    Ok(_) => {}\n-                    Err(err) => {\n-                        tcx.sess.err(&format!(\"{:?}\", err));\n-                        let pretty_error =\n-                            ::cranelift::codegen::print_errors::pretty_verifier_error(\n-                                &func,\n-                                None,\n-                                Some(Box::new(writer)),\n-                                &err,\n-                            );\n-                        tcx.sess\n-                            .fatal(&format!(\"cretonne verify error:\\n{}\", pretty_error));\n-                    }\n-                }\n-\n-                context.func = func;\n-                // TODO: cranelift doesn't yet support some of the things needed\n-                if should_codegen(cx.tcx) {\n-                    cx.module.define_function(func_id, context).unwrap();\n-                    cx.defined_functions.push(func_id);\n-                }\n-\n-                context.clear();\n+                let func_id = trans_fn(cx.tcx, cx.module, &mut cx.constants, &mut cx.context, inst);\n+                cx.defined_functions.push(func_id);\n             }\n             Instance {\n                 def: InstanceDef::DropGlue(_, _),\n@@ -64,7 +30,7 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(\n             inst => unimpl!(\"Unimplemented instance {:?}\", inst),\n         },\n         MonoItem::Static(def_id) => {\n-            crate::constant::codegen_static(cx, def_id);\n+            crate::constant::codegen_static(&mut cx.constants, def_id);\n         }\n         MonoItem::GlobalAsm(node_id) => cx\n             .tcx\n@@ -73,25 +39,38 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(\n     }\n }\n \n-pub fn trans_fn<'a, 'tcx: 'a>(\n-    cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>,\n-    f: &mut Function,\n+fn trans_fn<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    module: &mut Module<SimpleJITBackend>,\n+    constants: &mut crate::constant::ConstantCx,\n+    context: &mut Context,\n     instance: Instance<'tcx>,\n-) -> HashMap<Inst, String> {\n-    let mir = cx.tcx.optimized_mir(instance.def_id());\n+) -> FuncId {\n+    // Step 1. Get mir\n+    let mir = tcx.optimized_mir(instance.def_id());\n+\n+    // Step 2. Declare function\n+    let (name, sig) = get_function_name_and_sig(tcx, instance);\n+    let func_id = module\n+        .declare_function(&name, Linkage::Export, &sig)\n+        .unwrap();\n+\n+    // Step 3. Make FunctionBuilder\n+    let mut func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n     let mut func_ctx = FunctionBuilderContext::new();\n-    let mut bcx: FunctionBuilder<Variable> = FunctionBuilder::new(f, &mut func_ctx);\n+    let mut bcx: FunctionBuilder<Variable> = FunctionBuilder::new(&mut func, &mut func_ctx);\n \n+    // Step 4. Predefine ebb's\n     let start_ebb = bcx.create_ebb();\n-    bcx.switch_to_block(start_ebb);\n     let mut ebb_map: HashMap<BasicBlock, Ebb> = HashMap::new();\n     for (bb, _bb_data) in mir.basic_blocks().iter_enumerated() {\n         ebb_map.insert(bb, bcx.create_ebb());\n     }\n \n+    // Step 5. Make FunctionCx\n     let mut fx = FunctionCx {\n-        tcx: cx.tcx,\n-        module: &mut cx.module,\n+        tcx,\n+        module,\n         instance,\n         mir,\n         bcx,\n@@ -102,17 +81,53 @@ pub fn trans_fn<'a, 'tcx: 'a>(\n         ebb_map,\n         local_map: HashMap::new(),\n         comments: HashMap::new(),\n-        constants: &mut cx.constants,\n+        constants,\n     };\n-    let fx = &mut fx;\n \n-    crate::abi::codegen_fn_prelude(fx, start_ebb);\n+    // Step 6. Codegen function\n+    crate::abi::codegen_fn_prelude(&mut fx, start_ebb);\n+    codegen_fn_content(&mut fx);\n+\n+    // Step 7. Print function to terminal for debugging\n+    let mut writer = crate::pretty_clif::CommentWriter(fx.comments);\n+    let mut cton = String::new();\n+    ::cranelift::codegen::write::decorate_function(&mut writer, &mut cton, &func, None).unwrap();\n+    tcx.sess.warn(&cton);\n+\n+    // Step 8. Verify function\n+    verify_func(tcx, writer, &func);\n+\n+    // Step 9. Define function\n+    // TODO: cranelift doesn't yet support some of the things needed\n+    if should_codegen(tcx) {\n+        context.func = func;\n+        module.define_function(func_id, context).unwrap();\n+        context.clear();\n+    }\n+\n+    func_id\n+}\n \n-    fx.bcx\n-        .ins()\n-        .jump(*fx.ebb_map.get(&START_BLOCK).unwrap(), &[]);\n+fn verify_func(tcx: TyCtxt, writer: crate::pretty_clif::CommentWriter, func: &Function) {\n+    let flags = settings::Flags::new(settings::builder());\n+    match ::cranelift::codegen::verify_function(&func, &flags) {\n+        Ok(_) => {}\n+        Err(err) => {\n+            tcx.sess.err(&format!(\"{:?}\", err));\n+            let pretty_error = ::cranelift::codegen::print_errors::pretty_verifier_error(\n+                &func,\n+                None,\n+                Some(Box::new(writer)),\n+                &err,\n+            );\n+            tcx.sess\n+                .fatal(&format!(\"cretonne verify error:\\n{}\", pretty_error));\n+        }\n+    }\n+}\n \n-    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n+fn codegen_fn_content<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>) {\n+    for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n         let ebb = fx.get_ebb(bb);\n         fx.bcx.switch_to_block(ebb);\n \n@@ -208,8 +223,6 @@ pub fn trans_fn<'a, 'tcx: 'a>(\n \n     fx.bcx.seal_all_blocks();\n     fx.bcx.finalize();\n-\n-    fx.comments.clone()\n }\n \n fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &Statement<'tcx>) {"}, {"sha": "868bf2a81810175a71d73f364bfa3124f84ec5cb", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f67ad9c120174356d7673238a735bea0d800ea52/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67ad9c120174356d7673238a735bea0d800ea52/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=f67ad9c120174356d7673238a735bea0d800ea52", "patch": "@@ -32,8 +32,8 @@ impl ConstantCx {\n     }\n }\n \n-pub fn codegen_static<'a, 'tcx: 'a, B: Backend>(cx: &mut CodegenCx<'a, 'tcx, B>, def_id: DefId) {\n-    cx.constants.todo.insert(TodoItem::Static(def_id));\n+pub fn codegen_static<'a, 'tcx: 'a>(ccx: &mut ConstantCx, def_id: DefId) {\n+    ccx.todo.insert(TodoItem::Static(def_id));\n }\n \n pub fn codegen_static_ref<'a, 'tcx: 'a>("}, {"sha": "9e6e9acf4c0c4be5ef76e74745ceb4eb99fa723c", "filename": "src/lib.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f67ad9c120174356d7673238a735bea0d800ea52/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67ad9c120174356d7673238a735bea0d800ea52/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f67ad9c120174356d7673238a735bea0d800ea52", "patch": "@@ -103,6 +103,9 @@ pub struct CodegenCx<'a, 'tcx: 'a, B: Backend + 'a> {\n     pub module: &'a mut Module<B>,\n     pub constants: crate::constant::ConstantCx,\n     pub defined_functions: Vec<FuncId>,\n+\n+    // Cache\n+    pub context: Context,\n }\n \n struct CraneliftMetadataLoader;\n@@ -248,16 +251,25 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         let isa = cranelift::codegen::isa::lookup(target_lexicon::Triple::host())\n             .unwrap()\n             .finish(flags);\n-        let mut module: Module<SimpleJITBackend> = Module::new(SimpleJITBuilder::new());\n-        let mut context = Context::new();\n+        let mut jit_module: Module<SimpleJITBackend> = Module::new(SimpleJITBuilder::new());\n+        let mut faerie_module: Module<FaerieBackend> = Module::new(\n+            FaerieBuilder::new(\n+                isa,\n+                \"some_file.o\".to_string(),\n+                FaerieTrapCollection::Disabled,\n+                FaerieBuilder::default_libcall_names(),\n+            ).unwrap(),\n+        );\n \n         let defined_functions = {\n             use std::io::Write;\n             let mut cx = CodegenCx {\n                 tcx,\n-                module: &mut module,\n+                module: &mut jit_module,\n                 constants: Default::default(),\n                 defined_functions: Vec::new(),\n+\n+                context: Context::new(),\n             };\n \n             let mut log = ::std::fs::File::create(\"target/log.txt\").unwrap();\n@@ -273,9 +285,8 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n             for mono_item in mono_items {\n                 let cx = &mut cx;\n-                let context = &mut context;\n                 let res = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(move || {\n-                    base::trans_mono_item(cx, context, mono_item);\n+                    base::trans_mono_item(cx, mono_item);\n                 }));\n                 if let Err(err) = res {\n                     match err.downcast::<NonFatal>() {\n@@ -304,43 +315,34 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n             let (name, sig) =\n                 crate::abi::get_function_name_and_sig(tcx, Instance::mono(tcx, start_wrapper));\n-            let called_func_id = module\n+            let called_func_id = jit_module\n                 .declare_function(&name, Linkage::Import, &sig)\n                 .unwrap();\n \n             for func_id in defined_functions {\n                 if func_id != called_func_id {\n-                    module.finalize_function(func_id);\n+                    jit_module.finalize_function(func_id);\n                 }\n             }\n             tcx.sess.warn(\"Finalized everything\");\n \n-            let finalized_function: *const u8 = module.finalize_function(called_func_id);\n+            let finalized_function: *const u8 = jit_module.finalize_function(called_func_id);\n             let f: extern \"C\" fn(*const u8, isize, *const *const u8) -> isize =\n                 unsafe { ::std::mem::transmute(finalized_function) };\n             let res = f(0 as *const u8, 0, 0 as *const _);\n             tcx.sess.warn(&format!(\"main returned {}\", res));\n \n-            module.finish();\n+            jit_module.finish();\n         } else if should_codegen(tcx) {\n             for func_id in defined_functions {\n-                module.finalize_function(func_id);\n+                jit_module.finalize_function(func_id);\n             }\n \n             tcx.sess.warn(\"Finalized everything\");\n         }\n \n-        let mut translated_module: Module<FaerieBackend> = Module::new(\n-            FaerieBuilder::new(\n-                isa,\n-                \"some_file.o\".to_string(),\n-                FaerieTrapCollection::Disabled,\n-                FaerieBuilder::default_libcall_names(),\n-            ).unwrap(),\n-        );\n-\n         Box::new(OngoingCodegen {\n-            product: translated_module.finish(),\n+            product: faerie_module.finish(),\n             metadata: metadata.raw_data,\n             crate_name: tcx.crate_name(LOCAL_CRATE),\n         })"}]}