{"sha": "417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "node_id": "C_kwDOAAsO6NoAKDQxN2VkOWZlZTIwYTk3N2FhYThlM2Y4YThmNzk5Yjg1ODA3NzlmYjc", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-16T19:26:38Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-21T09:18:59Z"}, "message": "Remove `ref` patterns from `rustc_ast`\n\nAlso use if let chains in one case.", "tree": {"sha": "64521a15c341c22c70695fe1517ced0fd0610593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64521a15c341c22c70695fe1517ced0fd0610593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "html_url": "https://github.com/rust-lang/rust/commit/417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "736c675d2ab65bcde6554e1b73340c2dbc27c85a", "url": "https://api.github.com/repos/rust-lang/rust/commits/736c675d2ab65bcde6554e1b73340c2dbc27c85a", "html_url": "https://github.com/rust-lang/rust/commit/736c675d2ab65bcde6554e1b73340c2dbc27c85a"}], "stats": {"total": 438, "additions": 214, "deletions": 224}, "files": [{"sha": "4ad9981991d308196dee93a57497468df1269d73", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "patch": "@@ -175,9 +175,9 @@ impl GenericArgs {\n     }\n \n     pub fn span(&self) -> Span {\n-        match *self {\n-            AngleBracketed(ref data) => data.span,\n-            Parenthesized(ref data) => data.span,\n+        match self {\n+            AngleBracketed(data) => data.span,\n+            Parenthesized(data) => data.span,\n         }\n     }\n }\n@@ -312,8 +312,8 @@ pub enum GenericBound {\n impl GenericBound {\n     pub fn span(&self) -> Span {\n         match self {\n-            GenericBound::Trait(ref t, ..) => t.span,\n-            GenericBound::Outlives(ref l) => l.ident.span,\n+            GenericBound::Trait(t, ..) => t.span,\n+            GenericBound::Outlives(l) => l.ident.span,\n         }\n     }\n }\n@@ -1115,23 +1115,23 @@ impl Expr {\n     /// If this is not the case, name resolution does not resolve `N` when using\n     /// `min_const_generics` as more complex expressions are not supported.\n     pub fn is_potential_trivial_const_param(&self) -> bool {\n-        let this = if let ExprKind::Block(ref block, None) = self.kind {\n-            if block.stmts.len() == 1 {\n-                if let StmtKind::Expr(ref expr) = block.stmts[0].kind { expr } else { self }\n-            } else {\n-                self\n-            }\n+        let this = if let ExprKind::Block(block, None) = &self.kind\n+            && block.stmts.len() == 1\n+            && let StmtKind::Expr(expr) = &block.stmts[0].kind\n+        {\n+            expr\n         } else {\n             self\n         };\n \n-        if let ExprKind::Path(None, ref path) = this.kind {\n-            if path.segments.len() == 1 && path.segments[0].args.is_none() {\n-                return true;\n-            }\n+        if let ExprKind::Path(None, path) = &this.kind\n+            && path.segments.len() == 1\n+            && path.segments[0].args.is_none()\n+        {\n+            true\n+        } else {\n+            false\n         }\n-\n-        false\n     }\n \n     pub fn to_bound(&self) -> Option<GenericBound> {\n@@ -2393,9 +2393,9 @@ pub enum FnRetTy {\n \n impl FnRetTy {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            FnRetTy::Default(span) => span,\n-            FnRetTy::Ty(ref ty) => ty.span,\n+        match self {\n+            &FnRetTy::Default(span) => span,\n+            FnRetTy::Ty(ty) => ty.span,\n         }\n     }\n }\n@@ -2657,8 +2657,8 @@ pub enum VariantData {\n impl VariantData {\n     /// Return the fields of this variant.\n     pub fn fields(&self) -> &[FieldDef] {\n-        match *self {\n-            VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, _) => fields,\n+        match self {\n+            VariantData::Struct(fields, ..) | VariantData::Tuple(fields, _) => fields,\n             _ => &[],\n         }\n     }"}, {"sha": "b7be94dde480eb205e41db5aeca2718d1ce1f02d", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "patch": "@@ -44,16 +44,16 @@ impl MarkedAttrs {\n impl NestedMetaItem {\n     /// Returns the `MetaItem` if `self` is a `NestedMetaItem::MetaItem`.\n     pub fn meta_item(&self) -> Option<&MetaItem> {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => Some(item),\n+        match self {\n+            NestedMetaItem::MetaItem(item) => Some(item),\n             _ => None,\n         }\n     }\n \n     /// Returns the `Lit` if `self` is a `NestedMetaItem::Literal`s.\n     pub fn literal(&self) -> Option<&Lit> {\n-        match *self {\n-            NestedMetaItem::Literal(ref lit) => Some(lit),\n+        match self {\n+            NestedMetaItem::Literal(lit) => Some(lit),\n             _ => None,\n         }\n     }\n@@ -116,18 +116,18 @@ impl NestedMetaItem {\n impl Attribute {\n     #[inline]\n     pub fn has_name(&self, name: Symbol) -> bool {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal.item.path == name,\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.path == name,\n             AttrKind::DocComment(..) => false,\n         }\n     }\n \n     /// For a single-segment attribute, returns its name; otherwise, returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => {\n-                if normal.item.path.segments.len() == 1 {\n-                    Some(normal.item.path.segments[0].ident)\n+        match &self.kind {\n+            AttrKind::Normal(normal) => {\n+                if let [ident] = &*normal.item.path.segments {\n+                    Some(ident.ident)\n                 } else {\n                     None\n                 }\n@@ -140,17 +140,15 @@ impl Attribute {\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => {\n-                normal.item.meta_kind().and_then(|kind| kind.value_str())\n-            }\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta_kind().and_then(|kind| kind.value_str()),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => match normal.item.meta_kind() {\n+        match &self.kind {\n+            AttrKind::Normal(normal) => match normal.item.meta_kind() {\n                 Some(MetaItemKind::List(list)) => Some(list),\n                 _ => None,\n             },\n@@ -191,8 +189,8 @@ impl MetaItem {\n     }\n \n     pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n-        match self.kind {\n-            MetaItemKind::List(ref l) => Some(&l[..]),\n+        match &self.kind {\n+            MetaItemKind::List(l) => Some(&**l),\n             _ => None,\n         }\n     }\n@@ -268,9 +266,9 @@ impl Attribute {\n     /// * `#[doc = \"doc\"]` returns `Some(\"doc\")`.\n     /// * `#[doc(...)]` returns `None`.\n     pub fn doc_str(&self) -> Option<Symbol> {\n-        match self.kind {\n-            AttrKind::DocComment(.., data) => Some(data),\n-            AttrKind::Normal(ref normal) if normal.item.path == sym::doc => {\n+        match &self.kind {\n+            AttrKind::DocComment(.., data) => Some(*data),\n+            AttrKind::Normal(normal) if normal.item.path == sym::doc => {\n                 normal.item.meta_kind().and_then(|kind| kind.value_str())\n             }\n             _ => None,\n@@ -282,8 +280,8 @@ impl Attribute {\n     }\n \n     pub fn get_normal_item(&self) -> &AttrItem {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => &normal.item,\n+        match &self.kind {\n+            AttrKind::Normal(normal) => &normal.item,\n             AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n         }\n     }\n@@ -297,28 +295,28 @@ impl Attribute {\n \n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal.item.meta(self.span),\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta(self.span),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal.item.meta_kind(),\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta_kind(),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn tokens(&self) -> TokenStream {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal\n                 .tokens\n                 .as_ref()\n                 .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n                 .to_attr_token_stream()\n                 .to_tokenstream(),\n-            AttrKind::DocComment(comment_kind, data) => TokenStream::new(vec![TokenTree::Token(\n+            &AttrKind::DocComment(comment_kind, data) => TokenStream::new(vec![TokenTree::Token(\n                 Token::new(token::DocComment(comment_kind, self.style, data), self.span),\n                 Spacing::Alone,\n             )]),\n@@ -496,17 +494,17 @@ impl MetaItem {\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n                 Path { span, segments, tokens: None }\n             }\n-            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. }, _)) => match *nt {\n-                token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n-                token::Nonterminal::NtPath(ref path) => (**path).clone(),\n+            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. }, _)) => match &*nt {\n+                token::Nonterminal::NtMeta(item) => return item.meta(item.path.span),\n+                token::Nonterminal::NtPath(path) => (**path).clone(),\n                 _ => return None,\n             },\n             _ => return None,\n         };\n         let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi());\n         let kind = MetaItemKind::from_tokens(tokens)?;\n-        let hi = match kind {\n-            MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n+        let hi = match &kind {\n+            MetaItemKind::NameValue(lit) => lit.span.hi(),\n             MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(path.span.hi()),\n             _ => path.span.hi(),\n         };\n@@ -518,8 +516,8 @@ impl MetaItem {\n impl MetaItemKind {\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self {\n-            MetaItemKind::NameValue(ref v) => match v.kind {\n-                LitKind::Str(ref s, _) => Some(*s),\n+            MetaItemKind::NameValue(v) => match v.kind {\n+                LitKind::Str(s, _) => Some(s),\n                 _ => None,\n             },\n             _ => None,\n@@ -557,15 +555,15 @@ impl MetaItemKind {\n     }\n \n     fn token_trees(&self, span: Span) -> Vec<TokenTree> {\n-        match *self {\n+        match self {\n             MetaItemKind::Word => vec![],\n-            MetaItemKind::NameValue(ref lit) => {\n+            MetaItemKind::NameValue(lit) => {\n                 vec![\n                     TokenTree::token_alone(token::Eq, span),\n                     TokenTree::Token(lit.to_token(), Spacing::Alone),\n                 ]\n             }\n-            MetaItemKind::List(ref list) => {\n+            MetaItemKind::List(list) => {\n                 let mut tokens = Vec::new();\n                 for (i, item) in list.iter().enumerate() {\n                     if i > 0 {\n@@ -648,16 +646,16 @@ impl MetaItemKind {\n \n impl NestedMetaItem {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.span,\n-            NestedMetaItem::Literal(ref lit) => lit.span,\n+        match self {\n+            NestedMetaItem::MetaItem(item) => item.span,\n+            NestedMetaItem::Literal(lit) => lit.span,\n         }\n     }\n \n     fn token_trees(&self) -> Vec<TokenTree> {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.token_trees(),\n-            NestedMetaItem::Literal(ref lit) => {\n+        match self {\n+            NestedMetaItem::MetaItem(item) => item.token_trees(),\n+            NestedMetaItem::Literal(lit) => {\n                 vec![TokenTree::Token(lit.to_token(), Spacing::Alone)]\n             }\n         }"}, {"sha": "f9ab5a17570855bcd3fb4351e61de63558510920", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "patch": "@@ -439,15 +439,15 @@ pub fn noop_visit_constraint<T: MutVisitor>(\n ) {\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    if let Some(ref mut gen_args) = gen_args {\n+    if let Some(gen_args) = gen_args {\n         vis.visit_generic_args(gen_args);\n     }\n     match kind {\n-        AssocConstraintKind::Equality { ref mut term } => match term {\n+        AssocConstraintKind::Equality { term } => match term {\n             Term::Ty(ty) => vis.visit_ty(ty),\n             Term::Const(c) => vis.visit_anon_const(c),\n         },\n-        AssocConstraintKind::Bound { ref mut bounds } => visit_bounds(bounds, vis),\n+        AssocConstraintKind::Bound { bounds } => visit_bounds(bounds, vis),\n     }\n     vis.visit_span(span);\n }\n@@ -880,7 +880,7 @@ pub fn noop_flat_map_generic_param<T: MutVisitor>(\n     let GenericParam { id, ident, attrs, bounds, kind, colon_span, is_placeholder: _ } = &mut param;\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    if let Some(ref mut colon_span) = colon_span {\n+    if let Some(colon_span) = colon_span {\n         vis.visit_span(colon_span);\n     }\n     visit_attrs(attrs, vis);"}, {"sha": "cb32925584c58a20dcb191724765c7e0aa9ef84f", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "patch": "@@ -601,17 +601,18 @@ impl Token {\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind && let NtPath(..) = **nt {\n+        if let Interpolated(nt) = &self.kind && let NtPath(..) = **nt {\n             return true;\n         }\n+\n         false\n     }\n \n     /// Would `maybe_whole_expr` in `parser.rs` return `Ok(..)`?\n     /// That is, is this a pre-parsed expression dropped into the token stream\n     /// (which happens while parsing the result of macro expansion)?\n     pub fn is_whole_expr(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind\n+        if let Interpolated(nt) = &self.kind\n             && let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtBlock(_) = **nt\n         {\n             return true;\n@@ -622,9 +623,10 @@ impl Token {\n \n     // Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind && let NtBlock(..) = **nt {\n+        if let Interpolated(nt) = &self.kind && let NtBlock(..) = **nt {\n             return true;\n         }\n+\n         false\n     }\n "}, {"sha": "f65f1f069cba230b790ac60ae97ecbcd3fe94070", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "patch": "@@ -377,26 +377,26 @@ pub fn needs_par_as_let_scrutinee(order: i8) -> bool {\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-    match value.kind {\n+    match &value.kind {\n         ast::ExprKind::Struct(..) => true,\n \n-        ast::ExprKind::Assign(ref lhs, ref rhs, _)\n-        | ast::ExprKind::AssignOp(_, ref lhs, ref rhs)\n-        | ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n+        ast::ExprKind::Assign(lhs, rhs, _)\n+        | ast::ExprKind::AssignOp(_, lhs, rhs)\n+        | ast::ExprKind::Binary(_, lhs, rhs) => {\n             // X { y: 1 } + X { y: 2 }\n             contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n         }\n-        ast::ExprKind::Await(ref x)\n-        | ast::ExprKind::Unary(_, ref x)\n-        | ast::ExprKind::Cast(ref x, _)\n-        | ast::ExprKind::Type(ref x, _)\n-        | ast::ExprKind::Field(ref x, _)\n-        | ast::ExprKind::Index(ref x, _) => {\n+        ast::ExprKind::Await(x)\n+        | ast::ExprKind::Unary(_, x)\n+        | ast::ExprKind::Cast(x, _)\n+        | ast::ExprKind::Type(x, _)\n+        | ast::ExprKind::Field(x, _)\n+        | ast::ExprKind::Index(x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n             contains_exterior_struct_lit(&x)\n         }\n \n-        ast::ExprKind::MethodCall(box ast::MethodCall { ref receiver, .. }) => {\n+        ast::ExprKind::MethodCall(box ast::MethodCall { receiver, .. }) => {\n             // X { y: 1 }.bar(...)\n             contains_exterior_struct_lit(&receiver)\n         }"}, {"sha": "0978fc94d698d11a69bab0a1ea5e6857ddb608c2", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 128, "deletions": 138, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417ed9fee20a977aaa8e3f8a8f799b8580779fb7/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=417ed9fee20a977aaa8e3f8a8f799b8580779fb7", "patch": "@@ -299,74 +299,68 @@ pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitR\n pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n-    match item.kind {\n+    match &item.kind {\n         ItemKind::ExternCrate(_) => {}\n-        ItemKind::Use(ref use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n-        ItemKind::Static(ref typ, _, ref expr) | ItemKind::Const(_, ref typ, ref expr) => {\n+        ItemKind::Use(use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n+        ItemKind::Static(typ, _, expr) | ItemKind::Const(_, typ, expr) => {\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        ItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        ItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind =\n                 FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, generics, body.as_deref());\n             visitor.visit_fn(kind, item.span, item.id)\n         }\n-        ItemKind::Mod(_unsafety, ref mod_kind) => match mod_kind {\n+        ItemKind::Mod(_unsafety, mod_kind) => match mod_kind {\n             ModKind::Loaded(items, _inline, _inner_span) => {\n                 walk_list!(visitor, visit_item, items)\n             }\n             ModKind::Unloaded => {}\n         },\n-        ItemKind::ForeignMod(ref foreign_module) => {\n+        ItemKind::ForeignMod(foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemKind::GlobalAsm(ref asm) => visitor.visit_inline_asm(asm),\n-        ItemKind::TyAlias(box TyAlias { ref generics, ref bounds, ref ty, .. }) => {\n+        ItemKind::GlobalAsm(asm) => visitor.visit_inline_asm(asm),\n+        ItemKind::TyAlias(box TyAlias { generics, bounds, ty, .. }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_ty, ty);\n         }\n-        ItemKind::Enum(ref enum_definition, ref generics) => {\n+        ItemKind::Enum(enum_definition, generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_enum_def(enum_definition)\n         }\n         ItemKind::Impl(box Impl {\n             defaultness: _,\n             unsafety: _,\n-            ref generics,\n+            generics,\n             constness: _,\n             polarity: _,\n-            ref of_trait,\n-            ref self_ty,\n-            ref items,\n+            of_trait,\n+            self_ty,\n+            items,\n         }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_trait_ref, of_trait);\n             visitor.visit_ty(self_ty);\n             walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Impl);\n         }\n-        ItemKind::Struct(ref struct_definition, ref generics)\n-        | ItemKind::Union(ref struct_definition, ref generics) => {\n+        ItemKind::Struct(struct_definition, generics)\n+        | ItemKind::Union(struct_definition, generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_variant_data(struct_definition);\n         }\n-        ItemKind::Trait(box Trait {\n-            unsafety: _,\n-            is_auto: _,\n-            ref generics,\n-            ref bounds,\n-            ref items,\n-        }) => {\n+        ItemKind::Trait(box Trait { unsafety: _, is_auto: _, generics, bounds, items }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::SuperTraits);\n             walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Trait);\n         }\n-        ItemKind::TraitAlias(ref generics, ref bounds) => {\n+        ItemKind::TraitAlias(generics, bounds) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n-        ItemKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n-        ItemKind::MacroDef(ref ts) => visitor.visit_mac_def(ts, item.id),\n+        ItemKind::MacCall(mac) => visitor.visit_mac_call(mac),\n+        ItemKind::MacroDef(ts) => visitor.visit_mac_def(ts, item.id),\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n@@ -399,39 +393,39 @@ pub fn walk_pat_field<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a PatField) {\n }\n \n pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n-    match typ.kind {\n-        TyKind::Slice(ref ty) | TyKind::Paren(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n-        TyKind::Rptr(ref opt_lifetime, ref mutable_type) => {\n+    match &typ.kind {\n+        TyKind::Slice(ty) | TyKind::Paren(ty) => visitor.visit_ty(ty),\n+        TyKind::Ptr(mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Rptr(opt_lifetime, mutable_type) => {\n             walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Rptr);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Tup(ref tuple_element_types) => {\n+        TyKind::Tup(tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n-        TyKind::BareFn(ref function_declaration) => {\n+        TyKind::BareFn(function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n             walk_fn_decl(visitor, &function_declaration.decl);\n         }\n-        TyKind::Path(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+        TyKind::Path(maybe_qself, path) => {\n+            if let Some(qself) = maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, typ.id);\n         }\n-        TyKind::Array(ref ty, ref length) => {\n+        TyKind::Array(ty, length) => {\n             visitor.visit_ty(ty);\n             visitor.visit_anon_const(length)\n         }\n-        TyKind::TraitObject(ref bounds, ..) => {\n+        TyKind::TraitObject(bounds, ..) => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::TraitObject);\n         }\n-        TyKind::ImplTrait(_, ref bounds) => {\n+        TyKind::ImplTrait(_, bounds) => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Impl);\n         }\n-        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n+        TyKind::Typeof(expression) => visitor.visit_anon_const(expression),\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => {}\n-        TyKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        TyKind::MacCall(mac) => visitor.visit_mac_call(mac),\n         TyKind::Never | TyKind::CVarArgs => {}\n     }\n }\n@@ -444,15 +438,15 @@ pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) {\n \n pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree, id: NodeId) {\n     visitor.visit_path(&use_tree.prefix, id);\n-    match use_tree.kind {\n+    match &use_tree.kind {\n         UseTreeKind::Simple(rename, ..) => {\n             // The extra IDs are handled during HIR lowering.\n-            if let Some(rename) = rename {\n+            if let &Some(rename) = rename {\n                 visitor.visit_ident(rename);\n             }\n         }\n         UseTreeKind::Glob => {}\n-        UseTreeKind::Nested(ref use_trees) => {\n+        UseTreeKind::Nested(use_trees) => {\n             for &(ref nested_tree, nested_id) in use_trees {\n                 visitor.visit_use_tree(nested_tree, nested_id, true);\n             }\n@@ -462,7 +456,7 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree,\n \n pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V, segment: &'a PathSegment) {\n     visitor.visit_ident(segment.ident);\n-    if let Some(ref args) = segment.args {\n+    if let Some(args) = &segment.args {\n         visitor.visit_generic_args(args);\n     }\n }\n@@ -471,16 +465,16 @@ pub fn walk_generic_args<'a, V>(visitor: &mut V, generic_args: &'a GenericArgs)\n where\n     V: Visitor<'a>,\n {\n-    match *generic_args {\n-        GenericArgs::AngleBracketed(ref data) => {\n+    match generic_args {\n+        GenericArgs::AngleBracketed(data) => {\n             for arg in &data.args {\n                 match arg {\n                     AngleBracketedArg::Arg(a) => visitor.visit_generic_arg(a),\n                     AngleBracketedArg::Constraint(c) => visitor.visit_assoc_constraint(c),\n                 }\n             }\n         }\n-        GenericArgs::Parenthesized(ref data) => {\n+        GenericArgs::Parenthesized(data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);\n             walk_fn_ret_ty(visitor, &data.output);\n         }\n@@ -500,64 +494,64 @@ where\n \n pub fn walk_assoc_constraint<'a, V: Visitor<'a>>(visitor: &mut V, constraint: &'a AssocConstraint) {\n     visitor.visit_ident(constraint.ident);\n-    if let Some(ref gen_args) = constraint.gen_args {\n+    if let Some(gen_args) = &constraint.gen_args {\n         visitor.visit_generic_args(gen_args);\n     }\n-    match constraint.kind {\n-        AssocConstraintKind::Equality { ref term } => match term {\n+    match &constraint.kind {\n+        AssocConstraintKind::Equality { term } => match term {\n             Term::Ty(ty) => visitor.visit_ty(ty),\n             Term::Const(c) => visitor.visit_anon_const(c),\n         },\n-        AssocConstraintKind::Bound { ref bounds } => {\n+        AssocConstraintKind::Bound { bounds } => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n     }\n }\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n-    match pattern.kind {\n-        PatKind::TupleStruct(ref opt_qself, ref path, ref elems) => {\n-            if let Some(ref qself) = *opt_qself {\n+    match &pattern.kind {\n+        PatKind::TupleStruct(opt_qself, path, elems) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, elems);\n         }\n-        PatKind::Path(ref opt_qself, ref path) => {\n-            if let Some(ref qself) = *opt_qself {\n+        PatKind::Path(opt_qself, path) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id)\n         }\n-        PatKind::Struct(ref opt_qself, ref path, ref fields, _) => {\n-            if let Some(ref qself) = *opt_qself {\n+        PatKind::Struct(opt_qself, path, fields, _) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat_field, fields);\n         }\n-        PatKind::Box(ref subpattern)\n-        | PatKind::Ref(ref subpattern, _)\n-        | PatKind::Paren(ref subpattern) => visitor.visit_pat(subpattern),\n-        PatKind::Ident(_, ident, ref optional_subpattern) => {\n-            visitor.visit_ident(ident);\n+        PatKind::Box(subpattern) | PatKind::Ref(subpattern, _) | PatKind::Paren(subpattern) => {\n+            visitor.visit_pat(subpattern)\n+        }\n+        PatKind::Ident(_, ident, optional_subpattern) => {\n+            visitor.visit_ident(*ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n-        PatKind::Range(ref lower_bound, ref upper_bound, _) => {\n+        PatKind::Lit(expression) => visitor.visit_expr(expression),\n+        PatKind::Range(lower_bound, upper_bound, _) => {\n             walk_list!(visitor, visit_expr, lower_bound);\n             walk_list!(visitor, visit_expr, upper_bound);\n         }\n         PatKind::Wild | PatKind::Rest => {}\n-        PatKind::Tuple(ref elems) | PatKind::Slice(ref elems) | PatKind::Or(ref elems) => {\n+        PatKind::Tuple(elems) | PatKind::Slice(elems) | PatKind::Or(elems) => {\n             walk_list!(visitor, visit_pat, elems);\n         }\n-        PatKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        PatKind::MacCall(mac) => visitor.visit_mac_call(mac),\n     }\n }\n \n pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignItem) {\n-    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    let &Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = item;\n     visitor.visit_vis(vis);\n     visitor.visit_ident(ident);\n     walk_list!(visitor, visit_attribute, attrs);\n@@ -566,7 +560,7 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        ForeignItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        ForeignItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind = FnKind::Fn(FnCtxt::Foreign, ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n@@ -582,22 +576,20 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n }\n \n pub fn walk_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a GenericBound) {\n-    match *bound {\n-        GenericBound::Trait(ref typ, ref _modifier) => visitor.visit_poly_trait_ref(typ),\n-        GenericBound::Outlives(ref lifetime) => {\n-            visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound)\n-        }\n+    match bound {\n+        GenericBound::Trait(typ, _modifier) => visitor.visit_poly_trait_ref(typ),\n+        GenericBound::Outlives(lifetime) => visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound),\n     }\n }\n \n pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a GenericParam) {\n     visitor.visit_ident(param.ident);\n     walk_list!(visitor, visit_attribute, param.attrs.iter());\n     walk_list!(visitor, visit_param_bound, &param.bounds, BoundKind::Bound);\n-    match param.kind {\n+    match &param.kind {\n         GenericParamKind::Lifetime => (),\n-        GenericParamKind::Type { ref default } => walk_list!(visitor, visit_ty, default),\n-        GenericParamKind::Const { ref ty, ref default, .. } => {\n+        GenericParamKind::Type { default } => walk_list!(visitor, visit_ty, default),\n+        GenericParamKind::Const { ty, default, .. } => {\n             visitor.visit_ty(ty);\n             if let Some(default) = default {\n                 visitor.visit_anon_const(default);\n@@ -621,32 +613,30 @@ pub fn walk_closure_binder<'a, V: Visitor<'a>>(visitor: &mut V, binder: &'a Clos\n }\n \n pub fn walk_where_predicate<'a, V: Visitor<'a>>(visitor: &mut V, predicate: &'a WherePredicate) {\n-    match *predicate {\n+    match predicate {\n         WherePredicate::BoundPredicate(WhereBoundPredicate {\n-            ref bounded_ty,\n-            ref bounds,\n-            ref bound_generic_params,\n+            bounded_ty,\n+            bounds,\n+            bound_generic_params,\n             ..\n         }) => {\n             visitor.visit_ty(bounded_ty);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n-        WherePredicate::RegionPredicate(WhereRegionPredicate {\n-            ref lifetime, ref bounds, ..\n-        }) => {\n+        WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, .. }) => {\n             visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n-        WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, .. }) => {\n+        WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n             visitor.visit_ty(lhs_ty);\n             visitor.visit_ty(rhs_ty);\n         }\n     }\n }\n \n pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FnRetTy) {\n-    if let FnRetTy::Ty(ref output_ty) = *ret_ty {\n+    if let FnRetTy::Ty(output_ty) = ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n@@ -675,7 +665,7 @@ pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>) {\n }\n \n pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem, ctxt: AssocCtxt) {\n-    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    let &Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = item;\n     visitor.visit_vis(vis);\n     visitor.visit_ident(ident);\n     walk_list!(visitor, visit_attribute, attrs);\n@@ -684,7 +674,7 @@ pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem,\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        AssocItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        AssocItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n@@ -717,13 +707,13 @@ pub fn walk_block<'a, V: Visitor<'a>>(visitor: &mut V, block: &'a Block) {\n }\n \n pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n-    match statement.kind {\n-        StmtKind::Local(ref local) => visitor.visit_local(local),\n-        StmtKind::Item(ref item) => visitor.visit_item(item),\n-        StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => visitor.visit_expr(expr),\n+    match &statement.kind {\n+        StmtKind::Local(local) => visitor.visit_local(local),\n+        StmtKind::Item(item) => visitor.visit_item(item),\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => visitor.visit_expr(expr),\n         StmtKind::Empty => {}\n-        StmtKind::MacCall(ref mac) => {\n-            let MacCallStmt { ref mac, style: _, ref attrs, tokens: _ } = **mac;\n+        StmtKind::MacCall(mac) => {\n+            let MacCallStmt { mac, attrs, style: _, tokens: _ } = &**mac;\n             visitor.visit_mac_call(mac);\n             for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);\n@@ -760,7 +750,7 @@ pub fn walk_inline_asm<'a, V: Visitor<'a>>(visitor: &mut V, asm: &'a InlineAsm)\n }\n \n pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineAsmSym) {\n-    if let Some(ref qself) = sym.qself {\n+    if let Some(qself) = &sym.qself {\n         visitor.visit_ty(&qself.ty);\n     }\n     visitor.visit_path(&sym.path, sym.id);\n@@ -769,18 +759,18 @@ pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineA\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n-    match expression.kind {\n-        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::Array(ref subexpressions) => {\n+    match &expression.kind {\n+        ExprKind::Box(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::Array(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n-        ExprKind::Repeat(ref element, ref count) => {\n+        ExprKind::ConstBlock(anon_const) => visitor.visit_anon_const(anon_const),\n+        ExprKind::Repeat(element, count) => {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)\n         }\n-        ExprKind::Struct(ref se) => {\n-            if let Some(ref qself) = se.qself {\n+        ExprKind::Struct(se) => {\n+            if let Some(qself) = &se.qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(&se.path, expression.id);\n@@ -791,124 +781,124 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n                 StructRest::None => {}\n             }\n         }\n-        ExprKind::Tup(ref subexpressions) => {\n+        ExprKind::Tup(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprKind::Call(ref callee_expression, ref arguments) => {\n+        ExprKind::Call(callee_expression, arguments) => {\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(box MethodCall { ref seg, ref receiver, ref args, span: _ }) => {\n+        ExprKind::MethodCall(box MethodCall { seg, receiver, args, span: _ }) => {\n             visitor.visit_path_segment(seg);\n             visitor.visit_expr(receiver);\n             walk_list!(visitor, visit_expr, args);\n         }\n-        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n+        ExprKind::Binary(_, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, _, subexpression) | ExprKind::Unary(_, subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n+        ExprKind::Cast(subexpression, typ) | ExprKind::Type(subexpression, typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprKind::Let(ref pat, ref expr, _) => {\n+        ExprKind::Let(pat, expr, _) => {\n             visitor.visit_pat(pat);\n             visitor.visit_expr(expr);\n         }\n-        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n+        ExprKind::If(head_expression, if_block, optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::While(subexpression, block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::ForLoop(pattern, subexpression, block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Loop(ref block, ref opt_label) => {\n+        ExprKind::Loop(block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Match(ref subexpression, ref arms) => {\n+        ExprKind::Match(subexpression, arms) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprKind::Closure(box Closure {\n-            ref binder,\n+            binder,\n             capture_clause: _,\n             asyncness: _,\n             movability: _,\n-            ref fn_decl,\n-            ref body,\n+            fn_decl,\n+            body,\n             fn_decl_span: _,\n         }) => {\n             visitor.visit_fn(FnKind::Closure(binder, fn_decl, body), expression.span, expression.id)\n         }\n-        ExprKind::Block(ref block, ref opt_label) => {\n+        ExprKind::Block(block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Async(_, _, ref body) => {\n+        ExprKind::Async(_, _, body) => {\n             visitor.visit_block(body);\n         }\n-        ExprKind::Await(ref expr) => visitor.visit_expr(expr),\n-        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+        ExprKind::Await(expr) => visitor.visit_expr(expr),\n+        ExprKind::Assign(lhs, rhs, _) => {\n             visitor.visit_expr(lhs);\n             visitor.visit_expr(rhs);\n         }\n-        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+        ExprKind::AssignOp(_, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression);\n         }\n-        ExprKind::Field(ref subexpression, ident) => {\n+        ExprKind::Field(subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident);\n+            visitor.visit_ident(*ident);\n         }\n-        ExprKind::Index(ref main_expression, ref index_expression) => {\n+        ExprKind::Index(main_expression, index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprKind::Range(ref start, ref end, _) => {\n+        ExprKind::Range(start, end, _) => {\n             walk_list!(visitor, visit_expr, start);\n             walk_list!(visitor, visit_expr, end);\n         }\n         ExprKind::Underscore => {}\n-        ExprKind::Path(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+        ExprKind::Path(maybe_qself, path) => {\n+            if let Some(qself) = maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_label, ref opt_expr) => {\n+        ExprKind::Break(opt_label, opt_expr) => {\n             walk_list!(visitor, visit_label, opt_label);\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprKind::Continue(ref opt_label) => {\n+        ExprKind::Continue(opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n         }\n-        ExprKind::Ret(ref optional_expression) => {\n+        ExprKind::Ret(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::Yeet(ref optional_expression) => {\n+        ExprKind::Yeet(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n-        ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::InlineAsm(ref asm) => visitor.visit_inline_asm(asm),\n-        ExprKind::Yield(ref optional_expression) => {\n+        ExprKind::MacCall(mac) => visitor.visit_mac_call(mac),\n+        ExprKind::Paren(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::InlineAsm(asm) => visitor.visit_inline_asm(asm),\n+        ExprKind::Yield(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::Try(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::TryBlock(ref body) => visitor.visit_block(body),\n+        ExprKind::Try(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::TryBlock(body) => visitor.visit_block(body),\n         ExprKind::Lit(_) | ExprKind::IncludedBytes(..) | ExprKind::Err => {}\n     }\n \n@@ -935,8 +925,8 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n }\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n-    match attr.kind {\n-        AttrKind::Normal(ref normal) => walk_mac_args(visitor, &normal.item.args),\n+    match &attr.kind {\n+        AttrKind::Normal(normal) => walk_mac_args(visitor, &normal.item.args),\n         AttrKind::DocComment(..) => {}\n     }\n }"}]}