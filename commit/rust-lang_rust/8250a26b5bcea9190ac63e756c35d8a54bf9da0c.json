{"sha": "8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNTBhMjZiNWJjZWE5MTkwYWM2M2U3NTZjMzVkOGE1NGJmOWRhMGM=", "commit": {"author": {"name": "Sergio Benitez", "email": "sb@sergio.bz", "date": "2016-08-20T01:58:14Z"}, "committer": {"name": "Sergio Benitez", "email": "sb@sergio.bz", "date": "2016-08-25T20:25:22Z"}, "message": "Implement RFC#1559: allow all literals in attributes.", "tree": {"sha": "f95baa037c52c307de53d605ad752afd4880ffa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f95baa037c52c307de53d605ad752afd4880ffa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "html_url": "https://github.com/rust-lang/rust/commit/8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/comments", "author": {"login": "SergioBenitez", "id": 1480321, "node_id": "MDQ6VXNlcjE0ODAzMjE=", "avatar_url": "https://avatars.githubusercontent.com/u/1480321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SergioBenitez", "html_url": "https://github.com/SergioBenitez", "followers_url": "https://api.github.com/users/SergioBenitez/followers", "following_url": "https://api.github.com/users/SergioBenitez/following{/other_user}", "gists_url": "https://api.github.com/users/SergioBenitez/gists{/gist_id}", "starred_url": "https://api.github.com/users/SergioBenitez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SergioBenitez/subscriptions", "organizations_url": "https://api.github.com/users/SergioBenitez/orgs", "repos_url": "https://api.github.com/users/SergioBenitez/repos", "events_url": "https://api.github.com/users/SergioBenitez/events{/privacy}", "received_events_url": "https://api.github.com/users/SergioBenitez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SergioBenitez", "id": 1480321, "node_id": "MDQ6VXNlcjE0ODAzMjE=", "avatar_url": "https://avatars.githubusercontent.com/u/1480321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SergioBenitez", "html_url": "https://github.com/SergioBenitez", "followers_url": "https://api.github.com/users/SergioBenitez/followers", "following_url": "https://api.github.com/users/SergioBenitez/following{/other_user}", "gists_url": "https://api.github.com/users/SergioBenitez/gists{/gist_id}", "starred_url": "https://api.github.com/users/SergioBenitez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SergioBenitez/subscriptions", "organizations_url": "https://api.github.com/users/SergioBenitez/orgs", "repos_url": "https://api.github.com/users/SergioBenitez/repos", "events_url": "https://api.github.com/users/SergioBenitez/events{/privacy}", "received_events_url": "https://api.github.com/users/SergioBenitez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "528c6f3ed6a23a374dc5a40582d1bea2f2cfda65", "url": "https://api.github.com/repos/rust-lang/rust/commits/528c6f3ed6a23a374dc5a40582d1bea2f2cfda65", "html_url": "https://github.com/rust-lang/rust/commit/528c6f3ed6a23a374dc5a40582d1bea2f2cfda65"}], "stats": {"total": 1315, "additions": 942, "deletions": 373}, "files": [{"sha": "350b9fd88f6e76d0e4aaf0550f9fa939b32b9bcb", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -11,7 +11,7 @@\n use session::Session;\n \n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{AttrNestedMetaItemMethods, AttrMetaMethods};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -52,18 +52,22 @@ impl<'a> CheckAttrVisitor<'a> {\n                 return;\n             }\n         };\n+\n         for word in words {\n-            let word: &str = &word.name();\n-            let message = match word {\n+            let name = match word.name() {\n+                Some(word) => word,\n+                None => continue,\n+            };\n+\n+            let message = match &*name {\n                 \"C\" => {\n                     if target != Target::Struct && target != Target::Enum {\n-                            \"attribute should be applied to struct or enum\"\n+                        \"attribute should be applied to struct or enum\"\n                     } else {\n                         continue\n                     }\n                 }\n-                \"packed\" |\n-                \"simd\" => {\n+                \"packed\" | \"simd\" => {\n                     if target != Target::Struct {\n                         \"attribute should be applied to struct\"\n                     } else {\n@@ -74,13 +78,14 @@ impl<'a> CheckAttrVisitor<'a> {\n                 \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n                 \"isize\" | \"usize\" => {\n                     if target != Target::Enum {\n-                            \"attribute should be applied to enum\"\n+                        \"attribute should be applied to enum\"\n                     } else {\n                         continue\n                     }\n                 }\n                 _ => continue,\n             };\n+\n             span_err!(self.sess, attr.span, E0517, \"{}\", message);\n         }\n     }"}, {"sha": "99bd22cc87b1963b736b69eb7f3cc0cdb232c92f", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -12,8 +12,8 @@\n //! and returns a piece of the same type.\n \n use hir::*;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n-use syntax::ast::MetaItemKind;\n+use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_};\n+use syntax::ast::{NestedMetaItem, NestedMetaItemKind, MetaItem, MetaItemKind};\n use hir;\n use syntax_pos::Span;\n use syntax::codemap::{respan, Spanned};\n@@ -38,6 +38,10 @@ pub trait Folder : Sized {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n+    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n+        noop_fold_meta_list_item(list_item, self)\n+    }\n+\n     fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n         noop_fold_meta_item(meta_item, self)\n     }\n@@ -486,13 +490,26 @@ pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attr\n     })\n }\n \n+pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n+    -> NestedMetaItem {\n+    Spanned {\n+        node: match li.node {\n+            NestedMetaItemKind::MetaItem(mi) =>  {\n+                NestedMetaItemKind::MetaItem(fld.fold_meta_item(mi))\n+            },\n+            NestedMetaItemKind::Literal(lit) => NestedMetaItemKind::Literal(lit)\n+        },\n+        span: fld.new_span(li.span)\n+    }\n+}\n+\n pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n     mi.map(|Spanned { node, span }| {\n         Spanned {\n             node: match node {\n                 MetaItemKind::Word(id) => MetaItemKind::Word(id),\n                 MetaItemKind::List(id, mis) => {\n-                    MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+                    MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n                 }\n                 MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s),\n             },"}, {"sha": "bccd217352b70f18283a842a4cf7f2ce2adadba2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -38,7 +38,7 @@ use util::nodemap::FnvHashMap;\n use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr::{self, AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax::parse::token::InternedString;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -372,12 +372,10 @@ pub fn gather_attr(attr: &ast::Attribute)\n         return out;\n     };\n \n-    for meta in metas {\n-        out.push(if meta.is_word() {\n-            Ok((meta.name().clone(), level, meta.span))\n-        } else {\n-            Err(meta.span)\n-        });\n+    for li in metas {\n+        out.push(li.word().map_or(Err(li.span), |word| {\n+            Ok((word.name().clone(), level, word.span))\n+        }));\n     }\n \n     out"}, {"sha": "55c6a4de9df5075d65804396744eea73ad9c0457", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -11,7 +11,7 @@\n use borrowck::BorrowckCtxt;\n \n use syntax::ast::{self, MetaItem};\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -43,8 +43,9 @@ fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem\n         if attr.check_name(\"rustc_mir\") {\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n-                if item.check_name(name) {\n-                    return Some(item.clone())\n+                match item.meta_item() {\n+                    Some(mi) if mi.check_name(name) => return Some(mi.clone()),\n+                    _ => continue\n                 }\n             }\n         }"}, {"sha": "1f3f823d0b8abb2696fd1c1cac6854157d9eda17", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -655,17 +655,19 @@ impl RustcDefaultCalls {\n                         if !allow_unstable_cfg && GatedCfg::gate(&*cfg).is_some() {\n                             continue;\n                         }\n+\n                         if cfg.is_word() {\n                             println!(\"{}\", cfg.name());\n-                        } else if cfg.is_value_str() {\n-                            if let Some(s) = cfg.value_str() {\n-                                println!(\"{}=\\\"{}\\\"\", cfg.name(), s);\n-                            }\n+                        } else if let Some(s) = cfg.value_str() {\n+                            println!(\"{}=\\\"{}\\\"\", cfg.name(), s);\n                         } else if cfg.is_meta_item_list() {\n                             // Right now there are not and should not be any\n                             // MetaItemKind::List items in the configuration returned by\n                             // `build_configuration`.\n-                            panic!(\"MetaItemKind::List encountered in default cfg\")\n+                            panic!(\"Found an unexpected list in cfg attribute '{}'!\", cfg.name())\n+                        } else {\n+                            // There also shouldn't be literals.\n+                            panic!(\"Found an unexpected literal in cfg attribute '{}'!\", cfg.name())\n                         }\n                     }\n                 }"}, {"sha": "482b351481c4ea96611ce9def83bfcc8cf305915", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -56,7 +56,7 @@ use std::env;\n use std::fs::File;\n use std::io::Write;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{AttrNestedMetaItemMethods, AttrMetaMethods};\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n \n@@ -116,31 +116,40 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n         for attr in self.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(IF_THIS_CHANGED) {\n                 let mut id = None;\n-                for meta_item in attr.meta_item_list().unwrap_or_default() {\n-                    if meta_item.is_word() && id.is_none() {\n-                        id = Some(meta_item.name().clone());\n-                    } else {\n-                        // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                        span_bug!(meta_item.span(), \"unexpected meta-item {:?}\", meta_item.node)\n+                for list_item in attr.meta_item_list().unwrap_or_default() {\n+                    match list_item.word() {\n+                        Some(word) if id.is_none() => {\n+                            id = Some(word.name().clone())\n+                        },\n+                        _ => {\n+                            // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                            span_bug!(list_item.span(), \"unexpected list-item {:?}\", list_item.node)\n+                        }\n                     }\n                 }\n+\n                 let id = id.unwrap_or(InternedString::new(ID));\n                 self.if_this_changed.entry(id)\n                                     .or_insert(FnvHashSet())\n                                     .insert((attr.span, def_id, DepNode::Hir(def_id)));\n             } else if attr.check_name(THEN_THIS_WOULD_NEED) {\n                 let mut dep_node_interned = None;\n                 let mut id = None;\n-                for meta_item in attr.meta_item_list().unwrap_or_default() {\n-                    if meta_item.is_word() && dep_node_interned.is_none() {\n-                        dep_node_interned = Some(meta_item.name().clone());\n-                    } else if meta_item.is_word() && id.is_none() {\n-                        id = Some(meta_item.name().clone());\n-                    } else {\n-                        // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                        span_bug!(meta_item.span(), \"unexpected meta-item {:?}\", meta_item.node)\n+                for list_item in attr.meta_item_list().unwrap_or_default() {\n+                    match list_item.word() {\n+                        Some(word) if dep_node_interned.is_none() => {\n+                            dep_node_interned = Some(word.name().clone());\n+                        },\n+                        Some(word) if id.is_none() => {\n+                            id = Some(word.name().clone())\n+                        },\n+                        _ => {\n+                            // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                            span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node)\n+                        }\n                     }\n                 }\n+\n                 let dep_node = match dep_node_interned {\n                     Some(ref n) => {\n                         match DepNode::from_label_string(&n[..], def_id) {"}, {"sha": "f0092ce04d1f6bae88666ae4e5c4105145c46299", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -31,8 +31,8 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::Visitor;\n use rustc_data_structures::fnv::FnvHashSet;\n-use syntax::ast::{self, Attribute, MetaItem};\n-use syntax::attr::AttrMetaMethods;\n+use syntax::ast::{self, Attribute, NestedMetaItem};\n+use syntax::attr::{AttrNestedMetaItemMethods, AttrMetaMethods};\n use syntax::parse::token::InternedString;\n use rustc::ty::TyCtxt;\n \n@@ -71,13 +71,17 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-    fn expect_associated_value(&self, item: &MetaItem) -> InternedString {\n+    fn expect_associated_value(&self, item: &NestedMetaItem) -> InternedString {\n         if let Some(value) = item.value_str() {\n             value\n         } else {\n-            self.tcx.sess.span_fatal(\n-                item.span,\n-                &format!(\"associated value expected for `{}`\", item.name()));\n+            let msg = if let Some(name) = item.name() {\n+                format!(\"associated value expected for `{}`\", name)\n+            } else {\n+                \"expected an associated value\".to_string()\n+            };\n+\n+            self.tcx.sess.span_fatal(item.span, &msg);\n         }\n     }\n "}, {"sha": "9a4eec2d05b7a86432aeffdb37b4e4508e3d96f5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -44,8 +44,8 @@ use lint::{LintPass, LateLintPass};\n use std::collections::HashSet;\n \n use syntax::{ast};\n-use syntax::attr::{self, AttrMetaMethods, AttributeMethods};\n-use syntax_pos::Span;\n+use syntax::attr::{self, AttrMetaMethods, AttrNestedMetaItemMethods, AttributeMethods};\n+use syntax_pos::{Span};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::FnKind;\n@@ -317,7 +317,7 @@ impl LateLintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(&l[..], \"hidden\"),\n+                Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);"}, {"sha": "44c2ffe45ccb4df5f89870d69f2e91e9ee25eee1", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -234,10 +234,13 @@ impl LintPass for UnusedAttributes {\n \n impl LateLintPass for UnusedAttributes {\n     fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n+        debug!(\"checking attribute: {:?}\", attr);\n+\n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n             match ty {\n                 AttributeType::Whitelisted if attr.check_name(name) => {\n+                    debug!(\"{:?} is Whitelisted\", name);\n                     break;\n                 },\n                 _ => ()\n@@ -247,11 +250,13 @@ impl LateLintPass for UnusedAttributes {\n         let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n         for &(ref name, ty) in plugin_attributes.iter() {\n             if ty == AttributeType::Whitelisted && attr.check_name(&name) {\n+                debug!(\"{:?} (plugin attr) is whitelisted with ty {:?}\", name, ty);\n                 break;\n             }\n         }\n \n         if !attr::is_used(attr) {\n+            debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n             let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n@@ -275,6 +280,8 @@ impl LateLintPass for UnusedAttributes {\n                 };\n                 cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n             }\n+        } else {\n+            debug!(\"Attr was used: {:?}\", attr);\n         }\n     }\n }"}, {"sha": "85cf41e42a2737194e583093c55dd389970e0561", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -45,26 +45,13 @@ pub const tag_items_closure_kind: usize = 0x2a;\n pub const tag_items_closure_ty: usize = 0x2b;\n pub const tag_def_key: usize = 0x2c;\n \n-// GAP 0x2d 0x2e\n+// GAP 0x2d 0x34\n \n pub const tag_index: usize = 0x110; // top-level only\n pub const tag_xref_index: usize = 0x111; // top-level only\n pub const tag_xref_data: usize = 0x112; // top-level only\n-\n-pub const tag_meta_item_name_value: usize = 0x2f;\n-\n-pub const tag_meta_item_name: usize = 0x30;\n-\n-pub const tag_meta_item_value: usize = 0x31;\n-\n pub const tag_attributes: usize = 0x101; // top-level only\n \n-pub const tag_attribute: usize = 0x32;\n-\n-pub const tag_meta_item_word: usize = 0x33;\n-\n-pub const tag_meta_item_list: usize = 0x34;\n-\n // The list of crates that this crate depends on\n pub const tag_crate_deps: usize = 0x102; // top-level only\n "}, {"sha": "4dc3d04c4a23be9699425443fe14da7dfd11c360", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -35,8 +35,7 @@ use syntax::ast;\n use syntax::abi::Abi;\n use syntax::codemap;\n use syntax::parse;\n-use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{self, AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax::parse::token::InternedString;\n use syntax::visit;\n use syntax_pos::{self, Span, mk_sp, Pos};"}, {"sha": "b8ed1f7bae63b3f76b9eec39c3dd20be2ef0b0fd", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -56,7 +56,6 @@ use syntax::parse::token;\n use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust;\n-use syntax::ptr::P;\n use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n pub type Cmd<'a> = &'a CrateMetadata;\n@@ -1121,44 +1120,20 @@ pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n     })).collect()\n }\n \n-fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n-    reader::tagged_docs(md, tag_meta_item_word).map(|meta_item_doc| {\n-        let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = token::intern_and_get_ident(nd.as_str());\n-        attr::mk_word_item(n)\n-    }).chain(reader::tagged_docs(md, tag_meta_item_name_value).map(|meta_item_doc| {\n-        let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = token::intern_and_get_ident(nd.as_str());\n-        let v = token::intern_and_get_ident(vd.as_str());\n-        // FIXME (#623): Should be able to decode MetaItemKind::NameValue variants,\n-        // but currently the encoder just drops them\n-        attr::mk_name_value_item_str(n, v)\n-    })).chain(reader::tagged_docs(md, tag_meta_item_list).map(|meta_item_doc| {\n-        let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = token::intern_and_get_ident(nd.as_str());\n-        let subitems = get_meta_items(meta_item_doc);\n-        attr::mk_list_item(n, subitems)\n-    })).collect()\n-}\n-\n fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n-    match reader::maybe_get_doc(md, tag_attributes) {\n-        Some(attrs_d) => {\n-            reader::tagged_docs(attrs_d, tag_attribute).map(|attr_doc| {\n-                let is_sugared_doc = reader::doc_as_u8(\n-                    reader::get_doc(attr_doc, tag_attribute_is_sugared_doc)\n-                ) == 1;\n-                let meta_items = get_meta_items(attr_doc);\n-                // Currently it's only possible to have a single meta item on\n-                // an attribute\n-                assert_eq!(meta_items.len(), 1);\n-                let meta_item = meta_items.into_iter().nth(0).unwrap();\n-                attr::mk_doc_attr_outer(attr::mk_attr_id(), meta_item, is_sugared_doc)\n-            }).collect()\n-        },\n-        None => vec![],\n-    }\n+    reader::maybe_get_doc(md, tag_attributes).map_or(vec![], |attrs_doc| {\n+        let mut decoder = reader::Decoder::new(attrs_doc);\n+        let mut attrs: Vec<ast::Attribute> = decoder.read_opaque(|opaque_decoder, _| {\n+            Decodable::decode(opaque_decoder)\n+        }).unwrap();\n+\n+        // Need new unique IDs: old thread-local IDs won't map to new threads.\n+        for attr in attrs.iter_mut() {\n+            attr.node.id = attr::mk_attr_id();\n+        }\n+\n+        attrs\n+    })\n }\n \n fn list_crate_attributes(md: rbml::Doc, hash: &Svh,"}, {"sha": "ef8253713f5a1c55ac23187b16bdefa499213d2f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -41,7 +41,7 @@ use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n-use syntax::attr::{self,AttrMetaMethods,AttributeMethods};\n+use syntax::attr;\n use errors::Handler;\n use syntax;\n use syntax_pos::BytePos;\n@@ -1412,40 +1412,11 @@ fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n     rbml_w.end_tag();\n }\n \n-fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n-    if mi.is_word() {\n-        let name = mi.name();\n-        rbml_w.start_tag(tag_meta_item_word);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n-        rbml_w.end_tag();\n-    } else if mi.is_value_str() {\n-        let name = mi.name();\n-        /* FIXME (#623): support other literal kinds */\n-        let value = mi.value_str().unwrap();\n-        rbml_w.start_tag(tag_meta_item_name_value);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n-        rbml_w.wr_tagged_str(tag_meta_item_value, &value);\n-        rbml_w.end_tag();\n-    } else { // it must be a list\n-        let name = mi.name();\n-        let items = mi.meta_item_list().unwrap();\n-        rbml_w.start_tag(tag_meta_item_list);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n-        for inner_item in items {\n-            encode_meta_item(rbml_w, &inner_item);\n-        }\n-        rbml_w.end_tag();\n-    }\n-}\n-\n fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     rbml_w.start_tag(tag_attributes);\n-    for attr in attrs {\n-        rbml_w.start_tag(tag_attribute);\n-        rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n-        encode_meta_item(rbml_w, attr.meta());\n-        rbml_w.end_tag();\n-    }\n+    rbml_w.emit_opaque(|opaque_encoder| {\n+        attrs.encode(opaque_encoder)\n+    }).unwrap();\n     rbml_w.end_tag();\n }\n "}, {"sha": "ec0c9f455cd0c699338bddce01470b31842b3aca", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -18,8 +18,7 @@ use rustc::session::Session;\n use std::collections::{HashSet, HashMap};\n use syntax::parse::token;\n use syntax::ast;\n-use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{self, AttrNestedMetaItemMethods, AttrMetaMethods};\n use syntax::ext;\n use syntax_pos::Span;\n \n@@ -64,8 +63,8 @@ impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n                     }\n                     if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n                         for attr in names {\n-                            if attr.is_word() {\n-                                sel.insert(attr.name().clone(), attr.span());\n+                            if let Some(word) = attr.word() {\n+                                sel.insert(word.name().clone(), attr.span());\n                             } else {\n                                 span_err!(self.sess, attr.span(), E0466, \"bad macro import\");\n                             }\n@@ -82,8 +81,8 @@ impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n                     };\n \n                     for attr in names {\n-                        if attr.is_word() {\n-                            reexport.insert(attr.name().clone(), attr.span());\n+                        if let Some(word) = attr.word() {\n+                            reexport.insert(word.name().clone(), attr.span());\n                         } else {\n                             call_bad_macro_reexport(self.sess, attr.span());\n                         }"}, {"sha": "5a8d2e58c558b12fd7e3c8ed27625c78b71b4c5e", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -20,8 +20,7 @@ use std::env;\n use std::mem;\n use std::path::PathBuf;\n use syntax::ast;\n-use syntax::ptr::P;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax_pos::{Span, COMMAND_LINE_SP};\n \n /// Pointer to a registrar function.\n@@ -30,7 +29,7 @@ pub type PluginRegistrarFun =\n \n pub struct PluginRegistrar {\n     pub fun: PluginRegistrarFun,\n-    pub args: Vec<P<ast::MetaItem>>,\n+    pub args: Vec<ast::NestedMetaItem>,\n }\n \n struct PluginLoader<'a> {\n@@ -69,13 +68,14 @@ pub fn load_plugins(sess: &Session,\n             };\n \n             for plugin in plugins {\n-                if plugin.value_str().is_some() {\n-                    call_malformed_plugin_attribute(sess, attr.span);\n-                    continue;\n+                // plugins must have a name and can't be key = value\n+                match plugin.name() {\n+                    Some(ref name) if !plugin.is_value_str() => {\n+                        let args = plugin.meta_item_list().map(ToOwned::to_owned);\n+                        loader.load_plugin(plugin.span, name, args.unwrap_or_default());\n+                    },\n+                    _ => call_malformed_plugin_attribute(sess, attr.span),\n                 }\n-\n-                let args = plugin.meta_item_list().map(ToOwned::to_owned).unwrap_or_default();\n-                loader.load_plugin(plugin.span, &plugin.name(), args);\n             }\n         }\n     }\n@@ -102,7 +102,7 @@ impl<'a> PluginLoader<'a> {\n         }\n     }\n \n-    fn load_plugin(&mut self, span: Span, name: &str, args: Vec<P<ast::MetaItem>>) {\n+    fn load_plugin(&mut self, span: Span, name: &str, args: Vec<ast::NestedMetaItem>) {\n         let registrar = self.reader.find_plugin_registrar(span, name);\n \n         if let Some((lib, svh, index)) = registrar {"}, {"sha": "5ae6584aed4259ed204fd71bf96a67fa6a1a103c", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -19,7 +19,6 @@ use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n use syntax::ext::base::{IdentTT, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroExpanderFn, MacroRulesTT};\n use syntax::parse::token;\n-use syntax::ptr::P;\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -41,7 +40,7 @@ pub struct Registry<'a> {\n     pub sess: &'a Session,\n \n     #[doc(hidden)]\n-    pub args_hidden: Option<Vec<P<ast::MetaItem>>>,\n+    pub args_hidden: Option<Vec<ast::NestedMetaItem>>,\n \n     #[doc(hidden)]\n     pub krate_span: Span,\n@@ -95,7 +94,7 @@ impl<'a> Registry<'a> {\n     ///\n     /// Returns empty slice in case the plugin was loaded\n     /// with `--extra-plugins`\n-    pub fn args<'b>(&'b self) -> &'b [P<ast::MetaItem>] {\n+    pub fn args<'b>(&'b self) -> &'b [ast::NestedMetaItem] {\n         self.args_hidden.as_ref().map(|v| &v[..]).unwrap_or(&[])\n     }\n "}, {"sha": "e2633c829761fba63088c3cca30e365d96b12f66", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -29,7 +29,7 @@\n \n use rustc::ty::TyCtxt;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax::parse::token::InternedString;\n \n use {ModuleSource, ModuleTranslation};"}, {"sha": "02fa073dd552308a8e1d5a5959bea0182f396ae8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -26,10 +26,11 @@ pub use self::Visibility::*;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::attr::{AttributeMethods, AttrMetaMethods};\n+use syntax::attr::{AttributeMethods, AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax::codemap::Spanned;\n use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n+use syntax::print::pprust as syntax_pprust;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc_trans::back::link;\n@@ -501,11 +502,24 @@ impl Attributes for [Attribute] {\n     }\n }\n \n+/// This is a flattened version of the AST's Attribute + MetaItem.\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum Attribute {\n     Word(String),\n     List(String, Vec<Attribute>),\n-    NameValue(String, String)\n+    NameValue(String, String),\n+    Literal(String),\n+}\n+\n+impl Clean<Attribute> for ast::NestedMetaItem {\n+    fn clean(&self, cx: &DocContext) -> Attribute {\n+        if let Some(mi) = self.meta_item() {\n+            mi.clean(cx)\n+        } else { // must be a literal\n+            let lit = self.literal().unwrap();\n+            Literal(syntax_pprust::lit_to_string(lit))\n+        }\n+    }\n }\n \n impl Clean<Attribute> for ast::MetaItem {\n@@ -528,12 +542,28 @@ impl Clean<Attribute> for ast::Attribute {\n }\n \n // This is a rough approximation that gets us what we want.\n-impl attr::AttrMetaMethods for Attribute {\n-    fn name(&self) -> InternedString {\n+impl attr::AttrNestedMetaItemMethods for Attribute {\n+    fn check_name(&self, name: &str) -> bool {\n+        self.name().map_or(false, |mi_name| &*mi_name == name)\n+    }\n+\n+    fn literal(&self) -> Option<&ast::Lit> { None }\n+\n+    fn is_literal(&self) -> bool {\n+      match *self {\n+        Literal(..) => true,\n+        _ => false,\n+      }\n+    }\n+\n+    fn meta_item(&self) -> Option<&P<ast::MetaItem>> { None }\n+\n+    fn name(&self) -> Option<InternedString> {\n         match *self {\n             Word(ref n) | List(ref n, _) | NameValue(ref n, _) => {\n-                token::intern_and_get_ident(n)\n-            }\n+                Some(token::intern_and_get_ident(n))\n+            },\n+            _ => None\n         }\n     }\n \n@@ -545,7 +575,8 @@ impl attr::AttrMetaMethods for Attribute {\n             _ => None,\n         }\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n+\n+    fn word(&self) -> Option<&P<ast::MetaItem>> { None }\n \n     fn is_word(&self) -> bool {\n       match *self {\n@@ -554,12 +585,7 @@ impl attr::AttrMetaMethods for Attribute {\n       }\n     }\n \n-    fn is_value_str(&self) -> bool {\n-      match *self {\n-        NameValue(..) => true,\n-        _ => false,\n-      }\n-    }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [ast::NestedMetaItem]> { None }\n \n     fn is_meta_item_list(&self) -> bool {\n       match *self {\n@@ -2535,8 +2561,8 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n             &a.name()[..] == \"doc\" && match a.meta_item_list() {\n-                Some(l) => attr::contains_name(l, \"no_inline\") ||\n-                           attr::contains_name(l, \"hidden\"),\n+                Some(l) => attr::list_contains_name(l, \"no_inline\") ||\n+                           attr::list_contains_name(l, \"hidden\"),\n                 None => false,\n             }\n         });"}, {"sha": "23a047f922f9d7b883e01969e8105d885404f2a6", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -141,6 +141,7 @@ pub fn run(input: &str,\n // Look for #![doc(test(no_crate_inject))], used by crates in the std facade\n fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n     use syntax::attr::AttrMetaMethods;\n+    use syntax::attr::AttrNestedMetaItemMethods;\n     use syntax::print::pprust;\n \n     let mut opts = TestOptions {\n@@ -162,7 +163,7 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n         if attr.check_name(\"attr\") {\n             if let Some(l) = attr.meta_item_list() {\n                 for item in l {\n-                    opts.attrs.push(pprust::meta_item_to_string(item));\n+                    opts.attrs.push(pprust::meta_list_item_to_string(item));\n                 }\n             }\n         }"}, {"sha": "4e3a81b1baeac30be82f6fe8cda97c84224bb75e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -17,7 +17,7 @@ use std::mem;\n use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax_pos::Span;\n \n use rustc::hir::map as hir_map;\n@@ -333,8 +333,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let node = if item.vis == hir::Public {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n-                            Some(list) if &item.name()[..] == \"doc\" => {\n-                                list.iter().any(|i| &i.name()[..] == \"inline\")\n+                            Some(list) if item.check_name(\"doc\") => {\n+                                list.iter().any(|i| i.check_name(\"inline\"))\n                             }\n                             _ => false,\n                         }"}, {"sha": "63fd2e7686fdf52a7776973500bc5bcad3d8788d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -439,6 +439,22 @@ pub struct Crate {\n     pub exported_macros: Vec<MacroDef>,\n }\n \n+/// A spanned compile-time attribute list item.\n+pub type NestedMetaItem = Spanned<NestedMetaItemKind>;\n+\n+/// Possible values inside of compile-time attribute lists.\n+///\n+/// E.g. the '..' in `#[name(..)]`.\n+#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialEq)]\n+pub enum NestedMetaItemKind {\n+    /// A full MetaItem, for recursive meta items.\n+    MetaItem(P<MetaItem>),\n+    /// A literal.\n+    ///\n+    /// E.g. \"foo\", 64, true\n+    Literal(Lit),\n+}\n+\n /// A spanned compile-time attribute item.\n ///\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n@@ -456,7 +472,7 @@ pub enum MetaItemKind {\n     /// List meta item.\n     ///\n     /// E.g. `derive(..)` as in `#[derive(..)]`\n-    List(InternedString, Vec<P<MetaItem>>),\n+    List(InternedString, Vec<NestedMetaItem>),\n     /// Name value meta item.\n     ///\n     /// E.g. `feature = \"foo\"` as in `#[feature = \"foo\"]`\n@@ -472,19 +488,21 @@ impl PartialEq for MetaItemKind {\n                 Word(ref no) => (*ns) == (*no),\n                 _ => false\n             },\n+            List(ref ns, ref miss) => match *other {\n+                List(ref no, ref miso) => {\n+                    ns == no &&\n+                        miss.iter().all(|mi| {\n+                            miso.iter().any(|x| x.node == mi.node)\n+                        })\n+                }\n+                _ => false\n+            },\n             NameValue(ref ns, ref vs) => match *other {\n                 NameValue(ref no, ref vo) => {\n                     (*ns) == (*no) && vs.node == vo.node\n                 }\n                 _ => false\n             },\n-            List(ref ns, ref miss) => match *other {\n-                List(ref no, ref miso) => {\n-                    ns == no &&\n-                        miss.iter().all(|mi| miso.iter().any(|x| x.node == mi.node))\n-                }\n-                _ => false\n-            }\n         }\n     }\n }\n@@ -1105,6 +1123,30 @@ impl LitKind {\n             _ => false,\n         }\n     }\n+\n+    /// Returns true if this literal has no suffix. Note: this will return true\n+    /// for literals with prefixes such as raw strings and byte strings.\n+    pub fn is_unsuffixed(&self) -> bool {\n+        match *self {\n+            // unsuffixed variants\n+            LitKind::Str(..) => true,\n+            LitKind::ByteStr(..) => true,\n+            LitKind::Byte(..) => true,\n+            LitKind::Char(..) => true,\n+            LitKind::Int(_, LitIntType::Unsuffixed) => true,\n+            LitKind::FloatUnsuffixed(..) => true,\n+            LitKind::Bool(..) => true,\n+            // suffixed variants\n+            LitKind::Int(_, LitIntType::Signed(..)) => false,\n+            LitKind::Int(_, LitIntType::Unsigned(..)) => false,\n+            LitKind::Float(..) => false,\n+        }\n+    }\n+\n+    /// Returns true if this literal has a suffix.\n+    pub fn is_suffixed(&self) -> bool {\n+        !self.is_unsuffixed()\n+    }\n }\n \n // NB: If you change this, you'll probably want to change the corresponding"}, {"sha": "4897425f2c06c071b2247f4fffca66a142d7098c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 229, "deletions": 101, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -15,9 +15,10 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaItemKind};\n-use ast::{Expr, Item, Local, Stmt, StmtKind};\n-use codemap::{respan, spanned, dummy_spanned, Spanned};\n+use ast::{AttrId, Attribute, Attribute_};\n+use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n+use ast::{Lit, Expr, Item, Local, Stmt, StmtKind};\n+use codemap::{respan, spanned, dummy_spanned};\n use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n@@ -40,6 +41,7 @@ enum AttrError {\n     MissingSince,\n     MissingFeature,\n     MultipleStabilityLevels,\n+    UnsupportedLiteral\n }\n \n fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n@@ -52,10 +54,12 @@ fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n         AttrError::MissingFeature => span_err!(diag, span, E0546, \"missing 'feature'\"),\n         AttrError::MultipleStabilityLevels => span_err!(diag, span, E0544,\n                                                         \"multiple stability levels\"),\n+        AttrError::UnsupportedLiteral => span_err!(diag, span, E0565, \"unsupported literal\"),\n     }\n }\n \n pub fn mark_used(attr: &Attribute) {\n+    debug!(\"Marking {:?} as used.\", attr);\n     let AttrId(id) = attr.node.id;\n     USED_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n@@ -77,6 +81,93 @@ pub fn is_used(attr: &Attribute) -> bool {\n     })\n }\n \n+pub trait AttrNestedMetaItemMethods {\n+    /// Returns true if this list item is a MetaItem with a name of `name`.\n+    fn check_name(&self, name: &str) -> bool {\n+        self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n+    }\n+\n+    /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n+    /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n+    fn name(&self) -> Option<InternedString> {\n+        self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n+    }\n+\n+    /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n+    fn meta_item(&self) -> Option<&P<MetaItem>>;\n+\n+    /// Returns the Lit if self is a NestedMetaItemKind::Literal.\n+    fn literal(&self) -> Option<&Lit>;\n+\n+    /// Gets the string value if self is a MetaItem and the MetaItem is a\n+    /// MetaItemKind::NameValue variant containing a string, otherwise None.\n+    fn value_str(&self) -> Option<InternedString> {\n+        self.meta_item().and_then(|meta_item| meta_item.value_str())\n+    }\n+\n+    /// Returns a MetaItem if self is a MetaItem with Kind Word.\n+    fn word(&self) -> Option<&P<MetaItem>> {\n+        self.meta_item().and_then(|meta_item| if meta_item.is_word() {\n+            Some(meta_item)\n+        } else {\n+            None\n+        })\n+    }\n+\n+    /// Gets a list of inner meta items from a list MetaItem type.\n+    fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n+        self.meta_item().and_then(|meta_item| meta_item.meta_item_list())\n+    }\n+\n+    /// Returns `true` if the variant is MetaItem.\n+    fn is_meta_item(&self) -> bool {\n+        self.meta_item().is_some()\n+    }\n+\n+    /// Returns `true` if the variant is Literal.\n+    fn is_literal(&self) -> bool {\n+        self.literal().is_some()\n+    }\n+\n+    /// Returns `true` if self is a MetaItem and the meta item is a word.\n+    fn is_word(&self) -> bool {\n+        self.word().is_some()\n+    }\n+\n+    /// Returns `true` if self is a MetaItem and the meta item is a ValueString.\n+    fn is_value_str(&self) -> bool {\n+        self.value_str().is_some()\n+    }\n+\n+    /// Returns `true` if self is a MetaItem and the meta item is a list.\n+    fn is_meta_item_list(&self) -> bool {\n+        self.meta_item_list().is_some()\n+    }\n+\n+    /// Returns the Span for `self`.\n+    fn span(&self) -> Span;\n+}\n+\n+impl AttrNestedMetaItemMethods for NestedMetaItem {\n+    fn meta_item(&self) -> Option<&P<MetaItem>> {\n+        match self.node {\n+            NestedMetaItemKind::MetaItem(ref item) => Some(&item),\n+            _ => None\n+        }\n+    }\n+\n+    fn literal(&self) -> Option<&Lit> {\n+        match self.node {\n+            NestedMetaItemKind::Literal(ref lit) => Some(&lit),\n+            _ => None\n+        }\n+    }\n+\n+    fn span(&self) -> Span {\n+        self.span\n+    }\n+}\n+\n pub trait AttrMetaMethods {\n     fn check_name(&self, name: &str) -> bool {\n         name == &self.name()[..]\n@@ -89,8 +180,9 @@ pub trait AttrMetaMethods {\n     /// Gets the string value if self is a MetaItemKind::NameValue variant\n     /// containing a string, otherwise None.\n     fn value_str(&self) -> Option<InternedString>;\n+\n     /// Gets a list of inner meta items from a list MetaItem type.\n-    fn meta_item_list(&self) -> Option<&[P<MetaItem>]>;\n+    fn meta_item_list(&self) -> Option<&[NestedMetaItem]>;\n \n     /// Indicates if the attribute is a Word.\n     fn is_word(&self) -> bool;\n@@ -116,11 +208,14 @@ impl AttrMetaMethods for Attribute {\n         }\n         matches\n     }\n+\n     fn name(&self) -> InternedString { self.meta().name() }\n+\n     fn value_str(&self) -> Option<InternedString> {\n         self.meta().value_str()\n     }\n-    fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n+\n+    fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n         self.meta().meta_item_list()\n     }\n \n@@ -150,7 +245,7 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n+    fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n         match self.node {\n             MetaItemKind::List(_, ref l) => Some(&l[..]),\n             _ => None\n@@ -171,7 +266,7 @@ impl AttrMetaMethods for MetaItem {\n impl AttrMetaMethods for P<MetaItem> {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n+    fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n         (**self).meta_item_list()\n     }\n     fn is_word(&self) -> bool { (**self).is_word() }\n@@ -229,10 +324,14 @@ pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n     mk_spanned_name_value_item(DUMMY_SP, name, value)\n }\n \n-pub fn mk_list_item(name: InternedString, items: Vec<P<MetaItem>>) -> P<MetaItem> {\n+pub fn mk_list_item(name: InternedString, items: Vec<NestedMetaItem>) -> P<MetaItem> {\n     mk_spanned_list_item(DUMMY_SP, name, items)\n }\n \n+pub fn mk_list_word_item(name: InternedString) -> ast::NestedMetaItem {\n+    dummy_spanned(NestedMetaItemKind::MetaItem(mk_spanned_word_item(DUMMY_SP, name)))\n+}\n+\n pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n     mk_spanned_word_item(DUMMY_SP, name)\n }\n@@ -242,7 +341,7 @@ pub fn mk_spanned_name_value_item(sp: Span, name: InternedString, value: ast::Li\n     P(respan(sp, MetaItemKind::NameValue(name, value)))\n }\n \n-pub fn mk_spanned_list_item(sp: Span, name: InternedString, items: Vec<P<MetaItem>>)\n+pub fn mk_spanned_list_item(sp: Span, name: InternedString, items: Vec<NestedMetaItem>)\n                             -> P<MetaItem> {\n     P(respan(sp, MetaItemKind::List(name, items)))\n }\n@@ -332,6 +431,14 @@ pub fn contains(haystack: &[P<MetaItem>], needle: &MetaItem) -> bool {\n     })\n }\n \n+pub fn list_contains_name<AM: AttrNestedMetaItemMethods>(items: &[AM], name: &str) -> bool {\n+    debug!(\"attr::list_contains_name (name={})\", name);\n+    items.iter().any(|item| {\n+        debug!(\"  testing: {:?}\", item.name());\n+        item.check_name(name)\n+    })\n+}\n+\n pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n     debug!(\"attr::contains_name (name={})\", name);\n     metas.iter().any(|item| {\n@@ -357,27 +464,6 @@ pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n-    // This is sort of stupid here, but we need to sort by\n-    // human-readable strings.\n-    let mut v = items.into_iter()\n-        .map(|mi| (mi.name(), mi))\n-        .collect::<Vec<(InternedString, P<MetaItem>)>>();\n-\n-    v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n-\n-    // There doesn't seem to be a more optimal way to do this\n-    v.into_iter().map(|(_, m)| m.map(|Spanned {node, span}| {\n-        Spanned {\n-            node: match node {\n-                MetaItemKind::List(n, mis) => MetaItemKind::List(n, sort_meta_items(mis)),\n-                _ => node\n-            },\n-            span: span\n-        }\n-    })).collect()\n-}\n-\n pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n@@ -427,14 +513,15 @@ pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> In\n                 if items.len() != 1 {\n                     diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n                     InlineAttr::None\n-                } else if contains_name(&items[..], \"always\") {\n+                } else if list_contains_name(&items[..], \"always\") {\n                     InlineAttr::Always\n-                } else if contains_name(&items[..], \"never\") {\n+                } else if list_contains_name(&items[..], \"never\") {\n                     InlineAttr::Never\n                 } else {\n                     diagnostic.map(|d| {\n-                        span_err!(d, (*items[0]).span, E0535, \"invalid argument\");\n+                        span_err!(d, items[0].span, E0535, \"invalid argument\");\n                     });\n+\n                     InlineAttr::None\n                 }\n             }\n@@ -453,27 +540,44 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n \n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n-                   sess: &ParseSess, features: Option<&Features>)\n+                   sess: &ParseSess,\n+                   features: Option<&Features>)\n                    -> bool {\n     match cfg.node {\n-        ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"any\" =>\n-            mis.iter().any(|mi| cfg_matches(cfgs, &mi, sess, features)),\n-        ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"all\" =>\n-            mis.iter().all(|mi| cfg_matches(cfgs, &mi, sess, features)),\n-        ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"not\" => {\n-            if mis.len() != 1 {\n-                span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n-                return false;\n+        ast::MetaItemKind::List(ref pred, ref mis) => {\n+            for mi in mis.iter() {\n+                if !mi.is_meta_item() {\n+                    handle_errors(&sess.span_diagnostic, mi.span, AttrError::UnsupportedLiteral);\n+                    return false;\n+                }\n+            }\n+\n+            // The unwraps below may look dangerous, but we've already asserted\n+            // that they won't fail with the loop above.\n+            match &pred[..] {\n+                \"any\" => mis.iter().any(|mi| {\n+                    cfg_matches(cfgs, mi.meta_item().unwrap(), sess, features)\n+                }),\n+                \"all\" => mis.iter().all(|mi| {\n+                    cfg_matches(cfgs, mi.meta_item().unwrap(), sess, features)\n+                }),\n+                \"not\" => {\n+                    if mis.len() != 1 {\n+                        span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n+                        return false;\n+                    }\n+\n+                    !cfg_matches(cfgs, mis[0].meta_item().unwrap(), sess, features)\n+                },\n+                p => {\n+                    span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n+                    false\n+                }\n             }\n-            !cfg_matches(cfgs, &mis[0], sess, features)\n-        }\n-        ast::MetaItemKind::List(ref pred, _) => {\n-            span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", pred);\n-            false\n         },\n         ast::MetaItemKind::Word(_) | ast::MetaItemKind::NameValue(..) => {\n-            if let (Some(features), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n-                gated_cfg.check_and_emit(sess, features);\n+            if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n+                gated_cfg.check_and_emit(sess, feats);\n             }\n             contains(cfgs, cfg)\n         }\n@@ -557,14 +661,19 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     let mut reason = None;\n                     for meta in metas {\n-                        match &*meta.name() {\n-                            \"since\" => if !get(meta, &mut since) { continue 'outer },\n-                            \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n-                            _ => {\n-                                handle_errors(diagnostic, meta.span,\n-                                              AttrError::UnknownMetaItem(meta.name()));\n-                                continue 'outer\n+                        if let Some(mi) = meta.meta_item() {\n+                            match &*mi.name() {\n+                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(diagnostic, mi.span,\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                    continue 'outer\n+                                }\n                             }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n                         }\n                     }\n \n@@ -595,15 +704,20 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut reason = None;\n                     let mut issue = None;\n                     for meta in metas {\n-                        match &*meta.name() {\n-                            \"feature\" => if !get(meta, &mut feature) { continue 'outer },\n-                            \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n-                            \"issue\" => if !get(meta, &mut issue) { continue 'outer },\n-                            _ => {\n-                                handle_errors(diagnostic, meta.span,\n-                                              AttrError::UnknownMetaItem(meta.name()));\n-                                continue 'outer\n+                        if let Some(mi) = meta.meta_item() {\n+                            match &*mi.name() {\n+                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n+                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n+                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(diagnostic, meta.span,\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                    continue 'outer\n+                                }\n                             }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n                         }\n                     }\n \n@@ -645,14 +759,19 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut feature = None;\n                     let mut since = None;\n                     for meta in metas {\n-                        match &*meta.name() {\n-                            \"feature\" => if !get(meta, &mut feature) { continue 'outer },\n-                            \"since\" => if !get(meta, &mut since) { continue 'outer },\n-                            _ => {\n-                                handle_errors(diagnostic, meta.span,\n-                                              AttrError::UnknownMetaItem(meta.name()));\n-                                continue 'outer\n+                        if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n+                            match &*mi.name() {\n+                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n+                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(diagnostic, meta.span,\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                    continue 'outer\n+                                }\n                             }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n                         }\n                     }\n \n@@ -739,14 +858,19 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut since = None;\n             let mut note = None;\n             for meta in metas {\n-                match &*meta.name() {\n-                    \"since\" => if !get(meta, &mut since) { continue 'outer },\n-                    \"note\" => if !get(meta, &mut note) { continue 'outer },\n-                    _ => {\n-                        handle_errors(diagnostic, meta.span,\n-                                      AttrError::UnknownMetaItem(meta.name()));\n-                        continue 'outer\n+                if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n+                    match &*mi.name() {\n+                        \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                        \"note\" => if !get(mi, &mut note) { continue 'outer },\n+                        _ => {\n+                            handle_errors(diagnostic, meta.span,\n+                                          AttrError::UnknownMetaItem(mi.name()));\n+                            continue 'outer\n+                        }\n                     }\n+                } else {\n+                    handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                    continue 'outer\n                 }\n             }\n \n@@ -796,32 +920,36 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n         ast::MetaItemKind::List(ref s, ref items) if s == \"repr\" => {\n             mark_used(attr);\n             for item in items {\n-                match item.node {\n-                    ast::MetaItemKind::Word(ref word) => {\n-                        let hint = match &word[..] {\n-                            // Can't use \"extern\" because it's not a lexical identifier.\n-                            \"C\" => Some(ReprExtern),\n-                            \"packed\" => Some(ReprPacked),\n-                            \"simd\" => Some(ReprSimd),\n-                            _ => match int_type_of_word(&word) {\n-                                Some(ity) => Some(ReprInt(item.span, ity)),\n-                                None => {\n-                                    // Not a word we recognize\n-                                    span_err!(diagnostic, item.span, E0552,\n-                                              \"unrecognized representation hint\");\n-                                    None\n-                                }\n-                            }\n-                        };\n+                if !item.is_meta_item() {\n+                    handle_errors(diagnostic, item.span, AttrError::UnsupportedLiteral);\n+                    continue\n+                }\n \n-                        match hint {\n-                            Some(h) => acc.push(h),\n-                            None => { }\n+                if let Some(mi) = item.word() {\n+                    let word = &*mi.name();\n+                    let hint = match word {\n+                        // Can't use \"extern\" because it's not a lexical identifier.\n+                        \"C\" => Some(ReprExtern),\n+                        \"packed\" => Some(ReprPacked),\n+                        \"simd\" => Some(ReprSimd),\n+                        _ => match int_type_of_word(word) {\n+                            Some(ity) => Some(ReprInt(item.span, ity)),\n+                            None => {\n+                                // Not a word we recognize\n+                                span_err!(diagnostic, item.span, E0552,\n+                                          \"unrecognized representation hint\");\n+                                None\n+                            }\n                         }\n+                    };\n+\n+                    match hint {\n+                        Some(h) => acc.push(h),\n+                        None => { }\n                     }\n-                    // Not a word:\n-                    _ => span_err!(diagnostic, item.span, E0553,\n-                                   \"unrecognized enum representation hint\"),\n+                } else {\n+                    span_err!(diagnostic, item.span, E0553,\n+                              \"unrecognized enum representation hint\");\n                 }\n             }\n         }"}, {"sha": "4663143f4b1f81871f1765991632e7e81ed3533f", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use attr::{AttrMetaMethods, HasAttrs};\n+use attr::{AttrMetaMethods, AttrNestedMetaItemMethods, HasAttrs};\n use feature_gate::{emit_feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n use fold::Folder;\n use {fold, attr};\n@@ -52,6 +52,7 @@ impl<'a> StripUnconfigured<'a> {\n                 return None;\n             }\n         };\n+\n         let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n             (2, Some(cfg), Some(mi)) => (cfg, mi),\n             _ => {\n@@ -61,15 +62,24 @@ impl<'a> StripUnconfigured<'a> {\n             }\n         };\n \n-        if attr::cfg_matches(self.config, &cfg, self.sess, self.features) {\n-            self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n-                id: attr::mk_attr_id(),\n-                style: attr.node.style,\n-                value: mi.clone(),\n-                is_sugared_doc: false,\n-            }))\n-        } else {\n-            None\n+        use attr::cfg_matches;\n+        match (cfg.meta_item(), mi.meta_item()) {\n+            (Some(cfg), Some(mi)) =>\n+                if cfg_matches(self.config, &cfg, self.sess, self.features) {\n+                    self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n+                        id: attr::mk_attr_id(),\n+                        style: attr.node.style,\n+                        value: mi.clone(),\n+                        is_sugared_doc: false,\n+                    }))\n+                } else {\n+                    None\n+                },\n+            _ => {\n+                let msg = \"unexpected literal(s) in `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n+                self.sess.span_diagnostic.span_err(attr.span, msg);\n+                None\n+            }\n         }\n     }\n \n@@ -91,7 +101,12 @@ impl<'a> StripUnconfigured<'a> {\n                 return true;\n             }\n \n-            attr::cfg_matches(self.config, &mis[0], self.sess, self.features)\n+            if !mis[0].is_meta_item() {\n+                self.sess.span_diagnostic.span_err(mis[0].span, \"unexpected literal\");\n+                return true;\n+            }\n+\n+            attr::cfg_matches(self.config, mis[0].meta_item().unwrap(), self.sess, self.features)\n         })\n     }\n "}, {"sha": "9110e989a8a1491f6d1f884a78d79e06790c1241", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -161,6 +161,24 @@ fn main() {}\n ```\n \"##,\n \n+E0565: r##\"\n+A literal was used in an attribute that doesn't support literals.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0565\n+#[inline(\"always\")] // error: unsupported literal\n+pub fn something() {}\n+```\n+\n+Literals in attributes are new and largely unsupported. Work to support literals\n+where appropriate is ongoing. Try using an unquoted name instead:\n+\n+```\n+#[inline(always)]\n+pub fn something() {}\n+```\n+\"##,\n }\n \n register_diagnostics! {"}, {"sha": "1d3939df6fb826d7b616a914797ee732d3ed7881", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -277,10 +277,13 @@ pub trait AstBuilder {\n     fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute;\n \n     fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem>;\n+\n+    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem;\n+\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<P<ast::MetaItem>> )\n+                 mis: Vec<ast::NestedMetaItem> )\n                  -> P<ast::MetaItem>;\n     fn meta_name_value(&self,\n                        sp: Span,\n@@ -1141,10 +1144,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem> {\n         attr::mk_spanned_word_item(sp, w)\n     }\n-    fn meta_list(&self, sp: Span, name: InternedString, mis: Vec<P<ast::MetaItem>>)\n+\n+    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem {\n+        respan(sp, ast::NestedMetaItemKind::MetaItem(attr::mk_spanned_word_item(sp, w)))\n+    }\n+\n+    fn meta_list(&self, sp: Span, name: InternedString, mis: Vec<ast::NestedMetaItem>)\n                  -> P<ast::MetaItem> {\n         attr::mk_spanned_list_item(sp, name, mis)\n     }\n+\n     fn meta_name_value(&self, sp: Span, name: InternedString, value: ast::LitKind)\n                        -> P<ast::MetaItem> {\n         attr::mk_spanned_name_value_item(sp, name, respan(sp, value))"}, {"sha": "df1d5c4d9ca2fdcb3dca3c3c97a97172fe91c0cf", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -26,10 +26,8 @@ use self::AttributeType::*;\n use self::AttributeGate::*;\n \n use abi::Abi;\n-use ast::{NodeId, PatKind};\n-use ast;\n-use attr;\n-use attr::AttrMetaMethods;\n+use ast::{self, NodeId, PatKind};\n+use attr::{self, AttrMetaMethods, AttrNestedMetaItemMethods};\n use codemap::CodeMap;\n use syntax_pos::Span;\n use errors::Handler;\n@@ -283,7 +281,10 @@ declare_features! (\n     (active, relaxed_adts, \"1.12.0\", Some(35626)),\n \n     // The `!` type\n-    (active, never_type, \"1.13.0\", Some(35121))\n+    (active, never_type, \"1.13.0\", Some(35121)),\n+\n+    // Allows all literals in attribute lists and values of key-value pairs.\n+    (active, attr_literals, \"1.13.0\", Some(34981))\n );\n \n declare_features! (\n@@ -831,11 +832,34 @@ impl<'a> PostExpansionVisitor<'a> {\n     }\n }\n \n+fn contains_novel_literal(item: &ast::MetaItem) -> bool {\n+    use ast::MetaItemKind::*;\n+    use ast::NestedMetaItemKind::*;\n+\n+    match item.node {\n+        Word(..) => false,\n+        NameValue(_, ref lit) => !lit.node.is_str(),\n+        List(_, ref list) => list.iter().any(|li| {\n+            match li.node {\n+                MetaItem(ref mi) => contains_novel_literal(&**mi),\n+                Literal(_) => true,\n+            }\n+        }),\n+    }\n+}\n+\n impl<'a> Visitor for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         if !self.context.cm.span_allows_unstable(attr.span) {\n+            // check for gated attributes\n             self.context.check_attribute(attr, false);\n         }\n+\n+        if contains_novel_literal(&*(attr.node.value)) {\n+            gate_feature_post!(&self, attr_literals, attr.span,\n+                               \"non-string literals in attributes, or string \\\n+                               literals in top-level positions, are experimental\");\n+        }\n     }\n \n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n@@ -895,7 +919,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                 for attr in &i.attrs {\n                     if attr.name() == \"repr\" {\n                         for item in attr.meta_item_list().unwrap_or(&[]) {\n-                            if item.name() == \"simd\" {\n+                            if item.check_name(\"simd\") {\n                                 gate_feature_post!(&self, repr_simd, i.span,\n                                                    \"SIMD types are experimental \\\n                                                     and possibly buggy\");\n@@ -1155,13 +1179,14 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n             }\n             Some(list) => {\n                 for mi in list {\n-                    let name = if mi.is_word() {\n-                                   mi.name()\n-                               } else {\n-                                   span_err!(span_handler, mi.span, E0556,\n-                                             \"malformed feature, expected just one word\");\n-                                   continue\n-                               };\n+                    let name = if let Some(word) = mi.word() {\n+                        word.name()\n+                    } else {\n+                        span_err!(span_handler, mi.span, E0556,\n+                                  \"malformed feature, expected just one word\");\n+                        continue\n+                    };\n+\n                     if let Some(&(_, _, _, setter)) = ACTIVE_FEATURES.iter()\n                         .find(|& &(n, _, _, _)| name == n) {\n                         *(setter(&mut features)) = true;"}, {"sha": "b361a856dbe2c93387250f2f982754ad8c2996d5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -47,6 +47,10 @@ pub trait Folder : Sized {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n+    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n+        noop_fold_meta_list_item(list_item, self)\n+    }\n+\n     fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n         noop_fold_meta_item(meta_item, self)\n     }\n@@ -513,12 +517,25 @@ pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     }\n }\n \n+pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n+    -> NestedMetaItem {\n+    Spanned {\n+        node: match li.node {\n+            NestedMetaItemKind::MetaItem(mi) =>  {\n+                NestedMetaItemKind::MetaItem(fld.fold_meta_item(mi))\n+            },\n+            NestedMetaItemKind::Literal(lit) => NestedMetaItemKind::Literal(lit)\n+        },\n+        span: fld.new_span(li.span)\n+    }\n+}\n+\n pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n     mi.map(|Spanned {node, span}| Spanned {\n         node: match node {\n             MetaItemKind::Word(id) => MetaItemKind::Word(id),\n             MetaItemKind::List(id, mis) => {\n-                MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+                MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n             }\n             MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s)\n         },"}, {"sha": "27dd055cd3ae7431ce46e5651c26cf9e98e24d04", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -193,9 +193,26 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    /// matches meta_item = IDENT\n-    /// | IDENT = lit\n-    /// | IDENT meta_seq\n+    fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n+        let lit = self.parse_lit()?;\n+        debug!(\"Checking if {:?} is unusuffixed.\", lit);\n+\n+        if !lit.node.is_unsuffixed() {\n+            let msg = \"suffixed literals are not allowed in attributes\";\n+            self.diagnostic().struct_span_err(lit.span, msg)\n+                             .help(\"instead of using a suffixed literal \\\n+                                    (1u8, 1.0f32, etc.), use an unsuffixed version \\\n+                                    (1, 1.0, etc.).\")\n+                             .emit()\n+        }\n+\n+        Ok(lit)\n+    }\n+\n+    /// Per RFC#1559, matches the following grammar:\n+    ///\n+    /// meta_item : IDENT ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;\n+    /// meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     pub fn parse_meta_item(&mut self) -> PResult<'a, P<ast::MetaItem>> {\n         let nt_meta = match self.token {\n             token::Interpolated(token::NtMeta(ref e)) => Some(e.clone()),\n@@ -213,16 +230,7 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::Eq => {\n                 self.bump();\n-                let lit = self.parse_lit()?;\n-                // FIXME #623 Non-string meta items are not serialized correctly;\n-                // just forbid them for now\n-                match lit.node {\n-                    ast::LitKind::Str(..) => {}\n-                    _ => {\n-                        self.span_err(lit.span,\n-                                      \"non-string literals are not allowed in meta-items\");\n-                    }\n-                }\n+                let lit = self.parse_unsuffixed_lit()?;\n                 let hi = self.span.hi;\n                 Ok(P(spanned(lo, hi, ast::MetaItemKind::NameValue(name, lit))))\n             }\n@@ -238,11 +246,35 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> PResult<'a, Vec<P<ast::MetaItem>>> {\n+    /// matches meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;\n+    fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n+        let sp = self.span;\n+        let lo = self.span.lo;\n+\n+        match self.parse_unsuffixed_lit() {\n+            Ok(lit) => {\n+                return Ok(spanned(lo, self.span.hi, ast::NestedMetaItemKind::Literal(lit)))\n+            }\n+            Err(ref mut err) => self.diagnostic().cancel(err)\n+        }\n+\n+        match self.parse_meta_item() {\n+            Ok(mi) => {\n+                return Ok(spanned(lo, self.span.hi, ast::NestedMetaItemKind::MetaItem(mi)))\n+            }\n+            Err(ref mut err) => self.diagnostic().cancel(err)\n+        }\n+\n+        let found = self.this_token_to_string();\n+        let msg = format!(\"expected unsuffixed literal or identifier, found {}\", found);\n+        Err(self.diagnostic().struct_span_err(sp, &msg))\n+    }\n+\n+    /// matches meta_seq = ( COMMASEP(meta_item_inner) )\n+    fn parse_meta_seq(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n         self.parse_unspanned_seq(&token::OpenDelim(token::Paren),\n                                  &token::CloseDelim(token::Paren),\n                                  SeqSep::trailing_allowed(token::Comma),\n-                                 |p: &mut Parser<'a>| p.parse_meta_item())\n+                                 |p: &mut Parser<'a>| p.parse_meta_item_inner())\n     }\n }"}, {"sha": "562cc896aef010ecd98c12eaa06ab38cf3edd61b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -120,7 +120,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let prelude_import_meta = attr::mk_word_item(InternedString::new(\"prelude_import\"));\n+        let prelude_import_meta = attr::mk_list_word_item(InternedString::new(\"prelude_import\"));\n         let list = attr::mk_list_item(InternedString::new(\"feature\"),\n                                       vec![prelude_import_meta]);\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), list);\n@@ -406,6 +406,10 @@ pub fn block_to_string(blk: &ast::Block) -> String {\n     })\n }\n \n+pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n+    to_string(|s| s.print_meta_list_item(li))\n+}\n+\n pub fn meta_item_to_string(mi: &ast::MetaItem) -> String {\n     to_string(|s| s.print_meta_item(mi))\n }\n@@ -764,6 +768,17 @@ pub trait PrintState<'a> {\n         }\n     }\n \n+    fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) -> io::Result<()> {\n+        match item.node {\n+            ast::NestedMetaItemKind::MetaItem(ref mi) => {\n+                self.print_meta_item(mi)\n+            },\n+            ast::NestedMetaItemKind::Literal(ref lit) => {\n+                self.print_literal(lit)\n+            }\n+        }\n+    }\n+\n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n         try!(self.ibox(INDENT_UNIT));\n         match item.node {\n@@ -780,7 +795,7 @@ pub trait PrintState<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                               &items[..],\n-                              |s, i| s.print_meta_item(&i)));\n+                              |s, i| s.print_meta_list_item(&i)));\n                 try!(self.pclose());\n             }\n         }"}, {"sha": "ce917f248e1efd13ac9b645c8a33cc9e268c73c6", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -19,8 +19,7 @@ use std::iter;\n use std::slice;\n use std::mem;\n use std::vec;\n-use attr::AttrMetaMethods;\n-use attr;\n+use attr::{self, AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n use std::rc::Rc;\n \n@@ -210,9 +209,8 @@ impl fold::Folder for EntryPointCleaner {\n                 folded.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n                     let allow_str = InternedString::new(\"allow\");\n                     let dead_code_str = InternedString::new(\"dead_code\");\n-                    let allow_dead_code_item =\n-                        attr::mk_list_item(allow_str,\n-                                           vec![attr::mk_word_item(dead_code_str)]);\n+                    let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n+                    let allow_dead_code_item = attr::mk_list_item(allow_str, word_vec);\n                     let allow_dead_code = attr::mk_attr_outer(attr::mk_attr_id(),\n                                                               allow_dead_code_item);\n \n@@ -413,6 +411,7 @@ fn should_panic(i: &ast::Item) -> ShouldPanic {\n         Some(attr) => {\n             let msg = attr.meta_item_list()\n                 .and_then(|list| list.iter().find(|mi| mi.check_name(\"expected\")))\n+                .and_then(|li| li.meta_item())\n                 .and_then(|mi| mi.value_str());\n             ShouldPanic::Yes(msg)\n         }"}, {"sha": "2515435abeb9e5dc71977cf68756029a38bc0bde", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -40,7 +40,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n     }\n \n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let hidden = cx.meta_word(span, InternedString::new(\"hidden\"));\n+    let hidden = cx.meta_list_item_word(span, InternedString::new(\"hidden\"));\n     let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec![hidden]);\n     let attrs = vec![cx.attribute(span, inline), cx.attribute(span, doc)];\n     let trait_def = TraitDef {"}, {"sha": "bae40ddf45c9f672a0d1e5a82f3fe27d956b1c6e", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -623,7 +623,7 @@ impl<'a> TraitDef<'a> {\n         let unused_qual = cx.attribute(self.span,\n                                        cx.meta_list(self.span,\n                                                     InternedString::new(\"allow\"),\n-                                                    vec![cx.meta_word(self.span,\n+                                                    vec![cx.meta_list_item_word(self.span,\n                                            InternedString::new(\"unused_qualifications\"))]));\n         let mut a = vec![attr, unused_qual];\n         a.extend(self.attributes.iter().cloned());"}, {"sha": "ffc1bfd6db8cd1a2779ea24f5cdeb3dddaf87efb", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -11,7 +11,7 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use syntax::ast::{self, MetaItem};\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{AttrNestedMetaItemMethods, AttrMetaMethods};\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n use syntax::ext::build::AstBuilder;\n@@ -98,8 +98,8 @@ fn expand_derive(cx: &mut ExtCtxt,\n             let mut eq_span = None;\n \n             for titem in traits.iter().rev() {\n-                let tname = if titem.is_word() {\n-                    titem.name()\n+                let tname = if let Some(word) = titem.word() {\n+                    word.name()\n                 } else {\n                     cx.span_err(titem.span, \"malformed `derive` entry\");\n                     continue;"}, {"sha": "6db10eeae769befc50557b7b111f7adec179861d", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -17,7 +17,8 @@ extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::ast::{self, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n+use syntax::ast::{self, Item, MetaItem, ItemKind};\n+use syntax::attr::{AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax::ext::base::*;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n@@ -62,8 +63,8 @@ fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n }\n \n fn expand_into_foo_multi(cx: &mut ExtCtxt,\n-                         sp: Span,\n-                         attr: &MetaItem,\n+                         _sp: Span,\n+                         _attr: &MetaItem,\n                          it: Annotatable) -> Annotatable {\n     match it {\n         Annotatable::Item(it) => {\n@@ -72,7 +73,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 ..(*quote_item!(cx, enum Foo2 { Bar2, Baz2 }).unwrap()).clone()\n             }))\n         }\n-        Annotatable::ImplItem(it) => {\n+        Annotatable::ImplItem(_) => {\n             quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Impl(_, _, _, _, _, mut items) => {\n@@ -82,7 +83,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 }\n             })\n         }\n-        Annotatable::TraitItem(it) => {\n+        Annotatable::TraitItem(_) => {\n             quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Trait(_, _, _, mut items) => {\n@@ -97,15 +98,15 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n \n // Create a duplicate of the annotatable, based on the MetaItem\n fn expand_duplicate(cx: &mut ExtCtxt,\n-                    sp: Span,\n+                    _sp: Span,\n                     mi: &MetaItem,\n                     it: &Annotatable,\n                     push: &mut FnMut(Annotatable))\n {\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(_, ref xs) => {\n-            if let ast::MetaItemKind::Word(ref w) = xs[0].node {\n-                token::str_to_ident(&w)\n+            if let Some(word) = xs[0].word() {\n+                token::str_to_ident(&word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "d3e68c7c0daf8613f3c8cd95f184106d4f743654", "filename": "src/test/compile-fail/E0565-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail%2FE0565-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail%2FE0565-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0565-1.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(attr_literals)]\n+\n+// deprecated doesn't currently support literals\n+#[deprecated(\"since\")] //~ ERROR E0565\n+fn f() {  }\n+\n+fn main() {  }"}, {"sha": "b2d369223e7dac02cc76e6871dc5a9d2a999f2a7", "filename": "src/test/compile-fail/E0565.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail%2FE0565.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail%2FE0565.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0565.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(attr_literals)]\n+\n+// repr currently doesn't support literals\n+#[repr(\"C\")] //~ ERROR E0565\n+struct A {  }\n+\n+fn main() {  }"}, {"sha": "b54288035175d33c9a477d8279841fe374ad1c62", "filename": "src/test/compile-fail/attr-literals.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail%2Fattr-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail%2Fattr-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-literals.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that literals in attributes parse just fine.\n+\n+#![feature(rustc_attrs, attr_literals)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+#[fake_attr] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(100)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(1, 2, 3)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(\"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(name = \"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(1, \"hi\", key = 12, true, false)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(key = \"hello\", val = 10)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(key(\"hello\"), val(10))] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(enabled = true, disabled = false)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(true)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(pi = 3.14159)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(b\"hi\")] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_doc(r\"doc\")] //~ ERROR attribute `fake_doc` is currently unknown\n+struct Q {  }\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "f3132d5593e621d57048b95c70c3473aa96c7a99", "filename": "src/test/compile-fail/gated-attr-literals.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail%2Fgated-attr-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fcompile-fail%2Fgated-attr-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-attr-literals.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that literals in attributes don't parse without the feature gate.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+#[fake_attr] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(100)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(1, 2, 3)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(\"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR string literals in top-level positions, are experimental\n+#[fake_attr(name = \"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(1, \"hi\", key = 12, true, false)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes, or string literals in top-level positions\n+#[fake_attr(key = \"hello\", val = 10)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(key(\"hello\"), val(10))] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes, or string literals in top-level positions\n+#[fake_attr(enabled = true, disabled = false)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(true)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(pi = 3.14159)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(b\"hi\")] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR string literals in top-level positions, are experimental\n+#[fake_doc(r\"doc\")] //~ ERROR attribute `fake_doc` is currently unknown\n+    //~^ ERROR string literals in top-level positions, are experimental\n+struct Q {  }\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "0e2840c69d3643eee7e58f2f646b59b1448a1e2f", "filename": "src/test/parse-fail/suffixed-literal-meta.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+#[foo = 1usize] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1u8] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1u16] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1u32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1u64] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1isize] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1i8] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1i16] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1i32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1i64] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1.0f32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1.0f64] //~ ERROR: suffixed literals are not allowed in attributes\n+fn main() { }"}, {"sha": "ba8c580cb0a01d1f5753ad737663b3aafb49ad72", "filename": "src/test/pretty/attr-literals.rs", "status": "renamed", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fpretty%2Fattr-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Fpretty%2Fattr-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-literals.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -8,10 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// pp-exact\n+// Tests literals in attributes.\n \n-// Issue #623 - non-string meta items are not serialized correctly;\n-// for now just forbid them\n+#![feature(custom_attribute, attr_literals)]\n \n-#[foo = 1] //~ ERROR: non-string literals are not allowed in meta-items\n-fn main() { }\n+fn main() {\n+    #![hello(\"hi\", 1, 2, 1.012, pi = 3.14, bye, name(\"John\"))]\n+    #[align = 8]\n+    fn f() { }\n+\n+    #[vec(1, 2, 3)]\n+    fn g() { }\n+}", "previous_filename": "src/test/parse-fail/non-str-meta.rs"}, {"sha": "274e430bbea749a4493c7b9836ca87a28af2aac1", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -24,7 +24,6 @@ use syntax::ast;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n-use syntax::ptr::P;\n use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n use syntax_pos::Span;"}, {"sha": "882e90b2d6c159c31d98dd3a0f064ca0cd2fabac", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -26,7 +26,7 @@ use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n+use syntax_ext::deriving::generic::{TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n use syntax_pos::Span;"}, {"sha": "e37cd89f29991125f03c7425471f0ffe9bacf8a7", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 86, "deletions": 17, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -17,8 +17,11 @@ extern crate rustc;\n extern crate rustc_plugin;\n extern crate syntax_pos;\n \n-use syntax::ast::{self, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n+use syntax::ast::{self, Item, MetaItem, ItemKind};\n+use syntax::codemap::DUMMY_SP;\n+use syntax::attr::{AttrMetaMethods, AttrNestedMetaItemMethods};\n use syntax::ext::base::*;\n+use syntax::ext::quote::rt::ToTokens;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n use syntax::tokenstream::TokenTree;\n@@ -41,30 +44,32 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         token::intern(\"duplicate\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_duplicate)));\n+    reg.register_syntax_extension(\n+        token::intern(\"caller\"),\n+        // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n+        MultiDecorator(Box::new(expand_caller)));\n }\n \n-fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n-                   -> Box<MacResult+'static> {\n+fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult + 'static> {\n     if !tts.is_empty() {\n         cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n     }\n     MacEager::expr(quote_expr!(cx, 1))\n }\n \n // See Issue #15750\n-fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n-                   -> Box<MacResult+'static> {\n+fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree]) -> Box<MacResult + 'static> {\n     // Parse an expression and emit it unchanged.\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(),\n-        cx.cfg(), tts.to_vec());\n+    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts.to_vec());\n     let expr = parser.parse_expr().unwrap();\n     MacEager::expr(quote_expr!(&mut *cx, $expr))\n }\n \n fn expand_into_foo_multi(cx: &mut ExtCtxt,\n-                         sp: Span,\n-                         attr: &MetaItem,\n-                         it: Annotatable) -> Vec<Annotatable> {\n+                         _sp: Span,\n+                         _attr: &MetaItem,\n+                         it: Annotatable)\n+                         -> Vec<Annotatable> {\n     match it {\n         Annotatable::Item(it) => vec![\n             Annotatable::Item(P(Item {\n@@ -74,7 +79,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n             Annotatable::Item(quote_item!(cx, enum Foo3 { Bar }).unwrap()),\n             Annotatable::Item(quote_item!(cx, #[cfg(any())] fn foo2() {}).unwrap()),\n         ],\n-        Annotatable::ImplItem(it) => vec![\n+        Annotatable::ImplItem(_it) => vec![\n             quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Impl(_, _, _, _, _, mut items) => {\n@@ -84,7 +89,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 }\n             })\n         ],\n-        Annotatable::TraitItem(it) => vec![\n+        Annotatable::TraitItem(_it) => vec![\n             quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Trait(_, _, _, mut items) => {\n@@ -99,15 +104,14 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n \n // Create a duplicate of the annotatable, based on the MetaItem\n fn expand_duplicate(cx: &mut ExtCtxt,\n-                    sp: Span,\n+                    _sp: Span,\n                     mi: &MetaItem,\n                     it: &Annotatable,\n-                    push: &mut FnMut(Annotatable))\n-{\n+                    push: &mut FnMut(Annotatable)) {\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(_, ref xs) => {\n-            if let ast::MetaItemKind::Word(ref w) = xs[0].node {\n-                token::str_to_ident(&w)\n+            if let Some(word) = xs[0].word() {\n+                token::str_to_ident(&word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;\n@@ -142,4 +146,69 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n     }\n }\n \n+pub fn token_separate<T: ToTokens>(ecx: &ExtCtxt, things: &[T],\n+                                   token: token::Token) -> Vec<TokenTree> {\n+    let mut output: Vec<TokenTree> = vec![];\n+    for (i, thing) in things.iter().enumerate() {\n+        output.extend(thing.to_tokens(ecx));\n+        if i < things.len() - 1 {\n+            output.push(TokenTree::Token(DUMMY_SP, token.clone()));\n+        }\n+    }\n+\n+    output\n+}\n+\n+fn expand_caller(cx: &mut ExtCtxt,\n+                 sp: Span,\n+                 mi: &MetaItem,\n+                 it: &Annotatable,\n+                 push: &mut FnMut(Annotatable)) {\n+    let (orig_fn_name, ret_type) = match *it {\n+        Annotatable::Item(ref item) => match item.node {\n+            ItemKind::Fn(ref decl, _, _, _, _, _) => {\n+                (item.ident, &decl.output)\n+            }\n+            _ => cx.span_fatal(item.span, \"Only functions with return types can be annotated.\")\n+        },\n+        _ => cx.span_fatal(sp, \"Only functions can be annotated.\")\n+    };\n+\n+    let (caller_name, arguments) = if let Some(list) = mi.meta_item_list() {\n+        if list.len() < 2 {\n+            cx.span_fatal(mi.span(), \"Need a function name and at least one parameter.\");\n+        }\n+\n+        let fn_name = match list[0].name() {\n+            Some(name) => token::str_to_ident(&name),\n+            None => cx.span_fatal(list[0].span(), \"First parameter must be an ident.\")\n+        };\n+\n+        (fn_name, &list[1..])\n+    } else {\n+        cx.span_fatal(mi.span, \"Expected list.\");\n+    };\n+\n+    let literals: Vec<ast::Lit> = arguments.iter().map(|arg| {\n+        if let Some(lit) = arg.literal() {\n+            lit.clone()\n+        } else {\n+            cx.span_fatal(arg.span(), \"Expected literal.\");\n+        }\n+    }).collect();\n+\n+    let arguments = token_separate(cx, literals.as_slice(), token::Comma);\n+    if let ast::FunctionRetTy::Ty(ref rt) = *ret_type {\n+        push(Annotatable::Item(quote_item!(cx,\n+                                           fn $caller_name() -> $rt {\n+                                               $orig_fn_name($arguments)\n+                                           }).unwrap()))\n+    } else {\n+        push(Annotatable::Item(quote_item!(cx,\n+                                           fn $caller_name() {\n+                                               $orig_fn_name($arguments)\n+                                           }).unwrap()))\n+    }\n+}\n+\n pub fn foo() {}"}, {"sha": "f21c914a76c9c7406bee608dda9d53a7f7a1b5ef", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin_args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -30,15 +30,15 @@ use syntax::tokenstream;\n use rustc_plugin::Registry;\n \n struct Expander {\n-    args: Vec<P<ast::MetaItem>>,\n+    args: Vec<ast::NestedMetaItem>,\n }\n \n impl TTMacroExpander for Expander {\n     fn expand<'cx>(&self,\n                    ecx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    _: &[tokenstream::TokenTree]) -> Box<MacResult+'cx> {\n-        let args = self.args.iter().map(|i| pprust::meta_item_to_string(&*i))\n+        let args = self.args.iter().map(|i| pprust::meta_list_item_to_string(i))\n             .collect::<Vec<_>>().join(\", \");\n         let interned = token::intern_and_get_ident(&args[..]);\n         MacEager::expr(ecx.expr_str(sp, interned))"}, {"sha": "6dc651bb653a31d9aed137d89d39c69fb42d0ca4", "filename": "src/test/run-pass-fulldeps/macro-crate-multi-decorator-literals.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250a26b5bcea9190ac63e756c35d8a54bf9da0c/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs?ref=8250a26b5bcea9190ac63e756c35d8a54bf9da0c", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// ignore-stage1\n+\n+#![feature(plugin, custom_attribute, attr_literals)]\n+#![plugin(macro_crate_test)]\n+\n+#[macro_use]\n+#[no_link]\n+extern crate macro_crate_test;\n+\n+// The `caller(name, args...)` attribute emits a new nullary function named\n+// `name` that calls the annotated function with `args`. As an example, consider\n+// the following:\n+//\n+//     #[caller(simple, 1, \"hello\", 3.14)]\n+//     fn f(num: isize, string: &'static str, float: f32) -> (isize, &'static str, float) {\n+//         (num, string, float)\n+//     }\n+//\n+// This results in a function named `simple` that calls `f(1, \"hello\", 3.14)`.\n+// As a result, the expression `simple()` evaluates to `(1, \"helllo\", 3.14)`.\n+\n+#[caller(simple, 1, \"hello\", 3.14)]\n+#[caller(simple1, 2, \"bye\", 6.28)]\n+#[caller(simple2, 3, \"hi\", 1.01)]\n+fn f(num: isize, string: &'static str, float: f32) -> (isize, &'static str, f32) {\n+    (num, string, float)\n+}\n+\n+#[caller(complex, true, 10)]\n+#[caller(complex1, false, 15)]\n+#[caller(complex2, true, 20)]\n+fn g(emit: bool, num: i32) -> Option<i32> {\n+    match emit {\n+        true => Some(num),\n+        false => None\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(simple(), (1, \"hello\", 3.14));\n+    assert_eq!(simple1(), (2, \"bye\", 6.28));\n+    assert_eq!(simple2(), (3, \"hi\", 1.01));\n+\n+    assert_eq!(complex(), Some(10));\n+    assert_eq!(complex1(), None);\n+    assert_eq!(complex2(), Some(20));\n+}"}]}