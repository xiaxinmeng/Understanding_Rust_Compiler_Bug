{"sha": "10af4fb5301a69cc9db46684290f3f77a4b65269", "node_id": "C_kwDOAAsO6NoAKDEwYWY0ZmI1MzAxYTY5Y2M5ZGI0NjY4NDI5MGYzZjc3YTRiNjUyNjk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-09-12T09:51:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-12T09:51:32Z"}, "message": "Rollup merge of #101671 - LingMan:ieee_754, r=Dylan-DPC\n\nFix naming format of IEEE 754 standard\n\nCurrently the documentation of f64::min refers to \"IEEE-754 2008\" while the documentation of f64::minimum refers to \"IEEE 754-2019\".\nNote that one has the format IEEE,hyphen,number,space,year while the other is IEEE,space,number,hyphen,year. The official IEEE site [1] uses the later format and it is also the one most commonly used throughout the codebase.\n\nUpdate all comments and - more importantly - documentation to consistently use the official format.\n\n[1] https://standards.ieee.org/ieee/754/4211/", "tree": {"sha": "40e478dc9b792d5eacec485518a17b364ce56c7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40e478dc9b792d5eacec485518a17b364ce56c7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10af4fb5301a69cc9db46684290f3f77a4b65269", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjHwEkCRBK7hj4Ov3rIwAAMdIIABhqifvHq3dOGu3SVt0wuB1p\nlYTS+iYcXUQuBCJOsz7Eb6WOARs5s+ZRfgCj2XyUjZn/xT2/l88HDewBFyosIsiw\nT22K0Djicpjm+3v4HxS4/pdt7rmhDcNaKPGqiRmt0HSD3QoMOlYQ8kVYjYhXdD3g\nuM5Te1UKXi6uRbYLz+Phpqmgxph+Ly2qwlHPKd+mOocz4a8+fktT/lyxJ2SadT1h\nusyEw0kbB2bXH4Ap5yd7/F4GULmu/Yx63FbjH2JRN8EJofr0ipwtwkMRMkrYFtAH\n1UjaslhVnaXjCktcrUzBQMscowLUTulB6PjaDa9L5QBJ9V2okIeh/Gf0s5KC1YM=\n=trhZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 40e478dc9b792d5eacec485518a17b364ce56c7e\nparent d7bad03cabe350b5d8aa6669108272ac06e8bea3\nparent fd21df7182affbf342f33f97353ee34ee7eb5441\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1662976292 +0530\ncommitter GitHub <noreply@github.com> 1662976292 +0530\n\nRollup merge of #101671 - LingMan:ieee_754, r=Dylan-DPC\n\nFix naming format of IEEE 754 standard\n\nCurrently the documentation of f64::min refers to \"IEEE-754 2008\" while the documentation of f64::minimum refers to \"IEEE 754-2019\".\nNote that one has the format IEEE,hyphen,number,space,year while the other is IEEE,space,number,hyphen,year. The official IEEE site [1] uses the later format and it is also the one most commonly used throughout the codebase.\n\nUpdate all comments and - more importantly - documentation to consistently use the official format.\n\n[1] https://standards.ieee.org/ieee/754/4211/\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10af4fb5301a69cc9db46684290f3f77a4b65269", "html_url": "https://github.com/rust-lang/rust/commit/10af4fb5301a69cc9db46684290f3f77a4b65269", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10af4fb5301a69cc9db46684290f3f77a4b65269/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7bad03cabe350b5d8aa6669108272ac06e8bea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7bad03cabe350b5d8aa6669108272ac06e8bea3", "html_url": "https://github.com/rust-lang/rust/commit/d7bad03cabe350b5d8aa6669108272ac06e8bea3"}, {"sha": "fd21df7182affbf342f33f97353ee34ee7eb5441", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd21df7182affbf342f33f97353ee34ee7eb5441", "html_url": "https://github.com/rust-lang/rust/commit/fd21df7182affbf342f33f97353ee34ee7eb5441"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "d49e29b6e6e7fa82a9956b0d0d60847b9e819d21", "filename": "library/core/src/ffi/c_double.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md", "raw_url": "https://github.com/rust-lang/rust/raw/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md?ref=10af4fb5301a69cc9db46684290f3f77a4b65269", "patch": "@@ -1,6 +1,6 @@\n Equivalent to C's `double` type.\n \n-This type will almost always be [`f64`], which is guaranteed to be an [IEEE-754 double-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a [`float`], and it may be `f32` or something entirely different from the IEEE-754 standard.\n+This type will almost always be [`f64`], which is guaranteed to be an [IEEE 754 double-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a [`float`], and it may be `f32` or something entirely different from the IEEE-754 standard.\n \n-[IEEE-754 double-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n+[IEEE 754 double-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n [`float`]: c_float"}, {"sha": "36374ef43618167b28090a6ed6be74114e84af74", "filename": "library/core/src/ffi/c_float.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md", "raw_url": "https://github.com/rust-lang/rust/raw/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md?ref=10af4fb5301a69cc9db46684290f3f77a4b65269", "patch": "@@ -1,5 +1,5 @@\n Equivalent to C's `float` type.\n \n-This type will almost always be [`f32`], which is guaranteed to be an [IEEE-754 single-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than `f32` or not follow the IEEE-754 standard at all.\n+This type will almost always be [`f32`], which is guaranteed to be an [IEEE 754 single-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than `f32` or not follow the IEEE-754 standard at all.\n \n-[IEEE-754 single-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n+[IEEE 754 single-precision float]: https://en.wikipedia.org/wiki/IEEE_754"}, {"sha": "2019f71e69b8c635e6d91b410c2403b57c81da32", "filename": "library/core/src/num/dec2flt/decimal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs?ref=10af4fb5301a69cc9db46684290f3f77a4b65269", "patch": "@@ -32,7 +32,7 @@ impl Default for Decimal {\n impl Decimal {\n     /// The maximum number of digits required to unambiguously round a float.\n     ///\n-    /// For a double-precision IEEE-754 float, this required 767 digits,\n+    /// For a double-precision IEEE 754 float, this required 767 digits,\n     /// so we store the max digits + 1.\n     ///\n     /// We can exactly represent a float in radix `b` from radix 2 if"}, {"sha": "2c6a0ba64f266ea5f4165a4040e9d80039173d06", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=10af4fb5301a69cc9db46684290f3f77a4b65269", "patch": "@@ -394,7 +394,7 @@ impl f32 {\n \n     /// Not a Number (NaN).\n     ///\n-    /// Note that IEEE-754 doesn't define just a single NaN value;\n+    /// Note that IEEE 754 doesn't define just a single NaN value;\n     /// a plethora of bit patterns are considered to be NaN.\n     /// Furthermore, the standard makes a difference\n     /// between a \"signaling\" and a \"quiet\" NaN,\n@@ -632,7 +632,7 @@ impl f32 {\n     }\n \n     /// Returns `true` if `self` has a positive sign, including `+0.0`, NaNs with\n-    /// positive sign bit and positive infinity. Note that IEEE-754 doesn't assign any\n+    /// positive sign bit and positive infinity. Note that IEEE 754 doesn't assign any\n     /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n     /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n     /// `is_sign_positive` on a NaN might produce an unexpected result in some cases.\n@@ -654,7 +654,7 @@ impl f32 {\n     }\n \n     /// Returns `true` if `self` has a negative sign, including `-0.0`, NaNs with\n-    /// negative sign bit and negative infinity. Note that IEEE-754 doesn't assign any\n+    /// negative sign bit and negative infinity. Note that IEEE 754 doesn't assign any\n     /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n     /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n     /// `is_sign_negative` on a NaN might produce an unexpected result in some cases.\n@@ -833,7 +833,7 @@ impl f32 {\n     /// Returns the maximum of the two numbers, ignoring NaN.\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n-    /// This follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs;\n+    /// This follows the IEEE 754-2008 semantics for maxNum, except for handling of signaling NaNs;\n     /// this function handles all NaNs the same way and avoids maxNum's problems with associativity.\n     /// This also matches the behavior of libm\u2019s fmax.\n     ///\n@@ -853,7 +853,7 @@ impl f32 {\n     /// Returns the minimum of the two numbers, ignoring NaN.\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n-    /// This follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs;\n+    /// This follows the IEEE 754-2008 semantics for minNum, except for handling of signaling NaNs;\n     /// this function handles all NaNs the same way and avoids minNum's problems with associativity.\n     /// This also matches the behavior of libm\u2019s fmin.\n     ///\n@@ -1051,9 +1051,9 @@ impl f32 {\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n     /// * Floats and Ints have the same endianness on all supported platforms.\n-    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    /// * IEEE 754 very precisely specifies the bit layout of floats.\n     ///\n-    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// However there is one caveat: prior to the 2008 version of IEEE 754, how\n     /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n     /// (notably x86 and ARM) picked the interpretation that was ultimately\n     /// standardized in 2008, but some didn't (notably MIPS). As a result, all"}, {"sha": "fd3c18ce29bd289c3822937e7e4c23b54dc661ad", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=10af4fb5301a69cc9db46684290f3f77a4b65269", "patch": "@@ -393,7 +393,7 @@ impl f64 {\n \n     /// Not a Number (NaN).\n     ///\n-    /// Note that IEEE-754 doesn't define just a single NaN value;\n+    /// Note that IEEE 754 doesn't define just a single NaN value;\n     /// a plethora of bit patterns are considered to be NaN.\n     /// Furthermore, the standard makes a difference\n     /// between a \"signaling\" and a \"quiet\" NaN,\n@@ -624,7 +624,7 @@ impl f64 {\n     }\n \n     /// Returns `true` if `self` has a positive sign, including `+0.0`, NaNs with\n-    /// positive sign bit and positive infinity. Note that IEEE-754 doesn't assign any\n+    /// positive sign bit and positive infinity. Note that IEEE 754 doesn't assign any\n     /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n     /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n     /// `is_sign_positive` on a NaN might produce an unexpected result in some cases.\n@@ -655,7 +655,7 @@ impl f64 {\n     }\n \n     /// Returns `true` if `self` has a negative sign, including `-0.0`, NaNs with\n-    /// negative sign bit and negative infinity. Note that IEEE-754 doesn't assign any\n+    /// negative sign bit and negative infinity. Note that IEEE 754 doesn't assign any\n     /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n     /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n     /// `is_sign_negative` on a NaN might produce an unexpected result in some cases.\n@@ -844,7 +844,7 @@ impl f64 {\n     /// Returns the maximum of the two numbers, ignoring NaN.\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n-    /// This follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs;\n+    /// This follows the IEEE 754-2008 semantics for maxNum, except for handling of signaling NaNs;\n     /// this function handles all NaNs the same way and avoids maxNum's problems with associativity.\n     /// This also matches the behavior of libm\u2019s fmax.\n     ///\n@@ -864,7 +864,7 @@ impl f64 {\n     /// Returns the minimum of the two numbers, ignoring NaN.\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n-    /// This follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs;\n+    /// This follows the IEEE 754-2008 semantics for minNum, except for handling of signaling NaNs;\n     /// this function handles all NaNs the same way and avoids minNum's problems with associativity.\n     /// This also matches the behavior of libm\u2019s fmin.\n     ///\n@@ -1044,9 +1044,9 @@ impl f64 {\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n     /// * Floats and Ints have the same endianness on all supported platforms.\n-    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    /// * IEEE 754 very precisely specifies the bit layout of floats.\n     ///\n-    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// However there is one caveat: prior to the 2008 version of IEEE 754, how\n     /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n     /// (notably x86 and ARM) picked the interpretation that was ultimately\n     /// standardized in 2008, but some didn't (notably MIPS). As a result, all"}, {"sha": "b33b080126131da2594b861682e59105e5ba8a31", "filename": "library/test/src/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Ftest%2Fsrc%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10af4fb5301a69cc9db46684290f3f77a4b65269/library%2Ftest%2Fsrc%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fstats.rs?ref=10af4fb5301a69cc9db46684290f3f77a4b65269", "patch": "@@ -14,7 +14,7 @@ pub trait Stats {\n     /// Sum of the samples.\n     ///\n     /// Note: this method sacrifices performance at the altar of accuracy\n-    /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n+    /// Depends on IEEE 754 arithmetic guarantees. See proof of correctness at:\n     /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric\n     /// Predicates\"][paper]\n     ///"}]}