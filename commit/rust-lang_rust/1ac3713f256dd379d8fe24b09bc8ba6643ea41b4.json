{"sha": "1ac3713f256dd379d8fe24b09bc8ba6643ea41b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYzM3MTNmMjU2ZGQzNzlkOGZlMjRiMDliYzhiYTY2NDNlYTQxYjQ=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-17T19:40:47Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-17T19:49:59Z"}, "message": "refactor ty_is_non_local", "tree": {"sha": "9a6b8282c5ace24db28e8da3a7feee24da0209cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a6b8282c5ace24db28e8da3a7feee24da0209cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ac3713f256dd379d8fe24b09bc8ba6643ea41b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac3713f256dd379d8fe24b09bc8ba6643ea41b4", "html_url": "https://github.com/rust-lang/rust/commit/1ac3713f256dd379d8fe24b09bc8ba6643ea41b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ac3713f256dd379d8fe24b09bc8ba6643ea41b4/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5300ca38d88b924f7108274c50d918728c53aecd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5300ca38d88b924f7108274c50d918728c53aecd", "html_url": "https://github.com/rust-lang/rust/commit/5300ca38d88b924f7108274c50d918728c53aecd"}], "stats": {"total": 33, "additions": 18, "deletions": 15}, "files": [{"sha": "b3218f97e42b56af7abfc05bbeae215062534438", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1ac3713f256dd379d8fe24b09bc8ba6643ea41b4/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac3713f256dd379d8fe24b09bc8ba6643ea41b4/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=1ac3713f256dd379d8fe24b09bc8ba6643ea41b4", "patch": "@@ -389,7 +389,7 @@ fn orphan_check_trait_ref<'tcx>(\n     ) -> Vec<Ty<'tcx>> {\n         // FIXME(eddyb) figure out if this is redundant with `ty_is_non_local`,\n         // or maybe if this should be calling `ty_is_non_local_constructor`.\n-        if ty_is_non_local(tcx, ty, in_crate).is_some() {\n+        if !contained_non_local_types(tcx, ty, in_crate).is_empty() {\n             if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n                 return inner_tys\n                     .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n@@ -408,8 +408,8 @@ fn orphan_check_trait_ref<'tcx>(\n         .enumerate()\n     {\n         debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n-        if non_local_tys.is_none() {\n+        let non_local_tys = contained_non_local_types(tcx, input_ty, in_crate);\n+        if non_local_tys.is_empty() {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n             return Ok(());\n         } else if let ty::Param(_) = input_ty.kind {\n@@ -424,27 +424,30 @@ fn orphan_check_trait_ref<'tcx>(\n \n             return Err(OrphanCheckErr::UncoveredTy(input_ty, local_type));\n         }\n-        if let Some(non_local_tys) = non_local_tys {\n-            for input_ty in non_local_tys {\n-                non_local_spans.push((input_ty, i == 0));\n-            }\n+\n+        for input_ty in non_local_tys {\n+            non_local_spans.push((input_ty, i == 0));\n         }\n     }\n     // If we exit above loop, never found a local type.\n     debug!(\"orphan_check_trait_ref: no local type\");\n     Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-// FIXME: Return a `Vec` without `Option` here.\n-fn ty_is_non_local(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, in_crate: InCrate) -> Option<Vec<Ty<'tcx>>> {\n+/// Returns a list of relevant non-local types for `ty`.\n+///\n+/// This is just `ty` itself unless `ty` is `#[fundamental]`,\n+/// in which case we recursively look into this type.\n+fn contained_non_local_types(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n     if ty_is_local_constructor(ty, in_crate) {\n-        None\n-    } else if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n-        let tys: Vec<_> =\n-            inner_tys.filter_map(|ty| ty_is_non_local(tcx, ty, in_crate)).flatten().collect();\n-        if tys.is_empty() { None } else { Some(tys) }\n+        Vec::new()\n     } else {\n-        Some(vec![ty])\n+        match fundamental_ty_inner_tys(tcx, ty) {\n+            Some(inner_tys) => {\n+                inner_tys.flat_map(|ty| contained_non_local_types(tcx, ty, in_crate)).collect()\n+            }\n+            None => vec![ty],\n+        }\n     }\n }\n "}]}