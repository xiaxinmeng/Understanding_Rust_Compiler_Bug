{"sha": "88b0b511beed1599c5bddaf05b9cd0f98bd714ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YjBiNTExYmVlZDE1OTljNWJkZGFmMDViOWNkMGY5OGJkNzE0Y2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-02T00:41:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-02T00:41:29Z"}, "message": "auto merge of #9578 : alexcrichton/rust/un-ignore-libuv-process-tests, r=brson\n\nCloses #9341", "tree": {"sha": "52c4981cac8d0505c725044806e65a78d7ddebb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52c4981cac8d0505c725044806e65a78d7ddebb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88b0b511beed1599c5bddaf05b9cd0f98bd714ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88b0b511beed1599c5bddaf05b9cd0f98bd714ca", "html_url": "https://github.com/rust-lang/rust/commit/88b0b511beed1599c5bddaf05b9cd0f98bd714ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88b0b511beed1599c5bddaf05b9cd0f98bd714ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe4e7478c5b89994795292db2cea2f944c0f1013", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4e7478c5b89994795292db2cea2f944c0f1013", "html_url": "https://github.com/rust-lang/rust/commit/fe4e7478c5b89994795292db2cea2f944c0f1013"}, {"sha": "02cbfce0b3a2962a5faf6065bd652ea165a666ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/02cbfce0b3a2962a5faf6065bd652ea165a666ca", "html_url": "https://github.com/rust-lang/rust/commit/02cbfce0b3a2962a5faf6065bd652ea165a666ca"}], "stats": {"total": 300, "additions": 158, "deletions": 142}, "files": [{"sha": "b2dbd8ee1f47ab3620e0cceef23ef2f0d309e208", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 2, "deletions": 142, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/88b0b511beed1599c5bddaf05b9cd0f98bd714ca/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b0b511beed1599c5bddaf05b9cd0f98bd714ca/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=88b0b511beed1599c5bddaf05b9cd0f98bd714ca", "patch": "@@ -140,145 +140,5 @@ impl Drop for Process {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-\n-    use rt::io::{Reader, Writer};\n-    use rt::io::pipe::*;\n-    use str;\n-\n-    #[test]\n-    #[cfg(unix, not(android))]\n-    #[ignore] // FIXME(#9341)\n-    fn smoke() {\n-        let io = ~[];\n-        let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"true\"],\n-            env: None,\n-            cwd: None,\n-            io: io,\n-        };\n-        let p = Process::new(args);\n-        assert!(p.is_some());\n-        let mut p = p.unwrap();\n-        assert_eq!(p.wait(), 0);\n-    }\n-\n-    #[test]\n-    #[cfg(unix, not(android))]\n-    #[ignore] // FIXME(#9341)\n-    fn smoke_failure() {\n-        let io = ~[];\n-        let args = ProcessConfig {\n-            program: \"if-this-is-a-binary-then-the-world-has-ended\",\n-            args: [],\n-            env: None,\n-            cwd: None,\n-            io: io,\n-        };\n-        let p = Process::new(args);\n-        assert!(p.is_some());\n-        let mut p = p.unwrap();\n-        assert!(p.wait() != 0);\n-    }\n-\n-    #[test]\n-    #[cfg(unix, not(android))]\n-    #[ignore] // FIXME(#9341)\n-    fn exit_reported_right() {\n-        let io = ~[];\n-        let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"exit 1\"],\n-            env: None,\n-            cwd: None,\n-            io: io,\n-        };\n-        let p = Process::new(args);\n-        assert!(p.is_some());\n-        let mut p = p.unwrap();\n-        assert_eq!(p.wait(), 1);\n-    }\n-\n-    fn read_all(input: &mut Reader) -> ~str {\n-        let mut ret = ~\"\";\n-        let mut buf = [0, ..1024];\n-        loop {\n-            match input.read(buf) {\n-                None | Some(0) => { break }\n-                Some(n) => { ret = ret + str::from_utf8(buf.slice_to(n)); }\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    fn run_output(args: ProcessConfig) -> ~str {\n-        let p = Process::new(args);\n-        assert!(p.is_some());\n-        let mut p = p.unwrap();\n-        assert!(p.io[0].is_none());\n-        assert!(p.io[1].is_some());\n-        let ret = read_all(p.io[1].get_mut_ref() as &mut Reader);\n-        assert_eq!(p.wait(), 0);\n-        return ret;\n-    }\n-\n-    #[test]\n-    #[cfg(unix, not(android))]\n-    #[ignore] // FIXME(#9341)\n-    fn stdout_works() {\n-        let pipe = PipeStream::new().unwrap();\n-        let io = ~[Ignored, CreatePipe(pipe, false, true)];\n-        let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"echo foobar\"],\n-            env: None,\n-            cwd: None,\n-            io: io,\n-        };\n-        assert_eq!(run_output(args), ~\"foobar\\n\");\n-    }\n-\n-    #[test]\n-    #[cfg(unix, not(android))]\n-    #[ignore] // FIXME(#9341)\n-    fn set_cwd_works() {\n-        let pipe = PipeStream::new().unwrap();\n-        let io = ~[Ignored, CreatePipe(pipe, false, true)];\n-        let cwd = Some(\"/\");\n-        let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"pwd\"],\n-            env: None,\n-            cwd: cwd,\n-            io: io,\n-        };\n-        assert_eq!(run_output(args), ~\"/\\n\");\n-    }\n-\n-    #[test]\n-    #[cfg(unix, not(android))]\n-    #[ignore] // FIXME(#9341)\n-    fn stdin_works() {\n-        let input = PipeStream::new().unwrap();\n-        let output = PipeStream::new().unwrap();\n-        let io = ~[CreatePipe(input, true, false),\n-                   CreatePipe(output, false, true)];\n-        let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"read line; echo $line\"],\n-            env: None,\n-            cwd: None,\n-            io: io,\n-        };\n-        let mut p = Process::new(args).expect(\"didn't create a proces?!\");\n-        p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n-        p.io[0] = None; // close stdin;\n-        let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n-        assert_eq!(p.wait(), 0);\n-        assert_eq!(out, ~\"foobar\\n\");\n-    }\n-}\n+// Tests for this module can be found in the rtio-processes run-pass test, along\n+// with the justification for why it's not located here."}, {"sha": "e4d3b0ed872d5c18628af9e4a2b067a5e2d6c55c", "filename": "src/test/run-pass/rtio-processes.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/88b0b511beed1599c5bddaf05b9cd0f98bd714ca/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b0b511beed1599c5bddaf05b9cd0f98bd714ca/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frtio-processes.rs?ref=88b0b511beed1599c5bddaf05b9cd0f98bd714ca", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+// xfail-fast\n+\n+// In the current state of affairs, libuv registers a SIGCHLD handler when a\n+// process is spawned through it. This is not done with a SA_RESTART flag,\n+// meaning that all of our syscalls run the risk of returning EINTR. This error\n+// is not correctly handled in the majority of std::io, so these can't run with\n+// the main body of tests there.\n+//\n+// That being said, libuv correctly handles EINTR completely, so these tests\n+// themselves are safe against that. Currently the test runner may run into this\n+// problem, but it's less likely than a whole suite of tests...\n+//\n+// See #9341\n+\n+use std::rt::io::process::*;\n+use std::rt::io::{Reader, Writer};\n+use std::rt::io::pipe::*;\n+use std::str;\n+\n+#[test]\n+#[cfg(unix, not(android))]\n+fn smoke() {\n+    let io = ~[];\n+    let args = ProcessConfig {\n+        program: \"/bin/sh\",\n+        args: [~\"-c\", ~\"true\"],\n+        env: None,\n+        cwd: None,\n+        io: io,\n+    };\n+    let p = Process::new(args);\n+    assert!(p.is_some());\n+    let mut p = p.unwrap();\n+    assert_eq!(p.wait(), 0);\n+}\n+\n+#[test]\n+#[cfg(unix, not(android))]\n+fn smoke_failure() {\n+    let io = ~[];\n+    let args = ProcessConfig {\n+        program: \"if-this-is-a-binary-then-the-world-has-ended\",\n+        args: [],\n+        env: None,\n+        cwd: None,\n+        io: io,\n+    };\n+    let p = Process::new(args);\n+    assert!(p.is_some());\n+    let mut p = p.unwrap();\n+    assert!(p.wait() != 0);\n+}\n+\n+#[test]\n+#[cfg(unix, not(android))]\n+fn exit_reported_right() {\n+    let io = ~[];\n+    let args = ProcessConfig {\n+        program: \"/bin/sh\",\n+        args: [~\"-c\", ~\"exit 1\"],\n+        env: None,\n+        cwd: None,\n+        io: io,\n+    };\n+    let p = Process::new(args);\n+    assert!(p.is_some());\n+    let mut p = p.unwrap();\n+    assert_eq!(p.wait(), 1);\n+}\n+\n+fn read_all(input: &mut Reader) -> ~str {\n+    let mut ret = ~\"\";\n+    let mut buf = [0, ..1024];\n+    loop {\n+        match input.read(buf) {\n+            None | Some(0) => { break }\n+            Some(n) => { ret = ret + str::from_utf8(buf.slice_to(n)); }\n+        }\n+    }\n+    return ret;\n+}\n+\n+fn run_output(args: ProcessConfig) -> ~str {\n+    let p = Process::new(args);\n+    assert!(p.is_some());\n+    let mut p = p.unwrap();\n+    assert!(p.io[0].is_none());\n+    assert!(p.io[1].is_some());\n+    let ret = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+    assert_eq!(p.wait(), 0);\n+    return ret;\n+}\n+\n+#[test]\n+#[cfg(unix, not(android))]\n+fn stdout_works() {\n+    let pipe = PipeStream::new().unwrap();\n+    let io = ~[Ignored, CreatePipe(pipe, false, true)];\n+    let args = ProcessConfig {\n+        program: \"/bin/sh\",\n+        args: [~\"-c\", ~\"echo foobar\"],\n+        env: None,\n+        cwd: None,\n+        io: io,\n+    };\n+    assert_eq!(run_output(args), ~\"foobar\\n\");\n+}\n+\n+#[test]\n+#[cfg(unix, not(android))]\n+fn set_cwd_works() {\n+    let pipe = PipeStream::new().unwrap();\n+    let io = ~[Ignored, CreatePipe(pipe, false, true)];\n+    let cwd = Some(\"/\");\n+    let args = ProcessConfig {\n+        program: \"/bin/sh\",\n+        args: [~\"-c\", ~\"pwd\"],\n+        env: None,\n+        cwd: cwd,\n+        io: io,\n+    };\n+    assert_eq!(run_output(args), ~\"/\\n\");\n+}\n+\n+#[test]\n+#[cfg(unix, not(android))]\n+fn stdin_works() {\n+    let input = PipeStream::new().unwrap();\n+    let output = PipeStream::new().unwrap();\n+    let io = ~[CreatePipe(input, true, false),\n+               CreatePipe(output, false, true)];\n+    let args = ProcessConfig {\n+        program: \"/bin/sh\",\n+        args: [~\"-c\", ~\"read line; echo $line\"],\n+        env: None,\n+        cwd: None,\n+        io: io,\n+    };\n+    let mut p = Process::new(args).expect(\"didn't create a proces?!\");\n+    p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n+    p.io[0] = None; // close stdin;\n+    let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+    assert_eq!(p.wait(), 0);\n+    assert_eq!(out, ~\"foobar\\n\");\n+}"}]}