{"sha": "6861750e663dbbf8c347e90a35e056d8d2e8c5b1", "node_id": "C_kwDOAAsO6NoAKDY4NjE3NTBlNjYzZGJiZjhjMzQ3ZTkwYTM1ZTA1NmQ4ZDJlOGM1YjE", "commit": {"author": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2023-04-05T07:37:30Z"}, "committer": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2023-04-05T07:37:30Z"}, "message": "Fix buffer overrun in (test-only) symlink_junction", "tree": {"sha": "51b0e058ceb10334c8839977c693aea2883ff9cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51b0e058ceb10334c8839977c693aea2883ff9cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6861750e663dbbf8c347e90a35e056d8d2e8c5b1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgMrDyZKNSLq6TEmWvPtNWv4vJNv\nay7sfrM7c6iOWHdh8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQGDPlKmWDiOZju8p3akq6/gRgzSj5zk1094VA4ATr+KjmBww0/3uUJxbBDsdyCECXp\nvsg0sO8peEOG042xv8aQk=\n-----END SSH SIGNATURE-----", "payload": "tree 51b0e058ceb10334c8839977c693aea2883ff9cf\nparent 540a50df0fb23127edf0b35b0e497748e24bba1a\nauthor Thom Chiovoloni <thom@shift.click> 1680680250 -0700\ncommitter Thom Chiovoloni <thom@shift.click> 1680680250 -0700\n\nFix buffer overrun in (test-only) symlink_junction\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6861750e663dbbf8c347e90a35e056d8d2e8c5b1", "html_url": "https://github.com/rust-lang/rust/commit/6861750e663dbbf8c347e90a35e056d8d2e8c5b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6861750e663dbbf8c347e90a35e056d8d2e8c5b1/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "540a50df0fb23127edf0b35b0e497748e24bba1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/540a50df0fb23127edf0b35b0e497748e24bba1a", "html_url": "https://github.com/rust-lang/rust/commit/540a50df0fb23127edf0b35b0e497748e24bba1a"}], "stats": {"total": 34, "additions": 25, "deletions": 9}, "files": [{"sha": "956db577d537182cd4fbd37e4329a2eb4528b7c8", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6861750e663dbbf8c347e90a35e056d8d2e8c5b1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6861750e663dbbf8c347e90a35e056d8d2e8c5b1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=6861750e663dbbf8c347e90a35e056d8d2e8c5b1", "patch": "@@ -1403,24 +1403,40 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n     opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT | c::FILE_FLAG_BACKUP_SEMANTICS);\n     let f = File::open(junction, &opts)?;\n     let h = f.as_inner().as_raw_handle();\n-\n     unsafe {\n         let mut data = Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n         let data_ptr = data.0.as_mut_ptr();\n+        let data_end = data_ptr.add(c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE);\n         let db = data_ptr.cast::<c::REPARSE_MOUNTPOINT_DATA_BUFFER>();\n         // Zero the header to ensure it's fully initialized, including reserved parameters.\n         *db = mem::zeroed();\n-        let buf = ptr::addr_of_mut!((*db).ReparseTarget).cast::<c::WCHAR>();\n-        let mut i = 0;\n+        let reparse_target_slice = {\n+            let buf_start = ptr::addr_of_mut!((*db).ReparseTarget).cast::<c::WCHAR>();\n+            // Compute offset in bytes and then divide so that we round down\n+            // rather than hit any UB (admittedly this arithmetic should work\n+            // out so that this isn't necessary)\n+            let buf_len_bytes = usize::try_from(data_end.byte_offset_from(buf_start)).unwrap();\n+            let buf_len_wchars = buf_len_bytes / core::mem::size_of::<c::WCHAR>();\n+            core::slice::from_raw_parts_mut(buf_start, buf_len_wchars)\n+        };\n+\n         // FIXME: this conversion is very hacky\n-        let v = br\"\\??\\\";\n-        let v = v.iter().map(|x| *x as u16);\n-        for c in v.chain(original.as_os_str().encode_wide()) {\n-            *buf.add(i) = c;\n+        let iter = br\"\\??\\\"\n+            .iter()\n+            .map(|x| *x as u16)\n+            .chain(original.as_os_str().encode_wide())\n+            .chain(core::iter::once(0));\n+        let mut i = 0;\n+        for c in iter {\n+            if i >= reparse_target_slice.len() {\n+                return Err(crate::io::const_io_error!(\n+                    crate::io::ErrorKind::InvalidFilename,\n+                    \"Input filename is too long\"\n+                ));\n+            }\n+            reparse_target_slice[i] = c;\n             i += 1;\n         }\n-        *buf.add(i) = 0;\n-        i += 1;\n         (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n         (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;\n         (*db).ReparseTargetLength = ((i - 1) * 2) as c::WORD;"}]}