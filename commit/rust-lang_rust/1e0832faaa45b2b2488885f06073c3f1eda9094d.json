{"sha": "1e0832faaa45b2b2488885f06073c3f1eda9094d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMDgzMmZhYWE0NWIyYjI0ODg4ODVmMDYwNzNjM2YxZWRhOTA5NGQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-07T18:42:08Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-11T16:08:23Z"}, "message": "Allow all impl trait types to capture bound lifetimes", "tree": {"sha": "f3555d5bcb713ffc92c7e3a12cac5dcd35cc067b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3555d5bcb713ffc92c7e3a12cac5dcd35cc067b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e0832faaa45b2b2488885f06073c3f1eda9094d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e0832faaa45b2b2488885f06073c3f1eda9094d", "html_url": "https://github.com/rust-lang/rust/commit/1e0832faaa45b2b2488885f06073c3f1eda9094d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e0832faaa45b2b2488885f06073c3f1eda9094d/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee0d3c7f906ae293be30a607e216e9f00ea22f08", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee0d3c7f906ae293be30a607e216e9f00ea22f08", "html_url": "https://github.com/rust-lang/rust/commit/ee0d3c7f906ae293be30a607e216e9f00ea22f08"}], "stats": {"total": 206, "additions": 159, "deletions": 47}, "files": [{"sha": "8cfbd408e22b3878078f479eb88d249a2cfd929c", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1e0832faaa45b2b2488885f06073c3f1eda9094d/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0832faaa45b2b2488885f06073c3f1eda9094d/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=1e0832faaa45b2b2488885f06073c3f1eda9094d", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -286,8 +287,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n             ItemKind::TyAlias(_, ref gen, _, Some(ref ty)) => {\n-                let ty =\n-                    self.lower_ty(ty, ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc));\n+                // We lower\n+                //\n+                // type Foo = impl Trait\n+                //\n+                // to\n+                //\n+                // type Foo = Foo1\n+                // opaque type Foo1: Trait\n+                let ty = self.lower_ty(\n+                    ty,\n+                    ImplTraitContext::OtherOpaqueTy {\n+                        capturable_lifetimes: &mut FxHashSet::default(),\n+                        origin: hir::OpaqueTyOrigin::Misc,\n+                    },\n+                );\n                 let generics = self.lower_generics(gen, ImplTraitContext::disallowed());\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n@@ -420,8 +434,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         body: Option<&Expr>,\n     ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n+        let mut capturable_lifetimes;\n         let itctx = if self.sess.features_untracked().impl_trait_in_bindings {\n-            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n+            capturable_lifetimes = FxHashSet::default();\n+            ImplTraitContext::OtherOpaqueTy {\n+                capturable_lifetimes: &mut capturable_lifetimes,\n+                origin: hir::OpaqueTyOrigin::Misc,\n+            }\n         } else {\n             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n         };\n@@ -829,7 +848,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     Some(ty) => {\n                         let ty = self.lower_ty(\n                             ty,\n-                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut FxHashSet::default(),\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n                         );\n                         hir::ImplItemKind::TyAlias(ty)\n                     }"}, {"sha": "d7946ad009415cfab41058a8dc7e893bc057f20e", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 119, "deletions": 28, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/1e0832faaa45b2b2488885f06073c3f1eda9094d/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0832faaa45b2b2488885f06073c3f1eda9094d/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=1e0832faaa45b2b2488885f06073c3f1eda9094d", "patch": "@@ -224,11 +224,30 @@ enum ImplTraitContext<'b, 'a> {\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n     /// equivalent to a new opaque type like `type T = impl Debug; fn foo() -> T`.\n     ///\n-    /// We optionally store a `DefId` for the parent item here so we can look up necessary\n-    /// information later. It is `None` when no information about the context should be stored\n-    /// (e.g., for consts and statics).\n-    OpaqueTy(Option<DefId> /* fn def-ID */, hir::OpaqueTyOrigin),\n-\n+    ReturnPositionOpaqueTy {\n+        /// `DefId` for the parent function, used to look up necessary\n+        /// information later.\n+        fn_def_id: DefId,\n+        /// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,\n+        origin: hir::OpaqueTyOrigin,\n+    },\n+    /// Impl trait in type aliases, consts and statics.\n+    OtherOpaqueTy {\n+        /// Set of lifetimes that this opaque type can capture, if it uses\n+        /// them. This includes lifetimes bound since we entered this context.\n+        /// For example, in\n+        ///\n+        /// type A<'b> = impl for<'a> Trait<'a, Out = impl Sized + 'a>;\n+        ///\n+        /// the inner opaque type captures `'a` because it uses it. It doesn't\n+        /// need to capture `'b` because it already inherits the lifetime\n+        /// parameter from `A`.\n+        // FIXME(impl_trait): but `required_region_bounds` will ICE later\n+        // anyway.\n+        capturable_lifetimes: &'b mut FxHashSet<hir::LifetimeName>,\n+        /// Origin: Either OpaqueTyOrigin::Misc or OpaqueTyOrigin::Binding,\n+        origin: hir::OpaqueTyOrigin,\n+    },\n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n }\n@@ -253,7 +272,12 @@ impl<'a> ImplTraitContext<'_, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n-            OpaqueTy(fn_def_id, origin) => OpaqueTy(*fn_def_id, *origin),\n+            ReturnPositionOpaqueTy { fn_def_id, origin } => {\n+                ReturnPositionOpaqueTy { fn_def_id: *fn_def_id, origin: *origin }\n+            }\n+            OtherOpaqueTy { capturable_lifetimes, origin } => {\n+                OtherOpaqueTy { capturable_lifetimes, origin: *origin }\n+            }\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -1001,6 +1025,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::TypeBindingKind::Equality { ty: self.lower_ty(ty, itctx) }\n             }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n+                let mut capturable_lifetimes;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1010,7 +1035,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo() -> impl Iterator<Item = impl Debug>\n-                    ImplTraitContext::OpaqueTy(..) => (true, itctx),\n+                    ImplTraitContext::ReturnPositionOpaqueTy { .. }\n+                    | ImplTraitContext::OtherOpaqueTy { .. } => (true, itctx),\n \n                     // We are in the argument position, but within a dyn type:\n                     //\n@@ -1028,7 +1054,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => {\n-                        (true, ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc))\n+                        capturable_lifetimes = FxHashSet::default();\n+                        (\n+                            true,\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut capturable_lifetimes,\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n+                        )\n                     }\n \n                     // We are in the parameter position, but not within a dyn type:\n@@ -1270,10 +1303,31 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::OpaqueTy(fn_def_id, origin) => {\n-                        self.lower_opaque_impl_trait(span, fn_def_id, origin, def_node_id, |this| {\n-                            this.lower_param_bounds(bounds, itctx)\n-                        })\n+                    ImplTraitContext::ReturnPositionOpaqueTy { fn_def_id, origin } => self\n+                        .lower_opaque_impl_trait(\n+                            span,\n+                            Some(fn_def_id),\n+                            origin,\n+                            def_node_id,\n+                            None,\n+                            |this| this.lower_param_bounds(bounds, itctx),\n+                        ),\n+                    ImplTraitContext::OtherOpaqueTy { ref capturable_lifetimes, origin } => {\n+                        // Reset capturable lifetimes, any nested impl trait\n+                        // types will inherit lifetimes from this opaque type,\n+                        // so don't need to capture them again.\n+                        let nested_itctx = ImplTraitContext::OtherOpaqueTy {\n+                            capturable_lifetimes: &mut FxHashSet::default(),\n+                            origin,\n+                        };\n+                        self.lower_opaque_impl_trait(\n+                            span,\n+                            None,\n+                            origin,\n+                            def_node_id,\n+                            Some(capturable_lifetimes),\n+                            |this| this.lower_param_bounds(bounds, nested_itctx),\n+                        )\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         // Add a definition for the in-band `Param`.\n@@ -1351,6 +1405,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         fn_def_id: Option<DefId>,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n+        capturable_lifetimes: Option<&FxHashSet<hir::LifetimeName>>,\n         lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n     ) -> hir::TyKind<'hir> {\n         debug!(\n@@ -1371,17 +1426,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let hir_bounds = self.with_hir_id_owner(opaque_ty_node_id, lower_bounds);\n \n-        let (lifetimes, lifetime_defs): (&[_], &[_]) = if fn_def_id.is_some() {\n-            self.lifetimes_from_impl_trait_bounds(opaque_ty_node_id, opaque_ty_def_id, &hir_bounds)\n-        } else {\n-            // Non return-position impl trait captures all of the lifetimes of\n-            // the parent item.\n-            (&[], &[])\n-        };\n+        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n+            opaque_ty_node_id,\n+            opaque_ty_def_id,\n+            &hir_bounds,\n+            capturable_lifetimes,\n+        );\n \n-        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,);\n+        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes);\n \n-        debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,);\n+        debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n \n         self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n@@ -1438,6 +1492,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         opaque_ty_id: NodeId,\n         parent_def_id: LocalDefId,\n         bounds: hir::GenericBounds<'hir>,\n+        lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n     ) -> (&'hir [hir::GenericArg<'hir>], &'hir [hir::GenericParam<'hir>]) {\n         debug!(\n             \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n@@ -1458,6 +1513,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n             output_lifetimes: Vec<hir::GenericArg<'hir>>,\n             output_lifetime_params: Vec<hir::GenericParam<'hir>>,\n+            lifetimes_to_include: Option<&'r FxHashSet<hir::LifetimeName>>,\n         }\n \n         impl<'r, 'a, 'v, 'hir> intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n@@ -1543,6 +1599,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 if !self.currently_bound_lifetimes.contains(&name)\n                     && !self.already_defined_lifetimes.contains(&name)\n+                    && self.lifetimes_to_include.map_or(true, |lifetimes| lifetimes.contains(&name))\n                 {\n                     self.already_defined_lifetimes.insert(name);\n \n@@ -1596,6 +1653,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             already_defined_lifetimes: FxHashSet::default(),\n             output_lifetimes: Vec::new(),\n             output_lifetime_params: Vec::new(),\n+            lifetimes_to_include,\n         };\n \n         for bound in bounds {\n@@ -1620,10 +1678,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n         let ty = l.ty.as_ref().map(|t| {\n+            let mut capturable_lifetimes;\n             self.lower_ty(\n                 t,\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n-                    ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Binding)\n+                    capturable_lifetimes = FxHashSet::default();\n+                    ImplTraitContext::OtherOpaqueTy {\n+                        capturable_lifetimes: &mut capturable_lifetimes,\n+                        origin: hir::OpaqueTyOrigin::Binding,\n+                    }\n                 } else {\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                 },\n@@ -1726,7 +1789,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 FnRetTy::Ty(ref ty) => {\n                     let context = match in_band_ty_params {\n                         Some((def_id, _)) if impl_trait_return_allow => {\n-                            ImplTraitContext::OpaqueTy(Some(def_id), hir::OpaqueTyOrigin::FnReturn)\n+                            ImplTraitContext::ReturnPositionOpaqueTy {\n+                                fn_def_id: def_id,\n+                                origin: hir::OpaqueTyOrigin::FnReturn,\n+                            }\n                         }\n                         _ => ImplTraitContext::disallowed(),\n                     };\n@@ -1945,7 +2011,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n-        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n+        let opaque_ty_ref = hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, generic_args);\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n         hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n@@ -1963,8 +2029,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // Not `OpaqueTyOrigin::AsyncFn`: that's only used for the\n                 // `impl Future` opaque type that `async fn` implicitly\n                 // generates.\n-                let context =\n-                    ImplTraitContext::OpaqueTy(Some(fn_def_id), hir::OpaqueTyOrigin::FnReturn);\n+                let context = ImplTraitContext::ReturnPositionOpaqueTy {\n+                    fn_def_id,\n+                    origin: hir::OpaqueTyOrigin::FnReturn,\n+                };\n                 self.lower_ty(ty, context)\n             }\n             FnRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n@@ -2114,7 +2182,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     default: default.as_ref().map(|x| {\n                         self.lower_ty(\n                             x,\n-                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut FxHashSet::default(),\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n                         )\n                     }),\n                     synthetic: param\n@@ -2170,8 +2241,28 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             &NodeMap::default(),\n             itctx.reborrow(),\n         );\n+\n         let trait_ref = self.with_in_scope_lifetime_defs(&p.bound_generic_params, |this| {\n-            this.lower_trait_ref(&p.trait_ref, itctx)\n+            // Any impl Trait types defined within this scope can capture\n+            // lifetimes bound on this predicate.\n+            let lt_def_names = p.bound_generic_params.iter().filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => Some(hir::LifetimeName::Param(\n+                    ParamName::Plain(param.ident.normalize_to_macros_2_0()),\n+                )),\n+                _ => None,\n+            });\n+            if let ImplTraitContext::OtherOpaqueTy { ref mut capturable_lifetimes, .. } = itctx {\n+                capturable_lifetimes.extend(lt_def_names.clone());\n+            }\n+\n+            let res = this.lower_trait_ref(&p.trait_ref, itctx.reborrow());\n+\n+            if let ImplTraitContext::OtherOpaqueTy { ref mut capturable_lifetimes, .. } = itctx {\n+                for param in lt_def_names {\n+                    capturable_lifetimes.remove(&param);\n+                }\n+            }\n+            res\n         });\n \n         hir::PolyTraitRef { bound_generic_params, trait_ref, span: p.span }"}, {"sha": "267f3d9f3ef6e6dc02dbfe7436bc375181174a30", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1e0832faaa45b2b2488885f06073c3f1eda9094d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0832faaa45b2b2488885f06073c3f1eda9094d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1e0832faaa45b2b2488885f06073c3f1eda9094d", "patch": "@@ -2843,19 +2843,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let def_id = tcx.hir().local_def_id(item_id.id).to_def_id();\n \n                 match opaque_ty.kind {\n-                    // RPIT (return position impl trait)\n-                    // Only lifetimes mentioned in the impl Trait predicate are\n-                    // captured by the opaque type, so the lifetime parameters\n-                    // from the parent item need to be replaced with `'static`.\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) => {\n-                        self.impl_trait_ty_to_ty(def_id, lifetimes)\n-                    }\n-                    // This arm is for `impl Trait` in the types of statics,\n-                    // constants, locals and type aliases. These capture all\n-                    // parent lifetimes, so they can use their identity subst.\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: None, .. }) => {\n-                        let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                        tcx.mk_opaque(def_id, substs)\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n+                        self.impl_trait_ty_to_ty(def_id, lifetimes, impl_trait_fn.is_some())\n                     }\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 }\n@@ -2911,6 +2900,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         def_id: DefId,\n         lifetimes: &[hir::GenericArg<'_>],\n+        replace_parent_lifetimes: bool,\n     ) -> Ty<'tcx> {\n         debug!(\"impl_trait_ty_to_ty(def_id={:?}, lifetimes={:?})\", def_id, lifetimes);\n         let tcx = self.tcx();\n@@ -2932,9 +2922,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     _ => bug!(),\n                 }\n             } else {\n-                // Replace all parent lifetimes with `'static`.\n                 match param.kind {\n-                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_static.into(),\n+                    // For RPIT (return position impl trait), only lifetimes\n+                    // mentioned in the impl Trait predicate are captured by\n+                    // the opaque type, so the lifetime parameters from the\n+                    // parent item need to be replaced with `'static`.\n+                    //\n+                    // For `impl Trait` in the types of statics, constants,\n+                    // locals and type aliases. These capture all parent\n+                    // lifetimes, so they can use their identity subst.\n+                    GenericParamDefKind::Lifetime if replace_parent_lifetimes => {\n+                        tcx.lifetimes.re_static.into()\n+                    }\n                     _ => tcx.mk_param_from_def(param),\n                 }\n             }"}]}