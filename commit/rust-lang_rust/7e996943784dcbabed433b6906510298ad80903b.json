{"sha": "7e996943784dcbabed433b6906510298ad80903b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlOTk2OTQzNzg0ZGNiYWJlZDQzM2I2OTA2NTEwMjk4YWQ4MDkwM2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-08T13:44:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-08T13:44:22Z"}, "message": "Auto merge of #32738 - Aatch:mir-operand-fn-ret, r=arielb1\n\nHandle operand temps for function calls\n\nPreviously, all non-void function returns required an on-stack location for the value to be stored to. This code improves translation of function calls so this is no longer necessary.", "tree": {"sha": "07b353e27adec99b172480abe5bff1e8c353d932", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07b353e27adec99b172480abe5bff1e8c353d932"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e996943784dcbabed433b6906510298ad80903b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e996943784dcbabed433b6906510298ad80903b", "html_url": "https://github.com/rust-lang/rust/commit/7e996943784dcbabed433b6906510298ad80903b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e996943784dcbabed433b6906510298ad80903b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8694b4ffe9b223c351e50c10bd8ea4e23af58baa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8694b4ffe9b223c351e50c10bd8ea4e23af58baa", "html_url": "https://github.com/rust-lang/rust/commit/8694b4ffe9b223c351e50c10bd8ea4e23af58baa"}, {"sha": "cb1bec9096d09da202f5c33756144de54e9fcd56", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb1bec9096d09da202f5c33756144de54e9fcd56", "html_url": "https://github.com/rust-lang/rust/commit/cb1bec9096d09da202f5c33756144de54e9fcd56"}], "stats": {"total": 280, "additions": 220, "deletions": 60}, "files": [{"sha": "de349917258815ba538a176f83f3e48794f5d78a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7e996943784dcbabed433b6906510298ad80903b", "patch": "@@ -44,8 +44,9 @@ impl fmt::Debug for CodeExtent {\n \n         ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n-                let data = tcx.region_maps.code_extents.borrow()[self.0 as usize];\n-                write!(f, \"/{:?}\", data)?;\n+                if let Some(data) = tcx.region_maps.code_extents.borrow().get(self.0 as usize) {\n+                    write!(f, \"/{:?}\", data)?;\n+                }\n             }\n             Ok(())\n         })?;"}, {"sha": "450d25b60671942be2ca8f4ac9d5b4d5f141974e", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=7e996943784dcbabed433b6906510298ad80903b", "patch": "@@ -407,7 +407,7 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(arg);\n                         }\n                         if let Some((ref $($mutability)* destination, target)) = *destination {\n-                            self.visit_lvalue(destination, LvalueContext::Store);\n+                            self.visit_lvalue(destination, LvalueContext::Call);\n                             self.visit_branch(block, target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n@@ -692,9 +692,12 @@ make_mir_visitor!(MutVisitor,mut);\n \n #[derive(Copy, Clone, Debug)]\n pub enum LvalueContext {\n-    // Appears as LHS of an assignment or as dest of a call\n+    // Appears as LHS of an assignment\n     Store,\n \n+    // Dest of a call\n+    Call,\n+\n     // Being dropped\n     Drop,\n "}, {"sha": "f721e88a954139138cc03e3bb9a84950dfdad1db", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=7e996943784dcbabed433b6906510298ad80903b", "patch": "@@ -105,6 +105,9 @@ impl<'tcx> Visitor<'tcx> for TempAnalyzer {\n         match *lvalue {\n             mir::Lvalue::Temp(index) => {\n                 match context {\n+                    LvalueContext::Call => {\n+                        self.mark_assigned(index as usize);\n+                    }\n                     LvalueContext::Consume => {\n                     }\n                     LvalueContext::Store |"}, {"sha": "303cf61ad3379e81cf271a88e7caf5a804d2bc41", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 174, "deletions": 55, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=7e996943784dcbabed433b6906510298ad80903b", "patch": "@@ -11,12 +11,12 @@\n use llvm::{self, BasicBlockRef, ValueRef, OperandBundleDef};\n use rustc::ty;\n use rustc::mir::repr as mir;\n-use abi::{Abi, FnType};\n+use abi::{Abi, FnType, ArgType};\n use adt;\n use base;\n use build;\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, Block, BlockAndBuilder, C_undef};\n+use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, C_undef};\n use debuginfo::DebugLoc;\n use Disr;\n use machine::{llalign_of_min, llbitsize_of_real};\n@@ -25,7 +25,7 @@ use type_of;\n use glue;\n use type_::Type;\n \n-use super::{MirContext, drop};\n+use super::{MirContext, TempRef, drop};\n use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n@@ -169,6 +169,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n \n+                let sig = bcx.tcx().erase_late_bound_regions(sig);\n+\n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n                 let intrinsic = match (&callee.ty.sty, &callee.data) {\n                     (&ty::TyFnDef(def_id, _, _), &Intrinsic) => {\n@@ -191,31 +193,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 if intrinsic == Some(\"transmute\") {\n                     let &(ref dest, target) = destination.as_ref().unwrap();\n-                    let dst = self.trans_lvalue(&bcx, dest);\n-                    let mut val = self.trans_operand(&bcx, &args[0]);\n-                    if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n-                        let llouttype = type_of::type_of(bcx.ccx(), dst.ty.to_ty(bcx.tcx()));\n-                        let out_type_size = llbitsize_of_real(bcx.ccx(), llouttype);\n-                        if out_type_size != 0 {\n-                            // FIXME #19925 Remove this hack after a release cycle.\n-                            let f = Callee::def(bcx.ccx(), def_id, substs);\n-                            let datum = f.reify(bcx.ccx());\n-                            val = OperandRef {\n-                                val: OperandValue::Immediate(datum.val),\n-                                ty: datum.ty\n-                            };\n-                        }\n-                    }\n+                    self.with_lvalue_ref(&bcx, dest, |this, dest| {\n+                        this.trans_transmute(&bcx, &args[0], dest);\n+                    });\n \n-                    let llty = type_of::type_of(bcx.ccx(), val.ty);\n-                    let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n-                    self.store_operand(&bcx, cast_ptr, val);\n                     self.set_operand_dropped(&bcx, &args[0]);\n                     funclet_br(bcx, self.llblock(target));\n                     return;\n                 }\n \n-                let extra_args = &args[sig.0.inputs.len()..];\n+                let extra_args = &args[sig.inputs.len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n                     self.mir.operand_ty(bcx.tcx(), op_arg)\n                 }).collect::<Vec<_>>();\n@@ -226,18 +213,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let mut llargs = Vec::with_capacity(arg_count);\n \n                 // Prepare the return value destination\n-                let ret_dest = if let Some((ref d, _)) = *destination {\n-                    let dest = self.trans_lvalue(&bcx, d);\n-                    if fn_ty.ret.is_indirect() {\n-                        llargs.push(dest.llval);\n-                        None\n-                    } else if fn_ty.ret.is_ignore() {\n-                        None\n+                let ret_dest = if let Some((ref dest, _)) = *destination {\n+                    let is_intrinsic = if let Intrinsic = callee.data {\n+                        true\n                     } else {\n-                        Some(dest)\n-                    }\n+                        false\n+                    };\n+                    self.make_return_dest(&bcx, dest, &fn_ty.ret, &mut llargs, is_intrinsic)\n                 } else {\n-                    None\n+                    ReturnDest::Nothing\n                 };\n \n                 // Split the rust-call tupled arguments off.\n@@ -269,29 +253,42 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         use expr::{Ignore, SaveIn};\n                         use intrinsic::trans_intrinsic_call;\n \n-                        let (dest, llargs) = if fn_ty.ret.is_indirect() {\n-                            (SaveIn(llargs[0]), &llargs[1..])\n-                        } else if let Some(dest) = ret_dest {\n-                            (SaveIn(dest.llval), &llargs[..])\n-                        } else {\n-                            (Ignore, &llargs[..])\n+                        let (dest, llargs) = match ret_dest {\n+                            _ if fn_ty.ret.is_indirect() => {\n+                                (SaveIn(llargs[0]), &llargs[1..])\n+                            }\n+                            ReturnDest::Nothing => (Ignore, &llargs[..]),\n+                            ReturnDest::IndirectOperand(dst, _) |\n+                            ReturnDest::Store(dst) => (SaveIn(dst), &llargs[..]),\n+                            ReturnDest::DirectOperand(_) =>\n+                                bug!(\"Cannot use direct operand with an intrinsic call\")\n                         };\n \n                         bcx.with_block(|bcx| {\n-                            let res = trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n+                            trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n                                                            ArgVals(llargs), dest,\n                                                            DebugLoc::None);\n-                            let bcx = res.bcx.build();\n-                            if let Some((_, target)) = *destination {\n-                                for op in args {\n-                                    self.set_operand_dropped(&bcx, op);\n-                                }\n-                                funclet_br(bcx, self.llblock(target));\n-                            } else {\n-                                // trans_intrinsic_call already used Unreachable.\n-                                // bcx.unreachable();\n-                            }\n                         });\n+\n+                        if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n+                            // Make a fake operand for store_return\n+                            let op = OperandRef {\n+                                val: OperandValue::Ref(dst),\n+                                ty: sig.output.unwrap()\n+                            };\n+                            self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                        }\n+\n+                        if let Some((_, target)) = *destination {\n+                            for op in args {\n+                                self.set_operand_dropped(&bcx, op);\n+                            }\n+                            funclet_br(bcx, self.llblock(target));\n+                        } else {\n+                            // trans_intrinsic_call already used Unreachable.\n+                            // bcx.unreachable();\n+                        }\n+\n                         return;\n                     }\n                     Fn(f) => f,\n@@ -321,9 +318,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if destination.is_some() {\n                         let ret_bcx = ret_bcx.build();\n                         ret_bcx.at_start(|ret_bcx| {\n-                            if let Some(ret_dest) = ret_dest {\n-                                fn_ty.ret.store(&ret_bcx, invokeret, ret_dest.llval);\n-                            }\n+                            let op = OperandRef {\n+                                val: OperandValue::Immediate(invokeret),\n+                                ty: sig.output.unwrap()\n+                            };\n+                            self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n                             for op in args {\n                                 self.set_operand_dropped(&ret_bcx, op);\n                             }\n@@ -333,9 +332,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n                     fn_ty.apply_attrs_callsite(llret);\n                     if let Some((_, target)) = *destination {\n-                        if let Some(ret_dest) = ret_dest {\n-                            fn_ty.ret.store(&bcx, llret, ret_dest.llval);\n-                        }\n+                        let op = OperandRef {\n+                            val: OperandValue::Immediate(llret),\n+                            ty: sig.output.unwrap()\n+                        };\n+                        self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         for op in args {\n                             self.set_operand_dropped(&bcx, op);\n                         }\n@@ -544,4 +545,122 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n         self.blocks[bb.index()].llbb\n     }\n+\n+    fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                        dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n+                        llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {\n+        // If the return is ignored, we can just return a do-nothing ReturnDest\n+        if fn_ret_ty.is_ignore() {\n+            return ReturnDest::Nothing;\n+        }\n+        let dest = match *dest {\n+            mir::Lvalue::Temp(idx) => {\n+                let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), dest);\n+                let lvalue_ty = bcx.monomorphize(&lvalue_ty);\n+                let ret_ty = lvalue_ty.to_ty(bcx.tcx());\n+                match self.temps[idx as usize] {\n+                    TempRef::Lvalue(dest) => dest,\n+                    TempRef::Operand(None) => {\n+                        // Handle temporary lvalues, specifically Operand ones, as\n+                        // they don't have allocas\n+                        return if fn_ret_ty.is_indirect() {\n+                            // Odd, but possible, case, we have an operand temporary,\n+                            // but the calling convention has an indirect return.\n+                            let tmp = bcx.with_block(|bcx| {\n+                                base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n+                            });\n+                            llargs.push(tmp);\n+                            ReturnDest::IndirectOperand(tmp, idx)\n+                        } else if is_intrinsic {\n+                            // Currently, intrinsics always need a location to store\n+                            // the result. so we create a temporary alloca for the\n+                            // result\n+                            let tmp = bcx.with_block(|bcx| {\n+                                base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n+                            });\n+                            ReturnDest::IndirectOperand(tmp, idx)\n+                        } else {\n+                            ReturnDest::DirectOperand(idx)\n+                        };\n+                    }\n+                    TempRef::Operand(Some(_)) => {\n+                        bug!(\"lvalue temp already assigned to\");\n+                    }\n+                }\n+            }\n+            _ => self.trans_lvalue(bcx, dest)\n+        };\n+        if fn_ret_ty.is_indirect() {\n+            llargs.push(dest.llval);\n+            ReturnDest::Nothing\n+        } else {\n+            ReturnDest::Store(dest.llval)\n+        }\n+    }\n+\n+    fn trans_transmute(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                       src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n+        let mut val = self.trans_operand(bcx, src);\n+        if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n+            let llouttype = type_of::type_of(bcx.ccx(), dst.ty.to_ty(bcx.tcx()));\n+            let out_type_size = llbitsize_of_real(bcx.ccx(), llouttype);\n+            if out_type_size != 0 {\n+                // FIXME #19925 Remove this hack after a release cycle.\n+                let f = Callee::def(bcx.ccx(), def_id, substs);\n+                let datum = f.reify(bcx.ccx());\n+                val = OperandRef {\n+                    val: OperandValue::Immediate(datum.val),\n+                    ty: datum.ty\n+                };\n+            }\n+        }\n+\n+        let llty = type_of::type_of(bcx.ccx(), val.ty);\n+        let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n+        self.store_operand(bcx, cast_ptr, val);\n+    }\n+\n+    // Stores the return value of a function call into it's final location.\n+    fn store_return(&mut self,\n+                    bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                    dest: ReturnDest,\n+                    ret_ty: ArgType,\n+                    op: OperandRef<'tcx>) {\n+        use self::ReturnDest::*;\n+\n+        match dest {\n+            Nothing => (),\n+            Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n+            IndirectOperand(tmp, idx) => {\n+                let op = self.trans_load(bcx, tmp, op.ty);\n+                self.temps[idx as usize] = TempRef::Operand(Some(op));\n+            }\n+            DirectOperand(idx) => {\n+                let op = if type_is_fat_ptr(bcx.tcx(), op.ty) {\n+                    let llval = op.immediate();\n+                    let ptr = bcx.extract_value(llval, 0);\n+                    let meta = bcx.extract_value(llval, 1);\n+\n+                    OperandRef {\n+                        val: OperandValue::FatPtr(ptr, meta),\n+                        ty: op.ty\n+                    }\n+                } else {\n+                    op\n+                };\n+                self.temps[idx as usize] = TempRef::Operand(Some(op));\n+            }\n+        }\n+    }\n+}\n+\n+enum ReturnDest {\n+    // Do nothing, the return value is indirect or ignored\n+    Nothing,\n+    // Store the return value to the pointer\n+    Store(ValueRef),\n+    // Stores an indirect return value to an operand temporary lvalue\n+    IndirectOperand(ValueRef, u32),\n+    // Stores a direct return value to an operand temporary lvalue\n+    DirectOperand(u32)\n }"}, {"sha": "695806aa82cee0393800de13b20280994c143c44", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=7e996943784dcbabed433b6906510298ad80903b", "patch": "@@ -207,6 +207,40 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n+    // Perform an action using the given Lvalue.\n+    // If the Lvalue is an empty TempRef::Operand, then a temporary stack slot\n+    // is created first, then used as an operand to update the Lvalue.\n+    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                 lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n+    where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n+    {\n+        match *lvalue {\n+            mir::Lvalue::Temp(idx) => {\n+                match self.temps[idx as usize] {\n+                    TempRef::Lvalue(lvalue) => f(self, lvalue),\n+                    TempRef::Operand(None) => {\n+                        let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), lvalue);\n+                        let lvalue_ty = bcx.monomorphize(&lvalue_ty);\n+                        let lvalue = LvalueRef::alloca(bcx,\n+                                                       lvalue_ty.to_ty(bcx.tcx()),\n+                                                       \"lvalue_temp\");\n+                        let ret = f(self, lvalue);\n+                        let op = self.trans_load(bcx, lvalue.llval, lvalue_ty.to_ty(bcx.tcx()));\n+                        self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                        ret\n+                    }\n+                    TempRef::Operand(Some(_)) => {\n+                        bug!(\"Lvalue temp already set\");\n+                    }\n+                }\n+            }\n+            _ => {\n+                let lvalue = self.trans_lvalue(bcx, lvalue);\n+                f(self, lvalue)\n+            }\n+        }\n+    }\n+\n     /// Adjust the bitwidth of an index since LLVM is less forgiving\n     /// than we are.\n     ///"}, {"sha": "1f0a18ad4faa2d28bb6077a2836f327ac08d2f96", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e996943784dcbabed433b6906510298ad80903b/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=7e996943784dcbabed433b6906510298ad80903b", "patch": "@@ -182,7 +182,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     debug!(\"type_of {:?}\", t);\n \n-    assert!(!t.has_escaping_regions());\n+    assert!(!t.has_escaping_regions(), \"{:?} has escaping regions\", t);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain"}]}