{"sha": "70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYmY1NGJjYWM1ODdjMGJjOGEzYTU5M2JkYTc1MTE1ZTRjMjNhYTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-02T00:23:48Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-02T00:23:48Z"}, "message": "Implement 'else if'", "tree": {"sha": "fc04fe2f7bc4fa1dd902689e4db20e193bec9097", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc04fe2f7bc4fa1dd902689e4db20e193bec9097"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "html_url": "https://github.com/rust-lang/rust/commit/70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb16942c1de42c2f30f7e0eb0ff69371a167f7bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb16942c1de42c2f30f7e0eb0ff69371a167f7bd", "html_url": "https://github.com/rust-lang/rust/commit/eb16942c1de42c2f30f7e0eb0ff69371a167f7bd"}], "stats": {"total": 132, "additions": 104, "deletions": 28}, "files": [{"sha": "ac7dfcbbb719188a24030e0391c7b0acb4f934f1", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "patch": "@@ -447,6 +447,7 @@ TEST_XFAILS_RUSTC := $(filter-out \\\n                         div-mod.rs \\\n                         drop-bind-thunk-args.rs \\\n                         drop-on-ret.rs \\\n+                        else-if.rs \\\n                         fact.rs \\\n                         fn-lval.rs \\\n                         fun-call-variants.rs \\"}, {"sha": "be47615a502cd74da1f6632f0aed93fad99fed51", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "patch": "@@ -149,7 +149,7 @@ tag expr_ {\n     expr_unary(unop, @expr, ann);\n     expr_lit(@lit, ann);\n     expr_cast(@expr, @ty, ann);\n-    expr_if(@expr, block, option.t[block], ann);\n+    expr_if(@expr, block, vec[tup(@expr, block)], option.t[block], ann);\n     expr_while(@expr, block, ann);\n     expr_for(@decl, @expr, block, ann);\n     expr_do_while(block, @expr, ann);"}, {"sha": "0c90df5c783245d54dec4fba16350d527f0ff775", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "patch": "@@ -891,18 +891,40 @@ impure fn parse_if_expr(parser p) -> @ast.expr {\n     auto cond = parse_expr(p);\n     expect(p, token.RPAREN);\n     auto thn = parse_block(p);\n-    let option.t[ast.block] els = none[ast.block];\n     hi = thn.span;\n-    alt (p.peek()) {\n-        case (token.ELSE) {\n-            p.bump();\n-            auto eblk = parse_block(p);\n-            els = some(eblk);\n-            hi = eblk.span;\n+\n+    let vec[tup(@ast.expr, ast.block)] elifs = vec();\n+    let option.t[ast.block] els = none[ast.block];\n+    let bool parsing_elses = true;\n+    while (parsing_elses) {\n+        alt (p.peek()) {\n+            case (token.ELSE) {\n+                expect(p, token.ELSE);\n+                alt (p.peek()) {\n+                    case (token.IF) {\n+                        expect(p, token.IF);\n+                        expect(p, token.LPAREN);\n+                        auto elifcond = parse_expr(p);\n+                        expect(p, token.RPAREN);\n+                        auto elifthn = parse_block(p);\n+                        elifs += tup(elifcond, elifthn);\n+                        hi = elifthn.span;\n+                    }\n+                    case (_) {\n+                        auto eblk = parse_block(p);\n+                        els = some(eblk);\n+                        hi = eblk.span;\n+                        parsing_elses = false;\n+                    }\n+                }\n+            }\n+            case (_) {\n+                parsing_elses = false;\n+            }\n         }\n-        case (_) { /* fall through */ }\n     }\n-    ret @spanned(lo, hi, ast.expr_if(cond, thn, els, ast.ann_none));\n+\n+    ret @spanned(lo, hi, ast.expr_if(cond, thn, elifs, els, ast.ann_none));\n }\n \n impure fn parse_head_local(parser p) -> @ast.decl {\n@@ -1331,7 +1353,7 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_unary(_,_,_))    { ret true; }\n                 case (ast.expr_lit(_,_))        { ret true; }\n                 case (ast.expr_cast(_,_,_))     { ret true; }\n-                case (ast.expr_if(_,_,_,_))     { ret false; }\n+                case (ast.expr_if(_,_,_,_,_))   { ret false; }\n                 case (ast.expr_for(_,_,_,_))    { ret false; }\n                 case (ast.expr_while(_,_,_))    { ret false; }\n                 case (ast.expr_do_while(_,_,_)) { ret false; }"}, {"sha": "7e6839a831efc4938cc943467cb2af0c64c59701", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "patch": "@@ -28,6 +28,7 @@ import front.ast.def;\n import front.ast.def_id;\n import front.ast.ann;\n \n+import std._uint;\n import std._vec;\n \n type ast_fold[ENV] =\n@@ -100,6 +101,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          @expr cond, &block thn,\n+         &vec[tup(@expr, block)] elifs,\n          &option.t[block] els,\n          ann a) -> @expr)                         fold_expr_if,\n \n@@ -501,17 +503,27 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_cast(env_, e.span, ee, tt, at);\n         }\n \n-        case (ast.expr_if(?cnd, ?thn, ?els, ?t)) {\n+        case (ast.expr_if(?cnd, ?thn, ?elifs, ?els, ?t)) {\n             auto ccnd = fold_expr(env_, fld, cnd);\n             auto tthn = fold_block(env_, fld, thn);\n+\n+            let vec[tup(@ast.expr, ast.block)] eelifs = vec();\n+            for (tup(@expr, block) elif in elifs) {\n+                auto elifcnd = elif._0;\n+                auto elifthn = elif._1;\n+                auto elifccnd = fold_expr(env_, fld, elifcnd);\n+                auto eliftthn = fold_block(env_, fld, elifthn);\n+                eelifs += tup(elifccnd, eliftthn);\n+            }\n+\n             auto eels = none[block];\n             alt (els) {\n                 case (some[block](?b)) {\n                     eels = some(fold_block(env_, fld, b));\n                 }\n                 case (_) { /* fall through */  }\n             }\n-            ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eels, t);\n+            ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eelifs, eels, t);\n         }\n \n         case (ast.expr_for(?decl, ?seq, ?body, ?t)) {\n@@ -961,8 +973,9 @@ fn identity_fold_expr_cast[ENV](&ENV env, &span sp, @ast.expr e,\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n                               @expr cond, &block thn,\n+                              &vec[tup(@expr, block)] elifs,\n                               &option.t[block] els, ann a) -> @expr {\n-    ret @respan(sp, ast.expr_if(cond, thn, els, a));\n+    ret @respan(sp, ast.expr_if(cond, thn, elifs, els, a));\n }\n \n fn identity_fold_expr_for[ENV](&ENV env, &span sp,\n@@ -1237,7 +1250,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_unary  = bind identity_fold_expr_unary[ENV](_,_,_,_,_),\n          fold_expr_lit    = bind identity_fold_expr_lit[ENV](_,_,_,_),\n          fold_expr_cast   = bind identity_fold_expr_cast[ENV](_,_,_,_,_),\n-         fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_,_),\n+         fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_,_,_),\n          fold_expr_for    = bind identity_fold_expr_for[ENV](_,_,_,_,_,_),\n          fold_expr_while  = bind identity_fold_expr_while[ENV](_,_,_,_,_),\n          fold_expr_do_while"}, {"sha": "c08147fec5a76c907cc57d596321a7776d11dc79", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "patch": "@@ -1957,8 +1957,9 @@ fn join_results(@block_ctxt parent_cx,\n     ret res(join_cx, phi);\n }\n \n-fn trans_if(@block_ctxt cx, @ast.expr cond,\n-            &ast.block thn, &option.t[ast.block] els) -> result {\n+fn trans_if(@block_ctxt cx, @ast.expr cond, &ast.block thn,\n+            &vec[tup(@ast.expr, ast.block)] elifs,\n+            &option.t[ast.block] els) -> result {\n \n     auto cond_res = trans_expr(cx, cond);\n \n@@ -1968,11 +1969,25 @@ fn trans_if(@block_ctxt cx, @ast.expr cond,\n     auto else_cx = new_scope_block_ctxt(cx, \"else\");\n     auto else_res = res(else_cx, C_nil());\n \n-    alt (els) {\n-        case (some[ast.block](?eblk)) {\n-            else_res = trans_block(else_cx, eblk);\n+    auto num_elifs = _vec.len[tup(@ast.expr, ast.block)](elifs);\n+    if (num_elifs > 0u) {\n+        auto next_elif = elifs.(0u);\n+        auto next_elifthn = next_elif._0;\n+        auto next_elifcnd = next_elif._1;\n+        auto rest_elifs = _vec.shift[tup(@ast.expr, ast.block)](elifs);\n+        else_res = trans_if(else_cx, next_elifthn, next_elifcnd,\n+                            rest_elifs, els);\n+    }\n+\n+    /* else: FIXME: rustboot has a problem here\n+       with preconditions inside an else block */\n+    if (num_elifs == 0u)  {\n+        alt (els) {\n+            case (some[ast.block](?eblk)) {\n+                else_res = trans_block(else_cx, eblk);\n+            }\n+            case (_) { /* fall through */ }\n         }\n-        case (_) { /* fall through */ }\n     }\n \n     cond_res.bcx.build.CondBr(cond_res.val,\n@@ -2901,8 +2916,8 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_binary(cx, op, x, y);\n         }\n \n-        case (ast.expr_if(?cond, ?thn, ?els, _)) {\n-            ret trans_if(cx, cond, thn, els);\n+        case (ast.expr_if(?cond, ?thn, ?elifs, ?els, _)) {\n+            ret trans_if(cx, cond, thn, elifs, els);\n         }\n \n         case (ast.expr_for(?decl, ?seq, ?body, _)) {"}, {"sha": "2f14aae62594675342b020b306fb56ef03edb994", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "patch": "@@ -653,7 +653,7 @@ fn expr_ty(@ast.expr expr) -> @t {\n         case (ast.expr_unary(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_lit(_, ?ann))          { ret ann_to_type(ann); }\n         case (ast.expr_cast(_, _, ?ann))      { ret ann_to_type(ann); }\n-        case (ast.expr_if(_, _, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_if(_, _, _, _, ?ann))  { ret ann_to_type(ann); }\n         case (ast.expr_for(_, _, _, ?ann))    { ret ann_to_type(ann); }\n         case (ast.expr_while(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_do_while(_, _, ?ann))  { ret ann_to_type(ann); }"}, {"sha": "7112e982743d46d977ce7f15337d897486bd0a24", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70bf54bcac587c0bc8a3a593bda75115e4c23aa8/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=70bf54bcac587c0bc8a3a593bda75115e4c23aa8", "patch": "@@ -864,10 +864,19 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             e_1 = ast.expr_cast(sube, ast_ty, ast.ann_type(t));\n         }\n-        case (ast.expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n+        case (ast.expr_if(?cond, ?then_0, ?elifs_0, ?else_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n             auto then_1 = demand_block(fcx, expected, then_0);\n+\n+            let vec[tup(@ast.expr, ast.block)] elifs_1 = vec();\n+            for (tup(@ast.expr, ast.block) elif in elifs_0) {\n+                auto elifcond = elif._0;\n+                auto elifthn_0 = elif._1;\n+                auto elifthn_1 = demand_block(fcx, expected, elifthn_0);\n+                elifs_1 += tup(elifcond, elifthn_1);\n+            }\n+\n             auto else_1;\n             alt (else_0) {\n                 case (none[ast.block]) { else_1 = none[ast.block]; }\n@@ -876,7 +885,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     else_1 = some[ast.block](b_1);\n                 }\n             }\n-            e_1 = ast.expr_if(cond, then_1, else_1, ast.ann_type(t));\n+            e_1 = ast.expr_if(cond, then_1, elifs_1, else_1, ast.ann_type(t));\n         }\n         case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n@@ -1195,13 +1204,28 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                            ann));\n         }\n \n-        case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n+        case (ast.expr_if(?cond, ?thn, ?elifs, ?elsopt, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n             auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n \n             auto thn_0 = check_block(fcx, thn);\n             auto thn_t = block_ty(thn_0);\n \n+            auto num_elifs = _vec.len[tup(@ast.expr, ast.block)](elifs);\n+            let vec[tup(@ast.expr, ast.block)] elifs_1 = vec();\n+            for each (uint i in _uint.range(0u, num_elifs)) {\n+                auto elif = elifs.(i);\n+                auto elifcond = elif._0;\n+                auto elifcond_0 = check_expr(fcx, cond);\n+                auto elifcond_1 = demand_expr(fcx,\n+                                              plain_ty(ty.ty_bool),\n+                                              elifcond_0);\n+                auto elifthn = elif._1;\n+                auto elifthn_0 = check_block(fcx, elifthn);\n+                auto elifthn_1 = demand_block(fcx, thn_t, elifthn_0);\n+                elifs_1 += tup(elifcond_1, elifthn_1);\n+            }\n+\n             auto elsopt_1;\n             auto elsopt_t;\n             alt (elsopt) {\n@@ -1220,7 +1244,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto thn_1 = demand_block(fcx, elsopt_t, thn_0);\n \n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_if(cond_1, thn_1, elsopt_1,\n+                                        ast.expr_if(cond_1, thn_1,\n+                                                    elifs_1, elsopt_1,\n                                                     ast.ann_type(elsopt_t)));\n         }\n "}]}