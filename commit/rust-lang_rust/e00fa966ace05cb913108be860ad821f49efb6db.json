{"sha": "e00fa966ace05cb913108be860ad821f49efb6db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMGZhOTY2YWNlMDVjYjkxMzEwOGJlODYwYWQ4MjFmNDllZmI2ZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-02T07:40:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-02T07:40:02Z"}, "message": "Auto merge of #872 - RalfJung:retag-shallow, r=oli-obk\n\nMake Retag shallow\n\nA shallow retag does not traverse into fields of compound typed to search for references to retag. It only retags \"top-level\"/\"bare\" references (and boxes).\n\nThis helps with https://github.com/rust-lang/unsafe-code-guidelines/issues/125 because it also means that we do not add protectors for references passed in fields of a struct (or other compound types). Until we know what the rules should be for protectors, I prefer to be less aggressive about what we are rejecting.\nThis also matches our work-in-progress Coq formalization.", "tree": {"sha": "671209745dd5758035db839d9b29908c40f9cf4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/671209745dd5758035db839d9b29908c40f9cf4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e00fa966ace05cb913108be860ad821f49efb6db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e00fa966ace05cb913108be860ad821f49efb6db", "html_url": "https://github.com/rust-lang/rust/commit/e00fa966ace05cb913108be860ad821f49efb6db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e00fa966ace05cb913108be860ad821f49efb6db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bbf6733ea3d253740f2b78360c20f05781cfa11", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bbf6733ea3d253740f2b78360c20f05781cfa11", "html_url": "https://github.com/rust-lang/rust/commit/5bbf6733ea3d253740f2b78360c20f05781cfa11"}, {"sha": "30fb027f33e3c97489a7d7049d70ee876ac38c73", "url": "https://api.github.com/repos/rust-lang/rust/commits/30fb027f33e3c97489a7d7049d70ee876ac38c73", "html_url": "https://github.com/rust-lang/rust/commit/30fb027f33e3c97489a7d7049d70ee876ac38c73"}], "stats": {"total": 180, "additions": 93, "deletions": 87}, "files": [{"sha": "c276f83de660e49f149b86d0a2555c0ef67dee04", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 4, "deletions": 44, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e00fa966ace05cb913108be860ad821f49efb6db/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00fa966ace05cb913108be860ad821f49efb6db/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=e00fa966ace05cb913108be860ad821f49efb6db", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::{MutMutable, MutImmutable};\n use rustc::mir::RetagKind;\n \n use crate::{\n-    InterpResult, InterpError, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n+    InterpResult, InterpError, HelpersEvalContextExt,\n     MemoryKind, MiriMemoryKind, RangeMap, AllocId, Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n@@ -632,54 +632,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n \n-        // We need a visitor to visit all references. However, that requires\n-        // a `MemPlace`, so we have a fast path for reference types that\n-        // avoids allocating.\n+        // We only reborrow \"bare\" references/boxes.\n+        // Not traversing into fields helps with <https://github.com/rust-lang/unsafe-code-guidelines/issues/125>,\n+        // but might also cost us optimization and analyses. We will have to experiment more with this.\n         if let Some((mutbl, protector)) = qualify(place.layout.ty, kind) {\n             // Fast path.\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n             let val = this.retag_reference(val, mutbl, protector)?;\n             this.write_immediate(val, place)?;\n-            return Ok(());\n-        }\n-        let place = this.force_allocation(place)?;\n-\n-        let mut visitor = RetagVisitor { ecx: this, kind };\n-        visitor.visit_value(place)?;\n-\n-        // The actual visitor.\n-        struct RetagVisitor<'ecx, 'mir, 'tcx> {\n-            ecx: &'ecx mut MiriEvalContext<'mir, 'tcx>,\n-            kind: RetagKind,\n-        }\n-        impl<'ecx, 'mir, 'tcx>\n-            MutValueVisitor<'mir, 'tcx, Evaluator<'tcx>>\n-        for\n-            RetagVisitor<'ecx, 'mir, 'tcx>\n-        {\n-            type V = MPlaceTy<'tcx, Tag>;\n-\n-            #[inline(always)]\n-            fn ecx(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n-                &mut self.ecx\n-            }\n-\n-            // Primitives of reference type, that is the one thing we are interested in.\n-            fn visit_primitive(&mut self, place: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n-            {\n-                // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n-                // making it useless.\n-                if let Some((mutbl, protector)) = qualify(place.layout.ty, self.kind) {\n-                    let val = self.ecx.read_immediate(place.into())?;\n-                    let val = self.ecx.retag_reference(\n-                        val,\n-                        mutbl,\n-                        protector\n-                    )?;\n-                    self.ecx.write_immediate(val, place.into())?;\n-                }\n-                Ok(())\n-            }\n         }\n \n         Ok(())"}, {"sha": "798f68fa13cc948ac4e504976cd35b44804e4e6b", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=e00fa966ace05cb913108be860ad821f49efb6db", "patch": "@@ -9,7 +9,6 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR borrow stack\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }\n@@ -18,6 +17,7 @@ mod safe {\n fn main() {\n     let mut array = [1,2,3,4];\n     let (a, b) = safe::split_at_mut(&mut array, 0);\n+    //~^ ERROR borrow stack\n     a[1] = 5;\n     b[1] = 6;\n }"}, {"sha": "1cb3f3f920267f7c717d9f34cd5c3e678e5d2b9c", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_option.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=e00fa966ace05cb913108be860ad821f49efb6db", "patch": "@@ -1,11 +1,16 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in an `Option`.\n+// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n     let xraw = x as *mut (i32, i32);\n-    let ret = Some(unsafe { &mut (*xraw).1 });\n+    let ret = unsafe { &mut (*xraw).1 }; // let-bind to avoid 2phase\n+    let ret = Some(ret);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR borrow stack\n+    ret\n }\n \n fn main() {\n-    foo(&mut (1, 2));\n+    match foo(&mut (1, 2)) {\n+        Some(_x) => {}, //~ ERROR borrow stack\n+        None => {},\n+    }\n }"}, {"sha": "fbd9a6e5d269221784acd4fc0b8bcf27bf8c7323", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_tuple.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=e00fa966ace05cb913108be860ad821f49efb6db", "patch": "@@ -1,11 +1,12 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in a tuple.\n+// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &mut (*xraw).1 },);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR borrow stack\n+    ret\n }\n \n fn main() {\n-    foo(&mut (1, 2));\n+    foo(&mut (1, 2)).0; //~ ERROR: borrow stack\n }"}, {"sha": "2d8527fa3fb4f307ce824f9fb6c627a318460bbc", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr_option.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs?ref=e00fa966ace05cb913108be860ad821f49efb6db", "patch": "@@ -1,11 +1,15 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in an `Option`.\n+// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = Some(unsafe { &(*xraw).1 });\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret //~ ERROR borrow stack\n+    ret\n }\n \n fn main() {\n-    foo(&mut (1, 2));\n+    match foo(&mut (1, 2)) {\n+        Some(_x) => {}, //~ ERROR borrow stack\n+        None => {},\n+    }\n }"}, {"sha": "d7494d6ee653b5f1edf9debc34c12acb38a96169", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr_tuple.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs?ref=e00fa966ace05cb913108be860ad821f49efb6db", "patch": "@@ -1,11 +1,12 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in a tuple.\n+// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &(*xraw).1 },);\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret //~ ERROR borrow stack\n+    ret\n }\n \n fn main() {\n-    foo(&mut (1, 2));\n+    foo(&mut (1, 2)).0; //~ ERROR borrow stack\n }"}, {"sha": "93cef1572a3e13d5c88b4e1315ecfe0357c2ec7e", "filename": "tests/run-pass/refcell.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5bbf6733ea3d253740f2b78360c20f05781cfa11/tests%2Frun-pass%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbf6733ea3d253740f2b78360c20f05781cfa11/tests%2Frun-pass%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frefcell.rs?ref=5bbf6733ea3d253740f2b78360c20f05781cfa11", "patch": "@@ -1,33 +0,0 @@\n-use std::cell::RefCell;\n-\n-fn main() {\n-    let c = RefCell::new(42);\n-    {\n-        let s1 = c.borrow();\n-        let _x: i32 = *s1;\n-        let s2 = c.borrow();\n-        let _x: i32 = *s1;\n-        let _y: i32 = *s2;\n-        let _x: i32 = *s1;\n-        let _y: i32 = *s2;\n-    }\n-    {\n-        let mut m = c.borrow_mut();\n-        let _z: i32 = *m;\n-        {\n-            let s: &i32 = &*m;\n-            let _x = *s;\n-        }\n-        *m = 23;\n-        let _z: i32 = *m;\n-    }\n-    {\n-        let s1 = c.borrow();\n-        let _x: i32 = *s1;\n-        let s2 = c.borrow();\n-        let _x: i32 = *s1;\n-        let _y: i32 = *s2;\n-        let _x: i32 = *s1;\n-        let _y: i32 = *s2;\n-    }\n-}"}, {"sha": "0939a666193e87ab1bbe71da31466dfa964eb06a", "filename": "tests/run-pass/stacked-borrows/refcell.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Frun-pass%2Fstacked-borrows%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00fa966ace05cb913108be860ad821f49efb6db/tests%2Frun-pass%2Fstacked-borrows%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2Frefcell.rs?ref=e00fa966ace05cb913108be860ad821f49efb6db", "patch": "@@ -0,0 +1,68 @@\n+use std::cell::{RefCell, Ref, RefMut};\n+\n+fn main() {\n+    basic();\n+    ref_protector();\n+    ref_mut_protector();\n+}\n+\n+fn basic() {\n+    let c = RefCell::new(42);\n+    {\n+        let s1 = c.borrow();\n+        let _x: i32 = *s1;\n+        let s2 = c.borrow();\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+    }\n+    {\n+        let mut m = c.borrow_mut();\n+        let _z: i32 = *m;\n+        {\n+            let s: &i32 = &*m;\n+            let _x = *s;\n+        }\n+        *m = 23;\n+        let _z: i32 = *m;\n+    }\n+    {\n+        let s1 = c.borrow();\n+        let _x: i32 = *s1;\n+        let s2 = c.borrow();\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+    }\n+}\n+\n+// Adding a Stacked Borrows protector for `Ref` would break this\n+fn ref_protector() {\n+    fn break_it(rc: &RefCell<i32>, r: Ref<'_, i32>) {\n+        // `r` has a shared reference, it is passed in as argument and hence\n+        // a protector is added that marks this memory as read-only for the entire\n+        // duration of this function.\n+        drop(r);\n+        // *oops* here we can mutate that memory.\n+        *rc.borrow_mut() = 2;\n+    }\n+\n+    let rc = RefCell::new(0);\n+    break_it(&rc, rc.borrow())\n+}\n+\n+fn ref_mut_protector() {\n+    fn break_it(rc: &RefCell<i32>, r: RefMut<'_, i32>) {\n+        // `r` has a shared reference, it is passed in as argument and hence\n+        // a protector is added that marks this memory as inaccessible for the entire\n+        // duration of this function\n+        drop(r);\n+        // *oops* here we can mutate that memory.\n+        *rc.borrow_mut() = 2;\n+    }\n+\n+    let rc = RefCell::new(0);\n+    break_it(&rc, rc.borrow_mut())\n+}"}]}