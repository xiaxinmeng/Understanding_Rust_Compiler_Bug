{"sha": "88d84b38f19eff3c25ec88931f04bf2640edf2b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZDg0YjM4ZjE5ZWZmM2MyNWVjODg5MzFmMDRiZjI2NDBlZGYyYjU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-08-07T14:04:34Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-08-10T09:13:00Z"}, "message": "Introduce SmallCStr and use it where applicable.", "tree": {"sha": "1b161e6842a4e32c29ba92332eb5b28f81d0e3ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b161e6842a4e32c29ba92332eb5b28f81d0e3ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88d84b38f19eff3c25ec88931f04bf2640edf2b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88d84b38f19eff3c25ec88931f04bf2640edf2b5", "html_url": "https://github.com/rust-lang/rust/commit/88d84b38f19eff3c25ec88931f04bf2640edf2b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88d84b38f19eff3c25ec88931f04bf2640edf2b5/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9585c5dc1fa3cef34ebdc5a5d39af88db60c6f15", "url": "https://api.github.com/repos/rust-lang/rust/commits/9585c5dc1fa3cef34ebdc5a5d39af88db60c6f15", "html_url": "https://github.com/rust-lang/rust/commit/9585c5dc1fa3cef34ebdc5a5d39af88db60c6f15"}], "stats": {"total": 275, "additions": 200, "deletions": 75}, "files": [{"sha": "816242129f338e080b5061bfc424cf2f5e1c84b2", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -128,7 +128,7 @@ pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     llvm::AddFunctionAttrStringValue(\n             llfn,\n             llvm::AttributePlace::Function,\n-            cstr(\"target-cpu\\0\"),\n+            const_cstr!(\"target-cpu\"),\n             target_cpu.as_c_str());\n }\n "}, {"sha": "ebe8b79741438e7582371cfd191beab472f179db", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -31,6 +31,7 @@ use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n use rustc::util::common::{time_ext, time_depth, set_time_depth, print_time_passes_entry};\n use rustc_fs_util::{path2cstr, link_or_copy};\n+use rustc_data_structures::small_c_str::SmallCStr;\n use errors::{self, Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n use errors::emitter::{Emitter};\n use syntax::attr;\n@@ -170,11 +171,8 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n \n     let singlethread = sess.target.target.options.singlethread;\n \n-    let triple = &sess.target.target.llvm_target;\n-\n-    let triple = CString::new(triple.as_bytes()).unwrap();\n-    let cpu = sess.target_cpu();\n-    let cpu = CString::new(cpu.as_bytes()).unwrap();\n+    let triple = SmallCStr::new(&sess.target.target.llvm_target);\n+    let cpu = SmallCStr::new(sess.target_cpu());\n     let features = attributes::llvm_target_features(sess)\n         .collect::<Vec<_>>()\n         .join(\",\");\n@@ -522,7 +520,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n             // If we're verifying or linting, add them to the function pass\n             // manager.\n             let addpass = |pass_name: &str| {\n-                let pass_name = CString::new(pass_name).unwrap();\n+                let pass_name = SmallCStr::new(pass_name);\n                 let pass = match llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr()) {\n                     Some(pass) => pass,\n                     None => return false,"}, {"sha": "7ca6a89dd9b57f1164bc6873def4468f023f147b", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -73,6 +73,7 @@ use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n+use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n \n use std::any::Any;\n@@ -533,7 +534,7 @@ pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n         None => return,\n     };\n     unsafe {\n-        let buf = CString::new(sect.as_str().as_bytes()).unwrap();\n+        let buf = SmallCStr::new(&sect.as_str());\n         llvm::LLVMSetSection(llval, buf.as_ptr());\n     }\n }\n@@ -681,7 +682,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n         let section_name = metadata::metadata_section_name(&tcx.sess.target.target);\n-        let name = CString::new(section_name).unwrap();\n+        let name = SmallCStr::new(section_name);\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n \n         // Also generate a .section directive to force no"}, {"sha": "b0f88bd4189d3db41b77ed572b95e47d34eed63e", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -18,9 +18,9 @@ use libc::{c_uint, c_char};\n use rustc::ty::TyCtxt;\n use rustc::ty::layout::{Align, Size};\n use rustc::session::{config, Session};\n+use rustc_data_structures::small_c_str::SmallCStr;\n \n use std::borrow::Cow;\n-use std::ffi::CString;\n use std::ops::Range;\n use std::ptr;\n \n@@ -58,7 +58,7 @@ impl Builder<'a, 'll, 'tcx> {\n     pub fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &'b str) -> Self {\n         let bx = Builder::with_cx(cx);\n         let llbb = unsafe {\n-            let name = CString::new(name).unwrap();\n+            let name = SmallCStr::new(name);\n             llvm::LLVMAppendBasicBlockInContext(\n                 cx.llcx,\n                 llfn,\n@@ -118,7 +118,7 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn set_value_name(&self, value: &'ll Value, name: &str) {\n-        let cname = CString::new(name.as_bytes()).unwrap();\n+        let cname = SmallCStr::new(name);\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n@@ -436,7 +436,7 @@ impl Builder<'a, 'll, 'tcx> {\n             let alloca = if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty, noname())\n             } else {\n-                let name = CString::new(name).unwrap();\n+                let name = SmallCStr::new(name);\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty,\n                                       name.as_ptr())\n             };"}, {"sha": "781f8ebbb78c189cac74c6ca4c6f567339608343", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -26,6 +26,7 @@ use type_::Type;\n use type_of::PointeeInfo;\n \n use rustc_data_structures::base_n;\n+use rustc_data_structures::small_c_str::SmallCStr;\n use rustc::mir::mono::Stats;\n use rustc::session::config::{self, DebugInfo};\n use rustc::session::Session;\n@@ -34,7 +35,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::{HasTargetSpec, Target};\n \n-use std::ffi::{CStr, CString};\n+use std::ffi::CStr;\n use std::cell::{Cell, RefCell};\n use std::iter;\n use std::str;\n@@ -161,7 +162,7 @@ pub unsafe fn create_module(\n     llcx: &'ll llvm::Context,\n     mod_name: &str,\n ) -> &'ll llvm::Module {\n-    let mod_name = CString::new(mod_name).unwrap();\n+    let mod_name = SmallCStr::new(mod_name);\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n@@ -201,11 +202,10 @@ pub unsafe fn create_module(\n         }\n     }\n \n-    let data_layout = CString::new(&sess.target.target.data_layout[..]).unwrap();\n+    let data_layout = SmallCStr::new(&sess.target.target.data_layout);\n     llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n \n-    let llvm_target = sess.target.target.llvm_target.as_bytes();\n-    let llvm_target = CString::new(llvm_target).unwrap();\n+    let llvm_target = SmallCStr::new(&sess.target.target.llvm_target);\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n \n     if is_pie_binary(sess) {"}, {"sha": "223fa75723cf9e2526803868641d9bcec72e5ef8", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -37,6 +37,7 @@ use rustc::ty::layout::{self, Align, LayoutOf, PrimitiveExt, Size, TyLayout};\n use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n use rustc_fs_util::path2cstr;\n+use rustc_data_structures::small_c_str::SmallCStr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n@@ -274,7 +275,7 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n-                                              &member_descriptions[..]);\n+                                              member_descriptions);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -349,7 +350,7 @@ fn vec_slice_metadata(\n     let (pointer_size, pointer_align) = cx.size_and_align_of(data_ptr_type);\n     let (usize_size, usize_align) = cx.size_and_align_of(cx.tcx.types.usize);\n \n-    let member_descriptions = [\n+    let member_descriptions = vec![\n         MemberDescription {\n             name: \"data_ptr\".to_string(),\n             type_metadata: data_ptr_metadata,\n@@ -374,7 +375,7 @@ fn vec_slice_metadata(\n                                            slice_ptr_type,\n                                            &slice_type_name[..],\n                                            unique_type_id,\n-                                           &member_descriptions,\n+                                           member_descriptions,\n                                            NO_SCOPE_METADATA,\n                                            file_metadata,\n                                            span);\n@@ -460,7 +461,7 @@ fn trait_pointer_metadata(\n \n     let data_ptr_field = layout.field(cx, 0);\n     let vtable_field = layout.field(cx, 1);\n-    let member_descriptions = [\n+    let member_descriptions = vec![\n         MemberDescription {\n             name: \"pointer\".to_string(),\n             type_metadata: type_metadata(cx,\n@@ -485,7 +486,7 @@ fn trait_pointer_metadata(\n                             trait_object_type,\n                             &trait_type_name[..],\n                             unique_type_id,\n-                            &member_descriptions,\n+                            member_descriptions,\n                             containing_scope,\n                             file_metadata,\n                             syntax_pos::DUMMY_SP)\n@@ -746,8 +747,8 @@ fn file_metadata_raw(cx: &CodegenCx<'ll, '_>,\n \n     debug!(\"file_metadata: file_name: {}, directory: {}\", file_name, directory);\n \n-    let file_name = CString::new(file_name).unwrap();\n-    let directory = CString::new(directory).unwrap();\n+    let file_name = SmallCStr::new(file_name);\n+    let directory = SmallCStr::new(directory);\n \n     let file_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateFile(DIB(cx),\n@@ -782,7 +783,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     };\n \n     let (size, align) = cx.size_and_align_of(t);\n-    let name = CString::new(name).unwrap();\n+    let name = SmallCStr::new(name);\n     let ty_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n@@ -813,7 +814,7 @@ fn pointer_type_metadata(\n ) -> &'ll DIType {\n     let (pointer_size, pointer_align) = cx.size_and_align_of(pointer_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n-    let name = CString::new(name).unwrap();\n+    let name = SmallCStr::new(&name);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreatePointerType(\n             DIB(cx),\n@@ -847,9 +848,9 @@ pub fn compile_unit_metadata(tcx: TyCtxt,\n     let producer = format!(\"clang LLVM (rustc version {})\",\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n-    let name_in_debuginfo = name_in_debuginfo.to_string_lossy().into_owned();\n-    let name_in_debuginfo = CString::new(name_in_debuginfo).unwrap();\n-    let work_dir = CString::new(&tcx.sess.working_dir.0.to_string_lossy()[..]).unwrap();\n+    let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n+    let name_in_debuginfo = SmallCStr::new(&name_in_debuginfo);\n+    let work_dir = SmallCStr::new(&tcx.sess.working_dir.0.to_string_lossy());\n     let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n@@ -1187,7 +1188,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n-                                              &member_descriptions[..]);\n+                                              member_descriptions);\n                 vec![\n                     MemberDescription {\n                         name: \"\".to_string(),\n@@ -1217,7 +1218,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n-                                                  &member_descriptions);\n+                                                  member_descriptions);\n                     MemberDescription {\n                         name: \"\".to_string(),\n                         type_metadata: variant_type_metadata,\n@@ -1244,7 +1245,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n-                                              &variant_member_descriptions[..]);\n+                                              variant_member_descriptions);\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -1416,8 +1417,7 @@ fn prepare_enum_metadata(\n     let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n         .zip(&def.variants)\n         .map(|(discr, v)| {\n-            let token = v.name.as_str();\n-            let name = CString::new(token.as_bytes()).unwrap();\n+            let name = SmallCStr::new(&v.name.as_str());\n             unsafe {\n                 Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n                     DIB(cx),\n@@ -1442,7 +1442,7 @@ fn prepare_enum_metadata(\n                     type_metadata(cx, discr.to_ty(cx.tcx), syntax_pos::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id).as_str();\n \n-                let name = CString::new(discriminant_name.as_bytes()).unwrap();\n+                let name = SmallCStr::new(&discriminant_name);\n                 let discriminant_type_metadata = unsafe {\n                     llvm::LLVMRustDIBuilderCreateEnumerationType(\n                         DIB(cx),\n@@ -1482,10 +1482,10 @@ fn prepare_enum_metadata(\n \n     let (enum_type_size, enum_type_align) = layout.size_and_align();\n \n-    let enum_name = CString::new(enum_name).unwrap();\n-    let unique_type_id_str = CString::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n-    ).unwrap();\n+    let enum_name = SmallCStr::new(&enum_name);\n+    let unique_type_id_str = SmallCStr::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n+    );\n     let enum_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateUnionType(\n         DIB(cx),\n@@ -1531,7 +1531,7 @@ fn composite_type_metadata(\n     composite_type: Ty<'tcx>,\n     composite_type_name: &str,\n     composite_type_unique_id: UniqueTypeId,\n-    member_descriptions: &[MemberDescription<'ll>],\n+    member_descriptions: Vec<MemberDescription<'ll>>,\n     containing_scope: Option<&'ll DIScope>,\n \n     // Ignore source location information as long as it\n@@ -1555,7 +1555,7 @@ fn composite_type_metadata(\n \n fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n                                  composite_type_metadata: &'ll DICompositeType,\n-                                 member_descriptions: &[MemberDescription<'ll>]) {\n+                                 member_descriptions: Vec<MemberDescription<'ll>>) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n     // description being used instead of a new one created in\n     // create_struct_stub. This would cause a hard to trace assertion in\n@@ -1574,10 +1574,9 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n     }\n \n     let member_metadata: Vec<_> = member_descriptions\n-        .iter()\n+        .into_iter()\n         .map(|member_description| {\n-            let member_name = member_description.name.as_bytes();\n-            let member_name = CString::new(member_name).unwrap();\n+            let member_name = CString::new(member_description.name).unwrap();\n             unsafe {\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n@@ -1613,10 +1612,10 @@ fn create_struct_stub(\n ) -> &'ll DICompositeType {\n     let (struct_size, struct_align) = cx.size_and_align_of(struct_type);\n \n-    let name = CString::new(struct_type_name).unwrap();\n-    let unique_type_id = CString::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n-    ).unwrap();\n+    let name = SmallCStr::new(struct_type_name);\n+    let unique_type_id = SmallCStr::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n+    );\n     let metadata_stub = unsafe {\n         // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -1651,10 +1650,10 @@ fn create_union_stub(\n ) -> &'ll DICompositeType {\n     let (union_size, union_align) = cx.size_and_align_of(union_type);\n \n-    let name = CString::new(union_type_name).unwrap();\n-    let unique_type_id = CString::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n-    ).unwrap();\n+    let name = SmallCStr::new(union_type_name);\n+    let unique_type_id = SmallCStr::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n+    );\n     let metadata_stub = unsafe {\n         // LLVMRustDIBuilderCreateUnionType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -1713,13 +1712,12 @@ pub fn create_global_var_metadata(\n     let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n     let variable_type = Instance::mono(cx.tcx, def_id).ty(cx.tcx);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let var_name = tcx.item_name(def_id).to_string();\n-    let var_name = CString::new(var_name).unwrap();\n+    let var_name = SmallCStr::new(&tcx.item_name(def_id).as_str());\n     let linkage_name = if no_mangle {\n         None\n     } else {\n         let linkage_name = mangled_name_of_instance(cx, Instance::mono(tcx, def_id));\n-        Some(CString::new(linkage_name.to_string()).unwrap())\n+        Some(SmallCStr::new(&linkage_name.as_str()))\n     };\n \n     let global_align = cx.align_of(variable_type);"}, {"sha": "fcb8bc3fe2b21dc8e2f93625f7c06f4947db4b63", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -34,6 +34,7 @@ use rustc::ty::{self, ParamEnv, Ty, InstanceDef};\n use rustc::mir;\n use rustc::session::config::{self, DebugInfo};\n use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n+use rustc_data_structures::small_c_str::SmallCStr;\n use value::Value;\n \n use libc::c_uint;\n@@ -265,7 +266,7 @@ pub fn create_function_debug_context(\n     let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n \n     let function_name = CString::new(name).unwrap();\n-    let linkage_name = CString::new(linkage_name.to_string()).unwrap();\n+    let linkage_name = SmallCStr::new(&linkage_name.as_str());\n \n     let mut flags = DIFlags::FlagPrototyped;\n \n@@ -407,7 +408,7 @@ pub fn create_function_debug_context(\n                     let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                     let actual_type_metadata =\n                         type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n-                    let name = CString::new(name.as_str().as_bytes()).unwrap();\n+                    let name = SmallCStr::new(&name.as_str());\n                     Some(unsafe {\n                         Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n@@ -510,7 +511,7 @@ pub fn declare_local(\n     };\n     let align = cx.align_of(variable_type);\n \n-    let name = CString::new(variable_name.as_str().as_bytes()).unwrap();\n+    let name = SmallCStr::new(&variable_name.as_str());\n     match (variable_access, &[][..]) {\n         (DirectVariable { alloca }, address_operations) |\n         (IndirectVariable {alloca, address_operations}, _) => {"}, {"sha": "06f8a4b131b604610fe26ee1a4067f3c1ffbe3c4", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use common::CodegenCx;\n \n-use std::ffi::CString;\n+use rustc_data_structures::small_c_str::SmallCStr;\n \n pub fn mangled_name_of_instance<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n@@ -49,7 +49,7 @@ pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n         data => data.as_interned_str().as_str()\n     };\n \n-    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n+    let namespace_name = SmallCStr::new(&namespace_name);\n \n     let scope = unsafe {\n         llvm::LLVMRustDIBuilderCreateNameSpace("}, {"sha": "5e743ac51bc616ffebbf47aa31851f9911a243a7", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -25,6 +25,7 @@ use llvm::AttributePlace::Function;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::session::config::Sanitizer;\n+use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_target::spec::PanicStrategy;\n use abi::{Abi, FnType, FnTypeExt};\n use attributes;\n@@ -33,17 +34,14 @@ use common;\n use type_::Type;\n use value::Value;\n \n-use std::ffi::CString;\n \n /// Declare a global value.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// return its Value instead.\n pub fn declare_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> &'ll Value {\n     debug!(\"declare_global(name={:?})\", name);\n-    let namebuf = CString::new(name).unwrap_or_else(|_|{\n-        bug!(\"name {:?} contains an interior null byte\", name)\n-    });\n+    let namebuf = SmallCStr::new(name);\n     unsafe {\n         llvm::LLVMRustGetOrInsertGlobal(cx.llmod, namebuf.as_ptr(), ty)\n     }\n@@ -61,9 +59,7 @@ fn declare_raw_fn(\n     ty: &'ll Type,\n ) -> &'ll Value {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n-    let namebuf = CString::new(name).unwrap_or_else(|_|{\n-        bug!(\"name {:?} contains an interior null byte\", name)\n-    });\n+    let namebuf = SmallCStr::new(name);\n     let llfn = unsafe {\n         llvm::LLVMRustGetOrInsertFunction(cx.llmod, namebuf.as_ptr(), ty)\n     };\n@@ -214,9 +210,7 @@ pub fn define_internal_fn(\n /// Get declared value by name.\n pub fn get_declared_value(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n     debug!(\"get_declared_value(name={:?})\", name);\n-    let namebuf = CString::new(name).unwrap_or_else(|_|{\n-        bug!(\"name {:?} contains an interior null byte\", name)\n-    });\n+    let namebuf = SmallCStr::new(name);\n     unsafe { llvm::LLVMRustGetNamedValue(cx.llmod, namebuf.as_ptr()) }\n }\n "}, {"sha": "4343c8c184ecf02b8a9b4d87246e77858dc016f5", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -24,9 +24,10 @@ pub use self::Linkage::*;\n use std::str::FromStr;\n use std::string::FromUtf8Error;\n use std::slice;\n-use std::ffi::{CString, CStr};\n+use std::ffi::CStr;\n use std::cell::RefCell;\n use libc::{self, c_uint, c_char, size_t};\n+use rustc_data_structures::small_c_str::SmallCStr;\n \n pub mod archive_ro;\n pub mod diagnostic;\n@@ -264,7 +265,7 @@ pub struct OperandBundleDef<'a> {\n \n impl OperandBundleDef<'a> {\n     pub fn new(name: &str, vals: &[&'a Value]) -> Self {\n-        let name = CString::new(name).unwrap();\n+        let name = SmallCStr::new(name);\n         let def = unsafe {\n             LLVMRustBuildOperandBundleDef(name.as_ptr(), vals.as_ptr(), vals.len() as c_uint)\n         };"}, {"sha": "51a233d79162539d3e194db44f9db903eb38aa75", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -19,8 +19,8 @@ use context::CodegenCx;\n \n use syntax::ast;\n use rustc::ty::layout::{self, Align, Size};\n+use rustc_data_structures::small_c_str::SmallCStr;\n \n-use std::ffi::CString;\n use std::fmt;\n \n use libc::c_uint;\n@@ -201,7 +201,7 @@ impl Type {\n     }\n \n     pub fn named_struct(cx: &CodegenCx<'ll, '_>, name: &str) -> &'ll Type {\n-        let name = CString::new(name).unwrap();\n+        let name = SmallCStr::new(name);\n         unsafe {\n             llvm::LLVMStructCreateNamed(cx.llcx, name.as_ptr())\n         }"}, {"sha": "8a586d8c2337b577f8f3cba06cb27f03033c0d31", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -70,6 +70,7 @@ pub mod obligation_forest;\n pub mod owning_ref;\n pub mod ptr_key;\n pub mod sip128;\n+pub mod small_c_str;\n pub mod small_vec;\n pub mod snapshot_map;\n pub use ena::snapshot_vec;"}, {"sha": "b0ad83e4979380cd48395fe7156d4480de13771a", "filename": "src/librustc_data_structures/small_c_str.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_data_structures%2Fsmall_c_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d84b38f19eff3c25ec88931f04bf2640edf2b5/src%2Flibrustc_data_structures%2Fsmall_c_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_c_str.rs?ref=88d84b38f19eff3c25ec88931f04bf2640edf2b5", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ffi;\n+use std::ops::Deref;\n+\n+const SIZE: usize = 38;\n+\n+/// Like SmallVec but for C strings.\n+#[derive(Clone)]\n+pub enum SmallCStr {\n+    OnStack {\n+        data: [u8; SIZE],\n+        len_with_nul: u8,\n+    },\n+    OnHeap {\n+        data: ffi::CString,\n+    }\n+}\n+\n+impl SmallCStr {\n+    #[inline]\n+    pub fn new(s: &str) -> SmallCStr {\n+        if s.len() < SIZE {\n+            let mut data = [0; SIZE];\n+            data[.. s.len()].copy_from_slice(s.as_bytes());\n+            let len_with_nul = s.len() + 1;\n+\n+            // Make sure once that this is a valid CStr\n+            if let Err(e) = ffi::CStr::from_bytes_with_nul(&data[.. len_with_nul]) {\n+                panic!(\"The string \\\"{}\\\" cannot be converted into a CStr: {}\", s, e);\n+            }\n+\n+            SmallCStr::OnStack {\n+                data,\n+                len_with_nul: len_with_nul as u8,\n+            }\n+        } else {\n+            SmallCStr::OnHeap {\n+                data: ffi::CString::new(s).unwrap()\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_c_str(&self) -> &ffi::CStr {\n+        match *self {\n+            SmallCStr::OnStack { ref data, len_with_nul } => {\n+                unsafe {\n+                    let slice = &data[.. len_with_nul as usize];\n+                    ffi::CStr::from_bytes_with_nul_unchecked(slice)\n+                }\n+            }\n+            SmallCStr::OnHeap { ref data } => {\n+                data.as_c_str()\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn len_with_nul(&self) -> usize {\n+        match *self {\n+            SmallCStr::OnStack { len_with_nul, .. } => {\n+                len_with_nul as usize\n+            }\n+            SmallCStr::OnHeap { ref data } => {\n+                data.as_bytes_with_nul().len()\n+            }\n+        }\n+    }\n+}\n+\n+impl Deref for SmallCStr {\n+    type Target = ffi::CStr;\n+\n+    fn deref(&self) -> &ffi::CStr {\n+        self.as_c_str()\n+    }\n+}\n+\n+\n+#[test]\n+fn short() {\n+    const TEXT: &str = \"abcd\";\n+    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n+\n+    let scs = SmallCStr::new(TEXT);\n+\n+    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n+    assert_eq!(scs.as_c_str(), reference.as_c_str());\n+    assert!(if let SmallCStr::OnStack { .. } = scs { true } else { false });\n+}\n+\n+#[test]\n+fn empty() {\n+    const TEXT: &str = \"\";\n+    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n+\n+    let scs = SmallCStr::new(TEXT);\n+\n+    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n+    assert_eq!(scs.as_c_str(), reference.as_c_str());\n+    assert!(if let SmallCStr::OnStack { .. } = scs { true } else { false });\n+}\n+\n+#[test]\n+fn long() {\n+    const TEXT: &str = \"01234567890123456789012345678901234567890123456789\\\n+                        01234567890123456789012345678901234567890123456789\\\n+                        01234567890123456789012345678901234567890123456789\";\n+    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n+\n+    let scs = SmallCStr::new(TEXT);\n+\n+    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n+    assert_eq!(scs.as_c_str(), reference.as_c_str());\n+    assert!(if let SmallCStr::OnHeap { .. } = scs { true } else { false });\n+}\n+\n+#[test]\n+#[should_panic]\n+fn internal_nul() {\n+    let _ = SmallCStr::new(\"abcd\\0def\");\n+}"}]}