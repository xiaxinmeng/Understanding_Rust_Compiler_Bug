{"sha": "267e5e1ea78138543c99330b784a5b013ee03064", "node_id": "C_kwDOAAsO6NoAKDI2N2U1ZTFlYTc4MTM4NTQzYzk5MzMwYjc4NGE1YjAxM2VlMDMwNjQ", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-02-06T22:04:24Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-03-30T02:50:20Z"}, "message": "Add support for target builtins", "tree": {"sha": "ff0c76ba37ec4f34a7fe8fcd8ad3208f3b8b803f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff0c76ba37ec4f34a7fe8fcd8ad3208f3b8b803f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/267e5e1ea78138543c99330b784a5b013ee03064", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/267e5e1ea78138543c99330b784a5b013ee03064", "html_url": "https://github.com/rust-lang/rust/commit/267e5e1ea78138543c99330b784a5b013ee03064", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/267e5e1ea78138543c99330b784a5b013ee03064/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13ab1ab9de20dc7571347ff5c72026052e415dda", "url": "https://api.github.com/repos/rust-lang/rust/commits/13ab1ab9de20dc7571347ff5c72026052e415dda", "html_url": "https://github.com/rust-lang/rust/commit/13ab1ab9de20dc7571347ff5c72026052e415dda"}], "stats": {"total": 12, "additions": 10, "deletions": 2}, "files": [{"sha": "a4616d8673ec82b131280cd3c1c5e0321e0e094b", "filename": "src/builder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/267e5e1ea78138543c99330b784a5b013ee03064/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267e5e1ea78138543c99330b784a5b013ee03064/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=267e5e1ea78138543c99330b784a5b013ee03064", "patch": "@@ -231,6 +231,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                     }\n                     else {\n                         assert!(!((actual_ty.is_vector() && !expected_ty.is_vector()) || (!actual_ty.is_vector() && expected_ty.is_vector())), \"{:?} ({}) -> {:?} ({}), index: {:?}[{}]\", actual_ty, actual_ty.is_vector(), expected_ty, expected_ty.is_vector(), func_ptr, index);\n+                        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n                         self.bitcast(actual_val, expected_ty)\n                     }\n                 }\n@@ -1320,11 +1321,13 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             if vec_num_units < mask_num_units {\n                 // NOTE: the mask needs to be the same length as the input vectors, so join the 2\n                 // vectors and create a dummy second vector.\n+                // TODO(antoyo): switch to using new_vector_access.\n                 let array = self.context.new_bitcast(None, v1, array_type);\n                 let mut elements = vec![];\n                 for i in 0..vec_num_units {\n                     elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n                 }\n+                // TODO(antoyo): switch to using new_vector_access.\n                 let array = self.context.new_bitcast(None, v2, array_type);\n                 for i in 0..vec_num_units {\n                     elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n@@ -1347,6 +1350,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             // NOTE: if padding was added, only select the number of elements of the masks to\n             // remove that padding in the result.\n             let mut elements = vec![];\n+            // TODO(antoyo): switch to using new_vector_access.\n             let array = self.context.new_bitcast(None, result, array_type);\n             for i in 0..mask_num_units {\n                 elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());"}, {"sha": "0c5dab0046684bc9e48e504d6ded2ec2b083ba94", "filename": "src/int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/267e5e1ea78138543c99330b784a5b013ee03064/src%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267e5e1ea78138543c99330b784a5b013ee03064/src%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fint.rs?ref=267e5e1ea78138543c99330b784a5b013ee03064", "patch": "@@ -156,6 +156,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             if a_type != b_type {\n                 if a_type.is_vector() {\n                     // Vector types need to be bitcast.\n+                    // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n                     b = self.context.new_bitcast(None, b, a.get_type());\n                 }\n                 else {\n@@ -649,8 +650,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             // Since u128 and i128 are the only types that can be unsupported, we know the type of\n             // value and the destination type have the same size, so a bitcast is fine.\n \n-            // TODO(antoyo): perhaps use __builtin_convertvector for vector casting. (This is elsewhere,\n-            // though.)\n+            // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n             self.context.new_bitcast(None, value, dest_typ)\n         }\n     }"}, {"sha": "b8c6038896d88329c34959244b28bd3443d5c172", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/267e5e1ea78138543c99330b784a5b013ee03064/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267e5e1ea78138543c99330b784a5b013ee03064/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=267e5e1ea78138543c99330b784a5b013ee03064", "patch": "@@ -203,12 +203,14 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let param1_type = builtin.get_param(0).to_rvalue().get_type();\n         let vector =\n             if vector.get_type() != param1_type {\n+                // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n                 bx.context.new_bitcast(None, vector, param1_type)\n             }\n             else {\n                 vector\n             };\n         let result = bx.context.new_call(None, builtin, &[vector, value, bx.context.new_cast(None, index, bx.int_type)]);\n+        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n         return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n     }\n     if name == sym::simd_extract {\n@@ -277,6 +279,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             let vector_type = bx.context.new_vector_type(out_type, 8);\n             let vector = args[0].immediate();\n             let array_type = bx.context.new_array_type(None, in_type, 8);\n+            // TODO(antoyo): switch to using new_vector_access or __builtin_convertvector for vector casting.\n             let array = bx.context.new_bitcast(None, vector, array_type);\n \n             let cast_vec_element = |index| {\n@@ -533,6 +536,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n \n         let func = bx.context.get_target_builtin_function(builtin_name);\n         let result = bx.context.new_call(None, func, &[lhs, rhs]);\n+        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n         return Ok(bx.context.new_bitcast(None, result, vec_ty));\n     }\n "}]}