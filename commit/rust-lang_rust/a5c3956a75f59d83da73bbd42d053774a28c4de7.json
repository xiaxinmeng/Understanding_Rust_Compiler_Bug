{"sha": "a5c3956a75f59d83da73bbd42d053774a28c4de7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YzM5NTZhNzVmNTlkODNkYTczYmJkNDJkMDUzNzc0YTI4YzRkZTc=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2019-07-13T18:17:16Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2019-07-15T07:45:14Z"}, "message": "Don't add extra passes into the function pass manager\n\nException for specific cases like linting, additional passes should\nbe going into the module pass manager (even if they are function\npasses). The separate function pass manager is only used for very\nearly optimization passes.\n\nRather than apparending passes to the MPM, use the OptimizerLast\nand EnabledOnOptLevel0 pass manager builder extension hooks, which\nallow adding passes directly before finalization (alias\ncanonicalization and name-anon-globals).\n\nThe main effect and purpose of this change is to add sanitizer\npasses at the end of the pipeline, which is where they belong.\nIn LLVM 9 the address sanitizer can't be used as a pass in the\nearly function pass manager, because it has a dependence on a\nmodule-level analysis pass.", "tree": {"sha": "b6bbe1c5f96b8b5978b73f05d280bfd8cf1756a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6bbe1c5f96b8b5978b73f05d280bfd8cf1756a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5c3956a75f59d83da73bbd42d053774a28c4de7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c3956a75f59d83da73bbd42d053774a28c4de7", "html_url": "https://github.com/rust-lang/rust/commit/a5c3956a75f59d83da73bbd42d053774a28c4de7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5c3956a75f59d83da73bbd42d053774a28c4de7/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c102cb4ab537f7d71c60165108e2e50d1c92e93", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c102cb4ab537f7d71c60165108e2e50d1c92e93", "html_url": "https://github.com/rust-lang/rust/commit/2c102cb4ab537f7d71c60165108e2e50d1c92e93"}], "stats": {"total": 108, "additions": 69, "deletions": 39}, "files": [{"sha": "253110dcb34c097baf679577a0cde33f4e6b0778", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a5c3956a75f59d83da73bbd42d053774a28c4de7/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c3956a75f59d83da73bbd42d053774a28c4de7/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=a5c3956a75f59d83da73bbd42d053774a28c4de7", "patch": "@@ -329,33 +329,55 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         let mpm = llvm::LLVMCreatePassManager();\n \n         {\n-            // If we're verifying or linting, add them to the function pass\n-            // manager.\n-            let addpass = |pass_name: &str| {\n+            let find_pass = |pass_name: &str| {\n                 let pass_name = SmallCStr::new(pass_name);\n-                let pass = match llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr()) {\n-                    Some(pass) => pass,\n-                    None => return false,\n-                };\n-                let pass_manager = match llvm::LLVMRustPassKind(pass) {\n-                    llvm::PassKind::Function => &*fpm,\n-                    llvm::PassKind::Module => &*mpm,\n-                    llvm::PassKind::Other => {\n-                        diag_handler.err(\"Encountered LLVM pass kind we can't handle\");\n-                        return true\n-                    },\n-                };\n-                llvm::LLVMRustAddPass(pass_manager, pass);\n-                true\n+                llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr())\n             };\n \n-            if config.verify_llvm_ir { assert!(addpass(\"verify\")); }\n+            if config.verify_llvm_ir {\n+                // Verification should run as the very first pass.\n+                llvm::LLVMRustAddPass(fpm, find_pass(\"verify\").unwrap());\n+            }\n+\n+            let mut extra_passes = Vec::new();\n+            let mut have_name_anon_globals_pass = false;\n+\n+            for pass_name in &config.passes {\n+                if pass_name == \"lint\" {\n+                    // Linting should also be performed early, directly on the generated IR.\n+                    llvm::LLVMRustAddPass(fpm, find_pass(\"lint\").unwrap());\n+                    continue;\n+                }\n+\n+                if let Some(pass) = find_pass(pass_name) {\n+                    extra_passes.push(pass);\n+                } else {\n+                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass_name));\n+                }\n+\n+                if pass_name == \"name-anon-globals\" {\n+                    have_name_anon_globals_pass = true;\n+                }\n+            }\n+\n+            for pass_name in &cgcx.plugin_passes {\n+                if let Some(pass) = find_pass(pass_name) {\n+                    extra_passes.push(pass);\n+                } else {\n+                    diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n+                                               `{}` but LLVM does not \\\n+                                               recognize it\", pass_name));\n+                }\n+\n+                if pass_name == \"name-anon-globals\" {\n+                    have_name_anon_globals_pass = true;\n+                }\n+            }\n \n             // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n             // to make sure we run LLVM's NameAnonGlobals pass when emitting bitcode; otherwise\n             // we'll get errors in LLVM.\n             let using_thin_buffers = config.bitcode_needed();\n-            let mut have_name_anon_globals_pass = false;\n             if !config.no_prepopulate_passes {\n                 llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n                 llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n@@ -364,34 +386,22 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                 let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal ||\n                     (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n                 with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n+                    llvm::LLVMRustAddLastExtensionPasses(\n+                        b, extra_passes.as_ptr(), extra_passes.len() as size_t);\n                     llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n                     llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n                 });\n \n                 have_name_anon_globals_pass = have_name_anon_globals_pass || prepare_for_thin_lto;\n                 if using_thin_buffers && !prepare_for_thin_lto {\n-                    assert!(addpass(\"name-anon-globals\"));\n-                    have_name_anon_globals_pass = true;\n-                }\n-            }\n-\n-            for pass in &config.passes {\n-                if !addpass(pass) {\n-                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass));\n-                }\n-                if pass == \"name-anon-globals\" {\n+                    llvm::LLVMRustAddPass(mpm, find_pass(\"name-anon-globals\").unwrap());\n                     have_name_anon_globals_pass = true;\n                 }\n-            }\n-\n-            for pass in &cgcx.plugin_passes {\n-                if !addpass(pass) {\n-                    diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n-                                               `{}` but LLVM does not \\\n-                                               recognize it\", pass));\n-                }\n-                if pass == \"name-anon-globals\" {\n-                    have_name_anon_globals_pass = true;\n+            } else {\n+                // If we don't use the standard pipeline, directly populate the MPM\n+                // with the extra passes.\n+                for pass in extra_passes {\n+                    llvm::LLVMRustAddPass(mpm, pass);\n                 }\n             }\n "}, {"sha": "5d82698d8efb6724ea7847c35c74359db4b8dae1", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5c3956a75f59d83da73bbd42d053774a28c4de7/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c3956a75f59d83da73bbd42d053774a28c4de7/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=a5c3956a75f59d83da73bbd42d053774a28c4de7", "patch": "@@ -1668,6 +1668,9 @@ extern \"C\" {\n     pub fn LLVMRustPassKind(Pass: &Pass) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n     pub fn LLVMRustAddPass(PM: &PassManager<'_>, Pass: &'static mut Pass);\n+    pub fn LLVMRustAddLastExtensionPasses(PMB: &PassManagerBuilder,\n+                                          Passes: *const &'static mut Pass,\n+                                          NumPasses: size_t);\n \n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n "}, {"sha": "7d20086d9a22ee780771151999a34b29554face7", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a5c3956a75f59d83da73bbd42d053774a28c4de7/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a5c3956a75f59d83da73bbd42d053774a28c4de7/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=a5c3956a75f59d83da73bbd42d053774a28c4de7", "patch": "@@ -99,6 +99,23 @@ void LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n   unwrap(PMBR)->populateThinLTOPassManager(*unwrap(PMR));\n }\n \n+extern \"C\"\n+void LLVMRustAddLastExtensionPasses(\n+    LLVMPassManagerBuilderRef PMBR, LLVMPassRef *Passes, size_t NumPasses) {\n+  auto AddExtensionPasses = [Passes, NumPasses](\n+      const PassManagerBuilder &Builder, PassManagerBase &PM) {\n+    for (size_t I = 0; I < NumPasses; I++) {\n+      PM.add(unwrap(Passes[I]));\n+    }\n+  };\n+  // Add the passes to both of the pre-finalization extension points,\n+  // so they are run for optimized and non-optimized builds.\n+  unwrap(PMBR)->addExtension(PassManagerBuilder::EP_OptimizerLast,\n+                             AddExtensionPasses);\n+  unwrap(PMBR)->addExtension(PassManagerBuilder::EP_EnabledOnOptLevel0,\n+                             AddExtensionPasses);\n+}\n+\n #ifdef LLVM_COMPONENT_X86\n #define SUBTARGET_X86 SUBTARGET(X86)\n #else"}]}