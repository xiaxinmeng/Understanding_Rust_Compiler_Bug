{"sha": "9f91901f7e55915b359909b5422c03f70e4ab79b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmOTE5MDFmN2U1NTkxNWIzNTk5MDliNTQyMmMwM2Y3MGU0YWI3OWI=", "commit": {"author": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-11T12:16:35Z"}, "committer": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-11T12:16:35Z"}, "message": "Add more keywords", "tree": {"sha": "af51a0cf3023d04d0cc911564bcb39efb652f704", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af51a0cf3023d04d0cc911564bcb39efb652f704"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f91901f7e55915b359909b5422c03f70e4ab79b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f91901f7e55915b359909b5422c03f70e4ab79b", "html_url": "https://github.com/rust-lang/rust/commit/9f91901f7e55915b359909b5422c03f70e4ab79b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f91901f7e55915b359909b5422c03f70e4ab79b/comments", "author": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4af02d110b2515295d8375b40311c630b90d7be", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4af02d110b2515295d8375b40311c630b90d7be", "html_url": "https://github.com/rust-lang/rust/commit/b4af02d110b2515295d8375b40311c630b90d7be"}], "stats": {"total": 417, "additions": 183, "deletions": 234}, "files": [{"sha": "fa37b695576b1717d8bf358a651903459076c10b", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f91901f7e55915b359909b5422c03f70e4ab79b/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f91901f7e55915b359909b5422c03f70e4ab79b/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=9f91901f7e55915b359909b5422c03f70e4ab79b", "patch": "@@ -15,6 +15,7 @@ mod complete_unqualified_path;\n mod complete_postfix;\n mod complete_macro_in_item_position;\n mod complete_trait_impl;\n+mod patterns;\n #[cfg(test)]\n mod test_utils;\n "}, {"sha": "5b56c6275b6a8fe0a34f79f6559684f0d704b262", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 39, "deletions": 232, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/9f91901f7e55915b359909b5422c03f70e4ab79b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f91901f7e55915b359909b5422c03f70e4ab79b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=9f91901f7e55915b359909b5422c03f70e4ab79b", "patch": "@@ -1,12 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::{\n-    algo::non_trivia_sibling,\n-    ast::{self, LoopBodyOwner},\n-    match_ast, AstNode, Direction, NodeOrToken, SyntaxElement,\n-    SyntaxKind::*,\n-    SyntaxToken,\n-};\n+use ra_syntax::ast;\n \n use crate::completion::{\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n@@ -53,110 +47,56 @@ fn keyword(ctx: &CompletionContext, kw: &str, snippet: &str) -> CompletionItem {\n     .build()\n }\n \n-fn add_top_level_keywords(acc: &mut Completions, ctx: &CompletionContext) {\n-    if let Some(token) = previous_non_triva_element(&ctx.token).and_then(|it| it.into_token()) {\n-        if token.kind() == UNSAFE_KW {\n-            acc.add(keyword(ctx, \"impl\", \"impl $0 {}\"));\n-            acc.add(keyword(ctx, \"trait\", \"trait $0 {}\"));\n-            acc.add(keyword(ctx, \"fn\", \"fn $0() {}\"));\n-            return;\n-        }\n+fn add_keyword(\n+    ctx: &CompletionContext,\n+    acc: &mut Completions,\n+    kw: &str,\n+    snippet: &str,\n+    should_add: bool,\n+) {\n+    if should_add {\n+        acc.add(keyword(ctx, kw, snippet));\n     }\n-    acc.add(keyword(ctx, \"impl\", \"impl $0 {}\"));\n-    acc.add(keyword(ctx, \"enum\", \"enum $0 {}\"));\n-    acc.add(keyword(ctx, \"struct\", \"struct $0 {}\"));\n-    acc.add(keyword(ctx, \"trait\", \"trait $0 {}\"));\n-    acc.add(keyword(ctx, \"fn\", \"fn $0() {}\"));\n-    acc.add(keyword(ctx, \"unsafe\", \"unsafe \"));\n }\n \n pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n-    if ctx.is_new_item {\n-        add_top_level_keywords(acc, ctx);\n-        return;\n-    }\n-    if !ctx.is_trivial_path {\n-        return;\n-    }\n+    add_keyword(ctx, acc, \"fn\", \"fn $0() {}\", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"type\", \"type \", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"fn\", \"fn $0() {}\", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"impl\", \"impl $0 {}\", ctx.is_new_item);\n+    add_keyword(ctx, acc, \"trait\", \"impl $0 {}\", ctx.is_new_item);\n+    add_keyword(ctx, acc, \"enum\", \"enum $0 {}\", ctx.is_new_item && !ctx.after_unsafe);\n+    add_keyword(ctx, acc, \"struct\", \"struct $0 {}\", ctx.is_new_item && !ctx.after_unsafe);\n+    add_keyword(ctx, acc, \"union\", \"union $0 {}\", ctx.is_new_item && !ctx.after_unsafe);\n+    add_keyword(ctx, acc, \"match\", \"match $0 {}\", ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"loop\", \"loop {$0}\", ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"while\", \"while $0 {}\", ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"let\", \"let \", ctx.after_if || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"let\", \"let \", ctx.after_if || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"else\", \"else {$0}\", ctx.after_if);\n+    add_keyword(ctx, acc, \"else if\", \"else if $0 {}\", ctx.after_if);\n+    add_keyword(ctx, acc, \"mod\", \"mod $0 {}\", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"mut\", \"mut \", ctx.bind_pat_parent || ctx.ref_pat_parent);\n+    add_keyword(ctx, acc, \"true\", \"true\", !ctx.is_new_item); // this should be defined properly\n+    add_keyword(ctx, acc, \"false\", \"false\", !ctx.is_new_item); // this should be defined properly\n+    add_keyword(ctx, acc, \"const\", \"const \", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"type\", \"type \", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"static\", \"static \", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"extern\", \"extern \", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"unsafe\", \"unsafe \", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"continue\", \"continue;\", ctx.in_loop_body && ctx.can_be_stmt);\n+    add_keyword(ctx, acc, \"break\", \"break;\", ctx.in_loop_body && ctx.can_be_stmt);\n+    add_keyword(ctx, acc, \"continue\", \"continue\", ctx.in_loop_body && !ctx.can_be_stmt);\n+    add_keyword(ctx, acc, \"break\", \"break\", ctx.in_loop_body && !ctx.can_be_stmt);\n+    complete_use_tree_keyword(acc, ctx);\n \n     let fn_def = match &ctx.function_syntax {\n         Some(it) => it,\n         None => return,\n     };\n-    acc.add(keyword(ctx, \"if\", \"if $0 {}\"));\n-    acc.add(keyword(ctx, \"match\", \"match $0 {}\"));\n-    acc.add(keyword(ctx, \"while\", \"while $0 {}\"));\n-    acc.add(keyword(ctx, \"loop\", \"loop {$0}\"));\n-\n-    if ctx.after_if {\n-        acc.add(keyword(ctx, \"else\", \"else {$0}\"));\n-        acc.add(keyword(ctx, \"else if\", \"else if $0 {}\"));\n-    }\n-    if is_in_loop_body(&ctx.token) {\n-        if ctx.can_be_stmt {\n-            acc.add(keyword(ctx, \"continue\", \"continue;\"));\n-            acc.add(keyword(ctx, \"break\", \"break;\"));\n-        } else {\n-            acc.add(keyword(ctx, \"continue\", \"continue\"));\n-            acc.add(keyword(ctx, \"break\", \"break\"));\n-        }\n-    }\n     acc.add_all(complete_return(ctx, &fn_def, ctx.can_be_stmt));\n }\n \n-fn previous_non_triva_element(token: &SyntaxToken) -> Option<SyntaxElement> {\n-    // trying to get first non triva sibling if we have one\n-    let token_sibling = non_trivia_sibling(NodeOrToken::Token(token.to_owned()), Direction::Prev);\n-    let mut wrapped = if let Some(sibling) = token_sibling {\n-        sibling\n-    } else {\n-        // if not trying to find first ancestor which has such a sibling\n-        let node = token.parent();\n-        let range = node.text_range();\n-        let top_node = node.ancestors().take_while(|it| it.text_range() == range).last()?;\n-        let prev_sibling_node = top_node.ancestors().find(|it| {\n-            non_trivia_sibling(NodeOrToken::Node(it.to_owned()), Direction::Prev).is_some()\n-        })?;\n-        non_trivia_sibling(NodeOrToken::Node(prev_sibling_node), Direction::Prev)?\n-    };\n-    // traversing the tree down to get the last token or node, i.e. the closest one\n-    loop {\n-        if let Some(token) = wrapped.as_token() {\n-            return Some(NodeOrToken::Token(token.clone()));\n-        } else {\n-            let new = wrapped.as_node().and_then(|n| n.last_child_or_token());\n-            if new.is_some() {\n-                wrapped = new.unwrap().clone();\n-            } else {\n-                return Some(wrapped);\n-            }\n-        }\n-    }\n-}\n-\n-fn is_in_loop_body(leaf: &SyntaxToken) -> bool {\n-    // FIXME move this to CompletionContext and make it handle macros\n-    for node in leaf.parent().ancestors() {\n-        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n-            break;\n-        }\n-        let loop_body = match_ast! {\n-            match node {\n-                ast::ForExpr(it) => it.loop_body(),\n-                ast::WhileExpr(it) => it.loop_body(),\n-                ast::LoopExpr(it) => it.loop_body(),\n-                _ => None,\n-            }\n-        };\n-        if let Some(body) = loop_body {\n-            if body.syntax().text_range().contains_range(leaf.text_range()) {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n fn complete_return(\n     ctx: &CompletionContext,\n     fn_def: &ast::FnDef,\n@@ -320,139 +260,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn completes_unsafe_context_in_item_position_with_non_empty_token() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                mod my_mod {\n-                    unsafe i<|>\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"fn\",\n-                source_range: 57..58,\n-                delete: 57..58,\n-                insert: \"fn $0() {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"impl\",\n-                source_range: 57..58,\n-                delete: 57..58,\n-                insert: \"impl $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"trait\",\n-                source_range: 57..58,\n-                delete: 57..58,\n-                insert: \"trait $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_unsafe_context_in_item_position_with_empty_token() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                mod my_mod {\n-                    unsafe <|>\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"fn\",\n-                source_range: 57..57,\n-                delete: 57..57,\n-                insert: \"fn $0() {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"impl\",\n-                source_range: 57..57,\n-                delete: 57..57,\n-                insert: \"impl $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"trait\",\n-                source_range: 57..57,\n-                delete: 57..57,\n-                insert: \"trait $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_keywords_in_item_position_with_empty_token() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                <|>\n-                \",\n-            ),\n-            @r###\"\n-            [\n-                CompletionItem {\n-                    label: \"enum\",\n-                    source_range: 17..17,\n-                    delete: 17..17,\n-                    insert: \"enum $0 {}\",\n-                    kind: Keyword,\n-                },\n-                CompletionItem {\n-                    label: \"fn\",\n-                    source_range: 17..17,\n-                    delete: 17..17,\n-                    insert: \"fn $0() {}\",\n-                    kind: Keyword,\n-                },\n-                CompletionItem {\n-                    label: \"impl\",\n-                    source_range: 17..17,\n-                    delete: 17..17,\n-                    insert: \"impl $0 {}\",\n-                    kind: Keyword,\n-                },\n-                CompletionItem {\n-                    label: \"struct\",\n-                    source_range: 17..17,\n-                    delete: 17..17,\n-                    insert: \"struct $0 {}\",\n-                    kind: Keyword,\n-                },\n-                CompletionItem {\n-                    label: \"trait\",\n-                    source_range: 17..17,\n-                    delete: 17..17,\n-                    insert: \"trait $0 {}\",\n-                    kind: Keyword,\n-                },\n-                CompletionItem {\n-                    label: \"unsafe\",\n-                    source_range: 17..17,\n-                    delete: 17..17,\n-                    insert: \"unsafe \",\n-                    kind: Keyword,\n-                },\n-            ]\n-        \"###\n-        );\n-    }\n-\n     #[test]\n     fn completes_else_after_if() {\n         assert_debug_snapshot!("}, {"sha": "1ef07d8f4ca60a5affce74653eb5e4b0f56a8edf", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9f91901f7e55915b359909b5422c03f70e4ab79b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f91901f7e55915b359909b5422c03f70e4ab79b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=9f91901f7e55915b359909b5422c03f70e4ab79b", "patch": "@@ -5,12 +5,16 @@ use ra_db::SourceDatabase;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n-    ast, match_ast, AstNode,\n+    ast, match_ast, AstNode, NodeOrToken,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n use ra_text_edit::Indel;\n \n+use super::patterns::{\n+    goes_after_unsafe, has_bind_pat_parent, has_block_expr_parent, has_ref_pat_parent,\n+    is_in_loop_body,\n+};\n use crate::{call_info::ActiveParameter, completion::CompletionConfig, FilePosition};\n use test_utils::mark;\n \n@@ -60,6 +64,11 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_path_type: bool,\n     pub(super) has_type_args: bool,\n     pub(super) attribute_under_caret: Option<ast::Attr>,\n+    pub(super) after_unsafe: bool,\n+    pub(super) block_expr_parent: bool,\n+    pub(super) bind_pat_parent: bool,\n+    pub(super) ref_pat_parent: bool,\n+    pub(super) in_loop_body: bool,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -118,6 +127,11 @@ impl<'a> CompletionContext<'a> {\n             has_type_args: false,\n             dot_receiver_is_ambiguous_float_literal: false,\n             attribute_under_caret: None,\n+            after_unsafe: false,\n+            in_loop_body: false,\n+            ref_pat_parent: false,\n+            bind_pat_parent: false,\n+            block_expr_parent: false,\n         };\n \n         let mut original_file = original_file.syntax().clone();\n@@ -159,7 +173,7 @@ impl<'a> CompletionContext<'a> {\n                 break;\n             }\n         }\n-\n+        ctx.fill_keyword_patterns(&hypothetical_file, offset);\n         ctx.fill(&original_file, hypothetical_file, offset);\n         Some(ctx)\n     }\n@@ -188,6 +202,16 @@ impl<'a> CompletionContext<'a> {\n         self.sema.scope_at_offset(&self.token.parent(), self.offset)\n     }\n \n+    fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n+        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n+        let syntax_element = NodeOrToken::Token(fake_ident_token.clone());\n+        self.block_expr_parent = has_block_expr_parent(syntax_element.clone());\n+        self.after_unsafe = goes_after_unsafe(syntax_element.clone());\n+        self.bind_pat_parent = has_bind_pat_parent(syntax_element.clone());\n+        self.ref_pat_parent = has_ref_pat_parent(syntax_element.clone());\n+        self.in_loop_body = is_in_loop_body(syntax_element.clone());\n+    }\n+\n     fn fill(\n         &mut self,\n         original_file: &SyntaxNode,"}, {"sha": "b55f23fbe340658b916bc28c09d69613c08b8186", "filename": "crates/ra_ide/src/completion/patterns.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9f91901f7e55915b359909b5422c03f70e4ab79b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f91901f7e55915b359909b5422c03f70e4ab79b/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs?ref=9f91901f7e55915b359909b5422c03f70e4ab79b", "patch": "@@ -0,0 +1,117 @@\n+use ra_syntax::{\n+    algo::non_trivia_sibling,\n+    ast::{self, LoopBodyOwner},\n+    match_ast, AstNode, Direction, NodeOrToken, SyntaxElement,\n+    SyntaxKind::*,\n+    SyntaxNode,\n+};\n+\n+pub(crate) fn inside_impl(element: SyntaxElement) -> bool {\n+    let node = match element {\n+        NodeOrToken::Node(node) => node,\n+        NodeOrToken::Token(token) => token.parent(),\n+    };\n+    node.ancestors().find(|it| it.kind() == IMPL_DEF).is_some()\n+}\n+\n+pub(crate) fn has_bind_pat_parent(element: SyntaxElement) -> bool {\n+    let node = match element {\n+        NodeOrToken::Node(node) => node,\n+        NodeOrToken::Token(token) => token.parent(),\n+    };\n+    node.ancestors().find(|it| it.kind() == BIND_PAT).is_some()\n+}\n+\n+pub(crate) fn has_ref_pat_parent(element: SyntaxElement) -> bool {\n+    let node = match element {\n+        NodeOrToken::Node(node) => node,\n+        NodeOrToken::Token(token) => token.parent(),\n+    };\n+    node.ancestors().find(|it| it.kind() == REF_PAT).is_some()\n+}\n+\n+pub(crate) fn goes_after_unsafe(element: SyntaxElement) -> bool {\n+    if let Some(token) = previous_non_triva_element(element).and_then(|it| it.into_token()) {\n+        if token.kind() == UNSAFE_KW {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+pub(crate) fn has_block_expr_parent(element: SyntaxElement) -> bool {\n+    not_same_range_parent(element).filter(|it| it.kind() == BLOCK_EXPR).is_some()\n+}\n+\n+pub(crate) fn has_item_list_parent(element: SyntaxElement) -> bool {\n+    not_same_range_parent(element).filter(|it| it.kind() == ITEM_LIST).is_some()\n+}\n+\n+pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n+    let leaf = match element {\n+        NodeOrToken::Node(node) => node,\n+        NodeOrToken::Token(token) => token.parent(),\n+    };\n+    for node in leaf.ancestors() {\n+        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n+            break;\n+        }\n+        let loop_body = match_ast! {\n+            match node {\n+                ast::ForExpr(it) => it.loop_body(),\n+                ast::WhileExpr(it) => it.loop_body(),\n+                ast::LoopExpr(it) => it.loop_body(),\n+                _ => None,\n+            }\n+        };\n+        if let Some(body) = loop_body {\n+            if body.syntax().text_range().contains_range(leaf.text_range()) {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn not_same_range_parent(element: SyntaxElement) -> Option<SyntaxNode> {\n+    let node = match element {\n+        NodeOrToken::Node(node) => node,\n+        NodeOrToken::Token(token) => token.parent(),\n+    };\n+    let range = node.text_range();\n+    node.ancestors().take_while(|it| it.text_range() == range).last().and_then(|it| it.parent())\n+}\n+\n+fn previous_non_triva_element(element: SyntaxElement) -> Option<SyntaxElement> {\n+    // trying to get first non triva sibling if we have one\n+    let token_sibling = non_trivia_sibling(element.clone(), Direction::Prev);\n+    let mut wrapped = if let Some(sibling) = token_sibling {\n+        sibling\n+    } else {\n+        // if not trying to find first ancestor which has such a sibling\n+        let node = match element {\n+            NodeOrToken::Node(node) => node,\n+            NodeOrToken::Token(token) => token.parent(),\n+        };\n+        let range = node.text_range();\n+        let top_node = node.ancestors().take_while(|it| it.text_range() == range).last()?;\n+        let prev_sibling_node = top_node.ancestors().find(|it| {\n+            non_trivia_sibling(NodeOrToken::Node(it.to_owned()), Direction::Prev).is_some()\n+        })?;\n+        non_trivia_sibling(NodeOrToken::Node(prev_sibling_node), Direction::Prev)?\n+    };\n+    //I think you can avoid this loop if you use SyntaxToken::prev_token -- unlike prev_sibling_or_token, it works across parents.\n+    // traversing the tree down to get the last token or node, i.e. the closest one\n+    loop {\n+        if let Some(token) = wrapped.as_token() {\n+            return Some(NodeOrToken::Token(token.clone()));\n+        } else {\n+            let new = wrapped.as_node().and_then(|n| n.last_child_or_token());\n+            if new.is_some() {\n+                wrapped = new.unwrap().clone();\n+            } else {\n+                return Some(wrapped);\n+            }\n+        }\n+    }\n+}"}]}