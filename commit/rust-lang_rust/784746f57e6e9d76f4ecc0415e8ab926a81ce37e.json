{"sha": "784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NDc0NmY1N2U2ZTlkNzZmNGVjYzA0MTVlOGFiOTI2YTgxY2UzN2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-01T14:13:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-27T12:41:12Z"}, "message": "convert placeholder region vids in NLL mode as we see them", "tree": {"sha": "f60afcbd64473abc60bef1c4b4a8ffee9933801e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f60afcbd64473abc60bef1c4b4a8ffee9933801e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "html_url": "https://github.com/rust-lang/rust/commit/784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "018c515f077597ad45f85d962a49ab6fbc5421ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/018c515f077597ad45f85d962a49ab6fbc5421ac", "html_url": "https://github.com/rust-lang/rust/commit/018c515f077597ad45f85d962a49ab6fbc5421ac"}], "stats": {"total": 126, "additions": 88, "deletions": 38}, "files": [{"sha": "0c4140caee86f8e85542955b50e9cf4ccbb59127", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "patch": "@@ -134,6 +134,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     let var_origins = infcx.take_region_var_origins();\n     let MirTypeckRegionConstraints {\n         placeholder_indices,\n+        placeholder_index_to_region: _,\n         mut liveness_constraints,\n         outlives_constraints,\n         closure_bounds_mapping,"}, {"sha": "641351956379b14d0d8f55418990d85f449c8e57", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "patch": "@@ -594,6 +594,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     // Finds some region R such that `fr1: R` and `R` is live at\n     // `elem`.\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+        debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n         // Find all paths\n         let (_path, r) =\n             self.find_constraint_paths_between_regions(fr1, |r| {"}, {"sha": "0e44c8b36a929a5d2a0792e4328cf482a7e9acce", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "patch": "@@ -1226,6 +1226,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n+        debug!(\n+            \"check_bound_universal_region: longer_fr_scc={:?}\",\n+            longer_fr_scc,\n+        );\n \n         // If we have some bound universal region `'a`, then the only\n         // elements it can contain is itself -- we don't know anything\n@@ -1242,6 +1246,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             Some(v) => v,\n             None => return,\n         };\n+        debug!(\"check_bound_universal_region: error_element = {:?}\", error_element);\n \n         // Find the region that introduced this `error_element`.\n         let error_region = match error_element {"}, {"sha": "5904138ef603ac03df58ffe06f7df786c5425cb1", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "patch": "@@ -8,54 +8,54 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::region_infer::TypeTest;\n-use borrow_check::nll::type_check::Locations;\n+use borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::ToRegionVid;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n-use rustc::infer::{self, SubregionOrigin};\n+use rustc::infer::{self, InferCtxt, SubregionOrigin};\n use rustc::mir::ConstraintCategory;\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, TyCtxt};\n use syntax_pos::DUMMY_SP;\n \n crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n     category: ConstraintCategory,\n-    outlives_constraints: &'a mut ConstraintSet,\n-    type_tests: &'a mut Vec<TypeTest<'tcx>>,\n+    constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     crate fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n-        outlives_constraints: &'a mut ConstraintSet,\n-        type_tests: &'a mut Vec<TypeTest<'tcx>>,\n+        constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n     ) -> Self {\n         Self {\n-            tcx,\n+            infcx,\n+            tcx: infcx.tcx,\n             universal_regions,\n             region_bound_pairs,\n             implicit_region_bound,\n             param_env,\n             locations,\n             category,\n-            outlives_constraints,\n-            type_tests,\n+            constraints,\n         }\n     }\n \n@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     }\n \n     fn verify_to_type_test(\n-        &self,\n+        &mut self,\n         generic_kind: GenericKind<'tcx>,\n         region: ty::Region<'tcx>,\n         verify_bound: VerifyBound<'tcx>,\n@@ -128,22 +128,30 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n-        self.universal_regions.to_region_vid(r)\n+    fn to_region_vid(&mut self, r: ty::Region<'tcx>) -> ty::RegionVid {\n+        if let ty::RePlaceholder(placeholder) = r {\n+            self.constraints\n+                .placeholder_region(self.infcx, *placeholder)\n+                .to_region_vid()\n+        } else {\n+            self.universal_regions.to_region_vid(r)\n+        }\n     }\n \n     fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n-        self.outlives_constraints.push(OutlivesConstraint {\n-            locations: self.locations,\n-            category: self.category,\n-            sub,\n-            sup,\n-        });\n+        self.constraints\n+            .outlives_constraints\n+            .push(OutlivesConstraint {\n+                locations: self.locations,\n+                category: self.category,\n+                sub,\n+                sup,\n+            });\n     }\n \n     fn add_type_test(&mut self, type_test: TypeTest<'tcx>) {\n         debug!(\"add_type_test(type_test={:?})\", type_test);\n-        self.type_tests.push(type_test);\n+        self.constraints.type_tests.push(type_test);\n     }\n }\n \n@@ -156,8 +164,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx>\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) {\n-        let b = self.universal_regions.to_region_vid(b);\n-        let a = self.universal_regions.to_region_vid(a);\n+        let b = self.to_region_vid(b);\n+        let a = self.to_region_vid(a);\n         self.add_outlives(b, a);\n     }\n "}, {"sha": "3d0f3d9fc7d8d1ee8cffb99c9f357a0f9f206b89", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "patch": "@@ -271,15 +271,14 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n \n         for data in constraint_sets {\n             constraint_conversion::ConstraintConversion::new(\n-                self.infcx.tcx,\n+                self.infcx,\n                 &self.universal_regions,\n                 &self.region_bound_pairs,\n                 self.implicit_region_bound,\n                 self.param_env,\n                 Locations::All(DUMMY_SP),\n                 ConstraintCategory::Internal,\n-                &mut self.constraints.outlives_constraints,\n-                &mut self.constraints.type_tests,\n+                &mut self.constraints,\n             ).convert_all(&data);\n         }\n "}, {"sha": "eae41c81ff2fbedf35fdd8d8399f649d264373bb", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "patch": "@@ -16,6 +16,7 @@ use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::LivenessValues;\n+use borrow_check::nll::region_infer::values::PlaceholderIndex;\n use borrow_check::nll::region_infer::values::PlaceholderIndices;\n use borrow_check::nll::region_infer::values::RegionValueElements;\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n@@ -28,11 +29,12 @@ use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n+use either::Either;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::env::RegionBoundPairs;\n-use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n@@ -44,14 +46,13 @@ use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use std::rc::Rc;\n use std::{fmt, iter};\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n \n-use either::Either;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-\n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n         $crate::borrow_check::nll::type_check::mirbug(\n@@ -127,6 +128,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n         placeholder_indices: PlaceholderIndices::default(),\n+        placeholder_index_to_region: IndexVec::default(),\n         liveness_constraints: LivenessValues::new(elements),\n         outlives_constraints: ConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n@@ -738,8 +740,20 @@ crate struct MirTypeckResults<'tcx> {\n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n crate struct MirTypeckRegionConstraints<'tcx> {\n+    /// Maps from a `ty::Placeholder` to the corresponding\n+    /// `PlaceholderIndex` bit that we will use for it.\n+    ///\n+    /// To keep everything in sync, do not insert this set\n+    /// directly. Instead, use the `placeholder_region` helper.\n     crate placeholder_indices: PlaceholderIndices,\n \n+    /// Each time we add a placeholder to `placeholder_indices`, we\n+    /// also create a corresponding \"representative\" region vid for\n+    /// that wraps it. This vector tracks those. This way, when we\n+    /// convert the same `ty::RePlaceholder(p)` twice, we can map to\n+    /// the same underlying `RegionVid`.\n+    crate placeholder_index_to_region: IndexVec<PlaceholderIndex, ty::Region<'tcx>>,\n+\n     /// In general, the type-checker is not responsible for enforcing\n     /// liveness constraints; this job falls to the region inferencer,\n     /// which performs a liveness analysis. However, in some limited\n@@ -757,6 +771,25 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     crate type_tests: Vec<TypeTest<'tcx>>,\n }\n \n+impl MirTypeckRegionConstraints<'tcx> {\n+    fn placeholder_region(\n+        &mut self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        placeholder: ty::Placeholder,\n+    ) -> ty::Region<'tcx> {\n+        let placeholder_index = self.placeholder_indices.insert(placeholder);\n+        match self.placeholder_index_to_region.get(placeholder_index) {\n+            Some(&v) => v,\n+            None => {\n+                let origin = NLLRegionVariableOrigin::Placeholder(placeholder);\n+                let region = infcx.next_nll_region_var(origin);\n+                self.placeholder_index_to_region.push(region);\n+                region\n+            }\n+        }\n+    }\n+}\n+\n /// The `Locations` type summarizes *where* region constraints are\n /// required to hold. Normally, this is at a particular point which\n /// created the obligation, but for constraints that the user gave, we\n@@ -886,15 +919,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         if let Some(ref mut borrowck_context) = self.borrowck_context {\n             constraint_conversion::ConstraintConversion::new(\n-                self.infcx.tcx,\n+                self.infcx,\n                 borrowck_context.universal_regions,\n                 self.region_bound_pairs,\n                 self.implicit_region_bound,\n                 self.param_env,\n                 locations,\n                 category,\n-                &mut borrowck_context.constraints.outlives_constraints,\n-                &mut borrowck_context.constraints.type_tests,\n+                &mut borrowck_context.constraints,\n             ).convert_all(&data);\n         }\n     }"}, {"sha": "b82efb29f6e56a8a0cf0bc2a1745f5f54cd6b4d6", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784746f57e6e9d76f4ecc0415e8ab926a81ce37e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=784746f57e6e9d76f4ecc0415e8ab926a81ce37e", "patch": "@@ -76,16 +76,20 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n     }\n \n     fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n-        let origin = NLLRegionVariableOrigin::Existential;\n-        self.infcx.next_nll_region_var(origin)\n+        if let Some(_) = &mut self.borrowck_context {\n+            let origin = NLLRegionVariableOrigin::Existential;\n+            self.infcx.next_nll_region_var(origin)\n+        } else {\n+            self.infcx.tcx.types.re_erased\n+        }\n     }\n \n     fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx> {\n-        let origin = NLLRegionVariableOrigin::Placeholder(placeholder);\n         if let Some(borrowck_context) = &mut self.borrowck_context {\n-            borrowck_context.constraints.placeholder_indices.insert(placeholder);\n+            borrowck_context.constraints.placeholder_region(self.infcx, placeholder)\n+        } else {\n+            self.infcx.tcx.types.re_erased\n         }\n-        self.infcx.next_nll_region_var(origin)\n     }\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {"}]}