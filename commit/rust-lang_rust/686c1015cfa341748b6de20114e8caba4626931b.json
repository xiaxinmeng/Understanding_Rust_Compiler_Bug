{"sha": "686c1015cfa341748b6de20114e8caba4626931b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NmMxMDE1Y2ZhMzQxNzQ4YjZkZTIwMTE0ZThjYWJhNDYyNjkzMWI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-10-19T23:30:37Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-10-19T23:30:37Z"}, "message": "Make tools which may not build return Option.\n\nThis makes it mandatory for other steps to have to handle the potential\nfailure instead of failing in an odd way later down the road.", "tree": {"sha": "f186e91efd06e795b7de101dcd6a32d4966a76b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f186e91efd06e795b7de101dcd6a32d4966a76b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/686c1015cfa341748b6de20114e8caba4626931b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/686c1015cfa341748b6de20114e8caba4626931b", "html_url": "https://github.com/rust-lang/rust/commit/686c1015cfa341748b6de20114e8caba4626931b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/686c1015cfa341748b6de20114e8caba4626931b/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fcd3e7b07e0f50a75f50b2e7dc935ae06fc5abd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fcd3e7b07e0f50a75f50b2e7dc935ae06fc5abd", "html_url": "https://github.com/rust-lang/rust/commit/0fcd3e7b07e0f50a75f50b2e7dc935ae06fc5abd"}], "stats": {"total": 118, "additions": 65, "deletions": 53}, "files": [{"sha": "11bc9f7d217721b83252ce26e12a34bdbb9c5034", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/686c1015cfa341748b6de20114e8caba4626931b/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686c1015cfa341748b6de20114e8caba4626931b/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=686c1015cfa341748b6de20114e8caba4626931b", "patch": "@@ -340,25 +340,28 @@ impl Step for Miri {\n         let host = self.host;\n         let compiler = builder.compiler(1, host);\n \n-        let miri = builder.ensure(tool::Miri { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-        // miri tests need to know about the stage sysroot\n-        cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n-        cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-        cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-        cargo.env(\"MIRI_PATH\", miri);\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-        try_run_expecting(\n-            build,\n-            &mut cargo,\n-            builder.build.config.toolstate.miri.passes(ToolState::Testing),\n-        );\n+        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n+\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // miri tests need to know about the stage sysroot\n+            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            cargo.env(\"MIRI_PATH\", miri);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            try_run_expecting(\n+                build,\n+                &mut cargo,\n+                builder.build.config.toolstate.miri.passes(ToolState::Testing),\n+            );\n+        } else {\n+            eprintln!(\"failed to test miri: could not build\");\n+        }\n     }\n }\n \n@@ -391,24 +394,27 @@ impl Step for Clippy {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        let clippy = builder.ensure(tool::Clippy { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n+        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n \n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-        // clippy tests need to know about the stage sysroot\n-        cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n-        // clippy tests need to find the driver\n-        cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // clippy tests need to know about the stage sysroot\n+            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+            // clippy tests need to find the driver\n+            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n \n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        try_run_expecting(\n-            build,\n-            &mut cargo,\n-            builder.build.config.toolstate.clippy.passes(ToolState::Testing),\n-        );\n+            try_run_expecting(\n+                build,\n+                &mut cargo,\n+                builder.build.config.toolstate.clippy.passes(ToolState::Testing),\n+            );\n+        } else {\n+            eprintln!(\"failed to test clippy: could not build\");\n+        }\n     }\n }\n "}, {"sha": "a6663a854840e1abecabc90516bed53ee4003656", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/686c1015cfa341748b6de20114e8caba4626931b/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686c1015cfa341748b6de20114e8caba4626931b/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=686c1015cfa341748b6de20114e8caba4626931b", "patch": "@@ -1073,10 +1073,12 @@ impl Step for Rls {\n         t!(fs::create_dir_all(&image));\n \n         // Prepare the image directory\n+        // We expect RLS to build, because we've exited this step above if tool\n+        // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n             compiler: builder.compiler(stage, build.build),\n             target\n-        });\n+        }).expect(\"Rls to build: toolstate is testing\");\n         install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n         install(&src.join(\"README.md\"), &doc, 0o644);"}, {"sha": "912ffa519758cc1fdd8ef3e8959c9458d48ab08c", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/686c1015cfa341748b6de20114e8caba4626931b/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686c1015cfa341748b6de20114e8caba4626931b/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=686c1015cfa341748b6de20114e8caba4626931b", "patch": "@@ -86,7 +86,7 @@ struct ToolBuild {\n }\n \n impl Step for ToolBuild {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.never()\n@@ -96,7 +96,7 @@ impl Step for ToolBuild {\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n@@ -116,11 +116,15 @@ impl Step for ToolBuild {\n \n         let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n         build.run_expecting(&mut cargo, expectation);\n-        let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n-            .join(exe(tool, &compiler.host));\n-        let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n-        copy(&cargo_out, &bin);\n-        bin\n+        if expectation == BuildExpectation::Succeeding || expectation == BuildExpectation::None {\n+            let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n+                .join(exe(tool, &compiler.host));\n+            let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n+            copy(&cargo_out, &bin);\n+            Some(bin)\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -229,7 +233,7 @@ macro_rules! tool {\n                     mode: $mode,\n                     path: $path,\n                     expectation: BuildExpectation::None,\n-                })\n+                }).expect(\"expected to build -- BuildExpectation::None\")\n             }\n         }\n         )+\n@@ -277,7 +281,7 @@ impl Step for RemoteTestServer {\n             mode: Mode::Libstd,\n             path: \"src/tools/remote-test-server\",\n             expectation: BuildExpectation::None,\n-        })\n+        }).expect(\"expected to build -- BuildExpectation::None\")\n     }\n }\n \n@@ -395,7 +399,7 @@ impl Step for Cargo {\n             mode: Mode::Librustc,\n             path: \"src/tools/cargo\",\n             expectation: BuildExpectation::None,\n-        })\n+        }).expect(\"BuildExpectation::None - expected to build\")\n     }\n }\n \n@@ -406,7 +410,7 @@ pub struct Clippy {\n }\n \n impl Step for Clippy {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -421,7 +425,7 @@ impl Step for Clippy {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         // Clippy depends on procedural macros (serde), which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n@@ -446,7 +450,7 @@ pub struct Rls {\n }\n \n impl Step for Rls {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -462,7 +466,7 @@ impl Step for Rls {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         builder.ensure(native::Openssl {\n             target: self.target,\n         });\n@@ -490,7 +494,7 @@ pub struct Rustfmt {\n }\n \n impl Step for Rustfmt {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -506,7 +510,7 @@ impl Step for Rustfmt {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -526,7 +530,7 @@ pub struct Miri {\n }\n \n impl Step for Miri {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -542,7 +546,7 @@ impl Step for Miri {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,"}]}