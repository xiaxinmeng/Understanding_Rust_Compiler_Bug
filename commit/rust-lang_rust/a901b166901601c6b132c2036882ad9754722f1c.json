{"sha": "a901b166901601c6b132c2036882ad9754722f1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MDFiMTY2OTAxNjAxYzZiMTMyYzIwMzY4ODJhZDk3NTQ3MjJmMWM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-15T23:21:30Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:57Z"}, "message": "std: bootstrapping libuv-based fileio in newrt... open & close\n\nthe test \"touch\"es a new file", "tree": {"sha": "0cff31d2eba649b106a8b2cc0206ff5699e169d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cff31d2eba649b106a8b2cc0206ff5699e169d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a901b166901601c6b132c2036882ad9754722f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a901b166901601c6b132c2036882ad9754722f1c", "html_url": "https://github.com/rust-lang/rust/commit/a901b166901601c6b132c2036882ad9754722f1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a901b166901601c6b132c2036882ad9754722f1c/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f858452391c63bfbf46678c4ea9fd584adf1c28e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f858452391c63bfbf46678c4ea9fd584adf1c28e", "html_url": "https://github.com/rust-lang/rust/commit/f858452391c63bfbf46678c4ea9fd584adf1c28e"}], "stats": {"total": 246, "additions": 232, "deletions": 14}, "files": [{"sha": "cab27ee29c1c08c2289e8e46b030d3f86f96afe6", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 160, "deletions": 9, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/a901b166901601c6b132c2036882ad9754722f1c/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a901b166901601c6b132c2036882ad9754722f1c/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=a901b166901601c6b132c2036882ad9754722f1c", "patch": "@@ -11,30 +11,87 @@\n use prelude::*;\n use ptr::null;\n use libc::c_void;\n-use rt::uv::{Request, NativeHandle, Loop, FsCallback};\n+use rt::uv::{Request, NativeHandle, Loop, FsCallback,\n+             status_to_maybe_uv_error_with_loop};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n+use path::Path;\n+use cast::transmute;\n+use libc::{c_int};\n \n pub struct FsRequest(*uvll::uv_fs_t);\n impl Request for FsRequest;\n \n+#[allow(non_camel_case_types)]\n+pub enum UvFileFlag {\n+    O_RDONLY,\n+    O_WRONLY,\n+    O_RDWR,\n+    O_CREAT,\n+    O_TRUNC\n+}\n+pub fn map_flag(v: UvFileFlag) -> int {\n+    unsafe {\n+        match v {\n+            O_RDONLY => uvll::get_O_RDONLY() as int,\n+            O_WRONLY => uvll::get_O_WRONLY() as int,\n+            O_RDWR => uvll::get_O_RDWR() as int,\n+            O_CREAT => uvll::get_O_CREAT() as int,\n+            O_TRUNC => uvll::get_O_TRUNC() as int\n+        }\n+    }\n+}\n+\n+pub struct RequestData {\n+    complete_cb: Option<FsCallback>\n+}\n+\n impl FsRequest {\n-    fn new() -> FsRequest {\n+    pub fn new(cb: Option<FsCallback>) -> FsRequest {\n         let fs_req = unsafe { malloc_req(UV_FS) };\n         assert!(fs_req.is_not_null());\n-        let fs_req = fs_req as *uvll::uv_write_t;\n-        unsafe { uvll::set_data_for_req(fs_req, null::<()>()); }\n-        NativeHandle::from_native_handle(fs_req)\n+        let fs_req: FsRequest = NativeHandle::from_native_handle(fs_req);\n+        fs_req.install_req_data(cb);\n+        fs_req\n+    }\n+\n+    pub fn install_req_data(&self, cb: Option<FsCallback>) {\n+        let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n+        let data = ~RequestData {\n+            complete_cb: cb\n+        };\n+        unsafe {\n+            let data = transmute::<~RequestData, *c_void>(data);\n+            uvll::set_data_for_req(fs_req, data);\n+        }\n     }\n \n-    fn delete(self) {\n-        unsafe { free_req(self.native_handle() as *c_void) }\n+    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n+        unsafe {\n+            let data = uvll::get_data_for_req((self.native_handle()));\n+            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n+            return &mut **data;\n+        }\n     }\n \n-    fn open(&mut self, _loop_: &Loop, _cb: FsCallback) {\n+    pub fn get_result(&mut self) -> c_int {\n+        unsafe {\n+            uvll::get_result_from_fs_req(self.native_handle())\n+        }\n     }\n \n-    fn close(&mut self, _loop_: &Loop, _cb: FsCallback) {\n+    pub fn get_loop(&self) -> Loop {\n+        unsafe { Loop{handle:uvll::get_loop_from_fs_req(self.native_handle())} }\n+    }\n+\n+    fn cleanup_and_delete(self) {\n+        unsafe {\n+            uvll::fs_req_cleanup(self.native_handle());\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let _data = transmute::<*c_void, ~RequestData>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n+            free_req(self.native_handle() as *c_void)\n+        }\n     }\n }\n \n@@ -46,3 +103,97 @@ impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n         match self { &FsRequest(ptr) => ptr }\n     }\n }\n+\n+pub struct FileDescriptor(c_int);\n+impl FileDescriptor {\n+    fn new(fd: c_int) -> FileDescriptor {\n+        FileDescriptor(fd)\n+    }\n+\n+    pub fn from_open_req(req: &mut FsRequest) -> FileDescriptor {\n+        FileDescriptor::new(req.get_result())\n+    }\n+\n+    pub fn open(loop_: Loop, path: Path, flags: int, mode: int,\n+               cb: FsCallback) -> int {\n+        let req = FsRequest::new(Some(cb));\n+        path.to_str().to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_open(loop_.native_handle(),\n+                          req.native_handle(), p, flags, mode, complete_cb) as int\n+        })\n+\n+    }\n+\n+    fn close(self, loop_: Loop, cb: FsCallback) -> int {\n+        let req = FsRequest::new(Some(cb));\n+        unsafe {\n+            uvll::fs_close(loop_.native_handle(), req.native_handle(),\n+                           self.native_handle(), complete_cb) as int\n+        }\n+    }\n+}\n+extern fn complete_cb(req: *uv_fs_t) {\n+    let mut req: FsRequest = NativeHandle::from_native_handle(req);\n+    let loop_ = req.get_loop();\n+    // pull the user cb out of the req data\n+    let cb = {\n+        let data = req.get_req_data();\n+        assert!(data.complete_cb.is_some());\n+        // option dance, option dance. oooooh yeah.\n+        data.complete_cb.take_unwrap()\n+    };\n+    // in uv_fs_open calls, the result will be the fd in the\n+    // case of success, otherwise it's -1 indicating an error\n+    let result = req.get_result();\n+    let status = status_to_maybe_uv_error_with_loop(\n+        loop_.native_handle(), result);\n+    // we have a req and status, call the user cb..\n+    // only giving the user a ref to the FsRequest, as we\n+    // have to clean it up, afterwards (and they aren't really\n+    // reusable, anyways\n+    cb(&mut req, status);\n+    // clean up the req (and its data!) after calling the user cb\n+    req.cleanup_and_delete();\n+}\n+\n+impl NativeHandle<c_int> for FileDescriptor {\n+    fn from_native_handle(handle: c_int) -> FileDescriptor {\n+        FileDescriptor(handle)\n+    }\n+    fn native_handle(&self) -> c_int {\n+        match self { &FileDescriptor(ptr) => ptr }\n+    }\n+}\n+\n+mod test {\n+    use super::*;\n+    //use rt::test::*;\n+    use unstable::run_in_bare_thread;\n+    use path::Path;\n+    use rt::uv::Loop;\n+\n+    // this is equiv to touch, i guess?\n+    fn file_test_touch_impl() {\n+        debug!(\"hello?\")\n+        do run_in_bare_thread {\n+            debug!(\"In bare thread\")\n+            let loop_ = Loop::new();\n+            let flags = map_flag(O_RDWR) |\n+                map_flag(O_CREAT) | map_flag(O_TRUNC);\n+            do FileDescriptor::open(loop_, Path(\"./foo.txt\"), flags, 0644)\n+            |req, uverr| {\n+                let loop_ = req.get_loop();\n+                assert!(uverr.is_none());\n+                let fd = FileDescriptor::from_open_req(req);\n+                do fd.close(loop_) |_, uverr| {\n+                    assert!(uverr.is_none());\n+                };\n+            };\n+        }\n+    }\n+\n+    #[test]\n+    fn file_test_touch() {\n+        file_test_touch_impl();\n+    }\n+}"}, {"sha": "75b9a5ac553e8eff77d5d096730081f2e12cd902", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a901b166901601c6b132c2036882ad9754722f1c/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a901b166901601c6b132c2036882ad9754722f1c/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=a901b166901601c6b132c2036882ad9754722f1c", "patch": "@@ -53,7 +53,7 @@ use rt::io::IoError;\n \n //#[cfg(test)] use unstable::run_in_bare_thread;\n \n-pub use self::file::FsRequest;\n+pub use self::file::{FsRequest};\n pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n@@ -125,7 +125,7 @@ pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n pub type NullCallback = ~fn();\n pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n-pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n+pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n@@ -281,6 +281,20 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     }\n }\n \n+/// Given a uv handle, convert a callback status to a UvError\n+pub fn status_to_maybe_uv_error_with_loop(\n+    loop_: *uvll::uv_loop_t,\n+    status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n+    }\n+}\n /// Given a uv handle, convert a callback status to a UvError\n pub fn status_to_maybe_uv_error<T, U: Watcher + NativeHandle<*T>>(handle: U,\n                                                                  status: c_int) -> Option<UvError> {\n@@ -290,9 +304,7 @@ pub fn status_to_maybe_uv_error<T, U: Watcher + NativeHandle<*T>>(handle: U,\n         unsafe {\n             rtdebug!(\"handle: %x\", handle.native_handle() as uint);\n             let loop_ = uvll::get_loop_for_uv_handle(handle.native_handle());\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n+            status_to_maybe_uv_error_with_loop(loop_, status)\n         }\n     }\n }"}, {"sha": "b6cffa754c1481e46f59602b7b742aa20875337d", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a901b166901601c6b132c2036882ad9754722f1c/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a901b166901601c6b132c2036882ad9754722f1c/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=a901b166901601c6b132c2036882ad9754722f1c", "patch": "@@ -617,7 +617,40 @@ pub unsafe fn ip6_port(addr: *sockaddr_in6) -> c_uint {\n     return rust_uv_ip6_port(addr);\n }\n \n+pub unsafe fn fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, flags: int, mode: int,\n+                cb: *u8) -> c_int {\n+    rust_uv_fs_open(loop_ptr, req, path, flags as c_int, mode as c_int, cb)\n+}\n+pub unsafe fn fs_close(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n+                cb: *u8) -> c_int {\n+    rust_uv_fs_close(loop_ptr, req, fd, cb)\n+}\n+pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n+    rust_uv_fs_req_cleanup(req);\n+}\n+\n // data access helpers\n+pub unsafe fn get_O_RDONLY() -> c_int {\n+    rust_uv_get_O_RDONLY()\n+}\n+pub unsafe fn get_O_WRONLY() -> c_int {\n+    rust_uv_get_O_WRONLY()\n+}\n+pub unsafe fn get_O_RDWR() -> c_int {\n+    rust_uv_get_O_RDWR()\n+}\n+pub unsafe fn get_O_CREAT() -> c_int {\n+    rust_uv_get_O_CREAT()\n+}\n+pub unsafe fn get_O_TRUNC() -> c_int {\n+    rust_uv_get_O_TRUNC()\n+}\n+pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n+    rust_uv_get_result_from_fs_req(req)\n+}\n+pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n+    rust_uv_get_loop_from_fs_req(req)\n+}\n pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -784,6 +817,18 @@ extern {\n     fn rust_uv_timer_start(timer_handle: *uv_timer_t, cb: uv_timer_cb, timeout: libc::uint64_t,\n                            repeat: libc::uint64_t) -> c_int;\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n+    fn rust_uv_fs_open(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                       flags: c_int, mode: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n+                        cb: *u8) -> c_int;\n+    fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n+    fn rust_uv_get_O_RDONLY() -> c_int;\n+    fn rust_uv_get_O_WRONLY() -> c_int;\n+    fn rust_uv_get_O_RDWR() -> c_int;\n+    fn rust_uv_get_O_CREAT() -> c_int;\n+    fn rust_uv_get_O_TRUNC() -> c_int;\n+    fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n+    fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n \n     fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n     fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;"}, {"sha": "0e9eefd3018c75f2d52230deefe960d9c90555d6", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a901b166901601c6b132c2036882ad9754722f1c/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/a901b166901601c6b132c2036882ad9754722f1c/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=a901b166901601c6b132c2036882ad9754722f1c", "patch": "@@ -108,6 +108,16 @@ rust_uv_idle_delete\n rust_uv_idle_init\n rust_uv_idle_start\n rust_uv_idle_stop\n+rust_uv_fs_open\n+rust_uv_fs_close\n+rust_uv_get_O_RDONLY\n+rust_uv_get_O_WRONLY\n+rust_uv_get_O_RDWR\n+rust_uv_get_O_CREAT\n+rust_uv_get_O_TRUNC\n+rust_uv_get_result_from_fs_req\n+rust_uv_get_loop_from_fs_req\n+rust_uv_fs_req_cleanup\n rust_dbg_lock_create\n rust_dbg_lock_destroy\n rust_dbg_lock_lock"}]}