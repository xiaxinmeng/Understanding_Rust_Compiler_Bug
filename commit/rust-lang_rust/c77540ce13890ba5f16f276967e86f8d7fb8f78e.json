{"sha": "c77540ce13890ba5f16f276967e86f8d7fb8f78e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NzU0MGNlMTM4OTBiYTVmMTZmMjc2OTY3ZTg2ZjhkN2ZiOGY3OGU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-27T10:53:39Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-27T21:32:15Z"}, "message": "deallocate thread-local statics when the thread dies", "tree": {"sha": "527b12bd5e532e3b6bc987aa3d5396825792d009", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/527b12bd5e532e3b6bc987aa3d5396825792d009"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c77540ce13890ba5f16f276967e86f8d7fb8f78e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c77540ce13890ba5f16f276967e86f8d7fb8f78e", "html_url": "https://github.com/rust-lang/rust/commit/c77540ce13890ba5f16f276967e86f8d7fb8f78e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c77540ce13890ba5f16f276967e86f8d7fb8f78e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a42f8e93c3be903cbfd940cbee3299506e184c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a42f8e93c3be903cbfd940cbee3299506e184c7", "html_url": "https://github.com/rust-lang/rust/commit/2a42f8e93c3be903cbfd940cbee3299506e184c7"}], "stats": {"total": 95, "additions": 63, "deletions": 32}, "files": [{"sha": "5dfe99627437df5da938d6e9e5971a082bb6c075", "filename": "src/machine.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=c77540ce13890ba5f16f276967e86f8d7fb8f78e", "patch": "@@ -64,7 +64,10 @@ pub enum MiriMemoryKind {\n     Global,\n     /// Memory for extern statics.\n     /// This memory may leak.\n-    ExternGlobal,\n+    ExternStatic,\n+    /// Memory for thread-local statics.\n+    /// This memory may leak.\n+    Tls,\n }\n \n impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n@@ -80,7 +83,7 @@ impl MayLeak for MiriMemoryKind {\n         use self::MiriMemoryKind::*;\n         match self {\n             Rust | C | WinHeap | Env => false,\n-            Machine | Global | ExternGlobal => true,\n+            Machine | Global | ExternStatic | Tls => true,\n         }\n     }\n }\n@@ -94,8 +97,9 @@ impl fmt::Display for MiriMemoryKind {\n             WinHeap => write!(f, \"Windows heap\"),\n             Machine => write!(f, \"machine-managed memory\"),\n             Env => write!(f, \"environment variable\"),\n-            Global => write!(f, \"global\"),\n-            ExternGlobal => write!(f, \"extern global\"),\n+            Global => write!(f, \"global (static or const)\"),\n+            ExternStatic => write!(f, \"extern static\"),\n+            Tls =>  write!(f, \"thread-local static\"),\n         }\n     }\n }\n@@ -175,7 +179,7 @@ impl MemoryExtra {\n                 // \"__cxa_thread_atexit_impl\"\n                 // This should be all-zero, pointer-sized.\n                 let layout = this.machine.layouts.usize;\n-                let place = this.allocate(layout, MiriMemoryKind::ExternGlobal.into());\n+                let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into());\n                 this.write_scalar(Scalar::from_machine_usize(0, this), place.into())?;\n                 Self::add_extern_static(this, \"__cxa_thread_atexit_impl\", place.ptr);\n                 // \"environ\"\n@@ -185,7 +189,7 @@ impl MemoryExtra {\n                 // \"_tls_used\"\n                 // This is some obscure hack that is part of the Windows TLS story. It's a `u8`.\n                 let layout = this.machine.layouts.u8;\n-                let place = this.allocate(layout, MiriMemoryKind::ExternGlobal.into());\n+                let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into());\n                 this.write_scalar(Scalar::from_u8(0), place.into())?;\n                 Self::add_extern_static(this, \"_tls_used\", place.ptr);\n             }"}, {"sha": "d7474dbf87efc9ba885964ca43adf4d4eb2f87ae", "filename": "src/shims/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=c77540ce13890ba5f16f276967e86f8d7fb8f78e", "patch": "@@ -383,9 +383,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.memory.deallocate(this.force_ptr(old_vars_ptr)?, None, MiriMemoryKind::Env.into())?;\n         } else {\n             // No `environ` allocated yet, let's do that.\n-            // This is memory backing an extern static, hence `ExternGlobal`, not `Env`.\n+            // This is memory backing an extern static, hence `ExternStatic`, not `Env`.\n             let layout = this.machine.layouts.usize;\n-            let place = this.allocate(layout, MiriMemoryKind::ExternGlobal.into());\n+            let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into());\n             this.machine.env_vars.environ = Some(place);\n         }\n "}, {"sha": "d929459740072472de962944707e8d8340652e26", "filename": "src/shims/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=c77540ce13890ba5f16f276967e86f8d7fb8f78e", "patch": "@@ -364,7 +364,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // All dtors done!\n         this.machine.tls.delete_all_thread_tls(active_thread);\n-        this.thread_terminated();\n+        this.thread_terminated()?;\n \n         Ok(())\n     }"}, {"sha": "cefe334574b44206f274d84b763cca88220120ea", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=c77540ce13890ba5f16f276967e86f8d7fb8f78e", "patch": "@@ -469,10 +469,10 @@ impl Stacks {\n             // `Global` memory can be referenced by global pointers from `tcx`.\n             // Thus we call `global_base_ptr` such that the global pointers get the same tag\n             // as what we use here.\n-            // `ExternGlobal` is used for extern statics, and thus must also be listed here.\n+            // `ExternStatic` is used for extern statics, and thus must also be listed here.\n             // `Env` we list because we can get away with precise tracking there.\n             // The base pointer is not unique, so the base permission is `SharedReadWrite`.\n-            MemoryKind::Machine(MiriMemoryKind::Global | MiriMemoryKind::ExternGlobal | MiriMemoryKind::Env) =>\n+            MemoryKind::Machine(MiriMemoryKind::Global | MiriMemoryKind::ExternStatic | MiriMemoryKind::Tls | MiriMemoryKind::Env) =>\n                 (extra.borrow_mut().global_base_ptr(id), Permission::SharedReadWrite),\n             // Everything else we handle entirely untagged for now.\n             // FIXME: experiment with more precise tracking."}, {"sha": "1e710a25edc995db76bb478f2a3b4826b540b25d", "filename": "src/thread.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77540ce13890ba5f16f276967e86f8d7fb8f78e/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=c77540ce13890ba5f16f276967e86f8d7fb8f78e", "patch": "@@ -410,18 +410,31 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         None\n     }\n \n-    /// Handles thread termination of the active thread: wakes up threads joining on this one,\n-    /// and deallocated thread-local statics.\n-    ///\n-    /// This is called from `tls.rs` after handling the TLS dtors.\n-    fn thread_terminated(&mut self) {\n+    /// Wakes up threads joining on the active one and deallocates thread-local statics.\n+    /// The `AllocId` that can now be freed is returned.\n+    fn thread_terminated(&mut self) -> Vec<AllocId> {\n+        let mut free_tls_statics = Vec::new();\n+        {\n+            let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();\n+            thread_local_statics.retain(|&(_def_id, thread), &mut alloc_id| {\n+                if thread != self.active_thread {\n+                    // Keep this static around.\n+                    return true;\n+                }\n+                // Delete this static from the map and from memory.\n+                // We cannot free directly here as we cannot use `?` in this context.\n+                free_tls_statics.push(alloc_id);\n+                return false;\n+            });\n+        }\n+        // Check if we need to unblock any threads.\n         for (i, thread) in self.threads.iter_enumerated_mut() {\n-            // Check if we need to unblock any threads.\n             if thread.state == ThreadState::BlockedOnJoin(self.active_thread) {\n                 trace!(\"unblocking {:?} because {:?} terminated\", i, self.active_thread);\n                 thread.state = ThreadState::Enabled;\n             }\n         }\n+        return free_tls_statics;\n     }\n \n     /// Decide which action to take next and on which thread.\n@@ -503,8 +516,8 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// Get a thread-specific allocation id for the given thread-local static.\n     /// If needed, allocate a new one.\n-    fn get_or_create_thread_local_alloc_id(&self, def_id: DefId) -> InterpResult<'tcx, AllocId> {\n-        let this = self.eval_context_ref();\n+    fn get_or_create_thread_local_alloc_id(&mut self, def_id: DefId) -> InterpResult<'tcx, AllocId> {\n+        let this = self.eval_context_mut();\n         let tcx = this.tcx;\n         if let Some(new_alloc_id) = this.machine.threads.get_thread_local_alloc_id(def_id) {\n             // We already have a thread-specific allocation id for this\n@@ -513,21 +526,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         } else {\n             // We need to allocate a thread-specific allocation id for this\n             // thread-local static.\n-            //\n-            // At first, we compute the initial value for this static.\n-            // Then we store the retrieved allocation back into the `alloc_map`\n-            // to get a fresh allocation id, which we can use as a\n-            // thread-specific allocation id for the thread-local static.\n-            // On first access to that allocation, it will be copied over to the machine memory.\n+            // First, we compute the initial value for this static.\n             if tcx.is_foreign_item(def_id) {\n                 throw_unsup_format!(\"foreign thread-local statics are not supported\");\n             }\n             let allocation = interpret::get_static(*tcx, def_id)?;\n-            // Create a new allocation id for the same allocation in this hacky\n-            // way. Internally, `alloc_map` deduplicates allocations, but this\n-            // is fine because Miri will make a copy before a first mutable\n-            // access.\n-            let new_alloc_id = tcx.create_memory_alloc(allocation);\n+            // Create a fresh allocation with this content.\n+            let new_alloc_id = this.memory.allocate_with(allocation.clone(), MiriMemoryKind::Tls.into()).alloc_id;\n             this.machine.threads.set_thread_local_alloc_id(def_id, new_alloc_id);\n             Ok(new_alloc_id)\n         }\n@@ -668,8 +673,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.schedule()\n     }\n \n+    /// Handles thread termination of the active thread: wakes up threads joining on this one,\n+    /// and deallocated thread-local statics.\n+    ///\n+    /// This is called from `tls.rs` after handling the TLS dtors.\n     #[inline]\n-    fn thread_terminated(&mut self) {\n-        self.eval_context_mut().machine.threads.thread_terminated()\n+    fn thread_terminated(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        for alloc_id in this.machine.threads.thread_terminated() {\n+            let ptr = this.memory.global_base_pointer(alloc_id.into())?;\n+            this.memory.deallocate(ptr, None, MiriMemoryKind::Tls.into())?;\n+        }\n+        Ok(())\n     }\n }"}, {"sha": "1b20ce8bfb3804de6c01e2d069e6473552b06f86", "filename": "tests/compile-fail/concurrency/thread_local_static_dealloc.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c77540ce13890ba5f16f276967e86f8d7fb8f78e/tests%2Fcompile-fail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77540ce13890ba5f16f276967e86f8d7fb8f78e/tests%2Fcompile-fail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Fthread_local_static_dealloc.rs?ref=c77540ce13890ba5f16f276967e86f8d7fb8f78e", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+//! Ensure that thread-local statics get deallocated when the thread dies.\n+\n+#![feature(thread_local)]\n+\n+#[thread_local]\n+static mut TLS: u8 = 0;\n+\n+fn main() { unsafe {\n+    let dangling_ptr = std::thread::spawn(|| &TLS as *const u8 as usize).join().unwrap();\n+    let _val = *(dangling_ptr as *const u8);\n+} }"}]}