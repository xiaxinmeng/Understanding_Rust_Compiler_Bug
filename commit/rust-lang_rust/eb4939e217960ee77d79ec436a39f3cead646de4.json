{"sha": "eb4939e217960ee77d79ec436a39f3cead646de4", "node_id": "C_kwDOAAsO6NoAKGViNDkzOWUyMTc5NjBlZTc3ZDc5ZWM0MzZhMzlmM2NlYWQ2NDZkZTQ", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-17T10:32:55Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-17T10:32:55Z"}, "message": "Support overloaded deref MIR lowering", "tree": {"sha": "72253f0fbc607185a676b03dbf72118f9a3a33f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72253f0fbc607185a676b03dbf72118f9a3a33f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb4939e217960ee77d79ec436a39f3cead646de4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4939e217960ee77d79ec436a39f3cead646de4", "html_url": "https://github.com/rust-lang/rust/commit/eb4939e217960ee77d79ec436a39f3cead646de4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb4939e217960ee77d79ec436a39f3cead646de4/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9564773d5e6dff6d430594028383315ca2e202ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/9564773d5e6dff6d430594028383315ca2e202ef", "html_url": "https://github.com/rust-lang/rust/commit/9564773d5e6dff6d430594028383315ca2e202ef"}], "stats": {"total": 484, "additions": 398, "deletions": 86}, "files": [{"sha": "448821d3844ab29a361c12551e34e0880f9ac644", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -609,21 +609,12 @@ impl ExprCollector<'_> {\n     fn collect_try_operator(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::TryExpr) -> ExprId {\n         let (try_branch, cf_continue, cf_break, try_from_residual) = 'if_chain: {\n             if let Some(try_branch) = LangItem::TryTraitBranch.path(self.db, self.krate) {\n-                if let Some(cf_continue) =\n-                    LangItem::ControlFlowContinue.path(self.db, self.krate)\n-                {\n-                    if let Some(cf_break) =\n-                        LangItem::ControlFlowBreak.path(self.db, self.krate)\n-                    {\n+                if let Some(cf_continue) = LangItem::ControlFlowContinue.path(self.db, self.krate) {\n+                    if let Some(cf_break) = LangItem::ControlFlowBreak.path(self.db, self.krate) {\n                         if let Some(try_from_residual) =\n                             LangItem::TryTraitFromResidual.path(self.db, self.krate)\n                         {\n-                            break 'if_chain (\n-                                try_branch,\n-                                cf_continue,\n-                                cf_break,\n-                                try_from_residual,\n-                            );\n+                            break 'if_chain (try_branch, cf_continue, cf_break, try_from_residual);\n                         }\n                     }\n                 }\n@@ -634,15 +625,10 @@ impl ExprCollector<'_> {\n         let operand = self.collect_expr_opt(e.expr());\n         let try_branch = self.alloc_expr(Expr::Path(try_branch), syntax_ptr.clone());\n         let expr = self.alloc_expr(\n-            Expr::Call {\n-                callee: try_branch,\n-                args: Box::new([operand]),\n-                is_assignee_expr: false,\n-            },\n+            Expr::Call { callee: try_branch, args: Box::new([operand]), is_assignee_expr: false },\n             syntax_ptr.clone(),\n         );\n-        let continue_binding =\n-            self.alloc_binding(name![v1], BindingAnnotation::Unannotated);\n+        let continue_binding = self.alloc_binding(name![v1], BindingAnnotation::Unannotated);\n         let continue_bpat =\n             self.alloc_pat_desugared(Pat::Bind { id: continue_binding, subpat: None });\n         self.add_definition_to_binding(continue_binding, continue_bpat);\n@@ -656,8 +642,7 @@ impl ExprCollector<'_> {\n             expr: self.alloc_expr(Expr::Path(Path::from(name![v1])), syntax_ptr.clone()),\n         };\n         let break_binding = self.alloc_binding(name![v1], BindingAnnotation::Unannotated);\n-        let break_bpat =\n-            self.alloc_pat_desugared(Pat::Bind { id: break_binding, subpat: None });\n+        let break_bpat = self.alloc_pat_desugared(Pat::Bind { id: break_binding, subpat: None });\n         self.add_definition_to_binding(break_binding, break_bpat);\n         let break_arm = MatchArm {\n             pat: self.alloc_pat_desugared(Pat::TupleStruct {\n@@ -667,10 +652,8 @@ impl ExprCollector<'_> {\n             }),\n             guard: None,\n             expr: {\n-                let x =\n-                    self.alloc_expr(Expr::Path(Path::from(name![v1])), syntax_ptr.clone());\n-                let callee =\n-                    self.alloc_expr(Expr::Path(try_from_residual), syntax_ptr.clone());\n+                let x = self.alloc_expr(Expr::Path(Path::from(name![v1])), syntax_ptr.clone());\n+                let callee = self.alloc_expr(Expr::Path(try_from_residual), syntax_ptr.clone());\n                 let result = self.alloc_expr(\n                     Expr::Call { callee, args: Box::new([x]), is_assignee_expr: false },\n                     syntax_ptr.clone(),\n@@ -1030,8 +1013,9 @@ impl ExprCollector<'_> {\n                         .collect(),\n                 }\n             }\n-            ast::Pat::LiteralPat(lit) => 'b: {\n-                if let Some(ast_lit) = lit.literal() {\n+            // FIXME: rustfmt removes this label if it is a block and not a loop\n+            ast::Pat::LiteralPat(lit) => 'b: loop {\n+                break if let Some(ast_lit) = lit.literal() {\n                     let mut hir_lit: Literal = ast_lit.kind().into();\n                     if lit.minus_token().is_some() {\n                         let Some(h) = hir_lit.negate() else {\n@@ -1045,8 +1029,8 @@ impl ExprCollector<'_> {\n                     Pat::Lit(expr_id)\n                 } else {\n                     Pat::Missing\n-                }\n-            }\n+                };\n+            },\n             ast::Pat::RestPat(_) => {\n                 // `RestPat` requires special handling and should not be mapped\n                 // to a Pat. Here we are using `Pat::Missing` as a fallback for"}, {"sha": "a658bfa0c9a835fdc78abb1dfbff7a387a5cfbbf", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -166,8 +166,7 @@ fn reference_autoderef() {\n \n #[test]\n fn overloaded_deref() {\n-    // FIXME: We should support this.\n-    check_fail(\n+    check_number(\n         r#\"\n     //- minicore: deref_mut\n     struct Foo;\n@@ -185,9 +184,7 @@ fn overloaded_deref() {\n         *y + *x\n     };\n     \"#,\n-        ConstEvalError::MirLowerError(MirLowerError::NotSupported(\n-            \"explicit overloaded deref\".into(),\n-        )),\n+        10,\n     );\n }\n \n@@ -698,7 +695,7 @@ fn pattern_matching_literal() {\n     }\n     const GOAL: i32 = f(-1) + f(1) + f(0) + f(-5);\n         \"#,\n-        211\n+        211,\n     );\n     check_number(\n         r#\"\n@@ -711,7 +708,7 @@ fn pattern_matching_literal() {\n     }\n     const GOAL: u8 = f(\"foo\") + f(\"bar\");\n         \"#,\n-        11\n+        11,\n     );\n }\n \n@@ -1116,6 +1113,22 @@ fn function_traits() {\n         \"#,\n         15,\n     );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: &dyn Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_mut(f: &mut dyn FnMut(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = call(&add2, 3) + call_mut(&mut add2, 3);\n+        \"#,\n+        10,\n+    );\n     check_number(\n         r#\"\n     //- minicore: fn"}, {"sha": "d1b9aff36d2422f9ff6e545ecc99757554fb3687", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -57,6 +57,7 @@ mod expr;\n mod pat;\n mod coerce;\n mod closure;\n+mod mutability;\n \n /// The entry point of type inference.\n pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n@@ -99,6 +100,8 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n \n     ctx.infer_body();\n \n+    ctx.infer_mut_body();\n+\n     Arc::new(ctx.resolve_all())\n }\n "}, {"sha": "82119c97ec21510531ca7e9971b7471aefea2b7a", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -390,14 +390,28 @@ impl<'a> InferenceContext<'a> {\n                         if let Some(fn_x) = func {\n                             match fn_x {\n                                 FnTrait::FnOnce => (),\n-                                FnTrait::FnMut => adjustments.push(Adjustment::borrow(\n-                                    Mutability::Mut,\n-                                    derefed_callee.clone(),\n-                                )),\n-                                FnTrait::Fn => adjustments.push(Adjustment::borrow(\n-                                    Mutability::Not,\n-                                    derefed_callee.clone(),\n-                                )),\n+                                FnTrait::FnMut => {\n+                                    if !matches!(\n+                                        derefed_callee.kind(Interner),\n+                                        TyKind::Ref(Mutability::Mut, _, _)\n+                                    ) {\n+                                        adjustments.push(Adjustment::borrow(\n+                                            Mutability::Mut,\n+                                            derefed_callee.clone(),\n+                                        ));\n+                                    }\n+                                }\n+                                FnTrait::Fn => {\n+                                    if !matches!(\n+                                        derefed_callee.kind(Interner),\n+                                        TyKind::Ref(Mutability::Not, _, _)\n+                                    ) {\n+                                        adjustments.push(Adjustment::borrow(\n+                                            Mutability::Not,\n+                                            derefed_callee.clone(),\n+                                        ));\n+                                    }\n+                                }\n                             }\n                             let trait_ = fn_x\n                                 .get_id(self.db, self.trait_env.krate)\n@@ -673,6 +687,23 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME: Note down method resolution her\n                 match op {\n                     UnaryOp::Deref => {\n+                        if let Some(deref_trait) = self\n+                            .db\n+                            .lang_item(self.table.trait_env.krate, LangItem::Deref)\n+                            .and_then(|l| l.as_trait())\n+                        {\n+                            if let Some(deref_fn) =\n+                                self.db.trait_data(deref_trait).method_by_name(&name![deref])\n+                            {\n+                                // FIXME: this is wrong in multiple ways, subst is empty, and we emit it even for builtin deref (note that\n+                                // the mutability is not wrong, and will be fixed in `self.infer_mut`).\n+                                self.write_method_resolution(\n+                                    tgt_expr,\n+                                    deref_fn,\n+                                    Substitution::empty(Interner),\n+                                );\n+                            }\n+                        }\n                         autoderef::deref(&mut self.table, inner_ty).unwrap_or_else(|| self.err_ty())\n                     }\n                     UnaryOp::Neg => {"}, {"sha": "8e3d71788f2f0ec4a9395bfb04a096801fe79ece", "filename": "crates/hir-ty/src/infer/mutability.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -0,0 +1,182 @@\n+//! Finds if an expression is an immutable context or a mutable context, which is used in selecting\n+//! between `Deref` and `DerefMut` or `Index` and `IndexMut` or similar.\n+\n+use chalk_ir::Mutability;\n+use hir_def::{\n+    expr::{Array, BindingAnnotation, Expr, ExprId, PatId, Statement, UnaryOp},\n+    lang_item::LangItem,\n+};\n+use hir_expand::name;\n+\n+use crate::{lower::lower_to_chalk_mutability, Adjust, AutoBorrow, OverloadedDeref};\n+\n+use super::InferenceContext;\n+\n+impl<'a> InferenceContext<'a> {\n+    pub(crate) fn infer_mut_body(&mut self) {\n+        self.infer_mut_expr(self.body.body_expr, Mutability::Not);\n+    }\n+\n+    fn infer_mut_expr(&mut self, tgt_expr: ExprId, mut mutability: Mutability) {\n+        let mut v = vec![];\n+        let adjustments = self.result.expr_adjustments.get_mut(&tgt_expr).unwrap_or(&mut v);\n+        for adj in adjustments.iter_mut().rev() {\n+            match &mut adj.kind {\n+                Adjust::NeverToAny | Adjust::Deref(None) | Adjust::Pointer(_) => (),\n+                Adjust::Deref(Some(d)) => *d = OverloadedDeref(Some(mutability)),\n+                Adjust::Borrow(b) => match b {\n+                    AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m) => mutability = *m,\n+                },\n+            }\n+        }\n+        self.infer_mut_expr_without_adjust(tgt_expr, mutability);\n+    }\n+\n+    fn infer_mut_expr_without_adjust(&mut self, tgt_expr: ExprId, mutability: Mutability) {\n+        match &self.body[tgt_expr] {\n+            Expr::Missing => (),\n+            &Expr::If { condition, then_branch, else_branch } => {\n+                self.infer_mut_expr(condition, Mutability::Not);\n+                self.infer_mut_expr(then_branch, Mutability::Not);\n+                if let Some(else_branch) = else_branch {\n+                    self.infer_mut_expr(else_branch, Mutability::Not);\n+                }\n+            }\n+            Expr::Let { pat, expr } => self.infer_mut_expr(*expr, self.pat_bound_mutability(*pat)),\n+            Expr::Block { id: _, statements, tail, label: _ }\n+            | Expr::TryBlock { id: _, statements, tail }\n+            | Expr::Async { id: _, statements, tail }\n+            | Expr::Const { id: _, statements, tail }\n+            | Expr::Unsafe { id: _, statements, tail } => {\n+                for st in statements.iter() {\n+                    match st {\n+                        Statement::Let { pat, type_ref: _, initializer, else_branch } => {\n+                            if let Some(i) = initializer {\n+                                self.infer_mut_expr(*i, self.pat_bound_mutability(*pat));\n+                            }\n+                            if let Some(e) = else_branch {\n+                                self.infer_mut_expr(*e, Mutability::Not);\n+                            }\n+                        }\n+                        Statement::Expr { expr, has_semi: _ } => {\n+                            self.infer_mut_expr(*expr, Mutability::Not);\n+                        }\n+                    }\n+                }\n+                if let Some(tail) = tail {\n+                    self.infer_mut_expr(*tail, Mutability::Not);\n+                }\n+            }\n+            &Expr::For { iterable: c, pat: _, body, label: _ }\n+            | &Expr::While { condition: c, body, label: _ } => {\n+                self.infer_mut_expr(c, Mutability::Not);\n+                self.infer_mut_expr(body, Mutability::Not);\n+            }\n+            Expr::MethodCall { receiver: x, method_name: _, args, generic_args: _ }\n+            | Expr::Call { callee: x, args, is_assignee_expr: _ } => {\n+                self.infer_mut_not_expr_iter(args.iter().copied().chain(Some(*x)));\n+            }\n+            Expr::Match { expr, arms } => {\n+                let m = self.pat_iter_bound_mutability(arms.iter().map(|x| x.pat));\n+                self.infer_mut_expr(*expr, m);\n+                for arm in arms.iter() {\n+                    self.infer_mut_expr(arm.expr, Mutability::Not);\n+                }\n+            }\n+            Expr::Yield { expr }\n+            | Expr::Yeet { expr }\n+            | Expr::Return { expr }\n+            | Expr::Break { expr, label: _ } => {\n+                if let &Some(expr) = expr {\n+                    self.infer_mut_expr(expr, Mutability::Not);\n+                }\n+            }\n+            Expr::RecordLit { path: _, fields, spread, ellipsis: _, is_assignee_expr: _ } => {\n+                self.infer_mut_not_expr_iter(fields.iter().map(|x| x.expr).chain(*spread))\n+            }\n+            &Expr::Index { base, index } => {\n+                self.infer_mut_expr(base, mutability);\n+                self.infer_mut_expr(index, Mutability::Not);\n+            }\n+            Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n+                if let Some((f, _)) = self.result.method_resolutions.get_mut(&tgt_expr) {\n+                    if mutability == Mutability::Mut {\n+                        if let Some(deref_trait) = self\n+                            .db\n+                            .lang_item(self.table.trait_env.krate, LangItem::DerefMut)\n+                            .and_then(|l| l.as_trait())\n+                        {\n+                            if let Some(deref_fn) =\n+                                self.db.trait_data(deref_trait).method_by_name(&name![deref_mut])\n+                            {\n+                                *f = deref_fn;\n+                            }\n+                        }\n+                    }\n+                }\n+                self.infer_mut_expr(*expr, mutability);\n+            }\n+            Expr::Field { expr, name: _ } => {\n+                self.infer_mut_expr(*expr, mutability);\n+            }\n+            Expr::UnaryOp { expr, op: _ }\n+            | Expr::Range { lhs: Some(expr), rhs: None, range_type: _ }\n+            | Expr::Range { rhs: Some(expr), lhs: None, range_type: _ }\n+            | Expr::Await { expr }\n+            | Expr::Box { expr }\n+            | Expr::Loop { body: expr, label: _ }\n+            | Expr::Cast { expr, type_ref: _ } => {\n+                self.infer_mut_expr(*expr, Mutability::Not);\n+            }\n+            Expr::Ref { expr, rawness: _, mutability } => {\n+                let mutability = lower_to_chalk_mutability(*mutability);\n+                self.infer_mut_expr(*expr, mutability);\n+            }\n+            Expr::Array(Array::Repeat { initializer: lhs, repeat: rhs })\n+            | Expr::BinaryOp { lhs, rhs, op: _ }\n+            | Expr::Range { lhs: Some(lhs), rhs: Some(rhs), range_type: _ } => {\n+                self.infer_mut_expr(*lhs, Mutability::Not);\n+                self.infer_mut_expr(*rhs, Mutability::Not);\n+            }\n+            // not implemented\n+            Expr::Closure { .. } => (),\n+            Expr::Tuple { exprs, is_assignee_expr: _ }\n+            | Expr::Array(Array::ElementList { elements: exprs, is_assignee_expr: _ }) => {\n+                self.infer_mut_not_expr_iter(exprs.iter().copied());\n+            }\n+            // These don't need any action, as they don't have sub expressions\n+            Expr::Range { lhs: None, rhs: None, range_type: _ }\n+            | Expr::Literal(_)\n+            | Expr::Path(_)\n+            | Expr::Continue { .. }\n+            | Expr::Underscore => (),\n+        }\n+    }\n+\n+    fn infer_mut_not_expr_iter(&mut self, exprs: impl Iterator<Item = ExprId>) {\n+        for expr in exprs {\n+            self.infer_mut_expr(expr, Mutability::Not);\n+        }\n+    }\n+\n+    fn pat_iter_bound_mutability(&self, mut pat: impl Iterator<Item = PatId>) -> Mutability {\n+        if pat.any(|p| self.pat_bound_mutability(p) == Mutability::Mut) {\n+            Mutability::Mut\n+        } else {\n+            Mutability::Not\n+        }\n+    }\n+\n+    /// Checks if the pat contains a `ref mut` binding. Such paths makes the context of bounded expressions\n+    /// mutable. For example in `let (ref mut x0, ref x1) = *x;` we need to use `DerefMut` for `*x` but in\n+    /// `let (ref x0, ref x1) = *x;` we should use `Deref`.\n+    fn pat_bound_mutability(&self, pat: PatId) -> Mutability {\n+        let mut r = Mutability::Not;\n+        self.body.walk_bindings_in_pat(pat, |b| {\n+            if self.body.bindings[b].mode == BindingAnnotation::RefMut {\n+                r = Mutability::Mut;\n+            }\n+        });\n+        r\n+    }\n+}"}, {"sha": "f8545e88ad5485d770df8f5130bf10a5e062588e", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -1,6 +1,6 @@\n //! This module provides a MIR interpreter, which is used in const eval.\n \n-use std::{borrow::Cow, collections::HashMap, iter, sync::Arc};\n+use std::{borrow::Cow, collections::HashMap, iter, ops::Range, sync::Arc};\n \n use base_db::CrateId;\n use chalk_ir::{\n@@ -109,6 +109,10 @@ impl Interval {\n     fn get<'a>(&self, memory: &'a Evaluator<'a>) -> Result<&'a [u8]> {\n         memory.read_memory(self.addr, self.size)\n     }\n+\n+    fn slice(self, range: Range<usize>) -> Interval {\n+        Interval { addr: self.addr.offset(range.start), size: range.len() }\n+    }\n }\n \n enum IntervalOrOwned {\n@@ -423,7 +427,6 @@ impl Evaluator<'_> {\n         args: impl Iterator<Item = Vec<u8>>,\n         subst: Substitution,\n     ) -> Result<Vec<u8>> {\n-        dbg!(body.dbg(self.db));\n         if let Some(x) = self.stack_depth_limit.checked_sub(1) {\n             self.stack_depth_limit = x;\n         } else {\n@@ -1360,24 +1363,24 @@ impl Evaluator<'_> {\n         locals: &Locals<'_>,\n     ) -> Result<()> {\n         let func = args.get(0).ok_or(MirEvalError::TypeError(\"fn trait with no arg\"))?;\n-        let ref_func_ty = self.operand_ty(func, locals)?;\n-        let func_ty = match ft {\n-            FnTrait::FnOnce => ref_func_ty,\n-            FnTrait::FnMut | FnTrait::Fn => match ref_func_ty.as_reference() {\n-                Some(x) => x.0.clone(),\n-                None => return Err(MirEvalError::TypeError(\"fn trait with non-reference arg\")),\n-            },\n-        };\n+        let mut func_ty = self.operand_ty(func, locals)?;\n+        let mut func_data = self.eval_operand(func, locals)?;\n+        while let TyKind::Ref(_, _, z) = func_ty.kind(Interner) {\n+            func_ty = z.clone();\n+            if matches!(func_ty.kind(Interner), TyKind::Dyn(_)) {\n+                let id =\n+                    from_bytes!(usize, &func_data.get(self)?[self.ptr_size()..self.ptr_size() * 2]);\n+                func_data = func_data.slice(0..self.ptr_size());\n+                func_ty = self.vtable_map.ty(id)?.clone();\n+            }\n+            let size = self.size_of_sized(&func_ty, locals, \"self type of fn trait\")?;\n+            func_data = Interval { addr: Address::from_bytes(func_data.get(self)?)?, size };\n+        }\n         match &func_ty.data(Interner).kind {\n             TyKind::FnDef(def, subst) => {\n                 self.exec_fn_def(*def, subst, destination, &args[1..], locals)?;\n             }\n             TyKind::Function(_) => {\n-                let mut func_data = self.eval_operand(func, locals)?;\n-                if let FnTrait::FnMut | FnTrait::Fn = ft {\n-                    let addr = Address::from_bytes(func_data.get(self)?)?;\n-                    func_data = Interval { addr, size: self.ptr_size() };\n-                }\n                 self.exec_fn_pointer(func_data, destination, &args[1..], locals)?;\n             }\n             x => not_supported!(\"Call {ft:?} trait methods with type {x:?}\"),"}, {"sha": "04175fb4d956940b20228947b0783152d619f09c", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -4,7 +4,7 @@ use std::{iter, mem, sync::Arc};\n \n use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n use hir_def::{\n-    adt::{VariantData, StructKind},\n+    adt::{StructKind, VariantData},\n     body::Body,\n     expr::{\n         Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,"}, {"sha": "c6f4f66ada0e30ac3a8470a958408bbfd94e090e", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -145,10 +145,32 @@ impl MirLowerCtx<'_> {\n                         self.expr_ty(*expr).kind(Interner),\n                         TyKind::Ref(..) | TyKind::Raw(..)\n                     ) {\n-                        let Some(_) = self.lower_expr_as_place(current, *expr, true)? else {\n+                        let Some((p, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n                             return Ok(None);\n                         };\n-                        not_supported!(\"explicit overloaded deref\");\n+                        return self.lower_overloaded_deref(\n+                            current,\n+                            p,\n+                            self.expr_ty_after_adjustments(*expr),\n+                            self.expr_ty(expr_id),\n+                            expr_id.into(),\n+                            'b: {\n+                                if let Some((f, _)) = self.infer.method_resolution(expr_id) {\n+                                    if let Some(deref_trait) =\n+                                        self.resolve_lang_item(LangItem::DerefMut)?.as_trait()\n+                                    {\n+                                        if let Some(deref_fn) = self\n+                                            .db\n+                                            .trait_data(deref_trait)\n+                                            .method_by_name(&name![deref_mut])\n+                                        {\n+                                            break 'b deref_fn == f;\n+                                        }\n+                                    }\n+                                }\n+                                false\n+                            },\n+                        );\n                     }\n                     let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n                         return Ok(None);"}, {"sha": "9ec2913dce970560a970f16dcc2b205235dd853c", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -1,6 +1,6 @@\n //! A pretty-printer for MIR.\n \n-use std::fmt::{Display, Write, Debug};\n+use std::fmt::{Debug, Display, Write};\n \n use hir_def::{body::Body, expr::BindingId};\n use hir_expand::name::Name;\n@@ -24,7 +24,7 @@ impl MirBody {\n         ctx.result\n     }\n \n-    // String with lines is rendered poorly in `dbg!` macros, which I use very much, so this\n+    // String with lines is rendered poorly in `dbg` macros, which I use very much, so this\n     // function exists to solve that.\n     pub fn dbg(&self, db: &dyn HirDatabase) -> impl Debug {\n         struct StringDbg(String);"}, {"sha": "9f624cc32c0ce25dfa95372833205bf41d99b4d5", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -258,7 +258,6 @@ fn test() {\n \n #[test]\n fn coerce_autoderef_block() {\n-    // FIXME: We should know mutability in overloaded deref\n     check_no_mismatches(\n         r#\"\n //- minicore: deref\n@@ -268,7 +267,7 @@ fn takes_ref_str(x: &str) {}\n fn returns_string() -> String { loop {} }\n fn test() {\n     takes_ref_str(&{ returns_string() });\n-               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(None))), Borrow(Ref(Not))\n+               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(Some(Not)))), Borrow(Ref(Not))\n }\n \"#,\n     );"}, {"sha": "f3ca93672d9fccd6b0488bbc883a1cff4e857146", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -1255,7 +1255,6 @@ fn foo<T: Trait>(a: &T) {\n \n #[test]\n fn autoderef_visibility_field() {\n-    // FIXME: We should know mutability in overloaded deref\n     check(\n         r#\"\n //- minicore: deref\n@@ -1277,7 +1276,7 @@ mod a {\n mod b {\n     fn foo() {\n         let x = super::a::Bar::new().0;\n-             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(None)))\n+             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(Some(Not))))\n              // ^^^^^^^^^^^^^^^^^^^^^^ type: char\n     }\n }"}, {"sha": "83c61f73db637625ef80000edd642d949a502adb", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -566,30 +566,43 @@ fn f(x: [(i32, u8); 10]) {\n \n     #[test]\n     fn overloaded_deref() {\n-        // FIXME: check for false negative\n         check_diagnostics(\n             r#\"\n //- minicore: deref_mut\n use core::ops::{Deref, DerefMut};\n \n struct Foo;\n impl Deref for Foo {\n-    type Target = i32;\n-    fn deref(&self) -> &i32 {\n-        &5\n+    type Target = (i32, u8);\n+    fn deref(&self) -> &(i32, u8) {\n+        &(5, 2)\n     }\n }\n impl DerefMut for Foo {\n-    fn deref_mut(&mut self) -> &mut i32 {\n-        &mut 5\n+    fn deref_mut(&mut self) -> &mut (i32, u8) {\n+        &mut (5, 2)\n     }\n }\n fn f() {\n-    let x = Foo;\n+    let mut x = Foo;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n     let y = &*x;\n     let x = Foo;\n-    let mut x = Foo;\n-    let y: &mut i32 = &mut x;\n+    let y = &mut *x;\n+               //^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let x = Foo;\n+    let x = Foo;\n+    let y: &mut (i32, u8) = &mut x;\n+                          //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let ref mut y = *x;\n+                  //^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let (ref mut y, _) = *x;\n+                       //^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    match *x {\n+        //^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        (ref y, _) => (),\n+        (_, ref mut y) => (),\n+    }\n }\n \"#,\n         );"}, {"sha": "11e6dc05fa106aa3b82014c270625df3fd4c1ddc", "filename": "crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -435,7 +435,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3415..3423,\n+                                        range: 5805..5813,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -448,7 +448,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3447..3451,\n+                                        range: 5837..5841,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -468,7 +468,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3415..3423,\n+                                        range: 5805..5813,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -481,7 +481,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3447..3451,\n+                                        range: 5837..5841,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -501,7 +501,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3415..3423,\n+                                        range: 5805..5813,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -514,7 +514,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3447..3451,\n+                                        range: 5837..5841,\n                                     },\n                                 ),\n                                 tooltip: \"\","}, {"sha": "5cc3bad04be188023941dad52578928374bbb34a", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -1126,5 +1126,5 @@ fn benchmark_syntax_highlighting_parser() {\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Function))\n             .count()\n     };\n-    assert_eq!(hash, 1608);\n+    assert_eq!(hash, 1170);\n }"}, {"sha": "1c15a606f957854b0ce41af2f9d610671a27f973", "filename": "crates/syntax/rust.ungram", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Frust.ungram?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -613,7 +613,7 @@ Pat =\n | ConstBlockPat\n \n LiteralPat =\n-  Literal\n+  '-'? Literal\n \n IdentPat =\n   Attr* 'ref'? 'mut'? Name ('@' Pat)?"}, {"sha": "0e84aca5c7d9ab68b31b3e8e4e33831c8188b1a9", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -1375,8 +1375,8 @@ pub struct LiteralPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl LiteralPat {\n-    pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n     pub fn minus_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![-]) }\n+    pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "77a8363a185c1ba8585de4959e5cbcc27edb1361", "filename": "crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -535,6 +535,7 @@ impl Field {\n                     \"!\" => \"excl\",\n                     \"*\" => \"star\",\n                     \"&\" => \"amp\",\n+                    \"-\" => \"minus\",\n                     \"_\" => \"underscore\",\n                     \".\" => \"dot\",\n                     \"..\" => \"dotdot\","}, {"sha": "118b9ad631bfa0248ef220dcacee30bacf9b3909", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4939e217960ee77d79ec436a39f3cead646de4/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=eb4939e217960ee77d79ec436a39f3cead646de4", "patch": "@@ -375,6 +375,68 @@ pub mod ops {\n             type Output;\n             extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n         }\n+\n+        mod impls {\n+            use crate::marker::Tuple;\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const Fn<A> for &F\n+            where\n+                F: ~const Fn<A>,\n+            {\n+                extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n+                    (**self).call(args)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const FnMut<A> for &F\n+            where\n+                F: ~const Fn<A>,\n+            {\n+                extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+                    (**self).call(args)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const FnOnce<A> for &F\n+            where\n+                F: ~const Fn<A>,\n+            {\n+                type Output = F::Output;\n+\n+                extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+                    (*self).call(args)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const FnMut<A> for &mut F\n+            where\n+                F: ~const FnMut<A>,\n+            {\n+                extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+                    (*self).call_mut(args)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const FnOnce<A> for &mut F\n+            where\n+                F: ~const FnMut<A>,\n+            {\n+                type Output = F::Output;\n+                extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+                    (*self).call_mut(args)\n+                }\n+            }\n+        }\n     }\n     pub use self::function::{Fn, FnMut, FnOnce};\n     // endregion:fn"}]}