{"sha": "b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NmNlMTc2YmJkMWZlNmQ1NGRjMDRiYTZlZWU1ZGNmOGVlYjcxNDI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-04-10T13:10:19Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-04-10T13:10:19Z"}, "message": "Fix op_ref in case of nonexisting operations", "tree": {"sha": "b28d6e25800acacc3104177c83717c18723beb80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b28d6e25800acacc3104177c83717c18723beb80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142", "html_url": "https://github.com/rust-lang/rust/commit/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0432f1efd31f8cd58faea180d8e44a786bc6fc4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0432f1efd31f8cd58faea180d8e44a786bc6fc4c", "html_url": "https://github.com/rust-lang/rust/commit/0432f1efd31f8cd58faea180d8e44a786bc6fc4c"}], "stats": {"total": 156, "additions": 112, "deletions": 44}, "files": [{"sha": "002725a4d6d90f312602eb276a25fb3dda2cbdaa", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 78, "deletions": 44, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use utils::{SpanlessEq, span_lint, span_lint_and_then, multispan_sugg, snippet};\n+use utils::{SpanlessEq, span_lint, span_lint_and_then, multispan_sugg, snippet, implements_trait};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for equal operands to comparison, logical and\n@@ -60,53 +60,87 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                             e.span,\n                             &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n                 } else {\n-                    match (&left.node, &right.node) {\n-                        (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n-                            span_lint_and_then(cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"taken reference of both operands, which is done automatically by the operator anyway\",\n-                                |db| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                    multispan_sugg(db,\n-                                                \"use the values directly\".to_string(),\n-                                                vec![(left.span, lsnip),\n-                                                     (right.span, rsnip)]);\n+                    let trait_id = match op.node {\n+                        BiAdd => cx.tcx.lang_items.add_trait(),\n+                        BiSub => cx.tcx.lang_items.sub_trait(),\n+                        BiMul => cx.tcx.lang_items.mul_trait(),\n+                        BiDiv => cx.tcx.lang_items.div_trait(),\n+                        BiRem => cx.tcx.lang_items.rem_trait(),\n+                        BiAnd => None,\n+                        BiOr => None,\n+                        BiBitXor => cx.tcx.lang_items.bitxor_trait(),\n+                        BiBitAnd => cx.tcx.lang_items.bitand_trait(),\n+                        BiBitOr => cx.tcx.lang_items.bitor_trait(),\n+                        BiShl => cx.tcx.lang_items.shl_trait(),\n+                        BiShr => cx.tcx.lang_items.shr_trait(),\n+                        BiNe |\n+                        BiEq => cx.tcx.lang_items.eq_trait(),\n+                        BiLt |\n+                        BiLe |\n+                        BiGe |\n+                        BiGt => cx.tcx.lang_items.ord_trait(),\n+                    };\n+                    if let Some(trait_id) = trait_id {\n+                        match (&left.node, &right.node) {\n+                            // do not suggest to dereference literals\n+                            (&ExprLit(..), _) |\n+                            (_, &ExprLit(..)) => {},\n+                            // &foo == &bar\n+                            (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n+                                if implements_trait(cx, cx.tables.expr_ty(l), trait_id, &[cx.tables.expr_ty(r)], None) {\n+                                    span_lint_and_then(cx,\n+                                        OP_REF,\n+                                        e.span,\n+                                        \"taken reference of both operands, which is done automatically by the operator anyway\",\n+                                        |db| {\n+                                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                            multispan_sugg(db,\n+                                                        \"use the values directly\".to_string(),\n+                                                        vec![(left.span, lsnip),\n+                                                            (right.span, rsnip)]);\n+                                        }\n+                                    )\n                                 }\n-                            )\n-                        }\n-                        (&ExprAddrOf(_, ref l), _) => {\n-                            span_lint_and_then(cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"taken reference of left operand\",\n-                                |db| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    let rsnip = Sugg::hir(cx, right, \"...\").deref().to_string();\n-                                    multispan_sugg(db,\n-                                                \"dereference the right operand instead\".to_string(),\n-                                                vec![(left.span, lsnip),\n-                                                     (right.span, rsnip)]);\n+                            }\n+                            // &foo == bar\n+                            (&ExprAddrOf(_, ref l), _) => {\n+                                if implements_trait(cx, cx.tables.expr_ty(l), trait_id, &[cx.tables.expr_ty(right)], None) {\n+                                    span_lint_and_then(cx,\n+                                        OP_REF,\n+                                        e.span,\n+                                        \"taken reference of left operand\",\n+                                        |db| {\n+                                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                            let rsnip = Sugg::hir(cx, right, \"...\").deref().to_string();\n+                                            multispan_sugg(db,\n+                                                        \"dereference the right operand instead\".to_string(),\n+                                                        vec![(left.span, lsnip),\n+                                                            (right.span, rsnip)]);\n+                                        }\n+                                    )\n                                 }\n-                            )\n-                        }\n-                        (_, &ExprAddrOf(_, ref r)) => {\n-                            span_lint_and_then(cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"taken reference of right operand\",\n-                                |db| {\n-                                    let lsnip = Sugg::hir(cx, left, \"...\").deref().to_string();\n-                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                    multispan_sugg(db,\n-                                                \"dereference the left operand instead\".to_string(),\n-                                                vec![(left.span, lsnip),\n-                                                     (right.span, rsnip)]);\n+                            }\n+                            // foo == &bar\n+                            (_, &ExprAddrOf(_, ref r)) => {\n+                                if implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[cx.tables.expr_ty(r)], None) {\n+                                    span_lint_and_then(cx,\n+                                        OP_REF,\n+                                        e.span,\n+                                        \"taken reference of right operand\",\n+                                        |db| {\n+                                            let lsnip = Sugg::hir(cx, left, \"...\").deref().to_string();\n+                                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                            multispan_sugg(db,\n+                                                        \"dereference the left operand instead\".to_string(),\n+                                                        vec![(left.span, lsnip),\n+                                                            (right.span, rsnip)]);\n+                                        }\n+                                    )\n                                 }\n-                            )\n+                            }\n+                            _ => {}\n                         }\n-                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "315e6535ef624def246e89a86fb08f7ee72c3035", "filename": "tests/ui/op_ref.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142/tests%2Fui%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142/tests%2Fui%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.rs?ref=b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142", "patch": "@@ -0,0 +1,24 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![allow(unused_variables, blacklisted_name)]\n+\n+use std::collections::HashSet;\n+\n+fn main() {\n+    let tracked_fds: HashSet<i32> = HashSet::new();\n+    let new_fds = HashSet::new();\n+    let unwanted = &tracked_fds - &new_fds;\n+    \n+    let foo = &5 - &6;\n+\n+    let bar = String::new();\n+    let bar = \"foo\" == &bar;\n+\n+    let a = \"a\".to_string();\n+    let b = \"a\";\n+\n+    if b < &a {\n+        println!(\"OK\");\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "6e6ca457e03ec54cd7b1a5a75bde6fd20dbd9188", "filename": "tests/ui/op_ref.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142/tests%2Fui%2Fop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142/tests%2Fui%2Fop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.stderr?ref=b76ce176bbd1fe6d54dc04ba6eee5dcf8eeb7142", "patch": "@@ -0,0 +1,10 @@\n+warning: taken reference of both operands, which is done automatically by the operator anyway\n+  --> $DIR/op_ref.rs:13:15\n+   |\n+13 |     let foo = &5 - &6;\n+   |               ^^^^^^^\n+   |\n+   = note: #[warn(op_ref)] on by default\n+help: use the values directly\n+   |     let foo = 5 - 6;\n+"}]}