{"sha": "340ac040f7603e169a3739c65956ed2213622be5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MGFjMDQwZjc2MDNlMTY5YTM3MzljNjU5NTZlZDIyMTM2MjJiZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-06T08:25:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-06T08:25:32Z"}, "message": "auto merge of #20610 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "0502e3fcb9ceaa41d36c707e95baf0d7740fc3fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0502e3fcb9ceaa41d36c707e95baf0d7740fc3fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/340ac040f7603e169a3739c65956ed2213622be5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/340ac040f7603e169a3739c65956ed2213622be5", "html_url": "https://github.com/rust-lang/rust/commit/340ac040f7603e169a3739c65956ed2213622be5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/340ac040f7603e169a3739c65956ed2213622be5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62", "html_url": "https://github.com/rust-lang/rust/commit/c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62"}, {"sha": "4b359e3aeeaf97a190c5a7ecff8815b7b5734ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b359e3aeeaf97a190c5a7ecff8815b7b5734ece", "html_url": "https://github.com/rust-lang/rust/commit/4b359e3aeeaf97a190c5a7ecff8815b7b5734ece"}], "stats": {"total": 12735, "additions": 7289, "deletions": 5446}, "files": [{"sha": "274598feada670d1a94c0347e2353ff74533f058", "filename": "mk/docs.mk", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -49,8 +49,10 @@ RUSTDOC_HTML_OPTS_NO_CSS = --html-before-content=doc/version_info.html \\\n RUSTDOC_HTML_OPTS = $(RUSTDOC_HTML_OPTS_NO_CSS) --markdown-css rust.css\n \n PANDOC_BASE_OPTS := --standalone --toc --number-sections\n-PANDOC_TEX_OPTS = $(PANDOC_BASE_OPTS) --include-before-body=doc/version.tex \\\n-\t--from=markdown --include-before-body=doc/footer.tex --to=latex\n+PANDOC_TEX_OPTS = $(PANDOC_BASE_OPTS) --from=markdown --to=latex \\\n+\t--include-before-body=doc/version.tex \\\n+\t--include-before-body=doc/footer.tex \\\n+\t--include-in-header=doc/uptack.tex\n PANDOC_EPUB_OPTS = $(PANDOC_BASE_OPTS) --to=epub\n \n # The rustdoc executable...\n@@ -155,6 +157,9 @@ doc/footer.tex: $(D)/footer.inc | doc/\n \t@$(call E, pandoc: $@)\n \t$(CFG_PANDOC) --from=html --to=latex $< --output=$@\n \n+doc/uptack.tex: $(D)/uptack.tex | doc/\n+\t$(Q)cp $< $@\n+\n # HTML (rustdoc)\n DOC_TARGETS += doc/not_found.html\n doc/not_found.html: $(D)/not_found.md $(HTML_DEPS) | doc/\n@@ -180,7 +185,7 @@ doc/$(1).epub: $$(D)/$(1).md | doc/\n \n # PDF (md =(pandoc)=> tex =(pdflatex)=> pdf)\n DOC_TARGETS += doc/$(1).tex\n-doc/$(1).tex: $$(D)/$(1).md doc/footer.tex doc/version.tex | doc/\n+doc/$(1).tex: $$(D)/$(1).md doc/uptack.tex doc/footer.tex doc/version.tex | doc/\n \t@$$(call E, pandoc: $$@)\n \t$$(CFG_PANDOC) $$(PANDOC_TEX_OPTS) $$< --output=$$@\n "}, {"sha": "a97e68af59b3808062dd5f8fa09b2ea0a1e6358c", "filename": "mk/main.mk", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,7 +13,7 @@\n ######################################################################\n \n # The version number\n-CFG_RELEASE_NUM=0.13.0\n+CFG_RELEASE_NUM=1.0.0\n \n # An optional number to put after the label, e.g. '2' -> '-beta2'\n CFG_BETA_CYCLE=\n@@ -29,14 +29,14 @@ endif\n ifeq ($(CFG_RELEASE_CHANNEL),beta)\n # The beta channel is temporarily called 'alpha'\n CFG_RELEASE=$(CFG_RELEASE_NUM)-alpha$(CFG_BETA_CYCLE)\n-# When building beta/nightly distributables just reuse the same \"beta\"\n-# name so when we upload we'll always override the previous\n-# nighly. This doesn't actually impact the version reported by rustc -\n-# it's just for file naming.\n-CFG_PACKAGE_VERS=alpha\n+CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-alpha$(CFG_BETA_CYCLE)\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),nightly)\n CFG_RELEASE=$(CFG_RELEASE_NUM)-nightly\n+# When building nightly distributables just reuse the same \"nightly\" name\n+# so when we upload we'll always override the previous nighly. This\n+# doesn't actually impact the version reported by rustc - it's just\n+# for file naming.\n CFG_PACKAGE_VERS=nightly\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),dev)"}, {"sha": "0ce31a335d8ab7d698804a6ed7efd31172d23a67", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -15,7 +15,14 @@\n \n extern crate test;\n extern crate getopts;\n-#[phase(plugin, link)] extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n \n extern crate regex;\n "}, {"sha": "a9a9e0858ec6b7cc387a5b48d2d09b8c5f166b24", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -17,7 +17,7 @@ Some examples that demonstrate different aspects of the language:\n * [sprocketnes], an NES emulator with no GC, using modern Rust conventions\n * The language's general-purpose [hash] function, SipHash-2-4. Bit twiddling, OO, macros\n * The standard library's [HashMap], a sendable hash map in an OO style\n-* The extra library's [json] module. Enums and pattern matching\n+* The standard library's [json] module. Enums and pattern matching\n \n [sprocketnes]: https://github.com/pcwalton/sprocketnes\n [hash]: https://github.com/rust-lang/rust/blob/master/src/libstd/hash/mod.rs"}, {"sha": "7ee1c1a7032a5c4fce6975e1c9d0e0201fe4dbe7", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -451,7 +451,7 @@ them.\n ~~~no_run\n extern crate libc;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::ptr;\n \n #[link(name = \"readline\")]\n@@ -460,11 +460,10 @@ extern {\n }\n \n fn main() {\n-    \"[my-awesome-shell] $\".with_c_str(|buf| {\n-        unsafe { rl_prompt = buf; }\n-        // get a line, process it\n-        unsafe { rl_prompt = ptr::null(); }\n-    });\n+    let prompt = CString::from_slice(b\"[my-awesome-shell] $\");\n+    unsafe { rl_prompt = prompt.as_ptr(); }\n+    // get a line, process it\n+    unsafe { rl_prompt = ptr::null(); }\n }\n ~~~\n \n@@ -509,23 +508,28 @@ to define a block for all windows systems, not just x86 ones.\n \n # Interoperability with foreign code\n \n-Rust guarantees that the layout of a `struct` is compatible with the platform's representation in C\n-only if the `#[repr(C)]` attribute is applied to it.  `#[repr(C, packed)]` can be used to lay out\n-struct members without padding.  `#[repr(C)]` can also be applied to an enum.\n-\n-Rust's owned boxes (`Box<T>`) use non-nullable pointers as handles which point to the contained\n-object. However, they should not be manually created because they are managed by internal\n-allocators. References can safely be assumed to be non-nullable pointers directly to the type.\n-However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer\n-using raw pointers (`*`) if that's needed because the compiler can't make as many assumptions about\n-them.\n-\n-Vectors and strings share the same basic memory layout, and utilities are available in the `vec` and\n-`str` modules for working with C APIs. However, strings are not terminated with `\\0`. If you need a\n-NUL-terminated string for interoperability with C, you should use the `c_str::to_c_str` function.\n-\n-The standard library includes type aliases and function definitions for the C standard library in\n-the `libc` module, and Rust links against `libc` and `libm` by default.\n+Rust guarantees that the layout of a `struct` is compatible with the platform's\n+representation in C only if the `#[repr(C)]` attribute is applied to it.\n+`#[repr(C, packed)]` can be used to lay out struct members without padding.\n+`#[repr(C)]` can also be applied to an enum.\n+\n+Rust's owned boxes (`Box<T>`) use non-nullable pointers as handles which point\n+to the contained object. However, they should not be manually created because\n+they are managed by internal allocators. References can safely be assumed to be\n+non-nullable pointers directly to the type.  However, breaking the borrow\n+checking or mutability rules is not guaranteed to be safe, so prefer using raw\n+pointers (`*`) if that's needed because the compiler can't make as many\n+assumptions about them.\n+\n+Vectors and strings share the same basic memory layout, and utilities are\n+available in the `vec` and `str` modules for working with C APIs. However,\n+strings are not terminated with `\\0`. If you need a NUL-terminated string for\n+interoperability with C, you should use the `CString` type in the `std::ffi`\n+module.\n+\n+The standard library includes type aliases and function definitions for the C\n+standard library in the `libc` module, and Rust links against `libc` and `libm`\n+by default.\n \n # The \"nullable pointer optimization\"\n "}, {"sha": "dc6d281307a7a602e746a599b78f16961f628da9", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 97, "deletions": 58, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -1,14 +1,5 @@\n % The Rust Macros Guide\n \n-<div class=\"unstable-feature\">\n-<b>Warning:</b> There are currently various problems with invoking macros, how\n-they interact with their environment, and how they are used outside of the\n-location in which they are defined. Macro definitions are likely to change\n-slightly in the future. For this reason, they are hidden behind the\n-<code>macro_rules</code> <a href=\"reference.html#compiler-features\">feature\n-attribute</a>.\n-</div>\n-\n # Introduction\n \n Functions are the primary tool that programmers can use to build abstractions.\n@@ -46,19 +37,18 @@ lightweight custom syntax extensions, themselves defined using the\n the pattern in the above code:\n \n ~~~~\n-# #![feature(macro_rules)]\n # enum T { SpecialA(uint), SpecialB(uint) }\n # fn f() -> uint {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n-macro_rules! early_return(\n+macro_rules! early_return {\n     ($inp:expr $sp:path) => ( // invoke it like `(input_5 SpecialE)`\n         match $inp {\n             $sp(x) => { return x; }\n             _ => {}\n         }\n     );\n-);\n+}\n // ...\n early_return!(input_1 T::SpecialA);\n // ...\n@@ -109,10 +99,10 @@ that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n \n ## Invocation location\n \n-A macro invocation may take the place of (and therefore expand to)\n-an expression, an item, or a statement.\n-The Rust parser will parse the macro invocation as a \"placeholder\"\n-for whichever of those three nonterminals is appropriate for the location.\n+A macro invocation may take the place of (and therefore expand to) an\n+expression, item, statement, or pattern.  The Rust parser will parse the macro\n+invocation as a \"placeholder\" for whichever syntactic form is appropriate for\n+the location.\n \n At expansion time, the output of the macro will be parsed as whichever of the\n three nonterminals it stands in for. This means that a single macro might,\n@@ -166,12 +156,11 @@ separator token (a comma-separated list could be written `$(...),*`), and `+`\n instead of `*` to mean \"at least one\".\n \n ~~~~\n-# #![feature(macro_rules)]\n # enum T { SpecialA(uint),SpecialB(uint),SpecialC(uint),SpecialD(uint)}\n # fn f() -> uint {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n-macro_rules! early_return(\n+macro_rules! early_return {\n     ($inp:expr, [ $($sp:path)|+ ]) => (\n         match $inp {\n             $(\n@@ -180,7 +169,7 @@ macro_rules! early_return(\n             _ => {}\n         }\n     )\n-);\n+}\n // ...\n early_return!(input_1, [T::SpecialA|T::SpecialC|T::SpecialD]);\n // ...\n@@ -228,7 +217,6 @@ solves the problem.\n Now consider code like the following:\n \n ~~~~\n-# #![feature(macro_rules)]\n # enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n # enum T3 { Good2(uint), Bad2}\n@@ -255,8 +243,7 @@ a match, but with a syntax that suits the problem better. The following macro\n can solve the problem:\n \n ~~~~\n-# #![feature(macro_rules)]\n-macro_rules! biased_match (\n+macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n     ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n       binds $bind_res:ident\n@@ -275,7 +262,7 @@ macro_rules! biased_match (\n             _ => { $err }\n         };\n     )\n-);\n+}\n \n # enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n@@ -297,13 +284,12 @@ like this, we might prefer to write a single macro invocation. The input\n pattern we want is clear:\n \n ~~~~\n-# #![feature(macro_rules)]\n # fn main() {}\n-# macro_rules! b(\n+# macro_rules! b {\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $( $bind_res:ident ),*\n     )\n-# => (0));\n+# => (0) }\n ~~~~\n \n However, it's not possible to directly expand to nested match statements. But\n@@ -320,35 +306,32 @@ process the semicolon-terminated lines, one-by-one. So, we want the following\n input patterns:\n \n ~~~~\n-# #![feature(macro_rules)]\n-# macro_rules! b(\n+# macro_rules! b {\n     ( binds $( $bind_res:ident ),* )\n-# => (0));\n+# => (0) }\n # fn main() {}\n ~~~~\n \n ...and:\n \n ~~~~\n-# #![feature(macro_rules)]\n # fn main() {}\n-# macro_rules! b(\n+# macro_rules! b {\n     (    ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n       $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     )\n-# => (0));\n+# => (0) }\n ~~~~\n \n The resulting macro looks like this. Note that the separation into\n `biased_match!` and `biased_match_rec!` occurs only because we have an outer\n piece of syntax (the `let`) which we only want to transcribe once.\n \n ~~~~\n-# #![feature(macro_rules)]\n # fn main() {\n \n-macro_rules! biased_match_rec (\n+macro_rules! biased_match_rec {\n     // Handle the first layer\n     (   ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n      $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n@@ -366,10 +349,10 @@ macro_rules! biased_match_rec (\n     );\n     // Produce the requested values\n     ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n-);\n+}\n \n // Wrap the whole thing in a `let`.\n-macro_rules! biased_match (\n+macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $bind_res:ident\n@@ -388,7 +371,7 @@ macro_rules! biased_match (\n             binds $( $bind_res ),*\n         );\n     )\n-);\n+}\n \n \n # enum T1 { Good1(T2, uint), Bad1}\n@@ -434,17 +417,15 @@ As an example, `loop` and `for-loop` labels (discussed in the lifetimes guide)\n will not clash. The following code will print \"Hello!\" only once:\n \n ~~~\n-#![feature(macro_rules)]\n-\n-macro_rules! loop_x (\n+macro_rules! loop_x {\n     ($e: expr) => (\n         // $e will not interact with this 'x\n         'x: loop {\n             println!(\"Hello!\");\n             $e\n         }\n     );\n-);\n+}\n \n fn main() {\n     'x: loop {\n@@ -467,45 +448,53 @@ lexical-order traversal of a crate's source. So a macro defined at module scope\n is visible to any subsequent code in the same module, which includes the body\n of any subsequent child `mod` items.\n \n-If a module has the `macro_escape` attribute, its macros are also visible in\n-its parent module after the child's `mod` item. If the parent also has\n-`macro_escape` then the macros will be visible in the grandparent after the\n-parent's `mod` item, and so forth.\n+If a module has the `macro_use` attribute, its macros are also visible in its\n+parent module after the child's `mod` item. If the parent also has `macro_use`\n+then the macros will be visible in the grandparent after the parent's `mod`\n+item, and so forth.\n \n-Independent of `macro_escape`, the `macro_export` attribute controls visibility\n-between crates.  Any `macro_rules!` definition with the `macro_export`\n-attribute will be visible to other crates that have loaded this crate with\n-`phase(plugin)`. There is currently no way for the importing crate to control\n-which macros are imported.\n+The `macro_use` attribute can also appear on `extern crate`.  In this context\n+it controls which macros are loaded from the external crate, e.g.\n+\n+```rust,ignore\n+#[macro_use(foo, bar)]\n+extern crate baz;\n+```\n+\n+If the attribute is given simply as `#[macro_use]`, all macros are loaded.  If\n+there is no `#[macro_use]` attribute then no macros are loaded.  Only macros\n+defined with the `#[macro_export]` attribute may be loaded.\n+\n+To load a crate's macros *without* linking it into the output, use `#[no_link]`\n+as well.\n \n An example:\n \n ```rust\n-# #![feature(macro_rules)]\n-macro_rules! m1 (() => (()));\n+macro_rules! m1 { () => (()) }\n \n // visible here: m1\n \n mod foo {\n     // visible here: m1\n \n     #[macro_export]\n-    macro_rules! m2 (() => (()));\n+    macro_rules! m2 { () => (()) }\n \n     // visible here: m1, m2\n }\n \n // visible here: m1\n \n-macro_rules! m3 (() => (()));\n+macro_rules! m3 { () => (()) }\n \n // visible here: m1, m3\n \n-#[macro_escape]\n+#[macro_use]\n mod bar {\n     // visible here: m1, m3\n \n-    macro_rules! m4 (() => (()));\n+    macro_rules! m4 { () => (()) }\n \n     // visible here: m1, m3, m4\n }\n@@ -514,8 +503,58 @@ mod bar {\n # fn main() { }\n ```\n \n-When this library is loaded with `#[phase(plugin)] extern crate`, only `m2`\n-will be imported.\n+When this library is loaded with `#[use_macros] extern crate`, only `m2` will\n+be imported.\n+\n+The Rust Reference has a [listing of macro-related\n+attributes](reference.html#macro--and-plugin-related-attributes).\n+\n+# The variable `$crate`\n+\n+A further difficulty occurs when a macro is used in multiple crates.  Say that\n+`mylib` defines\n+\n+```rust\n+pub fn increment(x: uint) -> uint {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! inc_a {\n+    ($x:expr) => ( ::increment($x) )\n+}\n+\n+#[macro_export]\n+macro_rules! inc_b {\n+    ($x:expr) => ( ::mylib::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+`inc_a` only works within `mylib`, while `inc_b` only works outside the\n+library.  Furthermore, `inc_b` will break if the user imports `mylib` under\n+another name.\n+\n+Rust does not (yet) have a hygiene system for crate references, but it does\n+provide a simple workaround for this problem.  Within a macro imported from a\n+crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n+By contrast, when a macro is defined and then used in the same crate, `$crate`\n+will expand to nothing.  This means we can write\n+\n+```rust\n+#[macro_export]\n+macro_rules! inc {\n+    ($x:expr) => ( $crate::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+to define a single macro that works both inside and outside our library.  The\n+function name will expand to either `::increment` or `::mylib::increment`.\n+\n+To keep this system simple and correct, `#[macro_use] extern crate ...` may\n+only appear at the root of your crate, not inside `mod`.  This ensures that\n+`$crate` is a single identifier.\n \n # A final note\n "}, {"sha": "414a874082eefdc24fe8acf2bfbdc656351bf93d", "filename": "src/doc/guide-ownership.md", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ownership.md?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -230,8 +230,9 @@ fn add_one(num: &int) -> int {\n ```\n \n Rust has a feature called 'lifetime elision,' which allows you to not write\n-lifetime annotations in certain circumstances. This is one of them. Without\n-eliding the lifetimes, `add_one` looks like this:\n+lifetime annotations in certain circumstances. This is one of them. We will\n+cover the others later. Without eliding the lifetimes, `add_one` looks like\n+this:\n \n ```rust\n fn add_one<'a>(num: &'a int) -> int {\n@@ -449,6 +450,80 @@ This is the simplest kind of multiple ownership possible. For example, there's\n also `Arc<T>`, which uses more expensive atomic instructions to be the\n thread-safe counterpart of `Rc<T>`.\n \n+## Lifetime Elision\n+\n+Earlier, we mentioned 'lifetime elision,' a feature of Rust which allows you to\n+not write lifetime annotations in certain circumstances. All references have a\n+lifetime, and so if you elide a lifetime (like `&T` instead of `&'a T`), Rust\n+will do three things to determine what those lifetimes should be.\n+\n+When talking about lifetime elision, we use the term 'input lifetime' and\n+'output lifetime'. An 'input liftime' is a lifetime associated with a parameter\n+of a function, and an 'output lifetime' is a lifetime associated with the return\n+value of a function. For example, this function has an input lifetime:\n+\n+```{rust,ignore}\n+fn foo<'a>(bar: &'a str)\n+```\n+\n+This one has an output lifetime:\n+\n+```{rust,ignore}\n+fn foo<'a>() -> &'a str\n+```\n+\n+This one has a lifetime in both positions:\n+\n+```{rust,ignore}\n+fn foo<'a>(bar: &'a str) -> &'a str\n+```\n+\n+Here are the three rules:\n+\n+* Each elided lifetime in a function's arguments becomes a distinct lifetime\n+  parameter.\n+\n+* If there is exactly one input lifetime, elided or not, that lifetime is\n+  assigned to all elided lifetimes in the return values of that function..\n+\n+* If there are multiple input lifetimes, but one of them is `&self` or `&mut\n+  self`, the lifetime of `self` is assigned to all elided output lifetimes.\n+\n+Otherwise, it is an error to elide an output lifetime.\n+\n+### Examples\n+\n+Here are some examples of functions with elided lifetimes, and the version of\n+what the elided lifetimes are expand to:\n+\n+```{rust,ignore}\n+fn print(s: &str);                                      // elided\n+fn print<'a>(s: &'a str);                               // expanded\n+\n+fn debug(lvl: uint, s: &str);                           // elided\n+fn debug<'a>(lvl: uint, s: &'a str);                    // expanded\n+\n+// In the preceeding example, `lvl` doesn't need a lifetime because it's not a\n+// reference (`&`). Only things relating to references (such as a `struct`\n+// which contains a reference) need lifetimes.\n+\n+fn substr(s: &str, until: uint) -> &str;                // elided\n+fn substr<'a>(s: &'a str, until: uint) -> &'a str;      // expanded\n+\n+fn get_str() -> &str;                                   // ILLEGAL, no inputs\n+\n+fn frob(s: &str, t: &str) -> &str;                      // ILLEGAL, two inputs\n+\n+fn get_mut(&mut self) -> &mut T;                        // elided\n+fn get_mut<'a>(&'a mut self) -> &'a mut T;              // expanded\n+\n+fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command                  // elided\n+fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n+\n+fn new(buf: &mut [u8]) -> BufWriter;                    // elided\n+fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>          // expanded\n+```\n+\n # Related Resources\n \n Coming Soon."}, {"sha": "025f0cced63a6a6cb6b3dd37f793ecd07ba84a99", "filename": "src/doc/guide-plugin.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-plugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-plugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-plugin.md?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -31,10 +31,14 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n \n A plugin is a dynamic library crate with a designated \"registrar\" function that\n registers extensions with `rustc`. Other crates can use these extensions by\n-loading the plugin crate with `#[phase(plugin)] extern crate`. See the\n+loading the plugin crate with `#[plugin] extern crate`. See the\n [`rustc::plugin`](rustc/plugin/index.html) documentation for more about the\n mechanics of defining and loading a plugin.\n \n+Arguments passed as `#[plugin=...]` or `#[plugin(...)]` are not interpreted by\n+rustc itself.  They are provided to the plugin through the `Registry`'s [`args`\n+method](rustc/plugin/registry/struct.Registry.html#method.args).\n+\n # Syntax extensions\n \n Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n@@ -105,10 +109,9 @@ pub fn plugin_registrar(reg: &mut Registry) {\n Then we can use `rn!()` like any other macro:\n \n ```ignore\n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n-extern crate roman_numerals;\n+#[plugin] extern crate roman_numerals;\n \n fn main() {\n     assert_eq!(rn!(MMXV), 2015);\n@@ -217,8 +220,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n Then code like\n \n ```ignore\n-#[phase(plugin)]\n-extern crate lint_plugin_test;\n+#[plugin] extern crate lint_plugin_test;\n \n fn lintme() { }\n ```"}, {"sha": "4c3d93bdfbe5feb70333c8aa1fc7f1b419f66db7", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -503,6 +503,8 @@ Advice on writing benchmarks:\n * Make the code in the `iter` loop do something simple, to assist in pinpointing\n   performance improvements (or regressions)\n \n+## Gotcha: optimizations\n+\n There's another tricky part to writing benchmarks: benchmarks compiled with\n optimizations activated can be dramatically changed by the optimizer so that\n the benchmark is no longer benchmarking what one expects. For example, the\n@@ -556,8 +558,12 @@ extern crate test;\n # struct X;\n # impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n b.iter(|| {\n-    test::black_box(range(0u, 1000).fold(0, |old, new| old ^ new));\n-});\n+    let mut n = 1000_u32;\n+\n+    test::black_box(&mut n); // pretend to modify `n`\n+\n+    range(0, n).fold(0, |a, b| a ^ b)\n+})\n # }\n ```\n \n@@ -573,3 +579,6 @@ test bench_xor_1000_ints ... bench:       1 ns/iter (+/- 0)\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n ```\n+\n+However, the optimizer can still modify a testcase in an undesirable manner\n+even when using either of the above."}, {"sha": "66551ec499a89eeb96044251a9b440b9910e46ae", "filename": "src/doc/guide.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -355,7 +355,7 @@ Hello, world!\n Bam! We build our project with `cargo build`, and run it with\n `./target/hello_world`. This hasn't bought us a whole lot over our simple use\n of `rustc`, but think about the future: when our project has more than one\n-file, we would need to call `rustc` twice, and pass it a bunch of options to\n+file, we would need to call `rustc` more than once, and pass it a bunch of options to\n tell it to build everything together. With Cargo, as our project grows, we can\n just `cargo build` and it'll work the right way.\n \n@@ -977,7 +977,7 @@ fn main() {\n ```\n \n Even though Rust functions can only return one value, a tuple _is_ one value,\n-that happens to be made up of two. You can also see in this example how you\n+that happens to be made up of more than one value. You can also see in this example how you\n can destructure a pattern returned by a function, as well.\n \n Tuples are a very simple data structure, and so are not often what you want."}, {"sha": "0f1f26d3e711c8f2d75d3250fef6178e2d61a243", "filename": "src/doc/reference.md", "status": "modified", "additions": 68, "deletions": 106, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -193,12 +193,12 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n | break    | const    | continue | crate    | do      |\n | else     | enum     | extern   | false    | final   |\n | fn       | for      | if       | impl     | in      |\n-| let      | loop     | match    | mod      | move    |\n-| mut      | offsetof | override | priv     | pub     |\n-| pure     | ref      | return   | sizeof   | static  |\n-| self     | struct   | super    | true     | trait   |\n-| type     | typeof   | unsafe   | unsized  | use     |\n-| virtual  | where    | while    | yield    |\n+| let      | loop     | macro    | match    | mod     |\n+| move     | mut      | offsetof | override | priv    |\n+| pub      | pure     | ref      | return   | sizeof  |\n+| static   | self     | struct   | super    | true    |\n+| trait    | type     | typeof   | unsafe   | unsized |\n+| use      | virtual  | where    | while    | yield   |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -668,9 +668,11 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n             | non_special_token ;\n ```\n \n-User-defined syntax extensions are called \"macros\", and the `macro_rules`\n-syntax extension defines them. Currently, user-defined macros can expand to\n-expressions, statements, items, or patterns.\n+`macro_rules` allows users to define syntax extension in a declarative way.  We\n+call such extensions \"macros by example\" or simply \"macros\" \u2014 to be distinguished\n+from the \"procedural macros\" defined in [compiler plugins][plugin].\n+\n+Currently, macros can expand to expressions, statements, items, or patterns.\n \n (A `sep_token` is any token other than `*` and `+`. A `non_special_token` is\n any token other than a delimiter or `$`.)\n@@ -1259,8 +1261,8 @@ We call such functions \"diverging\" because they never return a value to the\n caller. Every control path in a diverging function must end with a `panic!()` or\n a call to another diverging function on every control path. The `!` annotation\n does *not* denote a type. Rather, the result type of a diverging function is a\n-special type called $\\bot$ (\"bottom\") that unifies with any type. Rust has no\n-syntax for $\\bot$.\n+special type called \u22a5 (\"bottom\") that unifies with any type. Rust has no\n+syntax for \u22a5.\n \n It might be necessary to declare a diverging function because as mentioned\n previously, the typechecker checks that every control path in a function ends\n@@ -2002,8 +2004,6 @@ type int8_t = i8;\n \n ### Module-only attributes\n \n-- `macro_escape` - macros defined in this module will be visible in the\n-  module's parent, after this module has been included.\n - `no_implicit_prelude` - disable injecting `use std::prelude::*` in this\n   module.\n - `path` - specifies the file to load the module from. `#[path=\"foo.rs\"] mod\n@@ -2066,23 +2066,43 @@ On `struct`s:\n   remove any padding between fields (note that this is very fragile and may\n   break platforms which require aligned access).\n \n+### Macro- and plugin-related attributes\n+\n+- `macro_use` on a `mod` \u2014 macros defined in this module will be visible in the\n+  module's parent, after this module has been included.\n+\n+- `macro_use` on an `extern crate` \u2014 load macros from this crate.  An optional\n+  list of names `#[macro_use(foo, bar)]` restricts the import to just those\n+  macros named.  The `extern crate` must appear at the crate root, not inside\n+  `mod`, which ensures proper function of the [`$crate` macro\n+  variable](guide-macros.html#the-variable-$crate).\n+\n+- `macro_reexport` on an `extern crate` \u2014 re-export the named macros.\n+\n+- `macro_export` - export a macro for cross-crate usage.\n+\n+- `plugin` on an `extern crate`\u00a0\u2014 load this crate as a [compiler\n+  plugin][plugin].  The `plugin` feature gate is required.  Any arguments to\n+  the attribute, e.g. `#[plugin=...]` or `#[plugin(...)]`, are provided to the\n+  plugin.\n+\n+- `no_link` on an `extern crate` \u2014 even if we load this crate for macros or\n+  compiler plugins, don't link it into the output.\n+\n+See the [macros guide](guide-macros.html#scoping-and-macro-import/export) for\n+more information on macro scope.\n+\n+\n ### Miscellaneous attributes\n \n - `export_name` - on statics and functions, this determines the name of the\n   exported symbol.\n - `link_section` - on statics and functions, this specifies the section of the\n   object file that this item's contents will be placed into.\n-- `macro_export` - export a macro for cross-crate usage.\n - `no_mangle` - on any item, do not apply the standard name mangling. Set the\n   symbol for this item to its identifier.\n - `packed` - on structs or enums, eliminate any padding that would be used to\n   align fields.\n-- `phase` - on `extern crate` statements, allows specifying which \"phase\" of\n-  compilation the crate should be loaded for. Currently, there are two\n-  choices: `link` and `plugin`. `link` is the default. `plugin` will [load the\n-  crate at compile-time][plugin] and use any syntax extensions or lints that the crate\n-  defines. They can both be specified, `#[phase(link, plugin)]` to use a crate\n-  both at runtime and compiletime.\n - `simd` - on certain tuple structs, derive the arithmetic operators, which\n   lower to the target's SIMD instructions, if any; the `simd` feature gate\n   is necessary to use this attribute.\n@@ -2569,15 +2589,6 @@ The currently implemented features of the reference compiler are:\n * `log_syntax` - Allows use of the `log_syntax` macro attribute, which is a\n                  nasty hack that will certainly be removed.\n \n-* `macro_rules` - The definition of new macros. This does not encompass\n-                  macro-invocation, that is always enabled by default, this\n-                  only covers the definition of new macros. There are currently\n-                  various problems with invoking macros, how they interact with\n-                  their environment, and possibly how they are used outside of\n-                  location in which they are defined. Macro definitions are\n-                  likely to change slightly in the future, so they are\n-                  currently hidden behind this feature.\n-\n * `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n                        but the implementation is a little rough around the\n                        edges, so this can be seen as an experimental feature\n@@ -2588,15 +2599,10 @@ The currently implemented features of the reference compiler are:\n                closure as `once` is unlikely to be supported going forward. So\n                they are hidden behind this feature until they are to be removed.\n \n-* `phase` - Usage of the `#[phase]` attribute allows loading compiler plugins\n-            for custom lints or syntax extensions. The implementation is\n-            considered unwholesome and in need of overhaul, and it is not clear\n-            what they will look like moving forward.\n+* `plugin` - Usage of [compiler plugins][plugin] for custom lints or syntax extensions.\n+             These depend on compiler internals and are subject to change.\n \n-* `plugin_registrar` - Indicates that a crate has [compiler plugins][plugin] that it\n-                       wants to load. As with `phase`, the implementation is\n-                       in need of an overhaul, and it is not clear that plugins\n-                       defined using this will continue to work.\n+* `plugin_registrar` - Indicates that a crate provides [compiler plugins][plugin].\n \n * `quote` - Allows use of the `quote_*!` family of macros, which are\n             implemented very poorly and will likely change significantly\n@@ -3484,8 +3490,9 @@ fn main() {\n \n ```\n \n-Patterns can also dereference pointers by using the `&`, `box` symbols,\n-as appropriate. For example, these two matches on `x: &int` are equivalent:\n+Patterns can also dereference pointers by using the `&`, `&mut` and `box`\n+symbols, as appropriate. For example, these two matches on `x: &int` are\n+equivalent:\n \n ```\n # let x = &3i;\n@@ -4316,73 +4323,28 @@ fine-grained control is desired over the output format of a Rust crate.\n \n *TODO*.\n \n-# Appendix: Influences and further references\n-\n-## Influences\n-\n->  The essential problem that must be solved in making a fault-tolerant\n->  software system is therefore that of fault-isolation. Different programmers\n->  will write different modules, some modules will be correct, others will have\n->  errors. We do not want the errors in one module to adversely affect the\n->  behaviour of a module which does not have any errors.\n->\n->  &mdash; Joe Armstrong\n-\n->  In our approach, all data is private to some process, and processes can\n->  only communicate through communications channels. *Security*, as used\n->  in this paper, is the property which guarantees that processes in a system\n->  cannot affect each other except by explicit communication.\n->\n->  When security is absent, nothing which can be proven about a single module\n->  in isolation can be guaranteed to hold when that module is embedded in a\n->  system [...]\n->\n->  &mdash; Robert Strom and Shaula Yemini\n-\n->  Concurrent and applicative programming complement each other. The\n->  ability to send messages on channels provides I/O without side effects,\n->  while the avoidance of shared data helps keep concurrent processes from\n->  colliding.\n->\n->  &mdash; Rob Pike\n-\n-Rust is not a particularly original language. It may however appear unusual by\n-contemporary standards, as its design elements are drawn from a number of\n-\"historical\" languages that have, with a few exceptions, fallen out of favour.\n-Five prominent lineages contribute the most, though their influences have come\n-and gone during the course of Rust's development:\n-\n-* The NIL (1981) and Hermes (1990) family. These languages were developed by\n-  Robert Strom, Shaula Yemini, David Bacon and others in their group at IBM\n-  Watson Research Center (Yorktown Heights, NY, USA).\n-\n-* The Erlang (1987) language, developed by Joe Armstrong, Robert Virding, Claes\n-  Wikstr&ouml;m, Mike Williams and others in their group at the Ericsson Computer\n-  Science Laboratory (&Auml;lvsj&ouml;, Stockholm, Sweden) .\n-\n-* The Sather (1990) language, developed by Stephen Omohundro, Chu-Cheow Lim,\n-  Heinz Schmidt and others in their group at The International Computer\n-  Science Institute of the University of California, Berkeley (Berkeley, CA,\n-  USA).\n-\n-* The Newsqueak (1988), Alef (1995), and Limbo (1996) family. These\n-  languages were developed by Rob Pike, Phil Winterbottom, Sean Dorward and\n-  others in their group at Bell Labs Computing Sciences Research Center\n-  (Murray Hill, NJ, USA).\n-\n-* The Napier (1985) and Napier88 (1988) family. These languages were\n-  developed by Malcolm Atkinson, Ron Morrison and others in their group at\n-  the University of St. Andrews (St. Andrews, Fife, UK).\n-\n-Additional specific influences can be seen from the following languages:\n-\n-* The structural algebraic types and compilation manager of SML.\n-* The attribute and assembly systems of C#.\n-* The references and deterministic destructor system of C++.\n-* The memory region systems of the ML Kit and Cyclone.\n-* The typeclass system of Haskell.\n-* The lexical identifier rule of Python.\n-* The block syntax of Ruby.\n+# Appendix: Influences\n+\n+Rust is not a particularly original language, with design elements coming from\n+a wide range of sources. Some of these are listed below (including elements\n+that have since been removed):\n+\n+* SML, OCaml: algebraic datatypes, pattern matching, type inference,\n+  semicolon statement separation\n+* C++: references, RAII, smart pointers, move semantics, monomorphisation,\n+  memory model\n+* ML Kit, Cyclone: region based memory management\n+* Haskell (GHC): typeclasses, type families\n+* Newsqueak, Alef, Limbo: channels, concurrency\n+* Erlang: message passing, task failure, ~~linked task failure~~,\n+  ~~lightweight concurrency~~\n+* Swift: optional bindings\n+* Scheme: hygienic macros\n+* C#: attributes\n+* Ruby: ~~block syntax~~\n+* NIL, Hermes: ~~typestate~~\n+* [Unicode Annex #31](http://www.unicode.org/reports/tr31/): identifier and\n+  pattern syntax\n \n [ffi]: guide-ffi.html\n [plugin]: guide-plugin.html"}, {"sha": "32158ea549627c94fadc8d71f3889ca8e8cc6e9f", "filename": "src/doc/uptack.tex", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fuptack.tex", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fdoc%2Fuptack.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fuptack.tex?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,2 @@\n+\\usepackage{newunicodechar}\n+\\newunicodechar\u22a5{{$\\bot$}}"}, {"sha": "1fb01767a130b4833f0a36031a7ae678c652dbb4", "filename": "src/etc/kate/rust.xml", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -15,28 +15,41 @@\n \t<list name=\"type\">\n \t\t<item> type </item>\n \t</list>\n+\t<list name=\"reserved\">\n+\t\t<item> abstract </item>\n+\t\t<item> alignof </item>\n+\t\t<item> be </item>\n+\t\t<item> do </item>\n+\t\t<item> final </item>\n+\t\t<item> offsetof </item>\n+\t\t<item> override </item>\n+\t\t<item> priv </item>\n+\t\t<item> pure </item>\n+\t\t<item> sizeof </item>\n+\t\t<item> typeof </item>\n+\t\t<item> unsized </item>\n+\t\t<item> yield </item>\n+\t</list>\n \t<list name=\"keywords\">\n \t\t<item> as </item>\n-\t\t<item> break </item>\n \t\t<item> box </item>\n+\t\t<item> break </item>\n \t\t<item> const </item>\n \t\t<item> continue </item>\n \t\t<item> crate </item>\n-\t\t<item> do </item>\n-\t\t<item> drop </item>\n \t\t<item> else </item>\n \t\t<item> enum </item>\n \t\t<item> extern </item>\n \t\t<item> for </item>\n \t\t<item> if </item>\n \t\t<item> impl </item>\n+\t\t<item> in </item>\n \t\t<item> let </item>\n \t\t<item> loop </item>\n \t\t<item> match </item>\n \t\t<item> mod </item>\n \t\t<item> move </item>\n \t\t<item> mut </item>\n-\t\t<item> priv </item>\n \t\t<item> pub </item>\n \t\t<item> ref </item>\n \t\t<item> return </item>\n@@ -192,6 +205,7 @@\n \t\t\t<DetectSpaces/>\n \t\t\t<keyword String=\"fn\" attribute=\"Keyword\" context=\"Function\"/>\n \t\t\t<keyword String=\"type\" attribute=\"Keyword\" context=\"Type\"/>\n+\t\t\t<keyword String=\"reserved\" attribute=\"Keyword\" context=\"#stay\"/>\n \t\t\t<keyword String=\"keywords\" attribute=\"Keyword\" context=\"#stay\"/>\n \t\t\t<keyword String=\"types\" attribute=\"Type\" context=\"#stay\"/>\n \t\t\t<keyword String=\"traits\" attribute=\"Trait\" context=\"#stay\"/>"}, {"sha": "dce6d3f66879e3cca1d93594a22ad555fda3b650", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 20, "deletions": 42, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -3,7 +3,7 @@\n \" Maintainer:   Patrick Walton <pcwalton@mozilla.com>\n \" Maintainer:   Ben Blum <bblum@cs.cmu.edu>\n \" Maintainer:   Chris Morgan <me@chrismorgan.info>\n-\" Last Change:  July 18, 2014\n+\" Last Change:  January 5, 2015\n \n if version < 600\n   syntax clear\n@@ -56,7 +56,7 @@ syn match rustMacroRepeatCount \".\\?[*+]\" contained\n syn match rustMacroVariable \"$\\w\\+\"\n \n \" Reserved (but not yet used) keywords {{{2\n-syn keyword   rustReservedKeyword alignof be do offsetof priv pure sizeof typeof unsized yield abstract final override\n+syn keyword   rustReservedKeyword alignof be do offsetof priv pure sizeof typeof unsized yield abstract final override macro\n \n \" Built-in types {{{2\n syn keyword   rustType        int uint float char bool u8 u16 u32 u64 f32\n@@ -68,59 +68,37 @@ syn keyword   rustType        f64 i8 i16 i32 i64 str Self\n \n \" Reexported core operators {{{3\n syn keyword   rustTrait       Copy Send Sized Sync\n-syn keyword   rustTrait       Add Sub Mul Div Rem Neg Not\n-syn keyword   rustTrait       BitAnd BitOr BitXor\n-syn keyword   rustTrait       Drop Deref DerefMut\n-syn keyword   rustTrait       Shl Shr\n-syn keyword   rustTrait       Index IndexMut\n-syn keyword   rustTrait       Slice SliceMut\n-syn keyword   rustTrait       Fn FnMut FnOnce\n+syn keyword   rustTrait       Drop Fn FnMut FnOnce\n \n \" Reexported functions {{{3\n-\"syn keyword rustFunction range repeat\n-\"syn keyword rustFunction drop\n-\"syn keyword rustFunction from_str\n+syn keyword rustFunction drop\n \n \" Reexported types and traits {{{3\n-syn keyword rustTrait Ascii AsciiCast OwnedAsciiCast AsciiStr\n-syn keyword rustTrait IntoBytes\n-syn keyword rustTrait ToCStr\n-syn keyword rustTrait Char UnicodeChar\n+syn keyword rustTrait Box\n+syn keyword rustTrait CharExt\n syn keyword rustTrait Clone\n syn keyword rustTrait PartialEq PartialOrd Eq Ord\n-syn keyword rustEnum Ordering Equiv\n-syn keyword rustEnumVariant Less Equal Greater\n-syn keyword rustTrait FromIterator Extend ExactSizeIterator\n-syn keyword rustTrait Iterator DoubleEndedIterator\n-syn keyword rustTrait RandomAccessIterator CloneableIterator\n-syn keyword rustTrait OrdIterator MutableDoubleEndedIterator\n-syn keyword rustTrait ToPrimitive FromPrimitive\n-syn keyword rustTrait Box\n+syn keyword rustTrait DoubleEndedIterator\n+syn keyword rustTrait ExactSizeIterator\n+syn keyword rustTrait Iterator IteratorExt Extend\n syn keyword rustEnum Option\n syn keyword rustEnumVariant Some None\n-syn keyword rustTrait GenericPath Path PosixPath WindowsPath\n-syn keyword rustTrait RawPtr RawMutPtr\n+syn keyword rustTrait PtrExt MutPtrExt\n syn keyword rustEnum Result\n syn keyword rustEnumVariant Ok Err\n-syn keyword rustTrait Buffer Writer Reader Seek BufferPrelude\n-syn keyword rustTrait Str StrVector StrPrelude\n-syn keyword rustTrait IntoMaybeOwned StrAllocating UnicodeStrPrelude\n-syn keyword rustTrait Tuple1 Tuple2 Tuple3 Tuple4\n-syn keyword rustTrait Tuple5 Tuple6 Tuple7 Tuple8\n-syn keyword rustTrait Tuple9 Tuple10 Tuple11 Tuple12\n-syn keyword rustTrait SlicePrelude AsSlice CloneSlicePrelude\n-syn keyword rustTrait VectorVector PartialEqSlicePrelude OrdSlicePrelude\n-syn keyword rustTrait CloneSliceAllocPrelude OrdSliceAllocPrelude SliceAllocPrelude\n-syn keyword rustTrait IntoString String ToString\n+syn keyword rustTrait AsSlice\n+syn keyword rustTrait SliceExt SliceConcatExt\n+syn keyword rustTrait Str StrExt\n+syn keyword rustTrait String ToString\n syn keyword rustTrait Vec\n-\n-\" Reexported runtime types {{{3\n-\"syn keyword rustFunction sync_channel channel\n-syn keyword rustTrait SyncSender Sender Receiver\n-\"syn keyword rustFunction spawn\n+\" FIXME: remove when path reform lands\n+syn keyword rustTrait Path GenericPath\n+\" FIXME: remove when I/O reform lands\n+syn keyword rustTrait Buffer Writer Reader Seek BufferPrelude\n+\" FIXME: remove when range syntax lands\n+syn keyword rustFunction range\n \n \" Other syntax {{{2\n-\n syn keyword   rustSelf        self\n syn keyword   rustBoolean     true false\n "}, {"sha": "9194c7a47663d66e343750d8c515e39da09b8c8a", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(globs, phase, macro_rules)]\n+#![feature(globs, plugin)]\n \n extern crate syntax;\n extern crate rustc;\n \n-#[phase(link)]\n extern crate regex;\n \n-#[phase(link, plugin)]\n+#[macro_use]\n extern crate log;\n \n use std::collections::HashMap;\n@@ -269,7 +268,7 @@ fn main() {\n         assert!(rustc_tok.sp == antlr_tok.sp, \"{} and {} have different spans\", rustc_tok,\n                 antlr_tok);\n \n-        macro_rules! matches (\n+        macro_rules! matches {\n             ( $($x:pat),+ ) => (\n                 match rustc_tok.tok {\n                     $($x => match antlr_tok.tok {\n@@ -285,7 +284,7 @@ fn main() {\n                     ref c => assert!(c == &antlr_tok.tok, \"{} is not {}\", rustc_tok, antlr_tok)\n                 }\n             )\n-        );\n+        }\n \n         matches!(\n             token::Literal(token::Byte(..), _),"}, {"sha": "25f80ad11bd1124b87ef34445b799b4dd67f80cf", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -246,7 +246,7 @@ impl<T> BorrowFrom<Arc<T>> for T {\n     }\n }\n \n-#[experimental = \"Deref is experimental.\"]\n+#[stable]\n impl<T> Deref for Arc<T> {\n     type Target = T;\n \n@@ -290,7 +290,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n }\n \n #[unsafe_destructor]\n-#[experimental = \"waiting on stability of Drop\"]\n+#[stable]\n impl<T: Sync + Send> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n@@ -418,7 +418,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[stable]\n impl<T: Sync + Send> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///"}, {"sha": "6df8bb5f7aaf4b146b76b88ea00850932c17b7e3", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -75,14 +75,14 @@ impl<T: Clone> Clone for Box<T> {\n }\n \n #[stable]\n-impl<Sized? T: PartialEq> PartialEq for Box<T> {\n+impl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n #[stable]\n-impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n+impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n@@ -97,16 +97,16 @@ impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n #[stable]\n-impl<Sized? T: Ord> Ord for Box<T> {\n+impl<T: ?Sized + Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n \n #[stable]}\n-impl<Sized? T: Eq> Eq for Box<T> {}\n+impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n-impl<S: hash::Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {\n+impl<S: hash::Writer, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n@@ -143,7 +143,7 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n-impl<Sized? T: fmt::Show> fmt::Show for Box<T> {\n+impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         (**self).fmt(f)\n     }\n@@ -155,13 +155,15 @@ impl fmt::Show for Box<Any> {\n     }\n }\n \n-impl<Sized? T> Deref for Box<T> {\n+#[stable]\n+impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { &**self }\n }\n \n-impl<Sized? T> DerefMut for Box<T> {\n+#[stable]\n+impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }\n "}, {"sha": "001e02f9c0dd5c29cc91e2f0f25ecd51b4697e86", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -68,14 +68,33 @@\n #![feature(lang_items, phase, unsafe_destructor, default_type_params, old_orphan_check)]\n #![feature(associated_types)]\n \n+#[cfg(stage0)]\n #[phase(plugin, link)]\n extern crate core;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate core;\n+\n extern crate libc;\n \n // Allow testing this library\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate std;\n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate std;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate std;\n+\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate log;\n \n // Heaps provided for low-level allocation strategies\n "}, {"sha": "175bba4e71dc46f9671f04658e5a3b034914a43e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -354,7 +354,7 @@ impl<T> BorrowFrom<Rc<T>> for T {\n     }\n }\n \n-#[experimental = \"Deref is experimental.\"]\n+#[stable]\n impl<T> Deref for Rc<T> {\n     type Target = T;\n \n@@ -365,7 +365,7 @@ impl<T> Deref for Rc<T> {\n }\n \n #[unsafe_destructor]\n-#[experimental = \"Drop is experimental.\"]\n+#[stable]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n     ///\n@@ -656,7 +656,7 @@ impl<T> Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[stable]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///"}, {"sha": "01693391abed51037186c9f781eca4141ae148b9", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -148,6 +148,7 @@\n //! ```\n \n #![allow(missing_docs)]\n+#![stable]\n \n use core::prelude::*;\n \n@@ -561,11 +562,13 @@ impl<T: Ord> BinaryHeap<T> {\n }\n \n /// `BinaryHeap` iterator.\n+#[stable]\n pub struct Iter <'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+#[stable]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter { iter: self.iter.clone() }\n@@ -593,6 +596,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n+#[stable]\n pub struct IntoIter<T> {\n     iter: vec::IntoIter<T>,\n }\n@@ -618,6 +622,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n+#[unstable = \"recent addition\"]\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }"}, {"sha": "b85ea65f5ce5880140611f8be2d09687be61c5d0", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -130,7 +130,7 @@ pub struct Values<'a, K: 'a, V: 'a> {\n \n #[stable]\n /// A view into a single entry in a map, which may either be vacant or occupied.\n-pub enum Entry<'a, Sized? Q:'a, K:'a, V:'a> {\n+pub enum Entry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n     /// A vacant Entry\n     Vacant(VacantEntry<'a, Q, K, V>),\n     /// An occupied Entry\n@@ -139,7 +139,7 @@ pub enum Entry<'a, Sized? Q:'a, K:'a, V:'a> {\n \n #[stable]\n /// A vacant Entry.\n-pub struct VacantEntry<'a, Sized? Q:'a, K:'a, V:'a> {\n+pub struct VacantEntry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n     key: &'a Q,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n@@ -214,7 +214,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable]\n-    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n             match Node::search(cur_node, key) {\n@@ -246,7 +246,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable]\n-    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n \n@@ -270,7 +270,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable]\n-    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -440,7 +440,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -878,7 +878,7 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n }\n \n #[stable]\n-impl<K: Ord, Sized? Q, V> Index<Q> for BTreeMap<K, V>\n+impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n     type Output = V;\n@@ -889,7 +889,7 @@ impl<K: Ord, Sized? Q, V> Index<Q> for BTreeMap<K, V>\n }\n \n #[stable]\n-impl<K: Ord, Sized? Q, V> IndexMut<Q> for BTreeMap<K, V>\n+impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n     type Output = V;\n@@ -1111,7 +1111,7 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n #[stable]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n-impl<'a, Sized? Q, K: Ord, V> Entry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized, K: Ord, V> Entry<'a, Q, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n@@ -1122,7 +1122,7 @@ impl<'a, Sized? Q, K: Ord, V> Entry<'a, Q, K, V> {\n     }\n }\n \n-impl<'a, Sized? Q: ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized + ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n     #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n@@ -1362,7 +1362,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n     #[stable]\n-    pub fn entry<'a, Sized? Q>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n+    pub fn entry<'a, Q: ?Sized>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n         where Q: Ord + ToOwned<K>\n     {\n         // same basic logic of `swap` and `pop`, blended together"}, {"sha": "0a93bbf89c9971dea74fe7c5fadc95e614f35f06", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -517,7 +517,7 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Sized? Q, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n+    pub fn search<Q: ?Sized, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n                   -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n@@ -536,7 +536,7 @@ impl<K: Ord, V> Node<K, V> {\n         }\n     }\n \n-    fn search_linear<Sized? Q>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord {\n+    fn search_linear<Q: ?Sized>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord {\n         for (i, k) in self.keys().iter().enumerate() {\n             match key.cmp(BorrowFrom::borrow_from(k)) {\n                 Greater => {},"}, {"sha": "98f163321706041f81f7fb731f81726ba79b1303", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -299,7 +299,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable]\n-    pub fn contains<Sized? Q>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n \n@@ -429,7 +429,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }"}, {"sha": "5e08f90ce1c536368aef61df7e5577e675932a1e", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -19,6 +19,8 @@\n // Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n+#![stable]\n+\n use core::prelude::*;\n \n use alloc::boxed::Box;\n@@ -1064,6 +1066,7 @@ mod tests {\n     }\n \n     #[allow(deprecated)]\n+    #[test]\n     fn test_append() {\n         {\n             let mut m = DList::new();"}, {"sha": "5bf5f78af94c272381f14d4581bdb9b1946d9c00", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -29,15 +29,34 @@\n #![feature(associated_types)]\n #![no_std]\n \n-#[phase(plugin, link)] extern crate core;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate core;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate core;\n+\n extern crate unicode;\n extern crate alloc;\n \n #[cfg(test)] extern crate test;\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate std;\n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate std;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate std;\n \n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate log;\n \n pub use binary_heap::BinaryHeap;\n pub use bitv::Bitv;\n@@ -51,6 +70,11 @@ pub use string::String;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n+// Needed for the vec! macro\n+pub use alloc::boxed;\n+\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod macros;\n \n pub mod binary_heap;\n@@ -65,19 +89,23 @@ pub mod string;\n pub mod vec;\n pub mod vec_map;\n \n+#[stable]\n pub mod bitv {\n     pub use bit::{Bitv, Iter};\n }\n \n+#[stable]\n pub mod bitv_set {\n     pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n }\n \n+#[stable]\n pub mod btree_map {\n     pub use btree::map::*;\n }\n \n+#[stable]\n pub mod btree_set {\n     pub use btree::set::*;\n }\n@@ -109,8 +137,7 @@ mod prelude {\n     pub use core::iter::range;\n     pub use core::iter::{FromIterator, Extend, IteratorExt};\n     pub use core::iter::{Iterator, DoubleEndedIterator, RandomAccessIterator};\n-    pub use core::iter::{IteratorCloneExt, CloneIteratorExt};\n-    pub use core::iter::{IteratorOrdExt, MutableDoubleEndedIterator, ExactSizeIterator};\n+    pub use core::iter::{ExactSizeIterator};\n     pub use core::kinds::{Copy, Send, Sized, Sync};\n     pub use core::mem::drop;\n     pub use core::ops::{Drop, Fn, FnMut, FnOnce};"}, {"sha": "0c5929e8661d6d22870fbab4f215118834675009", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n /// Creates a `std::vec::Vec` containing the arguments.\n+// NOTE: remove after the next snapshot\n+#[cfg(stage0)]\n macro_rules! vec {\n     ($($e:expr),*) => ({\n         // leading _ to allow empty construction without a warning.\n@@ -21,3 +21,13 @@ macro_rules! vec {\n     ($($e:expr),+,) => (vec!($($e),+))\n }\n \n+/// Creates a `Vec` containing the arguments.\n+#[cfg(not(stage0))]\n+#[macro_export]\n+macro_rules! vec {\n+    ($($x:expr),*) => ({\n+        let xs: $crate::boxed::Box<[_]> = box [$($x),*];\n+        $crate::slice::SliceExt::into_vec(xs)\n+    });\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}"}, {"sha": "11775f62b1c547660826fcef88d1164d00cdf0be", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 309, "deletions": 22, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,12 +12,14 @@\n //! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n //! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n \n+#![stable]\n+\n use core::prelude::*;\n \n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{self, FromIterator, RandomAccessIterator};\n+use core::iter::{self, repeat, FromIterator, RandomAccessIterator};\n use core::kinds::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n@@ -30,11 +32,8 @@ use std::cmp;\n \n use alloc::heap;\n \n-static INITIAL_CAPACITY: uint = 8u; // 2^3\n-static MINIMUM_CAPACITY: uint = 2u;\n-\n-// FIXME(conventions): implement shrink_to_fit. Awkward with the current design, but it should\n-// be scrapped anyway. Defer to rewrite?\n+static INITIAL_CAPACITY: uint = 7u; // 2^3 - 1\n+static MINIMUM_CAPACITY: uint = 1u; // 2 - 1\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n #[stable]\n@@ -127,7 +126,20 @@ impl<T> RingBuf<T> {\n                       self.cap);\n         ptr::copy_memory(\n             self.ptr.offset(dst as int),\n-            self.ptr.offset(src as int) as *const T,\n+            self.ptr.offset(src as int),\n+            len);\n+    }\n+\n+    /// Copies a contiguous block of memory len long from src to dst\n+    #[inline]\n+    unsafe fn copy_nonoverlapping(&self, dst: uint, src: uint, len: uint) {\n+        debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        ptr::copy_nonoverlapping_memory(\n+            self.ptr.offset(dst as int),\n+            self.ptr.offset(src as int),\n             len);\n     }\n }\n@@ -143,7 +155,8 @@ impl<T> RingBuf<T> {\n     #[stable]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         // +1 since the ringbuffer always leaves one space empty\n-        let cap = cmp::max(n + 1, MINIMUM_CAPACITY).next_power_of_two();\n+        let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+        assert!(cap > n, \"capacity overflow\");\n         let size = cap.checked_mul(mem::size_of::<T>())\n                       .expect(\"capacity overflow\");\n \n@@ -346,31 +359,134 @@ impl<T> RingBuf<T> {\n                 // Nop\n             } else if self.head < oldcap - self.tail { // B\n                 unsafe {\n-                    ptr::copy_nonoverlapping_memory(\n-                        self.ptr.offset(oldcap as int),\n-                        self.ptr as *const T,\n-                        self.head\n-                    );\n+                    self.copy_nonoverlapping(oldcap, 0, self.head);\n                 }\n                 self.head += oldcap;\n                 debug_assert!(self.head > self.tail);\n             } else { // C\n+                let new_tail = count - (oldcap - self.tail);\n+                unsafe {\n+                    self.copy_nonoverlapping(new_tail, self.tail, oldcap - self.tail);\n+                }\n+                self.tail = new_tail;\n+                debug_assert!(self.head < self.tail);\n+            }\n+            debug_assert!(self.head < self.cap);\n+            debug_assert!(self.tail < self.cap);\n+            debug_assert!(self.cap.count_ones() == 1);\n+        }\n+    }\n+\n+    /// Shrinks the capacity of the ringbuf as much as possible.\n+    ///\n+    /// It will drop down as close as possible to the length but the allocator may still inform the\n+    /// ringbuf that there is space for a few more elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::with_capacity(15);\n+    /// buf.extend(range(0u, 4));\n+    /// assert_eq!(buf.capacity(), 15);\n+    /// buf.shrink_to_fit();\n+    /// assert!(buf.capacity() >= 4);\n+    /// ```\n+    pub fn shrink_to_fit(&mut self) {\n+        // +1 since the ringbuffer always leaves one space empty\n+        // len + 1 can't overflow for an existing, well-formed ringbuf.\n+        let target_cap = cmp::max(self.len() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+        if target_cap < self.cap {\n+            // There are three cases of interest:\n+            //   All elements are out of desired bounds\n+            //   Elements are contiguous, and head is out of desired bounds\n+            //   Elements are discontiguous, and tail is out of desired bounds\n+            //\n+            // At all other times, element positions are unaffected.\n+            //\n+            // Indicates that elements at the head should be moved.\n+            let head_outside = self.head == 0 || self.head >= target_cap;\n+            // Move elements from out of desired bounds (positions after target_cap)\n+            if self.tail >= target_cap && head_outside {\n+                //                    T             H\n+                //   [. . . . . . . . o o o o o o o . ]\n+                //    T             H\n+                //   [o o o o o o o . ]\n+                unsafe {\n+                    self.copy_nonoverlapping(0, self.tail, self.len());\n+                }\n+                self.head = self.len();\n+                self.tail = 0;\n+            } else if self.tail != 0 && self.tail < target_cap && head_outside {\n+                //          T             H\n+                //   [. . . o o o o o o o . . . . . . ]\n+                //        H T\n+                //   [o o . o o o o o ]\n+                let len = self.wrap_index(self.head - target_cap);\n+                unsafe {\n+                    self.copy_nonoverlapping(0, target_cap, len);\n+                }\n+                self.head = len;\n+                debug_assert!(self.head < self.tail);\n+            } else if self.tail >= target_cap {\n+                //              H                 T\n+                //   [o o o o o . . . . . . . . . o o ]\n+                //              H T\n+                //   [o o o o o . o o ]\n+                debug_assert!(self.wrap_index(self.head - 1) < target_cap);\n+                let len = self.cap - self.tail;\n+                let new_tail = target_cap - len;\n                 unsafe {\n-                    ptr::copy_nonoverlapping_memory(\n-                        self.ptr.offset((count - (oldcap - self.tail)) as int),\n-                        self.ptr.offset(self.tail as int) as *const T,\n-                        oldcap - self.tail\n-                    );\n+                    self.copy_nonoverlapping(new_tail, self.tail, len);\n                 }\n-                self.tail = count - (oldcap - self.tail);\n+                self.tail = new_tail;\n                 debug_assert!(self.head < self.tail);\n             }\n+\n+            if mem::size_of::<T>() != 0 {\n+                let old = self.cap * mem::size_of::<T>();\n+                let new_size = target_cap * mem::size_of::<T>();\n+                unsafe {\n+                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n+                                                old,\n+                                                new_size,\n+                                                mem::min_align_of::<T>()) as *mut T;\n+                    if self.ptr.is_null() { ::alloc::oom() }\n+                }\n+            }\n+            self.cap = target_cap;\n             debug_assert!(self.head < self.cap);\n             debug_assert!(self.tail < self.cap);\n             debug_assert!(self.cap.count_ones() == 1);\n         }\n     }\n \n+    /// Shorten a ringbuf, dropping excess elements from the back.\n+    ///\n+    /// If `len` is greater than the ringbuf's current length, this has no\n+    /// effect.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(5i);\n+    /// buf.push_back(10i);\n+    /// buf.push_back(15);\n+    /// buf.truncate(1);\n+    /// assert_eq!(buf.len(), 1);\n+    /// assert_eq!(Some(&5), buf.get(0));\n+    /// ```\n+    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    pub fn truncate(&mut self, len: uint) {\n+        for _ in range(len, self.len()) {\n+            self.pop_back();\n+        }\n+    }\n+\n     /// Returns a front-to-back iterator.\n     ///\n     /// # Examples\n@@ -735,6 +851,70 @@ impl<T> RingBuf<T> {\n         self.tail <= self.head\n     }\n \n+    /// Removes an element from anywhere in the ringbuf and returns it, replacing it with the last\n+    /// element.\n+    ///\n+    /// This does not preserve ordering, but is O(1).\n+    ///\n+    /// Returns `None` if `index` is out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// assert_eq!(buf.swap_back_remove(0), None);\n+    /// buf.push_back(5i);\n+    /// buf.push_back(99);\n+    /// buf.push_back(15);\n+    /// buf.push_back(20);\n+    /// buf.push_back(10);\n+    /// assert_eq!(buf.swap_back_remove(1), Some(99));\n+    /// ```\n+    #[unstable = \"the naming of this function may be altered\"]\n+    pub fn swap_back_remove(&mut self, index: uint) -> Option<T> {\n+        let length = self.len();\n+        if length > 0 && index < length - 1 {\n+            self.swap(index, length - 1);\n+        } else if index >= length {\n+            return None;\n+        }\n+        self.pop_back()\n+    }\n+\n+    /// Removes an element from anywhere in the ringbuf and returns it, replacing it with the first\n+    /// element.\n+    ///\n+    /// This does not preserve ordering, but is O(1).\n+    ///\n+    /// Returns `None` if `index` is out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// assert_eq!(buf.swap_front_remove(0), None);\n+    /// buf.push_back(15i);\n+    /// buf.push_back(5);\n+    /// buf.push_back(10);\n+    /// buf.push_back(99);\n+    /// buf.push_back(20i);\n+    /// assert_eq!(buf.swap_front_remove(3), Some(99));\n+    /// ```\n+    #[unstable = \"the naming of this function may be altered\"]\n+    pub fn swap_front_remove(&mut self, index: uint) -> Option<T> {\n+        let length = self.len();\n+        if length > 0 && index < length && index != 0 {\n+            self.swap(index, 0);\n+        } else if index >= length {\n+            return None;\n+        }\n+        self.pop_front()\n+    }\n+\n     /// Inserts an element at position `i` within the ringbuf. Whichever\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n@@ -743,7 +923,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// Panics if `i` is greater than ringbuf's length\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```rust\n     /// use std::collections::RingBuf;\n     ///\n@@ -945,7 +1125,7 @@ impl<T> RingBuf<T> {\n     /// room, and all the affected elements will be moved to new positions.\n     /// Returns `None` if `i` is out of bounds.\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```rust\n     /// use std::collections::RingBuf;\n     ///\n@@ -990,7 +1170,7 @@ impl<T> RingBuf<T> {\n         let distance_to_tail = i;\n         let distance_to_head = self.len() - i;\n \n-        let contiguous = self.tail <= self.head;\n+        let contiguous = self.is_contiguous();\n \n         match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n             (true, true, _) => unsafe {\n@@ -1105,6 +1285,37 @@ impl<T> RingBuf<T> {\n     }\n }\n \n+impl<T: Clone> RingBuf<T> {\n+    /// Modifies the ringbuf in-place so that `len()` is equal to new_len,\n+    /// either by removing excess elements or by appending copies of a value to the back.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(5i);\n+    /// buf.push_back(10i);\n+    /// buf.push_back(15);\n+    /// buf.resize(2, 0);\n+    /// buf.resize(6, 20);\n+    /// for (a, b) in [5, 10, 20, 20, 20, 20].iter().zip(buf.iter()) {\n+    ///     assert_eq!(a, b);\n+    /// }\n+    /// ```\n+    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    pub fn resize(&mut self, new_len: uint, value: T) {\n+        let len = self.len();\n+\n+        if new_len > len {\n+            self.extend(repeat(value).take(new_len - len))\n+        } else {\n+            self.truncate(new_len);\n+        }\n+    }\n+}\n+\n /// Returns the index in the underlying buffer for a given logical element index.\n #[inline]\n fn wrap_index(index: uint, size: uint) -> uint {\n@@ -2270,6 +2481,50 @@ mod tests {\n         assert_eq!(ring.get_mut(2), None);\n     }\n \n+    #[test]\n+    fn test_swap_front_back_remove() {\n+        fn test(back: bool) {\n+            // This test checks that every single combination of tail position and length is tested.\n+            // Capacity 15 should be large enough to cover every case.\n+            let mut tester = RingBuf::with_capacity(15);\n+            let usable_cap = tester.capacity();\n+            let final_len = usable_cap / 2;\n+\n+            for len in range(0, final_len) {\n+                let expected = if back {\n+                    range(0, len).collect()\n+                } else {\n+                    range(0, len).rev().collect()\n+                };\n+                for tail_pos in range(0, usable_cap) {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    if back {\n+                        for i in range(0, len * 2) {\n+                            tester.push_front(i);\n+                        }\n+                        for i in range(0, len) {\n+                            assert_eq!(tester.swap_back_remove(i), Some(len * 2 - 1 - i));\n+                        }\n+                    } else {\n+                        for i in range(0, len * 2) {\n+                            tester.push_back(i);\n+                        }\n+                        for i in range(0, len) {\n+                            let idx = tester.len() - 1 - i;\n+                            assert_eq!(tester.swap_front_remove(idx), Some(len * 2 - 1 - i));\n+                        }\n+                    }\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+        test(true);\n+        test(false);\n+    }\n+\n     #[test]\n     fn test_insert() {\n         // This test checks that every single combination of tail position, length, and\n@@ -2341,6 +2596,38 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_shrink_to_fit() {\n+        // This test checks that every single combination of head and tail position,\n+        // is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = RingBuf::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+        tester.reserve(63);\n+        let max_cap = tester.capacity();\n+\n+        for len in range(0, cap + 1) {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in range(0, max_cap + 1) {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                tester.reserve(63);\n+                for i in range(0, len) {\n+                    tester.push_back(i);\n+                }\n+                tester.shrink_to_fit();\n+                assert!(tester.capacity() <= cap);\n+                assert!(tester.tail < tester.cap);\n+                assert!(tester.head < tester.cap);\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_front() {\n         let mut ring = RingBuf::new();"}, {"sha": "9e5aa7d645ba0ac8783b745add1fd592013dbe88", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -86,6 +86,7 @@\n //! * Further iterators exist that split, chunk or permute the slice.\n \n #![doc(primitive = \"slice\")]\n+#![stable]\n \n use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n@@ -119,8 +120,9 @@ pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Allocating extension methods for slices.\n-#[unstable = \"needs associated types, may merge with other traits\"]\n-pub trait SliceExt for Sized? {\n+#[stable]\n+pub trait SliceExt {\n+    #[stable]\n     type Item;\n \n     /// Sorts the slice, in place, using `compare` to compare\n@@ -699,7 +701,7 @@ pub trait SliceExt for Sized? {\n     fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -989,7 +991,7 @@ impl<T> SliceExt for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n #[unstable = \"U should be an associated type\"]\n /// An extension trait for concatenating slices\n-pub trait SliceConcatExt<Sized? T, U> for Sized? {\n+pub trait SliceConcatExt<T: ?Sized, U> {\n     /// Flattens a slice of `T` into a single value `U`.\n     #[stable]\n     fn concat(&self) -> U;\n@@ -1090,6 +1092,7 @@ struct SizeDirection {\n     dir: Direction,\n }\n \n+#[stable]\n impl Iterator for ElementSwaps {\n     type Item = (uint, uint);\n \n@@ -2460,13 +2463,13 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        macro_rules! test_show_vec(\n+        macro_rules! test_show_vec {\n             ($x:expr, $x_str:expr) => ({\n                 let (x, x_str) = ($x, $x_str);\n                 assert_eq!(format!(\"{}\", x), x_str);\n                 assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n             })\n-        );\n+        }\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\");\n         test_show_vec!(vec![1i], \"[1]\");\n@@ -2486,12 +2489,12 @@ mod tests {\n \n     #[test]\n     fn test_vec_default() {\n-        macro_rules! t (\n+        macro_rules! t {\n             ($ty:ty) => {{\n                 let v: $ty = Default::default();\n                 assert!(v.is_empty());\n             }}\n-        );\n+        }\n \n         t!(&[int]);\n         t!(Vec<int>);"}, {"sha": "c0482702ccdb66c1a6ee149ebaa0811d7a66808b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -50,6 +50,7 @@\n //! is the same as `&[u8]`.\n \n #![doc(primitive = \"str\")]\n+#![stable]\n \n use self::RecompositionState::*;\n use self::DecompositionType::*;\n@@ -59,7 +60,6 @@ use core::char::CharExt;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n use core::iter::{range, Iterator, IteratorExt};\n-use core::kinds::Sized;\n use core::ops;\n use core::option::Option::{self, Some, None};\n use core::slice::AsSlice;\n@@ -165,13 +165,15 @@ enum DecompositionType {\n /// External iterator for a string's decomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n+#[unstable]\n pub struct Decompositions<'a> {\n     kind: DecompositionType,\n     iter: Chars<'a>,\n     buffer: Vec<(char, u8)>,\n     sorted: bool\n }\n \n+#[stable]\n impl<'a> Iterator for Decompositions<'a> {\n     type Item = char;\n \n@@ -253,6 +255,7 @@ enum RecompositionState {\n /// External iterator for a string's recomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n+#[unstable]\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n@@ -261,6 +264,7 @@ pub struct Recompositions<'a> {\n     last_ccc: Option<u8>\n }\n \n+#[stable]\n impl<'a> Iterator for Recompositions<'a> {\n     type Item = char;\n \n@@ -348,10 +352,12 @@ impl<'a> Iterator for Recompositions<'a> {\n /// External iterator for a string's UTF16 codeunits.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n+#[unstable]\n pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n \n+#[stable]\n impl<'a> Iterator for Utf16Units<'a> {\n     type Item = u16;\n \n@@ -401,7 +407,8 @@ Section: Trait implementations\n */\n \n /// Any string that can be represented as a slice.\n-pub trait StrExt for Sized?: ops::Slice<uint, str> {\n+#[stable]\n+pub trait StrExt: ops::Slice<uint, str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n     #[unstable = \"return type may change to be an iterator\"]\n     fn escape_default(&self) -> String {\n@@ -1340,6 +1347,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     }\n }\n \n+#[stable]\n impl StrExt for str {}\n \n #[cfg(test)]\n@@ -1838,7 +1846,9 @@ mod tests {\n     #[test]\n     fn test_is_utf16() {\n         use unicode::str::is_utf16;\n-        macro_rules! pos ( ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } });\n+        macro_rules! pos {\n+            ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } }\n+        }\n \n         // non-surrogates\n         pos!(&[0x0000],\n@@ -1858,7 +1868,9 @@ mod tests {\n              &[0x0067, 0xd8ff, 0xddb7, 0x000f, 0xd900, 0xdc80]);\n \n         // negative tests\n-        macro_rules! neg ( ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } });\n+        macro_rules! neg {\n+            ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } }\n+        }\n \n         neg!(\n             // surrogate + regular unit"}, {"sha": "0bf311e4d3f6e5674bc1eb9fd32f097087bea6e4", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -182,15 +182,15 @@ impl String {\n             let byte = unsafe_get(v, i);\n             i += 1;\n \n-            macro_rules! error(() => ({\n+            macro_rules! error { () => ({\n                 unsafe {\n                     if subseqidx != i_ {\n                         res.as_mut_vec().push_all(v[subseqidx..i_]);\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n                 }\n-            }));\n+            })}\n \n             if byte < 128u8 {\n                 // subseqidx handles this\n@@ -320,30 +320,6 @@ impl String {\n         }\n     }\n \n-    /// Creates a `String` from a null-terminated `*const u8` buffer.\n-    ///\n-    /// This function is unsafe because we dereference memory until we find the\n-    /// NUL character, which is not guaranteed to be present. Additionally, the\n-    /// slice is not checked to see whether it contains valid UTF-8\n-    #[unstable = \"just renamed from `mod raw`\"]\n-    pub unsafe fn from_raw_buf(buf: *const u8) -> String {\n-        String::from_str(str::from_c_str(buf as *const i8))\n-    }\n-\n-    /// Creates a `String` from a `*const u8` buffer of the given length.\n-    ///\n-    /// This function is unsafe because it blindly assumes the validity of the\n-    /// pointer `buf` for `len` bytes of memory. This function will copy the\n-    /// memory from `buf` into a new allocation (owned by the returned\n-    /// `String`).\n-    ///\n-    /// This function is also unsafe because it does not validate that the\n-    /// buffer is valid UTF-8 encoded data.\n-    #[unstable = \"just renamed from `mod raw`\"]\n-    pub unsafe fn from_raw_buf_len(buf: *const u8, len: uint) -> String {\n-        String::from_utf8_unchecked(Vec::from_raw_buf(buf, len))\n-    }\n-\n     /// Converts a vector of bytes to a new `String` without checking if\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n@@ -711,7 +687,7 @@ impl fmt::Show for FromUtf16Error {\n     }\n }\n \n-#[experimental = \"waiting on FromIterator stabilization\"]\n+#[stable]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -720,7 +696,7 @@ impl FromIterator<char> for String {\n     }\n }\n \n-#[experimental = \"waiting on FromIterator stabilization\"]\n+#[stable]\n impl<'a> FromIterator<&'a str> for String {\n     fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -832,7 +808,7 @@ impl<H: hash::Writer> hash::Hash<H> for String {\n     }\n }\n \n-#[experimental = \"waiting on Add stabilization\"]\n+#[unstable = \"recent addition, needs more experience\"]\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n \n@@ -864,7 +840,7 @@ impl ops::Slice<uint, str> for String {\n     }\n }\n \n-#[experimental = \"waiting on Deref stabilization\"]\n+#[stable]\n impl ops::Deref for String {\n     type Target = str;\n \n@@ -1126,24 +1102,6 @@ mod tests {\n                    String::from_str(\"\\u{FFFD}\ud801\udc8b\\u{FFFD}\"));\n     }\n \n-    #[test]\n-    fn test_from_buf_len() {\n-        unsafe {\n-            let a = vec![65u8, 65, 65, 65, 65, 65, 65, 0];\n-            assert_eq!(String::from_raw_buf_len(a.as_ptr(), 3), String::from_str(\"AAA\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_buf() {\n-        unsafe {\n-            let a = vec![65, 65, 65, 65, 65, 65, 65, 0];\n-            let b = a.as_ptr();\n-            let c = String::from_raw_buf(b);\n-            assert_eq!(c, String::from_str(\"AAAAAAA\"));\n-        }\n-    }\n-\n     #[test]\n     fn test_push_bytes() {\n         let mut s = String::from_str(\"ABC\");"}, {"sha": "99231e7253c3ce31f48baa0f8929ac9fdbcf156c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -1251,19 +1251,19 @@ impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n     }\n }\n \n-#[experimental = \"waiting on Deref stability\"]\n+#[stable]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n     fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n }\n \n-#[experimental = \"waiting on DerefMut stability\"]\n+#[stable]\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n }\n \n-#[experimental = \"waiting on FromIterator stability\"]\n+#[stable]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n@@ -1393,6 +1393,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n+#[unstable = \"recent addition, needs more experience\"]\n impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n     type Output = Vec<T>;\n \n@@ -1404,6 +1405,7 @@ impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n@@ -1449,6 +1451,7 @@ impl<'a> fmt::Writer for Vec<u8> {\n /// A clone-on-write vector\n pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n+#[unstable]\n impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n     fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> {\n         Cow::Owned(FromIterator::from_iter(it))\n@@ -1494,6 +1497,7 @@ impl<T> IntoIter<T> {\n     }\n }\n \n+#[stable]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1530,6 +1534,7 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n+#[stable]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n@@ -1553,9 +1558,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n     }\n }\n \n+#[stable]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n #[unsafe_destructor]\n+#[stable]\n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n@@ -1577,6 +1584,7 @@ pub struct Drain<'a, T> {\n     marker: ContravariantLifetime<'a>,\n }\n \n+#[stable]\n impl<'a, T> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1613,6 +1621,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n@@ -1636,9 +1645,11 @@ impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n #[unsafe_destructor]\n+#[stable]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         // self.ptr == self.end == null if drop has already been called,\n@@ -1671,7 +1682,7 @@ impl<'a, T> Deref for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[unsafe_destructor]\n-#[experimental]\n+#[stable]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;"}, {"sha": "15c20253c8bc78b1c739b28c14215e9484886455", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -86,15 +86,15 @@ pub struct AtomicBool {\n unsafe impl Sync for AtomicBool {}\n \n /// A signed integer type which can be safely shared between threads.\n-#[stable]\n+#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n pub struct AtomicInt {\n     v: UnsafeCell<int>,\n }\n \n unsafe impl Sync for AtomicInt {}\n \n /// An unsigned integer type which can be safely shared between threads.\n-#[stable]\n+#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n pub struct AtomicUint {\n     v: UnsafeCell<uint>,\n }\n@@ -146,28 +146,18 @@ pub enum Ordering {\n }\n \n /// An `AtomicBool` initialized to `false`.\n-#[unstable = \"may be renamed, pending conventions for static initalizers\"]\n+#[stable]\n pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicInt` initialized to `0`.\n-#[unstable = \"may be renamed, pending conventions for static initalizers\"]\n+#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n pub const ATOMIC_INT_INIT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 } };\n /// An `AtomicUint` initialized to `0`.\n-#[unstable = \"may be renamed, pending conventions for static initalizers\"]\n+#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n pub const ATOMIC_UINT_INIT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, } };\n \n-/// Deprecated\n-#[deprecated = \"renamed to ATOMIC_BOOL_INIT\"]\n-pub const INIT_ATOMIC_BOOL: AtomicBool = ATOMIC_BOOL_INIT;\n-/// Deprecated\n-#[deprecated = \"renamed to ATOMIC_INT_INIT\"]\n-pub const INIT_ATOMIC_INT: AtomicInt = ATOMIC_INT_INIT;\n-/// Deprecated\n-#[deprecated = \"renamed to ATOMIC_UINT_INIT\"]\n-pub const INIT_ATOMIC_UINT: AtomicUint = ATOMIC_UINT_INIT;\n-\n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n \n@@ -413,6 +403,7 @@ impl AtomicBool {\n     }\n }\n \n+#[unstable = \"awaiting int/uint conventions, types may change\"]\n impl AtomicInt {\n     /// Creates a new `AtomicInt`.\n     ///\n@@ -424,7 +415,6 @@ impl AtomicInt {\n     /// let atomic_forty_two  = AtomicInt::new(42);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn new(v: int) -> AtomicInt {\n         AtomicInt {v: UnsafeCell::new(v)}\n     }\n@@ -447,7 +437,6 @@ impl AtomicInt {\n     /// let value = some_int.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n@@ -470,7 +459,6 @@ impl AtomicInt {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n     pub fn store(&self, val: int, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n@@ -489,7 +477,6 @@ impl AtomicInt {\n     /// let value = some_int.swap(10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn swap(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -511,7 +498,6 @@ impl AtomicInt {\n     /// let value = some_int.compare_and_swap(5, 10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -528,7 +514,6 @@ impl AtomicInt {\n     /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -545,7 +530,6 @@ impl AtomicInt {\n     /// assert_eq!(-10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -561,7 +545,6 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -577,7 +560,6 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -593,12 +575,12 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n+#[unstable = \"awaiting int/uint conventions, types may change\"]\n impl AtomicUint {\n     /// Creates a new `AtomicUint`.\n     ///\n@@ -610,7 +592,6 @@ impl AtomicUint {\n     /// let atomic_forty_two = AtomicUint::new(42u);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn new(v: uint) -> AtomicUint {\n         AtomicUint { v: UnsafeCell::new(v) }\n     }\n@@ -633,7 +614,6 @@ impl AtomicUint {\n     /// let value = some_uint.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n@@ -656,7 +636,6 @@ impl AtomicUint {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n     pub fn store(&self, val: uint, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n@@ -675,7 +654,6 @@ impl AtomicUint {\n     /// let value = some_uint.swap(10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn swap(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -697,7 +675,6 @@ impl AtomicUint {\n     /// let value = some_uint.compare_and_swap(5, 10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -714,7 +691,6 @@ impl AtomicUint {\n     /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -731,7 +707,6 @@ impl AtomicUint {\n     /// assert_eq!(0, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -747,7 +722,6 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -763,7 +737,6 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -779,7 +752,6 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }"}, {"sha": "2c08b97635580c0504df846247a117644a491602", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -53,57 +53,61 @@ use option::Option;\n use self::Cow::*;\n \n /// A trait for borrowing data.\n-pub trait BorrowFrom<Sized? Owned> for Sized? {\n+#[old_orphan_check]\n+pub trait BorrowFrom<Owned: ?Sized> {\n     /// Immutably borrow from an owned value.\n     fn borrow_from(owned: &Owned) -> &Self;\n }\n \n /// A trait for mutably borrowing data.\n-pub trait BorrowFromMut<Sized? Owned> for Sized? : BorrowFrom<Owned> {\n+#[old_orphan_check]\n+pub trait BorrowFromMut<Owned: ?Sized> : BorrowFrom<Owned> {\n     /// Mutably borrow from an owned value.\n     fn borrow_from_mut(owned: &mut Owned) -> &mut Self;\n }\n \n-impl<Sized? T> BorrowFrom<T> for T {\n+impl<T: ?Sized> BorrowFrom<T> for T {\n     fn borrow_from(owned: &T) -> &T { owned }\n }\n \n-impl<Sized? T> BorrowFromMut<T> for T {\n+impl<T: ?Sized> BorrowFromMut<T> for T {\n     fn borrow_from_mut(owned: &mut T) -> &mut T { owned }\n }\n \n-impl<'a, Sized? T> BorrowFrom<&'a T> for T {\n+impl<'a, T: ?Sized> BorrowFrom<&'a T> for T {\n     fn borrow_from<'b>(owned: &'b &'a T) -> &'b T { &**owned }\n }\n \n-impl<'a, Sized? T> BorrowFrom<&'a mut T> for T {\n+impl<'a, T: ?Sized> BorrowFrom<&'a mut T> for T {\n     fn borrow_from<'b>(owned: &'b &'a mut T) -> &'b T { &**owned }\n }\n \n-impl<'a, Sized? T> BorrowFromMut<&'a mut T> for T {\n+impl<'a, T: ?Sized> BorrowFromMut<&'a mut T> for T {\n     fn borrow_from_mut<'b>(owned: &'b mut &'a mut T) -> &'b mut T { &mut **owned }\n }\n \n-impl<'a, T, Sized? B> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n     fn borrow_from<'b>(owned: &'b Cow<'a, T, B>) -> &'b B {\n         &**owned\n     }\n }\n \n /// Trait for moving into a `Cow`\n-pub trait IntoCow<'a, T, Sized? B> {\n+#[old_orphan_check]\n+pub trait IntoCow<'a, T, B: ?Sized> {\n     /// Moves `self` into `Cow`\n     fn into_cow(self) -> Cow<'a, T, B>;\n }\n \n-impl<'a, T, Sized? B> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> {\n     fn into_cow(self) -> Cow<'a, T, B> {\n         self\n     }\n }\n \n /// A generalization of Clone to borrowed data.\n-pub trait ToOwned<Owned> for Sized?: BorrowFrom<Owned> {\n+#[old_orphan_check]\n+pub trait ToOwned<Owned>: BorrowFrom<Owned> {\n     /// Create owned data from borrowed data, usually by copying.\n     fn to_owned(&self) -> Owned;\n }\n@@ -129,7 +133,7 @@ impl<T> ToOwned<T> for T where T: Clone {\n ///     }\n /// }\n /// ```\n-pub enum Cow<'a, T, Sized? B: 'a> where B: ToOwned<T> {\n+pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     /// Borrowed data.\n     Borrowed(&'a B),\n \n@@ -138,7 +142,7 @@ pub enum Cow<'a, T, Sized? B: 'a> where B: ToOwned<T> {\n }\n \n #[stable]\n-impl<'a, T, Sized? B> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n         match *self {\n             Borrowed(b) => Borrowed(b),\n@@ -150,7 +154,7 @@ impl<'a, T, Sized? B> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> {\n     /// Acquire a mutable reference to the owned form of the data.\n     ///\n     /// Copies the data if it is not already owned.\n@@ -191,7 +195,8 @@ impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-impl<'a, T, Sized? B> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n+#[stable]\n+impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     type Target = B;\n \n     fn deref(&self) -> &B {\n@@ -203,18 +208,18 @@ impl<'a, T, Sized? B> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n }\n \n #[stable]\n-impl<'a, T, Sized? B> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n+impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n \n #[stable]\n-impl<'a, T, Sized? B> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n+impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n #[stable]\n-impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n+impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n     B: PartialEq<C> + ToOwned<T>,\n     C: ToOwned<U>,\n {\n@@ -225,14 +230,14 @@ impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B\n }\n \n #[stable]\n-impl<'a, T, Sized? B> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n+impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n-impl<'a, T, Sized? B> fmt::Show for Cow<'a, T, B> where B: fmt::Show + ToOwned<T>, T: fmt::Show {\n+impl<'a, T, B: ?Sized> fmt::Show for Cow<'a, T, B> where B: fmt::Show + ToOwned<T>, T: fmt::Show {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Borrowed(ref b) => fmt::Show::fmt(b, f),"}, {"sha": "fd18d6ac3f3b409e389b599e5292343feccb720f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -419,7 +419,7 @@ pub struct Ref<'b, T:'b> {\n     _borrow: BorrowRef<'b>,\n }\n \n-#[unstable = \"waiting for `Deref` to become stable\"]\n+#[stable]\n impl<'b, T> Deref for Ref<'b, T> {\n     type Target = T;\n \n@@ -477,7 +477,7 @@ pub struct RefMut<'b, T:'b> {\n     _borrow: BorrowRefMut<'b>,\n }\n \n-#[unstable = \"waiting for `Deref` to become stable\"]\n+#[stable]\n impl<'b, T> Deref for RefMut<'b, T> {\n     type Target = T;\n \n@@ -487,7 +487,7 @@ impl<'b, T> Deref for RefMut<'b, T> {\n     }\n }\n \n-#[unstable = \"waiting for `DerefMut` to become stable\"]\n+#[stable]\n impl<'b, T> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {"}, {"sha": "caac894c0daa327c5ccf98edb285de9014b7fa08", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -314,6 +314,7 @@ pub struct EscapeUnicode {\n }\n \n #[derive(Clone)]\n+#[unstable]\n enum EscapeUnicodeState {\n     Backslash,\n     Type,\n@@ -375,6 +376,7 @@ pub struct EscapeDefault {\n }\n \n #[derive(Clone)]\n+#[unstable]\n enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),"}, {"sha": "17991659f97899c6027021eae8a8dceecccd54a6", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -43,7 +43,7 @@ pub trait Clone : Sized {\n }\n \n #[stable]\n-impl<'a, Sized? T> Clone for &'a T {\n+impl<'a, T: ?Sized> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n     fn clone(&self) -> &'a T { *self }"}, {"sha": "af5e98ed303240a9684c8207d9f4375eb208ccac", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -69,7 +69,8 @@ use option::Option::{self, Some, None};\n /// only if `a != b`.\n #[lang=\"eq\"]\n #[stable]\n-pub trait PartialEq<Sized? Rhs = Self> for Sized? {\n+#[old_orphan_check]\n+pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n     #[stable]\n     fn eq(&self, other: &Rhs) -> bool;\n@@ -90,7 +91,7 @@ pub trait PartialEq<Sized? Rhs = Self> for Sized? {\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n #[stable]\n-pub trait Eq for Sized?: PartialEq<Self> {\n+pub trait Eq: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n     // itself, the current deriving infrastructure means doing this\n@@ -164,7 +165,7 @@ impl Ordering {\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n #[stable]\n-pub trait Ord for Sized?: Eq + PartialOrd<Self> {\n+pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n     /// By convention, `self.cmp(&other)` returns the ordering matching\n@@ -224,7 +225,7 @@ impl PartialOrd for Ordering {\n /// 5.11).\n #[lang=\"ord\"]\n #[stable]\n-pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n+pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n     #[stable]\n@@ -428,14 +429,14 @@ mod impls {\n     // & pointers\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n@@ -450,24 +451,24 @@ mod impls {\n         fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Ord for &'a A where A: Ord {\n+    impl<'a, A: ?Sized> Ord for &'a A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Eq for &'a A where A: Eq {}\n+    impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}\n \n     // &mut pointers\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n@@ -482,23 +483,23 @@ mod impls {\n         fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Ord for &'a mut A where A: Ord {\n+    impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Eq for &'a mut A where A: Eq {}\n+    impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]"}, {"sha": "951f5c29f00e8c923c5520e0bb9c0c341360f7b7", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -20,12 +20,15 @@ use mem;\n use option::Option;\n use option::Option::{Some, None};\n use ops::{Deref, FnOnce};\n-use result::Result::{Ok, Err};\n+use result::Result::Ok;\n use result;\n use slice::SliceExt;\n use slice;\n use str::{self, StrExt, Utf8Error};\n \n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::Err;\n+\n pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n@@ -78,9 +81,9 @@ pub trait Writer {\n         // This Adapter is needed to allow `self` (of type `&mut\n         // Self`) to be cast to a FormatWriter (below) without\n         // requiring a `Sized` bound.\n-        struct Adapter<'a,Sized? T:'a>(&'a mut T);\n+        struct Adapter<'a,T: ?Sized +'a>(&'a mut T);\n \n-        impl<'a, Sized? T> Writer for Adapter<'a, T>\n+        impl<'a, T: ?Sized> Writer for Adapter<'a, T>\n             where T: Writer\n         {\n             fn write_str(&mut self, s: &str) -> Result {\n@@ -222,57 +225,57 @@ impl<'a> Show for Arguments<'a> {\n /// to this trait. There is not an explicit way of selecting this trait to be\n /// used for formatting, it is only if no other format is specified.\n #[unstable = \"I/O and core have yet to be reconciled\"]\n-pub trait Show for Sized? {\n+pub trait Show {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n \n /// Format trait for the `o` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n-pub trait Octal for Sized? {\n+pub trait Octal {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `b` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n-pub trait Binary for Sized? {\n+pub trait Binary {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `x` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n-pub trait LowerHex for Sized? {\n+pub trait LowerHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `X` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n-pub trait UpperHex for Sized? {\n+pub trait UpperHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `p` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n-pub trait Pointer for Sized? {\n+pub trait Pointer {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `e` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n-pub trait LowerExp for Sized? {\n+pub trait LowerExp {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `E` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n-pub trait UpperExp for Sized? {\n+pub trait UpperExp {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n@@ -592,10 +595,10 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n \n // Implementations of the core formatting traits\n \n-impl<'a, Sized? T: Show> Show for &'a T {\n+impl<'a, T: ?Sized + Show> Show for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n-impl<'a, Sized? T: Show> Show for &'a mut T {\n+impl<'a, T: ?Sized + Show> Show for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n "}, {"sha": "d8b9cf9594d6aab4cfb7ed4eedf15a06ef00aa08", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -76,7 +76,7 @@ pub mod sip;\n /// A hashable type. The `S` type parameter is an abstract hash state that is\n /// used by the `Hash` to compute the hash. It defaults to\n /// `std::hash::sip::SipState`.\n-pub trait Hash<S = sip::SipState> for Sized? {\n+pub trait Hash<S = sip::SipState> {\n     /// Computes the hash of a value.\n     fn hash(&self, state: &mut S);\n }\n@@ -85,7 +85,7 @@ pub trait Hash<S = sip::SipState> for Sized? {\n /// containers like `HashMap`, which need a generic way hash multiple types.\n pub trait Hasher<S> {\n     /// Compute the hash of a value.\n-    fn hash<Sized? T: Hash<S>>(&self, value: &T) -> u64;\n+    fn hash<T: ?Sized + Hash<S>>(&self, value: &T) -> u64;\n }\n \n #[allow(missing_docs)]\n@@ -194,14 +194,14 @@ impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n }\n \n \n-impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a T {\n+impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n \n-impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a mut T {\n+impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n@@ -233,7 +233,7 @@ impl<S: Writer> Hash<S> for TypeId {\n     }\n }\n \n-impl<'a, T, Sized? B, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n+impl<'a, T, B: ?Sized, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         Hash::hash(&**self, state)"}, {"sha": "c4d45e9c2c80454802496457b1f8e3b17dc3762f", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -239,7 +239,7 @@ impl SipHasher {\n \n impl Hasher<SipState> for SipHasher {\n     #[inline]\n-    fn hash<Sized? T: Hash<SipState>>(&self, value: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<SipState>>(&self, value: &T) -> u64 {\n         let mut state = SipState::new_with_keys(self.k0, self.k1);\n         value.hash(&mut state);\n         state.result()\n@@ -255,15 +255,15 @@ impl Default for SipHasher {\n \n /// Hashes a value using the SipHash algorithm.\n #[inline]\n-pub fn hash<Sized? T: Hash<SipState>>(value: &T) -> u64 {\n+pub fn hash<T: ?Sized + Hash<SipState>>(value: &T) -> u64 {\n     let mut state = SipState::new();\n     value.hash(&mut state);\n     state.result()\n }\n \n /// Hashes a value with the SipHash algorithm with the provided keys.\n #[inline]\n-pub fn hash_with_keys<Sized? T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n+pub fn hash_with_keys<T: ?Sized + Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n     let mut state = SipState::new_with_keys(k0, k1);\n     value.hash(&mut state);\n     state.result()"}, {"sha": "e5753f6cc2e7857e6e76c3a7cc3d4eaa5e151b89", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 348, "deletions": 362, "changes": 710, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -54,6 +54,8 @@\n //!\n //! This `for` loop syntax can be applied to any iterator over any type.\n \n+#![stable]\n+\n use self::MinMaxResult::*;\n \n use clone::Clone;\n@@ -79,38 +81,94 @@ use uint;\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n #[lang=\"iterator\"]\n-#[unstable = \"just split up for object safety\"]\n+#[stable]\n pub trait Iterator {\n+    #[stable]\n     type Item;\n \n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n+    #[stable]\n     fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n     /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n     /// does not fit within a `uint`.\n     #[inline]\n+    #[stable]\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n /// Conversion from an `Iterator`\n-#[unstable = \"may be replaced by a more general conversion trait\"]\n+#[stable]\n pub trait FromIterator<A> {\n     /// Build a container with elements from an external iterator.\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n /// A type growable from an `Iterator` implementation\n-#[unstable = \"just renamed as part of collections reform\"]\n+#[stable]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n }\n \n-#[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n+#[stable]\n pub trait IteratorExt: Iterator + Sized {\n+    /// Counts the number of elements in this iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert!(it.count() == 5);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn count(self) -> uint {\n+        self.fold(0, |cnt, _x| cnt + 1)\n+    }\n+\n+    /// Loops through the entire iterator, returning the last element of the\n+    /// iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// assert!(a.iter().last().unwrap() == &5);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn last(mut self) -> Option< <Self as Iterator>::Item> {\n+        let mut last = None;\n+        for x in self { last = Some(x); }\n+        last\n+    }\n+\n+    /// Loops through `n` iterations, returning the `n`th element of the\n+    /// iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert!(it.nth(2).unwrap() == &3);\n+    /// assert!(it.nth(2) == None);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn nth(&mut self, mut n: uint) -> Option< <Self as Iterator>::Item> {\n+        for x in *self {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+\n     /// Chain this iterator with another, returning a new iterator that will\n     /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n@@ -169,7 +227,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn map<B, F>(self, f: F) -> Map< <Self as Iterator>::Item, B, Self, F> where\n         F: FnMut(<Self as Iterator>::Item) -> B,\n     {\n@@ -189,7 +247,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn filter<P>(self, predicate: P) -> Filter< <Self as Iterator>::Item, Self, P> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -209,7 +267,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn filter_map<B, F>(self, f: F) -> FilterMap< <Self as Iterator>::Item, B, Self, F> where\n         F: FnMut(<Self as Iterator>::Item) -> Option<B>,\n     {\n@@ -258,9 +316,9 @@ pub trait IteratorExt: Iterator + Sized {\n         Peekable{iter: self, peeked: None}\n     }\n \n-    /// Creates an iterator that invokes the predicate on elements until it\n-    /// returns false. Once the predicate returns false, all further elements are\n-    /// yielded.\n+    /// Creates an iterator that invokes the predicate on elements\n+    /// until it returns false. Once the predicate returns false, that\n+    /// element and all further elements are yielded.\n     ///\n     /// # Example\n     ///\n@@ -273,7 +331,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn skip_while<P>(self, predicate: P) -> SkipWhile< <Self as Iterator>::Item, Self, P> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -294,7 +352,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, may want to require peek\"]\n+    #[stable]\n     fn take_while<P>(self, predicate: P) -> TakeWhile< <Self as Iterator>::Item, Self, P> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -359,7 +417,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn scan<St, B, F>(\n         self,\n         initial_state: St,\n@@ -389,7 +447,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn flat_map<B, U, F>(self, f: F) -> FlatMap< <Self as Iterator>::Item, B, Self, U, F> where\n         U: Iterator<Item=B>,\n         F: FnMut(<Self as Iterator>::Item) -> U,\n@@ -449,7 +507,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn inspect<F>(self, f: F) -> Inspect< <Self as Iterator>::Item, Self, F> where\n         F: FnMut(&<Self as Iterator>::Item),\n     {\n@@ -487,7 +545,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for general conversion traits, just changed to take self by value\"]\n+    #[stable]\n     fn collect<B: FromIterator< <Self as Iterator>::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n@@ -522,44 +580,6 @@ pub trait IteratorExt: Iterator + Sized {\n         (left, right)\n     }\n \n-    /// Loops through `n` iterations, returning the `n`th element of the\n-    /// iterator.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert!(it.nth(2).unwrap() == &3);\n-    /// assert!(it.nth(2) == None);\n-    /// ```\n-    #[inline]\n-    #[stable]\n-    fn nth(&mut self, mut n: uint) -> Option< <Self as Iterator>::Item> {\n-        for x in *self {\n-            if n == 0 { return Some(x) }\n-            n -= 1;\n-        }\n-        None\n-    }\n-\n-    /// Loops through the entire iterator, returning the last element of the\n-    /// iterator.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// assert!(a.iter().last().unwrap() == &5);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"just changed to take self by value\"]\n-    fn last(mut self) -> Option< <Self as Iterator>::Item> {\n-        let mut last = None;\n-        for x in self { last = Some(x); }\n-        last\n-    }\n-\n     /// Performs a fold operation over the entire iterator, returning the\n     /// eventual state at the end of the iteration.\n     ///\n@@ -570,7 +590,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[stable]\n     fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n         F: FnMut(B, <Self as Iterator>::Item) -> B,\n     {\n@@ -581,21 +601,6 @@ pub trait IteratorExt: Iterator + Sized {\n         accum\n     }\n \n-    /// Counts the number of elements in this iterator.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert!(it.count() == 5);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"just changed to take self by value\"]\n-    fn count(self) -> uint {\n-        self.fold(0, |cnt, _x| cnt + 1)\n-    }\n-\n     /// Tests whether the predicate holds true for all elements in the iterator.\n     ///\n     /// # Example\n@@ -606,7 +611,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[stable]\n     fn all<F>(mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n@@ -624,7 +629,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!it.any(|x| *x == 3));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n@@ -634,7 +639,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn find<P>(&mut self, mut predicate: P) -> Option< <Self as Iterator>::Item> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -646,7 +651,7 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n         P: FnMut(<Self as Iterator>::Item) -> bool,\n     {\n@@ -660,6 +665,145 @@ pub trait IteratorExt: Iterator + Sized {\n         None\n     }\n \n+    /// Return the index of the last element satisfying the specified predicate\n+    ///\n+    /// If no element matches, None is returned.\n+    #[inline]\n+    #[stable]\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n+        P: FnMut(<Self as Iterator>::Item) -> bool,\n+        Self: ExactSizeIterator + DoubleEndedIterator\n+    {\n+        let len = self.len();\n+        for i in range(0, len).rev() {\n+            if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n+                return Some(i);\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Consumes the entire iterator to return the maximum element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// assert!(a.iter().max().unwrap() == &5);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn max(self) -> Option< <Self as Iterator>::Item> where\n+        <Self as Iterator>::Item: Ord\n+    {\n+        self.fold(None, |max, x| {\n+            match max {\n+                None    => Some(x),\n+                Some(y) => Some(cmp::max(x, y))\n+            }\n+        })\n+    }\n+\n+    /// Consumes the entire iterator to return the minimum element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// assert!(a.iter().min().unwrap() == &1);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn min(self) -> Option< <Self as Iterator>::Item> where\n+        <Self as Iterator>::Item: Ord\n+    {\n+        self.fold(None, |min, x| {\n+            match min {\n+                None    => Some(x),\n+                Some(y) => Some(cmp::min(x, y))\n+            }\n+        })\n+    }\n+\n+    /// `min_max` finds the minimum and maximum elements in the iterator.\n+    ///\n+    /// The return type `MinMaxResult` is an enum of three variants:\n+    ///\n+    /// - `NoElements` if the iterator is empty.\n+    /// - `OneElement(x)` if the iterator has exactly one element.\n+    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n+    ///    values are equal if and only if there is more than one\n+    ///    element in the iterator and all elements are equal.\n+    ///\n+    /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n+    /// and so is faster than calling `min` and `max` separately which does `2 * n` comparisons.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n+    ///\n+    /// let v: [int; 0] = [];\n+    /// assert_eq!(v.iter().min_max(), NoElements);\n+    ///\n+    /// let v = [1i];\n+    /// assert!(v.iter().min_max() == OneElement(&1));\n+    ///\n+    /// let v = [1i, 2, 3, 4, 5];\n+    /// assert!(v.iter().min_max() == MinMax(&1, &5));\n+    ///\n+    /// let v = [1i, 2, 3, 4, 5, 6];\n+    /// assert!(v.iter().min_max() == MinMax(&1, &6));\n+    ///\n+    /// let v = [1i, 1, 1, 1];\n+    /// assert!(v.iter().min_max() == MinMax(&1, &1));\n+    /// ```\n+    #[unstable = \"return type may change\"]\n+    fn min_max(mut self) -> MinMaxResult< <Self as Iterator>::Item> where\n+        <Self as Iterator>::Item: Ord\n+    {\n+        let (mut min, mut max) = match self.next() {\n+            None => return NoElements,\n+            Some(x) => {\n+                match self.next() {\n+                    None => return OneElement(x),\n+                    Some(y) => if x < y {(x, y)} else {(y,x)}\n+                }\n+            }\n+        };\n+\n+        loop {\n+            // `first` and `second` are the two next elements we want to look at.\n+            // We first compare `first` and `second` (#1). The smaller one is then compared to\n+            // current minimum (#2). The larger one is compared to current maximum (#3). This\n+            // way we do 3 comparisons for 2 elements.\n+            let first = match self.next() {\n+                None => break,\n+                Some(x) => x\n+            };\n+            let second = match self.next() {\n+                None => {\n+                    if first < min {\n+                        min = first;\n+                    } else if first > max {\n+                        max = first;\n+                    }\n+                    break;\n+                }\n+                Some(x) => x\n+            };\n+            if first < second {\n+                if first < min {min = first;}\n+                if max < second {max = second;}\n+            } else {\n+                if second < min {min = second;}\n+                if max < first {max = first;}\n+            }\n+        }\n+\n+        MinMax(min, max)\n+    }\n+\n     /// Return the element that gives the maximum value from the\n     /// specified function.\n     ///\n@@ -672,7 +816,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n     fn max_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n         F: FnMut(&<Self as Iterator>::Item) -> B,\n     {\n@@ -701,7 +845,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n     fn min_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n         F: FnMut(&<Self as Iterator>::Item) -> B,\n     {\n@@ -740,6 +884,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n     /// each item into one new container, and the second component into another.\n+    #[unstable = \"recent addition\"]\n     fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n@@ -759,56 +904,73 @@ pub trait IteratorExt: Iterator + Sized {\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        ts.extend(SizeHint(lo, hi));\n-        us.extend(SizeHint(lo, hi));\n+        ts.extend(SizeHint(lo, hi));\n+        us.extend(SizeHint(lo, hi));\n+\n+        for (t, u) in self {\n+            ts.extend(Some(t).into_iter());\n+            us.extend(Some(u).into_iter());\n+        }\n+\n+        (ts, us)\n+    }\n+\n+    /// Creates an iterator that clones the elements it yields. Useful for converting an\n+    /// Iterator<&T> to an Iterator<T>.\n+    #[unstable = \"recent addition\"]\n+    fn cloned<T, D>(self) -> Cloned<Self> where\n+        Self: Iterator<Item=D>,\n+        D: Deref<Target=T>,\n+        T: Clone,\n+    {\n+        Cloned { it: self }\n+    }\n+\n+    /// Repeats an iterator endlessly\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::iter::count;\n+    ///\n+    /// let a = count(1i,1i).take(1);\n+    /// let mut cy = a.cycle();\n+    /// assert_eq!(cy.next(), Some(1));\n+    /// assert_eq!(cy.next(), Some(1));\n+    /// ```\n+    #[stable]\n+    #[inline]\n+    fn cycle(self) -> Cycle<Self> where Self: Clone {\n+        Cycle{orig: self.clone(), iter: self}\n+    }\n \n-        for (t, u) in self {\n-            ts.extend(Some(t).into_iter());\n-            us.extend(Some(u).into_iter());\n+    /// Use an iterator to reverse a container in place.\n+    #[experimental = \"uncertain about placement or widespread use\"]\n+    fn reverse_in_place<'a, T: 'a>(&mut self) where\n+        Self: Iterator<Item=&'a mut T> + DoubleEndedIterator\n+    {\n+        loop {\n+            match (self.next(), self.next_back()) {\n+                (Some(x), Some(y)) => mem::swap(x, y),\n+                _ => break\n+            }\n         }\n-\n-        (ts, us)\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> IteratorExt for I where I: Iterator {}\n \n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n /// elements from the *same* range, and do not work independently of each other.\n-#[unstable = \"recently split into two traits\"]\n+#[stable]\n pub trait DoubleEndedIterator: Iterator {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n     fn next_back(&mut self) -> Option< <Self as Iterator>::Item>;\n }\n \n-/// A double-ended iterator yielding mutable references\n-#[experimental = \"not widely used\"]\n-pub trait MutableDoubleEndedIterator {\n-    // FIXME: #5898: should be called `reverse`\n-    /// Use an iterator to reverse a container in-place\n-    fn reverse_(&mut self);\n-}\n-\n-#[experimental = \"trait is experimental\"]\n-impl<'a, T:'a, I> MutableDoubleEndedIterator for I where\n-    I: DoubleEndedIterator + Iterator<Item=&'a mut T>,\n-{\n-    // FIXME: #5898: should be called `reverse`\n-    /// Use an iterator to reverse a container in-place\n-    fn reverse_(&mut self) {\n-        loop {\n-            match (self.next(), self.next_back()) {\n-                (Some(x), Some(y)) => mem::swap(x, y),\n-                _ => break\n-            }\n-        }\n-    }\n-}\n-\n-\n /// An object implementing random access indexing by `uint`\n ///\n /// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n@@ -832,24 +994,8 @@ pub trait RandomAccessIterator: Iterator {\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `uint`.\n-#[unstable = \"could move DoubleEndedIterator bound onto rposition with method-level where clauses\"]\n-pub trait ExactSizeIterator: DoubleEndedIterator {\n-    /// Return the index of the last element satisfying the specified predicate\n-    ///\n-    /// If no element matches, None is returned.\n-    #[inline]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n-        P: FnMut(<Self as Iterator>::Item) -> bool,\n-    {\n-        let len = self.len();\n-        for i in range(0, len).rev() {\n-            if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n-                return Some(i);\n-            }\n-        }\n-        None\n-    }\n-\n+#[stable]\n+pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     /// Return the exact length of the iterator.\n     fn len(&self) -> uint {\n@@ -865,21 +1011,21 @@ pub trait ExactSizeIterator: DoubleEndedIterator {\n \n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n     I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n {}\n-#[unstable = \"trait is unstable\"]\n-impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator {}\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n+impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n+#[stable]\n impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n     I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n@@ -890,7 +1036,7 @@ pub struct Rev<T> {\n     iter: T\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -900,7 +1046,7 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next() }\n@@ -924,7 +1070,7 @@ pub struct ByRef<'a, I:'a> {\n     iter: &'a mut I,\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -934,7 +1080,7 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next_back() }\n@@ -1025,134 +1171,9 @@ impl_multiplicative! { uint, 1 }\n impl_multiplicative! { f32,  1.0 }\n impl_multiplicative! { f64,  1.0 }\n \n-/// A trait for iterators over elements which can be compared to one another.\n-#[unstable = \"recently renamed for new extension trait conventions\"]\n-pub trait IteratorOrdExt<A> {\n-    /// Consumes the entire iterator to return the maximum element.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// assert!(a.iter().max().unwrap() == &5);\n-    /// ```\n-    fn max(self) -> Option<A>;\n-\n-    /// Consumes the entire iterator to return the minimum element.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// assert!(a.iter().min().unwrap() == &1);\n-    /// ```\n-    fn min(self) -> Option<A>;\n-\n-    /// `min_max` finds the minimum and maximum elements in the iterator.\n-    ///\n-    /// The return type `MinMaxResult` is an enum of three variants:\n-    ///\n-    /// - `NoElements` if the iterator is empty.\n-    /// - `OneElement(x)` if the iterator has exactly one element.\n-    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n-    ///    values are equal if and only if there is more than one\n-    ///    element in the iterator and all elements are equal.\n-    ///\n-    /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n-    /// and so is faster than calling `min` and `max` separately which does `2 * n` comparisons.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n-    ///\n-    /// let v: [int; 0] = [];\n-    /// assert_eq!(v.iter().min_max(), NoElements);\n-    ///\n-    /// let v = [1i];\n-    /// assert!(v.iter().min_max() == OneElement(&1));\n-    ///\n-    /// let v = [1i, 2, 3, 4, 5];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &5));\n-    ///\n-    /// let v = [1i, 2, 3, 4, 5, 6];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &6));\n-    ///\n-    /// let v = [1i, 1, 1, 1];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &1));\n-    /// ```\n-    fn min_max(self) -> MinMaxResult<A>;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T, I> IteratorOrdExt<T> for I where I: Iterator<Item=T>, T: Ord {\n-    #[inline]\n-    fn max(self) -> Option<T> {\n-        self.fold(None, |max, x| {\n-            match max {\n-                None    => Some(x),\n-                Some(y) => Some(cmp::max(x, y))\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn min(self) -> Option<T> {\n-        self.fold(None, |min, x| {\n-            match min {\n-                None    => Some(x),\n-                Some(y) => Some(cmp::min(x, y))\n-            }\n-        })\n-    }\n-\n-    fn min_max(mut self) -> MinMaxResult<T> {\n-        let (mut min, mut max) = match self.next() {\n-            None => return NoElements,\n-            Some(x) => {\n-                match self.next() {\n-                    None => return OneElement(x),\n-                    Some(y) => if x < y {(x, y)} else {(y,x)}\n-                }\n-            }\n-        };\n-\n-        loop {\n-            // `first` and `second` are the two next elements we want to look at.\n-            // We first compare `first` and `second` (#1). The smaller one is then compared to\n-            // current minimum (#2). The larger one is compared to current maximum (#3). This\n-            // way we do 3 comparisons for 2 elements.\n-            let first = match self.next() {\n-                None => break,\n-                Some(x) => x\n-            };\n-            let second = match self.next() {\n-                None => {\n-                    if first < min {\n-                        min = first;\n-                    } else if first > max {\n-                        max = first;\n-                    }\n-                    break;\n-                }\n-                Some(x) => x\n-            };\n-            if first < second {\n-                if first < min {min = first;}\n-                if max < second {max = second;}\n-            } else {\n-                if second < min {min = second;}\n-                if max < first {max = first;}\n-            }\n-        }\n-\n-        MinMax(min, max)\n-    }\n-}\n-\n /// `MinMaxResult` is an enum returned by `min_max`. See `IteratorOrdExt::min_max` for more detail.\n #[derive(Clone, PartialEq, Show)]\n-#[unstable = \"waiting on namespaced enum conventions\"]\n+#[unstable = \"unclear whether such a fine-grained result is widely useful\"]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -1164,7 +1185,6 @@ pub enum MinMaxResult<T> {\n     MinMax(T, T)\n }\n \n-#[stable]\n impl<T: Clone> MinMaxResult<T> {\n     /// `into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n     /// `None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n@@ -1185,6 +1205,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r = MinMax(1i,2i);\n     /// assert_eq!(r.into_option(), Some((1,2)));\n     /// ```\n+    #[unstable = \"type is unstable\"]\n     pub fn into_option(self) -> Option<(T,T)> {\n         match self {\n             NoElements => None,\n@@ -1194,30 +1215,15 @@ impl<T: Clone> MinMaxResult<T> {\n     }\n }\n \n-/// A trait for iterators that contain cloneable elements\n-#[unstable = \"recently renamed for extension trait conventions\"]\n-pub trait IteratorCloneExt<A> {\n-    /// Creates an iterator that clones the elements it yields. Useful for converting an\n-    /// Iterator<&T> to an Iterator<T>.\n-    fn cloned(self) -> Cloned<Self>;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T, D, I> IteratorCloneExt<T> for I where\n-    T: Clone,\n-    D: Deref<Target=T>,\n-    I: Iterator<Item=D>,\n-{\n-    fn cloned(self) -> Cloned<I> {\n-        Cloned { it: self }\n-    }\n-}\n-\n /// An iterator that clones the elements of an underlying iterator\n+#[unstable = \"recent addition\"]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[derive(Clone)]\n pub struct Cloned<I> {\n     it: I,\n }\n \n+#[stable]\n impl<T, D, I> Iterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1234,6 +1240,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n     }\n }\n \n+#[stable]\n impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1244,39 +1251,13 @@ impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, D, I> ExactSizeIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n     I: ExactSizeIterator + Iterator<Item=D>,\n {}\n \n-#[unstable = \"recently renamed for extension trait conventions\"]\n-/// An extension trait for cloneable iterators.\n-pub trait CloneIteratorExt {\n-    /// Repeats an iterator endlessly\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::iter::{CloneIteratorExt, count};\n-    ///\n-    /// let a = count(1i,1i).take(1);\n-    /// let mut cy = a.cycle();\n-    /// assert_eq!(cy.next(), Some(1));\n-    /// assert_eq!(cy.next(), Some(1));\n-    /// ```\n-    #[stable]\n-    fn cycle(self) -> Cycle<Self>;\n-}\n-\n-impl<I> CloneIteratorExt for I where I: Iterator + Clone {\n-    #[inline]\n-    fn cycle(self) -> Cycle<I> {\n-        Cycle{orig: self.clone(), iter: self}\n-    }\n-}\n-\n /// An iterator that repeats endlessly\n #[derive(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -1286,6 +1267,7 @@ pub struct Cycle<I> {\n     iter: I,\n }\n \n+#[stable]\n impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1345,7 +1327,7 @@ pub struct Chain<A, B> {\n     flag: bool,\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1379,7 +1361,7 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     A: DoubleEndedIterator + Iterator<Item=T>,\n     B: DoubleEndedIterator + Iterator<Item=T>,\n@@ -1424,7 +1406,7 @@ pub struct Zip<A, B> {\n     b: B\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, U, A, B> Iterator for Zip<A, B> where\n     A: Iterator<Item = T>,\n     B: Iterator<Item = U>,\n@@ -1460,10 +1442,10 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n-    A: ExactSizeIterator + Iterator<Item=T>,\n-    B: ExactSizeIterator + Iterator<Item=U>,\n+    A: ExactSizeIterator + Iterator<Item=T> + DoubleEndedIterator,\n+    B: ExactSizeIterator + Iterator<Item=U> + DoubleEndedIterator,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(T, U)> {\n@@ -1539,7 +1521,7 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     type Item = B;\n \n@@ -1555,7 +1537,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1606,7 +1588,7 @@ impl<A, I, P> Clone for Filter<A, I, P> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1629,7 +1611,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     P: FnMut(&A) -> bool,\n@@ -1667,7 +1649,7 @@ impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1692,7 +1674,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1718,7 +1700,7 @@ pub struct Enumerate<I> {\n     count: uint\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n     type Item = (uint, <I as Iterator>::Item);\n \n@@ -1740,8 +1722,10 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n-impl<I> DoubleEndedIterator for Enumerate<I> where I: ExactSizeIterator {\n+#[stable]\n+impl<I> DoubleEndedIterator for Enumerate<I> where\n+    I: ExactSizeIterator + DoubleEndedIterator\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n         match self.iter.next_back() {\n@@ -1779,6 +1763,7 @@ pub struct Peekable<T, I> where I: Iterator<Item=T> {\n     peeked: Option<T>,\n }\n \n+#[stable]\n impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1850,7 +1835,7 @@ impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1896,7 +1881,7 @@ impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1935,7 +1920,7 @@ pub struct Skip<I> {\n     n: uint\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2005,7 +1990,7 @@ pub struct Take<I> {\n     n: uint\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Take<I> where I: Iterator{\n     type Item = <I as Iterator>::Item;\n \n@@ -2054,7 +2039,7 @@ impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n \n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[unstable = \"waiting for unboxed closures\"]\n+#[stable]\n pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n     iter: I,\n     f: F,\n@@ -2079,7 +2064,7 @@ impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(&mut St, A) -> Option<B>,\n@@ -2102,7 +2087,7 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n /// and yields the elements of the produced iterators\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[unstable = \"waiting for unboxed closures\"]\n+#[stable]\n pub struct FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2131,7 +2116,7 @@ impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2166,7 +2151,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     U: DoubleEndedIterator + Iterator<Item=B>,\n@@ -2199,7 +2184,7 @@ pub struct Fuse<I> {\n     done: bool\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Fuse<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2228,7 +2213,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option< <I as Iterator>::Item> {\n@@ -2260,11 +2245,11 @@ impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     }\n }\n \n-#[experimental = \"seems marginal\"]\n impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n+    #[experimental = \"seems marginal\"]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2273,7 +2258,7 @@ impl<I> Fuse<I> {\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[unstable = \"waiting for unboxed closures\"]\n+#[stable]\n pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     iter: I,\n     f: F,\n@@ -2305,7 +2290,7 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     type Item = A;\n \n@@ -2321,7 +2306,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n@@ -2416,7 +2401,7 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     }\n }\n \n-#[experimental]\n+#[stable]\n impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     type Item = A;\n \n@@ -2435,7 +2420,7 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n #[derive(Clone, Copy)]\n-#[unstable = \"may be renamed\"]\n+#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n     state: A,\n@@ -2445,12 +2430,12 @@ pub struct Counter<A> {\n \n /// Creates a new counter with the specified start/step\n #[inline]\n-#[unstable = \"may be renamed\"]\n+#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n     type Item = A;\n \n@@ -2469,7 +2454,7 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n \n /// An iterator over the range [start, stop)\n #[derive(Clone, Copy)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"will be replaced by range notation\"]\n pub struct Range<A> {\n     state: A,\n     stop: A,\n@@ -2490,6 +2475,7 @@ pub struct Range<A> {\n /// }\n /// ```\n #[inline]\n+#[unstable = \"will be replaced by range notation\"]\n pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n     Range {\n         state: start,\n@@ -2499,7 +2485,7 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n }\n \n // FIXME: #10414: Unfortunate type bound\n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"will be replaced by range notation\"]\n impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     type Item = A;\n \n@@ -2549,7 +2535,7 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"will be replaced by range notation\"]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2564,23 +2550,23 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n \n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub struct RangeInclusive<A> {\n     range: Range<A>,\n     done: bool,\n }\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n         range: range(start, stop),\n         done: false,\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     type Item = A;\n \n@@ -2615,7 +2601,7 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2634,7 +2620,7 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n \n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub struct RangeStep<A> {\n     state: A,\n     stop: A,\n@@ -2644,13 +2630,13 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int> Iterator for RangeStep<A> {\n     type Item = A;\n \n@@ -2671,7 +2657,7 @@ impl<A: Int> Iterator for RangeStep<A> {\n \n /// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub struct RangeStepInclusive<A> {\n     state: A,\n     stop: A,\n@@ -2682,7 +2668,7 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Int::zero();\n     RangeStepInclusive {\n@@ -2694,7 +2680,7 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int> Iterator for RangeStepInclusive<A> {\n     type Item = A;\n \n@@ -2719,7 +2705,7 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n /// directions. The `steps_between` function provides a way to\n /// compare two Step objects (it could be provided using `step()` and `Ord`,\n /// but the implementation would be so inefficient as to be useless).\n-#[unstable = \"Trait is unstable.\"]\n+#[unstable = \"design of range notation/iteration is in flux\"]\n pub trait Step: Ord {\n     /// Change self to the next object.\n     fn step(&mut self);\n@@ -2779,7 +2765,7 @@ pub struct Repeat<A> {\n     element: A\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n@@ -2789,7 +2775,7 @@ impl<A: Clone> Iterator for Repeat<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n@@ -2855,7 +2841,7 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n-#[experimental = \"likely to be removed after cmp reform\"]\n+#[unstable = \"needs review and revision\"]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}, {"sha": "5d69938fccff702adc1d8184f4503c3c899a26af", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -19,19 +19,19 @@\n \n /// Types able to be transferred across task boundaries.\n #[lang=\"send\"]\n-pub unsafe trait Send for Sized? : 'static {\n+pub unsafe trait Send : 'static {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n #[lang=\"sized\"]\n-pub trait Sized for Sized? {\n+pub trait Sized {\n     // Empty.\n }\n \n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n #[lang=\"copy\"]\n-pub trait Copy for Sized? {\n+pub trait Copy {\n     // Empty.\n }\n \n@@ -81,7 +81,7 @@ pub trait Copy for Sized? {\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n #[lang=\"sync\"]\n-pub unsafe trait Sync for Sized? {\n+pub unsafe trait Sync {\n     // Empty\n }\n \n@@ -133,10 +133,10 @@ pub mod marker {\n     /// for some lifetime `'a`, but not the other way around).\n     #[lang=\"covariant_type\"]\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct CovariantType<Sized? T>;\n+    pub struct CovariantType<T: ?Sized>;\n \n-    impl<Sized? T> Copy for CovariantType<T> {}\n-    impl<Sized? T> Clone for CovariantType<T> {\n+    impl<T: ?Sized> Copy for CovariantType<T> {}\n+    impl<T: ?Sized> Clone for CovariantType<T> {\n         fn clone(&self) -> CovariantType<T> { *self }\n     }\n \n@@ -181,10 +181,10 @@ pub mod marker {\n     /// arguments of type `U`, hence such a conversion is safe.\n     #[lang=\"contravariant_type\"]\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct ContravariantType<Sized? T>;\n+    pub struct ContravariantType<T: ?Sized>;\n \n-    impl<Sized? T> Copy for ContravariantType<T> {}\n-    impl<Sized? T> Clone for ContravariantType<T> {\n+    impl<T: ?Sized> Copy for ContravariantType<T> {}\n+    impl<T: ?Sized> Clone for ContravariantType<T> {\n         fn clone(&self) -> ContravariantType<T> { *self }\n     }\n \n@@ -211,10 +211,10 @@ pub mod marker {\n     /// interior mutability.\n     #[lang=\"invariant_type\"]\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct InvariantType<Sized? T>;\n+    pub struct InvariantType<T: ?Sized>;\n \n-    impl<Sized? T> Copy for InvariantType<T> {}\n-    impl<Sized? T> Clone for InvariantType<T> {\n+    impl<T: ?Sized> Copy for InvariantType<T> {}\n+    impl<T: ?Sized> Clone for InvariantType<T> {\n         fn clone(&self) -> InvariantType<T> { *self }\n     }\n "}, {"sha": "aff0065c52744d8d8430b8d7b9c69ef9125213cd", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -62,11 +62,24 @@\n #![feature(default_type_params, unboxed_closures, associated_types)]\n #![deny(missing_docs)]\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod macros;\n \n-#[path = \"num/float_macros.rs\"] mod float_macros;\n-#[path = \"num/int_macros.rs\"]   mod int_macros;\n-#[path = \"num/uint_macros.rs\"]  mod uint_macros;\n+#[path = \"num/float_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod float_macros;\n+\n+#[path = \"num/int_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod int_macros;\n+\n+#[path = \"num/uint_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod uint_macros;\n \n #[path = \"num/int.rs\"]  pub mod int;\n #[path = \"num/i8.rs\"]   pub mod i8;\n@@ -130,6 +143,7 @@ mod array;\n #[doc(hidden)]\n mod core {\n     pub use panicking;\n+    pub use fmt;\n }\n \n #[doc(hidden)]"}, {"sha": "a579f9db4161c3a8f04b1742a1f53d1602a7e96a", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 177, "deletions": 24, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n /// Entry point of task panic, for details, see std::macros\n #[macro_export]\n macro_rules! panic {\n@@ -30,69 +28,224 @@ macro_rules! panic {\n     });\n }\n \n-/// Runtime assertion, for details see std::macros\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// assert!(true);\n+/// # fn some_computation() -> bool { true }\n+/// assert!(some_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n #[macro_export]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n             panic!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n-    ($cond:expr, $($arg:tt)*) => (\n+    ($cond:expr, $($arg:expr),+) => (\n         if !$cond {\n-            panic!($($arg)*)\n+            panic!($($arg),+)\n         }\n     );\n }\n \n-/// Runtime assertion for equality, for details see std::macros\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// assert_eq!(a, b);\n+/// ```\n #[macro_export]\n macro_rules! assert_eq {\n-    ($cond1:expr, $cond2:expr) => ({\n-        let c1 = $cond1;\n-        let c2 = $cond2;\n-        if c1 != c2 || c2 != c1 {\n-            panic!(\"expressions not equal, left: {}, right: {}\", c1, c2);\n+    ($left:expr , $right:expr) => ({\n+        match (&($left), &($right)) {\n+            (left_val, right_val) => {\n+                // check both directions of equality....\n+                if !((*left_val == *right_val) &&\n+                     (*right_val == *left_val)) {\n+                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n+                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n+                }\n+            }\n         }\n     })\n }\n \n-/// Runtime assertion for equality, only without `--cfg ndebug`\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n+/// `--cfg ndebug` to the compiler. This makes `debug_assert!` useful for\n+/// checks that are too expensive to be present in a release build but may be\n+/// helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// debug_assert!(true);\n+/// # fn some_expensive_computation() -> bool { true }\n+/// debug_assert!(some_expensive_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// debug_assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! debug_assert {\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+}\n+\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n+/// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n+/// useful for checks that are too expensive to be present in a release build\n+/// but may be helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// debug_assert_eq!(a, b);\n+/// ```\n #[macro_export]\n macro_rules! debug_assert_eq {\n-    ($($a:tt)*) => ({\n-        if cfg!(not(ndebug)) {\n-            assert_eq!($($a)*);\n-        }\n-    })\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n }\n \n-/// Runtime assertion, disableable at compile time with `--cfg ndebug`\n+#[cfg(stage0)]\n #[macro_export]\n-macro_rules! debug_assert {\n-    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+macro_rules! try {\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n }\n \n /// Short circuiting evaluation on Err\n+///\n+/// `libstd` contains a more general `try!` macro that uses `FromError`.\n+#[cfg(not(stage0))]\n #[macro_export]\n macro_rules! try {\n-    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+    ($e:expr) => ({\n+        use $crate::result::Result::{Ok, Err};\n+\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(e),\n+        }\n+    })\n }\n \n-/// Writing a formatted string into a writer\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # #![allow(unused_must_use)]\n+///\n+/// let mut w = Vec::new();\n+/// write!(&mut w, \"test\");\n+/// write!(&mut w, \"formatted {}\", \"arguments\");\n+/// ```\n #[macro_export]\n macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n }\n \n-/// Writing a formatted string plus a newline into a writer\n+/// Equivalent to the `write!` macro, except that a newline is appended after\n+/// the message is written.\n #[macro_export]\n+#[stable]\n macro_rules! writeln {\n     ($dst:expr, $fmt:expr $($arg:tt)*) => (\n         write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n     )\n }\n \n+/// A utility macro for indicating unreachable code.\n+///\n+/// This is useful any time that the compiler can't determine that some code is unreachable. For\n+/// example:\n+///\n+/// * Match arms with guard conditions.\n+/// * Loops that dynamically terminate.\n+/// * Iterators that dynamically terminate.\n+///\n+/// # Panics\n+///\n+/// This will always panic.\n+///\n+/// # Examples\n+///\n+/// Match arms:\n+///\n+/// ```rust\n+/// fn foo(x: Option<int>) {\n+///     match x {\n+///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n+///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n+///         Some(_)           => unreachable!(), // compile error if commented out\n+///         None              => println!(\"None\")\n+///     }\n+/// }\n+/// ```\n+///\n+/// Iterators:\n+///\n+/// ```rust\n+/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n+///     for i in std::iter::count(0_u32, 1) {\n+///         if 3*i < i { panic!(\"u32 overflow\"); }\n+///         if x < 3*i { return i-1; }\n+///     }\n+///     unreachable!();\n+/// }\n+/// ```\n #[macro_export]\n-macro_rules! unreachable { () => (panic!(\"unreachable code\")) }\n+macro_rules! unreachable {\n+    () => ({\n+        panic!(\"internal error: entered unreachable code\")\n+    });\n+    ($msg:expr) => ({\n+        unreachable!(\"{}\", $msg)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n+    });\n+}\n \n+/// A standardised placeholder for marking unfinished code. It panics with the\n+/// message `\"not yet implemented\"` when executed.\n+#[macro_export]\n+macro_rules! unimplemented {\n+    () => (panic!(\"not yet implemented\"))\n+}"}, {"sha": "c60569161213f68949bed4524688bc4978982d93", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -320,7 +320,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a S,\n+pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n                                                         ptr: &T) -> &'a T {\n     transmute(ptr)\n }\n@@ -329,7 +329,7 @@ pub unsafe fn copy_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a S,\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_mut_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a mut S,\n+pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a mut S,\n                                                             ptr: &mut T)\n                                                             -> &'a mut T {\n     transmute(ptr)"}, {"sha": "20300d29fa0c5f1e66e5d255eb79bc5b1c11ed17", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! assert_approx_eq {"}, {"sha": "61cd8cbf7c10153da90d5f0da64168ae845e5e1a", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! int_module { ($T:ty, $bits:expr) => ("}, {"sha": "535765840a0fcacc345b9065311456d9e644bdf7", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => ("}, {"sha": "97d94e73bb33a0625764ba677ebdf97e49f8fe6f", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 90, "deletions": 16, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -59,6 +59,8 @@\n //! See the documentation for each trait for a minimum implementation that prints\n //! something to the screen.\n \n+#![stable]\n+\n use clone::Clone;\n use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use kinds::Sized;\n@@ -86,8 +88,10 @@ use option::Option::{self, Some, None};\n /// }\n /// ```\n #[lang=\"drop\"]\n+#[stable]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n+    #[stable]\n     fn drop(&mut self);\n }\n \n@@ -120,15 +124,19 @@ pub trait Drop {\n /// }\n /// ```\n #[lang=\"add\"]\n+#[stable]\n pub trait Add<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `+` operator\n+    #[stable]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Add for $t {\n             type Output = $t;\n \n@@ -169,15 +177,19 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"sub\"]\n+#[stable]\n pub trait Sub<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `-` operator\n+    #[stable]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Sub for $t {\n             type Output = $t;\n \n@@ -218,15 +230,19 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"mul\"]\n+#[stable]\n pub trait Mul<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `*` operator\n+    #[stable]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Mul for $t {\n             type Output = $t;\n \n@@ -267,15 +283,19 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"div\"]\n+#[stable]\n pub trait Div<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `/` operator\n+    #[stable]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Div for $t {\n             type Output = $t;\n \n@@ -316,15 +336,19 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"rem\"]\n+#[stable]\n pub trait Rem<RHS=Self> {\n+    #[stable]\n     type Output = Self;\n \n     /// The method for the `%` operator\n+    #[stable]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -336,6 +360,7 @@ macro_rules! rem_impl {\n \n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n+        #[stable]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -382,26 +407,33 @@ rem_float_impl! { f64, fmod }\n /// }\n /// ```\n #[lang=\"neg\"]\n+#[stable]\n pub trait Neg {\n+    #[stable]\n     type Output;\n \n     /// The method for the unary `-` operator\n+    #[stable]\n     fn neg(self) -> Self::Output;\n }\n \n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Neg for $t {\n+            #[stable]\n             type Output = $t;\n \n             #[inline]\n+            #[stable]\n             fn neg(self) -> $t { -self }\n         }\n     )*)\n }\n \n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n+        #[stable]\n         impl Neg for $t {\n             type Output = $t;\n \n@@ -450,15 +482,19 @@ neg_uint_impl! { u64, i64 }\n /// }\n /// ```\n #[lang=\"not\"]\n+#[stable]\n pub trait Not {\n+    #[stable]\n     type Output;\n \n     /// The method for the unary `!` operator\n+    #[stable]\n     fn not(self) -> Self::Output;\n }\n \n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Not for $t {\n             type Output = $t;\n \n@@ -499,15 +535,19 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitand\"]\n+#[stable]\n pub trait BitAnd<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `&` operator\n+    #[stable]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl BitAnd for $t {\n             type Output = $t;\n \n@@ -548,15 +588,19 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitor\"]\n+#[stable]\n pub trait BitOr<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `|` operator\n+    #[stable]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl BitOr for $t {\n             type Output = $t;\n \n@@ -597,15 +641,19 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitxor\"]\n+#[stable]\n pub trait BitXor<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `^` operator\n+    #[stable]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl BitXor for $t {\n             type Output = $t;\n \n@@ -646,15 +694,19 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shl\"]\n+#[stable]\n pub trait Shl<RHS> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `<<` operator\n+    #[stable]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! shl_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Shl<uint> for $t {\n             type Output = $t;\n \n@@ -697,10 +749,13 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shr\"]\n+#[stable]\n pub trait Shr<RHS> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `>>` operator\n+    #[stable]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n \n@@ -747,8 +802,8 @@ shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"index\"]\n-pub trait Index<Sized? Index> for Sized? {\n-    type Sized? Output;\n+pub trait Index<Index: ?Sized> {\n+    type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n@@ -784,8 +839,8 @@ pub trait Index<Sized? Index> for Sized? {\n /// }\n /// ```\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Sized? Index> for Sized? {\n-    type Sized? Output;\n+pub trait IndexMut<Index: ?Sized> {\n+    type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n@@ -829,7 +884,7 @@ pub trait IndexMut<Sized? Index> for Sized? {\n /// }\n /// ```\n #[lang=\"slice\"]\n-pub trait Slice<Sized? Idx, Sized? Result> for Sized? {\n+pub trait Slice<Idx: ?Sized, Result: ?Sized> {\n     /// The method for the slicing operation foo[]\n     fn as_slice_<'a>(&'a self) -> &'a Result;\n     /// The method for the slicing operation foo[from..]\n@@ -878,7 +933,7 @@ pub trait Slice<Sized? Idx, Sized? Result> for Sized? {\n /// }\n /// ```\n #[lang=\"slice_mut\"]\n-pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n+pub trait SliceMut<Idx: ?Sized, Result: ?Sized> {\n     /// The method for the slicing operation foo[]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Result;\n     /// The method for the slicing operation foo[from..]\n@@ -893,11 +948,13 @@ pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n /// An unbounded range.\n #[derive(Copy)]\n #[lang=\"full_range\"]\n+#[unstable = \"API still in development\"]\n pub struct FullRange;\n \n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy)]\n #[lang=\"range\"]\n+#[unstable = \"API still in development\"]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n@@ -907,6 +964,7 @@ pub struct Range<Idx> {\n \n // FIXME(#19391) needs a snapshot\n //impl<Idx: Clone + Step<T=uint>> Iterator<Idx> for Range<Idx> {\n+#[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     type Item = Idx;\n \n@@ -931,6 +989,7 @@ impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     }\n }\n \n+#[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     #[inline]\n     fn next_back(&mut self) -> Option<Idx> {\n@@ -943,16 +1002,19 @@ impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     }\n }\n \n+#[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n \n /// A range which is only bounded below.\n #[derive(Copy)]\n #[lang=\"range_from\"]\n+#[unstable = \"API still in development\"]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n+#[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n     type Item = Idx;\n \n@@ -968,6 +1030,7 @@ impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy)]\n #[lang=\"range_to\"]\n+#[unstable = \"API still in development\"]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n@@ -1005,20 +1068,25 @@ pub struct RangeTo<Idx> {\n /// }\n /// ```\n #[lang=\"deref\"]\n-pub trait Deref for Sized? {\n-    type Sized? Target;\n+#[stable]\n+pub trait Deref {\n+    #[stable]\n+    type Target: ?Sized;\n \n     /// The method called to dereference a value\n+    #[stable]\n     fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n-impl<'a, Sized? T> Deref for &'a T {\n+#[stable]\n+impl<'a, T: ?Sized> Deref for &'a T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n }\n \n-impl<'a, Sized? T> Deref for &'a mut T {\n+#[stable]\n+impl<'a, T: ?Sized> Deref for &'a mut T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n@@ -1062,38 +1130,44 @@ impl<'a, Sized? T> Deref for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n-pub trait DerefMut for Sized? : Deref {\n+#[stable]\n+pub trait DerefMut: Deref {\n     /// The method called to mutably dereference a value\n+    #[stable]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut <Self as Deref>::Target;\n }\n \n-impl<'a, Sized? T> DerefMut for &'a mut T {\n+#[stable]\n+impl<'a, T: ?Sized> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n \n /// A version of the call operator that takes an immutable receiver.\n #[lang=\"fn\"]\n-pub trait Fn<Args,Result> for Sized? {\n+#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n+pub trait Fn<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call(&self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n-pub trait FnMut<Args,Result> for Sized? {\n+#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n+pub trait FnMut<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n+#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n pub trait FnOnce<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_once(self, args: Args) -> Result;\n }\n \n-impl<Sized? F,A,R> FnMut<A,R> for F\n-    where F : Fn<A,R>\n+impl<F: ?Sized, A, R> FnMut<A, R> for F\n+    where F : Fn<A, R>\n {\n     extern \"rust-call\" fn call_mut(&mut self, args: A) -> R {\n         self.call(args)"}, {"sha": "39d0f024d4d4143f63c1419065d42481b8b5beb8", "filename": "src/libcore/option.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -807,6 +807,7 @@ impl<A> ExactSizeIterator for Item<A> {}\n #[stable]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n \n+#[stable]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -816,11 +817,13 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n }\n \n+#[stable]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n #[stable]\n@@ -834,6 +837,7 @@ impl<'a, A> Clone for Iter<'a, A> {\n #[stable]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n \n+#[stable]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n \n@@ -843,17 +847,20 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n }\n \n+#[stable]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an Option.\n #[stable]\n pub struct IntoIter<A> { inner: Item<A> }\n \n+#[stable]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -863,11 +870,13 @@ impl<A> Iterator for IntoIter<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n }\n \n+#[stable]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "e88cb73c8a9b7f6f8d7b6f1a0a6c1207febc3f0d", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -43,8 +43,7 @@ pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n pub use iter::{Extend, IteratorExt};\n pub use iter::{Iterator, DoubleEndedIterator};\n-pub use iter::{IteratorCloneExt, CloneIteratorExt};\n-pub use iter::{IteratorOrdExt, ExactSizeIterator};\n+pub use iter::{ExactSizeIterator};\n pub use option::Option::{self, Some, None};\n pub use ptr::{PtrExt, MutPtrExt};\n pub use result::Result::{self, Ok, Err};"}, {"sha": "5ef6f6b2623aa7c97ff6ba49d443a313a8e3b9e8", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -20,7 +20,6 @@\n \n use kinds::Copy;\n use mem;\n-use kinds::Sized;\n \n /// The representation of a Rust slice\n #[repr(C)]\n@@ -52,7 +51,7 @@ pub struct TraitObject {\n \n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values.\n-pub trait Repr<T> for Sized? {\n+pub trait Repr<T> {\n     /// This function \"unwraps\" a rust value (without consuming it) into its raw\n     /// struct representation. This can be used to read/write different values\n     /// for the struct. This is a safe method because by default it does not"}, {"sha": "8e9bf5487e3ed1faa974a1a3e04a6d8944af98a3", "filename": "src/libcore/result.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -220,9 +220,9 @@\n //!\n //! ```\n //! # #![feature(macro_rules)]\n-//! macro_rules! try(\n+//! macro_rules! try {\n //!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-//! );\n+//! }\n //! # fn main() { }\n //! ```\n //!\n@@ -807,6 +807,7 @@ impl<T, E> AsSlice<T> for Result<T, E> {\n #[stable]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n+#[stable]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -819,11 +820,13 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n }\n \n+#[stable]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n impl<'a, T> Clone for Iter<'a, T> {\n@@ -834,6 +837,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n #[stable]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n+#[stable]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -846,17 +850,20 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n }\n \n+#[stable]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An iterator over the value in a `Ok` variant of a `Result`.\n #[stable]\n pub struct IntoIter<T> { inner: Option<T> }\n \n+#[stable]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -869,11 +876,13 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n+#[stable]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.inner.take() }\n }\n \n+#[stable]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "093ed0b242f5f4d5583f839a7534ee8e697d9912", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -64,7 +64,7 @@ use raw::Slice as RawSlice;\n \n /// Extension methods for slices.\n #[allow(missing_docs)] // docs in libcollections\n-pub trait SliceExt for Sized? {\n+pub trait SliceExt {\n     type Item;\n \n     fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [Self::Item];\n@@ -614,7 +614,7 @@ impl<T> ops::SliceMut<uint, [T]> for [T] {\n \n /// Data that is viewable as a slice.\n #[experimental = \"will be replaced by slice syntax\"]\n-pub trait AsSlice<T> for Sized? {\n+pub trait AsSlice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n@@ -626,13 +626,13 @@ impl<T> AsSlice<T> for [T] {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a U {\n+impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a mut U {\n+impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n@@ -650,7 +650,7 @@ impl<'a, T> Default for &'a [T] {\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        #[experimental = \"needs review\"]\n+        #[stable]\n         impl<'a, T> Iterator for $name<'a, T> {\n             type Item = $elem;\n \n@@ -688,7 +688,7 @@ macro_rules! iterator {\n             }\n         }\n \n-        #[experimental = \"needs review\"]\n+        #[stable]\n         impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -771,15 +771,15 @@ impl<'a,T> Copy for Iter<'a,T> {}\n \n iterator!{struct Iter -> *const T, &'a T}\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-#[experimental = \"needs review\"]\n+#[experimental = \"trait is experimental\"]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -865,7 +865,7 @@ impl<'a, T> IterMut<'a, T> {\n \n iterator!{struct IterMut -> *mut T, &'a mut T}\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An internal abstraction over the splitting iterators, so that\n@@ -897,7 +897,7 @@ impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a [T];\n \n@@ -925,7 +925,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -970,7 +970,7 @@ impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a mut [T];\n \n@@ -1005,7 +1005,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n@@ -1038,7 +1038,6 @@ struct GenericSplitN<I> {\n     invert: bool\n }\n \n-#[experimental = \"needs review\"]\n impl<T, I: SplitIter + Iterator<Item=T>> Iterator for GenericSplitN<I> {\n     type Item = T;\n \n@@ -1061,32 +1060,37 @@ impl<T, I: SplitIter + Iterator<Item=T>> Iterator for GenericSplitN<I> {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n+#[stable]\n pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n+#[stable]\n pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n+#[stable]\n pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n+#[stable]\n pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n macro_rules! forward_iterator {\n     ($name:ident: $elem:ident, $iter_of:ty) => {\n+        #[stable]\n         impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n             P: FnMut(&T) -> bool\n         {\n@@ -1112,12 +1116,13 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n \n /// An iterator over overlapping subslices of length `size`.\n #[derive(Clone)]\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct Windows<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n+#[stable]\n impl<'a, T> Iterator for Windows<'a, T> {\n     type Item = &'a [T];\n \n@@ -1149,13 +1154,13 @@ impl<'a, T> Iterator for Windows<'a, T> {\n /// When the slice len is not evenly divided by the chunk size, the last slice\n /// of the iteration will be the remainder.\n #[derive(Clone)]\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> Iterator for Chunks<'a, T> {\n     type Item = &'a [T];\n \n@@ -1184,7 +1189,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1200,7 +1205,7 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[experimental = \"trait is experimental\"]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1224,13 +1229,13 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n /// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> Iterator for ChunksMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -1260,7 +1265,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1338,7 +1343,7 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable = \"jshould be renamed to from_raw_parts_mut\"]\n+#[unstable = \"should be renamed to from_raw_parts_mut\"]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p as *const T, len: len })\n }\n@@ -1350,12 +1355,11 @@ pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n /// Operations on `[u8]`.\n #[experimental = \"needs review\"]\n pub mod bytes {\n-    use kinds::Sized;\n     use ptr;\n     use slice::SliceExt;\n \n     /// A trait for operations on mutable `[u8]`s.\n-    pub trait MutableByteVector for Sized? {\n+    pub trait MutableByteVector {\n         /// Sets all bytes of the receiver to the given value.\n         fn set_memory(&mut self, value: u8);\n     }\n@@ -1439,7 +1443,7 @@ impl<T: PartialOrd> PartialOrd for [T] {\n \n /// Extension methods for slices containing integers.\n #[experimental]\n-pub trait IntSliceExt<U, S> for Sized? {\n+pub trait IntSliceExt<U, S> {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n     /// Converts the slice to an immutable slice of signed integers with the same width."}, {"sha": "a39787b8207b5161c2fcbdb54c899d0829a93e11", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -37,18 +37,16 @@ use uint;\n macro_rules! delegate_iter {\n     (exact $te:ty in $ti:ty) => {\n         delegate_iter!{$te in $ti}\n+        #[stable]\n         impl<'a> ExactSizeIterator for $ti {\n-            #[inline]\n-            fn rposition<P>(&mut self, predicate: P) -> Option<uint> where P: FnMut($te) -> bool{\n-                self.0.rposition(predicate)\n-            }\n             #[inline]\n             fn len(&self) -> uint {\n                 self.0.len()\n             }\n         }\n     };\n     ($te:ty in $ti:ty) => {\n+        #[stable]\n         impl<'a> Iterator for $ti {\n             type Item = $te;\n \n@@ -61,6 +59,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n+        #[stable]\n         impl<'a> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -69,6 +68,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern $te:ty in $ti:ty) => {\n+        #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -81,6 +81,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n+        #[stable]\n         impl<'a, P: CharEq> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -89,6 +90,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern forward $te:ty in $ti:ty) => {\n+        #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -142,6 +144,7 @@ Section: Creating a string\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n #[derive(Copy, Eq, PartialEq, Clone)]\n+#[unstable = \"error enumeration recently added and definitions may be refined\"]\n pub enum Utf8Error {\n     /// An invalid byte was detected at the byte offset given.\n     ///\n@@ -165,6 +168,7 @@ pub enum Utf8Error {\n ///\n /// Returns `Err` if the slice is not utf-8 with a description as to why the\n /// provided slice is not utf-8.\n+#[stable]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     try!(run_utf8_validation_iterator(&mut v.iter()));\n     Ok(unsafe { from_utf8_unchecked(v) })\n@@ -190,7 +194,7 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n /// # Panics\n ///\n /// This function will panic if the string pointed to by `s` is not valid UTF-8.\n-#[unstable = \"may change location based on the outcome of the c_str module\"]\n+#[deprecated = \"use std::ffi::c_str_to_bytes + str::from_utf8\"]\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0u;\n@@ -230,7 +234,7 @@ impl<F> CharEq for F where F: FnMut(char) -> bool {\n impl<'a> CharEq for &'a [char] {\n     #[inline]\n     fn matches(&mut self, c: char) -> bool {\n-        self.iter().any(|&mut m| m.matches(c))\n+        self.iter().any(|&m| { let mut m = m; m.matches(c) })\n     }\n \n     #[inline]\n@@ -247,6 +251,7 @@ Section: Iterators\n ///\n /// Created with the method `.chars()`.\n #[derive(Clone, Copy)]\n+#[stable]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n }\n@@ -275,6 +280,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n     }\n }\n \n+#[stable]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n \n@@ -320,6 +326,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n }\n \n+#[stable]\n impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n@@ -356,11 +363,13 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n+#[stable]\n pub struct CharIndices<'a> {\n     front_offset: uint,\n     iter: Chars<'a>,\n }\n \n+#[stable]\n impl<'a> Iterator for CharIndices<'a> {\n     type Item = (uint, char);\n \n@@ -384,6 +393,7 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n }\n \n+#[stable]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n@@ -465,6 +475,7 @@ impl<'a, Sep> CharSplits<'a, Sep> {\n     }\n }\n \n+#[stable]\n impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     type Item = &'a str;\n \n@@ -499,6 +510,7 @@ impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     }\n }\n \n+#[stable]\n impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n@@ -540,6 +552,7 @@ impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     }\n }\n \n+#[stable]\n impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n     type Item = &'a str;\n \n@@ -848,6 +861,7 @@ impl Searcher {\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[derive(Clone)]\n+#[unstable = \"type may be removed\"]\n pub struct MatchIndices<'a> {\n     // constants\n     haystack: &'a str,\n@@ -858,13 +872,14 @@ pub struct MatchIndices<'a> {\n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[derive(Clone)]\n-#[unstable = \"Type might get removed\"]\n+#[unstable = \"type may be removed\"]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n     last_end: uint,\n     finished: bool\n }\n \n+#[stable]\n impl<'a> Iterator for MatchIndices<'a> {\n     type Item = (uint, uint);\n \n@@ -881,6 +896,7 @@ impl<'a> Iterator for MatchIndices<'a> {\n     }\n }\n \n+#[stable]\n impl<'a> Iterator for SplitStr<'a> {\n     type Item = &'a str;\n \n@@ -948,17 +964,18 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         let old = *iter;\n \n         // restore the iterator we had at the start of this codepoint.\n-        macro_rules! err (() => { {\n+        macro_rules! err { () => {{\n             *iter = old;\n             return Err(Utf8Error::InvalidByte(whole.len() - iter.as_slice().len()))\n-        } });\n-        macro_rules! next ( () => {\n+        }}}\n+\n+        macro_rules! next { () => {\n             match iter.next() {\n                 Some(a) => *a,\n                 // we needed data, but there was none: error!\n                 None => return Err(Utf8Error::TooShort),\n             }\n-        });\n+        }}\n \n         let first = match iter.next() {\n             Some(&b) => b,\n@@ -1056,8 +1073,7 @@ const TAG_CONT_U8: u8 = 0b1000_0000u8;\n Section: Trait implementations\n */\n \n-#[allow(missing_docs)]\n-pub mod traits {\n+mod traits {\n     use cmp::{Ordering, Ord, PartialEq, PartialOrd, Eq};\n     use cmp::Ordering::{Less, Equal, Greater};\n     use iter::IteratorExt;\n@@ -1130,7 +1146,7 @@ pub mod traits {\n #[unstable = \"Instead of taking this bound generically, this trait will be \\\n               replaced with one of slicing syntax, deref coercions, or \\\n               a more generic conversion trait\"]\n-pub trait Str for Sized? {\n+pub trait Str {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n }\n@@ -1140,7 +1156,7 @@ impl Str for str {\n     fn as_slice<'a>(&'a self) -> &'a str { self }\n }\n \n-impl<'a, Sized? S> Str for &'a S where S: Str {\n+impl<'a, S: ?Sized> Str for &'a S where S: Str {\n     #[inline]\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n }\n@@ -1171,7 +1187,7 @@ delegate_iter!{pattern forward &'a str in RSplitN<'a, P>}\n \n /// Methods for string slices\n #[allow(missing_docs)]\n-pub trait StrExt for Sized? {\n+pub trait StrExt {\n     // NB there are no docs here are they're all located on the StrExt trait in\n     // libcollections, not here.\n \n@@ -1586,26 +1602,30 @@ impl<'a> Default for &'a str {\n     fn default() -> &'a str { \"\" }\n }\n \n+#[stable]\n impl<'a> Iterator for Lines<'a> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n-}\n+\n+#[stable]}\n impl<'a> DoubleEndedIterator for Lines<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n-}\n+\n+#[stable]}\n impl<'a> Iterator for LinesAny<'a> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n-}\n+\n+#[stable]}\n impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }"}, {"sha": "a4bafe754ffdd812c011fafbb03f6a02fb57494f", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -16,7 +16,7 @@ use core::hash::{Hash, Hasher, Writer};\n struct MyWriterHasher;\n \n impl Hasher<MyWriter> for MyWriterHasher {\n-    fn hash<Sized? T: Hash<MyWriter>>(&self, value: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<MyWriter>>(&self, value: &T) -> u64 {\n         let mut state = MyWriter { hash: 0 };\n         value.hash(&mut state);\n         state.hash"}, {"sha": "73db72d0313e6af1d527305e5061b3d145d226e8", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -769,7 +769,7 @@ fn test_range_step_inclusive() {\n #[test]\n fn test_reverse() {\n     let mut ys = [1i, 2, 3, 4, 5];\n-    ys.iter_mut().reverse_();\n+    ys.iter_mut().reverse_in_place();\n     assert!(ys == [5, 4, 3, 2, 1]);\n }\n "}, {"sha": "50ae59e70dc930ec32e21d96a444345b4b8f1bc9", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs, unsafe_destructor, macro_rules, slicing_syntax, default_type_params)]\n+#![feature(globs, unsafe_destructor, slicing_syntax, default_type_params)]\n #![feature(unboxed_closures)]\n \n extern crate core;"}, {"sha": "b98432e26b215c739066af43918ea4f20ee76f8e", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n-macro_rules! int_module (($T:ty, $T_i:ident) => (\n+macro_rules! int_module { ($T:ty, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n@@ -205,4 +203,4 @@ mod tests {\n     }\n }\n \n-));\n+)}"}, {"sha": "f86c85f821638f98813ab459ea8dab0293e00331", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -14,13 +14,20 @@ use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::kinds::Copy;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod int_macros;\n+\n mod i8;\n mod i16;\n mod i32;\n mod i64;\n mod int;\n+\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod uint_macros;\n+\n mod u8;\n mod u16;\n mod u32;"}, {"sha": "04d8fb15cf5aa41715d3043adf44c0fc95805c23", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n-macro_rules! uint_module (($T:ty, $T_i:ident) => (\n+macro_rules! uint_module { ($T:ty, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n@@ -125,4 +123,5 @@ mod tests {\n         assert!(5u.checked_div(0) == None);\n     }\n }\n-));\n+\n+)}"}, {"sha": "6ac311fe4b646ae2f5d9a8ae5642a8b5f0fd6e11", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -21,15 +21,34 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(phase, unboxed_closures)]\n+#![feature(unboxed_closures, associated_types)]\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n extern crate libc;\n \n use libc::{c_void, size_t, c_int};\n-use std::c_vec::CVec;\n+use std::ops::Deref;\n use std::ptr::Unique;\n+use std::slice;\n+\n+pub struct Bytes {\n+    ptr: Unique<u8>,\n+    len: uint,\n+}\n+\n+impl Deref for Bytes {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe { slice::from_raw_mut_buf(&self.ptr.0, self.len) }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    fn drop(&mut self) {\n+        unsafe { libc::free(self.ptr.0 as *mut _); }\n+    }\n+}\n \n #[link(name = \"miniz\", kind = \"static\")]\n extern {\n@@ -52,55 +71,55 @@ static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adler32 checksum\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n-fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n+fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n     unsafe {\n         let mut outsz : size_t = 0;\n         let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *const _,\n                                              bytes.len() as size_t,\n                                              &mut outsz,\n                                              flags);\n         if !res.is_null() {\n-            let res = Unique(res);\n-            Some(CVec::new_with_dtor(res.0 as *mut u8, outsz as uint, move|:| libc::free(res.0)))\n+            let res = Unique(res as *mut u8);\n+            Some(Bytes { ptr: res, len: outsz as uint })\n         } else {\n             None\n         }\n     }\n }\n \n /// Compress a buffer, without writing any sort of header on the output.\n-pub fn deflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n+pub fn deflate_bytes(bytes: &[u8]) -> Option<Bytes> {\n     deflate_bytes_internal(bytes, LZ_NORM)\n }\n \n /// Compress a buffer, using a header that zlib can understand.\n-pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n+pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<Bytes> {\n     deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n }\n \n-fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n+fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n     unsafe {\n         let mut outsz : size_t = 0;\n         let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *const _,\n                                                bytes.len() as size_t,\n                                                &mut outsz,\n                                                flags);\n         if !res.is_null() {\n-            let res = Unique(res);\n-            Some(CVec::new_with_dtor(res.0 as *mut u8, outsz as uint, move|:| libc::free(res.0)))\n+            let res = Unique(res as *mut u8);\n+            Some(Bytes { ptr: res, len: outsz as uint })\n         } else {\n             None\n         }\n     }\n }\n \n /// Decompress a buffer, without parsing any sort of header on the input.\n-pub fn inflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n+pub fn inflate_bytes(bytes: &[u8]) -> Option<Bytes> {\n     inflate_bytes_internal(bytes, 0)\n }\n \n /// Decompress a buffer that starts with a zlib header.\n-pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n+pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<Bytes> {\n     inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n }\n "}, {"sha": "917c6e99992f24c2aa084a23d03352b695516cb4", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -23,7 +23,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(macro_rules, globs, slicing_syntax)]\n+#![feature(globs, slicing_syntax)]\n #![feature(associated_types)]\n \n pub use self::Piece::*;"}, {"sha": "18077795e245f16dda711c3bc2c62a0373e86d83", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -85,11 +85,11 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(globs, phase, slicing_syntax)]\n+#![feature(globs, slicing_syntax)]\n #![feature(unboxed_closures)]\n #![deny(missing_docs)]\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n use self::Name::*;\n use self::HasArg::*;"}, {"sha": "64cc490f4b163e7d7c1d841b3f85a69087c0f8f4", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -587,7 +587,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n mod tests {\n     use self::NodeLabels::*;\n     use super::{Id, Labeller, Nodes, Edges, GraphWalk, render};\n-    use super::LabelText::{mod, LabelStr, EscStr};\n+    use super::LabelText::{self, LabelStr, EscStr};\n     use std::io::IoResult;\n     use std::borrow::IntoCow;\n     use std::iter::repeat;"}, {"sha": "567fe04c5afbc659df4ccb13f6b344b385bdb969", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -25,7 +25,7 @@ use std::slice;\n \n // Note 2: Once Dynamically Sized Types (DST) lands, it might be\n // reasonable to replace this with something like `enum MaybeOwned<'a,\n-// Sized? U>{ Owned(Box<U>), Borrowed(&'a U) }`; and then `U` could be\n+// U: ?Sized>{ Owned(Box<U>), Borrowed(&'a U) }`; and then `U` could be\n // instantiated with `[T]` or `str`, etc.  Of course, that would imply\n // removing the `Growable` variant, which relates to note 1 above.\n // Alternatively, we might add `MaybeOwned` for the general case but"}, {"sha": "df85e89efd17c5a805f46094b1766e0ba76be7e7", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,7 @@\n //! # Examples\n //!\n //! ```\n-//! #![feature(phase)]\n-//! #[phase(plugin, link)] extern crate log;\n+//! #[macro_use] extern crate log;\n //!\n //! fn main() {\n //!     debug!(\"this is a debug {}\", \"message\");\n@@ -183,7 +182,10 @@ use regex::Regex;\n \n use directive::LOG_LEVEL_NAMES;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod macros;\n+\n mod directive;\n \n /// Maximum logging level of a module that can be specified. Common logging"}, {"sha": "5249e971439cddc2af07df55748bf657ffb5e552", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,8 +10,6 @@\n \n //! Logging macros\n \n-#![macro_escape]\n-\n /// The standard logging macro\n ///\n /// This macro will generically log over a provided level (of type u32) with a\n@@ -21,8 +19,7 @@\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     log!(log::WARN, \"this is a warning {}\", \"message\");\n@@ -70,8 +67,7 @@ macro_rules! log {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     let error = 3u;\n@@ -96,8 +92,7 @@ macro_rules! error {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     let code = 3u;\n@@ -121,8 +116,7 @@ macro_rules! warn {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     let ret = 3i;\n@@ -148,8 +142,7 @@ macro_rules! info {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     debug!(\"x = {x}, y = {y}\", x=10i, y=20i);\n@@ -172,8 +165,7 @@ macro_rules! debug {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// struct Point { x: int, y: int }\n /// fn some_expensive_computation() -> Point { Point { x: 1, y: 2 } }"}, {"sha": "815fc0e7ec7ad399b078a165f09b0b37ae3237a4", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,7 +12,6 @@\n \n use core::prelude::*;\n use core::num::Int;\n-\n use {Rng, SeedableRng, Rand};\n \n const KEY_WORDS    : uint =  8; // 8 words for the 256-bit key\n@@ -28,8 +27,7 @@ const CHACHA_ROUNDS: uint = 20; // Cryptographically secure from 8 upwards as of\n ///\n /// [1]: D. J. Bernstein, [*ChaCha, a variant of\n /// Salsa20*](http://cr.yp.to/chacha.html)\n-\n-#[derive(Copy)]\n+#[derive(Copy, Clone)]\n pub struct ChaChaRng {\n     buffer:  [u32; STATE_WORDS], // Internal buffer of output\n     state:   [u32; STATE_WORDS], // Initial state\n@@ -283,5 +281,15 @@ mod test {\n                         0x11cfa18e, 0xd3c50049, 0x75c775f6, 0x434c6530,\n                         0x2c5bad8f, 0x898881dc, 0x5f1c86d9, 0xc1f8e7f4));\n     }\n+\n+    #[test]\n+    fn test_rng_clone() {\n+        let seed : &[_] = &[0u32; 8];\n+        let mut rng: ChaChaRng = SeedableRng::from_seed(seed);\n+        let mut clone = rng.clone();\n+        for _ in range(0u, 16) {\n+            assert_eq!(rng.next_u64(), clone.next_u64());\n+        }\n+    }\n }\n "}, {"sha": "2fdba8a6c4f960358a1c064d4d6ec7561cdb06ef", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -297,7 +297,7 @@ mod tests {\n         // it doesn't do weird things to the RNG (so 0 maps to 0, 1 to\n         // 1, internally; modulo a modulo operation).\n \n-        macro_rules! t (\n+        macro_rules! t {\n             ($items:expr, $expected:expr) => {{\n                 let mut items = $items;\n                 let wc = WeightedChoice::new(items.as_mut_slice());\n@@ -309,7 +309,7 @@ mod tests {\n                     assert_eq!(wc.ind_sample(&mut rng), val)\n                 }\n             }}\n-        );\n+        }\n \n         t!(vec!(Weighted { weight: 1, item: 10i}), [10]);\n "}, {"sha": "1038009522d67313af1e85c46f03d166a2f9222e", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -182,7 +182,7 @@ mod tests {\n     #[test]\n     fn test_integers() {\n         let mut rng = ::test::rng();\n-        macro_rules! t (\n+        macro_rules! t {\n             ($($ty:ty),*) => {{\n                 $(\n                    let v: &[($ty, $ty)] = &[(0, 10),\n@@ -199,15 +199,15 @@ mod tests {\n                     }\n                  )*\n             }}\n-        );\n+        }\n         t!(i8, i16, i32, i64, int,\n            u8, u16, u32, u64, uint)\n     }\n \n     #[test]\n     fn test_floats() {\n         let mut rng = ::test::rng();\n-        macro_rules! t (\n+        macro_rules! t {\n             ($($ty:ty),*) => {{\n                 $(\n                    let v: &[($ty, $ty)] = &[(0.0, 100.0),\n@@ -225,7 +225,7 @@ mod tests {\n                     }\n                  )*\n             }}\n-        );\n+        }\n \n         t!(f32, f64)\n     }"}, {"sha": "84328360ce32431e7b40f0ca582d2268ada3feee", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 97, "deletions": 69, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -69,7 +69,7 @@ impl IsaacRng {\n         let mut g = a;\n         let mut h = a;\n \n-        macro_rules! mix(\n+        macro_rules! mix {\n             () => {{\n                 a^=b<<11; d+=a; b+=c;\n                 b^=c>>2;  e+=b; c+=d;\n@@ -80,14 +80,14 @@ impl IsaacRng {\n                 g^=h<<8;  b+=g; h+=a;\n                 h^=a>>9;  c+=h; a+=b;\n             }}\n-        );\n+        }\n \n         for _ in range(0u, 4) {\n             mix!();\n         }\n \n         if use_rsl {\n-            macro_rules! memloop (\n+            macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in range_step(0, RAND_SIZE as uint, 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n@@ -101,7 +101,7 @@ impl IsaacRng {\n                         self.mem[i+6]=g; self.mem[i+7]=h;\n                     }\n                 }}\n-            );\n+            }\n \n             memloop!(self.rsl);\n             memloop!(self.mem);\n@@ -129,41 +129,42 @@ impl IsaacRng {\n \n         static MIDPOINT: uint = (RAND_SIZE / 2) as uint;\n \n-        macro_rules! ind (($x:expr) => {\n-            self.mem[(($x >> 2) as uint & ((RAND_SIZE - 1) as uint))]\n-        });\n+        macro_rules! ind {\n+            ($x:expr) => ( self.mem[(($x >> 2) as uint & ((RAND_SIZE - 1) as uint))] )\n+        }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n         for &(mr_offset, m2_offset) in r.iter() {\n \n-            macro_rules! rngstepp(\n+            macro_rules! rngstepp {\n                 ($j:expr, $shift:expr) => {{\n-                        let base = $j;\n-                        let mix = a << $shift as uint;\n+                    let base = $j;\n+                    let mix = a << $shift as uint;\n \n-                        let x = self.mem[base  + mr_offset];\n-                        a = (a ^ mix) + self.mem[base + m2_offset];\n-                        let y = ind!(x) + a + b;\n-                        self.mem[base + mr_offset] = y;\n+                    let x = self.mem[base  + mr_offset];\n+                    a = (a ^ mix) + self.mem[base + m2_offset];\n+                    let y = ind!(x) + a + b;\n+                    self.mem[base + mr_offset] = y;\n \n-                        b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n-                        self.rsl[base + mr_offset] = b;\n-                    }}\n-                );\n-            macro_rules! rngstepn(\n+                    b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                    self.rsl[base + mr_offset] = b;\n+                }}\n+            }\n+\n+            macro_rules! rngstepn {\n                 ($j:expr, $shift:expr) => {{\n-                        let base = $j;\n-                        let mix = a >> $shift as uint;\n+                    let base = $j;\n+                    let mix = a >> $shift as uint;\n \n-                        let x = self.mem[base  + mr_offset];\n-                        a = (a ^ mix) + self.mem[base + m2_offset];\n-                        let y = ind!(x) + a + b;\n-                        self.mem[base + mr_offset] = y;\n+                    let x = self.mem[base  + mr_offset];\n+                    a = (a ^ mix) + self.mem[base + m2_offset];\n+                    let y = ind!(x) + a + b;\n+                    self.mem[base + mr_offset] = y;\n \n-                        b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n-                        self.rsl[base + mr_offset] = b;\n-                    }}\n-                );\n+                    b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                    self.rsl[base + mr_offset] = b;\n+                }}\n+            }\n \n             for i in range_step(0u, MIDPOINT, 4) {\n                 rngstepp!(i + 0, 13);\n@@ -179,6 +180,13 @@ impl IsaacRng {\n     }\n }\n \n+// Cannot be derived because [u32; 256] does not implement Clone\n+impl Clone for IsaacRng {\n+    fn clone(&self) -> IsaacRng {\n+        *self\n+    }\n+}\n+\n impl Rng for IsaacRng {\n     #[inline]\n     fn next_u32(&mut self) -> u32 {\n@@ -294,15 +302,15 @@ impl Isaac64Rng {\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n     fn init(&mut self, use_rsl: bool) {\n-        macro_rules! init (\n+        macro_rules! init {\n             ($var:ident) => (\n                 let mut $var = 0x9e3779b97f4a7c13;\n             )\n-        );\n+        }\n         init!(a); init!(b); init!(c); init!(d);\n         init!(e); init!(f); init!(g); init!(h);\n \n-        macro_rules! mix(\n+        macro_rules! mix {\n             () => {{\n                 a-=e; f^=h>>9;  h+=a;\n                 b-=f; g^=a<<9;  a+=b;\n@@ -313,14 +321,14 @@ impl Isaac64Rng {\n                 g-=c; d^=f>>17; f+=g;\n                 h-=d; e^=g<<14; g+=h;\n             }}\n-        );\n+        }\n \n         for _ in range(0u, 4) {\n             mix!();\n         }\n \n         if use_rsl {\n-            macro_rules! memloop (\n+            macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n@@ -334,7 +342,7 @@ impl Isaac64Rng {\n                         self.mem[i+6]=g; self.mem[i+7]=h;\n                     }\n                 }}\n-            );\n+            }\n \n             memloop!(self.rsl);\n             memloop!(self.mem);\n@@ -359,49 +367,51 @@ impl Isaac64Rng {\n         let mut b = self.b + self.c;\n         const MIDPOINT: uint =  RAND_SIZE_64 / 2;\n         const MP_VEC: [(uint, uint); 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n-        macro_rules! ind (\n+        macro_rules! ind {\n             ($x:expr) => {\n                 *self.mem.get_unchecked(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n-        );\n+        }\n \n         for &(mr_offset, m2_offset) in MP_VEC.iter() {\n             for base in range(0, MIDPOINT / 4).map(|i| i * 4) {\n \n-                macro_rules! rngstepp(\n+                macro_rules! rngstepp {\n                     ($j:expr, $shift:expr) => {{\n-                            let base = base + $j;\n-                            let mix = a ^ (a << $shift as uint);\n-                            let mix = if $j == 0 {!mix} else {mix};\n-\n-                            unsafe {\n-                                let x = *self.mem.get_unchecked(base + mr_offset);\n-                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                                let y = ind!(x) + a + b;\n-                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n-\n-                                b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n-                            }\n-                        }}\n-                    );\n-                macro_rules! rngstepn(\n+                        let base = base + $j;\n+                        let mix = a ^ (a << $shift as uint);\n+                        let mix = if $j == 0 {!mix} else {mix};\n+\n+                        unsafe {\n+                            let x = *self.mem.get_unchecked(base + mr_offset);\n+                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n+                            let y = ind!(x) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+\n+                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                        }\n+                    }}\n+                }\n+\n+                macro_rules! rngstepn {\n                     ($j:expr, $shift:expr) => {{\n-                            let base = base + $j;\n-                            let mix = a ^ (a >> $shift as uint);\n-                            let mix = if $j == 0 {!mix} else {mix};\n-\n-                            unsafe {\n-                                let x = *self.mem.get_unchecked(base + mr_offset);\n-                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                                let y = ind!(x) + a + b;\n-                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n-\n-                                b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n-                            }\n-                        }}\n-                    );\n+                        let base = base + $j;\n+                        let mix = a ^ (a >> $shift as uint);\n+                        let mix = if $j == 0 {!mix} else {mix};\n+\n+                        unsafe {\n+                            let x = *self.mem.get_unchecked(base + mr_offset);\n+                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n+                            let y = ind!(x) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+\n+                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                        }\n+                    }}\n+                }\n+\n                 rngstepp!(0u, 21);\n                 rngstepn!(1u, 5);\n                 rngstepp!(2u, 12);\n@@ -415,6 +425,13 @@ impl Isaac64Rng {\n     }\n }\n \n+// Cannot be derived because [u32; 256] does not implement Clone\n+impl Clone for Isaac64Rng {\n+    fn clone(&self) -> Isaac64Rng {\n+        *self\n+    }\n+}\n+\n impl Rng for Isaac64Rng {\n     // FIXME #7771: having next_u32 like this should be unnecessary\n     #[inline]\n@@ -485,6 +502,7 @@ impl Rand for Isaac64Rng {\n     }\n }\n \n+\n #[cfg(test)]\n mod test {\n     use std::prelude::v1::*;\n@@ -594,4 +612,14 @@ mod test {\n                         596345674630742204, 9947027391921273664, 11788097613744130851,\n                         10391409374914919106));\n     }\n+\n+    #[test]\n+    fn test_rng_clone() {\n+        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n+        let mut rng: Isaac64Rng = SeedableRng::from_seed(seed);\n+        let mut clone = rng.clone();\n+        for _ in range(0u, 16) {\n+            assert_eq!(rng.next_u64(), clone.next_u64());\n+        }\n+    }\n }"}, {"sha": "c4dd08f9917e2dcbc95349b9449406adf91d3934", "filename": "src/librand/lib.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -29,11 +29,29 @@\n #![no_std]\n #![experimental]\n \n+#[cfg(stage0)]\n #[phase(plugin, link)]\n extern crate core;\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate std;\n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate core;\n+\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate std;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate std;\n+\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate log;\n \n use core::prelude::*;\n \n@@ -243,7 +261,7 @@ pub trait Rng : Sized {\n     /// println!(\"{}\", rng.gen_weighted_bool(3));\n     /// ```\n     fn gen_weighted_bool(&mut self, n: uint) -> bool {\n-        n == 0 || self.gen_range(0, n) == 0\n+        n <= 1 || self.gen_range(0, n) == 0\n     }\n \n     /// Return an iterator of random characters from the set A-Z,a-z,0-9.\n@@ -385,24 +403,14 @@ pub trait SeedableRng<Seed>: Rng {\n /// RNGs\"](http://www.jstatsoft.org/v08/i14/paper). *Journal of\n /// Statistical Software*. Vol. 8 (Issue 14).\n #[allow(missing_copy_implementations)]\n+#[derive(Clone)]\n pub struct XorShiftRng {\n     x: u32,\n     y: u32,\n     z: u32,\n     w: u32,\n }\n \n-impl Clone for XorShiftRng {\n-    fn clone(&self) -> XorShiftRng {\n-        XorShiftRng {\n-            x: self.x,\n-            y: self.y,\n-            z: self.z,\n-            w: self.w,\n-        }\n-    }\n-}\n-\n impl XorShiftRng {\n     /// Creates a new XorShiftRng instance which is not seeded.\n     ///\n@@ -507,6 +515,7 @@ pub struct Closed01<F>(pub F);\n #[cfg(not(test))]\n mod std {\n     pub use core::{option, fmt}; // panic!()\n+    pub use core::clone; // derive Clone\n     pub use core::kinds;\n }\n "}, {"sha": "e57542a6d14de1c1e2e08f91d51fe59ed594dc0f", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -30,7 +30,14 @@\n \n extern crate serialize;\n \n-#[phase(plugin, link)] extern crate log;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n #[cfg(test)] extern crate test;\n \n pub use self::EbmlEncoderTag::*;"}, {"sha": "0084be49b561904534e693d4b69e736ab96f5eff", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -24,7 +24,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, phase, slicing_syntax, globs)]\n+#![feature(macro_rules, slicing_syntax, globs)]\n #![feature(unboxed_closures)]\n #![feature(associated_types)]\n #![deny(missing_docs)]"}, {"sha": "3ed712b15dfdcdb4eba468811aaff5a1634d3a42", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -40,8 +40,22 @@ extern crate rustc_back;\n extern crate serialize;\n extern crate rbml;\n extern crate collections;\n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n "}, {"sha": "425e34cd9f0424b437b8eab9972519829e3a36b3", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -546,20 +546,20 @@ impl LintPass for BoxPointers {\n }\n \n declare_lint! {\n-    RAW_POINTER_DERIVING,\n+    RAW_POINTER_DERIVE,\n     Warn,\n     \"uses of #[derive] with raw pointers are rarely correct\"\n }\n \n-struct RawPtrDerivingVisitor<'a, 'tcx: 'a> {\n+struct RawPtrDeriveVisitor<'a, 'tcx: 'a> {\n     cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDerivingVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDeriveVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n         static MSG: &'static str = \"use of `#[derive]` with a raw pointer\";\n         if let ast::TyPtr(..) = ty.node {\n-            self.cx.span_lint(RAW_POINTER_DERIVING, ty.span, MSG);\n+            self.cx.span_lint(RAW_POINTER_DERIVE, ty.span, MSG);\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -568,21 +568,21 @@ impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDerivingVisitor<'a, 'tcx> {\n     fn visit_block(&mut self, _: &ast::Block) {}\n }\n \n-pub struct RawPointerDeriving {\n+pub struct RawPointerDerive {\n     checked_raw_pointers: NodeSet,\n }\n \n-impl RawPointerDeriving {\n-    pub fn new() -> RawPointerDeriving {\n-        RawPointerDeriving {\n+impl RawPointerDerive {\n+    pub fn new() -> RawPointerDerive {\n+        RawPointerDerive {\n             checked_raw_pointers: NodeSet::new(),\n         }\n     }\n }\n \n-impl LintPass for RawPointerDeriving {\n+impl LintPass for RawPointerDerive {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(RAW_POINTER_DERIVING)\n+        lint_array!(RAW_POINTER_DERIVE)\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n@@ -607,7 +607,7 @@ impl LintPass for RawPointerDeriving {\n         if !self.checked_raw_pointers.insert(item.id) { return }\n         match item.node {\n             ast::ItemStruct(..) | ast::ItemEnum(..) => {\n-                let mut visitor = RawPtrDerivingVisitor { cx: cx };\n+                let mut visitor = RawPtrDeriveVisitor { cx: cx };\n                 visit::walk_item(&mut visitor, &*item);\n             }\n             _ => {}\n@@ -666,6 +666,9 @@ impl LintPass for UnusedAttributes {\n             \"must_use\",\n             \"stable\",\n             \"unstable\",\n+\n+            // FIXME: #19470 this shouldn't be needed forever\n+            \"old_orphan_check\",\n         ];\n \n         static CRATE_ATTRS: &'static [&'static str] = &["}, {"sha": "5c0fd8944368f60da86abc2a3a85b2860e3de174", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -167,21 +167,27 @@ impl LintStore {\n     }\n \n     pub fn register_builtin(&mut self, sess: Option<&Session>) {\n-        macro_rules! add_builtin ( ( $sess:ident, $($name:ident),*, ) => (\n-            {$(\n-                self.register_pass($sess, false, box builtin::$name as LintPassObject);\n-            )*}\n-        ));\n-\n-        macro_rules! add_builtin_with_new ( ( $sess:ident, $($name:ident),*, ) => (\n-            {$(\n-                self.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n-            )*}\n-        ));\n-\n-        macro_rules! add_lint_group ( ( $sess:ident, $name:expr, $($lint:ident),* ) => (\n-            self.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n-        ));\n+        macro_rules! add_builtin {\n+            ($sess:ident, $($name:ident),*,) => (\n+                {$(\n+                    self.register_pass($sess, false, box builtin::$name as LintPassObject);\n+                )*}\n+            )\n+        }\n+\n+        macro_rules! add_builtin_with_new {\n+            ($sess:ident, $($name:ident),*,) => (\n+                {$(\n+                    self.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n+                )*}\n+            )\n+        }\n+\n+        macro_rules! add_lint_group {\n+            ($sess:ident, $name:expr, $($lint:ident),*) => (\n+                self.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n+            )\n+        }\n \n         add_builtin!(sess,\n                      HardwiredLints,\n@@ -208,7 +214,7 @@ impl LintStore {\n \n         add_builtin_with_new!(sess,\n                               TypeLimits,\n-                              RawPointerDeriving,\n+                              RawPointerDerive,\n                               MissingDoc,\n         );\n \n@@ -247,6 +253,7 @@ impl LintStore {\n         self.register_renamed(\"unknown_crate_type\", \"unknown_crate_types\");\n         self.register_renamed(\"variant_size_difference\", \"variant_size_differences\");\n         self.register_renamed(\"transmute_fat_ptr\", \"fat_ptr_transmutes\");\n+        self.register_renamed(\"raw_pointer_deriving\", \"raw_pointer_derive\");\n \n     }\n "}, {"sha": "e9778fa05ff1787f419d717d979591d8816a69ef", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -28,8 +28,6 @@\n //! example) requires more effort. See `emit_lint` and `GatherNodeLevels`\n //! in `context.rs`.\n \n-#![macro_escape]\n-\n pub use self::Level::*;\n pub use self::LintSource::*;\n "}, {"sha": "de9a09ffe44c1ba33dddee1c55b41199e02dbe20", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -206,8 +206,8 @@ pub const tag_native_libraries_name: uint = 0x89;\n pub const tag_native_libraries_kind: uint = 0x8a;\n \n pub const tag_plugin_registrar_fn: uint = 0x8b;\n-pub const tag_exported_macros: uint = 0x8c;\n-pub const tag_macro_def: uint = 0x8d;\n+\n+// GAP 0x8c, 0x8d\n \n pub const tag_method_argument_names: uint = 0x8e;\n pub const tag_method_argument_name: uint = 0x8f;\n@@ -261,3 +261,7 @@ pub const tag_associated_type_names: uint = 0xb2;\n pub const tag_associated_type_name: uint = 0xb3;\n \n pub const tag_polarity: uint = 0xb4;\n+\n+pub const tag_macro_defs: uint = 0xb5;\n+pub const tag_macro_def: uint = 0xb6;\n+pub const tag_macro_def_body: uint = 0xb7;"}, {"sha": "171bfd74a816b4604c281b7ac1933a002d453447", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 414, "deletions": 344, "changes": 758, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -16,11 +16,10 @@ use back::svh::Svh;\n use session::{config, Session};\n use session::search_paths::PathKind;\n use metadata::cstore;\n-use metadata::cstore::{CStore, CrateSource};\n+use metadata::cstore::{CStore, CrateSource, MetadataBlob};\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n-use plugin::load::PluginMetadata;\n use util::nodemap::FnvHashMap;\n \n use std::rc::Rc;\n@@ -29,43 +28,27 @@ use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{Span};\n+use syntax::codemap::{Span, mk_sp};\n use syntax::diagnostic::SpanHandler;\n+use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit;\n use util::fs;\n+use log;\n \n-struct Env<'a> {\n+pub struct CrateReader<'a> {\n     sess: &'a Session,\n     next_crate_num: ast::CrateNum,\n }\n \n-// Traverses an AST, reading all the information about use'd crates and extern\n-// libraries necessary for later resolving, typechecking, linking, etc.\n-pub fn read_crates(sess: &Session,\n-                   krate: &ast::Crate) {\n-    let mut e = Env {\n-        sess: sess,\n-        next_crate_num: sess.cstore.next_crate_num(),\n-    };\n-    visit_crate(&e, krate);\n-    visit::walk_crate(&mut e, krate);\n-    dump_crates(&sess.cstore);\n-    warn_if_multiple_versions(sess.diagnostic(), &sess.cstore);\n-\n-    for &(ref name, kind) in sess.opts.libs.iter() {\n-        register_native_lib(sess, None, name.clone(), kind);\n-    }\n-}\n-\n-impl<'a, 'v> visit::Visitor<'v> for Env<'a> {\n+impl<'a, 'v> visit::Visitor<'v> for CrateReader<'a> {\n     fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        visit_view_item(self, a);\n+        self.process_view_item(a);\n         visit::walk_view_item(self, a);\n     }\n     fn visit_item(&mut self, a: &ast::Item) {\n-        visit_item(self, a);\n+        self.process_item(a);\n         visit::walk_item(self, a);\n     }\n }\n@@ -105,42 +88,8 @@ fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n     }\n }\n \n-fn visit_crate(e: &Env, c: &ast::Crate) {\n-    for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-        match a.value_str() {\n-            Some(ref linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n-            None => { /* fallthrough */ }\n-        }\n-    }\n-}\n-\n fn should_link(i: &ast::ViewItem) -> bool {\n-    i.attrs.iter().all(|attr| {\n-        attr.name().get() != \"phase\" ||\n-            attr.meta_item_list().map_or(false, |phases| {\n-                attr::contains_name(phases[], \"link\")\n-            })\n-    })\n-}\n-\n-fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n-    if !should_link(i) {\n-        return;\n-    }\n-\n-    match extract_crate_info(e, i) {\n-        Some(info) => {\n-            let (cnum, _, _) = resolve_crate(e,\n-                                             &None,\n-                                             info.ident[],\n-                                             info.name[],\n-                                             None,\n-                                             i.span,\n-                                             PathKind::Crate);\n-            e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-        }\n-        None => ()\n-    }\n+    !attr::contains_name(i.attrs[], \"no_link\")\n }\n \n struct CrateInfo {\n@@ -150,32 +99,6 @@ struct CrateInfo {\n     should_link: bool,\n }\n \n-fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n-    match i.node {\n-        ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n-            let ident = token::get_ident(ident);\n-            debug!(\"resolving extern crate stmt. ident: {} path_opt: {}\",\n-                   ident, path_opt);\n-            let name = match *path_opt {\n-                Some((ref path_str, _)) => {\n-                    let name = path_str.get().to_string();\n-                    validate_crate_name(Some(e.sess), name[],\n-                                        Some(i.span));\n-                    name\n-                }\n-                None => ident.get().to_string(),\n-            };\n-            Some(CrateInfo {\n-                ident: ident.get().to_string(),\n-                name: name,\n-                id: id,\n-                should_link: should_link(i),\n-            })\n-        }\n-        _ => None\n-    }\n-}\n-\n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     let err = |&: s: &str| {\n         match (sp, sess) {\n@@ -198,85 +121,6 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     }\n }\n \n-fn visit_item(e: &Env, i: &ast::Item) {\n-    match i.node {\n-        ast::ItemForeignMod(ref fm) => {\n-            if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n-                return;\n-            }\n-\n-            // First, add all of the custom link_args attributes\n-            let link_args = i.attrs.iter()\n-                .filter_map(|at| if at.name() == \"link_args\" {\n-                    Some(at)\n-                } else {\n-                    None\n-                })\n-                .collect::<Vec<&ast::Attribute>>();\n-            for m in link_args.iter() {\n-                match m.value_str() {\n-                    Some(linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n-                    None => { /* fallthrough */ }\n-                }\n-            }\n-\n-            // Next, process all of the #[link(..)]-style arguments\n-            let link_args = i.attrs.iter()\n-                .filter_map(|at| if at.name() == \"link\" {\n-                    Some(at)\n-                } else {\n-                    None\n-                })\n-                .collect::<Vec<&ast::Attribute>>();\n-            for m in link_args.iter() {\n-                match m.meta_item_list() {\n-                    Some(items) => {\n-                        let kind = items.iter().find(|k| {\n-                            k.name() == \"kind\"\n-                        }).and_then(|a| a.value_str());\n-                        let kind = match kind {\n-                            Some(k) => {\n-                                if k == \"static\" {\n-                                    cstore::NativeStatic\n-                                } else if e.sess.target.target.options.is_like_osx\n-                                          && k == \"framework\" {\n-                                    cstore::NativeFramework\n-                                } else if k == \"framework\" {\n-                                    cstore::NativeFramework\n-                                } else if k == \"dylib\" {\n-                                    cstore::NativeUnknown\n-                                } else {\n-                                    e.sess.span_err(m.span,\n-                                        format!(\"unknown kind: `{}`\",\n-                                                k)[]);\n-                                    cstore::NativeUnknown\n-                                }\n-                            }\n-                            None => cstore::NativeUnknown\n-                        };\n-                        let n = items.iter().find(|n| {\n-                            n.name() == \"name\"\n-                        }).and_then(|a| a.value_str());\n-                        let n = match n {\n-                            Some(n) => n,\n-                            None => {\n-                                e.sess.span_err(m.span,\n-                                    \"#[link(...)] specified without \\\n-                                     `name = \\\"foo\\\"`\");\n-                                InternedString::new(\"foo\")\n-                            }\n-                        };\n-                        register_native_lib(e.sess, Some(m.span),\n-                                            n.get().to_string(), kind);\n-                    }\n-                    None => {}\n-                }\n-            }\n-        }\n-        _ => { }\n-    }\n-}\n-\n fn register_native_lib(sess: &Session,\n                        span: Option<Span>,\n                        name: String,\n@@ -304,172 +148,341 @@ fn register_native_lib(sess: &Session,\n     sess.cstore.add_used_library(name, kind);\n }\n \n-fn existing_match(e: &Env, name: &str,\n-                  hash: Option<&Svh>) -> Option<ast::CrateNum> {\n-    let mut ret = None;\n-    e.sess.cstore.iter_crate_data(|cnum, data| {\n-        if data.name != name { return }\n+pub struct PluginMetadata<'a> {\n+    sess: &'a Session,\n+    metadata: PMDSource,\n+    dylib: Option<Path>,\n+    info: CrateInfo,\n+    vi_span: Span,\n+    target_only: bool,\n+}\n \n-        match hash {\n-            Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }\n-            Some(..) => return,\n-            None => {}\n-        }\n+enum PMDSource {\n+    Registered(Rc<cstore::crate_metadata>),\n+    Owned(MetadataBlob),\n+}\n \n-        // When the hash is None we're dealing with a top-level dependency in\n-        // which case we may have a specification on the command line for this\n-        // library. Even though an upstream library may have loaded something of\n-        // the same name, we have to make sure it was loaded from the exact same\n-        // location as well.\n-        //\n-        // We're also sure to compare *paths*, not actual byte slices. The\n-        // `source` stores paths which are normalized which may be different\n-        // from the strings on the command line.\n-        let source = e.sess.cstore.get_used_crate_source(cnum).unwrap();\n-        match e.sess.opts.externs.get(name) {\n-            Some(locs) => {\n-                let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(l[])).ok();\n-                    l == source.dylib || l == source.rlib\n-                });\n-                if found {\n-                    ret = Some(cnum);\n-                }\n-            }\n-            None => ret = Some(cnum),\n+impl PMDSource {\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        match *self {\n+            PMDSource::Registered(ref cmd) => cmd.data(),\n+            PMDSource::Owned(ref mdb) => mdb.as_slice(),\n         }\n-    });\n-    return ret;\n+    }\n }\n \n-fn register_crate<'a>(e: &mut Env,\n-                  root: &Option<CratePaths>,\n-                  ident: &str,\n-                  name: &str,\n-                  span: Span,\n-                  lib: loader::Library)\n-                        -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n-                            cstore::CrateSource) {\n-    // Claim this crate number and cache it\n-    let cnum = e.next_crate_num;\n-    e.next_crate_num += 1;\n-\n-    // Stash paths for top-most crate locally if necessary.\n-    let crate_paths = if root.is_none() {\n-        Some(CratePaths {\n-            ident: ident.to_string(),\n-            dylib: lib.dylib.clone(),\n-            rlib:  lib.rlib.clone(),\n-        })\n-    } else {\n-        None\n-    };\n-    // Maintain a reference to the top most crate.\n-    let root = if root.is_some() { root } else { &crate_paths };\n+impl<'a> CrateReader<'a> {\n+    pub fn new(sess: &'a Session) -> CrateReader<'a> {\n+        CrateReader {\n+            sess: sess,\n+            next_crate_num: sess.cstore.next_crate_num(),\n+        }\n+    }\n \n-    let cnum_map = resolve_crate_deps(e, root, lib.metadata.as_slice(), span);\n+    // Traverses an AST, reading all the information about use'd crates and extern\n+    // libraries necessary for later resolving, typechecking, linking, etc.\n+    pub fn read_crates(&mut self, krate: &ast::Crate) {\n+        self.process_crate(krate);\n+        visit::walk_crate(self, krate);\n \n-    let loader::Library{ dylib, rlib, metadata } = lib;\n+        if log_enabled!(log::DEBUG) {\n+            dump_crates(&self.sess.cstore);\n+        }\n+        warn_if_multiple_versions(self.sess.diagnostic(), &self.sess.cstore);\n \n-    let cmeta = Rc::new( cstore::crate_metadata {\n-        name: name.to_string(),\n-        data: metadata,\n-        cnum_map: cnum_map,\n-        cnum: cnum,\n-        span: span,\n-    });\n+        for &(ref name, kind) in self.sess.opts.libs.iter() {\n+            register_native_lib(self.sess, None, name.clone(), kind);\n+        }\n+    }\n \n-    let source = cstore::CrateSource {\n-        dylib: dylib,\n-        rlib: rlib,\n-        cnum: cnum,\n-    };\n+    fn process_crate(&self, c: &ast::Crate) {\n+        for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n+            match a.value_str() {\n+                Some(ref linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n+                None => { /* fallthrough */ }\n+            }\n+        }\n+    }\n \n-    e.sess.cstore.set_crate_data(cnum, cmeta.clone());\n-    e.sess.cstore.add_used_crate_source(source.clone());\n-    (cnum, cmeta, source)\n-}\n+    fn process_view_item(&mut self, i: &ast::ViewItem) {\n+        if !should_link(i) {\n+            return;\n+        }\n \n-fn resolve_crate(e: &mut Env,\n-                 root: &Option<CratePaths>,\n-                 ident: &str,\n-                 name: &str,\n-                 hash: Option<&Svh>,\n-                 span: Span,\n-                 kind: PathKind)\n-                     -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n-                         cstore::CrateSource) {\n-    match existing_match(e, name, hash) {\n-        None => {\n-            let mut load_ctxt = loader::Context {\n-                sess: e.sess,\n-                span: span,\n-                ident: ident,\n-                crate_name: name,\n-                hash: hash.map(|a| &*a),\n-                filesearch: e.sess.target_filesearch(kind),\n-                triple: e.sess.opts.target_triple[],\n-                root: root,\n-                rejected_via_hash: vec!(),\n-                rejected_via_triple: vec!(),\n-                should_match_name: true,\n-            };\n-            let library = load_ctxt.load_library_crate();\n-            register_crate(e, root, ident, name, span, library)\n+        match self.extract_crate_info(i) {\n+            Some(info) => {\n+                let (cnum, _, _) = self.resolve_crate(&None,\n+                                                      info.ident[],\n+                                                      info.name[],\n+                                                      None,\n+                                                      i.span,\n+                                                      PathKind::Crate);\n+                self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+            }\n+            None => ()\n         }\n-        Some(cnum) => (cnum,\n-                       e.sess.cstore.get_crate_data(cnum),\n-                       e.sess.cstore.get_used_crate_source(cnum).unwrap())\n     }\n-}\n \n-// Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: &mut Env,\n+    fn extract_crate_info(&self, i: &ast::ViewItem) -> Option<CrateInfo> {\n+        match i.node {\n+            ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n+                let ident = token::get_ident(ident);\n+                debug!(\"resolving extern crate stmt. ident: {} path_opt: {}\",\n+                       ident, path_opt);\n+                let name = match *path_opt {\n+                    Some((ref path_str, _)) => {\n+                        let name = path_str.get().to_string();\n+                        validate_crate_name(Some(self.sess), name[],\n+                                            Some(i.span));\n+                        name\n+                    }\n+                    None => ident.get().to_string(),\n+                };\n+                Some(CrateInfo {\n+                    ident: ident.get().to_string(),\n+                    name: name,\n+                    id: id,\n+                    should_link: should_link(i),\n+                })\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    fn process_item(&self, i: &ast::Item) {\n+        match i.node {\n+            ast::ItemForeignMod(ref fm) => {\n+                if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n+                    return;\n+                }\n+\n+                // First, add all of the custom link_args attributes\n+                let link_args = i.attrs.iter()\n+                    .filter_map(|at| if at.name() == \"link_args\" {\n+                        Some(at)\n+                    } else {\n+                        None\n+                    })\n+                    .collect::<Vec<&ast::Attribute>>();\n+                for m in link_args.iter() {\n+                    match m.value_str() {\n+                        Some(linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n+                        None => { /* fallthrough */ }\n+                    }\n+                }\n+\n+                // Next, process all of the #[link(..)]-style arguments\n+                let link_args = i.attrs.iter()\n+                    .filter_map(|at| if at.name() == \"link\" {\n+                        Some(at)\n+                    } else {\n+                        None\n+                    })\n+                    .collect::<Vec<&ast::Attribute>>();\n+                for m in link_args.iter() {\n+                    match m.meta_item_list() {\n+                        Some(items) => {\n+                            let kind = items.iter().find(|k| {\n+                                k.name() == \"kind\"\n+                            }).and_then(|a| a.value_str());\n+                            let kind = match kind {\n+                                Some(k) => {\n+                                    if k == \"static\" {\n+                                        cstore::NativeStatic\n+                                    } else if self.sess.target.target.options.is_like_osx\n+                                              && k == \"framework\" {\n+                                        cstore::NativeFramework\n+                                    } else if k == \"framework\" {\n+                                        cstore::NativeFramework\n+                                    } else if k == \"dylib\" {\n+                                        cstore::NativeUnknown\n+                                    } else {\n+                                        self.sess.span_err(m.span,\n+                                            format!(\"unknown kind: `{}`\",\n+                                                    k)[]);\n+                                        cstore::NativeUnknown\n+                                    }\n+                                }\n+                                None => cstore::NativeUnknown\n+                            };\n+                            let n = items.iter().find(|n| {\n+                                n.name() == \"name\"\n+                            }).and_then(|a| a.value_str());\n+                            let n = match n {\n+                                Some(n) => n,\n+                                None => {\n+                                    self.sess.span_err(m.span,\n+                                        \"#[link(...)] specified without \\\n+                                         `name = \\\"foo\\\"`\");\n+                                    InternedString::new(\"foo\")\n+                                }\n+                            };\n+                            register_native_lib(self.sess, Some(m.span),\n+                                                n.get().to_string(), kind);\n+                        }\n+                        None => {}\n+                    }\n+                }\n+            }\n+            _ => { }\n+        }\n+    }\n+\n+    fn existing_match(&self, name: &str,\n+                      hash: Option<&Svh>) -> Option<ast::CrateNum> {\n+        let mut ret = None;\n+        self.sess.cstore.iter_crate_data(|cnum, data| {\n+            if data.name != name { return }\n+\n+            match hash {\n+                Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }\n+                Some(..) => return,\n+                None => {}\n+            }\n+\n+            // When the hash is None we're dealing with a top-level dependency in\n+            // which case we may have a specification on the command line for this\n+            // library. Even though an upstream library may have loaded something of\n+            // the same name, we have to make sure it was loaded from the exact same\n+            // location as well.\n+            //\n+            // We're also sure to compare *paths*, not actual byte slices. The\n+            // `source` stores paths which are normalized which may be different\n+            // from the strings on the command line.\n+            let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n+            match self.sess.opts.externs.get(name) {\n+                Some(locs) => {\n+                    let found = locs.iter().any(|l| {\n+                        let l = fs::realpath(&Path::new(l[])).ok();\n+                        l == source.dylib || l == source.rlib\n+                    });\n+                    if found {\n+                        ret = Some(cnum);\n+                    }\n+                }\n+                None => ret = Some(cnum),\n+            }\n+        });\n+        return ret;\n+    }\n+\n+    fn register_crate(&mut self,\n                       root: &Option<CratePaths>,\n-                      cdata: &[u8], span : Span)\n-                   -> cstore::cnum_map {\n-    debug!(\"resolving deps of external crate\");\n-    // The map from crate numbers in the crate we're resolving to local crate\n-    // numbers\n-    decoder::get_crate_deps(cdata).iter().map(|dep| {\n-        debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n-        let (local_cnum, _, _) = resolve_crate(e, root,\n-                                               dep.name[],\n-                                               dep.name[],\n-                                               Some(&dep.hash),\n-                                               span,\n-                                               PathKind::Dependency);\n-        (dep.cnum, local_cnum)\n-    }).collect()\n-}\n+                      ident: &str,\n+                      name: &str,\n+                      span: Span,\n+                      lib: loader::Library)\n+                      -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n+                          cstore::CrateSource) {\n+        // Claim this crate number and cache it\n+        let cnum = self.next_crate_num;\n+        self.next_crate_num += 1;\n+\n+        // Stash paths for top-most crate locally if necessary.\n+        let crate_paths = if root.is_none() {\n+            Some(CratePaths {\n+                ident: ident.to_string(),\n+                dylib: lib.dylib.clone(),\n+                rlib:  lib.rlib.clone(),\n+            })\n+        } else {\n+            None\n+        };\n+        // Maintain a reference to the top most crate.\n+        let root = if root.is_some() { root } else { &crate_paths };\n \n-pub struct PluginMetadataReader<'a> {\n-    env: Env<'a>,\n-}\n+        let cnum_map = self.resolve_crate_deps(root, lib.metadata.as_slice(), span);\n+\n+        let loader::Library{ dylib, rlib, metadata } = lib;\n+\n+        let cmeta = Rc::new( cstore::crate_metadata {\n+            name: name.to_string(),\n+            data: metadata,\n+            cnum_map: cnum_map,\n+            cnum: cnum,\n+            span: span,\n+        });\n+\n+        let source = cstore::CrateSource {\n+            dylib: dylib,\n+            rlib: rlib,\n+            cnum: cnum,\n+        };\n+\n+        self.sess.cstore.set_crate_data(cnum, cmeta.clone());\n+        self.sess.cstore.add_used_crate_source(source.clone());\n+        (cnum, cmeta, source)\n+    }\n \n-impl<'a> PluginMetadataReader<'a> {\n-    pub fn new(sess: &'a Session) -> PluginMetadataReader<'a> {\n-        PluginMetadataReader {\n-            env: Env {\n-                sess: sess,\n-                next_crate_num: sess.cstore.next_crate_num(),\n+    fn resolve_crate(&mut self,\n+                     root: &Option<CratePaths>,\n+                     ident: &str,\n+                     name: &str,\n+                     hash: Option<&Svh>,\n+                     span: Span,\n+                     kind: PathKind)\n+                         -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n+                             cstore::CrateSource) {\n+        match self.existing_match(name, hash) {\n+            None => {\n+                let mut load_ctxt = loader::Context {\n+                    sess: self.sess,\n+                    span: span,\n+                    ident: ident,\n+                    crate_name: name,\n+                    hash: hash.map(|a| &*a),\n+                    filesearch: self.sess.target_filesearch(kind),\n+                    triple: self.sess.opts.target_triple[],\n+                    root: root,\n+                    rejected_via_hash: vec!(),\n+                    rejected_via_triple: vec!(),\n+                    should_match_name: true,\n+                };\n+                let library = load_ctxt.load_library_crate();\n+                self.register_crate(root, ident, name, span, library)\n             }\n+            Some(cnum) => (cnum,\n+                           self.sess.cstore.get_crate_data(cnum),\n+                           self.sess.cstore.get_used_crate_source(cnum).unwrap())\n         }\n     }\n \n-    pub fn read_plugin_metadata(&mut self,\n-                                krate: &ast::ViewItem) -> PluginMetadata {\n-        let info = extract_crate_info(&self.env, krate).unwrap();\n-        let target_triple = self.env.sess.opts.target_triple[];\n+    // Go through the crate metadata and load any crates that it references\n+    fn resolve_crate_deps(&mut self,\n+                          root: &Option<CratePaths>,\n+                          cdata: &[u8], span : Span)\n+                       -> cstore::cnum_map {\n+        debug!(\"resolving deps of external crate\");\n+        // The map from crate numbers in the crate we're resolving to local crate\n+        // numbers\n+        decoder::get_crate_deps(cdata).iter().map(|dep| {\n+            debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n+            let (local_cnum, _, _) = self.resolve_crate(root,\n+                                                   dep.name[],\n+                                                   dep.name[],\n+                                                   Some(&dep.hash),\n+                                                   span,\n+                                                   PathKind::Dependency);\n+            (dep.cnum, local_cnum)\n+        }).collect()\n+    }\n+\n+    pub fn read_plugin_metadata<'b>(&'b mut self,\n+                                    vi: &'b ast::ViewItem) -> PluginMetadata<'b> {\n+        let info = self.extract_crate_info(vi).unwrap();\n+        let target_triple = self.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n+        let mut target_only = false;\n+        let ident = info.ident.clone();\n+        let name = info.name.clone();\n         let mut load_ctxt = loader::Context {\n-            sess: self.env.sess,\n-            span: krate.span,\n-            ident: info.ident[],\n-            crate_name: info.name[],\n+            sess: self.sess,\n+            span: vi.span,\n+            ident: ident[],\n+            crate_name: name[],\n             hash: None,\n-            filesearch: self.env.sess.host_filesearch(PathKind::Crate),\n+            filesearch: self.sess.host_filesearch(PathKind::Crate),\n             triple: config::host_triple(),\n             root: &None,\n             rejected_via_hash: vec!(),\n@@ -479,49 +492,106 @@ impl<'a> PluginMetadataReader<'a> {\n         let library = match load_ctxt.maybe_load_library_crate() {\n             Some(l) => l,\n             None if is_cross => {\n-                // try loading from target crates (only valid if there are\n-                // no syntax extensions)\n-                load_ctxt.triple = target_triple;\n-                load_ctxt.filesearch = self.env.sess.target_filesearch(PathKind::Crate);\n-                let lib = load_ctxt.load_library_crate();\n-                if decoder::get_plugin_registrar_fn(lib.metadata.as_slice()).is_some() {\n-                    let message = format!(\"crate `{}` contains a plugin_registrar fn but \\\n-                                  only a version for triple `{}` could be found (need {})\",\n-                                  info.ident, target_triple, config::host_triple());\n-                    self.env.sess.span_err(krate.span, message[]);\n-                    // need to abort now because the syntax expansion\n-                    // code will shortly attempt to load and execute\n-                    // code from the found library.\n-                    self.env.sess.abort_if_errors();\n-                }\n+                // Try loading from target crates. This will abort later if we try to\n+                // load a plugin registrar function,\n+                target_only = true;\n                 should_link = info.should_link;\n-                lib\n+\n+                load_ctxt.triple = target_triple;\n+                load_ctxt.filesearch = self.sess.target_filesearch(PathKind::Crate);\n+                load_ctxt.load_library_crate()\n             }\n             None => { load_ctxt.report_load_errs(); unreachable!() },\n         };\n-        let macros = decoder::get_exported_macros(library.metadata.as_slice());\n-        let registrar = decoder::get_plugin_registrar_fn(library.metadata.as_slice()).map(|id| {\n-            decoder::get_symbol(library.metadata.as_slice(), id)\n-        });\n-        if library.dylib.is_none() && registrar.is_some() {\n-            let message = format!(\"plugin crate `{}` only found in rlib format, \\\n-                                   but must be available in dylib format\",\n-                                  info.ident);\n-            self.env.sess.span_err(krate.span, message[]);\n-            // No need to abort because the loading code will just ignore this\n-            // empty dylib.\n-        }\n-        let pc = PluginMetadata {\n-            lib: library.dylib.clone(),\n-            macros: macros,\n-            registrar_symbol: registrar,\n+\n+        let dylib = library.dylib.clone();\n+        let register = should_link && self.existing_match(info.name[], None).is_none();\n+        let metadata = if register {\n+            // Register crate now to avoid double-reading metadata\n+            let (_, cmd, _) = self.register_crate(&None, info.ident[],\n+                                info.name[], vi.span, library);\n+            PMDSource::Registered(cmd)\n+        } else {\n+            // Not registering the crate; just hold on to the metadata\n+            PMDSource::Owned(library.metadata)\n         };\n-        if should_link && existing_match(&self.env, info.name[],\n-                                         None).is_none() {\n-            // register crate now to avoid double-reading metadata\n-            register_crate(&mut self.env, &None, info.ident[],\n-                           info.name[], krate.span, library);\n+\n+        PluginMetadata {\n+            sess: self.sess,\n+            metadata: metadata,\n+            dylib: dylib,\n+            info: info,\n+            vi_span: vi.span,\n+            target_only: target_only,\n+        }\n+    }\n+}\n+\n+impl<'a> PluginMetadata<'a> {\n+    /// Read exported macros\n+    pub fn exported_macros(&self) -> Vec<ast::MacroDef> {\n+        let imported_from = Some(token::intern(self.info.ident[]).ident());\n+        let source_name = format!(\"<{} macros>\", self.info.ident[]);\n+        let mut macros = vec![];\n+        decoder::each_exported_macro(self.metadata.as_slice(),\n+                                     &*self.sess.cstore.intr,\n+            |name, attrs, body| {\n+                // NB: Don't use parse::parse_tts_from_source_str because it parses with\n+                // quote_depth > 0.\n+                let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n+                                                              self.sess.opts.cfg.clone(),\n+                                                              source_name.clone(),\n+                                                              body);\n+                let lo = p.span.lo;\n+                let body = p.parse_all_token_trees();\n+                let span = mk_sp(lo, p.last_span.hi);\n+                p.abort_if_errors();\n+                macros.push(ast::MacroDef {\n+                    ident: name.ident(),\n+                    attrs: attrs,\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: span,\n+                    imported_from: imported_from,\n+                    // overridden in plugin/load.rs\n+                    export: false,\n+                    use_locally: false,\n+\n+                    body: body,\n+                });\n+                true\n+            }\n+        );\n+        macros\n+    }\n+\n+    /// Look for a plugin registrar. Returns library path and symbol name.\n+    pub fn plugin_registrar(&self) -> Option<(Path, String)> {\n+        if self.target_only {\n+            // Need to abort before syntax expansion.\n+            let message = format!(\"plugin crate `{}` is not available for triple `{}` \\\n+                                   (only found {})\",\n+                                  self.info.ident,\n+                                  config::host_triple(),\n+                                  self.sess.opts.target_triple);\n+            self.sess.span_err(self.vi_span, message[]);\n+            self.sess.abort_if_errors();\n+        }\n+\n+        let registrar = decoder::get_plugin_registrar_fn(self.metadata.as_slice())\n+            .map(|id| decoder::get_symbol(self.metadata.as_slice(), id));\n+\n+        match (self.dylib.as_ref(), registrar) {\n+            (Some(dylib), Some(reg)) => Some((dylib.clone(), reg)),\n+            (None, Some(_)) => {\n+                let message = format!(\"plugin crate `{}` only found in rlib format, \\\n+                                       but must be available in dylib format\",\n+                                       self.info.ident);\n+                self.sess.span_err(self.vi_span, message[]);\n+                // No need to abort because the loading code will just ignore this\n+                // empty dylib.\n+                None\n+            }\n+            _ => None,\n         }\n-        pc\n     }\n }"}, {"sha": "ec0b80c3a5342f26b6af6563ab6a628b0f2810b1", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -23,8 +23,8 @@ use metadata::loader;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n use std::cell::RefCell;\n-use std::c_vec::CVec;\n use std::rc::Rc;\n+use flate::Bytes;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::IdentInterner;\n@@ -36,7 +36,7 @@ use syntax::parse::token::IdentInterner;\n pub type cnum_map = FnvHashMap<ast::CrateNum, ast::CrateNum>;\n \n pub enum MetadataBlob {\n-    MetadataVec(CVec<u8>),\n+    MetadataVec(Bytes),\n     MetadataArchive(loader::ArchiveMetadata),\n }\n "}, {"sha": "ed0a1f6211b16edd5cc56be5cf8c7321e340c51d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -1353,15 +1353,16 @@ pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n         .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n }\n \n-pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n-    let macros = reader::get_doc(rbml::Doc::new(data),\n-                                 tag_exported_macros);\n-    let mut result = Vec::new();\n+pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n+    F: FnMut(ast::Name, Vec<ast::Attribute>, String) -> bool,\n+{\n+    let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n-        result.push(macro_doc.as_str().to_string());\n-        true\n+        let name = item_name(intr, macro_doc);\n+        let attrs = get_attributes(macro_doc);\n+        let body = reader::get_doc(macro_doc, tag_macro_def_body);\n+        f(name, attrs, body.as_str().to_string())\n     });\n-    result\n }\n \n pub fn get_dylib_dependency_formats(cdata: Cmd)"}, {"sha": "e4226ddde85b6540c0a6bd78e255e16420a46729", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -42,6 +42,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n+use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -1817,25 +1818,21 @@ fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     }\n }\n \n-/// Given a span, write the text of that span into the output stream\n-/// as an exported macro\n-fn encode_macro_def(ecx: &EncodeContext,\n-                    rbml_w: &mut Encoder,\n-                    span: &syntax::codemap::Span) {\n-    let def = ecx.tcx.sess.codemap().span_to_snippet(*span)\n-        .expect(\"Unable to find source for macro\");\n-    rbml_w.start_tag(tag_macro_def);\n-    rbml_w.wr_str(def[]);\n-    rbml_w.end_tag();\n-}\n-\n /// Serialize the text of the exported macros\n-fn encode_macro_defs(ecx: &EncodeContext,\n-                     krate: &ast::Crate,\n-                     rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_exported_macros);\n-    for item in krate.exported_macros.iter() {\n-        encode_macro_def(ecx, rbml_w, &item.span);\n+fn encode_macro_defs(rbml_w: &mut Encoder,\n+                     krate: &ast::Crate) {\n+    rbml_w.start_tag(tag_macro_defs);\n+    for def in krate.exported_macros.iter() {\n+        rbml_w.start_tag(tag_macro_def);\n+\n+        encode_name(rbml_w, def.ident.name);\n+        encode_attributes(rbml_w, def.attrs[]);\n+\n+        rbml_w.start_tag(tag_macro_def_body);\n+        rbml_w.wr_str(pprust::tts_to_string(def.body[])[]);\n+        rbml_w.end_tag();\n+\n+        rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n }\n@@ -2153,7 +2150,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     // Encode macro definitions\n     i = rbml_w.writer.tell().unwrap();\n-    encode_macro_defs(&ecx, krate, &mut rbml_w);\n+    encode_macro_defs(&mut rbml_w, krate);\n     stats.macro_defs_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the types of all unboxed closures in this crate."}, {"sha": "7c0645b4ca204037c451ef1c62f6232a7c547360", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -226,7 +226,7 @@ use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n use util::fs;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::io::fs::PathExtensions;\n@@ -720,9 +720,8 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n         }\n     }\n     unsafe {\n-        let mb = filename.with_c_str(|buf| {\n-            llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-        });\n+        let buf = CString::from_slice(filename.as_vec());\n+        let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n         if mb as int == 0 {\n             return Err(format!(\"error reading library: '{}'\",\n                                filename.display()))\n@@ -738,8 +737,9 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = String::from_raw_buf_len(name_buf as *const u8,\n-                                                name_len as uint);\n+            let name = slice::from_raw_buf(&(name_buf as *const u8),\n+                                           name_len as uint).to_vec();\n+            let name = String::from_utf8(name).unwrap();\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(is_osx) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);"}, {"sha": "3c672d0fdb6fa01057a9d69af99c66ed51c8be7b", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::PatBox(ref subpat) |\n-            ast::PatRegion(ref subpat) |\n+            ast::PatRegion(ref subpat, _) |\n             ast::PatIdent(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&**subpat, pred);\n                 self.add_node(pat.id, &[subpat_exit])"}, {"sha": "f2b9ecb5ec4322aa8af50c7a0d780aad0bee7682", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -473,7 +473,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             }\n         }\n \n-        ty::ty_rptr(_, ty::mt { ty, .. }) => {\n+        ty::ty_rptr(_, ty::mt { ty, mutbl }) => {\n             match ty.sty {\n                ty::ty_vec(_, Some(n)) => match ctor {\n                     &Single => {\n@@ -493,7 +493,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n \n                 _ => {\n                     assert_eq!(pats_len, 1);\n-                    ast::PatRegion(pats.nth(0).unwrap())\n+                    ast::PatRegion(pats.nth(0).unwrap(), mutbl)\n                 }\n             }\n         }\n@@ -860,7 +860,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         ast::PatTup(ref args) =>\n             Some(args.iter().map(|p| &**p).collect()),\n \n-        ast::PatBox(ref inner) | ast::PatRegion(ref inner) =>\n+        ast::PatBox(ref inner) | ast::PatRegion(ref inner, _) =>\n             Some(vec![&**inner]),\n \n         ast::PatLit(ref expr) => {"}, {"sha": "32482fce4daa8b05d556f35333e724f4980937cb", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -503,7 +503,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                                         \"target type not found for const cast\")\n                 });\n \n-        macro_rules! define_casts(\n+        macro_rules! define_casts {\n             ($val:ident, {\n                 $($ty_pat:pat => (\n                     $intermediate_ty:ty,\n@@ -524,7 +524,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                 },)*\n                 _ => Err(\"can't cast this type\".to_string())\n             })\n-        );\n+        }\n \n         eval_const_expr_partial(tcx, &**base)\n             .and_then(|val| define_casts!(val, {"}, {"sha": "e58ff53b00cb9f91c3e644f39075e4a70a9d9166", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -66,7 +66,8 @@ use super::region_inference::RegionResolutionError;\n use super::region_inference::ConcreteFailure;\n use super::region_inference::SubSupConflict;\n use super::region_inference::SupSupConflict;\n-use super::region_inference::ParamBoundFailure;\n+use super::region_inference::GenericBoundFailure;\n+use super::region_inference::GenericKind;\n use super::region_inference::ProcessedErrors;\n use super::region_inference::SameRegions;\n \n@@ -120,11 +121,11 @@ pub trait ErrorReporting<'tcx> {\n                                sub: Region,\n                                sup: Region);\n \n-    fn report_param_bound_failure(&self,\n-                                  origin: SubregionOrigin<'tcx>,\n-                                  param_ty: ty::ParamTy,\n-                                  sub: Region,\n-                                  sups: Vec<Region>);\n+    fn report_generic_bound_failure(&self,\n+                                    origin: SubregionOrigin<'tcx>,\n+                                    kind: GenericKind<'tcx>,\n+                                    sub: Region,\n+                                    sups: Vec<Region>);\n \n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n@@ -175,8 +176,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     self.report_concrete_failure(origin, sub, sup);\n                 }\n \n-                ParamBoundFailure(origin, param_ty, sub, sups) => {\n-                    self.report_param_bound_failure(origin, param_ty, sub, sups);\n+                GenericBoundFailure(kind, param_ty, sub, sups) => {\n+                    self.report_generic_bound_failure(kind, param_ty, sub, sups);\n                 }\n \n                 SubSupConflict(var_origin,\n@@ -421,63 +422,65 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                      found.user_string(self.tcx)))\n     }\n \n-    fn report_param_bound_failure(&self,\n-                                  origin: SubregionOrigin<'tcx>,\n-                                  param_ty: ty::ParamTy,\n-                                  sub: Region,\n-                                  _sups: Vec<Region>) {\n-\n+    fn report_generic_bound_failure(&self,\n+                                    origin: SubregionOrigin<'tcx>,\n+                                    bound_kind: GenericKind<'tcx>,\n+                                    sub: Region,\n+                                    _sups: Vec<Region>)\n+    {\n         // FIXME: it would be better to report the first error message\n         // with the span of the parameter itself, rather than the span\n         // where the error was detected. But that span is not readily\n         // accessible.\n \n+        let labeled_user_string = match bound_kind {\n+            GenericKind::Param(ref p) =>\n+                format!(\"the parameter type `{}`\", p.user_string(self.tcx)),\n+            GenericKind::Projection(ref p) =>\n+                format!(\"the associated type `{}`\", p.user_string(self.tcx)),\n+        };\n+\n         match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\n-                        \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx))[]);\n+                    format!(\"{} may not live long enough\", labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n-                        param_ty.user_string(self.tcx),\n+                        bound_kind.user_string(self.tcx),\n                         sub.user_string(self.tcx))[]);\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\n-                        \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx))[]);\n+                    format!(\"{} may not live long enough\", labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        param_ty.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx))[]);\n             }\n \n             _ => {\n                 // If not, be less specific.\n                 self.tcx.sess.span_err(\n                     origin.span(),\n                     format!(\n-                        \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx))[]);\n+                        \"{} may not live long enough\",\n+                        labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n-                        \"consider adding an explicit lifetime bound to `{}`\",\n-                        param_ty.user_string(self.tcx))[]);\n+                        \"consider adding an explicit lifetime bound for `{}`\",\n+                        bound_kind.user_string(self.tcx))[]);\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"the parameter type `{}` must be valid for \",\n-                            param_ty.user_string(self.tcx))[],\n+                    format!(\"{} must be valid for \", labeled_user_string)[],\n                     sub,\n                     \"...\");\n             }"}, {"sha": "c2db81d311483b5e72d57be2921e26f39ce176bd", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -20,6 +20,7 @@ pub use self::ValuePairs::*;\n pub use self::fixup_err::*;\n pub use middle::ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n+pub use self::region_inference::GenericKind;\n \n use middle::subst;\n use middle::subst::Substs;\n@@ -382,19 +383,6 @@ pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     cx.region_vars.commit(snapshot);\n }\n \n-pub fn verify_param_bound<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                    origin: SubregionOrigin<'tcx>,\n-                                    param_ty: ty::ParamTy,\n-                                    a: ty::Region,\n-                                    bs: Vec<ty::Region>) {\n-    debug!(\"verify_param_bound({}, {} <: {})\",\n-           param_ty.repr(cx.tcx),\n-           a.repr(cx.tcx),\n-           bs.repr(cx.tcx));\n-\n-    cx.region_vars.verify_param_bound(origin, param_ty, a, bs);\n-}\n-\n pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          a_is_expected: bool,\n                          origin: TypeOrigin,\n@@ -1070,6 +1058,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             value,\n             |br, _| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n     }\n+\n+    /// See `verify_generic_bound` method in `region_inference`\n+    pub fn verify_generic_bound(&self,\n+                                origin: SubregionOrigin<'tcx>,\n+                                kind: GenericKind<'tcx>,\n+                                a: ty::Region,\n+                                bs: Vec<ty::Region>) {\n+        debug!(\"verify_generic_bound({}, {} <: {})\",\n+               kind.repr(self.tcx),\n+               a.repr(self.tcx),\n+               bs.repr(self.tcx));\n+\n+        self.region_vars.verify_generic_bound(origin, kind, a, bs);\n+    }\n }\n \n impl<'tcx> TypeTrace<'tcx> {"}, {"sha": "d30a6ff1cd9d5f1e5b5f1e97c711fa405674ce06", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -22,15 +22,15 @@ use super::cres;\n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n use middle::region;\n-use middle::ty;\n+use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::graph;\n use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n@@ -61,12 +61,18 @@ pub enum Verify<'tcx> {\n     // `b` are inference variables.\n     VerifyRegSubReg(SubregionOrigin<'tcx>, Region, Region),\n \n-    // VerifyParamBound(T, _, R, RS): The parameter type `T` must\n-    // outlive the region `R`. `T` is known to outlive `RS`. Therefore\n-    // verify that `R <= RS[i]` for some `i`. Inference variables may\n-    // be involved (but this verification step doesn't influence\n-    // inference).\n-    VerifyParamBound(ty::ParamTy, SubregionOrigin<'tcx>, Region, Vec<Region>),\n+    // VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+    // associated type) must outlive the region `R`. `T` is known to\n+    // outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+    // `i`. Inference variables may be involved (but this verification\n+    // step doesn't influence inference).\n+    VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, Vec<Region>),\n+}\n+\n+#[derive(Clone, Show, PartialEq, Eq)]\n+pub enum GenericKind<'tcx> {\n+    Param(ty::ParamTy),\n+    Projection(ty::ProjectionTy<'tcx>),\n }\n \n #[derive(Copy, PartialEq, Eq, Hash)]\n@@ -98,12 +104,12 @@ pub enum RegionResolutionError<'tcx> {\n     /// `o` requires that `a <= b`, but this does not hold\n     ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n \n-    /// `ParamBoundFailure(p, s, a, bs)\n+    /// `GenericBoundFailure(p, s, a, bs)\n     ///\n-    /// The parameter type `p` must be known to outlive the lifetime\n+    /// The parameter/assocated-type `p` must be known to outlive the lifetime\n     /// `a`, but it is only known to outlive `bs` (and none of the\n     /// regions in `bs` outlive `a`).\n-    ParamBoundFailure(SubregionOrigin<'tcx>, ty::ParamTy, Region, Vec<Region>),\n+    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region, Vec<Region>),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n@@ -489,12 +495,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    pub fn verify_param_bound(&self,\n-                              origin: SubregionOrigin<'tcx>,\n-                              param_ty: ty::ParamTy,\n-                              sub: Region,\n-                              sups: Vec<Region>) {\n-        self.add_verify(VerifyParamBound(param_ty, origin, sub, sups));\n+    /// See `Verify::VerifyGenericBound`\n+    pub fn verify_generic_bound(&self,\n+                                origin: SubregionOrigin<'tcx>,\n+                                kind: GenericKind<'tcx>,\n+                                sub: Region,\n+                                sups: Vec<Region>) {\n+        self.add_verify(VerifyGenericBound(kind, origin, sub, sups));\n     }\n \n     pub fn lub_regions(&self,\n@@ -660,7 +667,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                     &mut result_set, r,\n                                     a, b);\n                             }\n-                            VerifyParamBound(_, _, a, ref bs) => {\n+                            VerifyGenericBound(_, _, a, ref bs) => {\n                                 for &b in bs.iter() {\n                                     consider_adding_bidirectional_edges(\n                                         &mut result_set, r,\n@@ -1211,7 +1218,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n \n-                VerifyParamBound(ref param_ty, ref origin, sub, ref sups) => {\n+                VerifyGenericBound(ref kind, ref origin, sub, ref sups) => {\n                     let sub = normalize(values, sub);\n                     if sups.iter()\n                            .map(|&sup| normalize(values, sup))\n@@ -1223,8 +1230,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     let sups = sups.iter().map(|&sup| normalize(values, sup))\n                                           .collect();\n                     errors.push(\n-                        ParamBoundFailure(\n-                            (*origin).clone(), *param_ty, sub, sups));\n+                        GenericBoundFailure(\n+                            (*origin).clone(), kind.clone(), sub, sups));\n                 }\n             }\n         }\n@@ -1584,8 +1591,8 @@ impl<'tcx> Repr<'tcx> for Verify<'tcx> {\n             VerifyRegSubReg(_, ref a, ref b) => {\n                 format!(\"VerifyRegSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n             }\n-            VerifyParamBound(_, ref p, ref a, ref bs) => {\n-                format!(\"VerifyParamBound({}, {}, {})\",\n+            VerifyGenericBound(_, ref p, ref a, ref bs) => {\n+                format!(\"VerifyGenericBound({}, {}, {})\",\n                         p.repr(tcx), a.repr(tcx), bs.repr(tcx))\n             }\n         }\n@@ -1624,3 +1631,32 @@ impl<'tcx> Repr<'tcx> for RegionAndOrigin<'tcx> {\n                 self.origin.repr(tcx))\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for GenericKind<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            GenericKind::Param(ref p) => p.repr(tcx),\n+            GenericKind::Projection(ref p) => p.repr(tcx),\n+        }\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for GenericKind<'tcx> {\n+    fn user_string(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            GenericKind::Param(ref p) => p.user_string(tcx),\n+            GenericKind::Projection(ref p) => p.user_string(tcx),\n+        }\n+    }\n+}\n+\n+impl<'tcx> GenericKind<'tcx> {\n+    pub fn to_ty(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            GenericKind::Param(ref p) =>\n+                p.to_ty(tcx),\n+            GenericKind::Projection(ref p) =>\n+                ty::mk_projection(tcx, p.trait_ref.clone(), p.item_name),\n+        }\n+    }\n+}"}, {"sha": "a83416667abdc331eaf8534011977c4826e8fa00", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         // However, it's not as simple as checking whether `T :\n         // Sized`, because even if `T : Sized` does not hold, that\n         // just means that `T` *may* not be sized.  After all, even a\n-        // type parameter `Sized? T` could be bound to a sized\n+        // type parameter `T: ?Sized` could be bound to a sized\n         // type. (Issue #20116)\n         //\n         // To handle this, we first check for \"interior\" type\n@@ -139,16 +139,16 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         // exhaustively checking all possible combinations. Here are some examples:\n         //\n         // ```\n-        // fn foo<T,U>() {\n+        // fn foo<T, U>() {\n         //     // T=int, U=int\n         // }\n         //\n-        // fn bar<Sized? T,U>() {\n+        // fn bar<T: ?Sized, U>() {\n         //     // T=int, U=int\n         //     // T=[int], U=int\n         // }\n         //\n-        // fn baz<Sized? T, Sized?U>() {\n+        // fn baz<T: ?Sized, U: ?Sized>() {\n         //     // T=int, U=int\n         //     // T=[int], U=int\n         //     // T=int, U=[int]"}, {"sha": "2b8c9b532e593270e035fbac2fde45769f3a6e42", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -1235,8 +1235,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n           }\n \n-          ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n-            // @p1, ~p1, ref p1\n+          ast::PatBox(ref subpat) | ast::PatRegion(ref subpat, _) => {\n+            // box p1, &p1, &mut p1.  we can ignore the mutability of\n+            // PatRegion since that information is already contained\n+            // in the type.\n             let subcmt = try!(self.cat_deref(pat, cmt, 0, false));\n               try!(self.cat_pattern_(subcmt, &**subpat, op));\n           }"}, {"sha": "42b6e54420b409ed9e014e793f8e7e93e597a2a5", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -14,7 +14,7 @@ use super::SelectionContext;\n use super::{Obligation, ObligationCause};\n use super::util;\n \n-use middle::subst::Subst;\n+use middle::subst::{Subst};\n use middle::ty::{self, Ty};\n use middle::infer::InferCtxt;\n use std::collections::HashSet;\n@@ -53,20 +53,20 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n }\n \n #[allow(missing_copy_implementations)]\n-pub enum OrphanCheckErr {\n+pub enum OrphanCheckErr<'tcx> {\n     NoLocalInputType,\n-    UncoveredTypeParameter(ty::ParamTy),\n+    UncoveredTy(Ty<'tcx>),\n }\n \n /// Checks the coherence orphan rules. `impl_def_id` should be the\n /// def-id of a trait impl. To pass, either the trait must be local, or else\n /// two conditions must be satisfied:\n ///\n-/// 1. At least one of the input types must involve a local type.\n-/// 2. All type parameters must be covered by a local type.\n-pub fn orphan_check(tcx: &ty::ctxt,\n-                    impl_def_id: ast::DefId)\n-                    -> Result<(), OrphanCheckErr>\n+/// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n+/// 2. Some local type must appear in `Self`.\n+pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                          impl_def_id: ast::DefId)\n+                          -> Result<(), OrphanCheckErr<'tcx>>\n {\n     debug!(\"impl_is_local({})\", impl_def_id.repr(tcx));\n \n@@ -82,31 +82,21 @@ pub fn orphan_check(tcx: &ty::ctxt,\n         return Ok(());\n     }\n \n-    // Check condition 1: at least one type must be local.\n-    if !trait_ref.input_types().iter().any(|&t| ty_reaches_local(tcx, t)) {\n-        return Err(OrphanCheckErr::NoLocalInputType);\n+    // Otherwise, check that (1) all type parameters are covered.\n+    let covered_params = type_parameters_covered_by_ty(tcx, trait_ref.self_ty());\n+    let all_params = type_parameters_reachable_from_ty(trait_ref.self_ty());\n+    for &param in all_params.difference(&covered_params) {\n+        return Err(OrphanCheckErr::UncoveredTy(param));\n     }\n \n-    // Check condition 2: type parameters must be \"covered\" by a local type.\n-    let covered_params: HashSet<_> =\n-        trait_ref.input_types().iter()\n-                               .flat_map(|&t| type_parameters_covered_by_ty(tcx, t).into_iter())\n-                               .collect();\n-    let all_params: HashSet<_> =\n-        trait_ref.input_types().iter()\n-                               .flat_map(|&t| type_parameters_reachable_from_ty(t).into_iter())\n-                               .collect();\n-    for &param in all_params.difference(&covered_params) {\n-        return Err(OrphanCheckErr::UncoveredTypeParameter(param));\n+    // And (2) some local type appears.\n+    if !trait_ref.self_ty().walk().any(|t| ty_is_local_constructor(tcx, t)) {\n+        return Err(OrphanCheckErr::NoLocalInputType);\n     }\n \n     return Ok(());\n }\n \n-fn ty_reaches_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.walk().any(|t| ty_is_local_constructor(tcx, t))\n-}\n-\n fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n \n@@ -153,8 +143,8 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n fn type_parameters_covered_by_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 ty: Ty<'tcx>)\n-                                 -> HashSet<ty::ParamTy>\n+                                       ty: Ty<'tcx>)\n+                                       -> HashSet<Ty<'tcx>>\n {\n     if ty_is_local_constructor(tcx, ty) {\n         type_parameters_reachable_from_ty(ty)\n@@ -164,14 +154,14 @@ fn type_parameters_covered_by_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n /// All type parameters reachable from `ty`\n-fn type_parameters_reachable_from_ty<'tcx>(ty: Ty<'tcx>) -> HashSet<ty::ParamTy> {\n+fn type_parameters_reachable_from_ty<'tcx>(ty: Ty<'tcx>) -> HashSet<Ty<'tcx>> {\n     ty.walk()\n-        .filter_map(|t| {\n+        .filter(|&t| {\n             match t.sty {\n-                ty::ty_param(ref param_ty) => Some(param_ty.clone()),\n-                _ => None,\n+                // FIXME(#20590) straighten story about projection types\n+                ty::ty_projection(..) | ty::ty_param(..) => true,\n+                _ => false,\n             }\n         })\n         .collect()\n }\n-"}, {"sha": "65f7ad296db519855ac5cd625d79f7b11c972db7", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -643,11 +643,12 @@ fn confirm_candidate<'cx,'tcx>(\n             match impl_ty {\n                 Some(ty) => (ty, impl_vtable.nested.to_vec()),\n                 None => {\n-                    selcx.tcx().sess.span_bug(\n-                        obligation.cause.span,\n-                        format!(\"impl `{}` did not contain projection for `{}`\",\n-                                impl_vtable.repr(selcx.tcx()),\n-                                obligation.repr(selcx.tcx())).as_slice());\n+                    // This means that the impl is missing a\n+                    // definition for the associated type. This error\n+                    // ought to be reported by the type checker method\n+                    // `check_impl_items_against_trait`, so here we\n+                    // just return ty_err.\n+                    (selcx.tcx().types.err, vec!())\n                 }\n             }\n         }"}, {"sha": "229d34fe4237c22df7a49a2cb08740c3f89c1fd7", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -92,8 +92,8 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n                 // Only keep those bounds that we haven't already\n                 // seen.  This is necessary to prevent infinite\n                 // recursion in some cases.  One common case is when\n-                // people define `trait Sized { }` rather than `trait\n-                // Sized for Sized? { }`.\n+                // people define `trait Sized: Sized { }` rather than `trait\n+                // Sized { }`.\n                 predicates.retain(|r| self.visited.insert(r.clone()));\n \n                 self.stack.push(StackEntry { position: 0,"}, {"sha": "c359233eca173cd4ad7b9fe05d76b6838a4bc6d4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -1776,6 +1776,10 @@ impl<'tcx> Generics<'tcx> {\n         !self.regions.is_empty_in(space)\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        self.types.is_empty() && self.regions.is_empty()\n+    }\n+\n     pub fn to_bounds(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>)\n                      -> GenericBounds<'tcx> {\n         GenericBounds {\n@@ -6167,8 +6171,8 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n     return state.result();\n \n     fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh, state: &mut sip::SipState) {\n-        macro_rules! byte( ($b:expr) => { ($b as u8).hash(state) } );\n-        macro_rules! hash( ($e:expr) => { $e.hash(state) } );\n+        macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n+        macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n \n         let region = |&: state: &mut sip::SipState, r: Region| {\n             match r {"}, {"sha": "44a223954858a76d7089143c981353b2a72a705a", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 125, "deletions": 44, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,55 +8,55 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Used by `rustc` when loading a plugin.\n+//! Used by `rustc` when loading a plugin, or a crate with exported macros.\n \n use session::Session;\n-use metadata::creader::PluginMetadataReader;\n+use metadata::creader::CrateReader;\n use plugin::registry::Registry;\n \n use std::mem;\n use std::os;\n use std::dynamic_lib::DynamicLibrary;\n+use std::collections::HashSet;\n use syntax::ast;\n use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::ext::expand::ExportedMacros;\n use syntax::attr::AttrMetaMethods;\n \n-/// Plugin-related crate metadata.\n-pub struct PluginMetadata {\n-    /// Source code of macros exported by the crate.\n-    pub macros: Vec<String>,\n-    /// Path to the shared library file.\n-    pub lib: Option<Path>,\n-    /// Symbol name of the plugin registrar function.\n-    pub registrar_symbol: Option<String>,\n-}\n-\n /// Pointer to a registrar function.\n pub type PluginRegistrarFun =\n     fn(&mut Registry);\n \n+pub struct PluginRegistrar {\n+    pub fun: PluginRegistrarFun,\n+    pub args: P<ast::MetaItem>,\n+}\n+\n /// Information about loaded plugins.\n pub struct Plugins {\n-    /// Source code of exported macros.\n-    pub macros: Vec<ExportedMacros>,\n+    /// Imported macros.\n+    pub macros: Vec<ast::MacroDef>,\n     /// Registrars, as function pointers.\n-    pub registrars: Vec<PluginRegistrarFun>,\n+    pub registrars: Vec<PluginRegistrar>,\n }\n \n struct PluginLoader<'a> {\n     sess: &'a Session,\n-    reader: PluginMetadataReader<'a>,\n+    span_whitelist: HashSet<Span>,\n+    reader: CrateReader<'a>,\n     plugins: Plugins,\n }\n \n impl<'a> PluginLoader<'a> {\n     fn new(sess: &'a Session) -> PluginLoader<'a> {\n         PluginLoader {\n             sess: sess,\n-            reader: PluginMetadataReader::new(sess),\n+            reader: CrateReader::new(sess),\n+            span_whitelist: HashSet::new(),\n             plugins: Plugins {\n                 macros: vec!(),\n                 registrars: vec!(),\n@@ -69,6 +69,14 @@ impl<'a> PluginLoader<'a> {\n pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n                     addl_plugins: Option<Plugins>) -> Plugins {\n     let mut loader = PluginLoader::new(sess);\n+\n+    // We need to error on `#[macro_use] extern crate` when it isn't at the\n+    // crate root, because `$crate` won't work properly. Identify these by\n+    // spans, because the crate map isn't set up yet.\n+    for vi in krate.module.view_items.iter() {\n+        loader.span_whitelist.insert(vi.span);\n+    }\n+\n     visit::walk_crate(&mut loader, krate);\n \n     let mut plugins = loader.plugins;\n@@ -89,41 +97,112 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n // note that macros aren't expanded yet, and therefore macros can't add plugins.\n impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n     fn visit_view_item(&mut self, vi: &ast::ViewItem) {\n+        // We're only interested in `extern crate`.\n         match vi.node {\n-            ast::ViewItemExternCrate(name, _, _) => {\n-                let mut plugin_phase = false;\n+            ast::ViewItemExternCrate(..) => (),\n+            _ => return,\n+        }\n \n-                for attr in vi.attrs.iter().filter(|a| a.check_name(\"phase\")) {\n-                    let phases = attr.meta_item_list().unwrap_or(&[]);\n-                    if attr::contains_name(phases, \"plugin\") {\n-                        plugin_phase = true;\n+        // Parse the attributes relating to macro / plugin loading.\n+        let mut plugin_attr = None;\n+        let mut macro_selection = Some(HashSet::new());  // None => load all\n+        let mut reexport = HashSet::new();\n+        for attr in vi.attrs.iter() {\n+            let mut used = true;\n+            match attr.name().get() {\n+                \"phase\" => {\n+                    self.sess.span_err(attr.span, \"#[phase] is deprecated; use \\\n+                                       #[macro_use], #[plugin], and/or #[no_link]\");\n+                }\n+                \"plugin\" => {\n+                    if plugin_attr.is_some() {\n+                        self.sess.span_err(attr.span, \"#[plugin] specified multiple times\");\n+                    }\n+                    plugin_attr = Some(attr.node.value.clone());\n+                }\n+                \"macro_use\" => {\n+                    let names = attr.meta_item_list();\n+                    if names.is_none() {\n+                        // no names => load all\n+                        macro_selection = None;\n+                    }\n+                    if let (Some(sel), Some(names)) = (macro_selection.as_mut(), names) {\n+                        for name in names.iter() {\n+                            if let ast::MetaWord(ref name) = name.node {\n+                                sel.insert(name.clone());\n+                            } else {\n+                                self.sess.span_err(name.span, \"bad macro import\");\n+                            }\n+                        }\n                     }\n-                    if attr::contains_name(phases, \"syntax\") {\n-                        plugin_phase = true;\n-                        self.sess.span_warn(attr.span,\n-                            \"phase(syntax) is a deprecated synonym for phase(plugin)\");\n+                }\n+                \"macro_reexport\" => {\n+                    let names = match attr.meta_item_list() {\n+                        Some(names) => names,\n+                        None => {\n+                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                            continue;\n+                        }\n+                    };\n+\n+                    for name in names.iter() {\n+                        if let ast::MetaWord(ref name) = name.node {\n+                            reexport.insert(name.clone());\n+                        } else {\n+                            self.sess.span_err(name.span, \"bad macro reexport\");\n+                        }\n                     }\n                 }\n+                _ => used = false,\n+            }\n+            if used {\n+                attr::mark_used(attr);\n+            }\n+        }\n \n-                if !plugin_phase { return; }\n+        let mut macros = vec![];\n+        let mut registrar = None;\n \n-                let PluginMetadata { macros, lib, registrar_symbol } =\n-                    self.reader.read_plugin_metadata(vi);\n+        let load_macros = match macro_selection.as_ref() {\n+            Some(sel) => sel.len() != 0 || reexport.len() != 0,\n+            None => true,\n+        };\n+        let load_registrar = plugin_attr.is_some();\n \n-                self.plugins.macros.push(ExportedMacros {\n-                    crate_name: name,\n-                    macros: macros,\n-                });\n+        if load_macros && !self.span_whitelist.contains(&vi.span) {\n+            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n+                                         the crate root\");\n+        }\n \n-                match (lib, registrar_symbol) {\n-                    (Some(lib), Some(symbol))\n-                        => self.dylink_registrar(vi, lib, symbol),\n-                    _ => (),\n-                }\n+        if load_macros || load_registrar {\n+            let pmd = self.reader.read_plugin_metadata(vi);\n+            if load_macros {\n+                macros = pmd.exported_macros();\n+            }\n+            if load_registrar {\n+                registrar = pmd.plugin_registrar();\n             }\n-            _ => (),\n+        }\n+\n+        for mut def in macros.into_iter() {\n+            let name = token::get_ident(def.ident);\n+            def.use_locally = match macro_selection.as_ref() {\n+                None => true,\n+                Some(sel) => sel.contains(&name),\n+            };\n+            def.export = reexport.contains(&name);\n+            self.plugins.macros.push(def);\n+        }\n+\n+        if let Some((lib, symbol)) = registrar {\n+            let fun = self.dylink_registrar(vi, lib, symbol);\n+            self.plugins.registrars.push(PluginRegistrar {\n+                fun: fun,\n+                args: plugin_attr.unwrap(),\n+            });\n         }\n     }\n+\n     fn visit_mac(&mut self, _: &ast::Mac) {\n         // bummer... can't see plugins inside macros.\n         // do nothing.\n@@ -132,7 +211,10 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n \n impl<'a> PluginLoader<'a> {\n     // Dynamically link a registrar function into the compiler process.\n-    fn dylink_registrar(&mut self, vi: &ast::ViewItem, path: Path, symbol: String) {\n+    fn dylink_registrar(&mut self,\n+                        vi: &ast::ViewItem,\n+                        path: Path,\n+                        symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n         let path = os::make_absolute(&path).unwrap();\n \n@@ -154,13 +236,12 @@ impl<'a> PluginLoader<'a> {\n                     Err(err) => self.sess.span_fatal(vi.span, err[])\n                 };\n \n-            self.plugins.registrars.push(registrar);\n-\n             // Intentionally leak the dynamic library. We can't ever unload it\n             // since the library can make things that will live arbitrarily long\n             // (e.g. an @-box cycle or a task).\n             mem::forget(lib);\n \n+            registrar\n         }\n     }\n }"}, {"sha": "fd8873454b4d983fe21831454c17fe083744075e", "filename": "src/librustc/plugin/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fplugin%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fplugin%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -43,14 +43,14 @@\n //! To use a plugin while compiling another crate:\n //!\n //! ```rust\n-//! #![feature(phase)]\n+//! #![feature(plugin)]\n //!\n-//! #[phase(plugin)]\n+//! #[plugin]\n //! extern crate myplugin;\n //! ```\n //!\n-//! If you also need the plugin crate available at runtime, use\n-//! `phase(plugin, link)`.\n+//! If you don't need the plugin crate available at runtime, use\n+//! `#[no_link]` as well.\n //!\n //! See [the compiler plugin guide](../../guide-plugin.html)\n //! for more examples."}, {"sha": "feec97f02da55dd204399f7bdf39066605298934", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -11,12 +11,14 @@\n //! Used by plugin crates to tell `rustc` about the plugins they provide.\n \n use lint::{LintPassObject, LintId, Lint};\n+use session::Session;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n-use syntax::ext::base::{IdentTT, LetSyntaxTT, Decorator, Modifier};\n+use syntax::ext::base::{IdentTT, Decorator, Modifier, MacroRulesTT};\n use syntax::ext::base::{MacroExpanderFn};\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::ast;\n \n use std::collections::HashMap;\n@@ -29,7 +31,14 @@ use std::collections::HashMap;\n /// This struct has public fields and other methods for use by `rustc`\n /// itself. They are not documented here, and plugin authors should\n /// not use them.\n-pub struct Registry {\n+pub struct Registry<'a> {\n+    /// Compiler session. Useful if you want to emit diagnostic messages\n+    /// from the plugin registrar.\n+    pub sess: &'a Session,\n+\n+    #[doc(hidden)]\n+    pub args_hidden: Option<P<ast::MetaItem>>,\n+\n     #[doc(hidden)]\n     pub krate_span: Span,\n \n@@ -43,17 +52,27 @@ pub struct Registry {\n     pub lint_groups: HashMap<&'static str, Vec<LintId>>,\n }\n \n-impl Registry {\n+impl<'a> Registry<'a> {\n     #[doc(hidden)]\n-    pub fn new(krate: &ast::Crate) -> Registry {\n+    pub fn new(sess: &'a Session, krate: &ast::Crate) -> Registry<'a> {\n         Registry {\n+            sess: sess,\n+            args_hidden: None,\n             krate_span: krate.span,\n             syntax_exts: vec!(),\n             lint_passes: vec!(),\n             lint_groups: HashMap::new(),\n         }\n     }\n \n+    /// Get the `#[plugin]` attribute used to load this plugin.\n+    ///\n+    /// This gives access to arguments passed via `#[plugin=...]` or\n+    /// `#[plugin(...)]`.\n+    pub fn args<'b>(&'b self) -> &'b P<ast::MetaItem> {\n+        self.args_hidden.as_ref().expect(\"args not set\")\n+    }\n+\n     /// Register a syntax extension of any kind.\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n@@ -63,8 +82,11 @@ impl Registry {\n             IdentTT(ext, _) => IdentTT(ext, Some(self.krate_span)),\n             Decorator(ext) => Decorator(ext),\n             Modifier(ext) => Modifier(ext),\n-            // there's probably a nicer way to signal this:\n-            LetSyntaxTT(_, _) => panic!(\"can't register a new LetSyntax!\"),\n+\n+            MacroRulesTT => {\n+                self.sess.err(\"plugin tried to register a new MacroRulesTT\");\n+                return;\n+            }\n         }));\n     }\n "}, {"sha": "138f648049c73f748e6937474f7e94ff38054148", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -105,6 +105,7 @@ pub struct Options {\n     pub prints: Vec<PrintRequest>,\n     pub cg: CodegenOptions,\n     pub color: ColorConfig,\n+    pub show_span: Option<String>,\n     pub externs: HashMap<String, Vec<String>>,\n     pub crate_name: Option<String>,\n     /// An optional name to use as the crate for std during std injection,\n@@ -211,6 +212,7 @@ pub fn basic_options() -> Options {\n         prints: Vec::new(),\n         cg: basic_codegen_options(),\n         color: Auto,\n+        show_span: None,\n         externs: HashMap::new(),\n         crate_name: None,\n         alt_std_name: None,\n@@ -259,7 +261,6 @@ debugging_opts! {\n         BORROWCK_STATS,\n         NO_LANDING_PADS,\n         DEBUG_LLVM,\n-        SHOW_SPAN,\n         COUNT_TYPE_SIZES,\n         META_STATS,\n         GC,\n@@ -299,7 +300,6 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"no-landing-pads\", \"omit landing pads for unwinding\",\n       NO_LANDING_PADS),\n      (\"debug-llvm\", \"enable debug output from LLVM\", DEBUG_LLVM),\n-     (\"show-span\", \"show spans for compiler debugging\", SHOW_SPAN),\n      (\"count-type-sizes\", \"count the sizes of aggregate types\",\n       COUNT_TYPE_SIZES),\n      (\"meta-stats\", \"gather metadata statistics\", META_STATS),\n@@ -823,6 +823,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                       `flowgraph=<nodeid>` (graphviz formatted flowgraph for node), or\n                       `everybody_loops` (all function bodies replaced with `loop {}`).\",\n                      \"TYPE\"),\n+        opt::opt_u(\"\", \"show-span\", \"Show spans for compiler debugging\", \"expr|pat|ty\"),\n         opt::flagopt(\"\", \"dep-info\",\n                  \"Output dependency info to <filename> after compiling, \\\n                   in a format suitable for use by Makefiles\", \"FILENAME\"),\n@@ -1143,6 +1144,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         prints: prints,\n         cg: cg,\n         color: color,\n+        show_span: None,\n         externs: externs,\n         crate_name: crate_name,\n         alt_std_name: None,"}, {"sha": "abb780615ae7b8170f6f8801dd660e3368417683", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -201,8 +201,8 @@ impl Session {\n     pub fn no_landing_pads(&self) -> bool {\n         self.debugging_opt(config::NO_LANDING_PADS)\n     }\n-    pub fn show_span(&self) -> bool {\n-        self.debugging_opt(config::SHOW_SPAN)\n+    pub fn unstable_options(&self) -> bool {\n+        self.debugging_opt(config::UNSTABLE_OPTIONS)\n     }\n     pub fn print_enum_sizes(&self) -> bool {\n         self.debugging_opt(config::PRINT_ENUM_SIZES)"}, {"sha": "ee224d1ec80fe0361a1b52506accf6e55c1f08a4", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -75,7 +75,7 @@ pub struct FnvHasher;\n pub struct FnvState(u64);\n \n impl Hasher<FnvState> for FnvHasher {\n-    fn hash<Sized? T: Hash<FnvState>>(&self, t: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<FnvState>>(&self, t: &T) -> u64 {\n         let mut state = FnvState(0xcbf29ce484222325);\n         t.hash(&mut state);\n         let FnvState(ret) = state;"}, {"sha": "8c2a9993004d99c4e6d96ff2ca49181aa2d5108f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -38,7 +38,7 @@ use syntax::{ast, ast_util};\n use syntax::owned_slice::OwnedSlice;\n \n /// Produces a string suitable for debugging output.\n-pub trait Repr<'tcx> for Sized? {\n+pub trait Repr<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String;\n }\n \n@@ -601,7 +601,7 @@ impl<'tcx> Repr<'tcx> for () {\n     }\n }\n \n-impl<'a, 'tcx, Sized? T:Repr<'tcx>> Repr<'tcx> for &'a T {\n+impl<'a, 'tcx, T: ?Sized +Repr<'tcx>> Repr<'tcx> for &'a T {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         Repr::repr(*self, tcx)\n     }"}, {"sha": "238c84e88a9e0178fb37d9e17ffca8fd71535ee5", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -34,8 +34,14 @@\n #![feature(unboxed_closures)]\n #![feature(old_orphan_check)]\n \n+#[cfg(stage0)]\n #[phase(plugin, link)]\n extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n extern crate syntax;\n extern crate serialize;\n "}, {"sha": "d606c5158d0f7d930ae003664e2ac4cee9f47f59", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -346,12 +346,12 @@ impl Engine256State {\n \n         // Sha-512 and Sha-256 use basically the same calculations which are implemented\n         // by these macros. Inlining the calculations seems to result in better generated code.\n-        macro_rules! schedule_round( ($t:expr) => (\n+        macro_rules! schedule_round { ($t:expr) => (\n                 w[$t] = sigma1(w[$t - 2]) + w[$t - 7] + sigma0(w[$t - 15]) + w[$t - 16];\n                 )\n-        );\n+        }\n \n-        macro_rules! sha2_round(\n+        macro_rules! sha2_round {\n             ($A:ident, $B:ident, $C:ident, $D:ident,\n              $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n                 {\n@@ -360,7 +360,7 @@ impl Engine256State {\n                     $H += sum0($A) + maj($A, $B, $C);\n                 }\n              )\n-        );\n+        }\n \n         read_u32v_be(w.slice_mut(0, 16), data);\n "}, {"sha": "86bd74d3f85e5b2ca97769ca579130767638a09a", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -327,11 +327,11 @@ mod svh_visitor {\n \n     impl<'a, 'v> Visitor<'v> for StrictVersionHashVisitor<'a> {\n \n-        fn visit_mac(&mut self, macro: &Mac) {\n+        fn visit_mac(&mut self, mac: &Mac) {\n             // macro invocations, namely macro_rules definitions,\n             // *can* appear as items, even in the expanded crate AST.\n \n-            if macro_name(macro).get() == \"macro_rules\" {\n+            if macro_name(mac).get() == \"macro_rules\" {\n                 // Pretty-printing definition to a string strips out\n                 // surface artifacts (currently), such as the span\n                 // information, yielding a content-based hash.\n@@ -341,22 +341,22 @@ mod svh_visitor {\n                 // trees might be faster. Implementing this is far\n                 // easier in short term.\n                 let macro_defn_as_string = pprust::to_string(|pp_state| {\n-                    pp_state.print_mac(macro, token::Paren)\n+                    pp_state.print_mac(mac, token::Paren)\n                 });\n                 macro_defn_as_string.hash(self.st);\n             } else {\n                 // It is not possible to observe any kind of macro\n                 // invocation at this stage except `macro_rules!`.\n                 panic!(\"reached macro somehow: {}\",\n                       pprust::to_string(|pp_state| {\n-                          pp_state.print_mac(macro, token::Paren)\n+                          pp_state.print_mac(mac, token::Paren)\n                       }));\n             }\n \n-            visit::walk_mac(self, macro);\n+            visit::walk_mac(self, mac);\n \n-            fn macro_name(macro: &Mac) -> token::InternedString {\n-                match &macro.node {\n+            fn macro_name(mac: &Mac) -> token::InternedString {\n+                match &mac.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n                         let s = path.segments[];\n                         assert_eq!(s.len(), 1);"}, {"sha": "f14583bb9aa81b23282861f47019b9786790d6ce", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -239,7 +239,7 @@ impl Target {\n             options: Default::default(),\n         };\n \n-        macro_rules! key (\n+        macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 obj.find(name[]).map(|o| o.as_string()\n@@ -257,7 +257,7 @@ impl Target {\n                         )\n                     );\n             } );\n-        );\n+        }\n \n         key!(cpu);\n         key!(linker);\n@@ -305,7 +305,7 @@ impl Target {\n         }\n \n         // this would use a match if stringify! were allowed in pattern position\n-        macro_rules! load_specific (\n+        macro_rules! load_specific {\n             ( $($name:ident),+ ) => (\n                 {\n                     let target = target.replace(\"-\", \"_\");\n@@ -326,7 +326,7 @@ impl Target {\n                     }\n                 }\n             )\n-        );\n+        }\n \n         load_specific!(\n             x86_64_unknown_linux_gnu,"}, {"sha": "20949151557cbeec572e1cd76102e75ec5d2c399", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -39,15 +39,6 @@ use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n use syntax::ast::{FnDecl, Block, NodeId};\n \n-macro_rules! if_ok {\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => { v }\n-            Err(e) => { return Err(e); }\n-        }\n-    )\n-}\n-\n pub mod doc;\n \n pub mod check_loans;"}, {"sha": "0600ddba01897e1e257848c6533ca51b90c9c67a", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -24,8 +24,21 @@\n #![feature(old_orphan_check)]\n #![allow(non_camel_case_types)]\n \n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits."}, {"sha": "74f81ae9d6d1eeb7f256f4cc940e847caa7a574d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,7 +12,7 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input, OutputFilenames};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::metadata::creader;\n+use rustc::metadata::creader::CrateReader;\n use rustc::middle::{stability, ty, reachable};\n use rustc::middle::dependency_format;\n use rustc::middle;\n@@ -146,8 +146,8 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n         println!(\"{}\", json::as_json(&krate));\n     }\n \n-    if sess.show_span() {\n-        syntax::show_span::run(sess.diagnostic(), &krate);\n+    if let Some(ref s) = sess.opts.show_span {\n+        syntax::show_span::run(sess.diagnostic(), s.as_slice(), &krate);\n     }\n \n     krate\n@@ -182,7 +182,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // strip before expansion to allow macros to depend on\n     // configuration variables e.g/ in\n     //\n-    //   #[macro_escape] #[cfg(foo)]\n+    //   #[macro_use] #[cfg(foo)]\n     //   mod bar { macro_rules! baz!(() => {{}}) }\n     //\n     // baz! should not use this definition unless foo is enabled.\n@@ -216,9 +216,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         = time(time_passes, \"plugin loading\", (), |_|\n                plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n \n-    let mut registry = Registry::new(&krate);\n+    let mut registry = Registry::new(sess, &krate);\n \n-    time(time_passes, \"plugin registration\", (), |_| {\n+    time(time_passes, \"plugin registration\", registrars, |registrars| {\n         if sess.features.borrow().rustc_diagnostic_macros {\n             registry.register_macro(\"__diagnostic_used\",\n                 diagnostics::plugin::expand_diagnostic_used);\n@@ -228,8 +228,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                 diagnostics::plugin::expand_build_diagnostic_array);\n         }\n \n-        for &registrar in registrars.iter() {\n-            registrar(&mut registry);\n+        for registrar in registrars.into_iter() {\n+            registry.args_hidden = Some(registrar.args);\n+            (registrar.fun)(&mut registry);\n         }\n     });\n \n@@ -272,7 +273,6 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n-                deriving_hash_type_parameter: sess.features.borrow().default_type_params,\n                 enable_quotes: sess.features.borrow().quote,\n                 recursion_limit: sess.recursion_limit.get(),\n             };\n@@ -352,7 +352,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let krate = ast_map.krate();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|\n-         creader::read_crates(&sess, krate));\n+         CrateReader::new(&sess).read_crates(krate));\n \n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n                           middle::lang_items::collect_language_items(krate, &sess));\n@@ -572,7 +572,7 @@ pub fn stop_after_phase_1(sess: &Session) -> bool {\n         debug!(\"invoked with --parse-only, returning early from compile_input\");\n         return true;\n     }\n-    if sess.show_span() {\n+    if sess.opts.show_span.is_some() {\n         return true;\n     }\n     return sess.opts.debugging_opts & config::AST_JSON_NOEXPAND != 0;"}, {"sha": "89b2e0f257acd97b5ca75a1b0c2b393e0f7e84dc", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -39,11 +39,25 @@ extern crate rustc_borrowck;\n extern crate rustc_resolve;\n extern crate rustc_trans;\n extern crate rustc_typeck;\n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n extern crate serialize;\n extern crate \"rustc_llvm\" as llvm;\n \n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n+\n pub use syntax::diagnostic;\n \n use rustc_trans::back::link;\n@@ -134,7 +148,7 @@ fn run_compiler(args: &[String]) {\n         _ => early_error(\"multiple input filenames provided\")\n     };\n \n-    let sess = build_session(sopts, input_file_path, descriptions);\n+    let mut sess = build_session(sopts, input_file_path, descriptions);\n     let cfg = config::build_configuration(&sess);\n     if print_crate_info(&sess, Some(&input), &odir, &ofile) {\n         return\n@@ -145,7 +159,7 @@ fn run_compiler(args: &[String]) {\n         pretty::parse_pretty(&sess, a.as_slice(), false)\n     });\n     let pretty = if pretty.is_none() &&\n-        sess.debugging_opt(config::UNSTABLE_OPTIONS) {\n+        sess.unstable_options() {\n             matches.opt_str(\"xpretty\").map(|a| {\n                 // extended with unstable pretty-print variants\n                 pretty::parse_pretty(&sess, a.as_slice(), true)\n@@ -162,6 +176,10 @@ fn run_compiler(args: &[String]) {\n         None => {/* continue */ }\n     }\n \n+    if sess.unstable_options() {\n+        sess.opts.show_span = matches.opt_str(\"show-span\");\n+    }\n+\n     let r = matches.opt_strs(\"Z\");\n     if r.contains(&(\"ls\".to_string())) {\n         match input {"}, {"sha": "61fd7d16ab7ddea401a618297fa3dc6e7cafc56d", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -484,8 +484,8 @@ impl fold::Folder for ReplaceBodyWithLoop {\n \n     // in general the pretty printer processes unexpanded code, so\n     // we override the default `fold_mac` method which panics.\n-    fn fold_mac(&mut self, _macro: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(_macro, self)\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n     }\n }\n "}, {"sha": "d3555e4c0436354055399d04ab1cbb2f58995c97", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,7 +13,7 @@\n use libc;\n use ArchiveRef;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::mem;\n use std::raw;\n \n@@ -30,9 +30,8 @@ impl ArchiveRO {\n     /// raised.\n     pub fn open(dst: &Path) -> Option<ArchiveRO> {\n         unsafe {\n-            let ar = dst.with_c_str(|dst| {\n-                ::LLVMRustOpenArchive(dst)\n-            });\n+            let s = CString::from_slice(dst.as_vec());\n+            let ar = ::LLVMRustOpenArchive(s.as_ptr());\n             if ar.is_null() {\n                 None\n             } else {\n@@ -45,9 +44,9 @@ impl ArchiveRO {\n     pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n         unsafe {\n             let mut size = 0 as libc::size_t;\n-            let ptr = file.with_c_str(|file| {\n-                ::LLVMRustArchiveReadSection(self.ptr, file, &mut size)\n-            });\n+            let file = CString::from_slice(file.as_bytes());\n+            let ptr = ::LLVMRustArchiveReadSection(self.ptr, file.as_ptr(),\n+                                                   &mut size);\n             if ptr.is_null() {\n                 None\n             } else {"}, {"sha": "8a9334be985f70b04d177ec6402b734bd4b066e3", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -24,6 +24,7 @@\n #![feature(globs)]\n #![feature(link_args)]\n #![feature(unboxed_closures)]\n+#![feature(old_orphan_check)]\n \n extern crate libc;\n \n@@ -47,7 +48,7 @@ pub use self::Visibility::*;\n pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::cell::RefCell;\n use std::{raw, mem};\n use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n@@ -2114,10 +2115,9 @@ impl Drop for TargetData {\n }\n \n pub fn mk_target_data(string_rep: &str) -> TargetData {\n+    let string_rep = CString::from_slice(string_rep.as_bytes());\n     TargetData {\n-        lltd: string_rep.with_c_str(|buf| {\n-            unsafe { LLVMCreateTargetData(buf) }\n-        })\n+        lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) }\n     }\n }\n "}, {"sha": "58102fe5629d9f43bc2656d609830f2451a0f68e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -19,9 +19,23 @@\n #![feature(globs, phase, slicing_syntax)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(associated_types)]\n+#![feature(old_orphan_check)]\n \n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n \n extern crate rustc;\n "}, {"sha": "f3e90c43a8414961bcdb979fb15f9dbada402d85", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -20,7 +20,7 @@ use rustc::util::common::time;\n use libc;\n use flate;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::iter;\n use std::mem;\n use std::num::Int;\n@@ -139,9 +139,10 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     }\n \n     // Internalize everything but the reachable symbols of the current module\n-    let cstrs: Vec<::std::c_str::CString> =\n-        reachable.iter().map(|s| s.to_c_str()).collect();\n-    let arr: Vec<*const libc::c_char> = cstrs.iter().map(|c| c.as_ptr()).collect();\n+    let cstrs: Vec<CString> = reachable.iter().map(|s| {\n+        CString::from_slice(s.as_bytes())\n+    }).collect();\n+    let arr: Vec<*const i8> = cstrs.iter().map(|c| c.as_ptr()).collect();\n     let ptr = arr.as_ptr();\n     unsafe {\n         llvm::LLVMRustRunRestrictionPass(llmod,\n@@ -164,15 +165,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     unsafe {\n         let pm = llvm::LLVMCreatePassManager();\n         llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n-        \"verify\".with_c_str(|s| llvm::LLVMRustAddPass(pm, s));\n+        llvm::LLVMRustAddPass(pm, \"verify\\0\".as_ptr() as *const _);\n \n         let builder = llvm::LLVMPassManagerBuilderCreate();\n         llvm::LLVMPassManagerBuilderPopulateLTOPassManager(builder, pm,\n             /* Internalize = */ False,\n             /* RunInliner = */ True);\n         llvm::LLVMPassManagerBuilderDispose(builder);\n \n-        \"verify\".with_c_str(|s| llvm::LLVMRustAddPass(pm, s));\n+        llvm::LLVMRustAddPass(pm, \"verify\\0\".as_ptr() as *const _);\n \n         time(sess.time_passes(), \"LTO passes\", (), |()|\n              llvm::LLVMRunPassManager(pm, llmod));"}, {"sha": "98e2b4b9dddb575bbba99fe53160840f43c7d138", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -22,7 +22,7 @@ use syntax::codemap;\n use syntax::diagnostic;\n use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n \n-use std::c_str::{ToCStr, CString};\n+use std::ffi::{self, CString};\n use std::io::Command;\n use std::io::fs;\n use std::iter::Unfold;\n@@ -32,7 +32,7 @@ use std::mem;\n use std::sync::{Arc, Mutex};\n use std::sync::mpsc::channel;\n use std::thread;\n-use libc::{c_uint, c_int, c_void};\n+use libc::{self, c_uint, c_int, c_void};\n \n #[derive(Clone, Copy, PartialEq, PartialOrd, Ord, Eq)]\n pub enum OutputType {\n@@ -49,8 +49,9 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n         if cstr == ptr::null() {\n             handler.fatal(msg[]);\n         } else {\n-            let err = CString::new(cstr, true);\n-            let err = String::from_utf8_lossy(err.as_bytes());\n+            let err = ffi::c_str_to_bytes(&cstr);\n+            let err = String::from_utf8_lossy(err.as_slice()).to_string();\n+            libc::free(cstr as *mut _);\n             handler.fatal(format!(\"{}: {}\",\n                                   msg[],\n                                   err[])[]);\n@@ -66,13 +67,12 @@ pub fn write_output_file(\n         output: &Path,\n         file_type: llvm::FileType) {\n     unsafe {\n-        output.with_c_str(|output| {\n-            let result = llvm::LLVMRustWriteOutputFile(\n-                    target, pm, m, output, file_type);\n-            if !result {\n-                llvm_err(handler, \"could not write output\".to_string());\n-            }\n-        })\n+        let output = CString::from_slice(output.as_vec());\n+        let result = llvm::LLVMRustWriteOutputFile(\n+                target, pm, m, output.as_ptr(), file_type);\n+        if !result {\n+            llvm_err(handler, \"could not write output\".to_string());\n+        }\n     }\n }\n \n@@ -221,28 +221,25 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let triple = sess.target.target.llvm_target[];\n \n     let tm = unsafe {\n-        triple.with_c_str(|t| {\n-            let cpu = match sess.opts.cg.target_cpu {\n-                Some(ref s) => s[],\n-                None => sess.target.target.options.cpu[]\n-            };\n-            cpu.with_c_str(|cpu| {\n-                target_feature(sess).with_c_str(|features| {\n-                    llvm::LLVMRustCreateTargetMachine(\n-                        t, cpu, features,\n-                        code_model,\n-                        reloc_model,\n-                        opt_level,\n-                        true /* EnableSegstk */,\n-                        use_softfp,\n-                        no_fp_elim,\n-                        !any_library && reloc_model == llvm::RelocPIC,\n-                        ffunction_sections,\n-                        fdata_sections,\n-                    )\n-                })\n-            })\n-        })\n+        let triple = CString::from_slice(triple.as_bytes());\n+        let cpu = match sess.opts.cg.target_cpu {\n+            Some(ref s) => s.as_slice(),\n+            None => sess.target.target.options.cpu.as_slice()\n+        };\n+        let cpu = CString::from_slice(cpu.as_bytes());\n+        let features = CString::from_slice(target_feature(sess).as_bytes());\n+        llvm::LLVMRustCreateTargetMachine(\n+            triple.as_ptr(), cpu.as_ptr(), features.as_ptr(),\n+            code_model,\n+            reloc_model,\n+            opt_level,\n+            true /* EnableSegstk */,\n+            use_softfp,\n+            no_fp_elim,\n+            !any_library && reloc_model == llvm::RelocPIC,\n+            ffunction_sections,\n+            fdata_sections,\n+        )\n     };\n \n     if tm.is_null() {\n@@ -371,8 +368,9 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::Optimization(opt) => {\n-            let pass_name = CString::new(opt.pass_name, false);\n-            let pass_name = pass_name.as_str().expect(\"got a non-UTF8 pass name from LLVM\");\n+            let pass_name = str::from_utf8(ffi::c_str_to_bytes(&opt.pass_name))\n+                                .ok()\n+                                .expect(\"got a non-UTF8 pass name from LLVM\");\n             let enabled = match cgcx.remark {\n                 AllPasses => true,\n                 SomePasses(ref v) => v.iter().any(|s| *s == pass_name),\n@@ -416,9 +414,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n-        output_names.with_extension(ext[]).with_c_str(|buf| {\n-            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-        })\n+        let out = output_names.with_extension(ext.as_slice());\n+        let out = CString::from_slice(out.as_vec());\n+        llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     match config.opt_level {\n@@ -433,7 +431,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             // If we're verifying or linting, add them to the function pass\n             // manager.\n             let addpass = |&: pass: &str| {\n-                pass.with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n+                let pass = CString::from_slice(pass.as_bytes());\n+                llvm::LLVMRustAddPass(fpm, pass.as_ptr())\n             };\n             if !config.no_verify { assert!(addpass(\"verify\")); }\n \n@@ -445,12 +444,11 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             }\n \n             for pass in config.passes.iter() {\n-                pass.with_c_str(|s| {\n-                    if !llvm::LLVMRustAddPass(mpm, s) {\n-                        cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n-                                                  *pass)[]);\n-                    }\n-                })\n+                let pass = CString::from_slice(pass.as_bytes());\n+                if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n+                    cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n+                                              pass).as_slice());\n+                }\n             }\n \n             // Finally, run the actual optimization passes\n@@ -470,9 +468,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n                     if config.emit_lto_bc {\n                         let name = format!(\"{}.lto.bc\", name_extra);\n-                        output_names.with_extension(name[]).with_c_str(|buf| {\n-                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                        })\n+                        let out = output_names.with_extension(name.as_slice());\n+                        let out = CString::from_slice(out.as_vec());\n+                        llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n                     }\n                 },\n                 _ => {},\n@@ -504,18 +502,18 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_bc {\n         let ext = format!(\"{}.bc\", name_extra);\n-        output_names.with_extension(ext[]).with_c_str(|buf| {\n-            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-        })\n+        let out = output_names.with_extension(ext.as_slice());\n+        let out = CString::from_slice(out.as_vec());\n+        llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     time(config.time_passes, \"codegen passes\", (), |()| {\n         if config.emit_ir {\n             let ext = format!(\"{}.ll\", name_extra);\n-            output_names.with_extension(ext[]).with_c_str(|output| {\n-                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                    llvm::LLVMRustPrintModule(cpm, llmod, output);\n-                })\n+            let out = output_names.with_extension(ext.as_slice());\n+            let out = CString::from_slice(out.as_vec());\n+            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n             })\n         }\n \n@@ -995,7 +993,7 @@ unsafe fn configure_llvm(sess: &Session) {\n     let mut llvm_args = Vec::new();\n     {\n         let mut add = |&mut : arg: &str| {\n-            let s = arg.to_c_str();\n+            let s = CString::from_slice(arg.as_bytes());\n             llvm_args.push(s.as_ptr());\n             llvm_c_strs.push(s);\n         };\n@@ -1083,7 +1081,7 @@ unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n \n     match opt {\n         llvm::CodeGenLevelDefault | llvm::CodeGenLevelAggressive => {\n-            \"mergefunc\".with_c_str(|s| llvm::LLVMRustAddPass(mpm, s));\n+            llvm::LLVMRustAddPass(mpm, \"mergefunc\\0\".as_ptr() as *const _);\n         }\n         _ => {}\n     };"}, {"sha": "705fecf4d198eec8b7590c53b659c719dbf93fdf", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -37,11 +37,25 @@ extern crate graphviz;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n extern crate serialize;\n extern crate \"rustc_llvm\" as llvm;\n \n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n+\n pub use rustc::session;\n pub use rustc::metadata;\n pub use rustc::middle;"}, {"sha": "fed0931cab71d52f071ed5429356ce99ed19fbd9", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -683,7 +683,7 @@ fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n }\n \n fn any_region_pat(m: &[Match], col: uint) -> bool {\n-    any_pat!(m, col, ast::PatRegion(_))\n+    any_pat!(m, col, ast::PatRegion(..))\n }\n \n fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n@@ -1725,7 +1725,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llbox = Load(bcx, val);\n             bcx = bind_irrefutable_pat(bcx, &**inner, llbox, cleanup_scope);\n         }\n-        ast::PatRegion(ref inner) => {\n+        ast::PatRegion(ref inner, _) => {\n             let loaded_val = Load(bcx, val);\n             bcx = bind_irrefutable_pat(bcx, &**inner, loaded_val, cleanup_scope);\n         }"}, {"sha": "f18d483f70328bd3389cdc527f445b729c6247ff", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -20,9 +20,8 @@ use trans::expr;\n use trans::type_of;\n use trans::type_::Type;\n \n-use std::c_str::ToCStr;\n-use std::string::String;\n use syntax::ast;\n+use std::ffi::CString;\n use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n@@ -121,18 +120,16 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         ast::AsmIntel => llvm::AD_Intel\n     };\n \n-    let r = ia.asm.get().with_c_str(|a| {\n-        constraints.with_c_str(|c| {\n-            InlineAsmCall(bcx,\n-                          a,\n-                          c,\n-                          inputs[],\n+    let asm = CString::from_slice(ia.asm.get().as_bytes());\n+    let constraints = CString::from_slice(constraints.as_bytes());\n+    let r = InlineAsmCall(bcx,\n+                          asm.as_ptr(),\n+                          constraints.as_ptr(),\n+                          inputs.as_slice(),\n                           output_type,\n                           ia.volatile,\n                           ia.alignstack,\n-                          dialect)\n-        })\n-    });\n+                          dialect);\n \n     // Again, based on how many outputs we have\n     if num_outputs == 1 {"}, {"sha": "edcfaae0f802d32482aab9ca1f785b2d142d7999", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -88,11 +88,12 @@ use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n use libc::{c_uint, uint64_t};\n-use std::c_str::ToCStr;\n+use std::ffi::{self, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::mem;\n use std::rc::Rc;\n+use std::str;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{Rust, RustCall, RustIntrinsic, Abi};\n use syntax::ast_util::local_def;\n@@ -187,11 +188,10 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n                ty: Type, output: ty::FnOutput) -> ValueRef {\n \n-    let llfn: ValueRef = name.with_c_str(|buf| {\n-        unsafe {\n-            llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf, ty.to_ref())\n-        }\n-    });\n+    let buf = CString::from_slice(name.as_bytes());\n+    let llfn: ValueRef = unsafe {\n+        llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf.as_ptr(), ty.to_ref())\n+    };\n \n     // diverging functions may unwind, but can never return normally\n     if output == ty::FnDiverging {\n@@ -331,9 +331,8 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n         None => ()\n     }\n     unsafe {\n-        let c = name.with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf)\n-        });\n+        let buf = CString::from_slice(name.as_bytes());\n+        let c = llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf.as_ptr());\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n@@ -472,15 +471,17 @@ pub fn set_always_inline(f: ValueRef) {\n }\n \n pub fn set_split_stack(f: ValueRef) {\n-    \"split-stack\".with_c_str(|buf| {\n-        unsafe { llvm::LLVMAddFunctionAttrString(f, llvm::FunctionIndex as c_uint, buf); }\n-    })\n+    unsafe {\n+        llvm::LLVMAddFunctionAttrString(f, llvm::FunctionIndex as c_uint,\n+                                        \"split-stack\\0\".as_ptr() as *const _);\n+    }\n }\n \n pub fn unset_split_stack(f: ValueRef) {\n-    \"split-stack\".with_c_str(|buf| {\n-        unsafe { llvm::LLVMRemoveFunctionAttrString(f, llvm::FunctionIndex as c_uint, buf); }\n-    })\n+    unsafe {\n+        llvm::LLVMRemoveFunctionAttrString(f, llvm::FunctionIndex as c_uint,\n+                                           \"split-stack\\0\".as_ptr() as *const _);\n+    }\n }\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n@@ -534,11 +535,8 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // Structural comparison: a rather involved form of glue.\n pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n     if cx.sess().opts.cg.save_temps {\n-        s.with_c_str(|buf| {\n-            unsafe {\n-                llvm::LLVMSetValueName(v, buf)\n-            }\n-        })\n+        let buf = CString::from_slice(s.as_bytes());\n+        unsafe { llvm::LLVMSetValueName(v, buf.as_ptr()) }\n     }\n }\n \n@@ -2639,11 +2637,10 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             unsafe { llvm::LLVMRustSetDLLExportStorageClass(llfn) }\n         }\n \n-        let llbb = \"top\".with_c_str(|buf| {\n-            unsafe {\n-                llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, buf)\n-            }\n-        });\n+        let llbb = unsafe {\n+            llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn,\n+                                                \"top\\0\".as_ptr() as *const _)\n+        };\n         let bld = ccx.raw_builder();\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n@@ -2664,9 +2661,9 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                 };\n \n                 let args = {\n-                    let opaque_rust_main = \"rust_main\".with_c_str(|buf| {\n-                        llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p(ccx).to_ref(), buf)\n-                    });\n+                    let opaque_rust_main = llvm::LLVMBuildPointerCast(bld,\n+                        rust_main, Type::i8p(ccx).to_ref(),\n+                        \"rust_main\\0\".as_ptr() as *const _);\n \n                     vec!(\n                         opaque_rust_main,\n@@ -2773,9 +2770,9 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                 format!(\"Illegal null byte in export_name \\\n                                          value: `{}`\", sym)[]);\n                         }\n-                        let g = sym.with_c_str(|buf| {\n-                            llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n-                        });\n+                        let buf = CString::from_slice(sym.as_bytes());\n+                        let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n+                                                    buf.as_ptr());\n \n                         if attr::contains_name(i.attrs[],\n                                                \"thread_local\") {\n@@ -2817,9 +2814,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                  sect.get())[]);\n                     }\n                     unsafe {\n-                        sect.get().with_c_str(|buf| {\n-                            llvm::LLVMSetSection(v, buf);\n-                        })\n+                        let buf = CString::from_slice(sect.get().as_bytes());\n+                        llvm::LLVMSetSection(v, buf.as_ptr());\n                     }\n                 },\n                 None => ()\n@@ -2986,26 +2982,23 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n                        cx.link_meta().crate_hash);\n-    let llglobal = name.with_c_str(|buf| {\n-        unsafe {\n-            llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(), buf)\n-        }\n-    });\n+    let buf = CString::from_vec(name.into_bytes());\n+    let llglobal = unsafe {\n+        llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(),\n+                            buf.as_ptr())\n+    };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n         let name = loader::meta_section_name(cx.sess().target.target.options.is_like_osx);\n-        name.with_c_str(|buf| {\n-            llvm::LLVMSetSection(llglobal, buf)\n-        });\n+        let name = CString::from_slice(name.as_bytes());\n+        llvm::LLVMSetSection(llglobal, name.as_ptr())\n     }\n     return metadata;\n }\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n-    use std::c_str::CString;\n-\n     unsafe {\n         let mut declared = HashSet::new();\n \n@@ -3035,7 +3028,8 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                     continue\n                 }\n \n-                let name = CString::new(llvm::LLVMGetValueName(val), false);\n+                let name = ffi::c_str_to_bytes(&llvm::LLVMGetValueName(val))\n+                               .to_vec();\n                 declared.insert(name);\n             }\n         }\n@@ -3051,9 +3045,10 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                     continue\n                 }\n \n-                let name = CString::new(llvm::LLVMGetValueName(val), false);\n+                let name = ffi::c_str_to_bytes(&llvm::LLVMGetValueName(val))\n+                               .to_vec();\n                 if !declared.contains(&name) &&\n-                   !reachable.contains(name.as_str().unwrap()) {\n+                   !reachable.contains(str::from_utf8(name.as_slice()).unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);\n                 }\n             }"}, {"sha": "e09d36ddae923188be8407e9942c2aac077713ec", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -20,7 +20,8 @@ use trans::machine::llalign_of_pref;\n use trans::type_::Type;\n use util::nodemap::FnvHashMap;\n use libc::{c_uint, c_char};\n-use std::c_str::ToCStr;\n+\n+use std::ffi::CString;\n use syntax::codemap::Span;\n \n pub struct Builder<'a, 'tcx: 'a> {\n@@ -429,9 +430,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n-                name.with_c_str(|c| {\n-                    llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c)\n-                })\n+                let name = CString::from_slice(name.as_bytes());\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n+                                      name.as_ptr())\n             }\n         }\n     }\n@@ -774,12 +775,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let comment_text = format!(\"{} {}\", \"#\",\n                                        sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let asm = comment_text.with_c_str(|c| {\n-                unsafe {\n-                    llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n-                                             c, noname(), False, False)\n-                }\n-            });\n+            let comment_text = CString::from_vec(comment_text.into_bytes());\n+            let asm = unsafe {\n+                llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n+                                         comment_text.as_ptr(), noname(), False,\n+                                         False)\n+            };\n             self.call(asm, &[], None);\n         }\n     }\n@@ -926,9 +927,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let bb: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n             let fn_: ValueRef = llvm::LLVMGetBasicBlockParent(bb);\n             let m: ModuleRef = llvm::LLVMGetGlobalParent(fn_);\n-            let t: ValueRef = \"llvm.trap\".with_c_str(|buf| {\n-                llvm::LLVMGetNamedFunction(m, buf)\n-            });\n+            let p = \"llvm.trap\\0\".as_ptr();\n+            let t: ValueRef = llvm::LLVMGetNamedFunction(m, p as *const _);\n             assert!((t as int != 0));\n             let args: &[ValueRef] = &[];\n             self.count_insn(\"trap\");"}, {"sha": "9ec0c822bf5fe4acc92a27aaddf00194d08d8a1d", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -63,7 +63,7 @@ impl RegClass {\n     }\n }\n \n-trait ClassList for Sized? {\n+trait ClassList {\n     fn is_pass_byval(&self) -> bool;\n     fn is_ret_bysret(&self) -> bool;\n }"}, {"sha": "094f98e988aad202fda3fc3e9535f62c1a3cdcaa", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -44,7 +44,7 @@ use util::nodemap::{FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n use std::vec::Vec;\n use syntax::ast::Ident;\n@@ -401,9 +401,8 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         if self.llreturn.get().is_none() {\n \n             self.llreturn.set(Some(unsafe {\n-                \"return\".with_c_str(|buf| {\n-                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn, buf)\n-                })\n+                llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn,\n+                                                    \"return\\0\".as_ptr() as *const _)\n             }))\n         }\n \n@@ -429,11 +428,10 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                      opt_node_id: Option<ast::NodeId>)\n                      -> Block<'a, 'tcx> {\n         unsafe {\n-            let llbb = name.with_c_str(|buf| {\n-                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n-                                                        self.llfn,\n-                                                        buf)\n-                });\n+            let name = CString::from_slice(name.as_bytes());\n+            let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n+                                                           self.llfn,\n+                                                           name.as_ptr());\n             BlockS::new(llbb, is_lpad, opt_node_id, self)\n         }\n     }\n@@ -708,7 +706,8 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        s.with_c_str(|buf| llvm::LLVMConstRealOfString(t.to_ref(), buf))\n+        let s = CString::from_slice(s.as_bytes());\n+        llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n     }\n }\n \n@@ -789,9 +788,8 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let g = format!(\"str{}\", gsym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf)\n-        });\n+        let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n+        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::SetLinkage(g, llvm::InternalLinkage);\n@@ -815,9 +813,10 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n         let lldata = C_bytes(cx, data);\n \n         let gsym = token::gensym(\"binary\");\n-        let g = format!(\"binary{}\", gsym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(), buf)\n-        });\n+        let name = format!(\"binary{}\", gsym.uint());\n+        let name = CString::from_vec(name.into_bytes());\n+        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n+                                    name.as_ptr());\n         llvm::LLVMSetInitializer(g, lldata);\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::SetLinkage(g, llvm::InternalLinkage);"}, {"sha": "a3861e71d83de56c614d8c676c5a203167d1065e", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -24,7 +24,6 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, ty_to_string};\n \n-use std::c_str::ToCStr;\n use std::iter::repeat;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n@@ -103,9 +102,8 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n \n pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n     unsafe {\n-        let gv = \"const\".with_c_str(|name| {\n-            llvm::LLVMAddGlobal(cx.llmod(), val_ty(cv).to_ref(), name)\n-        });\n+        let gv = llvm::LLVMAddGlobal(cx.llmod(), val_ty(cv).to_ref(),\n+                                     \"const\\0\".as_ptr() as *const _);\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetGlobalConstant(gv,\n                                     if mutbl == ast::MutImmutable {True} else {False});"}, {"sha": "3726cf14023ee35c88ac7b05af5cbe377ff75b87", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -29,8 +29,8 @@ use util::ppaux::Repr;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n+use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n-use std::c_str::ToCStr;\n use std::ptr;\n use std::rc::Rc;\n use syntax::ast;\n@@ -221,21 +221,16 @@ impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n \n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n-    let llmod = mod_name.with_c_str(|buf| {\n-        llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-    });\n-    sess.target\n-        .target\n-        .data_layout\n-        .with_c_str(|buf| {\n-        llvm::LLVMSetDataLayout(llmod, buf);\n-    });\n-    sess.target\n-        .target\n-        .llvm_target\n-        .with_c_str(|buf| {\n-        llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n-    });\n+    let mod_name = CString::from_slice(mod_name.as_bytes());\n+    let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n+\n+    let data_layout = sess.target.target.data_layout.as_slice();\n+    let data_layout = CString::from_slice(data_layout.as_bytes());\n+    llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n+\n+    let llvm_target = sess.target.target.llvm_target.as_slice();\n+    let llvm_target = CString::from_slice(llvm_target.as_bytes());\n+    llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n     (llcx, llmod)\n }\n \n@@ -741,7 +736,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n-    macro_rules! ifn (\n+    macro_rules! ifn {\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(\n@@ -759,10 +754,10 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         )\n-    );\n-    macro_rules! mk_struct (\n+    }\n+    macro_rules! mk_struct {\n         ($($field_ty:expr),*) => (Type::struct_(ccx, &[$($field_ty),*], false))\n-    );\n+    }\n \n     let i8p = Type::i8p(ccx);\n     let void = Type::void(ccx);\n@@ -883,7 +878,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     // Some intrinsics were introduced in later versions of LLVM, but they have\n     // fallbacks in libc or libm and such. Currently, all of these intrinsics\n     // were introduced in LLVM 3.4, so we case on that.\n-    macro_rules! compatible_ifn (\n+    macro_rules! compatible_ifn {\n         ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => (\n             if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n                 // The `if key == $name` is already in ifn!\n@@ -896,7 +891,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         )\n-    );\n+    }\n \n     compatible_ifn!(\"llvm.copysign.f32\", copysignf(t_f32, t_f32) -> t_f32);\n     compatible_ifn!(\"llvm.copysign.f64\", copysign(t_f64, t_f64) -> t_f64);"}, {"sha": "3f0f7fd9bd3032564c37beff27febf777b1aecb3", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 254, "deletions": 274, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -207,7 +207,7 @@ use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n use util::ppaux;\n \n use libc::c_uint;\n-use std::c_str::{CString, ToCStr};\n+use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n use std::ptr;\n use std::rc::{Rc, Weak};\n@@ -755,14 +755,15 @@ pub fn finalize(cx: &CrateContext) {\n         // for OS X to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n         if cx.sess().target.target.options.is_like_osx {\n-            \"Dwarf Version\".with_c_str(\n-                |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s, 2));\n+            llvm::LLVMRustAddModuleFlag(cx.llmod(),\n+                                        \"Dwarf Version\\0\".as_ptr() as *const _,\n+                                        2)\n         }\n \n         // Prevent bitcode readers from deleting the debug info.\n-        \"Debug Info Version\".with_c_str(\n-            |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s,\n-                                            llvm::LLVMRustDebugMetadataVersion));\n+        let ptr = \"Debug Info Version\\0\".as_ptr();\n+        llvm::LLVMRustAddModuleFlag(cx.llmod(), ptr as *const _,\n+                                    llvm::LLVMRustDebugMetadataVersion);\n     };\n }\n \n@@ -824,22 +825,20 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         namespace_node.mangled_name_of_contained_item(var_name[]);\n     let var_scope = namespace_node.scope;\n \n-    var_name.with_c_str(|var_name| {\n-        linkage_name.with_c_str(|linkage_name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n-                                                        var_scope,\n-                                                        var_name,\n-                                                        linkage_name,\n-                                                        file_metadata,\n-                                                        line_number,\n-                                                        type_metadata,\n-                                                        is_local_to_unit,\n-                                                        global,\n-                                                        ptr::null_mut());\n-            }\n-        })\n-    });\n+    let var_name = CString::from_slice(var_name.as_bytes());\n+    let linkage_name = CString::from_slice(linkage_name.as_bytes());\n+    unsafe {\n+        llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n+                                                var_scope,\n+                                                var_name.as_ptr(),\n+                                                linkage_name.as_ptr(),\n+                                                file_metadata,\n+                                                line_number,\n+                                                type_metadata,\n+                                                is_local_to_unit,\n+                                                global,\n+                                                ptr::null_mut());\n+    }\n }\n \n /// Creates debug information for the given local variable.\n@@ -1383,28 +1382,26 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n \n-    let fn_metadata = function_name.with_c_str(|function_name| {\n-                          linkage_name.with_c_str(|linkage_name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateFunction(\n-                    DIB(cx),\n-                    containing_scope,\n-                    function_name,\n-                    linkage_name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    function_type_metadata,\n-                    is_local_to_unit,\n-                    true,\n-                    scope_line as c_uint,\n-                    FlagPrototyped as c_uint,\n-                    cx.sess().opts.optimize != config::No,\n-                    llfn,\n-                    template_parameters,\n-                    ptr::null_mut())\n-            }\n-        })\n-    });\n+    let function_name = CString::from_slice(function_name.as_bytes());\n+    let linkage_name = CString::from_slice(linkage_name.as_bytes());\n+    let fn_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateFunction(\n+            DIB(cx),\n+            containing_scope,\n+            function_name.as_ptr(),\n+            linkage_name.as_ptr(),\n+            file_metadata,\n+            loc.line as c_uint,\n+            function_type_metadata,\n+            is_local_to_unit,\n+            true,\n+            scope_line as c_uint,\n+            FlagPrototyped as c_uint,\n+            cx.sess().opts.optimize != config::No,\n+            llfn,\n+            template_parameters,\n+            ptr::null_mut())\n+    };\n \n     let scope_map = create_scope_map(cx,\n                                      fn_decl.inputs.as_slice(),\n@@ -1509,19 +1506,18 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n                 let ident = special_idents::type_self;\n \n-                let param_metadata = token::get_ident(ident).get()\n-                                                            .with_c_str(|name| {\n-                    unsafe {\n-                        llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                            DIB(cx),\n-                            file_metadata,\n-                            name,\n-                            actual_self_type_metadata,\n-                            ptr::null_mut(),\n-                            0,\n-                            0)\n-                    }\n-                });\n+                let ident = token::get_ident(ident);\n+                let name = CString::from_slice(ident.get().as_bytes());\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_self_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n \n                 template_params.push(param_metadata);\n             }\n@@ -1544,19 +1540,18 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // Again, only create type information if full debuginfo is enabled\n             if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n-                let param_metadata = token::get_ident(ident).get()\n-                                                            .with_c_str(|name| {\n-                    unsafe {\n-                        llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                            DIB(cx),\n-                            file_metadata,\n-                            name,\n-                            actual_type_metadata,\n-                            ptr::null_mut(),\n-                            0,\n-                            0)\n-                    }\n-                });\n+                let ident = token::get_ident(ident);\n+                let name = CString::from_slice(ident.get().as_bytes());\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n                 template_params.push(param_metadata);\n             }\n         }\n@@ -1601,19 +1596,19 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n             } else {\n                 match abs_path.path_relative_from(work_dir) {\n                     Some(ref p) if p.is_relative() => {\n-                            // prepend \"./\" if necessary\n-                            let dotdot = b\"..\";\n-                            let prefix = [dotdot[0], ::std::path::SEP_BYTE];\n-                            let mut path_bytes = p.as_vec().to_vec();\n-\n-                            if path_bytes.slice_to(2) != prefix &&\n-                               path_bytes.slice_to(2) != dotdot {\n-                                path_bytes.insert(0, prefix[0]);\n-                                path_bytes.insert(1, prefix[1]);\n-                            }\n-\n-                            path_bytes.to_c_str()\n+                        // prepend \"./\" if necessary\n+                        let dotdot = b\"..\";\n+                        let prefix: &[u8] = &[dotdot[0], ::std::path::SEP_BYTE];\n+                        let mut path_bytes = p.as_vec().to_vec();\n+\n+                        if path_bytes.slice_to(2) != prefix &&\n+                           path_bytes.slice_to(2) != dotdot {\n+                            path_bytes.insert(0, prefix[0]);\n+                            path_bytes.insert(1, prefix[1]);\n                         }\n+\n+                        CString::from_vec(path_bytes)\n+                    }\n                     _ => fallback_path(cx)\n                 }\n             }\n@@ -1625,29 +1620,25 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n     let compile_unit_name = compile_unit_name.as_ptr();\n-    return work_dir.as_vec().with_c_str(|work_dir| {\n-        producer.with_c_str(|producer| {\n-            \"\".with_c_str(|flags| {\n-                \"\".with_c_str(|split_name| {\n-                    unsafe {\n-                        llvm::LLVMDIBuilderCreateCompileUnit(\n-                            debug_context(cx).builder,\n-                            DW_LANG_RUST,\n-                            compile_unit_name,\n-                            work_dir,\n-                            producer,\n-                            cx.sess().opts.optimize != config::No,\n-                            flags,\n-                            0,\n-                            split_name)\n-                    }\n-                })\n-            })\n-        })\n-    });\n+    let work_dir = CString::from_slice(work_dir.as_vec());\n+    let producer = CString::from_slice(producer.as_bytes());\n+    let flags = \"\\0\";\n+    let split_name = \"\\0\";\n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateCompileUnit(\n+            debug_context(cx).builder,\n+            DW_LANG_RUST,\n+            compile_unit_name,\n+            work_dir.as_ptr(),\n+            producer.as_ptr(),\n+            cx.sess().opts.optimize != config::No,\n+            flags.as_ptr() as *const _,\n+            0,\n+            split_name.as_ptr() as *const _)\n+    };\n \n     fn fallback_path(cx: &CrateContext) -> CString {\n-        cx.link_meta().crate_name.to_c_str()\n+        CString::from_slice(cx.link_meta().crate_name.as_bytes())\n     }\n }\n \n@@ -1673,42 +1664,41 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n \n-    let (var_alloca, var_metadata) = name.get().with_c_str(|name| {\n-        match variable_access {\n-            DirectVariable { alloca } => (\n-                alloca,\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateLocalVariable(\n-                        DIB(cx),\n-                        dwarf_tag,\n-                        scope_metadata,\n-                        name,\n-                        file_metadata,\n-                        loc.line as c_uint,\n-                        type_metadata,\n-                        cx.sess().opts.optimize != config::No,\n-                        0,\n-                        argument_index)\n-                }\n-            ),\n-            IndirectVariable { alloca, address_operations } => (\n-                alloca,\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateComplexVariable(\n-                        DIB(cx),\n-                        dwarf_tag,\n-                        scope_metadata,\n-                        name,\n-                        file_metadata,\n-                        loc.line as c_uint,\n-                        type_metadata,\n-                        address_operations.as_ptr(),\n-                        address_operations.len() as c_uint,\n-                        argument_index)\n-                }\n-            )\n-        }\n-    });\n+    let name = CString::from_slice(name.get().as_bytes());\n+    let (var_alloca, var_metadata) = match variable_access {\n+        DirectVariable { alloca } => (\n+            alloca,\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateLocalVariable(\n+                    DIB(cx),\n+                    dwarf_tag,\n+                    scope_metadata,\n+                    name.as_ptr(),\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    cx.sess().opts.optimize != config::No,\n+                    0,\n+                    argument_index)\n+            }\n+        ),\n+        IndirectVariable { alloca, address_operations } => (\n+            alloca,\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateComplexVariable(\n+                    DIB(cx),\n+                    dwarf_tag,\n+                    scope_metadata,\n+                    name.as_ptr(),\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    argument_index)\n+            }\n+        )\n+    };\n \n     set_debug_location(cx, DebugLocation::new(scope_metadata,\n                                               loc.line,\n@@ -1753,14 +1743,12 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n             full_path\n         };\n \n-    let file_metadata =\n-        file_name.with_c_str(|file_name| {\n-            work_dir.with_c_str(|work_dir| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n-                }\n-            })\n-        });\n+    let file_name = CString::from_slice(file_name.as_bytes());\n+    let work_dir = CString::from_slice(work_dir.as_bytes());\n+    let file_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n+                                      work_dir.as_ptr())\n+    };\n \n     let mut created_files = debug_context(cx).created_files.borrow_mut();\n     created_files.insert(full_path.to_string(), file_metadata);\n@@ -1788,16 +1776,14 @@ fn scope_metadata(fcx: &FunctionContext,\n }\n \n fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n-    \"!\".with_c_str(|name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateBasicType(\n-                DIB(cx),\n-                name,\n-                bytes_to_bits(0),\n-                bytes_to_bits(0),\n-                DW_ATE_unsigned)\n-        }\n-    })\n+    unsafe {\n+        llvm::LLVMDIBuilderCreateBasicType(\n+            DIB(cx),\n+            \"!\\0\".as_ptr() as *const _,\n+            bytes_to_bits(0),\n+            bytes_to_bits(0),\n+            DW_ATE_unsigned)\n+    }\n }\n \n fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1833,16 +1819,15 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let ty_metadata = name.with_c_str(|name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateBasicType(\n-                DIB(cx),\n-                name,\n-                bytes_to_bits(size),\n-                bytes_to_bits(align),\n-                encoding)\n-        }\n-    });\n+    let name = CString::from_slice(name.as_bytes());\n+    let ty_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateBasicType(\n+            DIB(cx),\n+            name.as_ptr(),\n+            bytes_to_bits(size),\n+            bytes_to_bits(align),\n+            encoding)\n+    };\n \n     return ty_metadata;\n }\n@@ -1854,16 +1839,15 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n-    let ptr_metadata = name.with_c_str(|name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreatePointerType(\n-                DIB(cx),\n-                pointee_type_metadata,\n-                bytes_to_bits(pointer_size),\n-                bytes_to_bits(pointer_align),\n-                name)\n-        }\n-    });\n+    let name = CString::from_slice(name.as_bytes());\n+    let ptr_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreatePointerType(\n+            DIB(cx),\n+            pointee_type_metadata,\n+            bytes_to_bits(pointer_size),\n+            bytes_to_bits(pointer_align),\n+            name.as_ptr())\n+    };\n     return ptr_metadata;\n }\n \n@@ -2473,14 +2457,14 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n         .map(|v| {\n-            token::get_name(v.name).get().with_c_str(|name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateEnumerator(\n-                        DIB(cx),\n-                        name,\n-                        v.disr_val as u64)\n-                }\n-            })\n+            let token = token::get_name(v.name);\n+            let name = CString::from_slice(token.get().as_bytes());\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateEnumerator(\n+                    DIB(cx),\n+                    name.as_ptr(),\n+                    v.disr_val as u64)\n+            }\n         })\n         .collect();\n \n@@ -2504,20 +2488,19 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   codemap::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n-                let discriminant_type_metadata = discriminant_name.get().with_c_str(|name| {\n-                    unsafe {\n-                        llvm::LLVMDIBuilderCreateEnumerationType(\n-                            DIB(cx),\n-                            containing_scope,\n-                            name,\n-                            UNKNOWN_FILE_METADATA,\n-                            UNKNOWN_LINE_NUMBER,\n-                            bytes_to_bits(discriminant_size),\n-                            bytes_to_bits(discriminant_align),\n-                            create_DIArray(DIB(cx), enumerators_metadata[]),\n-                            discriminant_base_type_metadata)\n-                    }\n-                });\n+                let name = CString::from_slice(discriminant_name.get().as_bytes());\n+                let discriminant_type_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateEnumerationType(\n+                        DIB(cx),\n+                        containing_scope,\n+                        name.as_ptr(),\n+                        UNKNOWN_FILE_METADATA,\n+                        UNKNOWN_LINE_NUMBER,\n+                        bytes_to_bits(discriminant_size),\n+                        bytes_to_bits(discriminant_align),\n+                        create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n+                        discriminant_base_type_metadata)\n+                };\n \n                 debug_context(cx).created_enum_disr_types\n                                  .borrow_mut()\n@@ -2548,24 +2531,22 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              .borrow()\n                              .get_unique_type_id_as_string(unique_type_id);\n \n-    let enum_metadata = enum_name.with_c_str(|enum_name| {\n-        unique_type_id_str.with_c_str(|unique_type_id_str| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateUnionType(\n-                DIB(cx),\n-                containing_scope,\n-                enum_name,\n-                UNKNOWN_FILE_METADATA,\n-                UNKNOWN_LINE_NUMBER,\n-                bytes_to_bits(enum_type_size),\n-                bytes_to_bits(enum_type_align),\n-                0, // Flags\n-                ptr::null_mut(),\n-                0, // RuntimeLang\n-                unique_type_id_str)\n-            }\n-        })\n-    });\n+    let enum_name = CString::from_slice(enum_name.as_bytes());\n+    let unique_type_id_str = CString::from_slice(unique_type_id_str.as_bytes());\n+    let enum_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateUnionType(\n+        DIB(cx),\n+        containing_scope,\n+        enum_name.as_ptr(),\n+        UNKNOWN_FILE_METADATA,\n+        UNKNOWN_LINE_NUMBER,\n+        bytes_to_bits(enum_type_size),\n+        bytes_to_bits(enum_type_align),\n+        0, // Flags\n+        ptr::null_mut(),\n+        0, // RuntimeLang\n+        unique_type_id_str.as_ptr())\n+    };\n \n     return create_and_register_recursive_type_forward_declaration(\n         cx,\n@@ -2676,21 +2657,20 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                 ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n             };\n \n-            member_description.name.with_c_str(|member_name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateMemberType(\n-                        DIB(cx),\n-                        composite_type_metadata,\n-                        member_name,\n-                        UNKNOWN_FILE_METADATA,\n-                        UNKNOWN_LINE_NUMBER,\n-                        bytes_to_bits(member_size),\n-                        bytes_to_bits(member_align),\n-                        bytes_to_bits(member_offset),\n-                        member_description.flags,\n-                        member_description.type_metadata)\n-                }\n-            })\n+            let member_name = CString::from_slice(member_description.name.as_bytes());\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    composite_type_metadata,\n+                    member_name.as_ptr(),\n+                    UNKNOWN_FILE_METADATA,\n+                    UNKNOWN_LINE_NUMBER,\n+                    bytes_to_bits(member_size),\n+                    bytes_to_bits(member_align),\n+                    bytes_to_bits(member_offset),\n+                    member_description.flags,\n+                    member_description.type_metadata)\n+            }\n         })\n         .collect();\n \n@@ -2714,30 +2694,28 @@ fn create_struct_stub(cx: &CrateContext,\n     let unique_type_id_str = debug_context(cx).type_map\n                                               .borrow()\n                                               .get_unique_type_id_as_string(unique_type_id);\n+    let name = CString::from_slice(struct_type_name.as_bytes());\n+    let unique_type_id = CString::from_slice(unique_type_id_str.as_bytes());\n     let metadata_stub = unsafe {\n-        struct_type_name.with_c_str(|name| {\n-            unique_type_id_str.with_c_str(|unique_type_id| {\n-                // LLVMDIBuilderCreateStructType() wants an empty array. A null\n-                // pointer will lead to hard to trace and debug LLVM assertions\n-                // later on in llvm/lib/IR/Value.cpp.\n-                let empty_array = create_DIArray(DIB(cx), &[]);\n-\n-                llvm::LLVMDIBuilderCreateStructType(\n-                    DIB(cx),\n-                    containing_scope,\n-                    name,\n-                    UNKNOWN_FILE_METADATA,\n-                    UNKNOWN_LINE_NUMBER,\n-                    bytes_to_bits(struct_size),\n-                    bytes_to_bits(struct_align),\n-                    0,\n-                    ptr::null_mut(),\n-                    empty_array,\n-                    0,\n-                    ptr::null_mut(),\n-                    unique_type_id)\n-            })\n-        })\n+        // LLVMDIBuilderCreateStructType() wants an empty array. A null\n+        // pointer will lead to hard to trace and debug LLVM assertions\n+        // later on in llvm/lib/IR/Value.cpp.\n+        let empty_array = create_DIArray(DIB(cx), &[]);\n+\n+        llvm::LLVMDIBuilderCreateStructType(\n+            DIB(cx),\n+            containing_scope,\n+            name.as_ptr(),\n+            UNKNOWN_FILE_METADATA,\n+            UNKNOWN_LINE_NUMBER,\n+            bytes_to_bits(struct_size),\n+            bytes_to_bits(struct_align),\n+            0,\n+            ptr::null_mut(),\n+            empty_array,\n+            0,\n+            ptr::null_mut(),\n+            unique_type_id.as_ptr())\n     };\n \n     return metadata_stub;\n@@ -3464,7 +3442,7 @@ fn create_scope_map(cx: &CrateContext,\n                 }\n             }\n \n-            ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat) => {\n+            ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat, _) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n                 walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n             }\n@@ -4011,18 +3989,18 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                         None => ptr::null_mut()\n                     };\n                     let namespace_name = token::get_name(name);\n-                    let scope = namespace_name.get().with_c_str(|namespace_name| {\n-                        unsafe {\n-                            llvm::LLVMDIBuilderCreateNameSpace(\n-                                DIB(cx),\n-                                parent_scope,\n-                                namespace_name,\n-                                // cannot reconstruct file ...\n-                                ptr::null_mut(),\n-                                // ... or line information, but that's not so important.\n-                                0)\n-                        }\n-                    });\n+                    let namespace_name = CString::from_slice(namespace_name\n+                                                                .get().as_bytes());\n+                    let scope = unsafe {\n+                        llvm::LLVMDIBuilderCreateNameSpace(\n+                            DIB(cx),\n+                            parent_scope,\n+                            namespace_name.as_ptr(),\n+                            // cannot reconstruct file ...\n+                            ptr::null_mut(),\n+                            // ... or line information, but that's not so important.\n+                            0)\n+                    };\n \n                     let node = Rc::new(NamespaceTreeNode {\n                         name: name,\n@@ -4060,7 +4038,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n     if needs_gdb_debug_scripts_section(ccx) {\n-        let empty = b\"\".to_c_str();\n+        let empty = CString::from_slice(b\"\");\n         let gdb_debug_scripts_section_global =\n             get_or_insert_gdb_debug_scripts_section_global(ccx);\n         unsafe {\n@@ -4077,23 +4055,25 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext)\n /// section.\n fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n                                                   -> llvm::ValueRef {\n-    let section_var_name = b\"__rustc_debug_gdb_scripts_section__\".to_c_str();\n+    let section_var_name = b\"__rustc_debug_gdb_scripts_section__\\0\";\n \n     let section_var = unsafe {\n-        llvm::LLVMGetNamedGlobal(ccx.llmod(), section_var_name.as_ptr())\n+        llvm::LLVMGetNamedGlobal(ccx.llmod(),\n+                                 section_var_name.as_ptr() as *const _)\n     };\n \n     if section_var == ptr::null_mut() {\n-        let section_name = b\".debug_gdb_scripts\".to_c_str();\n+        let section_name = b\".debug_gdb_scripts\\0\";\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n             let llvm_type = Type::array(&Type::i8(ccx),\n                                         section_contents.len() as u64);\n             let section_var = llvm::LLVMAddGlobal(ccx.llmod(),\n                                                   llvm_type.to_ref(),\n-                                                  section_var_name.as_ptr());\n-            llvm::LLVMSetSection(section_var, section_name.as_ptr());\n+                                                  section_var_name.as_ptr()\n+                                                    as *const _);\n+            llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n             llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);"}, {"sha": "1c9be6ae4a8ba5e357566cf1ff2d65834ac56020", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -24,9 +24,10 @@ use trans::type_::Type;\n use trans::type_of::*;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use middle::subst::{Substs};\n+use middle::subst::Substs;\n+\n+use std::ffi::CString;\n use std::cmp;\n-use std::c_str::ToCStr;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n use syntax::abi::{RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n@@ -132,9 +133,9 @@ pub fn register_static(ccx: &CrateContext,\n             };\n             unsafe {\n                 // Declare a symbol `foo` with the desired linkage.\n-                let g1 = ident.get().with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(), buf)\n-                });\n+                let buf = CString::from_slice(ident.get().as_bytes());\n+                let g1 = llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(),\n+                                             buf.as_ptr());\n                 llvm::SetLinkage(g1, linkage);\n \n                 // Declare an internal global `extern_with_linkage_foo` which\n@@ -145,19 +146,18 @@ pub fn register_static(ccx: &CrateContext,\n                 // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(ident.get());\n-                let g2 = real_name.with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf)\n-                });\n+                let real_name = CString::from_vec(real_name.into_bytes());\n+                let g2 = llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(),\n+                                             real_name.as_ptr());\n                 llvm::SetLinkage(g2, llvm::InternalLinkage);\n                 llvm::LLVMSetInitializer(g2, g1);\n                 g2\n             }\n         }\n         None => unsafe {\n             // Generate an external declaration.\n-            ident.get().with_c_str(|buf| {\n-                llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf)\n-            })\n+            let buf = CString::from_slice(ident.get().as_bytes());\n+            llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf.as_ptr())\n         }\n     }\n }\n@@ -606,9 +606,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         //         return r;\n         //     }\n \n-        let the_block =\n-            \"the block\".with_c_str(\n-                |s| llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llwrapfn, s));\n+        let ptr = \"the block\\0\".as_ptr();\n+        let the_block = llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llwrapfn,\n+                                                            ptr as *const _);\n \n         let builder = ccx.builder();\n         builder.position_at_end(the_block);"}, {"sha": "2fd9031fdfe4cc7f6e74fc1d70c40da040c26ad0", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -40,8 +40,8 @@ use util::ppaux::{ty_to_short_str, Repr};\n use util::ppaux;\n \n use arena::TypedArena;\n-use std::c_str::ToCStr;\n use libc::c_uint;\n+use std::ffi::CString;\n use syntax::ast;\n use syntax::parse::token;\n \n@@ -486,11 +486,11 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n-    let gvar = name.with_c_str(|buf| {\n-        unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(), buf)\n-        }\n-    });\n+    let buf = CString::from_slice(name.as_bytes());\n+    let gvar = unsafe {\n+        llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(),\n+                            buf.as_ptr())\n+    };\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident("}, {"sha": "de0f714276d0de4ec94a6513de0161193b24d001", "filename": "src/librustc_trans/trans/llrepr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,7 +12,7 @@ use trans::context::CrateContext;\n use trans::type_::Type;\n use llvm::ValueRef;\n \n-pub trait LlvmRepr for Sized? {\n+pub trait LlvmRepr {\n     fn llrepr(&self, ccx: &CrateContext) -> String;\n }\n "}, {"sha": "77efcc6fb0030d9d768d644c02f30696ec91b09b", "filename": "src/librustc_trans/trans/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmacros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n macro_rules! unpack_datum {\n     ($bcx: ident, $inp: expr) => (\n         {"}, {"sha": "f6d69959dadf9ecec5607e0b0a17cdb6f03a7240", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -34,7 +34,7 @@ use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use util::ppaux::Repr;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n@@ -762,9 +762,9 @@ pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n     unsafe {\n         let tbl = C_struct(ccx, components[], false);\n         let sym = token::gensym(\"vtable\");\n-        let vt_gvar = format!(\"vtable{}\", sym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(), buf)\n-        });\n+        let buf = CString::from_vec(format!(\"vtable{}\", sym.uint()).into_bytes());\n+        let vt_gvar = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(),\n+                                          buf.as_ptr());\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, llvm::True);\n         llvm::SetLinkage(vt_gvar, llvm::InternalLinkage);"}, {"sha": "fa9cd5a698bbe05784d661832f89cbb630529f90", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -16,8 +16,11 @@ pub use self::base::trans_crate;\n pub use self::context::CrateContext;\n pub use self::common::gensym_name;\n \n-mod doc;\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod macros;\n+\n+mod doc;\n mod inline;\n mod monomorphize;\n mod controlflow;"}, {"sha": "3785c2fb9bc54e5b633e3dd36099266ed2840dec", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -19,7 +19,7 @@ use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n \n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::mem;\n use std::cell::RefCell;\n use std::iter::repeat;\n@@ -157,7 +157,8 @@ impl Type {\n     }\n \n     pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n-        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ccx.llcx(), s)))\n+        let name = CString::from_slice(name.as_bytes());\n+        ty!(llvm::LLVMStructCreateNamed(ccx.llcx(), name.as_ptr()))\n     }\n \n     pub fn empty_struct(ccx: &CrateContext) -> Type {"}, {"sha": "183b8c5c830ef0f29f71ab43c683120f755190cb", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -361,14 +361,6 @@ fn create_substs_for_ast_path<'tcx>(\n                                            supplied_ty_param_count)[]);\n     }\n \n-    if supplied_ty_param_count > required_ty_param_count\n-        && !this.tcx().sess.features.borrow().default_type_params {\n-        span_err!(this.tcx().sess, span, E0108,\n-            \"default type parameters are experimental and possibly buggy\");\n-        span_help!(this.tcx().sess, span,\n-            \"add #![feature(default_type_params)] to the crate attributes to enable\");\n-    }\n-\n     let mut substs = Substs::new_type(types, regions);\n \n     match self_ty {"}, {"sha": "80e7e7060595675b2e09485b529fb4dcb0981f4d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 127, "deletions": 20, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -30,7 +30,9 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n \n pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n-                           pat: &ast::Pat, expected: Ty<'tcx>) {\n+                           pat: &ast::Pat,\n+                           expected: Ty<'tcx>)\n+{\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -46,6 +48,19 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_expr(fcx, &**lt);\n             let expr_ty = fcx.expr_ty(&**lt);\n             fcx.write_ty(pat.id, expr_ty);\n+\n+            // somewhat surprising: in this case, the subtyping\n+            // relation goes the opposite way as the other\n+            // cases. Actually what we really want is not a subtyping\n+            // relation at all but rather that there exists a LUB (so\n+            // that they can be compared). However, in practice,\n+            // constants are always scalars or strings.  For scalars\n+            // subtyping is irrelevant, and for strings `expr_ty` is\n+            // type is `&'static str`, so if we say that\n+            //\n+            //     &'static str <: expected\n+            //\n+            // that's equivalent to there existing a LUB.\n             demand::suptype(fcx, pat.span, expected, expr_ty);\n         }\n         ast::PatRange(ref begin, ref end) => {\n@@ -54,10 +69,16 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             let lhs_ty = fcx.expr_ty(&**begin);\n             let rhs_ty = fcx.expr_ty(&**end);\n-            if require_same_types(\n-                tcx, Some(fcx.infcx()), false, pat.span, lhs_ty, rhs_ty,\n-                || \"mismatched types in range\".to_string())\n-                && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(rhs_ty)) {\n+\n+            let lhs_eq_rhs =\n+                require_same_types(\n+                    tcx, Some(fcx.infcx()), false, pat.span, lhs_ty, rhs_ty,\n+                    || \"mismatched types in range\".to_string());\n+\n+            let numeric_or_char =\n+                lhs_eq_rhs && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(lhs_ty));\n+\n+            if numeric_or_char {\n                 match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n                     Some(false) => {\n                         span_err!(tcx.sess, begin.span, E0030,\n@@ -71,38 +92,59 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             } else {\n                 span_err!(tcx.sess, begin.span, E0029,\n-                    \"only char and numeric types are allowed in range\");\n+                          \"only char and numeric types are allowed in range\");\n             }\n \n             fcx.write_ty(pat.id, lhs_ty);\n+\n+            // subtyping doens't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n             let const_did = tcx.def_map.borrow()[pat.id].clone().def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n-            fcx.write_ty(pat.id, const_scheme.ty);\n-            demand::suptype(fcx, pat.span, expected, const_scheme.ty);\n+            assert!(const_scheme.generics.is_empty());\n+            let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n+                                                           &Substs::empty(),\n+                                                           &const_scheme.ty);\n+            fcx.write_ty(pat.id, const_ty);\n+\n+            // FIXME(#20489) -- we should limit the types here to scalars or something!\n+\n+            // As with PatLit, what we really want here is that there\n+            // exist a LUB, but for the cases that can occur, subtype\n+            // is good enough.\n+            demand::suptype(fcx, pat.span, expected, const_ty);\n         }\n         ast::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);\n             match bm {\n                 ast::BindByRef(mutbl) => {\n                     // if the binding is like\n                     //    ref x | ref const x | ref mut x\n-                    // then the type of x is &M T where M is the mutability\n-                    // and T is the expected type\n+                    // then `x` is assigned a value of type `&M T` where M is the mutability\n+                    // and T is the expected type.\n                     let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     let mt = ty::mt { ty: expected, mutbl: mutbl };\n                     let region_ty = ty::mk_rptr(tcx, tcx.mk_region(region_var), mt);\n+\n+                    // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n+                    // required. However, we use equality, which is stronger. See (*) for\n+                    // an explanation.\n                     demand::eqtype(fcx, pat.span, region_ty, typ);\n                 }\n                 // otherwise the type of x is the expected type T\n                 ast::BindByValue(_) => {\n+                    // As above, `T <: typeof(x)` is required but we\n+                    // use equality, see (*) below.\n                     demand::eqtype(fcx, pat.span, expected, typ);\n                 }\n             }\n+\n             fcx.write_ty(pat.id, typ);\n \n+            // if there are multiple arms, make sure they all agree on\n+            // what the type of the binding `x` ought to be\n             let canon_id = pcx.map[path.node];\n             if canon_id != pat.id {\n                 let ct = fcx.local_ty(pat.span, canon_id);\n@@ -124,8 +166,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_pat_struct(pcx, pat, path, fields.as_slice(), etc, expected);\n         }\n         ast::PatTup(ref elements) => {\n-            let element_tys: Vec<_> = range(0, elements.len()).map(|_| fcx.infcx()\n-                .next_ty_var()).collect();\n+            let element_tys: Vec<_> =\n+                range(0, elements.len()).map(|_| fcx.infcx().next_ty_var())\n+                                        .collect();\n             let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n@@ -138,27 +181,37 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let uniq_ty = ty::mk_uniq(tcx, inner_ty);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n-                demand::suptype(fcx, pat.span, expected, uniq_ty);\n+                // Here, `demand::subtype` is good enough, but I don't\n+                // think any errors can be introduced by using\n+                // `demand::eqtype`.\n+                demand::eqtype(fcx, pat.span, expected, uniq_ty);\n                 fcx.write_ty(pat.id, uniq_ty);\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n                 fcx.write_error(pat.id);\n                 check_pat(pcx, &**inner, tcx.types.err);\n             }\n         }\n-        ast::PatRegion(ref inner) => {\n+        ast::PatRegion(ref inner, mutbl) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n \n-            let mutbl =\n+            // SNAP b2085d9 remove this `if`-`else` entirely after next snapshot\n+            let mutbl = if mutbl == ast::MutImmutable {\n                 ty::deref(fcx.infcx().shallow_resolve(expected), true)\n-                .map_or(ast::MutImmutable, |mt| mt.mutbl);\n+                   .map(|mt| mt.mutbl).unwrap_or(ast::MutImmutable)\n+            } else {\n+                mutbl\n+            };\n \n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n             let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n             let rptr_ty = ty::mk_rptr(tcx, tcx.mk_region(region), mt);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n-                demand::suptype(fcx, pat.span, expected, rptr_ty);\n+                // `demand::subtype` would be good enough, but using\n+                // `eqtype` turns out to be equally general. See (*)\n+                // below for details.\n+                demand::eqtype(fcx, pat.span, expected, rptr_ty);\n                 fcx.write_ty(pat.id, rptr_ty);\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n@@ -181,14 +234,18 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n                         ty: inner_ty,\n-                        mutbl: ty::deref(expected_ty, true)\n-                            .map_or(ast::MutImmutable, |mt| mt.mutbl)\n+                        mutbl: ty::deref(expected_ty, true).map(|mt| mt.mutbl)\n+                                                           .unwrap_or(ast::MutImmutable)\n                     })\n                 }\n             };\n \n             fcx.write_ty(pat.id, pat_ty);\n-            demand::suptype(fcx, pat.span, expected, pat_ty);\n+\n+            // `demand::subtype` would be good enough, but using\n+            // `eqtype` turns out to be equally general. See (*)\n+            // below for details.\n+            demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n             for elt in before.iter() {\n                 check_pat(pcx, &**elt, inner_ty);\n@@ -210,6 +267,56 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatMac(_) => tcx.sess.bug(\"unexpanded macro\")\n     }\n+\n+\n+    // (*) In most of the cases above (literals and constants being\n+    // the exception), we relate types using strict equality, evewn\n+    // though subtyping would be sufficient. There are a few reasons\n+    // for this, some of which are fairly subtle and which cost me\n+    // (nmatsakis) an hour or two debugging to remember, so I thought\n+    // I'd write them down this time.\n+    //\n+    // 1. Most importantly, there is no loss of expressiveness\n+    // here. What we are saying is that the type of `x`\n+    // becomes *exactly* what is expected. This might seem\n+    // like it will cause errors in a case like this:\n+    //\n+    // ```\n+    // fn foo<'x>(x: &'x int) {\n+    //    let a = 1;\n+    //    let mut z = x;\n+    //    z = &a;\n+    // }\n+    // ```\n+    //\n+    // The reason we might get an error is that `z` might be\n+    // assigned a type like `&'x int`, and then we would have\n+    // a problem when we try to assign `&a` to `z`, because\n+    // the lifetime of `&a` (i.e., the enclosing block) is\n+    // shorter than `'x`.\n+    //\n+    // HOWEVER, this code works fine. The reason is that the\n+    // expected type here is whatever type the user wrote, not\n+    // the initializer's type. In this case the user wrote\n+    // nothing, so we are going to create a type variable `Z`.\n+    // Then we will assign the type of the initializer (`&'x\n+    // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n+    // will instantiate `Z` as a type `&'0 int` where `'0` is\n+    // a fresh region variable, with the constraint that `'x :\n+    // '0`.  So basically we're all set.\n+    //\n+    // Note that there are two tests to check that this remains true\n+    // (`regions-reassign-{match,let}-bound-pointer.rs`).\n+    //\n+    // 2. Things go horribly wrong if we use subtype. The reason for\n+    // THIS is a fairly subtle case involving bound regions. See the\n+    // `givens` field in `region_inference`, as well as the test\n+    // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n+    // for details. Short version is that we must sometimes detect\n+    // relationships between specific region variables and regions\n+    // bound in a closure signature, and that detection gets thrown\n+    // off when we substitute fresh region variables here to enable\n+    // subtyping.\n }\n \n pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,"}, {"sha": "b1dc033b567bbf659f58053bb30d68b553c33efe", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -22,7 +22,7 @@ use super::TupleArgumentsFlag;\n use super::write_call;\n \n use middle::infer;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{self, Ty};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;"}, {"sha": "a51e89c1669de7cd6d4fa0d8972ab5f17c68c528", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -18,14 +18,15 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n-// Requires that the two types unify, and prints an error message if they\n-// don't.\n+// Requires that the two types unify, and prints an error message if\n+// they don't.\n pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-    suptype_with_fn(fcx, sp, false, expected, actual,\n+                         ty_expected: Ty<'tcx>, ty_actual: Ty<'tcx>) {\n+    suptype_with_fn(fcx, sp, false, ty_expected, ty_actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n+/// As `suptype`, but call `handle_err` if unification for subtyping fails.\n pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                     sp: Span,\n                                     b_is_expected: bool,\n@@ -48,9 +49,7 @@ pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n-        Err(ref err) => {\n-            fcx.report_mismatched_types(sp, expected, actual, err);\n-        }\n+        Err(ref err) => { fcx.report_mismatched_types(sp, expected, actual, err); }\n     }\n }\n "}, {"sha": "115711ae92b297f75360699e7c29198173370d81", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -442,7 +442,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_extension_candidates_for_trait(&mut self,\n                                                trait_def_id: ast::DefId) {\n-        debug!(\"assemble_extension_candidates_for_trait: trait_def_id={}\",\n+        debug!(\"assemble_extension_candidates_for_trait(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n@@ -471,8 +471,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                            matching_index);\n \n         self.assemble_unboxed_closure_candidates(trait_def_id,\n-                                                 method,\n+                                                 method.clone(),\n                                                  matching_index);\n+\n+        self.assemble_where_clause_candidates(trait_def_id,\n+                                              method,\n+                                              matching_index);\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n@@ -599,6 +603,35 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n+    fn assemble_where_clause_candidates(&mut self,\n+                                        trait_def_id: ast::DefId,\n+                                        method_ty: Rc<ty::Method<'tcx>>,\n+                                        method_index: uint)\n+    {\n+        debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n+               trait_def_id.repr(self.tcx()));\n+\n+        // Check whether there are any where-clauses pertaining to this trait.\n+        let caller_predicates =\n+            self.fcx.inh.param_env.caller_bounds.predicates.as_slice().to_vec();\n+        for bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n+                     .filter_map(|p| p.to_opt_poly_trait_ref())\n+                     .filter(|b| b.def_id() == trait_def_id)\n+        {\n+            let xform_self_ty = self.xform_self_ty(&method_ty, bound.substs());\n+\n+            debug!(\"assemble_where_clause_candidates: bound={} xform_self_ty={}\",\n+                   bound.repr(self.tcx()),\n+                   xform_self_ty.repr(self.tcx()));\n+\n+            self.extension_candidates.push(Candidate {\n+                xform_self_ty: xform_self_ty,\n+                method_ty: method_ty.clone(),\n+                kind: WhereClauseCandidate(bound, method_index)\n+            });\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // THE ACTUAL SEARCH\n \n@@ -774,26 +807,26 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             match probe.kind {\n                 InherentImplCandidate(impl_def_id, ref substs) |\n                 ExtensionImplCandidate(impl_def_id, _, ref substs, _) => {\n+                    let selcx = &mut traits::SelectionContext::new(self.infcx(), self.fcx);\n+                    let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n+\n                     // Check whether the impl imposes obligations we have to worry about.\n                     let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n                     let impl_bounds = impl_generics.to_bounds(self.tcx(), substs);\n-                    // FIXME(#20378) assoc type normalization here?\n-\n-                    // Erase any late-bound regions bound in the impl\n-                    // which appear in the bounds.\n-                    let impl_bounds = self.erase_late_bound_regions(&ty::Binder(impl_bounds));\n+                    let traits::Normalized { value: impl_bounds,\n+                                             obligations: norm_obligations } =\n+                        traits::normalize(selcx, cause.clone(), &impl_bounds);\n \n                     // Convert the bounds into obligations.\n                     let obligations =\n-                        traits::predicates_for_generics(\n-                            self.tcx(),\n-                            traits::ObligationCause::misc(self.span, self.fcx.body_id),\n-                            &impl_bounds);\n+                        traits::predicates_for_generics(self.tcx(),\n+                                                        cause.clone(),\n+                                                        &impl_bounds);\n                     debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n \n                     // Evaluate those obligations to see if they might possibly hold.\n-                    let mut selcx = traits::SelectionContext::new(self.infcx(), self.fcx);\n-                    obligations.all(|o| selcx.evaluate_obligation(o))\n+                    obligations.all(|o| selcx.evaluate_obligation(o)) &&\n+                        norm_obligations.iter().all(|o| selcx.evaluate_obligation(o))\n                 }\n \n                 ObjectCandidate(..) |"}, {"sha": "1b51434a58cc130c5f20b9a73810ee4ba797b0c9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -4554,7 +4554,7 @@ impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n pub fn check_decl_initializer(fcx: &FnCtxt,\n                               nid: ast::NodeId,\n                               init: &ast::Expr)\n-                            {\n+{\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n }"}, {"sha": "c7df5ed8453fd3a990658694248c632f5f65dfef", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -92,7 +92,7 @@ use middle::region::CodeExtent;\n use middle::traits;\n use middle::ty::{ReScope};\n use middle::ty::{self, Ty, MethodCall};\n-use middle::infer;\n+use middle::infer::{self, GenericKind};\n use middle::pat_util;\n use util::ppaux::{ty_to_string, Repr};\n \n@@ -164,7 +164,7 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub struct Rcx<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n \n-    region_param_pairs: Vec<(ty::Region, ty::ParamTy)>,\n+    region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               subject: subject,\n-              region_param_pairs: Vec::new() }\n+              region_bound_pairs: Vec::new() }\n     }\n \n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n@@ -286,12 +286,12 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             }\n         };\n \n-        let len = self.region_param_pairs.len();\n+        let len = self.region_bound_pairs.len();\n         self.relate_free_regions(fn_sig[], body.id);\n         link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs[]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n-        self.region_param_pairs.truncate(len);\n+        self.region_bound_pairs.truncate(len);\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n@@ -357,11 +357,11 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                         // relationship that arises here, but\n                         // presently we do not.)\n                     }\n-                    regionmanip::RegionSubParamConstraint(_, r_a, p_b) => {\n-                        debug!(\"RegionSubParamConstraint: {} <= {}\",\n-                               r_a.repr(tcx), p_b.repr(tcx));\n+                    regionmanip::RegionSubGenericConstraint(_, r_a, ref generic_b) => {\n+                        debug!(\"RegionSubGenericConstraint: {} <= {}\",\n+                               r_a.repr(tcx), generic_b.repr(tcx));\n \n-                        self.region_param_pairs.push((r_a, p_b));\n+                        self.region_bound_pairs.push((r_a, generic_b.clone()));\n                     }\n                 }\n             }\n@@ -1427,31 +1427,31 @@ fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 rcx.fcx.mk_subr(o1, r_a, r_b);\n             }\n-            regionmanip::RegionSubParamConstraint(None, r_a, param_b) => {\n-                param_must_outlive(rcx, origin.clone(), r_a, param_b);\n+            regionmanip::RegionSubGenericConstraint(None, r_a, ref generic_b) => {\n+                generic_must_outlive(rcx, origin.clone(), r_a, generic_b);\n             }\n-            regionmanip::RegionSubParamConstraint(Some(ty), r_a, param_b) => {\n+            regionmanip::RegionSubGenericConstraint(Some(ty), r_a, ref generic_b) => {\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n-                param_must_outlive(rcx, o1, r_a, param_b);\n+                generic_must_outlive(rcx, o1, r_a, generic_b);\n             }\n         }\n     }\n }\n \n-fn param_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                origin: infer::SubregionOrigin<'tcx>,\n-                                region: ty::Region,\n-                                param_ty: ty::ParamTy) {\n+fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                  origin: infer::SubregionOrigin<'tcx>,\n+                                  region: ty::Region,\n+                                  generic: &GenericKind<'tcx>) {\n     let param_env = &rcx.fcx.inh.param_env;\n \n-    debug!(\"param_must_outlive(region={}, param_ty={})\",\n+    debug!(\"param_must_outlive(region={}, generic={})\",\n            region.repr(rcx.tcx()),\n-           param_ty.repr(rcx.tcx()));\n+           generic.repr(rcx.tcx()));\n \n     // To start, collect bounds from user:\n     let mut param_bounds =\n         ty::required_region_bounds(rcx.tcx(),\n-                                   param_ty.to_ty(rcx.tcx()),\n+                                   generic.to_ty(rcx.tcx()),\n                                    param_env.caller_bounds.predicates.as_slice().to_vec());\n \n     // Add in the default bound of fn body that applies to all in\n@@ -1467,22 +1467,21 @@ fn param_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     //     fn foo<'a, A>(x: &'a A) { x.bar() }\n     //\n     // The problem is that the type of `x` is `&'a A`. To be\n-    // well-formed, then, A must be lower-bounded by `'a`, but we\n+    // well-formed, then, A must be lower-generic by `'a`, but we\n     // don't know that this holds from first principles.\n-    for &(ref r, ref p) in rcx.region_param_pairs.iter() {\n-        debug!(\"param_ty={} p={}\",\n-               param_ty.repr(rcx.tcx()),\n+    for &(ref r, ref p) in rcx.region_bound_pairs.iter() {\n+        debug!(\"generic={} p={}\",\n+               generic.repr(rcx.tcx()),\n                p.repr(rcx.tcx()));\n-        if param_ty == *p {\n+        if generic == p {\n             param_bounds.push(*r);\n         }\n     }\n \n-    // Inform region inference that this parameter type must be\n-    // properly bounded.\n-    infer::verify_param_bound(rcx.fcx.infcx(),\n-                              origin,\n-                              param_ty,\n-                              region,\n-                              param_bounds);\n+    // Inform region inference that this generic must be properly\n+    // bounded.\n+    rcx.fcx.infcx().verify_generic_bound(origin,\n+                                         generic.clone(),\n+                                         region,\n+                                         param_bounds);\n }"}, {"sha": "7ca21bdf5b83f7eaacac5c1114a9107cb9e25801", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,6 +12,7 @@\n \n pub use self::WfConstraint::*;\n \n+use middle::infer::GenericKind;\n use middle::subst::{ParamSpace, Subst, Substs};\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder};\n@@ -24,7 +25,7 @@ use util::ppaux::Repr;\n \n pub enum WfConstraint<'tcx> {\n     RegionSubRegionConstraint(Option<Ty<'tcx>>, ty::Region, ty::Region),\n-    RegionSubParamConstraint(Option<Ty<'tcx>>, ty::Region, ty::ParamTy),\n+    RegionSubGenericConstraint(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n }\n \n struct Wf<'a, 'tcx: 'a> {\n@@ -121,8 +122,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             ty::ty_projection(ref data) => {\n                 // `<T as TraitRef<..>>::Name`\n \n-                // FIXME(#20303) -- gain ability to require that ty_projection : in-scope region,\n-                // like a type parameter\n+                self.push_projection_constraint_from_top(data);\n \n                 // this seems like a minimal requirement:\n                 let trait_def = ty::lookup_trait_def(self.tcx, data.trait_ref.def_id);\n@@ -211,12 +211,21 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         self.push_param_constraint(region, opt_ty, param_ty);\n     }\n \n+    /// Pushes a constraint that `projection_ty` must outlive the top region on the stack.\n+    fn push_projection_constraint_from_top(&mut self,\n+                                           projection_ty: &ty::ProjectionTy<'tcx>) {\n+        let &(region, opt_ty) = self.stack.last().unwrap();\n+        self.out.push(RegionSubGenericConstraint(\n+            opt_ty, region, GenericKind::Projection(projection_ty.clone())));\n+    }\n+\n     /// Pushes a constraint that `region <= param_ty`, due to `opt_ty`\n     fn push_param_constraint(&mut self,\n                              region: ty::Region,\n                              opt_ty: Option<Ty<'tcx>>,\n                              param_ty: ty::ParamTy) {\n-        self.out.push(RegionSubParamConstraint(opt_ty, region, param_ty));\n+        self.out.push(RegionSubGenericConstraint(\n+            opt_ty, region, GenericKind::Param(param_ty)));\n     }\n \n     fn accumulate_from_adt(&mut self,\n@@ -373,16 +382,16 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n }\n \n impl<'tcx> Repr<'tcx> for WfConstraint<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n-            RegionSubRegionConstraint(_, r_a, r_b) => {\n+            RegionSubRegionConstraint(_, ref r_a, ref r_b) => {\n                 format!(\"RegionSubRegionConstraint({}, {})\",\n                         r_a.repr(tcx),\n                         r_b.repr(tcx))\n             }\n \n-            RegionSubParamConstraint(_, r, p) => {\n-                format!(\"RegionSubParamConstraint({}, {})\",\n+            RegionSubGenericConstraint(_, ref r, ref p) => {\n+                format!(\"RegionSubGenericConstraint({}, {})\",\n                         r.repr(tcx),\n                         p.repr(tcx))\n             }"}, {"sha": "77d71e740d681f8c626bc173e1139b8e87cca468", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -72,20 +72,30 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n             ast::ItemImpl(_, _, _, Some(_), _, _) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\", item.repr(self.tcx));\n+                let trait_def_id = ty::impl_trait_ref(self.tcx, def_id).unwrap().def_id;\n                 match traits::orphan_check(self.tcx, def_id) {\n                     Ok(()) => { }\n                     Err(traits::OrphanCheckErr::NoLocalInputType) => {\n-                        span_err!(self.tcx.sess, item.span, E0117,\n-                                  \"cannot provide an extension implementation \\\n-                                   where both trait and type are not defined in this crate\");\n+                        if !ty::has_attr(self.tcx, trait_def_id, \"old_orphan_check\") {\n+                            let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n+                            span_err!(\n+                                self.tcx.sess, item.span, E0117,\n+                                \"the type `{}` does not reference any \\\n+                                 types defined in this crate; \\\n+                                 only traits defined in the current crate can be \\\n+                                 implemented for arbitrary types\",\n+                                self_ty.user_string(self.tcx));\n+                        }\n                     }\n-                    Err(traits::OrphanCheckErr::UncoveredTypeParameter(param_ty)) => {\n-                        if !self.tcx.sess.features.borrow().old_orphan_check {\n+                    Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n+                        if !ty::has_attr(self.tcx, trait_def_id, \"old_orphan_check\") {\n                             self.tcx.sess.span_err(\n                                 item.span,\n-                                format!(\"type parameter `{}` must also appear as a type parameter \\\n-                                         of some type defined within this crate\",\n-                                        param_ty.user_string(self.tcx)).as_slice());\n+                                format!(\n+                                    \"type parameter `{}` is not constrained by any local type; \\\n+                                     only traits defined in the current crate can be implemented \\\n+                                     for a type parameter\",\n+                                    param_ty.user_string(self.tcx)).as_slice());\n                             self.tcx.sess.span_note(\n                                 item.span,\n                                 format!(\"for a limited time, you can add \\"}, {"sha": "dc434f1401585af1fa782235e983011bb418430e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -77,8 +77,21 @@ This API is completely unstable and subject to change.\n #![feature(unboxed_closures)]\n #![allow(non_camel_case_types)]\n \n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n \n extern crate arena;\n extern crate rustc;"}, {"sha": "bb9a9ac430340642d193d21293af34296674a4a0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -2220,7 +2220,7 @@ fn name_from_pat(p: &ast::Pat) -> String {\n         PatTup(ref elts) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().connect(\", \")),\n         PatBox(ref p) => name_from_pat(&**p),\n-        PatRegion(ref p) => name_from_pat(&**p),\n+        PatRegion(ref p, _) => name_from_pat(&**p),\n         PatLit(..) => {\n             warn!(\"tried to get argument name from PatLit, \\\n                   which is silly in function arguments\");"}, {"sha": "dcc90117d26606041d1cc721e52e893706df9c8d", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -20,8 +20,8 @@ pub use self::imp::Lock;\n \n #[cfg(unix)]\n mod imp {\n+    use std::ffi::CString;\n     use libc;\n-    use std::c_str::ToCStr;\n \n     #[cfg(target_os = \"linux\")]\n     mod os {\n@@ -111,9 +111,11 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let fd = p.with_c_str(|s| unsafe {\n-                libc::open(s, libc::O_RDWR | libc::O_CREAT, libc::S_IRWXU)\n-            });\n+            let buf = CString::from_slice(p.as_vec());\n+            let fd = unsafe {\n+                libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n+                           libc::S_IRWXU)\n+            };\n             assert!(fd > 0);\n             let flock = os::flock {\n                 l_start: 0,"}, {"sha": "30b9d6c63c5bb127db68bb38141011e850ed0f3c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -166,6 +166,9 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n                 }\n             }\n \n+            // Special macro vars are like keywords\n+            token::SpecialVarNt(_) => \"kw-2\",\n+\n             token::Lifetime(..) => \"lifetime\",\n             token::DocComment(..) => \"doccomment\",\n             token::Underscore | token::Eof | token::Interpolated(..) |"}, {"sha": "3b9265cf569765a39822fea60f54c567ddc9a46a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -29,7 +29,7 @@\n \n use libc;\n use std::ascii::AsciiExt;\n-use std::c_str::ToCStr;\n+use std::ffi::CString;\n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::fmt;\n@@ -215,7 +215,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                 let id = id.as_ref().map(|a| a.as_slice());\n                 s.push_str(highlight::highlight(text.as_slice(), None, id)\n                                      .as_slice());\n-                let output = s.to_c_str();\n+                let output = CString::from_vec(s.into_bytes());\n                 hoedown_buffer_puts(ob, output.as_ptr());\n             })\n         }\n@@ -224,15 +224,16 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n                      level: libc::c_int, opaque: *mut libc::c_void) {\n         // hoedown does this, we may as well too\n-        \"\\n\".with_c_str(|p| unsafe { hoedown_buffer_puts(ob, p) });\n+        unsafe { hoedown_buffer_puts(ob, \"\\n\\0\".as_ptr() as *const _); }\n \n         // Extract the text provided\n         let s = if text.is_null() {\n             \"\".to_string()\n         } else {\n-            unsafe {\n-                String::from_raw_buf_len((*text).data, (*text).size as uint)\n-            }\n+            let s = unsafe {\n+                slice::from_raw_buf(&(*text).data, (*text).size as uint)\n+            };\n+            str::from_utf8(s).unwrap().to_string()\n         };\n \n         // Transform the contents of the header into a hyphenated string\n@@ -273,7 +274,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                                format!(\"{} \", sec)\n                            });\n \n-        text.with_c_str(|p| unsafe { hoedown_buffer_puts(ob, p) });\n+        let text = CString::from_vec(text.into_bytes());\n+        unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n     }\n \n     reset_headers();"}, {"sha": "ddb14d6944b9d8f358aed8347577e7bf06d57887", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -2253,9 +2253,9 @@ impl<'a> fmt::Show for Source<'a> {\n             cols += 1;\n             tmp /= 10;\n         }\n-        try!(write!(fmt, \"<pre class='line-numbers'>\"));\n+        try!(write!(fmt, \"<pre class=\\\"line-numbers\\\">\"));\n         for i in range(1, lines + 1) {\n-            try!(write!(fmt, \"<span id='{0}'>{0:1$}</span>\\n\", i, cols));\n+            try!(write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols));\n         }\n         try!(write!(fmt, \"</pre>\"));\n         try!(write!(fmt, \"{}\", highlight::highlight(s.as_slice(), None, None)));"}, {"sha": "a5a482541410938bcfbbad6ba50cc27d93170ba2", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -157,6 +157,7 @@ nav.sub {\n     left: 0;\n     top: 0;\n     min-height: 100%;\n+    z-index: -1;\n }\n \n .content, nav { max-width: 960px; }\n@@ -217,10 +218,18 @@ nav.sub {\n     overflow: auto;\n     padding-left: 0;\n }\n-.content pre.line-numbers { float: left; border: none; }\n-.line-numbers span { color: #c67e2d; }\n+.content pre.line-numbers {\n+    float: left;\n+    border: none;\n+\n+    -webkit-user-select: none;\n+    -moz-user-select: none;\n+    -ms-user-select: none;\n+    user-select: none;\n+}\n+.line-numbers span { color: #c67e2d; cursor: pointer; }\n .line-numbers .line-highlighted {\n-    background-color: #f6fdb0;\n+    background-color: #f6fdb0 !important;\n }\n \n .content .highlighted {\n@@ -470,6 +479,7 @@ h1 .stability {\n .summary.Unmarked { background-color: #BBBBBB; }\n \n :target { background: #FDFFD3; }\n+.line-numbers :target { background-color: transparent; }\n \n /* Code highlighting */\n pre.rust .kw { color: #8959A8; }"}, {"sha": "2d575c226c5d0de5d938793553ec7d29ab64ae44", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -50,7 +50,7 @@\n     resizeShortBlocks();\n     $(window).on('resize', resizeShortBlocks);\n \n-    function highlightSourceLines() {\n+    function highlightSourceLines(ev) {\n         var i, from, to, match = window.location.hash.match(/^#?(\\d+)(?:-(\\d+))?$/);\n         if (match) {\n             from = parseInt(match[1], 10);\n@@ -59,14 +59,14 @@\n             if ($('#' + from).length === 0) {\n                 return;\n             }\n-            $('#' + from)[0].scrollIntoView();\n+            if (ev === null) $('#' + from)[0].scrollIntoView();\n             $('.line-numbers span').removeClass('line-highlighted');\n             for (i = from; i <= to; ++i) {\n                 $('#' + i).addClass('line-highlighted');\n             }\n         }\n     }\n-    highlightSourceLines();\n+    highlightSourceLines(null);\n     $(window).on('hashchange', highlightSourceLines);\n \n     $(document).on('keyup', function(e) {\n@@ -778,4 +778,35 @@\n         $(\"#main > .docblock\").before(wrapper);\n     });\n \n+    $('pre.line-numbers').on('click', 'span', function() {\n+        var prev_id = 0;\n+\n+        function set_fragment(name) {\n+            if (history.replaceState) {\n+                history.replaceState(null, null, '#' + name);\n+                $(window).trigger('hashchange');\n+            } else {\n+                location.replace('#' + name);\n+            }\n+        }\n+\n+        return function(ev) {\n+            var cur_id = parseInt(ev.target.id);\n+\n+            if (ev.shiftKey && prev_id) {\n+                if (prev_id > cur_id) {\n+                    var tmp = prev_id;\n+                    prev_id = cur_id;\n+                    cur_id = tmp;\n+                }\n+\n+                set_fragment(prev_id + '-' + cur_id);\n+            } else {\n+                prev_id = cur_id;\n+\n+                set_fragment(cur_id);\n+            }\n+        };\n+    }());\n+\n }());"}, {"sha": "6e42c50f974c51f2a4748db95d47c78a2ddf9fbe", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -32,7 +32,14 @@ extern crate rustc_driver;\n extern crate serialize;\n extern crate syntax;\n extern crate \"test\" as testing;\n-#[phase(plugin, link)] extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n \n@@ -49,11 +56,13 @@ use rustc::session::search_paths::SearchPaths;\n // reexported from `clean` so it can be easily updated with the mod itself\n pub use clean::SCHEMA_VERSION;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+pub mod externalfiles;\n+\n pub mod clean;\n pub mod core;\n pub mod doctree;\n-#[macro_escape]\n-pub mod externalfiles;\n pub mod fold;\n pub mod html {\n     pub mod highlight;"}, {"sha": "ad67672ea6ea741a35dc916fe31c990ee0f183f2", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                               None);\n         // attach the crate's exported macros to the top-level module:\n         self.module.macros = krate.exported_macros.iter()\n-            .map(|it| self.visit_macro(&**it)).collect();\n+            .map(|def| self.visit_macro(def)).collect();\n         self.module.is_crate = true;\n     }\n \n@@ -363,13 +363,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     // convert each exported_macro into a doc item\n-    fn visit_macro(&self, item: &ast::Item) -> Macro {\n+    fn visit_macro(&self, def: &ast::MacroDef) -> Macro {\n         Macro {\n-            id: item.id,\n-            attrs: item.attrs.clone(),\n-            name: item.ident,\n-            whence: item.span,\n-            stab: self.stability(item.id),\n+            id: def.id,\n+            attrs: def.attrs.clone(),\n+            name: def.ident,\n+            whence: def.span,\n+            stab: self.stability(def.id),\n         }\n     }\n }"}, {"sha": "11a49cd712f2557f155bdb09a81d219119faef06", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -70,7 +70,7 @@ static URLSAFE_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                        0123456789-_\";\n \n /// A trait for converting a value to base64 encoding.\n-pub trait ToBase64 for Sized? {\n+pub trait ToBase64 {\n     /// Converts the value of `self` to a base64 value following the specified\n     /// format configuration, returning the owned string.\n     fn to_base64(&self, config: Config) -> String;\n@@ -170,7 +170,7 @@ impl ToBase64 for [u8] {\n }\n \n /// A trait for converting from base64 encoded values.\n-pub trait FromBase64 for Sized? {\n+pub trait FromBase64 {\n     /// Converts the value of `self`, interpreted as base64 encoded data, into\n     /// an owned vector of bytes, returning the vector.\n     fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error>;"}, {"sha": "542d0678526b980367b48e41cd8f6ab0545c4a1c", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -18,7 +18,7 @@ use std::fmt;\n use std::error;\n \n /// A trait for converting a value to hexadecimal encoding\n-pub trait ToHex for Sized? {\n+pub trait ToHex {\n     /// Converts the value of `self` to a hex value, returning the owned\n     /// string.\n     fn to_hex(&self) -> String;\n@@ -54,7 +54,7 @@ impl ToHex for [u8] {\n }\n \n /// A trait for converting hexadecimal encoded values\n-pub trait FromHex for Sized? {\n+pub trait FromHex {\n     /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n     /// into an owned vector of bytes, returning the vector.\n     fn from_hex(&self) -> Result<Vec<u8>, FromHexError>;"}, {"sha": "8b0fb75b438fec3096545be149f17bb760aaa673", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -2302,7 +2302,7 @@ impl ::Decoder for Decoder {\n }\n \n /// A trait for converting values to JSON\n-pub trait ToJson for Sized? {\n+pub trait ToJson {\n     /// Converts the value of `self` to an instance of JSON\n     fn to_json(&self) -> Json;\n }"}, {"sha": "a157d9172749855309f8ab4143cd96957d1dfab8", "filename": "src/libserialize/json_stage0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fjson_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fjson_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson_stage0.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -2298,7 +2298,7 @@ impl ::Decoder<DecoderError> for Decoder {\n }\n \n /// A trait for converting values to JSON\n-pub trait ToJson for Sized? {\n+pub trait ToJson {\n     /// Converts the value of `self` to an instance of JSON\n     fn to_json(&self) -> Json;\n }"}, {"sha": "8fe15f00ded73e55f60285fd6720e192686b49fb", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -31,8 +31,14 @@ Core encoding and decoding interfaces.\n #[cfg(test)]\n extern crate test;\n \n+#[cfg(stage0)]\n #[phase(plugin, link)]\n extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n extern crate unicode;\n \n extern crate collections;"}, {"sha": "a04f67f765108e1a0a0aec7c9202fcdc5828696a", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -190,7 +190,7 @@ pub trait Decoder {\n     fn error(&mut self, err: &str) -> Self::Error;\n }\n \n-pub trait Encodable for Sized? {\n+pub trait Encodable {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error>;\n }\n \n@@ -396,13 +396,13 @@ impl Decodable for () {\n     }\n }\n \n-impl<'a, Sized? T: Encodable> Encodable for &'a T {\n+impl<'a, T: ?Sized + Encodable> Encodable for &'a T {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<Sized? T: Encodable> Encodable for Box<T> {\n+impl<T: ?Sized + Encodable> Encodable for Box<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }"}, {"sha": "fd37bb63230af40d1bc0332328d6f03cc2912845", "filename": "src/libserialize/serialize_stage0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fserialize_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibserialize%2Fserialize_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize_stage0.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -172,7 +172,7 @@ pub trait Decoder<E> {\n     fn error(&mut self, err: &str) -> E;\n }\n \n-pub trait Encodable<S:Encoder<E>, E> for Sized? {\n+pub trait Encodable<S:Encoder<E>, E> {\n     fn encode(&self, s: &mut S) -> Result<(), E>;\n }\n \n@@ -378,13 +378,13 @@ impl<E, D:Decoder<E>> Decodable<D, E> for () {\n     }\n }\n \n-impl<'a, E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for &'a T {\n+impl<'a, E, S: Encoder<E>, T: ?Sized + Encodable<S, E>> Encodable<S, E> for &'a T {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for Box<T> {\n+impl<E, S: Encoder<E>, T: ?Sized + Encodable<S, E>> Encodable<S, E> for Box<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }"}, {"sha": "671408acebf0d51174ab42e8af3478dda4495ebf", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -14,7 +14,6 @@\n \n #![unstable = \"unsure about placement and naming\"]\n \n-use core::kinds::Sized;\n use iter::IteratorExt;\n use ops::FnMut;\n use slice::SliceExt;\n@@ -38,7 +37,7 @@ pub trait OwnedAsciiExt {\n \n /// Extension methods for ASCII-subset only operations on string slices\n #[experimental = \"would prefer to do this in a more general way\"]\n-pub trait AsciiExt<T = Self> for Sized? {\n+pub trait AsciiExt<T = Self> {\n     /// Check if within the ASCII range.\n     fn is_ascii(&self) -> bool;\n \n@@ -53,7 +52,7 @@ pub trait AsciiExt<T = Self> for Sized? {\n     fn to_ascii_lowercase(&self) -> T;\n \n     /// Check that two strings are an ASCII case-insensitive match.\n-    /// Same as `to_ascii_lowercase(a) == to_ascii_lower(b)`,\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n     /// but without allocating and copying temporary strings.\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n }"}, {"sha": "ed3f2cbe1a1da3f5471e06bb12aa2d0de1f0309d", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![experimental]\n-#![macro_escape]\n \n //! A typesafe bitmask flag generator.\n "}, {"sha": "9c96a9cac78310d5c0d91a3253599b4ea08abd85", "filename": "src/libstd/c_str.rs", "status": "removed", "additions": 0, "deletions": 857, "changes": 857, "blob_url": "https://github.com/rust-lang/rust/blob/c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62", "patch": "@@ -1,857 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! C-string manipulation and management\n-//!\n-//! This modules provides the basic methods for creating and manipulating\n-//! null-terminated strings for use with FFI calls (back to C). Most C APIs require\n-//! that the string being passed to them is null-terminated, and by default rust's\n-//! string types are *not* null terminated.\n-//!\n-//! The other problem with translating Rust strings to C strings is that Rust\n-//! strings can validly contain a null-byte in the middle of the string (0 is a\n-//! valid Unicode codepoint). This means that not all Rust strings can actually be\n-//! translated to C strings.\n-//!\n-//! # Creation of a C string\n-//!\n-//! A C string is managed through the `CString` type defined in this module. It\n-//! \"owns\" the internal buffer of characters and will automatically deallocate the\n-//! buffer when the string is dropped. The `ToCStr` trait is implemented for `&str`\n-//! and `&[u8]`, but the conversions can fail due to some of the limitations\n-//! explained above.\n-//!\n-//! This also means that currently whenever a C string is created, an allocation\n-//! must be performed to place the data elsewhere (the lifetime of the C string is\n-//! not tied to the lifetime of the original string/data buffer). If C strings are\n-//! heavily used in applications, then caching may be advisable to prevent\n-//! unnecessary amounts of allocations.\n-//!\n-//! Be carefull to remember that the memory is managed by C allocator API and not\n-//! by Rust allocator API.\n-//! That means that the CString pointers should be freed with C allocator API\n-//! if you intend to do that on your own, as the behaviour if you free them with\n-//! Rust's allocator API is not well defined\n-//!\n-//! An example of creating and using a C string would be:\n-//!\n-//! ```rust\n-//! extern crate libc;\n-//!\n-//! use std::c_str::ToCStr;\n-//!\n-//! extern {\n-//!     fn puts(s: *const libc::c_char);\n-//! }\n-//!\n-//! fn main() {\n-//!     let my_string = \"Hello, world!\";\n-//!\n-//!     // Allocate the C string with an explicit local that owns the string. The\n-//!     // `c_buffer` pointer will be deallocated when `my_c_string` goes out of scope.\n-//!     let my_c_string = my_string.to_c_str();\n-//!     unsafe {\n-//!         puts(my_c_string.as_ptr());\n-//!     }\n-//!\n-//!     // Don't save/return the pointer to the C string, the `c_buffer` will be\n-//!     // deallocated when this block returns!\n-//!     my_string.with_c_str(|c_buffer| {\n-//!         unsafe { puts(c_buffer); }\n-//!     });\n-//! }\n-//! ```\n-\n-use core::prelude::*;\n-use libc;\n-\n-use cmp::Ordering;\n-use fmt;\n-use hash;\n-use mem;\n-use ptr;\n-use slice::{self, IntSliceExt};\n-use str;\n-use string::String;\n-use core::kinds::marker;\n-\n-/// The representation of a C String.\n-///\n-/// This structure wraps a `*libc::c_char`, and will automatically free the\n-/// memory it is pointing to when it goes out of scope.\n-#[allow(missing_copy_implementations)]\n-pub struct CString {\n-    buf: *const libc::c_char,\n-    owns_buffer_: bool,\n-}\n-\n-unsafe impl Send for CString { }\n-unsafe impl Sync for CString { }\n-\n-impl Clone for CString {\n-    /// Clone this CString into a new, uniquely owned CString. For safety\n-    /// reasons, this is always a deep clone with the memory allocated\n-    /// with C's allocator API, rather than the usual shallow clone.\n-    fn clone(&self) -> CString {\n-        let len = self.len() + 1;\n-        let buf = unsafe { libc::malloc(len as libc::size_t) } as *mut libc::c_char;\n-        if buf.is_null() { ::alloc::oom() }\n-        unsafe { ptr::copy_nonoverlapping_memory(buf, self.buf, len); }\n-        CString { buf: buf as *const libc::c_char, owns_buffer_: true }\n-    }\n-}\n-\n-impl PartialEq for CString {\n-    fn eq(&self, other: &CString) -> bool {\n-        // Check if the two strings share the same buffer\n-        if self.buf as uint == other.buf as uint {\n-            true\n-        } else {\n-            unsafe {\n-                libc::strcmp(self.buf, other.buf) == 0\n-            }\n-        }\n-    }\n-}\n-\n-impl PartialOrd for CString {\n-    #[inline]\n-    fn partial_cmp(&self, other: &CString) -> Option<Ordering> {\n-        self.as_bytes().partial_cmp(other.as_bytes())\n-    }\n-}\n-\n-impl Eq for CString {}\n-\n-impl<S: hash::Writer> hash::Hash<S> for CString {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_bytes().hash(state)\n-    }\n-}\n-\n-impl CString {\n-    /// Create a C String from a pointer, with memory managed by C's allocator\n-    /// API, so avoid calling it with a pointer to memory managed by Rust's\n-    /// allocator API, as the behaviour would not be well defined.\n-    ///\n-    ///# Panics\n-    ///\n-    /// Panics if `buf` is null\n-    pub unsafe fn new(buf: *const libc::c_char, owns_buffer: bool) -> CString {\n-        assert!(!buf.is_null());\n-        CString { buf: buf, owns_buffer_: owns_buffer }\n-    }\n-\n-    /// Return a pointer to the NUL-terminated string data.\n-    ///\n-    /// `.as_ptr` returns an internal pointer into the `CString`, and\n-    /// may be invalidated when the `CString` falls out of scope (the\n-    /// destructor will run, freeing the allocation if there is\n-    /// one).\n-    ///\n-    /// ```rust\n-    /// use std::c_str::ToCStr;\n-    ///\n-    /// let foo = \"some string\";\n-    ///\n-    /// // right\n-    /// let x = foo.to_c_str();\n-    /// let p = x.as_ptr();\n-    ///\n-    /// // wrong (the CString will be freed, invalidating `p`)\n-    /// let p = foo.to_c_str().as_ptr();\n-    /// ```\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// extern crate libc;\n-    ///\n-    /// use std::c_str::ToCStr;\n-    ///\n-    /// fn main() {\n-    ///     let c_str = \"foo bar\".to_c_str();\n-    ///     unsafe {\n-    ///         libc::puts(c_str.as_ptr());\n-    ///     }\n-    /// }\n-    /// ```\n-    pub fn as_ptr(&self) -> *const libc::c_char {\n-        self.buf\n-    }\n-\n-    /// Return a mutable pointer to the NUL-terminated string data.\n-    ///\n-    /// `.as_mut_ptr` returns an internal pointer into the `CString`, and\n-    /// may be invalidated when the `CString` falls out of scope (the\n-    /// destructor will run, freeing the allocation if there is\n-    /// one).\n-    ///\n-    /// ```rust\n-    /// use std::c_str::ToCStr;\n-    ///\n-    /// let foo = \"some string\";\n-    ///\n-    /// // right\n-    /// let mut x = foo.to_c_str();\n-    /// let p = x.as_mut_ptr();\n-    ///\n-    /// // wrong (the CString will be freed, invalidating `p`)\n-    /// let p = foo.to_c_str().as_mut_ptr();\n-    /// ```\n-    pub fn as_mut_ptr(&mut self) -> *mut libc::c_char {\n-        self.buf as *mut _\n-    }\n-\n-    /// Returns whether or not the `CString` owns the buffer.\n-    pub fn owns_buffer(&self) -> bool {\n-        self.owns_buffer_\n-    }\n-\n-    /// Converts the CString into a `&[u8]` without copying.\n-    /// Includes the terminating NUL byte.\n-    #[inline]\n-    pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n-        unsafe {\n-            slice::from_raw_buf(&self.buf, self.len() + 1).as_unsigned()\n-        }\n-    }\n-\n-    /// Converts the CString into a `&[u8]` without copying.\n-    /// Does not include the terminating NUL byte.\n-    #[inline]\n-    pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u8] {\n-        unsafe {\n-            slice::from_raw_buf(&self.buf, self.len()).as_unsigned()\n-        }\n-    }\n-\n-    /// Converts the CString into a `&str` without copying.\n-    /// Returns None if the CString is not UTF-8.\n-    #[inline]\n-    pub fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        let buf = self.as_bytes_no_nul();\n-        str::from_utf8(buf).ok()\n-    }\n-\n-    /// Return a CString iterator.\n-    pub fn iter<'a>(&'a self) -> CChars<'a> {\n-        CChars {\n-            ptr: self.buf,\n-            marker: marker::ContravariantLifetime,\n-        }\n-    }\n-\n-    /// Unwraps the wrapped `*libc::c_char` from the `CString` wrapper.\n-    ///\n-    /// Any ownership of the buffer by the `CString` wrapper is\n-    /// forgotten, meaning that the backing allocation of this\n-    /// `CString` is not automatically freed if it owns the\n-    /// allocation. In this case, a user of `.unwrap()` should ensure\n-    /// the allocation is freed, to avoid leaking memory. You should\n-    /// use libc's memory allocator in this case.\n-    ///\n-    /// Prefer `.as_ptr()` when just retrieving a pointer to the\n-    /// string data, as that does not relinquish ownership.\n-    pub unsafe fn into_inner(mut self) -> *const libc::c_char {\n-        self.owns_buffer_ = false;\n-        self.buf\n-    }\n-\n-    /// Return the number of bytes in the CString (not including the NUL\n-    /// terminator).\n-    #[inline]\n-    pub fn len(&self) -> uint {\n-        unsafe { libc::strlen(self.buf) as uint }\n-    }\n-\n-    /// Returns if there are no bytes in this string\n-    #[inline]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-impl Drop for CString {\n-    fn drop(&mut self) {\n-        if self.owns_buffer_ {\n-            unsafe {\n-                libc::free(self.buf as *mut libc::c_void)\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Show for CString {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        String::from_utf8_lossy(self.as_bytes_no_nul()).fmt(f)\n-    }\n-}\n-\n-/// A generic trait for converting a value to a CString.\n-pub trait ToCStr for Sized? {\n-    /// Copy the receiver into a CString.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the receiver has an interior null.\n-    fn to_c_str(&self) -> CString;\n-\n-    /// Unsafe variant of `to_c_str()` that doesn't check for nulls.\n-    unsafe fn to_c_str_unchecked(&self) -> CString;\n-\n-    /// Work with a temporary CString constructed from the receiver.\n-    /// The provided `*libc::c_char` will be freed immediately upon return.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// extern crate libc;\n-    ///\n-    /// use std::c_str::ToCStr;\n-    ///\n-    /// fn main() {\n-    ///     let s = \"PATH\".with_c_str(|path| unsafe {\n-    ///         libc::getenv(path)\n-    ///     });\n-    /// }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the receiver has an interior null.\n-    #[inline]\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        let c_str = self.to_c_str();\n-        f(c_str.as_ptr())\n-    }\n-\n-    /// Unsafe variant of `with_c_str()` that doesn't check for nulls.\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        let c_str = self.to_c_str_unchecked();\n-        f(c_str.as_ptr())\n-    }\n-}\n-\n-impl ToCStr for str {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        self.as_bytes().to_c_str()\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_bytes().to_c_str_unchecked()\n-    }\n-\n-    #[inline]\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        self.as_bytes().with_c_str(f)\n-    }\n-\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        self.as_bytes().with_c_str_unchecked(f)\n-    }\n-}\n-\n-impl ToCStr for String {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        self.as_bytes().to_c_str()\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_bytes().to_c_str_unchecked()\n-    }\n-\n-    #[inline]\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        self.as_bytes().with_c_str(f)\n-    }\n-\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        self.as_bytes().with_c_str_unchecked(f)\n-    }\n-}\n-\n-// The length of the stack allocated buffer for `vec.with_c_str()`\n-const BUF_LEN: uint = 128;\n-\n-impl ToCStr for [u8] {\n-    fn to_c_str(&self) -> CString {\n-        let mut cs = unsafe { self.to_c_str_unchecked() };\n-        check_for_null(self, cs.as_mut_ptr());\n-        cs\n-    }\n-\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        let self_len = self.len();\n-        let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n-        if buf.is_null() { ::alloc::oom() }\n-\n-        ptr::copy_memory(buf, self.as_ptr(), self_len);\n-        *buf.offset(self_len as int) = 0;\n-\n-        CString::new(buf as *const libc::c_char, true)\n-    }\n-\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        unsafe { with_c_str(self, true, f) }\n-    }\n-\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        with_c_str(self, false, f)\n-    }\n-}\n-\n-impl<'a, Sized? T: ToCStr> ToCStr for &'a T {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        (**self).to_c_str()\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        (**self).to_c_str_unchecked()\n-    }\n-\n-    #[inline]\n-    fn with_c_str<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        (**self).with_c_str(f)\n-    }\n-\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n-        F: FnOnce(*const libc::c_char) -> T,\n-    {\n-        (**self).with_c_str_unchecked(f)\n-    }\n-}\n-\n-// Unsafe function that handles possibly copying the &[u8] into a stack array.\n-unsafe fn with_c_str<T, F>(v: &[u8], checked: bool, f: F) -> T where\n-    F: FnOnce(*const libc::c_char) -> T,\n-{\n-    let c_str = if v.len() < BUF_LEN {\n-        let mut buf: [u8; BUF_LEN] = mem::uninitialized();\n-        slice::bytes::copy_memory(&mut buf, v);\n-        buf[v.len()] = 0;\n-\n-        let buf = buf.as_mut_ptr();\n-        if checked {\n-            check_for_null(v, buf as *mut libc::c_char);\n-        }\n-\n-        return f(buf as *const libc::c_char)\n-    } else if checked {\n-        v.to_c_str()\n-    } else {\n-        v.to_c_str_unchecked()\n-    };\n-\n-    f(c_str.as_ptr())\n-}\n-\n-#[inline]\n-fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n-    for i in range(0, v.len()) {\n-        unsafe {\n-            let p = buf.offset(i as int);\n-            assert!(*p != 0);\n-        }\n-    }\n-}\n-\n-/// External iterator for a CString's bytes.\n-///\n-/// Use with the `std::iter` module.\n-#[allow(raw_pointer_deriving)]\n-#[derive(Clone)]\n-pub struct CChars<'a> {\n-    ptr: *const libc::c_char,\n-    marker: marker::ContravariantLifetime<'a>,\n-}\n-\n-impl<'a> Iterator for CChars<'a> {\n-    type Item = libc::c_char;\n-\n-    fn next(&mut self) -> Option<libc::c_char> {\n-        let ch = unsafe { *self.ptr };\n-        if ch == 0 {\n-            None\n-        } else {\n-            self.ptr = unsafe { self.ptr.offset(1) };\n-            Some(ch)\n-        }\n-    }\n-}\n-\n-/// Parses a C \"multistring\", eg windows env values or\n-/// the req->ptr result in a uv_fs_readdir() call.\n-///\n-/// Optionally, a `count` can be passed in, limiting the\n-/// parsing to only being done `count`-times.\n-///\n-/// The specified closure is invoked with each string that\n-/// is found, and the number of strings found is returned.\n-pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n-                                    count: Option<uint>,\n-                                    mut f: F)\n-                                    -> uint where\n-    F: FnMut(&CString),\n-{\n-\n-    let mut curr_ptr: uint = buf as uint;\n-    let mut ctr = 0;\n-    let (limited_count, limit) = match count {\n-        Some(limit) => (true, limit),\n-        None => (false, 0)\n-    };\n-    while ((limited_count && ctr < limit) || !limited_count)\n-          && *(curr_ptr as *const libc::c_char) != 0 as libc::c_char {\n-        let cstr = CString::new(curr_ptr as *const libc::c_char, false);\n-        f(&cstr);\n-        curr_ptr += cstr.len() + 1;\n-        ctr += 1;\n-    }\n-    return ctr;\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-    use super::*;\n-    use ptr;\n-    use thread::Thread;\n-    use libc;\n-\n-    #[test]\n-    fn test_str_multistring_parsing() {\n-        unsafe {\n-            let input = b\"zero\\0one\\0\\0\";\n-            let ptr = input.as_ptr();\n-            let expected = [\"zero\", \"one\"];\n-            let mut it = expected.iter();\n-            let result = from_c_multistring(ptr as *const libc::c_char, None, |c| {\n-                let cbytes = c.as_bytes_no_nul();\n-                assert_eq!(cbytes, it.next().unwrap().as_bytes());\n-            });\n-            assert_eq!(result, 2);\n-            assert!(it.next().is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_str_to_c_str() {\n-        let c_str = \"\".to_c_str();\n-        unsafe {\n-            assert_eq!(*c_str.as_ptr().offset(0), 0);\n-        }\n-\n-        let c_str = \"hello\".to_c_str();\n-        let buf = c_str.as_ptr();\n-        unsafe {\n-            assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-            assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-            assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(5), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_vec_to_c_str() {\n-        let b: &[u8] = &[];\n-        let c_str = b.to_c_str();\n-        unsafe {\n-            assert_eq!(*c_str.as_ptr().offset(0), 0);\n-        }\n-\n-        let c_str = b\"hello\".to_c_str();\n-        let buf = c_str.as_ptr();\n-        unsafe {\n-            assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-            assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-            assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(5), 0);\n-        }\n-\n-        let c_str = b\"foo\\xFF\".to_c_str();\n-        let buf = c_str.as_ptr();\n-        unsafe {\n-            assert_eq!(*buf.offset(0), 'f' as libc::c_char);\n-            assert_eq!(*buf.offset(1), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(2), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(3), 0xffu8 as libc::c_char);\n-            assert_eq!(*buf.offset(4), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unwrap() {\n-        let c_str = \"hello\".to_c_str();\n-        unsafe { libc::free(c_str.into_inner() as *mut libc::c_void) }\n-    }\n-\n-    #[test]\n-    fn test_as_ptr() {\n-        let c_str = \"hello\".to_c_str();\n-        let len = unsafe { libc::strlen(c_str.as_ptr()) };\n-        assert_eq!(len, 5);\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let c_str = \"\".to_c_str();\n-        let mut iter = c_str.iter();\n-        assert_eq!(iter.next(), None);\n-\n-        let c_str = \"hello\".to_c_str();\n-        let mut iter = c_str.iter();\n-        assert_eq!(iter.next(), Some('h' as libc::c_char));\n-        assert_eq!(iter.next(), Some('e' as libc::c_char));\n-        assert_eq!(iter.next(), Some('l' as libc::c_char));\n-        assert_eq!(iter.next(), Some('l' as libc::c_char));\n-        assert_eq!(iter.next(), Some('o' as libc::c_char));\n-        assert_eq!(iter.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_to_c_str_fail() {\n-        assert!(Thread::spawn(move|| { \"he\\x00llo\".to_c_str() }).join().is_err());\n-    }\n-\n-    #[test]\n-    fn test_to_c_str_unchecked() {\n-        unsafe {\n-            let c_string = \"he\\x00llo\".to_c_str_unchecked();\n-            let buf = c_string.as_ptr();\n-            assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-            assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-            assert_eq!(*buf.offset(2), 0);\n-            assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n-            assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n-            assert_eq!(*buf.offset(6), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_as_bytes() {\n-        let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), b\"hello\\0\");\n-        let c_str = \"\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), b\"\\0\");\n-        let c_str = b\"foo\\xFF\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), b\"foo\\xFF\\0\");\n-    }\n-\n-    #[test]\n-    fn test_as_bytes_no_nul() {\n-        let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_bytes_no_nul(), b\"hello\");\n-        let c_str = \"\".to_c_str();\n-        let exp: &[u8] = &[];\n-        assert_eq!(c_str.as_bytes_no_nul(), exp);\n-        let c_str = b\"foo\\xFF\".to_c_str();\n-        assert_eq!(c_str.as_bytes_no_nul(), b\"foo\\xFF\");\n-    }\n-\n-    #[test]\n-    fn test_as_str() {\n-        let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_str(), Some(\"hello\"));\n-        let c_str = \"\".to_c_str();\n-        assert_eq!(c_str.as_str(), Some(\"\"));\n-        let c_str = b\"foo\\xFF\".to_c_str();\n-        assert_eq!(c_str.as_str(), None);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_new_fail() {\n-        let _c_str = unsafe { CString::new(ptr::null(), false) };\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let a = \"hello\".to_c_str();\n-        let b = a.clone();\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_clone_noleak() {\n-        fn foo<F>(f: F) where F: FnOnce(&CString) {\n-            let s = \"test\".to_string();\n-            let c = s.to_c_str();\n-            // give the closure a non-owned CString\n-            let mut c_ = unsafe { CString::new(c.as_ptr(), false) };\n-            f(&c_);\n-            // muck with the buffer for later printing\n-            unsafe { *c_.as_mut_ptr() = 'X' as libc::c_char }\n-        }\n-\n-        let mut c_: Option<CString> = None;\n-        foo(|c| {\n-            c_ = Some(c.clone());\n-            c.clone();\n-            // force a copy, reading the memory\n-            c.as_bytes().to_vec();\n-        });\n-        let c_ = c_.unwrap();\n-        // force a copy, reading the memory\n-        c_.as_bytes().to_vec();\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    use prelude::v1::*;\n-    use self::test::Bencher;\n-    use libc;\n-    use c_str::ToCStr;\n-\n-    #[inline]\n-    fn check(s: &str, c_str: *const libc::c_char) {\n-        let s_buf = s.as_ptr();\n-        for i in range(0, s.len()) {\n-            unsafe {\n-                assert_eq!(\n-                    *s_buf.offset(i as int) as libc::c_char,\n-                    *c_str.offset(i as int));\n-            }\n-        }\n-    }\n-\n-    static S_SHORT: &'static str = \"Mary\";\n-    static S_MEDIUM: &'static str = \"Mary had a little lamb\";\n-    static S_LONG: &'static str = \"\\\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\";\n-\n-    fn bench_to_string(b: &mut Bencher, s: &str) {\n-        b.iter(|| {\n-            let c_str = s.to_c_str();\n-            check(s, c_str.as_ptr());\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_short(b: &mut Bencher) {\n-        bench_to_string(b, S_SHORT)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_medium(b: &mut Bencher) {\n-        bench_to_string(b, S_MEDIUM)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_long(b: &mut Bencher) {\n-        bench_to_string(b, S_LONG)\n-    }\n-\n-    fn bench_to_c_str_unchecked(b: &mut Bencher, s: &str) {\n-        b.iter(|| {\n-            let c_str = unsafe { s.to_c_str_unchecked() };\n-            check(s, c_str.as_ptr())\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_unchecked_short(b: &mut Bencher) {\n-        bench_to_c_str_unchecked(b, S_SHORT)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_unchecked_medium(b: &mut Bencher) {\n-        bench_to_c_str_unchecked(b, S_MEDIUM)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_unchecked_long(b: &mut Bencher) {\n-        bench_to_c_str_unchecked(b, S_LONG)\n-    }\n-\n-    fn bench_with_c_str(b: &mut Bencher, s: &str) {\n-        b.iter(|| {\n-            s.with_c_str(|c_str_buf| check(s, c_str_buf))\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_short(b: &mut Bencher) {\n-        bench_with_c_str(b, S_SHORT)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_medium(b: &mut Bencher) {\n-        bench_with_c_str(b, S_MEDIUM)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_long(b: &mut Bencher) {\n-        bench_with_c_str(b, S_LONG)\n-    }\n-\n-    fn bench_with_c_str_unchecked(b: &mut Bencher, s: &str) {\n-        b.iter(|| {\n-            unsafe {\n-                s.with_c_str_unchecked(|c_str_buf| check(s, c_str_buf))\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_unchecked_short(b: &mut Bencher) {\n-        bench_with_c_str_unchecked(b, S_SHORT)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_unchecked_medium(b: &mut Bencher) {\n-        bench_with_c_str_unchecked(b, S_MEDIUM)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_unchecked_long(b: &mut Bencher) {\n-        bench_with_c_str_unchecked(b, S_LONG)\n-    }\n-}"}, {"sha": "4a20208f31a6ae49ad7c7a80f71eb62bcfc293c4", "filename": "src/libstd/c_vec.rs", "status": "removed", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62", "patch": "@@ -1,232 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Library to interface with chunks of memory allocated in C.\n-//!\n-//! It is often desirable to safely interface with memory allocated from C,\n-//! encapsulating the unsafety into allocation and destruction time.  Indeed,\n-//! allocating memory externally is currently the only way to give Rust shared\n-//! mut state with C programs that keep their own references; vectors are\n-//! unsuitable because they could be reallocated or moved at any time, and\n-//! importing C memory into a vector takes a one-time snapshot of the memory.\n-//!\n-//! This module simplifies the usage of such external blocks of memory.  Memory\n-//! is encapsulated into an opaque object after creation; the lifecycle of the\n-//! memory can be optionally managed by Rust, if an appropriate destructor\n-//! closure is provided.  Safety is ensured by bounds-checking accesses, which\n-//! are marshalled through get and set functions.\n-//!\n-//! There are three unsafe functions: the two constructors, and the\n-//! unwrap method. The constructors are unsafe for the\n-//! obvious reason (they act on a pointer that cannot be checked inside the\n-//! method), but `unwrap()` is somewhat more subtle in its unsafety.\n-//! It returns the contained pointer, but at the same time destroys the CVec\n-//! without running its destructor. This can be used to pass memory back to\n-//! C, but care must be taken that the ownership of underlying resources are\n-//! handled correctly, i.e. that allocated memory is eventually freed\n-//! if necessary.\n-\n-#![experimental]\n-\n-use kinds::Send;\n-use mem;\n-use ops::{Drop, FnOnce};\n-use option::Option;\n-use option::Option::{Some, None};\n-use ptr::PtrExt;\n-use ptr;\n-use raw;\n-use slice::AsSlice;\n-use thunk::{Thunk};\n-\n-/// The type representing a foreign chunk of memory\n-pub struct CVec<T> {\n-    base: *mut T,\n-    len: uint,\n-    dtor: Option<Thunk>,\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for CVec<T> {\n-    fn drop(&mut self) {\n-        match self.dtor.take() {\n-            None => (),\n-            Some(f) => f.invoke(())\n-        }\n-    }\n-}\n-\n-impl<T> CVec<T> {\n-    /// Create a `CVec` from a raw pointer to a buffer with a given length.\n-    ///\n-    /// Panics if the given pointer is null. The returned vector will not attempt\n-    /// to deallocate the vector when dropped.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * base - A raw pointer to a buffer\n-    /// * len - The number of elements in the buffer\n-    pub unsafe fn new(base: *mut T, len: uint) -> CVec<T> {\n-        assert!(base != ptr::null_mut());\n-        CVec {\n-            base: base,\n-            len: len,\n-            dtor: None,\n-        }\n-    }\n-\n-    /// Create a `CVec` from a foreign buffer, with a given length,\n-    /// and a function to run upon destruction.\n-    ///\n-    /// Panics if the given pointer is null.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * base - A foreign pointer to a buffer\n-    /// * len - The number of elements in the buffer\n-    /// * dtor - A fn to run when the value is destructed, useful\n-    ///          for freeing the buffer, etc.\n-    pub unsafe fn new_with_dtor<F>(base: *mut T,\n-                                   len: uint,\n-                                   dtor: F)\n-                                   -> CVec<T>\n-        where F : FnOnce(), F : Send\n-    {\n-        assert!(base != ptr::null_mut());\n-        let dtor: Thunk = Thunk::new(dtor);\n-        CVec {\n-            base: base,\n-            len: len,\n-            dtor: Some(dtor)\n-        }\n-    }\n-\n-    /// View the stored data as a mutable slice.\n-    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        unsafe {\n-            mem::transmute(raw::Slice { data: self.base as *const T, len: self.len })\n-        }\n-    }\n-\n-    /// Retrieves an element at a given index, returning `None` if the requested\n-    /// index is greater than the length of the vector.\n-    pub fn get<'a>(&'a self, ofs: uint) -> Option<&'a T> {\n-        if ofs < self.len {\n-            Some(unsafe { &*self.base.offset(ofs as int) })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Retrieves a mutable element at a given index, returning `None` if the\n-    /// requested index is greater than the length of the vector.\n-    pub fn get_mut<'a>(&'a mut self, ofs: uint) -> Option<&'a mut T> {\n-        if ofs < self.len {\n-            Some(unsafe { &mut *self.base.offset(ofs as int) })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Unwrap the pointer without running the destructor\n-    ///\n-    /// This method retrieves the underlying pointer, and in the process\n-    /// destroys the CVec but without running the destructor. A use case\n-    /// would be transferring ownership of the buffer to a C function, as\n-    /// in this case you would not want to run the destructor.\n-    ///\n-    /// Note that if you want to access the underlying pointer without\n-    /// cancelling the destructor, you can simply call `transmute` on the return\n-    /// value of `get(0)`.\n-    pub unsafe fn into_inner(mut self) -> *mut T {\n-        self.dtor = None;\n-        self.base\n-    }\n-\n-    /// Returns the number of items in this vector.\n-    pub fn len(&self) -> uint { self.len }\n-\n-    /// Returns whether this vector is empty.\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-impl<T> AsSlice<T> for CVec<T> {\n-    /// View the stored data as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        unsafe {\n-            mem::transmute(raw::Slice { data: self.base as *const T, len: self.len })\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-\n-    use super::CVec;\n-    use libc;\n-    use ptr;\n-\n-    fn malloc(n: uint) -> CVec<u8> {\n-        unsafe {\n-            let mem = ptr::Unique(libc::malloc(n as libc::size_t));\n-            if mem.0.is_null() { ::alloc::oom() }\n-\n-            CVec::new_with_dtor(mem.0 as *mut u8,\n-                                n,\n-                                move|| { libc::free(mem.0 as *mut libc::c_void); })\n-        }\n-    }\n-\n-    #[test]\n-    fn test_basic() {\n-        let mut cv = malloc(16);\n-\n-        *cv.get_mut(3).unwrap() = 8;\n-        *cv.get_mut(4).unwrap() = 9;\n-        assert_eq!(*cv.get(3).unwrap(), 8);\n-        assert_eq!(*cv.get(4).unwrap(), 9);\n-        assert_eq!(cv.len(), 16);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_panic_at_null() {\n-        unsafe {\n-            CVec::new(ptr::null_mut::<u8>(), 9);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_overrun_get() {\n-        let cv = malloc(16);\n-\n-        assert!(cv.get(17).is_none());\n-    }\n-\n-    #[test]\n-    fn test_overrun_set() {\n-        let mut cv = malloc(16);\n-\n-        assert!(cv.get_mut(17).is_none());\n-    }\n-\n-    #[test]\n-    fn test_unwrap() {\n-        unsafe {\n-            let cv = CVec::new_with_dtor(1 as *mut int,\n-                                         0,\n-                                         move|:| panic!(\"Don't run this destructor!\"));\n-            let p = cv.into_inner();\n-            assert_eq!(p, 1 as *mut int);\n-        }\n-    }\n-\n-}"}, {"sha": "a3fc38c34e84fb70deb3f094cfdf0f745b32e29c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -440,22 +440,22 @@ impl<K, V, M> SearchResult<K, V, M> {\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n-    fn make_hash<Sized? X: Hash<S>>(&self, x: &X) -> SafeHash {\n+    fn make_hash<X: ?Sized + Hash<S>>(&self, x: &X) -> SafeHash {\n         table::make_hash(&self.hasher, x)\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n-    fn search<'a, Sized? Q>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n-    fn search_mut<'a, Sized? Q>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n@@ -923,7 +923,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[stable]\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     /// Regardless of whether or not `to_owned()` has been called, the key must hash the same way.\n-    pub fn entry<'a, Sized? Q>(&'a mut self, key: &'a Q) -> Entry<'a, Q, K, V>\n+    pub fn entry<'a, Q: ?Sized>(&'a mut self, key: &'a Q) -> Entry<'a, Q, K, V>\n         where Q: Eq + Hash<S> + ToOwned<K>\n     {\n         // Gotta resize now.\n@@ -1030,7 +1030,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable]\n-    pub fn get<Sized? Q>(&self, k: &Q) -> Option<&V>\n+    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         self.search(k).map(|bucket| bucket.into_refs().1)\n@@ -1053,7 +1053,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable]\n-    pub fn contains_key<Sized? Q>(&self, k: &Q) -> bool\n+    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         self.search(k).is_some()\n@@ -1079,7 +1079,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[stable]\n-    pub fn get_mut<Sized? Q>(&mut self, k: &Q) -> Option<&mut V>\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n@@ -1131,7 +1131,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, k: &Q) -> Option<V>\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         if self.table.size() == 0 {\n@@ -1142,7 +1142,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-fn search_entry_hashed<'a, K, V, Sized? Q>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: &'a Q)\n+fn search_entry_hashed<'a, K, V, Q: ?Sized>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: &'a Q)\n         -> Entry<'a, Q, K, V>\n     where Q: Eq + ToOwned<K>\n {\n@@ -1227,7 +1227,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n }\n \n #[stable]\n-impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H>\n+impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n     type Output = V;\n@@ -1239,7 +1239,7 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H\n }\n \n #[stable]\n-impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q> for HashMap<K, V, H>\n+impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> IndexMut<Q> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n     type Output = V;\n@@ -1331,15 +1331,15 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n \n #[stable]\n /// A view into a single empty location in a HashMap\n-pub struct VacantEntry<'a, Sized? Q: 'a, K: 'a, V: 'a> {\n+pub struct VacantEntry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: &'a Q,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n #[stable]\n /// A view into a single location in a map, which may be vacant or occupied\n-pub enum Entry<'a, Sized? Q: 'a, K: 'a, V: 'a> {\n+pub enum Entry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n     /// A vacant Entry\n@@ -1409,7 +1409,7 @@ impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> {\n     }\n }\n \n-impl<'a, Sized? Q, K, V> Entry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized, K, V> Entry<'a, Q, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n@@ -1455,7 +1455,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     }\n }\n \n-impl<'a, Sized? Q: 'a + ToOwned<K>, K: 'a, V: 'a> VacantEntry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized + 'a + ToOwned<K>, K: 'a, V: 'a> VacantEntry<'a, Q, K, V> {\n     #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n@@ -1482,7 +1482,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for Has\n }\n \n #[stable]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Extend<(K, V)> for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Extend<(K, V)> for HashMap<K, V, H> {\n     fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);"}, {"sha": "211bfe2c10e8fede558452f3c9a12918bd60054c", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -18,10 +18,12 @@ use default::Default;\n use fmt::Show;\n use fmt;\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{Iterator, IteratorExt, IteratorCloneExt, FromIterator, Map, Chain, Extend};\n+use iter::{Iterator, IteratorExt, FromIterator, Map, Chain, Extend};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n-use result::Result::{Ok, Err};\n+\n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::{Ok, Err};\n \n use super::map::{self, HashMap, Keys, INITIAL_CAPACITY};\n \n@@ -451,7 +453,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable]\n-    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<S> + Eq\n     {\n         self.map.contains_key(value)\n@@ -561,7 +563,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<S> + Eq\n     {\n         self.map.remove(value).is_some()\n@@ -605,7 +607,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T,\n }\n \n #[stable]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extend<T> for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Extend<T> for HashSet<T, H> {\n     fn extend<I: Iterator<Item=T>>(&mut self, mut iter: I) {\n         for k in iter {\n             self.insert(k);"}, {"sha": "1eb4408eedc403d4d4fb0e273e9bd9d52ad88eeb", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -138,7 +138,7 @@ impl SafeHash {\n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n-pub fn make_hash<Sized? T: Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n+pub fn make_hash<T: ?Sized + Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n     // We need to avoid 0u64 in order to prevent collisions with\n     // EMPTY_HASH. We can maintain our precious uniform distribution\n     // of initial indexes by unconditionally setting the MSB,"}, {"sha": "ef9d28bbbb2e863bd993080831155ff454335613", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -309,7 +309,7 @@\n //! }\n //! ```\n \n-#![experimental]\n+#![stable]\n \n pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n pub use core_collections::{DList, RingBuf, VecMap};\n@@ -322,11 +322,13 @@ pub use self::hash_set::HashSet;\n \n mod hash;\n \n+#[stable]\n pub mod hash_map {\n     //! A hashmap\n     pub use super::hash::map::*;\n }\n \n+#[stable]\n pub mod hash_set {\n     //! A hashset\n     pub use super::hash::set::*;"}, {"sha": "2d013a8a5b830325c083a49e35c3ccfa0d1fd342", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -17,7 +17,7 @@\n \n use prelude::v1::*;\n \n-use c_str::ToCStr;\n+use ffi::CString;\n use mem;\n use os;\n use str;\n@@ -51,13 +51,11 @@ impl DynamicLibrary {\n \n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n-    pub fn open<T: ToCStr>(filename: Option<T>)\n-                        -> Result<DynamicLibrary, String> {\n+    pub fn open(filename: Option<&Path>) -> Result<DynamicLibrary, String> {\n         unsafe {\n-            let mut filename = filename;\n             let maybe_library = dl::check_for_errors_in(|| {\n-                match filename.take() {\n-                    Some(name) => dl::open_external(name),\n+                match filename {\n+                    Some(name) => dl::open_external(name.as_vec()),\n                     None => dl::open_internal()\n                 }\n             });\n@@ -130,10 +128,9 @@ impl DynamicLibrary {\n         // This function should have a lifetime constraint of 'a on\n         // T but that feature is still unimplemented\n \n+        let raw_string = CString::from_slice(symbol.as_bytes());\n         let maybe_symbol_value = dl::check_for_errors_in(|| {\n-            symbol.with_c_str(|raw_string| {\n-                dl::symbol(self.handle, raw_string)\n-            })\n+            dl::symbol(self.handle, raw_string.as_ptr())\n         });\n \n         // The value must not be constructed if there is an error so\n@@ -157,7 +154,7 @@ mod test {\n     fn test_loading_cosine() {\n         // The math library does not need to be loaded since it is already\n         // statically linked in\n-        let none: Option<Path> = None; // appease the typechecker\n+        let none: Option<&Path> = None; // appease the typechecker\n         let libm = match DynamicLibrary::open(none) {\n             Err(error) => panic!(\"Could not load self as module: {}\", error),\n             Ok(libm) => libm\n@@ -202,17 +199,17 @@ mod test {\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n pub mod dl {\n-    use self::Rtld::*;\n-\n+    pub use self::Rtld::*;\n     use prelude::v1::*;\n-    use c_str::{CString, ToCStr};\n+\n+    use ffi::{self, CString};\n+    use str;\n     use libc;\n     use ptr;\n \n-    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *mut u8 {\n-        filename.with_c_str(|raw_name| {\n-            dlopen(raw_name, Lazy as libc::c_int) as *mut u8\n-        })\n+    pub unsafe fn open_external(filename: &[u8]) -> *mut u8 {\n+        let s = CString::from_slice(filename);\n+        dlopen(s.as_ptr(), Lazy as libc::c_int) as *mut u8\n     }\n \n     pub unsafe fn open_internal() -> *mut u8 {\n@@ -236,8 +233,8 @@ pub mod dl {\n             let ret = if ptr::null() == last_error {\n                 Ok(result)\n             } else {\n-                Err(String::from_str(CString::new(last_error, false).as_str()\n-                    .unwrap()))\n+                let s = ffi::c_str_to_bytes(&last_error);\n+                Err(str::from_utf8(s).unwrap().to_string())\n             };\n \n             ret\n@@ -273,7 +270,6 @@ pub mod dl {\n \n #[cfg(target_os = \"windows\")]\n pub mod dl {\n-    use c_str::ToCStr;\n     use iter::IteratorExt;\n     use libc;\n     use ops::FnOnce;\n@@ -287,10 +283,9 @@ pub mod dl {\n     use string::String;\n     use vec::Vec;\n \n-    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *mut u8 {\n+    pub unsafe fn open_external(filename: &[u8]) -> *mut u8 {\n         // Windows expects Unicode data\n-        let filename_cstr = filename.to_c_str();\n-        let filename_str = str::from_utf8(filename_cstr.as_bytes_no_nul()).unwrap();\n+        let filename_str = str::from_utf8(filename).unwrap();\n         let mut filename_str: Vec<u16> = filename_str.utf16_units().collect();\n         filename_str.push(0);\n         LoadLibraryW(filename_str.as_ptr() as *const libc::c_void) as *mut u8"}, {"sha": "bef2344d9e8bc4e8cae962a3c0c3e0bf821cc772", "filename": "src/libstd/ffi/c_str.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+use iter::IteratorExt;\n+use libc;\n+use mem;\n+use ops::Deref;\n+use slice::{self, SliceExt, AsSlice};\n+use string::String;\n+use vec::Vec;\n+\n+/// A type representing a C-compatible string\n+///\n+/// This type serves the primary purpose of being able to generate a\n+/// C-compatible string from a Rust byte slice or vector. An instance of this\n+/// type is a static guarantee that the underlying bytes contain no interior 0\n+/// bytes and the final byte is 0.\n+///\n+/// A `CString` is created from either a byte slice or a byte vector. After\n+/// being created, a `CString` predominately inherits all of its methods from\n+/// the `Deref` implementation to `[libc::c_char]`. Note that the underlying\n+/// array is represented as an array of `libc::c_char` as opposed to `u8`. A\n+/// `u8` slice can be obtained with the `as_bytes` method.  Slices produced from\n+/// a `CString` do *not* contain the trailing nul terminator unless otherwise\n+/// specified.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// # extern crate libc;\n+/// # fn main() {\n+/// use std::ffi::CString;\n+/// use libc;\n+///\n+/// extern {\n+///     fn my_printer(s: *const libc::c_char);\n+/// }\n+///\n+/// let to_print = \"Hello, world!\";\n+/// let c_to_print = CString::from_slice(to_print.as_bytes());\n+/// unsafe {\n+///     my_printer(c_to_print.as_ptr());\n+/// }\n+/// # }\n+/// ```\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]\n+pub struct CString {\n+    inner: Vec<libc::c_char>,\n+}\n+\n+impl CString {\n+    /// Create a new C-compatible string from a byte slice.\n+    ///\n+    /// This method will copy the data of the slice provided into a new\n+    /// allocation, ensuring that there is a trailing 0 byte.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if there are any 0 bytes already in the slice\n+    /// provided.\n+    pub fn from_slice(v: &[u8]) -> CString {\n+        CString::from_vec(v.to_vec())\n+    }\n+\n+    /// Create a C-compatible string from a byte vector.\n+    ///\n+    /// This method will consume ownership of the provided vector, appending a 0\n+    /// byte to the end after verifying that there are no interior 0 bytes.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if there are any 0 bytes already in the vector\n+    /// provided.\n+    pub fn from_vec(v: Vec<u8>) -> CString {\n+        assert!(!v.iter().any(|&x| x == 0));\n+        unsafe { CString::from_vec_unchecked(v) }\n+    }\n+\n+    /// Create a C-compatibel string from a byte vector without checking for\n+    /// interior 0 bytes.\n+    ///\n+    /// This method is equivalent to `from_vec` except that no runtime assertion\n+    /// is made that `v` contains no 0 bytes.\n+    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n+        v.push(0);\n+        CString { inner: mem::transmute(v) }\n+    }\n+\n+    /// Create a view into this C string which includes the trailing nul\n+    /// terminator at the end of the string.\n+    pub fn as_slice_with_nul(&self) -> &[libc::c_char] { self.inner.as_slice() }\n+\n+    /// Similar to the `as_slice` method, but returns a `u8` slice instead of a\n+    /// `libc::c_char` slice.\n+    pub fn as_bytes(&self) -> &[u8] {\n+        unsafe { mem::transmute(self.as_slice()) }\n+    }\n+\n+    /// Equivalend to `as_slice_with_nul` except that the type returned is a\n+    /// `u8` slice instead of a `libc::c_char` slice.\n+    pub fn as_bytes_with_nul(&self) -> &[u8] {\n+        unsafe { mem::transmute(self.as_slice_with_nul()) }\n+    }\n+}\n+\n+impl Deref for CString {\n+    type Target = [libc::c_char];\n+\n+    fn deref(&self) -> &[libc::c_char] {\n+        self.inner.slice_to(self.inner.len() - 1)\n+    }\n+}\n+\n+impl fmt::Show for CString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        String::from_utf8_lossy(self.as_bytes()).fmt(f)\n+    }\n+}\n+\n+/// Interpret a C string as a byte slice.\n+///\n+/// This function will calculate the length of the C string provided, and it\n+/// will then return a corresponding slice for the contents of the C string not\n+/// including the nul terminator.\n+///\n+/// This function will tie the lifetime of the returned slice to the lifetime of\n+/// the pointer provided. This is done to help prevent the slice from escaping\n+/// the lifetime of the pointer itself. If a longer lifetime is needed, then\n+/// `mem::copy_lifetime` should be used.\n+///\n+/// This function is unsafe because there is no guarantee of the validity of the\n+/// pointer `raw` or a guarantee that a nul terminator will be found.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// # extern crate libc;\n+/// # fn main() {\n+/// use std::ffi;\n+/// use std::str;\n+/// use libc;\n+///\n+/// extern {\n+///     fn my_string() -> *const libc::c_char;\n+/// }\n+///\n+/// unsafe {\n+///     let to_print = my_string();\n+///     let slice = ffi::c_str_to_bytes(&to_print);\n+///     println!(\"string returned: {}\", str::from_utf8(slice).unwrap());\n+/// }\n+/// # }\n+/// ```\n+pub unsafe fn c_str_to_bytes<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n+    let len = libc::strlen(*raw);\n+    slice::from_raw_buf(&*(raw as *const _ as *const *const u8), len as uint)\n+}\n+\n+/// Interpret a C string as a byte slice with the nul terminator.\n+///\n+/// This function is identical to `from_raw_buf` except that the returned slice\n+/// will include the nul terminator of the string.\n+pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n+    let len = libc::strlen(*raw) + 1;\n+    slice::from_raw_buf(&*(raw as *const _ as *const *const u8), len as uint)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use super::*;\n+    use libc;\n+    use mem;\n+\n+    #[test]\n+    fn c_to_rust() {\n+        let data = b\"123\\0\";\n+        let ptr = data.as_ptr() as *const libc::c_char;\n+        unsafe {\n+            assert_eq!(c_str_to_bytes(&ptr), b\"123\");\n+            assert_eq!(c_str_to_bytes_with_nul(&ptr), b\"123\\0\");\n+        }\n+    }\n+\n+    #[test]\n+    fn simple() {\n+        let s = CString::from_slice(b\"1234\");\n+        assert_eq!(s.as_bytes(), b\"1234\");\n+        assert_eq!(s.as_bytes_with_nul(), b\"1234\\0\");\n+        unsafe {\n+            assert_eq!(s.as_slice(),\n+                       mem::transmute::<_, &[libc::c_char]>(b\"1234\"));\n+            assert_eq!(s.as_slice_with_nul(),\n+                       mem::transmute::<_, &[libc::c_char]>(b\"1234\\0\"));\n+        }\n+    }\n+\n+    #[should_fail] #[test]\n+    fn build_with_zero1() { CString::from_slice(b\"\\0\"); }\n+    #[should_fail] #[test]\n+    fn build_with_zero2() { CString::from_vec(vec![0]); }\n+\n+    #[test]\n+    fn build_with_zero3() {\n+        unsafe {\n+            let s = CString::from_vec_unchecked(vec![0]);\n+            assert_eq!(s.as_bytes(), b\"\\0\");\n+        }\n+    }\n+}"}, {"sha": "cc86f804e3eb1347772e143287da0443728f67e4", "filename": "src/libstd/ffi/mod.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Utilities related to FFI bindings.\n+\n+#![unstable = \"module just underwent fairly large reorganization and the dust \\\n+               still needs to settle\"]\n+\n+pub use self::c_str::CString;\n+pub use self::c_str::c_str_to_bytes;\n+pub use self::c_str::c_str_to_bytes_with_nul;\n+\n+mod c_str;"}, {"sha": "ac2b01e995e2c62b5b17cea4e589659149bff133", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -90,7 +90,7 @@ impl RandomSipHasher {\n \n impl Hasher<sip::SipState> for RandomSipHasher {\n     #[inline]\n-    fn hash<Sized? T: Hash<sip::SipState>>(&self, value: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<sip::SipState>>(&self, value: &T) -> u64 {\n         self.hasher.hash(value)\n     }\n }"}, {"sha": "d590aa8419453d6de9ce3ed35c62fba98b719052", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -14,15 +14,18 @@\n \n use cmp;\n use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n-use iter::ExactSizeIterator;\n+use iter::{IteratorExt, ExactSizeIterator};\n use ops::Drop;\n use option::Option;\n use option::Option::{Some, None};\n-use result::Result::{Ok, Err};\n+use result::Result::Ok;\n use slice::{SliceExt};\n use slice;\n use vec::Vec;\n \n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::Err;\n+\n /// Wraps a Reader and buffers input from it\n ///\n /// It can be excessively inefficient to work directly with a `Reader`. For"}, {"sha": "5bef473db990c8879a7fcb23d801ad6a88321769", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -282,10 +282,13 @@ pub mod net;\n pub mod pipe;\n pub mod process;\n pub mod stdio;\n-pub mod test;\n pub mod timer;\n pub mod util;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+pub mod test;\n+\n /// The default buffer size for various I/O operations\n // libuv recommends 64k buffers to maximize throughput\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n@@ -1012,12 +1015,12 @@ pub trait Writer {\n     fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n         // Create a shim which translates a Writer to a fmt::Writer and saves\n         // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, Sized? T:'a> {\n+        struct Adaptor<'a, T: ?Sized +'a> {\n             inner: &'a mut T,\n             error: IoResult<()>,\n         }\n \n-        impl<'a, Sized? T: Writer> fmt::Writer for Adaptor<'a, T> {\n+        impl<'a, T: ?Sized + Writer> fmt::Writer for Adaptor<'a, T> {\n             fn write_str(&mut self, s: &str) -> fmt::Result {\n                 match self.inner.write(s.as_bytes()) {\n                     Ok(()) => Ok(()),\n@@ -1597,11 +1600,11 @@ pub trait Acceptor<T> {\n /// `Some`. The `Some` contains the `IoResult` representing whether the\n /// connection attempt was successful.  A successful connection will be wrapped\n /// in `Ok`. A failed connection is represented as an `Err`.\n-pub struct IncomingConnections<'a, Sized? A:'a> {\n+pub struct IncomingConnections<'a, A: ?Sized +'a> {\n     inc: &'a mut A,\n }\n \n-impl<'a, T, Sized? A: Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n+impl<'a, T, A: ?Sized + Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n     type Item = IoResult<T>;\n \n     fn next(&mut self) -> Option<IoResult<T>> {"}, {"sha": "738c70412f78a0aa3def5993a313879ecdeed747", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -22,7 +22,8 @@\n \n use prelude::v1::*;\n \n-use c_str::ToCStr;\n+use ffi::CString;\n+use path::BytesContainer;\n use io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n use sys::pipe::UnixListener as UnixListenerImp;\n@@ -53,8 +54,9 @@ impl UnixStream {\n     /// let mut stream = UnixStream::connect(&server);\n     /// stream.write(&[1, 2, 3]);\n     /// ```\n-    pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n-        UnixStreamImp::connect(&path.to_c_str(), None)\n+    pub fn connect<P: BytesContainer>(path: P) -> IoResult<UnixStream> {\n+        let path = CString::from_slice(path.container_as_bytes());\n+        UnixStreamImp::connect(&path, None)\n             .map(|inner| UnixStream { inner: inner })\n     }\n \n@@ -67,13 +69,15 @@ impl UnixStream {\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument is likely to change types\"]\n-    pub fn connect_timeout<P: ToCStr>(path: &P,\n-                                      timeout: Duration) -> IoResult<UnixStream> {\n+    pub fn connect_timeout<P>(path: P, timeout: Duration)\n+                              -> IoResult<UnixStream>\n+                              where P: BytesContainer {\n         if timeout <= Duration::milliseconds(0) {\n             return Err(standard_error(TimedOut));\n         }\n \n-        UnixStreamImp::connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64))\n+        let path = CString::from_slice(path.container_as_bytes());\n+        UnixStreamImp::connect(&path, Some(timeout.num_milliseconds() as u64))\n             .map(|inner| UnixStream { inner: inner })\n     }\n \n@@ -177,8 +181,9 @@ impl UnixListener {\n     /// }\n     /// # }\n     /// ```\n-    pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> {\n-        UnixListenerImp::bind(&path.to_c_str())\n+    pub fn bind<P: BytesContainer>(path: P) -> IoResult<UnixListener> {\n+        let path = CString::from_slice(path.container_as_bytes());\n+        UnixListenerImp::bind(&path)\n             .map(|inner| UnixListener { inner: inner })\n     }\n }"}, {"sha": "ea232ad0c3f1b0876b1d860fb1dd1447397b7d1f", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -18,8 +18,8 @@ pub use self::ProcessExit::*;\n \n use prelude::v1::*;\n \n-use c_str::{CString, ToCStr};\n use collections::HashMap;\n+use ffi::CString;\n use fmt;\n use hash::Hash;\n use io::pipe::{PipeStream, PipePair};\n@@ -35,6 +35,7 @@ use sys;\n use thread::Thread;\n \n #[cfg(windows)] use std::hash::sip::SipState;\n+#[cfg(windows)] use str;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n@@ -109,11 +110,11 @@ struct EnvKey(CString);\n impl Hash for EnvKey {\n     fn hash(&self, state: &mut SipState) {\n         let &EnvKey(ref x) = self;\n-        match x.as_str() {\n-            Some(s) => for ch in s.chars() {\n+        match str::from_utf8(x.as_bytes()) {\n+            Ok(s) => for ch in s.chars() {\n                 (ch as u8 as char).to_lowercase().hash(state);\n             },\n-            None => x.hash(state)\n+            Err(..) => x.hash(state)\n         }\n     }\n }\n@@ -123,8 +124,8 @@ impl PartialEq for EnvKey {\n     fn eq(&self, other: &EnvKey) -> bool {\n         let &EnvKey(ref x) = self;\n         let &EnvKey(ref y) = other;\n-        match (x.as_str(), y.as_str()) {\n-            (Some(xs), Some(ys)) => {\n+        match (str::from_utf8(x.as_bytes()), str::from_utf8(y.as_bytes())) {\n+            (Ok(xs), Ok(ys)) => {\n                 if xs.len() != ys.len() {\n                     return false\n                 } else {\n@@ -185,10 +186,10 @@ pub struct Command {\n }\n \n // FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n-// we cannot usefully take ToCStr arguments by reference (without forcing an\n+// we cannot usefully take BytesContainer arguments by reference (without forcing an\n // additional & around &str). So we are instead temporarily adding an instance\n-// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n-// instance should be removed, and arguments bound by ToCStr should be passed by\n+// for &Path, so that we can take BytesContainer as owned. When DST lands, the &Path\n+// instance should be removed, and arguments bound by BytesContainer should be passed by\n // reference. (Here: {new, arg, args, env}.)\n \n impl Command {\n@@ -203,9 +204,9 @@ impl Command {\n     ///\n     /// Builder methods are provided to change these defaults and\n     /// otherwise configure the process.\n-    pub fn new<T:ToCStr>(program: T) -> Command {\n+    pub fn new<T: BytesContainer>(program: T) -> Command {\n         Command {\n-            program: program.to_c_str(),\n+            program: CString::from_slice(program.container_as_bytes()),\n             args: Vec::new(),\n             env: None,\n             cwd: None,\n@@ -219,27 +220,29 @@ impl Command {\n     }\n \n     /// Add an argument to pass to the program.\n-    pub fn arg<'a, T: ToCStr>(&'a mut self, arg: T) -> &'a mut Command {\n-        self.args.push(arg.to_c_str());\n+    pub fn arg<'a, T: BytesContainer>(&'a mut self, arg: T) -> &'a mut Command {\n+        self.args.push(CString::from_slice(arg.container_as_bytes()));\n         self\n     }\n \n     /// Add multiple arguments to pass to the program.\n-    pub fn args<'a, T: ToCStr>(&'a mut self, args: &[T]) -> &'a mut Command {\n-        self.args.extend(args.iter().map(|arg| arg.to_c_str()));;\n+    pub fn args<'a, T: BytesContainer>(&'a mut self, args: &[T]) -> &'a mut Command {\n+        self.args.extend(args.iter().map(|arg| {\n+            CString::from_slice(arg.container_as_bytes())\n+        }));\n         self\n     }\n     // Get a mutable borrow of the environment variable map for this `Command`.\n-    fn get_env_map<'a>(&'a mut self) -> &'a mut  EnvMap {\n+    fn get_env_map<'a>(&'a mut self) -> &'a mut EnvMap {\n         match self.env {\n             Some(ref mut map) => map,\n             None => {\n                 // if the env is currently just inheriting from the parent's,\n                 // materialize the parent's env into a hashtable.\n-                self.env = Some(os::env_as_bytes().into_iter()\n-                                   .map(|(k, v)| (EnvKey(k.to_c_str()),\n-                                                  v.to_c_str()))\n-                                   .collect());\n+                self.env = Some(os::env_as_bytes().into_iter().map(|(k, v)| {\n+                    (EnvKey(CString::from_slice(k.as_slice())),\n+                     CString::from_slice(v.as_slice()))\n+                }).collect());\n                 self.env.as_mut().unwrap()\n             }\n         }\n@@ -249,32 +252,40 @@ impl Command {\n     ///\n     /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n     /// and case-sensitive on all other platforms.\n-    pub fn env<'a, T: ToCStr, U: ToCStr>(&'a mut self, key: T, val: U)\n-                                         -> &'a mut Command {\n-        self.get_env_map().insert(EnvKey(key.to_c_str()), val.to_c_str());\n+    pub fn env<'a, T, U>(&'a mut self, key: T, val: U)\n+                         -> &'a mut Command\n+                         where T: BytesContainer, U: BytesContainer {\n+        let key = EnvKey(CString::from_slice(key.container_as_bytes()));\n+        let val = CString::from_slice(val.container_as_bytes());\n+        self.get_env_map().insert(key, val);\n         self\n     }\n \n     /// Removes an environment variable mapping.\n-    pub fn env_remove<'a, T: ToCStr>(&'a mut self, key: T) -> &'a mut Command {\n-        self.get_env_map().remove(&EnvKey(key.to_c_str()));\n+    pub fn env_remove<'a, T>(&'a mut self, key: T) -> &'a mut Command\n+                             where T: BytesContainer {\n+        let key = EnvKey(CString::from_slice(key.container_as_bytes()));\n+        self.get_env_map().remove(&key);\n         self\n     }\n \n     /// Sets the entire environment map for the child process.\n     ///\n     /// If the given slice contains multiple instances of an environment\n     /// variable, the *rightmost* instance will determine the value.\n-    pub fn env_set_all<'a, T: ToCStr, U: ToCStr>(&'a mut self, env: &[(T,U)])\n-                                                 -> &'a mut Command {\n-        self.env = Some(env.iter().map(|&(ref k, ref v)| (EnvKey(k.to_c_str()), v.to_c_str()))\n-                                  .collect());\n+    pub fn env_set_all<'a, T, U>(&'a mut self, env: &[(T,U)])\n+                                 -> &'a mut Command\n+                                 where T: BytesContainer, U: BytesContainer {\n+        self.env = Some(env.iter().map(|&(ref k, ref v)| {\n+            (EnvKey(CString::from_slice(k.container_as_bytes())),\n+             CString::from_slice(v.container_as_bytes()))\n+        }).collect());\n         self\n     }\n \n     /// Set the working directory for the child process.\n     pub fn cwd<'a>(&'a mut self, dir: &Path) -> &'a mut Command {\n-        self.cwd = Some(dir.to_c_str());\n+        self.cwd = Some(CString::from_slice(dir.as_vec()));\n         self\n     }\n \n@@ -389,9 +400,9 @@ impl fmt::Show for Command {\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", String::from_utf8_lossy(self.program.as_bytes_no_nul())));\n+        try!(write!(f, \"{}\", String::from_utf8_lossy(self.program.as_bytes())));\n         for arg in self.args.iter() {\n-            try!(write!(f, \" '{}'\", String::from_utf8_lossy(arg.as_bytes_no_nul())));\n+            try!(write!(f, \" '{}'\", String::from_utf8_lossy(arg.as_bytes())));\n         }\n         Ok(())\n     }\n@@ -1208,13 +1219,13 @@ mod tests {\n     #[test]\n     #[cfg(windows)]\n     fn env_map_keys_ci() {\n-        use c_str::ToCStr;\n+        use ffi::CString;\n         use super::EnvKey;\n         let mut cmd = Command::new(\"\");\n         cmd.env(\"path\", \"foo\");\n         cmd.env(\"Path\", \"bar\");\n         let env = &cmd.env.unwrap();\n-        let val = env.get(&EnvKey(\"PATH\".to_c_str()));\n-        assert!(val.unwrap() == &\"bar\".to_c_str());\n+        let val = env.get(&EnvKey(CString::from_slice(b\"PATH\")));\n+        assert!(val.unwrap() == &CString::from_slice(b\"bar\"));\n     }\n }"}, {"sha": "394686be814f24c593ce5c72080c6164c1fbc6be", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,16 +10,18 @@\n \n //! Temporary files and directories\n \n-use io::{fs, IoResult};\n+use io::{fs, IoError, IoErrorKind, IoResult};\n use io;\n-use libc;\n+use iter::{IteratorExt, range};\n use ops::Drop;\n use option::Option;\n use option::Option::{None, Some};\n use os;\n use path::{Path, GenericPath};\n+use rand::{Rng, thread_rng};\n use result::Result::{Ok, Err};\n-use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+use str::StrExt;\n+use string::String;\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-based deletion.\n@@ -31,7 +33,7 @@ use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n ///\n /// {\n ///     // create a temporary directory\n-///     let tmpdir = match TempDir::new(\"mysuffix\") {\n+///     let tmpdir = match TempDir::new(\"myprefix\") {\n ///         Ok(dir) => dir,\n ///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n ///     };\n@@ -46,7 +48,7 @@ use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n /// }\n /// {\n ///     // create a temporary directory, this time using a custom path\n-///     let tmpdir = match TempDir::new_in(&Path::new(\"/tmp/best/custom/path\"), \"mysuffix\") {\n+///     let tmpdir = match TempDir::new_in(&Path::new(\"/tmp/best/custom/path\"), \"myprefix\") {\n ///         Ok(dir) => dir,\n ///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n ///     };\n@@ -61,7 +63,7 @@ use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n /// }\n /// {\n ///     // create a temporary directory\n-///     let tmpdir = match TempDir::new(\"mysuffix\") {\n+///     let tmpdir = match TempDir::new(\"myprefix\") {\n ///         Ok(dir) => dir,\n ///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n ///     };\n@@ -78,47 +80,59 @@ pub struct TempDir {\n     disarmed: bool\n }\n \n+// How many times should we (re)try finding an unused random name? It should be\n+// enough that an attacker will run out of luck before we run out of patience.\n+const NUM_RETRIES: u32 = 1 << 31;\n+// How many characters should we include in a random file name? It needs to\n+// be enough to dissuade an attacker from trying to preemptively create names\n+// of that length, but not so huge that we unnecessarily drain the random number\n+// generator of entropy.\n+const NUM_RAND_CHARS: uint = 12;\n+\n impl TempDir {\n     /// Attempts to make a temporary directory inside of `tmpdir` whose name\n-    /// will have the suffix `suffix`. The directory will be automatically\n+    /// will have the prefix `prefix`. The directory will be automatically\n     /// deleted once the returned wrapper is destroyed.\n     ///\n     /// If no directory can be created, `Err` is returned.\n-    pub fn new_in(tmpdir: &Path, suffix: &str) -> IoResult<TempDir> {\n+    pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n         if !tmpdir.is_absolute() {\n             let abs_tmpdir = try!(os::make_absolute(tmpdir));\n-            return TempDir::new_in(&abs_tmpdir, suffix);\n+            return TempDir::new_in(&abs_tmpdir, prefix);\n         }\n \n-        static CNT: AtomicUint = ATOMIC_UINT_INIT;\n-\n-        let mut attempts = 0u;\n-        loop {\n-            let filename =\n-                format!(\"rs-{}-{}-{}\",\n-                        unsafe { libc::getpid() },\n-                        CNT.fetch_add(1, Ordering::SeqCst),\n-                        suffix);\n-            let p = tmpdir.join(filename);\n-            match fs::mkdir(&p, io::USER_RWX) {\n-                Err(error) => {\n-                    if attempts >= 1000 {\n-                        return Err(error)\n-                    }\n-                    attempts += 1;\n-                }\n-                Ok(()) => return Ok(TempDir { path: Some(p), disarmed: false })\n+        let mut rng = thread_rng();\n+        for _ in range(0, NUM_RETRIES) {\n+            let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n+            let leaf = if prefix.len() > 0 {\n+                format!(\"{}.{}\", prefix, suffix)\n+            } else {\n+                // If we're given an empty string for a prefix, then creating a\n+                // directory starting with \".\" would lead to it being\n+                // semi-invisible on some systems.\n+                suffix\n+            };\n+            let path = tmpdir.join(leaf);\n+            match fs::mkdir(&path, io::USER_RWX) {\n+                Ok(_) => return Ok(TempDir { path: Some(path), disarmed: false }),\n+                Err(IoError{kind:IoErrorKind::PathAlreadyExists,..}) => (),\n+                Err(e) => return Err(e)\n             }\n         }\n+\n+        return Err(IoError{\n+                       kind: IoErrorKind::PathAlreadyExists,\n+                       desc:\"Exhausted\",\n+                       detail: None});\n     }\n \n     /// Attempts to make a temporary directory inside of `os::tmpdir()` whose\n-    /// name will have the suffix `suffix`. The directory will be automatically\n+    /// name will have the prefix `prefix`. The directory will be automatically\n     /// deleted once the returned wrapper is destroyed.\n     ///\n     /// If no directory can be created, `Err` is returned.\n-    pub fn new(suffix: &str) -> IoResult<TempDir> {\n-        TempDir::new_in(&os::tmpdir(), suffix)\n+    pub fn new(prefix: &str) -> IoResult<TempDir> {\n+        TempDir::new_in(&os::tmpdir(), prefix)\n     }\n \n     /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper."}, {"sha": "6eeef175f73d50844c1d17123385c3cc544a61da", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,8 +10,6 @@\n \n //! Various utility functions useful for writing I/O tests\n \n-#![macro_escape]\n-\n use prelude::v1::*;\n \n use libc;"}, {"sha": "b9f226c5aca73e83a227f4fc81b1116bc4cf5a0d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -95,7 +95,7 @@\n //! and `format!`, also available to all Rust code.\n \n #![crate_name = \"std\"]\n-#![unstable]\n+#![stable]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -117,13 +117,36 @@\n \n #![reexport_test_harness_main = \"test_main\"]\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate log;\n \n-extern crate alloc;\n-extern crate unicode;\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate core;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+#[macro_reexport(assert, assert_eq, debug_assert, debug_assert_eq,\n+    unreachable, unimplemented, write, writeln)]\n extern crate core;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate \"collections\" as core_collections;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+#[macro_reexport(vec)]\n extern crate \"collections\" as core_collections;\n+\n extern crate \"rand\" as core_rand;\n+extern crate alloc;\n+extern crate unicode;\n extern crate libc;\n \n // Make std testable by not duplicating lang items. See #2912\n@@ -167,7 +190,18 @@ pub use unicode::char;\n \n /* Exported macros */\n \n+#[cfg(stage0)]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+pub mod macros_stage0;\n+\n+#[cfg(not(stage0))]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod macros;\n+\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod bitflags;\n \n mod rtdeps;\n@@ -179,9 +213,20 @@ pub mod prelude;\n \n /* Primitive types */\n \n-#[path = \"num/float_macros.rs\"] mod float_macros;\n-#[path = \"num/int_macros.rs\"]   mod int_macros;\n-#[path = \"num/uint_macros.rs\"]  mod uint_macros;\n+#[path = \"num/float_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod float_macros;\n+\n+#[path = \"num/int_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod int_macros;\n+\n+#[path = \"num/uint_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod uint_macros;\n \n #[path = \"num/int.rs\"]  pub mod int;\n #[path = \"num/i8.rs\"]   pub mod i8;\n@@ -208,10 +253,12 @@ pub mod num;\n \n /* Runtime and platform support */\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod thread_local;\n-pub mod c_str;\n-pub mod c_vec;\n+\n pub mod dynamic_lib;\n+pub mod ffi;\n pub mod fmt;\n pub mod io;\n pub mod os;"}, {"sha": "d96441e09a813efa82ee5c66384c11074d90416c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -15,7 +15,6 @@\n //! library.\n \n #![experimental]\n-#![macro_escape]\n \n /// The entry point for panic of Rust tasks.\n ///\n@@ -246,34 +245,6 @@ macro_rules! format {\n     ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n }\n \n-/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// # #![allow(unused_must_use)]\n-///\n-/// let mut w = Vec::new();\n-/// write!(&mut w, \"test\");\n-/// write!(&mut w, \"formatted {}\", \"arguments\");\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n-}\n-\n-/// Equivalent to the `write!` macro, except that a newline is appended after\n-/// the message is written.\n-#[macro_export]\n-#[stable]\n-macro_rules! writeln {\n-    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n-        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n-    )\n-}\n-\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n@@ -306,23 +277,15 @@ macro_rules! println {\n #[macro_export]\n macro_rules! try {\n     ($expr:expr) => ({\n+        use $crate::result::Result::{Ok, Err};\n+\n         match $expr {\n             Ok(val) => val,\n-            Err(err) => return Err(::std::error::FromError::from_error(err))\n+            Err(err) => return Err($crate::error::FromError::from_error(err)),\n         }\n     })\n }\n \n-/// Create a `std::vec::Vec` containing the arguments.\n-#[macro_export]\n-macro_rules! vec {\n-    ($($x:expr),*) => ({\n-        let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n-        ::std::slice::SliceExt::into_vec(xs)\n-    });\n-    ($($x:expr,)*) => (vec![$($x),*])\n-}\n-\n /// A macro to select an event from a number of receivers.\n ///\n /// This macro is used to wait for the first event to occur on a number of\n@@ -358,7 +321,7 @@ macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n     ) => ({\n-        use std::sync::mpsc::Select;\n+        use $crate::sync::mpsc::Select;\n         let sel = Select::new();\n         $( let mut $rx = sel.handle(&$rx); )+\n         unsafe {"}, {"sha": "48d62e73e13edeba26b4b7f7907dc6a23716bb65", "filename": "src/libstd/macros_stage0.rs", "status": "added", "additions": 648, "deletions": 0, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fmacros_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fmacros_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros_stage0.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,648 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Standard library macros\n+//!\n+//! This modules contains a set of macros which are exported from the standard\n+//! library. Each macro is available for use when linking against the standard\n+//! library.\n+\n+#![experimental]\n+\n+/// The entry point for panic of Rust tasks.\n+///\n+/// This macro is used to inject panic into a Rust task, causing the task to\n+/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n+/// the value which is transmitted.\n+///\n+/// The multi-argument form of this macro panics with a string and has the\n+/// `format!` syntax for building a string.\n+///\n+/// # Example\n+///\n+/// ```should_fail\n+/// # #![allow(unreachable_code)]\n+/// panic!();\n+/// panic!(\"this is a terrible mistake!\");\n+/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n+/// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n+/// ```\n+#[macro_export]\n+macro_rules! panic {\n+    () => ({\n+        panic!(\"explicit panic\")\n+    });\n+    ($msg:expr) => ({\n+        // static requires less code at runtime, more constant data\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind($msg, &_FILE_LINE)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        // The leading _'s are to avoid dead code warnings if this is\n+        // used inside a dead function. Just `#[allow(dead_code)]` is\n+        // insufficient, since the user may have\n+        // `#[forbid(dead_code)]` and which cannot be overridden.\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+\n+    });\n+}\n+\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// assert!(true);\n+/// # fn some_computation() -> bool { true }\n+/// assert!(some_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! assert {\n+    ($cond:expr) => (\n+        if !$cond {\n+            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n+        }\n+    );\n+    ($cond:expr, $($arg:expr),+) => (\n+        if !$cond {\n+            panic!($($arg),+)\n+        }\n+    );\n+}\n+\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// assert_eq!(a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! assert_eq {\n+    ($left:expr , $right:expr) => ({\n+        match (&($left), &($right)) {\n+            (left_val, right_val) => {\n+                // check both directions of equality....\n+                if !((*left_val == *right_val) &&\n+                     (*right_val == *left_val)) {\n+                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n+                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n+                }\n+            }\n+        }\n+    })\n+}\n+\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n+/// `--cfg ndebug` to the compiler. This makes `debug_assert!` useful for\n+/// checks that are too expensive to be present in a release build but may be\n+/// helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// debug_assert!(true);\n+/// # fn some_expensive_computation() -> bool { true }\n+/// debug_assert!(some_expensive_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// debug_assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! debug_assert {\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+}\n+\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n+/// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n+/// useful for checks that are too expensive to be present in a release build\n+/// but may be helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// debug_assert_eq!(a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! debug_assert_eq {\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n+}\n+\n+/// A utility macro for indicating unreachable code.\n+///\n+/// This is useful any time that the compiler can't determine that some code is unreachable. For\n+/// example:\n+///\n+/// * Match arms with guard conditions.\n+/// * Loops that dynamically terminate.\n+/// * Iterators that dynamically terminate.\n+///\n+/// # Panics\n+///\n+/// This will always panic.\n+///\n+/// # Examples\n+///\n+/// Match arms:\n+///\n+/// ```rust\n+/// fn foo(x: Option<int>) {\n+///     match x {\n+///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n+///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n+///         Some(_)           => unreachable!(), // compile error if commented out\n+///         None              => println!(\"None\")\n+///     }\n+/// }\n+/// ```\n+///\n+/// Iterators:\n+///\n+/// ```rust\n+/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n+///     for i in std::iter::count(0_u32, 1) {\n+///         if 3*i < i { panic!(\"u32 overflow\"); }\n+///         if x < 3*i { return i-1; }\n+///     }\n+///     unreachable!();\n+/// }\n+/// ```\n+#[macro_export]\n+macro_rules! unreachable {\n+    () => ({\n+        panic!(\"internal error: entered unreachable code\")\n+    });\n+    ($msg:expr) => ({\n+        unreachable!(\"{}\", $msg)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n+    });\n+}\n+\n+/// A standardised placeholder for marking unfinished code. It panics with the\n+/// message `\"not yet implemented\"` when executed.\n+#[macro_export]\n+macro_rules! unimplemented {\n+    () => (panic!(\"not yet implemented\"))\n+}\n+\n+/// Use the syntax described in `std::fmt` to create a value of type `String`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// format!(\"test\");\n+/// format!(\"hello {}\", \"world!\");\n+/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! format {\n+    ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n+}\n+\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # #![allow(unused_must_use)]\n+///\n+/// let mut w = Vec::new();\n+/// write!(&mut w, \"test\");\n+/// write!(&mut w, \"formatted {}\", \"arguments\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! write {\n+    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n+}\n+\n+/// Equivalent to the `write!` macro, except that a newline is appended after\n+/// the message is written.\n+#[macro_export]\n+#[stable]\n+macro_rules! writeln {\n+    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n+        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n+    )\n+}\n+\n+/// Equivalent to the `println!` macro except that a newline is not printed at\n+/// the end of the message.\n+#[macro_export]\n+#[stable]\n+macro_rules! print {\n+    ($($arg:tt)*) => (::std::io::stdio::print_args(format_args!($($arg)*)))\n+}\n+\n+/// Macro for printing to a task's stdout handle.\n+///\n+/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n+/// The syntax of this macro is the same as that used for `format!`. For more\n+/// information, see `std::fmt` and `std::io::stdio`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// println!(\"hello there!\");\n+/// println!(\"format {} arguments\", \"some\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! println {\n+    ($($arg:tt)*) => (::std::io::stdio::println_args(format_args!($($arg)*)))\n+}\n+\n+/// Helper macro for unwrapping `Result` values while returning early with an\n+/// error if the value of the expression is `Err`. For more information, see\n+/// `std::io`.\n+#[macro_export]\n+macro_rules! try {\n+    ($expr:expr) => ({\n+        match $expr {\n+            Ok(val) => val,\n+            Err(err) => return Err(::std::error::FromError::from_error(err))\n+        }\n+    })\n+}\n+\n+/// Create a `std::vec::Vec` containing the arguments.\n+#[macro_export]\n+macro_rules! vec {\n+    ($($x:expr),*) => ({\n+        let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n+        ::std::slice::SliceExt::into_vec(xs)\n+    });\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n+/// A macro to select an event from a number of receivers.\n+///\n+/// This macro is used to wait for the first event to occur on a number of\n+/// receivers. It places no restrictions on the types of receivers given to\n+/// this macro, this can be viewed as a heterogeneous select.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::thread::Thread;\n+/// use std::sync::mpsc::channel;\n+///\n+/// let (tx1, rx1) = channel();\n+/// let (tx2, rx2) = channel();\n+/// # fn long_running_task() {}\n+/// # fn calculate_the_answer() -> int { 42i }\n+///\n+/// Thread::spawn(move|| { long_running_task(); tx1.send(()) }).detach();\n+/// Thread::spawn(move|| { tx2.send(calculate_the_answer()) }).detach();\n+///\n+/// select! (\n+///     _ = rx1.recv() => println!(\"the long running task finished first\"),\n+///     answer = rx2.recv() => {\n+///         println!(\"the answer was: {}\", answer.unwrap());\n+///     }\n+/// )\n+/// ```\n+///\n+/// For more information about select, see the `std::sync::mpsc::Select` structure.\n+#[macro_export]\n+#[experimental]\n+macro_rules! select {\n+    (\n+        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n+    ) => ({\n+        use std::sync::mpsc::Select;\n+        let sel = Select::new();\n+        $( let mut $rx = sel.handle(&$rx); )+\n+        unsafe {\n+            $( $rx.add(); )+\n+        }\n+        let ret = sel.wait();\n+        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n+        { unreachable!() }\n+    })\n+}\n+\n+// When testing the standard library, we link to the liblog crate to get the\n+// logging macros. In doing so, the liblog crate was linked against the real\n+// version of libstd, and uses a different std::fmt module than the test crate\n+// uses. To get around this difference, we redefine the log!() macro here to be\n+// just a dumb version of what it should be.\n+#[cfg(test)]\n+macro_rules! log {\n+    ($lvl:expr, $($args:tt)*) => (\n+        if log_enabled!($lvl) { println!($($args)*) }\n+    )\n+}\n+\n+/// Built-in macros to the compiler itself.\n+///\n+/// These macros do not have any corresponding definition with a `macro_rules!`\n+/// macro, but are documented here. Their implementations can be found hardcoded\n+/// into libsyntax itself.\n+#[cfg(dox)]\n+pub mod builtin {\n+    /// The core macro for formatted string creation & output.\n+    ///\n+    /// This macro produces a value of type `fmt::Arguments`. This value can be\n+    /// passed to the functions in `std::fmt` for performing useful functions.\n+    /// All other formatting macros (`format!`, `write!`, `println!`, etc) are\n+    /// proxied through this one.\n+    ///\n+    /// For more information, see the documentation in `std::fmt`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n+    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n+    ///\n+    /// ```\n+    #[macro_export]\n+    macro_rules! format_args { ($fmt:expr $($args:tt)*) => ({\n+        /* compiler built-in */\n+    }) }\n+\n+    /// Inspect an environment variable at compile time.\n+    ///\n+    /// This macro will expand to the value of the named environment variable at\n+    /// compile time, yielding an expression of type `&'static str`.\n+    ///\n+    /// If the environment variable is not defined, then a compilation error\n+    /// will be emitted.  To not emit a compile error, use the `option_env!`\n+    /// macro instead.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let path: &'static str = env!(\"PATH\");\n+    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Optionally inspect an environment variable at compile time.\n+    ///\n+    /// If the named environment variable is present at compile time, this will\n+    /// expand into an expression of type `Option<&'static str>` whose value is\n+    /// `Some` of the value of the environment variable. If the environment\n+    /// variable is not present, then this will expand to `None`.\n+    ///\n+    /// A compile time error is never emitted when using this macro regardless\n+    /// of whether the environment variable is present or not.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n+    /// println!(\"the secret key might be: {}\", key);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Concatenate literals into a static byte slice.\n+    ///\n+    /// This macro takes any number of comma-separated literal expressions,\n+    /// yielding an expression of type `&'static [u8]` which is the\n+    /// concatenation (left to right) of all the literals in their byte format.\n+    ///\n+    /// This extension currently only supports string literals, character\n+    /// literals, and integers less than 256. The byte slice returned is the\n+    /// utf8-encoding of strings and characters.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let rust = bytes!(\"r\", 'u', \"st\", 255);\n+    /// assert_eq!(rust[1], b'u');\n+    /// assert_eq!(rust[4], 255);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! bytes { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n+\n+    /// Concatenate identifiers into one identifier.\n+    ///\n+    /// This macro takes any number of comma-separated identifiers, and\n+    /// concatenates them all into one, yielding an expression which is a new\n+    /// identifier. Note that hygiene makes it such that this macro cannot\n+    /// capture local variables, and macros are only allowed in item,\n+    /// statement or expression position, meaning this macro may be difficult to\n+    /// use in some situations.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(concat_idents)]\n+    ///\n+    /// # fn main() {\n+    /// fn foobar() -> int { 23 }\n+    ///\n+    /// let f = concat_idents!(foo, bar);\n+    /// println!(\"{}\", f());\n+    /// # }\n+    /// ```\n+    #[macro_export]\n+    macro_rules! concat_idents {\n+        ($($e:ident),*) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Concatenates literals into a static string slice.\n+    ///\n+    /// This macro takes any number of comma-separated literals, yielding an\n+    /// expression of type `&'static str` which represents all of the literals\n+    /// concatenated left-to-right.\n+    ///\n+    /// Integer and floating point literals are stringified in order to be\n+    /// concatenated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = concat!(\"test\", 10i, 'b', true);\n+    /// assert_eq!(s, \"test10btrue\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the line number on which it was invoked.\n+    ///\n+    /// The expanded expression has type `uint`, and the returned line is not\n+    /// the invocation of the `line!()` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `line!()` macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let current_line = line!();\n+    /// println!(\"defined on line: {}\", current_line);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! line { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the column number on which it was invoked.\n+    ///\n+    /// The expanded expression has type `uint`, and the returned column is not\n+    /// the invocation of the `column!()` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `column!()` macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let current_col = column!();\n+    /// println!(\"defined on column: {}\", current_col);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! column { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the file name from which it was invoked.\n+    ///\n+    /// The expanded expression has type `&'static str`, and the returned file\n+    /// is not the invocation of the `file!()` macro itself, but rather the\n+    /// first macro invocation leading up to the invocation of the `file!()`\n+    /// macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let this_file = file!();\n+    /// println!(\"defined in file: {}\", this_file);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! file { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which stringifies its argument.\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// stringification of all the tokens passed to the macro. No restrictions\n+    /// are placed on the syntax of the macro invocation itself.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let one_plus_one = stringify!(1 + 1);\n+    /// assert_eq!(one_plus_one, \"1 + 1\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n+\n+    /// Includes a utf8-encoded file as a string.\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// contents of the filename specified. The file is located relative to the\n+    /// current file (similarly to how modules are found),\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let secret_key = include_str!(\"secret-key.ascii\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Includes a file as a byte slice.\n+    ///\n+    /// This macro will yield an expression of type `&'static [u8]` which is\n+    /// the contents of the filename specified. The file is located relative to\n+    /// the current file (similarly to how modules are found),\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let secret_key = include_bytes!(\"secret-key.bin\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Deprecated alias for `include_bytes!()`.\n+    #[macro_export]\n+    macro_rules! include_bin { ($file:expr) => ({ /* compiler built-in */}) }\n+\n+    /// Expands to a string that represents the current module path.\n+    ///\n+    /// The current module path can be thought of as the hierarchy of modules\n+    /// leading back up to the crate root. The first component of the path\n+    /// returned is the name of the crate currently being compiled.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// mod test {\n+    ///     pub fn foo() {\n+    ///         assert!(module_path!().ends_with(\"test\"));\n+    ///     }\n+    /// }\n+    ///\n+    /// test::foo();\n+    /// ```\n+    #[macro_export]\n+    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n+\n+    /// Boolean evaluation of configuration flags.\n+    ///\n+    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n+    /// boolean expression evaluation of configuration flags. This frequently\n+    /// leads to less duplicated code.\n+    ///\n+    /// The syntax given to this macro is the same syntax as the `cfg`\n+    /// attribute.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let my_directory = if cfg!(windows) {\n+    ///     \"windows-specific-directory\"\n+    /// } else {\n+    ///     \"unix-directory\"\n+    /// };\n+    /// ```\n+    #[macro_export]\n+    macro_rules! cfg { ($cfg:tt) => ({ /* compiler built-in */ }) }\n+}"}, {"sha": "4c52f29b12d763a2433b29af0341b0c29ac1b656", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![experimental]\n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! assert_approx_eq {"}, {"sha": "ebcb20861879c87aebf86b92b17cc568e198ea92", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![experimental]\n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! int_module { ($T:ty) => ("}, {"sha": "08ea1b024c99360264b37d989ac2c099486e1014", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![experimental]\n-#![macro_escape]\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n "}, {"sha": "300ceec4b45bf3a047a54a0947a29395cd8accc3", "filename": "src/libstd/os.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -57,12 +57,10 @@ use string::{String, ToString};\n use sync::atomic::{AtomicInt, ATOMIC_INT_INIT, Ordering};\n use vec::Vec;\n \n-#[cfg(unix)] use c_str::ToCStr;\n+#[cfg(unix)] use ffi::{self, CString};\n \n-#[cfg(unix)]\n-pub use sys::ext as unix;\n-#[cfg(windows)]\n-pub use sys::ext as windows;\n+#[cfg(unix)] pub use sys::ext as unix;\n+#[cfg(windows)] pub use sys::ext as windows;\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n@@ -196,15 +194,14 @@ pub fn getenv(n: &str) -> Option<String> {\n ///\n /// Panics if `n` has any interior NULs.\n pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n-    use c_str::CString;\n-\n     unsafe {\n         with_env_lock(|| {\n-            let s = n.with_c_str(|buf| libc::getenv(buf));\n+            let s = CString::from_slice(n.as_bytes());\n+            let s = libc::getenv(s.as_ptr()) as *const _;\n             if s.is_null() {\n                 None\n             } else {\n-                Some(CString::new(s as *const libc::c_char, false).as_bytes_no_nul().to_vec())\n+                Some(ffi::c_str_to_bytes(&s).to_vec())\n             }\n         })\n     }\n@@ -253,13 +250,12 @@ pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n     fn _setenv(n: &str, v: &[u8]) {\n         unsafe {\n             with_env_lock(|| {\n-                n.with_c_str(|nbuf| {\n-                    v.with_c_str(|vbuf| {\n-                        if libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1) != 0 {\n-                            panic!(IoError::last_error());\n-                        }\n-                    })\n-                })\n+                let k = CString::from_slice(n.as_bytes());\n+                let v = CString::from_slice(v);\n+                if libc::funcs::posix01::unistd::setenv(k.as_ptr(),\n+                                                        v.as_ptr(), 1) != 0 {\n+                    panic!(IoError::last_error());\n+                }\n             })\n         }\n     }\n@@ -289,11 +285,10 @@ pub fn unsetenv(n: &str) {\n     fn _unsetenv(n: &str) {\n         unsafe {\n             with_env_lock(|| {\n-                n.with_c_str(|nbuf| {\n-                    if libc::funcs::posix01::unistd::unsetenv(nbuf) != 0 {\n-                        panic!(IoError::last_error());\n-                    }\n-                })\n+                let nbuf = CString::from_slice(n.as_bytes());\n+                if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n+                    panic!(IoError::last_error());\n+                }\n             })\n         }\n     }\n@@ -618,11 +613,10 @@ pub fn get_exit_status() -> int {\n #[cfg(target_os = \"macos\")]\n unsafe fn load_argc_and_argv(argc: int,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n-    use c_str::CString;\n     use iter::range;\n \n     range(0, argc as uint).map(|i| {\n-        CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_vec()\n+        ffi::c_str_to_bytes(&*argv.offset(i as int)).to_vec()\n     }).collect()\n }\n \n@@ -652,7 +646,6 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n // res\n #[cfg(target_os = \"ios\")]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    use c_str::CString;\n     use iter::range;\n     use mem;\n "}, {"sha": "b020164158cff2d5d2e876b58403cc3016b7d244", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -62,7 +62,7 @@\n #![experimental]\n \n use core::kinds::Sized;\n-use c_str::CString;\n+use ffi::CString;\n use clone::Clone;\n use fmt;\n use iter::IteratorExt;\n@@ -786,7 +786,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n }\n \n /// A trait that represents something bytes-like (e.g. a &[u8] or a &str)\n-pub trait BytesContainer for Sized? {\n+pub trait BytesContainer {\n     /// Returns a &[u8] representing the receiver\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8];\n     /// Returns the receiver interpreted as a utf-8 string, if possible\n@@ -892,11 +892,11 @@ impl BytesContainer for Vec<u8> {\n impl BytesContainer for CString {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_bytes_no_nul()\n+        self.as_bytes()\n     }\n }\n \n-impl<'a, Sized? T: BytesContainer> BytesContainer for &'a T {\n+impl<'a, T: ?Sized + BytesContainer> BytesContainer for &'a T {\n     #[inline]\n     fn container_as_bytes(&self) -> &[u8] {\n         (**self).container_as_bytes()\n@@ -913,21 +913,3 @@ impl<'a, Sized? T: BytesContainer> BytesContainer for &'a T {\n fn contains_nul<T: BytesContainer>(v: &T) -> bool {\n     v.container_as_bytes().iter().any(|&x| x == 0)\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-    use c_str::ToCStr;\n-    use path::{WindowsPath, PosixPath};\n-\n-    #[test]\n-    fn test_cstring() {\n-        let input = \"/foo/bar/baz\";\n-        let path: PosixPath = PosixPath::new(input.to_c_str());\n-        assert_eq!(path.as_vec(), input.as_bytes());\n-\n-        let input = r\"\\foo\\bar\\baz\";\n-        let path: WindowsPath = WindowsPath::new(input.to_c_str());\n-        assert_eq!(path.as_str().unwrap(), input);\n-    }\n-}"}, {"sha": "d9981ace0301ec52b40ae8453951b392fe99df2d", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 39, "deletions": 62, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,19 +10,16 @@\n \n //! POSIX file path handling\n \n-use c_str::{CString, ToCStr};\n use clone::Clone;\n-use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map};\n-use option::Option;\n-use option::Option::{None, Some};\n use kinds::Sized;\n-use str::{FromStr, Str};\n-use str;\n-use slice::{Split, AsSlice, SliceConcatExt, SliceExt};\n+use option::Option::{self, Some, None};\n+use slice::{AsSlice, Split, SliceExt, SliceConcatExt};\n+use str::{self, FromStr, StrExt};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -86,26 +83,6 @@ impl FromStr for Path {\n     }\n }\n \n-// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n-// we cannot usefully take ToCStr arguments by reference (without forcing an\n-// additional & around &str). So we are instead temporarily adding an instance\n-// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n-// instance should be removed, and arguments bound by ToCStr should be passed by\n-// reference.\n-\n-impl ToCStr for Path {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        // The Path impl guarantees no internal NUL\n-        unsafe { self.to_c_str_unchecked() }\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_vec().to_c_str_unchecked()\n-    }\n-}\n-\n impl<S: hash::Writer> hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n@@ -344,7 +321,7 @@ impl Path {\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    fn normalize<Sized? V: AsSlice<u8>>(v: &V) -> Vec<u8> {\n+    fn normalize<V: ?Sized + AsSlice<u8>>(v: &V) -> Vec<u8> {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n@@ -558,7 +535,7 @@ mod tests {\n         t!(b\"foo/\\xFFbar\", filename_display, \"\\u{FFFD}bar\");\n         t!(b\"/\", filename_display, \"\");\n \n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -573,7 +550,7 @@ mod tests {\n                     assert!(mo.as_slice() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(\"foo\", \"foo\");\n         t!(b\"foo\\x80\", \"foo\\u{FFFD}\");\n@@ -585,7 +562,7 @@ mod tests {\n \n     #[test]\n     fn test_display() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -595,7 +572,7 @@ mod tests {\n                     assert!(f == $expf);\n                 }\n             )\n-        );\n+        }\n \n         t!(b\"foo\", \"foo\", \"foo\");\n         t!(b\"foo/bar\", \"foo/bar\", \"bar\");\n@@ -608,7 +585,7 @@ mod tests {\n \n     #[test]\n     fn test_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -629,7 +606,7 @@ mod tests {\n                     assert!(path.$op() == $exp);\n                 }\n             );\n-        );\n+        }\n \n         t!(v: b\"a/b/c\", filename, Some(b\"c\"));\n         t!(v: b\"a/b/c\\xFF\", filename, Some(b\"c\\xFF\"));\n@@ -692,7 +669,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr) => (\n                 {\n                     let path = $path;\n@@ -703,7 +680,7 @@ mod tests {\n                     assert!(p1 == p2.join(join));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"..\");\n         t!(s: \"/a/b/c\", \"d\");\n@@ -713,7 +690,7 @@ mod tests {\n \n     #[test]\n     fn test_push_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -722,7 +699,7 @@ mod tests {\n                     assert!(p.as_str() == Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"d\", \"a/b/c/d\");\n         t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n@@ -734,7 +711,7 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -749,7 +726,7 @@ mod tests {\n                     assert!(p.as_vec() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n@@ -762,7 +739,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -779,7 +756,7 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             )\n-        );\n+        }\n \n         t!(b: b\"a/b/c\", b\"a/b\", true);\n         t!(b: b\"a\", b\".\", true);\n@@ -818,7 +795,7 @@ mod tests {\n \n     #[test]\n     fn test_join_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -827,7 +804,7 @@ mod tests {\n                     assert!(res.as_str() == Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"..\", \"a/b\");\n         t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n@@ -839,7 +816,7 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -854,7 +831,7 @@ mod tests {\n                     assert!(res.as_vec() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n@@ -917,7 +894,7 @@ mod tests {\n \n     #[test]\n     fn test_setters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n@@ -938,7 +915,7 @@ mod tests {\n                     assert!(p1 == p2.$with(arg));\n                 }\n             )\n-        );\n+        }\n \n         t!(v: b\"a/b/c\", set_filename, with_filename, b\"d\");\n         t!(v: b\"/\", set_filename, with_filename, b\"foo\");\n@@ -961,7 +938,7 @@ mod tests {\n \n     #[test]\n     fn test_getters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n@@ -992,7 +969,7 @@ mod tests {\n                     assert!(path.extension() == $ext);\n                 }\n             )\n-        );\n+        }\n \n         t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n         t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n@@ -1031,15 +1008,15 @@ mod tests {\n \n     #[test]\n     fn test_is_absolute() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $abs:expr, $rel:expr) => (\n                 {\n                     let path = Path::new($path);\n                     assert_eq!(path.is_absolute(), $abs);\n                     assert_eq!(path.is_relative(), $rel);\n                 }\n             )\n-        );\n+        }\n         t!(s: \"a/b/c\", false, true);\n         t!(s: \"/a/b/c\", true, false);\n         t!(s: \"a\", false, true);\n@@ -1052,15 +1029,15 @@ mod tests {\n \n     #[test]\n     fn test_is_ancestor_of() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n                     let dest = Path::new($dest);\n                     assert_eq!(path.is_ancestor_of(&dest), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"a/b/c/d\", true);\n         t!(s: \"a/b/c\", \"a/b/c\", true);\n@@ -1086,7 +1063,7 @@ mod tests {\n \n     #[test]\n     fn test_ends_with_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1101,7 +1078,7 @@ mod tests {\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"c\", true);\n         t!(s: \"a/b/c\", \"d\", false);\n@@ -1125,7 +1102,7 @@ mod tests {\n \n     #[test]\n     fn test_path_relative_from() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1134,7 +1111,7 @@ mod tests {\n                     assert_eq!(res.as_ref().and_then(|x| x.as_str()), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n         t!(s: \"a/b/c\", \"a/b/d\", Some(\"../c\"));\n@@ -1170,7 +1147,7 @@ mod tests {\n \n     #[test]\n     fn test_components_iter() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1196,7 +1173,7 @@ mod tests {\n                     assert_eq!(comps, exp)\n                 }\n             )\n-        );\n+        }\n \n         t!(b: b\"a/b/c\", [b\"a\", b\"b\", b\"c\"]);\n         t!(b: b\"/\\xFF/a/\\x80\", [b\"\\xFF\", b\"a\", b\"\\x80\"]);\n@@ -1216,7 +1193,7 @@ mod tests {\n \n     #[test]\n     fn test_str_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (b: $arg:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($arg);\n@@ -1228,7 +1205,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(b: b\"a/b/c\", [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n         t!(b: b\"/\\xFF/a/\\x80\", [None, Some(\"a\"), None]);"}, {"sha": "4b5d793355b60137fabd2b321f25efb458076cb0", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 40, "deletions": 62, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -15,17 +15,15 @@\n use self::PathPrefix::*;\n \n use ascii::AsciiExt;\n-use c_str::{CString, ToCStr};\n use char::CharExt;\n use clone::Clone;\n-use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n-use option::Option;\n-use option::Option::{Some, None};\n+use option::Option::{self, Some, None};\n use slice::{SliceExt, SliceConcatExt};\n use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n@@ -112,26 +110,6 @@ impl FromStr for Path {\n     }\n }\n \n-// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n-// we cannot usefully take ToCStr arguments by reference (without forcing an\n-// additional & around &str). So we are instead temporarily adding an instance\n-// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n-// instance should be removed, and arguments bound by ToCStr should be passed by\n-// reference.\n-\n-impl ToCStr for Path {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        // The Path impl guarantees no internal NUL\n-        unsafe { self.to_c_str_unchecked() }\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_vec().to_c_str_unchecked()\n-    }\n-}\n-\n impl<S: hash::Writer> hash::Hash<S> for Path {\n     #[cfg(not(test))]\n     #[inline]\n@@ -1149,7 +1127,7 @@ mod tests {\n \n     #[test]\n     fn test_parse_prefix() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = $path;\n@@ -1159,7 +1137,7 @@ mod tests {\n                             \"parse_prefix(\\\"{}\\\"): expected {}, found {}\", path, exp, res);\n                 }\n             )\n-        );\n+        }\n \n         t!(\"\\\\\\\\SERVER\\\\share\\\\foo\", Some(UNCPrefix(6,5)));\n         t!(\"\\\\\\\\\", None);\n@@ -1348,7 +1326,7 @@ mod tests {\n \n     #[test]\n     fn test_display() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1358,7 +1336,7 @@ mod tests {\n                     assert_eq!(f, $expf);\n                 }\n             )\n-        );\n+        }\n \n         t!(\"foo\", \"foo\", \"foo\");\n         t!(\"foo\\\\bar\", \"foo\\\\bar\", \"bar\");\n@@ -1367,7 +1345,7 @@ mod tests {\n \n     #[test]\n     fn test_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = $path;\n@@ -1390,7 +1368,7 @@ mod tests {\n                     assert!(path.$op() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(v: b\"a\\\\b\\\\c\", filename, Some(b\"c\"));\n         t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n@@ -1490,7 +1468,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr) => (\n                 {\n                     let path = $path;\n@@ -1501,7 +1479,7 @@ mod tests {\n                     assert!(p1 == p2.join(join));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"..\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\");\n@@ -1525,7 +1503,7 @@ mod tests {\n \n     #[test]\n     fn test_push_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -1534,7 +1512,7 @@ mod tests {\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n@@ -1577,7 +1555,7 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -1592,7 +1570,7 @@ mod tests {\n                     assert_eq!(p.as_vec(), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n@@ -1606,7 +1584,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let pstr = $path;\n@@ -1627,7 +1605,7 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", true);\n         t!(s: \"a\", \".\", true);\n@@ -1695,7 +1673,7 @@ mod tests {\n \n     #[test]\n     fn test_join_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1704,7 +1682,7 @@ mod tests {\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"..\", \"a\\\\b\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n@@ -1718,7 +1696,7 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1733,7 +1711,7 @@ mod tests {\n                     assert_eq!(res.as_vec(), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n@@ -1746,7 +1724,7 @@ mod tests {\n \n     #[test]\n     fn test_with_helpers() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $op:ident, $arg:expr, $res:expr) => (\n                 {\n                     let pstr = $path;\n@@ -1759,7 +1737,7 @@ mod tests {\n                             pstr, stringify!($op), arg, exp, res.as_str().unwrap());\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", with_filename, \"d\", \"a\\\\b\\\\d\");\n         t!(s: \".\", with_filename, \"foo\", \"foo\");\n@@ -1831,7 +1809,7 @@ mod tests {\n \n     #[test]\n     fn test_setters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n@@ -1852,7 +1830,7 @@ mod tests {\n                     assert!(p1 == p2.$with(arg));\n                 }\n             )\n-        );\n+        }\n \n         t!(v: b\"a\\\\b\\\\c\", set_filename, with_filename, b\"d\");\n         t!(v: b\"\\\\\", set_filename, with_filename, b\"foo\");\n@@ -1876,7 +1854,7 @@ mod tests {\n \n     #[test]\n     fn test_getters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n@@ -1907,7 +1885,7 @@ mod tests {\n                     assert!(path.extension() == $ext);\n                 }\n             )\n-        );\n+        }\n \n         t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n         t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n@@ -1942,7 +1920,7 @@ mod tests {\n \n     #[test]\n     fn test_is_absolute() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $abs:expr, $vol:expr, $cwd:expr, $rel:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1961,7 +1939,7 @@ mod tests {\n                             path.as_str().unwrap(), rel, b);\n                 }\n             )\n-        );\n+        }\n         t!(\"a\\\\b\\\\c\", false, false, false, true);\n         t!(\"\\\\a\\\\b\\\\c\", false, true, false, false);\n         t!(\"a\", false, false, false, true);\n@@ -1982,7 +1960,7 @@ mod tests {\n \n     #[test]\n     fn test_is_ancestor_of() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1994,7 +1972,7 @@ mod tests {\n                             path.as_str().unwrap(), dest.as_str().unwrap(), exp, res);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\", true);\n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n@@ -2085,15 +2063,15 @@ mod tests {\n \n     #[test]\n     fn test_ends_with_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n                     let child = Path::new($child);\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             );\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"c\", true);\n         t!(s: \"a\\\\b\\\\c\", \"d\", false);\n@@ -2117,7 +2095,7 @@ mod tests {\n \n     #[test]\n     fn test_path_relative_from() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2130,7 +2108,7 @@ mod tests {\n                             res.as_ref().and_then(|x| x.as_str()));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", Some(\"c\"));\n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\d\", Some(\"..\\\\c\"));\n@@ -2251,7 +2229,7 @@ mod tests {\n \n     #[test]\n     fn test_str_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2265,7 +2243,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             );\n-        );\n+        }\n \n         t!(s: b\"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n@@ -2309,7 +2287,7 @@ mod tests {\n \n     #[test]\n     fn test_components_iter() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2321,7 +2299,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", [b\"a\", b\"b\", b\"c\"]);\n         t!(s: \".\", [b\".\"]);\n@@ -2330,7 +2308,7 @@ mod tests {\n \n     #[test]\n     fn test_make_non_verbatim() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2339,7 +2317,7 @@ mod tests {\n                     assert!(make_non_verbatim(&path) == exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(r\"\\a\\b\\c\", Some(r\"\\a\\b\\c\"));\n         t!(r\"a\\b\\c\", Some(r\"a\\b\\c\"));"}, {"sha": "0496944dbaf88e081424a09fe7514099bcca4381", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -35,5 +35,7 @@\n //! pervasive that it would be obnoxious to import for every use, particularly\n //! those that define methods on primitive types.\n \n+#![stable]\n+\n #[stable]\n pub mod v1;"}, {"sha": "9e9a483e1a5e3f510922eb6ae9b652eda2848162", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -25,11 +25,9 @@\n #[stable] #[doc(no_inline)] pub use char::CharExt;\n #[stable] #[doc(no_inline)] pub use clone::Clone;\n #[stable] #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n-#[stable] #[doc(no_inline)] pub use iter::CloneIteratorExt;\n #[stable] #[doc(no_inline)] pub use iter::DoubleEndedIterator;\n #[stable] #[doc(no_inline)] pub use iter::ExactSizeIterator;\n #[stable] #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n-#[stable] #[doc(no_inline)] pub use iter::{IteratorCloneExt, IteratorOrdExt};\n #[stable] #[doc(no_inline)] pub use option::Option::{self, Some, None};\n #[stable] #[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n #[stable] #[doc(no_inline)] pub use result::Result::{self, Ok, Err};"}, {"sha": "8855a7e5293ac18a04566cfc05cfccef1c6761f9", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -245,7 +245,7 @@ pub mod reader;\n \n /// The standard RNG. This is designed to be efficient on the current\n /// platform.\n-#[derive(Copy)]\n+#[derive(Copy, Clone)]\n pub struct StdRng {\n     rng: IsaacWordRng,\n }\n@@ -322,6 +322,7 @@ static THREAD_RNG_RESEED_THRESHOLD: uint = 32_768;\n type ThreadRngInner = reseeding::ReseedingRng<StdRng, ThreadRngReseeder>;\n \n /// The thread-local RNG.\n+#[derive(Clone)]\n pub struct ThreadRng {\n     rng: Rc<RefCell<ThreadRngInner>>,\n }"}, {"sha": "a79a6e35ebcfd377ff74265cba1a9ec9d842d149", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -23,11 +23,14 @@ mod imp {\n     use path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n-    use result::Result::{Ok, Err};\n+    use result::Result::Ok;\n     use slice::SliceExt;\n     use mem;\n     use os::errno;\n \n+    // NOTE: for old macros; remove after the next snapshot\n+    #[cfg(stage0)] use result::Result::Err;\n+\n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\",\n                   target_arch = \"x86\","}, {"sha": "86abacb936501f63124755cd6baeef981c9c7474", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -46,8 +46,9 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n mod imp {\n     use prelude::v1::*;\n \n+    use libc;\n     use mem;\n-    use slice;\n+    use ffi;\n \n     use sync::{StaticMutex, MUTEX_INIT};\n \n@@ -95,13 +96,9 @@ mod imp {\n     }\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n+        let argv = argv as *const *const libc::c_char;\n         range(0, argc as uint).map(|i| {\n-            let arg = *argv.offset(i as int);\n-            let mut len = 0u;\n-            while *arg.offset(len as int) != 0 {\n-                len += 1u;\n-            }\n-            slice::from_raw_buf(&arg, len).to_vec()\n+            ffi::c_str_to_bytes(&*argv.offset(i as int)).to_vec()\n         }).collect()\n     }\n "}, {"sha": "bb0b6fe804bea4e676c0520cee80d4539c8b95e6", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -15,7 +15,7 @@\n use prelude::v1::*;\n \n use os;\n-use sync::atomic::{mod, Ordering};\n+use sync::atomic::{self, Ordering};\n \n pub use sys::backtrace::write;\n "}, {"sha": "bbc96d0b19f125fa91ee2297e062e905ed937c76", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //! These macros call functions which are only accessible in the `rt` module, so\n //! they aren't defined anywhere outside of the `rt` module.\n \n-#![macro_escape]\n-\n macro_rules! rterrln {\n     ($fmt:expr $($arg:tt)*) => ( {\n         ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\") $($arg)*))"}, {"sha": "e556888a470a288b100364bf8fd29aaae1ae94bf", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -39,6 +39,8 @@ pub use alloc::heap;\n pub mod backtrace;\n \n // Internals\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod macros;\n \n // These should be refactored/moved/made private over time"}, {"sha": "71169386c186aee9400b363232787cf25c4a64af", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -67,7 +67,7 @@ use fmt;\n use intrinsics;\n use libc::c_void;\n use mem;\n-use sync::atomic::{mod, Ordering};\n+use sync::atomic::{self, Ordering};\n use sync::{Once, ONCE_INIT};\n \n use rt::libunwind as uw;"}, {"sha": "bc01ce926f8bc4306c43732cfdc51f8a546506af", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -19,7 +19,7 @@ use libc::{self, uintptr_t};\n use os;\n use slice;\n use str;\n-use sync::atomic::{mod, Ordering};\n+use sync::atomic::{self, Ordering};\n \n /// Dynamically inquire about whether we're running under V.\n /// You should usually not use this unless your test definitely"}, {"sha": "e97be51fdbc25af6ccc56aec377ee00aee43173a", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -188,6 +188,7 @@ impl Condvar {\n     pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n }\n \n+#[stable]\n impl Drop for Condvar {\n     fn drop(&mut self) {\n         unsafe { self.inner.inner.destroy() }"}, {"sha": "6fff6765bd34879c3e9d246de2b00c034fe6fec9", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -15,15 +15,15 @@\n //! and/or blocking at all, but rather provide the necessary tools to build\n //! other types of concurrent primitives.\n \n-#![experimental]\n+#![stable]\n \n pub use alloc::arc::{Arc, Weak};\n pub use core::atomic;\n \n pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n pub use self::mutex::MUTEX_INIT;\n-pub use self::rwlock::{RWLock, StaticRWLock, RWLOCK_INIT};\n-pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n+pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n+pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n pub use self::once::{Once, ONCE_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};"}, {"sha": "7c18b8a43faad827cbff96a4f577e61d2b8fc19a", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -163,6 +163,8 @@\n //! }\n //! ```\n \n+#![stable]\n+\n // A description of how Rust's channel implementation works\n //\n // Channels are supposed to be the basic building block for all other\n@@ -565,6 +567,7 @@ impl<T: Send> Sender<T> {\n     /// drop(rx);\n     /// assert_eq!(tx.send(1i).err().unwrap().0, 1);\n     /// ```\n+    #[stable]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n@@ -587,7 +590,7 @@ impl<T: Send> Sender<T> {\n                                 // asleep (we're looking at it), so the receiver\n                                 // can't go away.\n                                 (*a.get()).send(t).ok().unwrap();\n-                                token.signal();\n+                        token.signal();\n                                 (a, Ok(()))\n                             }\n                         }\n@@ -657,6 +660,7 @@ impl<T: Send> Clone for Sender<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n@@ -720,6 +724,7 @@ impl<T: Send> Clone for SyncSender<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n         unsafe { (*self.inner.get()).drop_chan(); }\n@@ -935,14 +940,15 @@ impl<T: Send> select::Packet for Receiver<T> {\n     }\n }\n \n-#[unstable]\n+#[stable]\n impl<'a, T: Send> Iterator for Iter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {"}, {"sha": "9ad24a5a11ec5dfb61080a507b4d4a61920a8198", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -138,6 +138,7 @@ impl<T: Send> Queue<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "6b3dd89f33b07fcc71cc4a4a02cdfd7c4072ec2a", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -228,6 +228,7 @@ impl<T: Send> Mutex<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n@@ -291,20 +292,23 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n     }\n }\n \n+#[stable]\n impl<'mutex, T> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.__data.get() }\n     }\n }\n+#[stable]\n impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<'a, T> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {"}, {"sha": "aa2d957a3eb5e14bb3268b2e539fcc51e31ff939", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -121,10 +121,6 @@ impl Once {\n             unsafe { self.mutex.destroy() }\n         }\n     }\n-\n-    /// Deprecated\n-    #[deprecated = \"renamed to `call_once`\"]\n-    pub fn doit<F>(&'static self, f: F) where F: FnOnce() { self.call_once(f) }\n }\n \n #[cfg(test)]"}, {"sha": "385df45b400c41a8cebfeab79d47c92ac6c5aed5", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -49,7 +49,7 @@ pub struct Guard {\n \n /// A type of error which can be returned whenever a lock is acquired.\n ///\n-/// Both Mutexes and RWLocks are poisoned whenever a task fails while the lock\n+/// Both Mutexes and RwLocks are poisoned whenever a task fails while the lock\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error."}, {"sha": "4afd5bb63f4fec79c368880afcd2b433d23d0d48", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 87, "deletions": 81, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -31,17 +31,17 @@ use sys_common::rwlock as sys;\n ///\n /// # Poisoning\n ///\n-/// RWLocks, like Mutexes, will become poisoned on panics. Note, however, that\n-/// an RWLock may only be poisoned if a panic occurs while it is locked\n+/// RwLocks, like Mutexes, will become poisoned on panics. Note, however, that\n+/// an RwLock may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n ///\n /// # Examples\n ///\n /// ```\n-/// use std::sync::RWLock;\n+/// use std::sync::RwLock;\n ///\n-/// let lock = RWLock::new(5i);\n+/// let lock = RwLock::new(5i);\n ///\n /// // many reader locks can be held at once\n /// {\n@@ -59,26 +59,26 @@ use sys_common::rwlock as sys;\n /// } // write lock is dropped here\n /// ```\n #[stable]\n-pub struct RWLock<T> {\n-    inner: Box<StaticRWLock>,\n+pub struct RwLock<T> {\n+    inner: Box<StaticRwLock>,\n     data: UnsafeCell<T>,\n }\n \n-unsafe impl<T:'static+Send> Send for RWLock<T> {}\n-unsafe impl<T> Sync for RWLock<T> {}\n+unsafe impl<T:'static+Send> Send for RwLock<T> {}\n+unsafe impl<T> Sync for RwLock<T> {}\n \n-/// Structure representing a statically allocated RWLock.\n+/// Structure representing a statically allocated RwLock.\n ///\n /// This structure is intended to be used inside of a `static` and will provide\n /// automatic global access as well as lazy initialization. The internal\n-/// resources of this RWLock, however, must be manually deallocated.\n+/// resources of this RwLock, however, must be manually deallocated.\n ///\n /// # Example\n ///\n /// ```\n-/// use std::sync::{StaticRWLock, RWLOCK_INIT};\n+/// use std::sync::{StaticRwLock, RW_LOCK_INIT};\n ///\n-/// static LOCK: StaticRWLock = RWLOCK_INIT;\n+/// static LOCK: StaticRwLock = RW_LOCK_INIT;\n ///\n /// {\n ///     let _g = LOCK.read().unwrap();\n@@ -90,18 +90,18 @@ unsafe impl<T> Sync for RWLock<T> {}\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n-#[unstable = \"may be merged with RWLock in the future\"]\n-pub struct StaticRWLock {\n+#[unstable = \"may be merged with RwLock in the future\"]\n+pub struct StaticRwLock {\n     lock: sys::RWLock,\n     poison: poison::Flag,\n }\n \n-unsafe impl Send for StaticRWLock {}\n-unsafe impl Sync for StaticRWLock {}\n+unsafe impl Send for StaticRwLock {}\n+unsafe impl Sync for StaticRwLock {}\n \n /// Constant initialization for a statically-initialized rwlock.\n-#[unstable = \"may be merged with RWLock in the future\"]\n-pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n+#[unstable = \"may be merged with RwLock in the future\"]\n+pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n     lock: sys::RWLOCK_INIT,\n     poison: poison::FLAG_INIT,\n };\n@@ -110,8 +110,8 @@ pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n /// dropped.\n #[must_use]\n #[stable]\n-pub struct RWLockReadGuard<'a, T: 'a> {\n-    __lock: &'a StaticRWLock,\n+pub struct RwLockReadGuard<'a, T: 'a> {\n+    __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __marker: marker::NoSend,\n }\n@@ -120,18 +120,18 @@ pub struct RWLockReadGuard<'a, T: 'a> {\n /// dropped.\n #[must_use]\n #[stable]\n-pub struct RWLockWriteGuard<'a, T: 'a> {\n-    __lock: &'a StaticRWLock,\n+pub struct RwLockWriteGuard<'a, T: 'a> {\n+    __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n     __marker: marker::NoSend,\n }\n \n-impl<T: Send + Sync> RWLock<T> {\n-    /// Creates a new instance of an RWLock which is unlocked and read to go.\n+impl<T: Send + Sync> RwLock<T> {\n+    /// Creates a new instance of an RwLock which is unlocked and read to go.\n     #[stable]\n-    pub fn new(t: T) -> RWLock<T> {\n-        RWLock { inner: box RWLOCK_INIT, data: UnsafeCell::new(t) }\n+    pub fn new(t: T) -> RwLock<T> {\n+        RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }\n     }\n \n     /// Locks this rwlock with shared read access, blocking the current thread\n@@ -148,14 +148,14 @@ impl<T: Send + Sync> RWLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// The failure will occur immediately after the lock has been acquired.\n     #[inline]\n     #[stable]\n-    pub fn read(&self) -> LockResult<RWLockReadGuard<T>> {\n+    pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n         unsafe { self.inner.lock.read() }\n-        RWLockReadGuard::new(&*self.inner, &self.data)\n+        RwLockReadGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n@@ -169,15 +169,15 @@ impl<T: Send + Sync> RWLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n     #[stable]\n-    pub fn try_read(&self) -> TryLockResult<RWLockReadGuard<T>> {\n+    pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n-            Ok(try!(RWLockReadGuard::new(&*self.inner, &self.data)))\n+            Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -194,14 +194,14 @@ impl<T: Send + Sync> RWLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// An error will be returned when the lock is acquired.\n     #[inline]\n     #[stable]\n-    pub fn write(&self) -> LockResult<RWLockWriteGuard<T>> {\n+    pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n         unsafe { self.inner.lock.write() }\n-        RWLockWriteGuard::new(&*self.inner, &self.data)\n+        RwLockWriteGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n@@ -212,23 +212,24 @@ impl<T: Send + Sync> RWLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n     #[stable]\n-    pub fn try_write(&self) -> TryLockResult<RWLockWriteGuard<T>> {\n+    pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n-            Ok(try!(RWLockWriteGuard::new(&*self.inner, &self.data)))\n+            Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n     }\n }\n \n #[unsafe_destructor]\n-impl<T> Drop for RWLock<T> {\n+#[stable]\n+impl<T> Drop for RwLock<T> {\n     fn drop(&mut self) {\n         unsafe { self.inner.lock.destroy() }\n     }\n@@ -238,27 +239,27 @@ struct Dummy(UnsafeCell<()>);\n unsafe impl Sync for Dummy {}\n static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n \n-impl StaticRWLock {\n+impl StaticRwLock {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n-    /// See `RWLock::read`.\n+    /// See `RwLock::read`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n-    pub fn read(&'static self) -> LockResult<RWLockReadGuard<'static, ()>> {\n+    #[unstable = \"may be merged with RwLock in the future\"]\n+    pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n         unsafe { self.lock.read() }\n-        RWLockReadGuard::new(self, &DUMMY.0)\n+        RwLockReadGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n     ///\n-    /// See `RWLock::try_read`.\n+    /// See `RwLock::try_read`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub fn try_read(&'static self)\n-                    -> TryLockResult<RWLockReadGuard<'static, ()>> {\n+                    -> TryLockResult<RwLockReadGuard<'static, ()>> {\n         if unsafe { self.lock.try_read() } {\n-            Ok(try!(RWLockReadGuard::new(self, &DUMMY.0)))\n+            Ok(try!(RwLockReadGuard::new(self, &DUMMY.0)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -267,23 +268,23 @@ impl StaticRWLock {\n     /// Lock this rwlock with exclusive write access, blocking the current\n     /// thread until it can be acquired.\n     ///\n-    /// See `RWLock::write`.\n+    /// See `RwLock::write`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n-    pub fn write(&'static self) -> LockResult<RWLockWriteGuard<'static, ()>> {\n+    #[unstable = \"may be merged with RwLock in the future\"]\n+    pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n         unsafe { self.lock.write() }\n-        RWLockWriteGuard::new(self, &DUMMY.0)\n+        RwLockWriteGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n     ///\n-    /// See `RWLock::try_write`.\n+    /// See `RwLock::try_write`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub fn try_write(&'static self)\n-                     -> TryLockResult<RWLockWriteGuard<'static, ()>> {\n+                     -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n         if unsafe { self.lock.try_write() } {\n-            Ok(try!(RWLockWriteGuard::new(self, &DUMMY.0)))\n+            Ok(try!(RwLockWriteGuard::new(self, &DUMMY.0)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -295,29 +296,29 @@ impl StaticRWLock {\n     /// active users of the lock, and this also doesn't prevent any future users\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n }\n \n-impl<'rwlock, T> RWLockReadGuard<'rwlock, T> {\n-    fn new(lock: &'rwlock StaticRWLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RWLockReadGuard<'rwlock, T>> {\n+impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n+    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n-            RWLockReadGuard {\n+            RwLockReadGuard {\n                 __lock: lock,\n                 __data: data,\n                 __marker: marker::NoSend,\n             }\n         })\n     }\n }\n-impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n-    fn new(lock: &'rwlock StaticRWLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RWLockWriteGuard<'rwlock, T>> {\n+impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n+    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n-            RWLockWriteGuard {\n+            RwLockWriteGuard {\n                 __lock: lock,\n                 __data: data,\n                 __poison: guard,\n@@ -327,31 +328,36 @@ impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n     }\n }\n \n-impl<'rwlock, T> Deref for RWLockReadGuard<'rwlock, T> {\n+#[stable]\n+impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-impl<'rwlock, T> Deref for RWLockWriteGuard<'rwlock, T> {\n+#[stable]\n+impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-impl<'rwlock, T> DerefMut for RWLockWriteGuard<'rwlock, T> {\n+#[stable]\n+impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-impl<'a, T> Drop for RWLockReadGuard<'a, T> {\n+#[stable]\n+impl<'a, T> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[unsafe_destructor]\n-impl<'a, T> Drop for RWLockWriteGuard<'a, T> {\n+#[stable]\n+impl<'a, T> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);\n         unsafe { self.__lock.lock.write_unlock(); }\n@@ -365,11 +371,11 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread::Thread;\n-    use sync::{Arc, RWLock, StaticRWLock, RWLOCK_INIT};\n+    use sync::{Arc, RwLock, StaticRwLock, RW_LOCK_INIT};\n \n     #[test]\n     fn smoke() {\n-        let l = RWLock::new(());\n+        let l = RwLock::new(());\n         drop(l.read().unwrap());\n         drop(l.write().unwrap());\n         drop((l.read().unwrap(), l.read().unwrap()));\n@@ -378,7 +384,7 @@ mod tests {\n \n     #[test]\n     fn static_smoke() {\n-        static R: StaticRWLock = RWLOCK_INIT;\n+        static R: StaticRwLock = RW_LOCK_INIT;\n         drop(R.read().unwrap());\n         drop(R.write().unwrap());\n         drop((R.read().unwrap(), R.read().unwrap()));\n@@ -388,7 +394,7 @@ mod tests {\n \n     #[test]\n     fn frob() {\n-        static R: StaticRWLock = RWLOCK_INIT;\n+        static R: StaticRwLock = RW_LOCK_INIT;\n         static N: uint = 10;\n         static M: uint = 1000;\n \n@@ -414,7 +420,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_poison_wr() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n@@ -425,7 +431,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_poison_ww() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n@@ -436,7 +442,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n@@ -447,7 +453,7 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n@@ -459,7 +465,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc() {\n-        let arc = Arc::new(RWLock::new(0i));\n+        let arc = Arc::new(RwLock::new(0i));\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n@@ -497,11 +503,11 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_access_in_unwind() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _ = Thread::spawn(move|| -> () {\n             struct Unwinder {\n-                i: Arc<RWLock<int>>,\n+                i: Arc<RwLock<int>>,\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {"}, {"sha": "505819fbf8a246cf4ee618b64e89cb921dd8d8a7", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -99,6 +99,7 @@ impl Semaphore {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<'a> Drop for SemaphoreGuard<'a> {\n     fn drop(&mut self) {\n         self.sem.release();"}, {"sha": "a31dcc9884f465fa74c4311f443ac670853c0dac", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -14,7 +14,7 @@\n use io::{self, IoError, IoResult};\n use prelude::v1::*;\n use sys::{last_error, retry};\n-use c_str::CString;\n+use ffi::CString;\n use num::Int;\n use path::BytesContainer;\n use collections;"}, {"sha": "4cf891ac4985eba360859a1cff038719ce3ca9a8", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,15 +12,16 @@ use prelude::v1::*;\n use self::SocketStatus::*;\n use self::InAddr::*;\n \n-use c_str::ToCStr;\n+use ffi::CString;\n+use ffi;\n use io::net::addrinfo;\n use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n use io::{IoResult, IoError};\n use libc::{self, c_char, c_int};\n-use c_str::CString;\n use mem;\n use num::Int;\n use ptr::{self, null, null_mut};\n+use str;\n use sys::{self, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n           wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n           decode_error_detailed};\n@@ -234,9 +235,9 @@ pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n \n     assert!(host.is_some() || servname.is_some());\n \n-    let c_host = host.map(|x| x.to_c_str());\n+    let c_host = host.map(|x| CString::from_slice(x.as_bytes()));\n     let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-    let c_serv = servname.map(|x| x.to_c_str());\n+    let c_serv = servname.map(|x| CString::from_slice(x.as_bytes()));\n     let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n \n     let hint = hint.map(|hint| {\n@@ -324,7 +325,8 @@ pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n     }\n \n     unsafe {\n-        Ok(CString::new(hostbuf.as_ptr(), false).as_str().unwrap().to_string())\n+        Ok(str::from_utf8(ffi::c_str_to_bytes(&hostbuf.as_ptr()))\n+               .unwrap().to_string())\n     }\n }\n "}, {"sha": "ca268a8f27ff34680a915eff95255b7f4acd2093", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -83,12 +83,13 @@\n /// to symbols. This is a bit of a hokey implementation as-is, but it works for\n /// all unix platforms we support right now, so it at least gets the job done.\n \n-use c_str::CString;\n-use io::{IoResult, Writer};\n+use prelude::v1::*;\n+\n+use ffi;\n+use io::IoResult;\n use libc;\n use mem;\n-use option::Option::{self, Some, None};\n-use result::Result::{Ok, Err};\n+use str;\n use sync::{StaticMutex, MUTEX_INIT};\n \n use sys_common::backtrace::*;\n@@ -105,9 +106,7 @@ use sys_common::backtrace::*;\n #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n #[inline(never)]\n pub fn write(w: &mut Writer) -> IoResult<()> {\n-    use iter::{IteratorExt, range};\n     use result;\n-    use slice::SliceExt;\n \n     extern {\n         fn backtrace(buf: *mut *mut libc::c_void,\n@@ -234,19 +233,15 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         output(w, idx,addr, None)\n     } else {\n         output(w, idx, addr, Some(unsafe {\n-            CString::new(info.dli_sname, false)\n+            ffi::c_str_to_bytes(&info.dli_sname)\n         }))\n     }\n }\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-    use iter::{Iterator, IteratorExt};\n     use os;\n-    use path::GenericPath;\n-    use ptr::PtrExt;\n     use ptr;\n-    use slice::SliceExt;\n \n     ////////////////////////////////////////////////////////////////////////\n     // libbacktrace.h API\n@@ -368,15 +363,15 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n     if ret == 0 || data.is_null() {\n         output(w, idx, addr, None)\n     } else {\n-        output(w, idx, addr, Some(unsafe { CString::new(data, false) }))\n+        output(w, idx, addr, Some(unsafe { ffi::c_str_to_bytes(&data) }))\n     }\n }\n \n // Finally, after all that work above, we can emit a symbol.\n fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n-          s: Option<CString>) -> IoResult<()> {\n+          s: Option<&[u8]>) -> IoResult<()> {\n     try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, HEX_WIDTH));\n-    match s.as_ref().and_then(|c| c.as_str()) {\n+    match s.and_then(|s| str::from_utf8(s).ok()) {\n         Some(string) => try!(demangle(w, string)),\n         None => try!(write!(w, \"<unknown>\")),\n     }"}, {"sha": "1ad775517bba714aac62f8ea639ed31660d1d935", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,7 +12,7 @@\n \n use prelude::v1::*;\n \n-use c_str::{CString, ToCStr};\n+use ffi::{self, CString};\n use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use io::{IoResult, FileStat, SeekStyle};\n use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n@@ -150,6 +150,10 @@ impl Drop for FileDesc {\n     }\n }\n \n+fn cstr(path: &Path) -> CString {\n+    CString::from_slice(path.as_vec())\n+}\n+\n pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n     let flags = match fm {\n         Open => 0,\n@@ -165,15 +169,15 @@ pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n                             libc::S_IRUSR | libc::S_IWUSR),\n     };\n \n-    let path = path.to_c_str();\n+    let path = cstr(path);\n     match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n         -1 => Err(super::last_error()),\n         fd => Ok(FileDesc::new(fd, true)),\n     }\n }\n \n pub fn mkdir(p: &Path, mode: uint) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(unsafe { libc::mkdir(p.as_ptr(), mode as libc::mode_t) })\n }\n \n@@ -182,7 +186,6 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n     use libc::{opendir, readdir_r, closedir};\n \n     fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n-        let root = unsafe { CString::new(root.as_ptr(), false) };\n         let root = Path::new(root);\n \n         dirs.into_iter().filter(|path| {\n@@ -199,18 +202,17 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n     let mut buf = Vec::<u8>::with_capacity(size as uint);\n     let ptr = buf.as_mut_ptr() as *mut dirent_t;\n \n-    let p = p.to_c_str();\n+    let p = CString::from_slice(p.as_vec());\n     let dir_ptr = unsafe {opendir(p.as_ptr())};\n \n     if dir_ptr as uint != 0 {\n         let mut paths = vec!();\n         let mut entry_ptr = 0 as *mut dirent_t;\n         while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n             if entry_ptr.is_null() { break }\n-            let cstr = unsafe {\n-                CString::new(rust_list_dir_val(entry_ptr), false)\n-            };\n-            paths.push(Path::new(cstr));\n+            paths.push(unsafe {\n+                Path::new(ffi::c_str_to_bytes(&rust_list_dir_val(entry_ptr)))\n+            });\n         }\n         assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n         Ok(prune(&p, paths))\n@@ -220,39 +222,39 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n }\n \n pub fn unlink(p: &Path) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(unsafe { libc::unlink(p.as_ptr()) })\n }\n \n pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n-    let old = old.to_c_str();\n-    let new = new.to_c_str();\n+    let old = cstr(old);\n+    let new = cstr(new);\n     mkerr_libc(unsafe {\n         libc::rename(old.as_ptr(), new.as_ptr())\n     })\n }\n \n pub fn chmod(p: &Path, mode: uint) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(retry(|| unsafe {\n         libc::chmod(p.as_ptr(), mode as libc::mode_t)\n     }))\n }\n \n pub fn rmdir(p: &Path) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(unsafe { libc::rmdir(p.as_ptr()) })\n }\n \n pub fn chown(p: &Path, uid: int, gid: int) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     mkerr_libc(retry(|| unsafe {\n         libc::chown(p.as_ptr(), uid as libc::uid_t, gid as libc::gid_t)\n     }))\n }\n \n pub fn readlink(p: &Path) -> IoResult<Path> {\n-    let c_path = p.to_c_str();\n+    let c_path = cstr(p);\n     let p = c_path.as_ptr();\n     let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n     if len == -1 {\n@@ -273,14 +275,14 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    let src = src.to_c_str();\n-    let dst = dst.to_c_str();\n+    let src = cstr(src);\n+    let dst = cstr(dst);\n     mkerr_libc(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })\n }\n \n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    let src = src.to_c_str();\n-    let dst = dst.to_c_str();\n+    let src = cstr(src);\n+    let dst = cstr(dst);\n     mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })\n }\n \n@@ -328,7 +330,7 @@ fn mkstat(stat: &libc::stat) -> FileStat {\n }\n \n pub fn stat(p: &Path) -> IoResult<FileStat> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match unsafe { libc::stat(p.as_ptr(), &mut stat) } {\n         0 => Ok(mkstat(&stat)),\n@@ -337,7 +339,7 @@ pub fn stat(p: &Path) -> IoResult<FileStat> {\n }\n \n pub fn lstat(p: &Path) -> IoResult<FileStat> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match unsafe { libc::lstat(p.as_ptr(), &mut stat) } {\n         0 => Ok(mkstat(&stat)),\n@@ -346,7 +348,7 @@ pub fn lstat(p: &Path) -> IoResult<FileStat> {\n }\n \n pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    let p = p.to_c_str();\n+    let p = cstr(p);\n     let buf = libc::utimbuf {\n         actime: (atime / 1000) as libc::time_t,\n         modtime: (mtime / 1000) as libc::time_t,"}, {"sha": "6a408aa60f0bfb2aa8bbcbbf8fe3a691fb681e0e", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -15,12 +15,14 @@\n #![allow(unused_unsafe)]\n #![allow(unused_mut)]\n \n-extern crate libc;\n-\n-use num;\n-use num::{Int, SignedInt};\n use prelude::v1::*;\n+\n+use ffi;\n use io::{self, IoResult, IoError};\n+use libc;\n+use num::{Int, SignedInt};\n+use num;\n+use str;\n use sys_common::mkerr_libc;\n \n macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n@@ -78,11 +80,10 @@ extern \"system\" {\n }\n \n pub fn last_gai_error(s: libc::c_int) -> IoError {\n-    use c_str::CString;\n \n     let mut err = decode_error(s);\n     err.detail = Some(unsafe {\n-        CString::new(gai_strerror(s), false).as_str().unwrap().to_string()\n+        str::from_utf8(ffi::c_str_to_bytes(&gai_strerror(s))).unwrap().to_string()\n     });\n     err\n }"}, {"sha": "175c4e2e353f91044fa0453395c27f173671a870", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,18 +12,18 @@\n \n use prelude::v1::*;\n \n-use c_str::ToCStr;\n use error::{FromError, Error};\n+use ffi::{self, CString};\n use fmt;\n use io::{IoError, IoResult};\n use libc::{self, c_int, c_char, c_void};\n+use os::TMPBUF_SZ;\n use os;\n use path::{BytesContainer};\n use ptr;\n+use str;\n use sys::fs::FileDesc;\n \n-use os::TMPBUF_SZ;\n-\n const BUF_BYTES : uint = 2048u;\n \n /// Returns the platform-specific value of errno\n@@ -108,7 +108,8 @@ pub fn error_string(errno: i32) -> String {\n             panic!(\"strerror_r failure\");\n         }\n \n-        String::from_raw_buf(p as *const u8)\n+        let p = p as *const _;\n+        str::from_utf8(ffi::c_str_to_bytes(&p)).unwrap().to_string()\n     }\n }\n \n@@ -122,21 +123,17 @@ pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n }\n \n pub fn getcwd() -> IoResult<Path> {\n-    use c_str::CString;\n-\n     let mut buf = [0 as c_char; BUF_BYTES];\n     unsafe {\n         if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n             Err(IoError::last_error())\n         } else {\n-            Ok(Path::new(CString::new(buf.as_ptr(), false)))\n+            Ok(Path::new(ffi::c_str_to_bytes(&buf.as_ptr())))\n         }\n     }\n }\n \n pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-    use c_str::CString;\n-\n     extern {\n         fn rust_env_pairs() -> *const *const c_char;\n     }\n@@ -147,8 +144,7 @@ pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n     }\n     let mut result = Vec::new();\n     while *environ != 0 as *const _ {\n-        let env_pair =\n-            CString::new(*environ, false).as_bytes_no_nul().to_vec();\n+        let env_pair = ffi::c_str_to_bytes(&*environ).to_vec();\n         result.push(env_pair);\n         environ = environ.offset(1);\n     }\n@@ -234,14 +230,13 @@ pub fn load_self() -> Option<Vec<u8>> {\n }\n \n pub fn chdir(p: &Path) -> IoResult<()> {\n-    p.with_c_str(|buf| {\n-        unsafe {\n-            match libc::chdir(buf) == (0 as c_int) {\n-                true => Ok(()),\n-                false => Err(IoError::last_error()),\n-            }\n+    let p = CString::from_slice(p.as_vec());\n+    unsafe {\n+        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n+            true => Ok(()),\n+            false => Err(IoError::last_error()),\n         }\n-    })\n+    }\n }\n \n pub fn page_size() -> uint {"}, {"sha": "158a1ce220411439bfeb2f188fdb002bf12ed14d", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,8 +10,8 @@\n \n use prelude::v1::*;\n \n+use ffi::CString;\n use libc;\n-use c_str::CString;\n use mem;\n use sync::{Arc, Mutex};\n use sync::atomic::{AtomicBool, Ordering};\n@@ -48,7 +48,7 @@ fn addr_to_sockaddr_un(addr: &CString,\n     }\n     s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n     for (slot, value) in s.sun_path.iter_mut().zip(addr.iter()) {\n-        *slot = value;\n+        *slot = *value;\n     }\n \n     // count the null terminator"}, {"sha": "5bc6b0c703b1c9c90057820cb37f2880bec164aa", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -11,8 +11,8 @@\n use prelude::v1::*;\n use self::Req::*;\n \n-use c_str::{CString, ToCStr};\n use collections;\n+use ffi::CString;\n use hash::Hash;\n use io::process::{ProcessExit, ExitStatus, ExitSignal};\n use io::{self, IoResult, IoError, EndOfFile};\n@@ -101,7 +101,7 @@ impl Process {\n \n                 // We may use this in the child, so perform allocations before the\n                 // fork\n-                let devnull = \"/dev/null\".to_c_str();\n+                let devnull = b\"/dev/null\\0\";\n \n                 set_cloexec(output.fd());\n \n@@ -204,7 +204,7 @@ impl Process {\n                             } else {\n                                 libc::O_RDWR\n                             };\n-                            libc::open(devnull.as_ptr(), flags, 0)\n+                            libc::open(devnull.as_ptr() as *const _, flags, 0)\n                         }\n                         Some(obj) => {\n                             let fd = obj.as_inner().fd();"}, {"sha": "62f3242a2062580360ee277bc83ce9be8cf97767", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -54,7 +54,7 @@ use libc;\n use mem;\n use os;\n use ptr;\n-use sync::atomic::{mod, Ordering};\n+use sync::atomic::{self, Ordering};\n use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n use sys::c;\n use sys::fs::FileDesc;"}, {"sha": "4ccecfd1f5f2e6cc35f754cbe7049dcd23181388", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -21,7 +21,8 @@\n /// copy of that function in my mingw install (maybe it was broken?). Instead,\n /// this takes the route of using StackWalk64 in order to walk the stack.\n \n-use c_str::CString;\n+use dynamic_lib::DynamicLibrary;\n+use ffi;\n use intrinsics;\n use io::{IoResult, Writer};\n use libc;\n@@ -30,10 +31,9 @@ use ops::Drop;\n use option::Option::{Some, None};\n use path::Path;\n use result::Result::{Ok, Err};\n-use sync::{StaticMutex, MUTEX_INIT};\n use slice::SliceExt;\n-use str::StrExt;\n-use dynamic_lib::DynamicLibrary;\n+use str::{self, StrExt};\n+use sync::{StaticMutex, MUTEX_INIT};\n \n use sys_common::backtrace::*;\n \n@@ -357,11 +357,11 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n \n         if ret == libc::TRUE {\n             try!(write!(w, \" - \"));\n-            let cstr = unsafe { CString::new(info.Name.as_ptr(), false) };\n-            let bytes = cstr.as_bytes();\n-            match cstr.as_str() {\n-                Some(s) => try!(demangle(w, s)),\n-                None => try!(w.write(bytes[..bytes.len()-1])),\n+            let ptr = info.Name.as_ptr() as *const libc::c_char;\n+            let bytes = unsafe { ffi::c_str_to_bytes(&ptr) };\n+            match str::from_utf8(bytes) {\n+                Ok(s) => try!(demangle(w, s)),\n+                Err(..) => try!(w.write(bytes[..bytes.len()-1])),\n             }\n         }\n         try!(w.write(&['\\n' as u8]));"}, {"sha": "945c2e8e7d156ce501ca029f5b54483123a3acd5", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -133,7 +133,7 @@ pub mod compat {\n     use intrinsics::{atomic_store_relaxed, transmute};\n     use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n     use prelude::v1::*;\n-    use c_str::ToCStr;\n+    use ffi::CString;\n \n     extern \"system\" {\n         fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n@@ -147,14 +147,13 @@ pub mod compat {\n     unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) {\n         let mut module: Vec<u16> = module.utf16_units().collect();\n         module.push(0);\n-        symbol.with_c_str(|symbol| {\n-            let handle = GetModuleHandleW(module.as_ptr());\n-            let func: uint = transmute(GetProcAddress(handle, symbol));\n-            atomic_store_relaxed(ptr, if func == 0 {\n-                fallback\n-            } else {\n-                func\n-            })\n+        let symbol = CString::from_slice(symbol.as_bytes());\n+        let handle = GetModuleHandleW(module.as_ptr());\n+        let func: uint = transmute(GetProcAddress(handle, symbol.as_ptr()));\n+        atomic_store_relaxed(ptr, if func == 0 {\n+            fallback\n+        } else {\n+            func\n         })\n     }\n "}, {"sha": "f8c75335b35dc31059790965e7c89e54f52322ec", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,7 +13,6 @@\n use alloc::arc::Arc;\n use libc::{self, c_int};\n \n-use c_str::CString;\n use mem;\n use sys::os::fill_utf16_buf_and_decode;\n use path;"}, {"sha": "9996909f2f5bbc18a9781018bd4dd4aaaf952fd1", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -87,16 +87,21 @@\n use prelude::v1::*;\n \n use libc;\n-use c_str::CString;\n+use ffi::CString;\n+use io::{self, IoError, IoResult};\n use mem;\n use ptr;\n-use sync::{Arc, Mutex};\n+use str;\n use sync::atomic::{AtomicBool, Ordering};\n-use io::{self, IoError, IoResult};\n+use sync::{Arc, Mutex};\n \n use sys_common::{self, eof};\n \n-use super::{c, os, timer, to_utf16, decode_error_detailed};\n+use super::{c, os, timer, decode_error_detailed};\n+\n+fn to_utf16(c: &CString) -> IoResult<Vec<u16>> {\n+    super::to_utf16(str::from_utf8(c.as_bytes()).ok())\n+}\n \n struct Event(libc::HANDLE);\n \n@@ -270,7 +275,7 @@ impl UnixStream {\n     }\n \n     pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> {\n-        let addr = try!(to_utf16(addr.as_str()));\n+        let addr = try!(to_utf16(addr));\n         let start = timer::now();\n         loop {\n             match UnixStream::try_connect(addr.as_ptr()) {\n@@ -571,7 +576,7 @@ impl UnixListener {\n         // Although we technically don't need the pipe until much later, we\n         // create the initial handle up front to test the validity of the name\n         // and such.\n-        let addr_v = try!(to_utf16(addr.as_str()));\n+        let addr_v = try!(to_utf16(addr));\n         let ret = unsafe { pipe(addr_v.as_ptr(), true) };\n         if ret == libc::INVALID_HANDLE_VALUE {\n             Err(super::last_error())\n@@ -661,7 +666,7 @@ impl UnixAcceptor {\n         // proceed in accepting new clients in the future\n         if self.inner.closed.load(Ordering::SeqCst) { return Err(eof()) }\n \n-        let name = try!(to_utf16(self.listener.name.as_str()));\n+        let name = try!(to_utf16(&self.listener.name));\n \n         // Once we've got a \"server handle\", we need to wait for a client to\n         // connect. The ConnectNamedPipe function will block this thread until\n@@ -753,7 +758,7 @@ impl UnixAcceptor {\n \n impl Clone for UnixAcceptor {\n     fn clone(&self) -> UnixAcceptor {\n-        let name = to_utf16(self.listener.name.as_str()).ok().unwrap();\n+        let name = to_utf16(&self.listener.name).ok().unwrap();\n         UnixAcceptor {\n             inner: self.inner.clone(),\n             event: Event::new(true, false).ok().unwrap(),"}, {"sha": "7b667416b171418f0dedaaedaf6694a8de70da59", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,27 +10,26 @@\n \n use prelude::v1::*;\n \n+use collections;\n+use ffi::CString;\n+use hash::Hash;\n+use io::fs::PathExtensions;\n+use io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use io::{IoResult, IoError};\n+use io;\n use libc::{pid_t, c_void, c_int};\n use libc;\n-use c_str::{CString, ToCStr};\n-use io;\n use mem;\n use os;\n-use ptr;\n-use io::process::{ProcessExit, ExitStatus, ExitSignal};\n-use collections;\n use path::BytesContainer;\n-use hash::Hash;\n-use io::{IoResult, IoError};\n-\n+use ptr;\n+use str;\n+use sys::fs::FileDesc;\n use sys::fs;\n use sys::{self, retry, c, wouldblock, set_nonblocking, ms_to_timeval, timer};\n-use sys::fs::FileDesc;\n use sys_common::helper_thread::Helper;\n use sys_common::{AsInner, mkerr_libc, timeout};\n \n-use io::fs::PathExtensions;\n-\n pub use sys_common::ProcessConfig;\n \n /// A value representing a child process.\n@@ -142,10 +141,10 @@ impl Process {\n                 // Split the value and test each path to see if the\n                 // program exists.\n                 for path in os::split_paths(v.container_as_bytes()).into_iter() {\n-                    let path = path.join(cfg.program().as_bytes_no_nul())\n+                    let path = path.join(cfg.program().as_bytes())\n                                    .with_extension(os::consts::EXE_EXTENSION);\n                     if path.exists() {\n-                        return Some(path.to_c_str())\n+                        return Some(CString::from_slice(path.as_vec()))\n                     }\n                 }\n                 break\n@@ -363,11 +362,11 @@ fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMA\n \n fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     let mut cmd = String::new();\n-    append_arg(&mut cmd, prog.as_str()\n+    append_arg(&mut cmd, str::from_utf8(prog.as_bytes()).ok()\n                              .expect(\"expected program name to be utf-8 encoded\"));\n     for arg in args.iter() {\n         cmd.push(' ');\n-        append_arg(&mut cmd, arg.as_str()\n+        append_arg(&mut cmd, str::from_utf8(arg.as_bytes()).ok()\n                                 .expect(\"expected argument to be utf-8 encoded\"));\n     }\n     return cmd;\n@@ -449,7 +448,7 @@ fn with_dirp<T, F>(d: Option<&CString>, cb: F) -> T where\n {\n     match d {\n       Some(dir) => {\n-          let dir_str = dir.as_str()\n+          let dir_str = str::from_utf8(dir.as_bytes()).ok()\n                            .expect(\"expected workingdirectory to be utf-8 encoded\");\n           let mut dir_str: Vec<u16> = dir_str.utf16_units().collect();\n           dir_str.push(0);\n@@ -467,19 +466,17 @@ fn free_handle(handle: *mut ()) {\n \n #[cfg(test)]\n mod tests {\n-    use c_str::ToCStr;\n+    use prelude::v1::*;\n+    use str;\n+    use ffi::CString;\n+    use super::make_command_line;\n \n     #[test]\n     fn test_make_command_line() {\n-        use prelude::v1::*;\n-        use str;\n-        use c_str::CString;\n-        use super::make_command_line;\n-\n         fn test_wrapper(prog: &str, args: &[&str]) -> String {\n-            make_command_line(&prog.to_c_str(),\n+            make_command_line(&CString::from_slice(prog.as_bytes()),\n                               args.iter()\n-                                  .map(|a| a.to_c_str())\n+                                  .map(|a| CString::from_slice(a.as_bytes()))\n                                   .collect::<Vec<CString>>()\n                                   .as_slice())\n         }"}, {"sha": "cc82d38ae2af1f01140701dd4e6894296fc594d6", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -423,6 +423,7 @@ impl<T: Send> JoinGuard<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for JoinGuard<T> {\n     fn drop(&mut self) {\n         if !self.joined {"}, {"sha": "e0cbaa8ca50edbbb99c63a147445d1951f8551a7", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -34,13 +34,14 @@\n //! will want to make use of some form of **interior mutability** through the\n //! `Cell` or `RefCell` types.\n \n-#![macro_escape]\n #![stable]\n \n use prelude::v1::*;\n \n use cell::UnsafeCell;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod scoped;\n \n // Sure wish we had macro hygiene, no?"}, {"sha": "714b71d5dbd4e75364c4ee165a32dc8b8eafc10b", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -38,7 +38,6 @@\n //! });\n //! ```\n \n-#![macro_escape]\n #![unstable = \"scoped TLS has yet to have wide enough use to fully consider \\\n                stabilizing its interface\"]\n "}, {"sha": "ac1f0c5d803ac6a5b5b1e37a0a5fa7c51644c198", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -17,8 +17,10 @@ use ops::{Add, Sub, Mul, Div, Neg, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n use num::Int;\n-use result::Result;\n-use result::Result::{Ok, Err};\n+use result::Result::Ok;\n+\n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::Err;\n \n /// The number of nanoseconds in a microsecond.\n const NANOS_PER_MICRO: i32 = 1000;"}, {"sha": "e76dcef226ddc3e79eec371d7c8451fb1db9a4e3", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,18 +10,12 @@\n \n //! Operations on tuples\n //!\n-//! To access a single element of a tuple one can use the following\n-//! methods:\n+//! To access the _N_-th element of a tuple one can use `N` itself\n+//! as a field of the tuple.\n //!\n-//! * `valN` - returns a value of _N_-th element\n-//! * `refN` - returns a reference to _N_-th element\n-//! * `mutN` - returns a mutable reference to _N_-th element\n-//!\n-//! Indexing starts from zero, so `val0` returns first value, `val1`\n+//! Indexing starts from zero, so `0` returns first value, `1`\n //! returns second value, and so on. In general, a tuple with _S_\n-//! elements provides aforementioned methods suffixed with numbers\n-//! from `0` to `S-1`. Traits which contain these methods are\n-//! implemented for tuples with up to 12 elements.\n+//! elements provides aforementioned fields from `0` to `S-1`.\n //!\n //! If every type inside a tuple implements one of the following\n //! traits, then a tuple itself also implements it.\n@@ -35,6 +29,17 @@\n //!\n //! # Examples\n //!\n+//! Accessing elements of a tuple at specified indices:\n+//!\n+//! ```\n+//! let x = (\"colorless\",  \"green\", \"ideas\", \"sleep\", \"furiously\");\n+//! assert_eq!(x.3, \"sleep\");\n+//!\n+//! let v = (3i, 3i);\n+//! let u = (1i, -5i);\n+//! assert_eq!(v.0 * u.0 + v.1 * u.1, -12i);\n+//! ```\n+//!\n //! Using traits implemented for tuples:\n //!\n //! ```"}, {"sha": "7aa7c4fcfb3019be51d900134fb6adab37a0c81a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -476,7 +476,7 @@ pub struct Crate {\n     pub attrs: Vec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n-    pub exported_macros: Vec<P<Item>>\n+    pub exported_macros: Vec<MacroDef>,\n }\n \n pub type MetaItem = Spanned<MetaItem_>;\n@@ -572,7 +572,7 @@ pub enum Pat_ {\n     PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n     PatTup(Vec<P<Pat>>),\n     PatBox(P<Pat>),\n-    PatRegion(P<Pat>), // reference pattern\n+    PatRegion(P<Pat>, Mutability), // reference pattern\n     PatLit(P<Expr>),\n     PatRange(P<Expr>, P<Expr>),\n     /// [a, b, ..i, y, z] is represented as:\n@@ -884,6 +884,7 @@ impl TokenTree {\n         match *self {\n             TtToken(_, token::DocComment(_)) => 2,\n             TtToken(_, token::SubstNt(..)) => 2,\n+            TtToken(_, token::SpecialVarNt(..)) => 2,\n             TtToken(_, token::MatchNt(..)) => 3,\n             TtDelimited(_, ref delimed) => {\n                 delimed.tts.len() + 2\n@@ -925,6 +926,12 @@ impl TokenTree {\n                          TtToken(sp, token::Ident(name, name_st))];\n                 v[index]\n             }\n+            (&TtToken(sp, token::SpecialVarNt(var)), _) => {\n+                let v = [TtToken(sp, token::Dollar),\n+                         TtToken(sp, token::Ident(token::str_to_ident(var.as_str()),\n+                                                  token::Plain))];\n+                v[index]\n+            }\n             (&TtToken(sp, token::MatchNt(name, kind, name_st, kind_st)), _) => {\n                 let v = [TtToken(sp, token::SubstNt(name, name_st)),\n                          TtToken(sp, token::Colon),\n@@ -1689,6 +1696,21 @@ pub enum InlinedItem {\n     IIForeign(P<ForeignItem>),\n }\n \n+/// A macro definition, in this crate or imported from another.\n+///\n+/// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+pub struct MacroDef {\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub imported_from: Option<Ident>,\n+    pub export: bool,\n+    pub use_locally: bool,\n+    pub body: Vec<TokenTree>,\n+}\n+\n #[cfg(test)]\n mod test {\n     use serialize::json;"}, {"sha": "5e03afec16cf8709e1e5a92a047e87d39ef9a6b5", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -633,7 +633,7 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n             PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n                 s.iter().all(|p| walk_pat_(&**p, it))\n             }\n-            PatBox(ref s) | PatRegion(ref s) => {\n+            PatBox(ref s) | PatRegion(ref s, _) => {\n                 walk_pat_(&**s, it)\n             }\n             PatVec(ref before, ref slice, ref after) => {"}, {"sha": "34a193dffd3db5d1d7079a2bf16fa08f3c7e1aff", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n #[macro_export]\n macro_rules! register_diagnostic {\n     ($code:tt, $description:tt) => (__register_diagnostic! { $code, $description });"}, {"sha": "91ae7396ea46920b4a97f1b188e30b9a714f2438", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -16,6 +16,7 @@ use codemap;\n use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n use ext;\n use ext::expand;\n+use ext::tt::macro_rules;\n use parse;\n use parse::parser;\n use parse::token;\n@@ -28,19 +29,6 @@ use fold::Folder;\n use std::collections::HashMap;\n use std::rc::Rc;\n \n-// new-style macro! tt code:\n-//\n-//    MacResult, NormalTT, IdentTT\n-//\n-// also note that ast::Mac used to have a bunch of extraneous cases and\n-// is now probably a redundant AST node, can be merged with\n-// ast::MacInvocTT.\n-\n-pub struct MacroDef {\n-    pub name: String,\n-    pub ext: SyntaxExtension\n-}\n-\n pub trait ItemDecorator {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n@@ -140,13 +128,6 @@ impl<F> IdentMacroExpander for F\n /// methods are spliced into the AST at the callsite of the macro (or\n /// just into the compiler's internal macro table, for `make_def`).\n pub trait MacResult {\n-    /// Attempt to define a new macro.\n-    // this should go away; the idea that a macro might expand into\n-    // either a macro definition or an expression, depending on what\n-    // the context wants, is kind of silly.\n-    fn make_def(&mut self) -> Option<MacroDef> {\n-        None\n-    }\n     /// Create an expression.\n     fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n         None\n@@ -328,13 +309,8 @@ pub enum SyntaxExtension {\n     ///\n     IdentTT(Box<IdentMacroExpander + 'static>, Option<Span>),\n \n-    /// An ident macro that has two properties:\n-    /// - it adds a macro definition to the environment, and\n-    /// - the definition it adds doesn't introduce any new\n-    ///   identifiers.\n-    ///\n-    /// `macro_rules!` is a LetSyntaxTT\n-    LetSyntaxTT(Box<IdentMacroExpander + 'static>, Option<Span>),\n+    /// Represents `macro_rules!` itself.\n+    MacroRulesTT,\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n@@ -364,8 +340,7 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n     }\n \n     let mut syntax_expanders = SyntaxEnv::new();\n-    syntax_expanders.insert(intern(\"macro_rules\"),\n-                            LetSyntaxTT(box ext::tt::macro_rules::add_new_extension, None));\n+    syntax_expanders.insert(intern(\"macro_rules\"), MacroRulesTT);\n     syntax_expanders.insert(intern(\"fmt\"),\n                             builtin_normal_expander(\n                                 ext::fmt::expand_syntax_ext));\n@@ -475,7 +450,7 @@ pub struct ExtCtxt<'a> {\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n-    pub exported_macros: Vec<P<ast::Item>>,\n+    pub exported_macros: Vec<ast::MacroDef>,\n \n     pub syntax_env: SyntaxEnv,\n     pub recursion_count: uint,\n@@ -594,6 +569,17 @@ impl<'a> ExtCtxt<'a> {\n             }\n         }\n     }\n+\n+    pub fn insert_macro(&mut self, def: ast::MacroDef) {\n+        if def.export {\n+            self.exported_macros.push(def.clone());\n+        }\n+        if def.use_locally {\n+            let ext = macro_rules::compile(self, &def);\n+            self.syntax_env.insert(def.ident.name, ext);\n+        }\n+    }\n+\n     /// Emit `msg` attached to `sp`, and stop compilation immediately.\n     ///\n     /// `span_err` should be strongly preferred where-ever possible:"}, {"sha": "7cb7ee3d35533e43fa9fa4c8231cd131a3a3f3b4", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -61,7 +61,7 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n             cx, span, substr)\n     }\n \n-    macro_rules! md (\n+    macro_rules! md {\n         ($name:expr, $f:ident) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n             let attrs = vec!(cx.attribute(span, inline));\n@@ -77,7 +77,7 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n                 })\n             }\n         } }\n-    );\n+    }\n \n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "c126238be8293f8a4e0e4efecc5ff827d49bf23c", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -27,7 +27,7 @@ pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n                               push: F) where\n     F: FnOnce(P<Item>),\n {\n-    macro_rules! md (\n+    macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n             let attrs = vec!(cx.attribute(span, inline));\n@@ -43,7 +43,7 @@ pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n                 })\n             }\n         } }\n-    );\n+    }\n \n     let ordering_ty = Literal(Path::new(vec![\"std\", \"cmp\", \"Ordering\"]));\n     let ret_ty = Literal(Path::new_(vec![\"std\", \"option\", \"Option\"],"}, {"sha": "1aa430c4a08299b325ec73fd42dbb8934ffa4443", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -937,7 +937,7 @@ impl<'a> MethodDef<'a> {\n                                                                          &**variant,\n                                                                          self_arg_name,\n                                                                          ast::MutImmutable);\n-                    (cx.pat(sp, ast::PatRegion(p)), idents)\n+                    (cx.pat(sp, ast::PatRegion(p, ast::MutImmutable)), idents)\n                 };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK"}, {"sha": "844bd80d1610a4674e91f01293ab5881dd5dade1", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -25,20 +25,14 @@ pub fn expand_deriving_hash<F>(cx: &mut ExtCtxt,\n     F: FnOnce(P<Item>),\n {\n \n-    let (path, generics, args) = if cx.ecfg.deriving_hash_type_parameter {\n-        (Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,\n-                    vec!(box Literal(Path::new_local(\"__S\"))), true),\n-         LifetimeBounds {\n-             lifetimes: Vec::new(),\n-             bounds: vec!((\"__S\",\n-                           vec!(Path::new(vec!(\"std\", \"hash\", \"Writer\"))))),\n-         },\n-         Path::new_local(\"__S\"))\n-    } else {\n-        (Path::new(vec!(\"std\", \"hash\", \"Hash\")),\n-         LifetimeBounds::empty(),\n-         Path::new(vec!(\"std\", \"hash\", \"sip\", \"SipState\")))\n+    let path = Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,\n+                          vec!(box Literal(Path::new_local(\"__S\"))), true);\n+    let generics = LifetimeBounds {\n+        lifetimes: Vec::new(),\n+        bounds: vec!((\"__S\",\n+                      vec!(Path::new(vec!(\"std\", \"hash\", \"Writer\"))))),\n     };\n+    let args = Path::new_local(\"__S\");\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let hash_trait_def = TraitDef {"}, {"sha": "e72c83b67c89be435404aea043c5b9b6d0f54f62", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -71,9 +71,11 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                     MetaNameValue(ref tname, _) |\n                     MetaList(ref tname, _) |\n                     MetaWord(ref tname) => {\n-                        macro_rules! expand(($func:path) => ($func(cx, titem.span,\n-                                                                   &**titem, item,\n-                                                                   |i| push.call_mut((i,)))));\n+                        macro_rules! expand {\n+                            ($func:path) => ($func(cx, titem.span, &**titem, item,\n+                                                   |i| push.call_mut((i,))))\n+                        }\n+\n                         match tname.get() {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n "}, {"sha": "212ec3b0903252ccd9f7c418cb473c39f6bbe1bf", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 64, "deletions": 80, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use self::Either::*;\n \n use ast::{Block, Crate, DeclLocal, ExprMac, PatMac};\n use ast::{Local, Ident, MacInvocTT};\n@@ -33,11 +32,6 @@ use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n \n-enum Either<L,R> {\n-    Left(L),\n-    Right(R)\n-}\n-\n pub fn expand_type(t: P<ast::Ty>,\n                    fld: &mut MacroExpander,\n                    impl_ty: Option<P<ast::Ty>>)\n@@ -445,9 +439,9 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n             if valid_ident {\n                 fld.cx.mod_push(it.ident);\n             }\n-            let macro_escape = contains_macro_escape(new_attrs[]);\n+            let macro_use = contains_macro_use(fld, new_attrs[]);\n             let result = with_exts_frame!(fld.cx.syntax_env,\n-                                          macro_escape,\n+                                          macro_use,\n                                           noop_fold_item(it, fld));\n             if valid_ident {\n                 fld.cx.mod_pop();\n@@ -527,15 +521,34 @@ fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Ite\n     }\n }\n \n-// does this attribute list contain \"macro_escape\" ?\n-fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n-    attr::contains_name(attrs, \"macro_escape\")\n+// does this attribute list contain \"macro_use\" ?\n+fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool {\n+    for attr in attrs.iter() {\n+        let mut is_use = attr.check_name(\"macro_use\");\n+        if attr.check_name(\"macro_escape\") {\n+            fld.cx.span_warn(attr.span, \"macro_escape is a deprecated synonym for macro_use\");\n+            is_use = true;\n+            if let ast::AttrInner = attr.node.style {\n+                fld.cx.span_help(attr.span, \"consider an outer attribute, \\\n+                                             #[macro_use] mod ...\");\n+            }\n+        };\n+\n+        if is_use {\n+            match attr.node.value.node {\n+                ast::MetaWord(..) => (),\n+                _ => fld.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\"),\n+            }\n+            return true;\n+        }\n+    }\n+    false\n }\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n-                       -> SmallVector<P<ast::Item>> {\n+pub fn expand_item_mac(it: P<ast::Item>,\n+                       fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n     let (extname, path_span, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n             node: MacInvocTT(ref pth, ref tts, _),\n@@ -548,8 +561,8 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n \n     let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n-    let def_or_items = {\n-        let mut expanded = match fld.cx.syntax_env.find(&extname.name) {\n+    let items = {\n+        let expanded = match fld.cx.syntax_env.find(&extname.name) {\n             None => {\n                 fld.cx.span_err(path_span,\n                                 format!(\"macro undefined: '{}!'\",\n@@ -600,23 +613,37 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n                     let marked_tts = mark_tts(tts[], fm);\n                     expander.expand(fld.cx, it.span, it.ident, marked_tts)\n                 }\n-                LetSyntaxTT(ref expander, span) => {\n+                MacroRulesTT => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n-                                        format!(\"macro {}! expects an ident argument\",\n-                                                extnamestr.get())[]);\n+                                        format!(\"macro_rules! expects an ident argument\")[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n                             name: extnamestr.get().to_string(),\n                             format: MacroBang,\n-                            span: span\n+                            span: None,\n                         }\n                     });\n-                    // DON'T mark before expansion:\n-                    expander.expand(fld.cx, it.span, it.ident, tts)\n+                    // DON'T mark before expansion.\n+\n+                    let def = ast::MacroDef {\n+                        ident: it.ident,\n+                        attrs: it.attrs.clone(),\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: it.span,\n+                        imported_from: None,\n+                        export: attr::contains_name(it.attrs.as_slice(), \"macro_export\"),\n+                        use_locally: true,\n+                        body: tts,\n+                    };\n+                    fld.cx.insert_macro(def);\n+\n+                    // macro_rules! has a side effect but expands to nothing.\n+                    fld.cx.bt_pop();\n+                    return SmallVector::zero();\n                 }\n                 _ => {\n                     fld.cx.span_err(it.span,\n@@ -627,31 +654,17 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n             }\n         };\n \n-        match expanded.make_def() {\n-            Some(def) => Left(def),\n-            None => Right(expanded.make_items())\n-        }\n+        expanded.make_items()\n     };\n \n-    let items = match def_or_items {\n-        Left(MacroDef { name, ext }) => {\n-            // hidden invariant: this should only be possible as the\n-            // result of expanding a LetSyntaxTT, and thus doesn't\n-            // need to be marked. Not that it could be marked anyway.\n-            // create issue to recommend refactoring here?\n-            fld.cx.syntax_env.insert(intern(name[]), ext);\n-            if attr::contains_name(it.attrs[], \"macro_export\") {\n-                fld.cx.exported_macros.push(it);\n-            }\n-            SmallVector::zero()\n-        }\n-        Right(Some(items)) => {\n+    let items = match items {\n+        Some(items) => {\n             items.into_iter()\n                 .map(|i| mark_item(i, fm))\n                 .flat_map(|i| fld.fold_item(i).into_iter())\n                 .collect()\n         }\n-        Right(None) => {\n+        None => {\n             fld.cx.span_err(path_span,\n                             format!(\"non-item macro in item position: {}\",\n                                     extnamestr.get())[]);\n@@ -664,9 +677,6 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n }\n \n /// Expand a stmt\n-//\n-// I don't understand why this returns a vector... it looks like we're\n-// half done adding machinery to allow macros to expand into multiple statements.\n fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     let (mac, style) = match s.node {\n         StmtMac(mac, style) => (mac, style),\n@@ -976,8 +986,8 @@ impl<'a> Folder for IdentRenamer<'a> {\n             ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n         }\n     }\n-    fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(macro, self)\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n     }\n }\n \n@@ -1013,8 +1023,8 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n             _ => unreachable!()\n         })\n     }\n-    fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(macro, self)\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n     }\n }\n \n@@ -1161,7 +1171,6 @@ fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n \n pub struct ExpansionConfig {\n     pub crate_name: String,\n-    pub deriving_hash_type_parameter: bool,\n     pub enable_quotes: bool,\n     pub recursion_limit: uint,\n }\n@@ -1170,38 +1179,23 @@ impl ExpansionConfig {\n     pub fn default(crate_name: String) -> ExpansionConfig {\n         ExpansionConfig {\n             crate_name: crate_name,\n-            deriving_hash_type_parameter: false,\n             enable_quotes: false,\n             recursion_limit: 64,\n         }\n     }\n }\n \n-pub struct ExportedMacros {\n-    pub crate_name: Ident,\n-    pub macros: Vec<String>,\n-}\n-\n pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     cfg: ExpansionConfig,\n                     // these are the macros being imported to this crate:\n-                    imported_macros: Vec<ExportedMacros>,\n+                    imported_macros: Vec<ast::MacroDef>,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     let mut expander = MacroExpander::new(&mut cx);\n \n-    for ExportedMacros { crate_name, macros } in imported_macros.into_iter() {\n-        let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n-\n-        for source in macros.into_iter() {\n-            let item = parse::parse_item_from_source_str(name.clone(),\n-                                                         source,\n-                                                         expander.cx.cfg(),\n-                                                         expander.cx.parse_sess())\n-                    .expect(\"expected a serialized item\");\n-            expand_item_mac(item, &mut expander);\n-        }\n+    for def in imported_macros.into_iter() {\n+        expander.cx.insert_macro(def);\n     }\n \n     for (name, extension) in user_exts.into_iter() {\n@@ -1290,8 +1284,8 @@ struct MacroExterminator<'a>{\n }\n \n impl<'a, 'v> Visitor<'v> for MacroExterminator<'a> {\n-    fn visit_mac(&mut self, macro: &ast::Mac) {\n-        self.sess.span_diagnostic.span_bug(macro.span,\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n+        self.sess.span_diagnostic.span_bug(mac.span,\n                                            \"macro exterminator: expected AST \\\n                                            with no macro invocations\");\n     }\n@@ -1300,7 +1294,7 @@ impl<'a, 'v> Visitor<'v> for MacroExterminator<'a> {\n \n #[cfg(test)]\n mod test {\n-    use super::{pattern_bindings, expand_crate, contains_macro_escape};\n+    use super::{pattern_bindings, expand_crate, contains_macro_use};\n     use super::{PatIdentFinder, IdentRenamer, PatIdentRenamer, ExpansionConfig};\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord, Name};\n@@ -1397,9 +1391,9 @@ mod test {\n         expand_crate(&sess,test_ecfg(),vec!(),vec!(),crate_ast);\n     }\n \n-    // macro_escape modules should allow macros to escape\n+    // macro_use modules should allow macros to escape\n     #[test] fn macros_can_escape_flattened_mods_test () {\n-        let src = \"#[macro_escape] mod foo {macro_rules! z (() => (3+4));}\\\n+        let src = \"#[macro_use] mod foo {macro_rules! z (() => (3+4));}\\\n                    fn inty() -> int { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n@@ -1409,16 +1403,6 @@ mod test {\n         expand_crate(&sess, test_ecfg(), vec!(), vec!(), crate_ast);\n     }\n \n-    #[test] fn test_contains_flatten (){\n-        let attr1 = make_dummy_attr (\"foo\");\n-        let attr2 = make_dummy_attr (\"bar\");\n-        let escape_attr = make_dummy_attr (\"macro_escape\");\n-        let attrs1 = vec!(attr1.clone(), escape_attr, attr2.clone());\n-        assert_eq!(contains_macro_escape(attrs1[]),true);\n-        let attrs2 = vec!(attr1,attr2);\n-        assert_eq!(contains_macro_escape(attrs2[]),false);\n-    }\n-\n     // make a MetaWord outer attribute with the given name\n     fn make_dummy_attr(s: &str) -> ast::Attribute {\n         Spanned {"}, {"sha": "f1b52fa33c386a3bd439ad9b9c2e9e4f0ed308c4", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -85,14 +85,14 @@ pub mod rt {\n     */\n \n     // FIXME: Move this trait to pprust and get rid of *_to_str?\n-    pub trait ToSource for Sized? {\n+    pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n         fn to_source(&self) -> String;\n     }\n \n     // FIXME (Issue #16472): This should go away after ToToken impls\n     // are revised to go directly to token-trees.\n-    trait ToSourceWithHygiene for Sized? : ToSource {\n+    trait ToSourceWithHygiene : ToSource {\n         // Takes a thing and generates a string containing rust code\n         // for it, encoding Idents as special byte sequences to\n         // maintain hygiene across serialization and deserialization."}, {"sha": "9837c8088fa4507a38f6ec9a523384009787d53c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -11,7 +11,7 @@\n use ast::{Ident, TtDelimited, TtSequence, TtToken};\n use ast;\n use codemap::{Span, DUMMY_SP};\n-use ext::base::{ExtCtxt, MacResult, MacroDef};\n+use ext::base::{ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n@@ -38,8 +38,8 @@ impl<'a> ParserAnyMacro<'a> {\n     /// Make sure we don't have any tokens left to parse, so we don't\n     /// silently drop anything. `allow_semi` is so that \"optional\"\n     /// semicolons at the end of normal expressions aren't complained\n-    /// about e.g. the semicolon in `macro_rules! kapow( () => {\n-    /// panic!(); } )` doesn't get picked up by .parse_expr(), but it's\n+    /// about e.g. the semicolon in `macro_rules! kapow { () => {\n+    /// panic!(); } }` doesn't get picked up by .parse_expr(), but it's\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool) {\n         let mut parser = self.parser.borrow_mut();\n@@ -110,6 +110,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n \n struct MacroRulesMacroExpander {\n     name: Ident,\n+    imported_from: Option<Ident>,\n     lhses: Vec<Rc<NamedMatch>>,\n     rhses: Vec<Rc<NamedMatch>>,\n }\n@@ -123,25 +124,18 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         generic_extension(cx,\n                           sp,\n                           self.name,\n+                          self.imported_from,\n                           arg,\n                           self.lhses[],\n                           self.rhses[])\n     }\n }\n \n-struct MacroRulesDefiner {\n-    def: Option<MacroDef>\n-}\n-impl MacResult for MacroRulesDefiner {\n-    fn make_def(&mut self) -> Option<MacroDef> {\n-        Some(self.def.take().expect(\"empty MacroRulesDefiner\"))\n-    }\n-}\n-\n /// Given `lhses` and `rhses`, this is the new macro we create\n fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           sp: Span,\n                           name: Ident,\n+                          imported_from: Option<Ident>,\n                           arg: &[ast::TokenTree],\n                           lhses: &[Rc<NamedMatch>],\n                           rhses: &[Rc<NamedMatch>])\n@@ -165,6 +159,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n             };\n             // `None` is because we're not interpolating\n             let mut arg_rdr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n+                                            None,\n                                             None,\n                                             arg.iter()\n                                                .map(|x| (*x).clone())\n@@ -186,6 +181,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                            Some(named_matches),\n+                                           imported_from,\n                                            rhs);\n                 let p = Parser::new(cx.parse_sess(), cx.cfg(), box trncbr);\n                 // Let the context choose how to interpret the result.\n@@ -212,14 +208,9 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n //\n // Holy self-referential!\n \n-/// This procedure performs the expansion of the\n-/// macro_rules! macro. It parses the RHS and adds\n-/// an extension to the current context.\n-pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n-                              sp: Span,\n-                              name: Ident,\n-                              arg: Vec<ast::TokenTree> )\n-                              -> Box<MacResult+'cx> {\n+/// Converts a `macro_rules!` invocation into a syntax extension.\n+pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n+                    def: &ast::MacroDef) -> SyntaxExtension {\n \n     let lhs_nm =  gensym_ident(\"lhs\");\n     let rhs_nm =  gensym_ident(\"rhs\");\n@@ -256,7 +247,8 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                    None,\n-                                   arg.clone());\n+                                   None,\n+                                   def.body.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n                                      arg_reader,\n@@ -265,24 +257,20 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n     // Extract the arguments:\n     let lhses = match *argument_map[lhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n-        _ => cx.span_bug(sp, \"wrong-structured lhs\")\n+        _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n     let rhses = match *argument_map[rhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n-        _ => cx.span_bug(sp, \"wrong-structured rhs\")\n+        _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };\n \n     let exp = box MacroRulesMacroExpander {\n-        name: name,\n+        name: def.ident,\n+        imported_from: def.imported_from,\n         lhses: lhses,\n         rhses: rhses,\n     };\n \n-    box MacroRulesDefiner {\n-        def: Some(MacroDef {\n-            name: token::get_ident(name).to_string(),\n-            ext: NormalTT(exp, Some(sp))\n-        })\n-    } as Box<MacResult+'cx>\n+    NormalTT(exp, Some(def.span))\n }"}, {"sha": "e4e6f5ac6b0f0f0c4953b6ab426eb8cb914d2e31", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -15,7 +15,7 @@ use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{Eof, DocComment, Interpolated, MatchNt, SubstNt};\n-use parse::token::{Token, NtIdent};\n+use parse::token::{Token, NtIdent, SpecialMacroVar};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n \n@@ -39,6 +39,10 @@ pub struct TtReader<'a> {\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n     interpolations: HashMap<Ident, Rc<NamedMatch>>,\n+    imported_from: Option<Ident>,\n+\n+    // Some => return imported_from as the next token\n+    crate_name_next: Option<Span>,\n     repeat_idx: Vec<uint>,\n     repeat_len: Vec<uint>,\n     /* cached: */\n@@ -53,6 +57,7 @@ pub struct TtReader<'a> {\n /// should) be none.\n pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n                          interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n+                         imported_from: Option<Ident>,\n                          src: Vec<ast::TokenTree> )\n                          -> TtReader<'a> {\n     let mut r = TtReader {\n@@ -71,6 +76,8 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n             None => HashMap::new(),\n             Some(x) => x,\n         },\n+        imported_from: imported_from,\n+        crate_name_next: None,\n         repeat_idx: Vec::new(),\n         repeat_len: Vec::new(),\n         desugar_doc_comments: false,\n@@ -162,6 +169,14 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         sp: r.cur_span.clone(),\n     };\n     loop {\n+        match r.crate_name_next.take() {\n+            None => (),\n+            Some(sp) => {\n+                r.cur_span = sp;\n+                r.cur_tok = token::Ident(r.imported_from.unwrap(), token::Plain);\n+                return ret_val;\n+            },\n+        }\n         let should_pop = match r.stack.last() {\n             None => {\n                 assert_eq!(ret_val.tok, token::Eof);\n@@ -307,6 +322,18 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                    sep: None\n                 });\n             }\n+            TtToken(sp, token::SpecialVarNt(SpecialMacroVar::CrateMacroVar)) => {\n+                r.stack.last_mut().unwrap().idx += 1;\n+\n+                if r.imported_from.is_some() {\n+                    r.cur_span = sp;\n+                    r.cur_tok = token::ModSep;\n+                    r.crate_name_next = Some(sp);\n+                    return ret_val;\n+                }\n+\n+                // otherwise emit nothing and proceed to the next token\n+            }\n             TtToken(sp, tok) => {\n                 r.cur_span = sp;\n                 r.cur_tok = tok;"}, {"sha": "0810d4ee93ac700cf5c650d7cc6fa983524b5935", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 22, "deletions": 79, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -36,15 +36,15 @@ use std::ascii::AsciiExt;\n \n // if you change this list without updating src/doc/reference.md, @cmr will be sad\n static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n-    (\"globs\", Active),\n-    (\"macro_rules\", Active),\n+    (\"globs\", Accepted),\n+    (\"macro_rules\", Accepted),\n     (\"struct_variant\", Accepted),\n     (\"asm\", Active),\n     (\"managed_boxes\", Removed),\n     (\"non_ascii_idents\", Active),\n     (\"thread_local\", Active),\n     (\"link_args\", Active),\n-    (\"phase\", Active),\n+    (\"phase\", Active),  // NOTE(stage0): switch to Removed after next snapshot\n     (\"plugin_registrar\", Active),\n     (\"log_syntax\", Active),\n     (\"trace_macros\", Active),\n@@ -54,7 +54,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"lang_items\", Active),\n \n     (\"simd\", Active),\n-    (\"default_type_params\", Active),\n+    (\"default_type_params\", Accepted),\n     (\"quote\", Active),\n     (\"link_llvm_intrinsics\", Active),\n     (\"linkage\", Active),\n@@ -67,13 +67,15 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"import_shadowing\", Active),\n     (\"advanced_slice_patterns\", Active),\n     (\"tuple_indexing\", Accepted),\n-    (\"associated_types\", Active),\n+    (\"associated_types\", Accepted),\n     (\"visible_private_types\", Active),\n     (\"slicing_syntax\", Active),\n \n     (\"if_let\", Accepted),\n     (\"while_let\", Accepted),\n \n+    (\"plugin\", Active),\n+\n     // A temporary feature gate used to enable parser extensions needed\n     // to bootstrap fix for #5723.\n     (\"issue_5723_bootstrap\", Accepted),\n@@ -112,7 +114,6 @@ enum Status {\n /// A set of features to be used by later passes.\n #[derive(Copy)]\n pub struct Features {\n-    pub default_type_params: bool,\n     pub unboxed_closures: bool,\n     pub rustc_diagnostic_macros: bool,\n     pub import_shadowing: bool,\n@@ -125,7 +126,6 @@ pub struct Features {\n impl Features {\n     pub fn new() -> Features {\n         Features {\n-            default_type_params: false,\n             unboxed_closures: false,\n             rustc_diagnostic_macros: false,\n             import_shadowing: false,\n@@ -163,32 +163,11 @@ struct MacroVisitor<'a> {\n }\n \n impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        match i.node {\n-            ast::ViewItemExternCrate(..) => {\n-                for attr in i.attrs.iter() {\n-                    if attr.name().get() == \"phase\"{\n-                        self.context.gate_feature(\"phase\", attr.span,\n-                                          \"compile time crate loading is \\\n-                                           experimental and possibly buggy\");\n-                    }\n-                }\n-            },\n-            _ => { }\n-        }\n-        visit::walk_view_item(self, i)\n-    }\n-\n-    fn visit_mac(&mut self, macro: &ast::Mac) {\n-        let ast::MacInvocTT(ref path, _, _) = macro.node;\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n+        let ast::MacInvocTT(ref path, _, _) = mac.node;\n         let id = path.segments.last().unwrap().identifier;\n \n-        if id == token::str_to_ident(\"macro_rules\") {\n-            self.context.gate_feature(\"macro_rules\", path.span, \"macro definitions are \\\n-                not stable enough for use and are subject to change\");\n-        }\n-\n-        else if id == token::str_to_ident(\"asm\") {\n+        if id == token::str_to_ident(\"asm\") {\n             self.context.gate_feature(\"asm\", path.span, \"inline assembly is not \\\n                 stable enough for use and is subject to change\");\n         }\n@@ -232,19 +211,13 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem) {\n         match i.node {\n-            ast::ViewItemUse(ref path) => {\n-                if let ast::ViewPathGlob(..) = path.node {\n-                    self.gate_feature(\"globs\", path.span,\n-                                      \"glob import statements are \\\n-                                       experimental and possibly buggy\");\n-                }\n-            }\n+            ast::ViewItemUse(..) => {}\n             ast::ViewItemExternCrate(..) => {\n                 for attr in i.attrs.iter() {\n-                    if attr.name().get() == \"phase\"{\n-                        self.gate_feature(\"phase\", attr.span,\n-                                          \"compile time crate loading is \\\n-                                           experimental and possibly buggy\");\n+                    if attr.check_name(\"plugin\") {\n+                        self.gate_feature(\"plugin\", attr.span,\n+                                          \"compiler plugins are experimental \\\n+                                           and possibly buggy\");\n                     }\n                 }\n             }\n@@ -294,7 +267,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemImpl(_, polarity, _, _, _, ref items) => {\n+            ast::ItemImpl(_, polarity, _, _, _, _) => {\n                 match polarity {\n                     ast::ImplPolarity::Negative => {\n                         self.gate_feature(\"optin_builtin_traits\",\n@@ -314,16 +287,12 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                        removed in the future\");\n                 }\n \n-                for item in items.iter() {\n-                    match *item {\n-                        ast::MethodImplItem(_) => {}\n-                        ast::TypeImplItem(ref typedef) => {\n-                            self.gate_feature(\"associated_types\",\n-                                              typedef.span,\n-                                              \"associated types are \\\n-                                               experimental\")\n-                        }\n-                    }\n+                if attr::contains_name(i.attrs[],\n+                                       \"old_orphan_check\") {\n+                    self.gate_feature(\n+                        \"old_orphan_check\",\n+                        i.span,\n+                        \"the new orphan check rules will eventually be strictly enforced\");\n                 }\n             }\n \n@@ -333,17 +302,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_item(self, i);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n-        match *trait_item {\n-            ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n-            ast::TypeTraitItem(ref ti) => {\n-                self.gate_feature(\"associated_types\",\n-                                  ti.ty_param.span,\n-                                  \"associated types are experimental\")\n-            }\n-        }\n-    }\n-\n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n         if attr::contains_name(i.attrs[], \"linkage\") {\n             self.gate_feature(\"linkage\", i.span,\n@@ -379,20 +337,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_expr(self, e);\n     }\n \n-    fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for type_parameter in generics.ty_params.iter() {\n-            match type_parameter.default {\n-                Some(ref ty) => {\n-                    self.gate_feature(\"default_type_params\", ty.span,\n-                                      \"default type parameters are \\\n-                                       experimental and possibly buggy\");\n-                }\n-                None => {}\n-            }\n-        }\n-        visit::walk_generics(self, generics);\n-    }\n-\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         if attr::contains_name(slice::ref_slice(attr), \"lang\") {\n             self.gate_feature(\"lang_items\",\n@@ -498,7 +442,6 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n     check(&mut cx, krate);\n \n     (Features {\n-        default_type_params: cx.has_feature(\"default_type_params\"),\n         unboxed_closures: cx.has_feature(\"unboxed_closures\"),\n         rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n         import_shadowing: cx.has_feature(\"import_shadowing\"),"}, {"sha": "c45a4005339baea337116a1494daf44e2da0d048", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -194,13 +194,13 @@ pub trait Folder : Sized {\n         noop_fold_local(l, self)\n     }\n \n-    fn fold_mac(&mut self, _macro: Mac) -> Mac {\n+    fn fold_mac(&mut self, _mac: Mac) -> Mac {\n         panic!(\"fold_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a folder that\n         // works on macros, use this\n         // definition in your trait impl:\n-        // fold::noop_fold_mac(_macro, self)\n+        // fold::noop_fold_mac(_mac, self)\n     }\n \n     fn fold_explicit_self(&mut self, es: ExplicitSelf) -> ExplicitSelf {\n@@ -1104,7 +1104,7 @@ pub fn noop_fold_mod<T: Folder>(Mod {inner, view_items, items}: Mod, folder: &mu\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, exported_macros, span}: Crate,\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_macros, span}: Crate,\n                                   folder: &mut T) -> Crate {\n     let config = folder.fold_meta_items(config);\n \n@@ -1135,6 +1135,10 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, exported_macros,\n         }, Vec::new(), span)\n     };\n \n+    for def in exported_macros.iter_mut() {\n+        def.id = folder.new_id(def.id);\n+    }\n+\n     Crate {\n         module: module,\n         attrs: attrs,\n@@ -1257,7 +1261,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n             }\n             PatTup(elts) => PatTup(elts.move_map(|x| folder.fold_pat(x))),\n             PatBox(inner) => PatBox(folder.fold_pat(inner)),\n-            PatRegion(inner) => PatRegion(folder.fold_pat(inner)),\n+            PatRegion(inner, mutbl) => PatRegion(folder.fold_pat(inner), mutbl),\n             PatRange(e1, e2) => {\n                 PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n             },\n@@ -1472,8 +1476,8 @@ mod test {\n         fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n             token::str_to_ident(\"zz\")\n         }\n-        fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n-            fold::noop_fold_mac(macro, self)\n+        fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+            fold::noop_fold_mac(mac, self)\n         }\n     }\n "}, {"sha": "b7bfd346d506b96fffdfbbb0e535d273a0969255", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -31,11 +31,18 @@\n \n extern crate arena;\n extern crate fmt_macros;\n-#[phase(plugin, link)] extern crate log;\n extern crate serialize;\n extern crate term;\n extern crate libc;\n \n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n extern crate \"serialize\" as rustc_serialize; // used by deriving\n \n pub mod util {"}, {"sha": "b0969a573e66b3cf35e1cb5a0573c079e85228de", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -24,8 +24,11 @@ use std::num::Int;\n use std::str;\n use std::iter;\n \n-pub mod lexer;\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod parser;\n+\n+pub mod lexer;\n pub mod token;\n pub mod attr;\n \n@@ -166,6 +169,8 @@ pub fn parse_stmt_from_source_str(name: String,\n \n // Note: keep in sync with `with_hygiene::parse_tts_from_source_str`\n // until #16472 is resolved.\n+//\n+// Warning: This parses with quote_depth > 0, which is not the default.\n pub fn parse_tts_from_source_str(name: String,\n                                  source: String,\n                                  cfg: ast::CrateConfig,\n@@ -291,7 +296,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<ast::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n-    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n+    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, None, tts);\n     Parser::new(sess, cfg, box trdr)\n }\n \n@@ -307,6 +312,8 @@ pub mod with_hygiene {\n \n     // Note: keep this in sync with `super::parse_tts_from_source_str` until\n     // #16472 is resolved.\n+    //\n+    // Warning: This parses with quote_depth > 0, which is not the default.\n     pub fn parse_tts_from_source_str(name: String,\n                                      source: String,\n                                      cfg: ast::CrateConfig,"}, {"sha": "a49680d7e1c0344a682098a6270ede9214650f4c", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //!\n //! Obsolete syntax that becomes too hard to parse can be removed.\n \n-pub use self::ObsoleteSyntax::*;\n-\n use ast::{Expr, ExprTup};\n use codemap::Span;\n use parse::parser;\n@@ -24,17 +22,19 @@ use ptr::P;\n /// The specific types of unsupported syntax\n #[derive(Copy, PartialEq, Eq, Hash)]\n pub enum ObsoleteSyntax {\n-    ObsoleteOwnedType,\n-    ObsoleteOwnedExpr,\n-    ObsoleteOwnedPattern,\n-    ObsoleteOwnedVector,\n-    ObsoleteOwnedSelf,\n-    ObsoleteImportRenaming,\n-    ObsoleteSubsliceMatch,\n-    ObsoleteExternCrateRenaming,\n-    ObsoleteProcType,\n-    ObsoleteProcExpr,\n-    ObsoleteClosureType,\n+    Sized,\n+    ForSized,\n+    OwnedType,\n+    OwnedExpr,\n+    OwnedPattern,\n+    OwnedVector,\n+    OwnedSelf,\n+    ImportRenaming,\n+    SubsliceMatch,\n+    ExternCrateRenaming,\n+    ProcType,\n+    ProcExpr,\n+    ClosureType,\n }\n \n pub trait ParserObsoleteMethods {\n@@ -56,50 +56,59 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n-            ObsoleteProcType => (\n+            ObsoleteSyntax::ForSized => (\n+                \"for Sized?\",\n+                \"no longer required. Traits (and their `Self` type) do not have the `Sized` bound \\\n+                 by default\",\n+            ),\n+            ObsoleteSyntax::ProcType => (\n                 \"the `proc` type\",\n                 \"use unboxed closures instead\",\n             ),\n-            ObsoleteProcExpr => (\n+            ObsoleteSyntax::ProcExpr => (\n                 \"`proc` expression\",\n                 \"use a `move ||` expression instead\",\n             ),\n-            ObsoleteOwnedType => (\n+            ObsoleteSyntax::OwnedType => (\n                 \"`~` notation for owned pointers\",\n                 \"use `Box<T>` in `std::owned` instead\"\n             ),\n-            ObsoleteOwnedExpr => (\n+            ObsoleteSyntax::OwnedExpr => (\n                 \"`~` notation for owned pointer allocation\",\n                 \"use the `box` operator instead of `~`\"\n             ),\n-            ObsoleteOwnedPattern => (\n+            ObsoleteSyntax::OwnedPattern => (\n                 \"`~` notation for owned pointer patterns\",\n                 \"use the `box` operator instead of `~`\"\n             ),\n-            ObsoleteOwnedVector => (\n+            ObsoleteSyntax::OwnedVector => (\n                 \"`~[T]` is no longer a type\",\n                 \"use the `Vec` type instead\"\n             ),\n-            ObsoleteOwnedSelf => (\n+            ObsoleteSyntax::OwnedSelf => (\n                 \"`~self` is no longer supported\",\n                 \"write `self: Box<Self>` instead\"\n             ),\n-            ObsoleteImportRenaming => (\n+            ObsoleteSyntax::ImportRenaming => (\n                 \"`use foo = bar` syntax\",\n                 \"write `use bar as foo` instead\"\n             ),\n-            ObsoleteSubsliceMatch => (\n+            ObsoleteSyntax::SubsliceMatch => (\n                 \"subslice match syntax\",\n                 \"instead of `..xs`, write `xs..` in a pattern\"\n             ),\n-            ObsoleteExternCrateRenaming => (\n+            ObsoleteSyntax::ExternCrateRenaming => (\n                 \"`extern crate foo = bar` syntax\",\n                 \"write `extern crate bar as foo` instead\"\n             ),\n-            ObsoleteClosureType => (\n+            ObsoleteSyntax::ClosureType => (\n                 \"`|uint| -> bool` closure type syntax\",\n                 \"use unboxed closures instead, no type annotation needed\"\n-            )\n+            ),\n+            ObsoleteSyntax::Sized => (\n+                \"`Sized? T` syntax for removing the `Sized` bound\",\n+                \"write `T: ?Sized` instead\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "32f8f5ee3d63b97c35aa94e14070129269204dac", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 142, "deletions": 71, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n pub use self::PathParsingMode::*;\n use self::ItemOrViewItem::*;\n \n@@ -74,8 +72,8 @@ use parse::classify;\n use parse::common::{SeqSep, seq_sep_none, seq_sep_trailing_allowed};\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::*;\n-use parse::token::{self, MatchNt, SubstNt, InternedString};\n-use parse::token::{keywords, special_idents};\n+use parse::token::{self, MatchNt, SubstNt, SpecialVarNt, InternedString};\n+use parse::token::{keywords, special_idents, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n use print::pprust;\n use ptr::P;\n@@ -1155,7 +1153,7 @@ impl<'a> Parser<'a> {\n         let _ = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n         let _ = self.parse_ret_ty();\n \n-        self.obsolete(proc_span, ObsoleteProcType);\n+        self.obsolete(proc_span, ObsoleteSyntax::ProcType);\n \n         TyInfer\n     }\n@@ -1246,7 +1244,7 @@ impl<'a> Parser<'a> {\n \n         let _ = self.parse_ret_ty();\n \n-        self.obsolete(ty_closure_span, ObsoleteClosureType);\n+        self.obsolete(ty_closure_span, ObsoleteSyntax::ClosureType);\n \n         TyInfer\n     }\n@@ -1511,8 +1509,10 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let last_span = self.last_span;\n             match self.token {\n-                token::OpenDelim(token::Bracket) => self.obsolete(last_span, ObsoleteOwnedVector),\n-                _ => self.obsolete(last_span, ObsoleteOwnedType)\n+                token::OpenDelim(token::Bracket) => {\n+                    self.obsolete(last_span, ObsoleteSyntax::OwnedVector)\n+                }\n+                _ => self.obsolete(last_span, ObsoleteSyntax::OwnedType)\n             }\n             TyTup(vec![self.parse_ty()])\n         } else if self.check(&token::BinOp(token::Star)) {\n@@ -2275,7 +2275,7 @@ impl<'a> Parser<'a> {\n                     let span = self.last_span;\n                     let _ = self.parse_proc_decl();\n                     let _ = self.parse_expr();\n-                    return self.obsolete_expr(span, ObsoleteProcExpr);\n+                    return self.obsolete_expr(span, ObsoleteSyntax::ProcExpr);\n                 }\n                 if self.eat_keyword(keywords::If) {\n                     return self.parse_if_expr();\n@@ -2737,6 +2737,9 @@ impl<'a> Parser<'a> {\n                                    op: repeat,\n                                    num_captures: name_num\n                                }))\n+                } else if p.token.is_keyword_allow_following_colon(keywords::Crate) {\n+                    p.bump();\n+                    TtToken(sp, SpecialVarNt(SpecialMacroVar::CrateMacroVar))\n                 } else {\n                     // A nonterminal that matches or not\n                     let namep = match p.token { token::Ident(_, p) => p, _ => token::Plain };\n@@ -2850,9 +2853,9 @@ impl<'a> Parser<'a> {\n             let last_span = self.last_span;\n             match self.token {\n                 token::OpenDelim(token::Bracket) => {\n-                    self.obsolete(last_span, ObsoleteOwnedVector)\n+                    self.obsolete(last_span, ObsoleteSyntax::OwnedVector)\n                 },\n-                _ => self.obsolete(last_span, ObsoleteOwnedExpr)\n+                _ => self.obsolete(last_span, ObsoleteSyntax::OwnedExpr)\n             }\n \n             let e = self.parse_prefix_expr();\n@@ -2966,14 +2969,17 @@ impl<'a> Parser<'a> {\n     /// actually, this seems to be the main entry point for\n     /// parsing an arbitrary expression.\n     pub fn parse_assign_expr(&mut self) -> P<Expr> {\n-        let lo = self.span.lo;\n         let lhs = self.parse_binops();\n+        self.parse_assign_expr_with(lhs)\n+    }\n+\n+    pub fn parse_assign_expr_with(&mut self, lhs: P<Expr>) -> P<Expr> {\n         let restrictions = self.restrictions & RESTRICTION_NO_STRUCT_LITERAL;\n         match self.token {\n           token::Eq => {\n               self.bump();\n               let rhs = self.parse_expr_res(restrictions);\n-              self.mk_expr(lo, rhs.span.hi, ExprAssign(lhs, rhs))\n+              self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs))\n           }\n           token::BinOpEq(op) => {\n               self.bump();\n@@ -2991,8 +2997,9 @@ impl<'a> Parser<'a> {\n                   token::Shr =>     BiShr\n               };\n               let rhs_span = rhs.span;\n+              let span = lhs.span;\n               let assign_op = self.mk_assign_op(aop, lhs, rhs);\n-              self.mk_expr(lo, rhs_span.hi, assign_op)\n+              self.mk_expr(span.lo, rhs_span.hi, assign_op)\n           }\n           _ => {\n               lhs\n@@ -3223,7 +3230,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         let _ = self.parse_pat();\n                         let span = self.span;\n-                        self.obsolete(span, ObsoleteSubsliceMatch);\n+                        self.obsolete(span, ObsoleteSyntax::SubsliceMatch);\n                     }\n                     continue\n                 }\n@@ -3339,19 +3346,24 @@ impl<'a> Parser<'a> {\n             pat = PatBox(sub);\n             let last_span = self.last_span;\n             hi = last_span.hi;\n-            self.obsolete(last_span, ObsoleteOwnedPattern);\n+            self.obsolete(last_span, ObsoleteSyntax::OwnedPattern);\n             return P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n             })\n           }\n           token::BinOp(token::And) | token::AndAnd => {\n-            // parse &pat\n+            // parse &pat and &mut pat\n             let lo = self.span.lo;\n             self.expect_and();\n+            let mutability = if self.eat_keyword(keywords::Mut) {\n+                ast::MutMutable\n+            } else {\n+                ast::MutImmutable\n+            };\n             let sub = self.parse_pat();\n-            pat = PatRegion(sub);\n+            pat = PatRegion(sub, mutability);\n             hi = self.last_span.hi;\n             return P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n@@ -3870,13 +3882,13 @@ impl<'a> Parser<'a> {\n                                                                   &mut stmts,\n                                                                   &mut expr);\n                         }\n-                        StmtMac(macro, MacStmtWithoutBraces) => {\n+                        StmtMac(mac, MacStmtWithoutBraces) => {\n                             // statement macro without braces; might be an\n                             // expr depending on whether a semicolon follows\n                             match self.token {\n                                 token::Semi => {\n                                     stmts.push(P(Spanned {\n-                                        node: StmtMac(macro,\n+                                        node: StmtMac(mac,\n                                                       MacStmtWithSemicolon),\n                                         span: span,\n                                     }));\n@@ -3885,9 +3897,10 @@ impl<'a> Parser<'a> {\n                                 _ => {\n                                     let e = self.mk_mac_expr(span.lo,\n                                                              span.hi,\n-                                                             macro.and_then(|m| m.node));\n-                                    let e =\n-                                        self.parse_dot_or_call_expr_with(e);\n+                                                             mac.and_then(|m| m.node));\n+                                    let e = self.parse_dot_or_call_expr_with(e);\n+                                    let e = self.parse_more_binops(e, 0);\n+                                    let e = self.parse_assign_expr_with(e);\n                                     self.handle_expression_like_statement(\n                                         e,\n                                         ast::DUMMY_NODE_ID,\n@@ -4080,8 +4093,8 @@ impl<'a> Parser<'a> {\n         // unbound, and it may only be `Sized`. To avoid backtracking and other\n         // complications, we parse an ident, then check for `?`. If we find it,\n         // we use the ident as the unbound, otherwise, we use it as the name of\n-        // type param. Even worse, for now, we need to check for `?` before or\n-        // after the bound.\n+        // type param. Even worse, we need to check for `?` before or after the\n+        // bound.\n         let mut span = self.span;\n         let mut ident = self.parse_ident();\n         let mut unbound = None;\n@@ -4090,6 +4103,7 @@ impl<'a> Parser<'a> {\n             unbound = Some(tref);\n             span = self.span;\n             ident = self.parse_ident();\n+            self.obsolete(span, ObsoleteSyntax::Sized);\n         }\n \n         let mut bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Modified);\n@@ -4453,7 +4467,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     drop(self.expect_self_ident());\n                     let last_span = self.last_span;\n-                    self.obsolete(last_span, ObsoleteOwnedSelf)\n+                    self.obsolete(last_span, ObsoleteSyntax::OwnedSelf)\n                 }\n                 SelfStatic\n             }\n@@ -4504,7 +4518,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     drop(self.expect_self_ident());\n                     let last_span = self.last_span;\n-                    self.obsolete(last_span, ObsoleteOwnedSelf);\n+                    self.obsolete(last_span, ObsoleteSyntax::OwnedSelf);\n                     SelfStatic\n                 } else {\n                     SelfStatic\n@@ -4880,67 +4894,116 @@ impl<'a> Parser<'a> {\n             self.span_err(ty.span, \"`virtual` structs have been removed from the language\");\n         }\n \n-        self.parse_where_clause(&mut generics);\n+        // There is a special case worth noting here, as reported in issue #17904.\n+        // If we are parsing a tuple struct it is the case that the where clause\n+        // should follow the field list. Like so:\n+        //\n+        // struct Foo<T>(T) where T: Copy;\n+        //\n+        // If we are parsing a normal record-style struct it is the case\n+        // that the where clause comes before the body, and after the generics.\n+        // So if we look ahead and see a brace or a where-clause we begin\n+        // parsing a record style struct.\n+        //\n+        // Otherwise if we look ahead and see a paren we parse a tuple-style\n+        // struct.\n+\n+        let (fields, ctor_id) = if self.token.is_keyword(keywords::Where) {\n+            self.parse_where_clause(&mut generics);\n+            if self.eat(&token::Semi) {\n+                // If we see a: `struct Foo<T> where T: Copy;` style decl.\n+                (Vec::new(), Some(ast::DUMMY_NODE_ID))\n+            } else {\n+                // If we see: `struct Foo<T> where T: Copy { ... }`\n+                (self.parse_record_struct_body(&class_name), None)\n+            }\n+        // No `where` so: `struct Foo<T>;`\n+        } else if self.eat(&token::Semi) {\n+            (Vec::new(), Some(ast::DUMMY_NODE_ID))\n+        // Record-style struct definition\n+        } else if self.token == token::OpenDelim(token::Brace) {\n+            let fields = self.parse_record_struct_body(&class_name);\n+            (fields, None)\n+        // Tuple-style struct definition with optional where-clause.\n+        } else {\n+            let fields = self.parse_tuple_struct_body(&class_name, &mut generics);\n+            (fields, Some(ast::DUMMY_NODE_ID))\n+        };\n \n-        let mut fields: Vec<StructField>;\n-        let is_tuple_like;\n+        (class_name,\n+         ItemStruct(P(ast::StructDef {\n+             fields: fields,\n+             ctor_id: ctor_id,\n+         }), generics),\n+         None)\n+    }\n \n+    pub fn parse_record_struct_body(&mut self, class_name: &ast::Ident) -> Vec<StructField> {\n+        let mut fields = Vec::new();\n         if self.eat(&token::OpenDelim(token::Brace)) {\n-            // It's a record-like struct.\n-            is_tuple_like = false;\n-            fields = Vec::new();\n             while self.token != token::CloseDelim(token::Brace) {\n                 fields.push(self.parse_struct_decl_field(true));\n             }\n+\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n-                                    written as `struct {};`\",\n-                                   token::get_ident(class_name))[]);\n+                    written as `struct {};`\",\n+                    token::get_ident(class_name.clone()))[]);\n             }\n+\n             self.bump();\n-        } else if self.check(&token::OpenDelim(token::Paren)) {\n-            // It's a tuple-like struct.\n-            is_tuple_like = true;\n-            fields = self.parse_unspanned_seq(\n+        } else {\n+            let token_str = self.this_token_to_string();\n+            self.fatal(format!(\"expected `where`, or `{}` after struct \\\n+                                name, found `{}`\", \"{\",\n+                                token_str)[]);\n+        }\n+\n+        fields\n+    }\n+\n+    pub fn parse_tuple_struct_body(&mut self,\n+                                   class_name: &ast::Ident,\n+                                   generics: &mut ast::Generics)\n+                                   -> Vec<StructField> {\n+        // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n+        if self.check(&token::OpenDelim(token::Paren)) {\n+            let fields = self.parse_unspanned_seq(\n                 &token::OpenDelim(token::Paren),\n                 &token::CloseDelim(token::Paren),\n                 seq_sep_trailing_allowed(token::Comma),\n                 |p| {\n-                let attrs = p.parse_outer_attributes();\n-                let lo = p.span.lo;\n-                let struct_field_ = ast::StructField_ {\n-                    kind: UnnamedField(p.parse_visibility()),\n-                    id: ast::DUMMY_NODE_ID,\n-                    ty: p.parse_ty_sum(),\n-                    attrs: attrs,\n-                };\n-                spanned(lo, p.span.hi, struct_field_)\n-            });\n+                    let attrs = p.parse_outer_attributes();\n+                    let lo = p.span.lo;\n+                    let struct_field_ = ast::StructField_ {\n+                        kind: UnnamedField(p.parse_visibility()),\n+                        id: ast::DUMMY_NODE_ID,\n+                        ty: p.parse_ty_sum(),\n+                        attrs: attrs,\n+                    };\n+                    spanned(lo, p.span.hi, struct_field_)\n+                });\n+\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n-                                    written as `struct {};`\",\n-                                   token::get_ident(class_name))[]);\n+                    written as `struct {};`\",\n+                    token::get_ident(class_name.clone()))[]);\n             }\n+\n+            self.parse_where_clause(generics);\n             self.expect(&token::Semi);\n-        } else if self.eat(&token::Semi) {\n-            // It's a unit-like struct.\n-            is_tuple_like = true;\n-            fields = Vec::new();\n+            fields\n+        // This is the case where we just see struct Foo<T> where T: Copy;\n+        } else if self.token.is_keyword(keywords::Where) {\n+            self.parse_where_clause(generics);\n+            self.expect(&token::Semi);\n+            Vec::new()\n+        // This case is where we see: `struct Foo<T>;`\n         } else {\n             let token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `{}`, `(`, or `;` after struct \\\n-                                name, found `{}`\", \"{\",\n-                               token_str)[])\n+            self.fatal(format!(\"expected `where`, `{}`, `(`, or `;` after struct \\\n+                name, found `{}`\", \"{\", token_str)[]);\n         }\n-\n-        let _ = ast::DUMMY_NODE_ID;  // FIXME: Workaround for crazy bug.\n-        let new_id = ast::DUMMY_NODE_ID;\n-        (class_name,\n-         ItemStruct(P(ast::StructDef {\n-             fields: fields,\n-             ctor_id: if is_tuple_like { Some(new_id) } else { None },\n-         }), generics),\n-         None)\n     }\n \n     /// Parse a structure field declaration\n@@ -4993,6 +5056,7 @@ impl<'a> Parser<'a> {\n         // re-jigged shortly in any case, so leaving the hacky version for now.\n         if self.eat_keyword(keywords::For) {\n             let span = self.span;\n+\n             let mut ate_question = false;\n             if self.eat(&token::Question) {\n                 ate_question = true;\n@@ -5010,8 +5074,11 @@ impl<'a> Parser<'a> {\n                     \"expected `?Sized` after `for` in trait item\");\n                 return None;\n             }\n-            let tref = Parser::trait_ref_from_ident(ident, span);\n-            Some(tref)\n+            let _tref = Parser::trait_ref_from_ident(ident, span);\n+\n+            self.obsolete(span, ObsoleteSyntax::ForSized);\n+\n+            None\n         } else {\n             None\n         }\n@@ -5333,7 +5400,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     let path = self.parse_str();\n                     let span = self.span;\n-                    self.obsolete(span, ObsoleteExternCrateRenaming);\n+                    self.obsolete(span, ObsoleteSyntax::ExternCrateRenaming);\n                     Some(path)\n                 } else if self.eat_keyword(keywords::As) {\n                     // skip the ident if there is one\n@@ -5960,6 +6027,10 @@ impl<'a> Parser<'a> {\n     fn parse_view_path(&mut self) -> P<ViewPath> {\n         let lo = self.span.lo;\n \n+        // Allow a leading :: because the paths are absolute either way.\n+        // This occurs with \"use $crate::...\" in macros.\n+        self.eat(&token::ModSep);\n+\n         if self.check(&token::OpenDelim(token::Brace)) {\n             // use {foo,bar}\n             let idents = self.parse_unspanned_seq(\n@@ -5990,7 +6061,7 @@ impl<'a> Parser<'a> {\n                 path.push(id);\n             }\n             let span = mk_sp(path_lo, self.span.hi);\n-            self.obsolete(span, ObsoleteImportRenaming);\n+            self.obsolete(span, ObsoleteSyntax::ImportRenaming);\n             let path = ast::Path {\n                 span: span,\n                 global: false,"}, {"sha": "094aacf3207fcb0a14be6207f51d79f21d623275", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -61,6 +61,21 @@ pub enum IdentStyle {\n     Plain,\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n+pub enum SpecialMacroVar {\n+    /// `$crate` will be filled in with the name of the crate a macro was\n+    /// imported from, if any.\n+    CrateMacroVar,\n+}\n+\n+impl SpecialMacroVar {\n+    pub fn as_str(self) -> &'static str {\n+        match self {\n+            SpecialMacroVar::CrateMacroVar => \"crate\",\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n pub enum Lit {\n     Byte(ast::Name),\n@@ -143,6 +158,8 @@ pub enum Token {\n     // In right-hand-sides of MBE macros:\n     /// A syntactic variable that will be filled in by macro expansion.\n     SubstNt(ast::Ident, IdentStyle),\n+    /// A macro variable with special meaning.\n+    SpecialVarNt(SpecialMacroVar),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for\n@@ -265,6 +282,13 @@ impl Token {\n         }\n     }\n \n+    pub fn is_keyword_allow_following_colon(&self, kw: keywords::Keyword) -> bool {\n+        match *self {\n+            Ident(sid, _) => { kw.to_name() == sid.name }\n+            _ => { false }\n+        }\n+    }\n+\n     /// Returns `true` if the token is either a special identifier, or a strict\n     /// or reserved keyword.\n     #[allow(non_upper_case_globals)]\n@@ -550,6 +574,7 @@ declare_special_idents_and_keywords! {\n         (56,                         Abstract,   \"abstract\");\n         (57,                         Final,      \"final\");\n         (58,                         Override,   \"override\");\n+        (59,                         Macro,      \"macro\");\n     }\n }\n "}, {"sha": "402583b60fae5387e6c89055f875408341539c5e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -272,6 +272,8 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Comment              => \"/* */\".to_string(),\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s.as_str()),\n \n+        token::SpecialVarNt(var)    => format!(\"${}\", var.as_str()),\n+\n         token::Interpolated(ref nt) => match *nt {\n             token::NtExpr(ref e)  => expr_to_string(&**e),\n             token::NtMeta(ref e)  => meta_item_to_string(&**e),\n@@ -1056,7 +1058,6 @@ impl<'a> State<'a> {\n                         span: codemap::Span) -> IoResult<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n-        try!(self.print_where_clause(generics));\n         if ast_util::struct_def_is_tuple_like(struct_def) {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());\n@@ -1075,10 +1076,12 @@ impl<'a> State<'a> {\n                 ));\n                 try!(self.pclose());\n             }\n+            try!(self.print_where_clause(generics));\n             try!(word(&mut self.s, \";\"));\n             try!(self.end());\n             self.end() // close the outer-box\n         } else {\n+            try!(self.print_where_clause(generics));\n             try!(self.nbsp());\n             try!(self.bopen());\n             try!(self.hardbreak_if_not_bol());\n@@ -2081,8 +2084,11 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"box \"));\n                 try!(self.print_pat(&**inner));\n             }\n-            ast::PatRegion(ref inner) => {\n+            ast::PatRegion(ref inner, mutbl) => {\n                 try!(word(&mut self.s, \"&\"));\n+                if mutbl == ast::MutMutable {\n+                    try!(word(&mut self.s, \"mut \"));\n+                }\n                 try!(self.print_pat(&**inner));\n             }\n             ast::PatLit(ref e) => try!(self.print_expr(&**e)),"}, {"sha": "57520257fe1b3f9e54fe61f4e7ac363e8b082f1e", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,27 +13,73 @@\n //! This module shows spans for all expressions in the crate\n //! to help with compiler debugging.\n \n+use std::str::FromStr;\n+\n use ast;\n use diagnostic;\n use visit;\n use visit::Visitor;\n \n+enum Mode {\n+    Expression,\n+    Pattern,\n+    Type,\n+}\n+\n+impl FromStr for Mode {\n+    fn from_str(s: &str) -> Option<Mode> {\n+        let mode = match s {\n+            \"expr\" => Mode::Expression,\n+            \"pat\" => Mode::Pattern,\n+            \"ty\" => Mode::Type,\n+            _ => return None\n+        };\n+        Some(mode)\n+    }\n+}\n+\n struct ShowSpanVisitor<'a> {\n     span_diagnostic: &'a diagnostic::SpanHandler,\n+    mode: Mode,\n }\n \n impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n-        self.span_diagnostic.span_note(e.span, \"expression\");\n+        if let Mode::Expression = self.mode {\n+            self.span_diagnostic.span_note(e.span, \"expression\");\n+        }\n         visit::walk_expr(self, e);\n     }\n \n-    fn visit_mac(&mut self, macro: &ast::Mac) {\n-        visit::walk_mac(self, macro);\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n+        if let Mode::Pattern = self.mode {\n+            self.span_diagnostic.span_note(p.span, \"pattern\");\n+        }\n+        visit::walk_pat(self, p);\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n+        if let Mode::Type = self.mode {\n+            self.span_diagnostic.span_note(t.span, \"type\");\n+        }\n+        visit::walk_ty(self, t);\n+    }\n+\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n+        visit::walk_mac(self, mac);\n     }\n }\n \n-pub fn run(span_diagnostic: &diagnostic::SpanHandler, krate: &ast::Crate) {\n-    let mut v = ShowSpanVisitor { span_diagnostic: span_diagnostic };\n+pub fn run(span_diagnostic: &diagnostic::SpanHandler,\n+           mode: &str,\n+           krate: &ast::Crate) {\n+    let mode = match mode.parse() {\n+        Some(mode) => mode,\n+        None => return\n+    };\n+    let mut v = ShowSpanVisitor {\n+        span_diagnostic: span_diagnostic,\n+        mode: mode,\n+    };\n     visit::walk_crate(&mut v, krate);\n }"}, {"sha": "4ef7eb97a218946e8c16b2b24d70c91d7617aff4", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -65,12 +65,8 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n                                            Some((actual_crate_name, ast::CookedStr)),\n                                            ast::DUMMY_NODE_ID),\n             attrs: vec!(\n-                attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_list_item(\n-                        InternedString::new(\"phase\"),\n-                        vec!(\n-                            attr::mk_word_item(InternedString::new(\"plugin\")),\n-                            attr::mk_word_item(InternedString::new(\"link\")\n-                        ))))),\n+                attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_word_item(\n+                        InternedString::new(\"macro_use\")))),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n         });\n@@ -82,16 +78,6 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n         // don't add #![no_std] here, that will block the prelude injection later.\n         // Add it during the prelude injection instead.\n \n-        // Add #![feature(phase)] here, because we use #[phase] on extern crate std.\n-        let feat_phase_attr = attr::mk_attr_inner(attr::mk_attr_id(),\n-                                                  attr::mk_list_item(\n-                                  InternedString::new(\"feature\"),\n-                                  vec![attr::mk_word_item(InternedString::new(\"phase\"))],\n-                              ));\n-        // std_inject runs after feature checking so manually mark this attr\n-        attr::mark_used(&feat_phase_attr);\n-        krate.attrs.push(feat_phase_attr);\n-\n         krate\n     }\n }"}, {"sha": "85eea2d9daf27226f889f7c80b4c3643587fbd48", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -77,7 +77,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n         (*vect).len()\n     }\n \n-    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n     where Q: BorrowFrom<T> + Eq + Hash {\n         let map = self.map.borrow();\n         match (*map).get(val) {\n@@ -202,7 +202,7 @@ impl StrInterner {\n         self.vect.borrow().len()\n     }\n \n-    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n     where Q: BorrowFrom<RcStr> + Eq + Hash {\n         match (*self.map.borrow()).get(val) {\n             Some(v) => Some(*v),"}, {"sha": "3f91304dcc5f21c528b2cfcdcee0c570109f10de", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -115,13 +115,13 @@ pub trait Visitor<'v> : Sized {\n     fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n         walk_explicit_self(self, es)\n     }\n-    fn visit_mac(&mut self, _macro: &'v Mac) {\n+    fn visit_mac(&mut self, _mac: &'v Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a visitor that\n         // works on macros, use this\n         // definition in your trait impl:\n-        // visit::walk_mac(self, _macro)\n+        // visit::walk_mac(self, _mac)\n     }\n     fn visit_path(&mut self, path: &'v Path, _id: ast::NodeId) {\n         walk_path(self, path)\n@@ -334,7 +334,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                 visitor.visit_trait_item(method)\n             }\n         }\n-        ItemMac(ref macro) => visitor.visit_mac(macro),\n+        ItemMac(ref mac) => visitor.visit_mac(mac),\n     }\n     for attr in item.attrs.iter() {\n         visitor.visit_attribute(attr);\n@@ -511,7 +511,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n             }\n         }\n         PatBox(ref subpattern) |\n-        PatRegion(ref subpattern) => {\n+        PatRegion(ref subpattern, _) => {\n             visitor.visit_pat(&**subpattern)\n         }\n         PatIdent(_, ref pth1, ref optional_subpattern) => {\n@@ -538,7 +538,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 visitor.visit_pat(&**postpattern)\n             }\n         }\n-        PatMac(ref macro) => visitor.visit_mac(macro),\n+        PatMac(ref mac) => visitor.visit_mac(mac),\n     }\n }\n \n@@ -738,7 +738,7 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n         StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n             visitor.visit_expr(&**expression)\n         }\n-        StmtMac(ref macro, _) => visitor.visit_mac(&**macro),\n+        StmtMac(ref mac, _) => visitor.visit_mac(&**mac),\n     }\n }\n \n@@ -885,7 +885,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprRet(ref optional_expression) => {\n             walk_expr_opt(visitor, optional_expression)\n         }\n-        ExprMac(ref macro) => visitor.visit_mac(macro),\n+        ExprMac(ref mac) => visitor.visit_mac(mac),\n         ExprParen(ref subexpression) => {\n             visitor.visit_expr(&**subexpression)\n         }"}, {"sha": "dd42bede13ac3e69d8f35850bad010214a9e9e24", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -52,7 +52,13 @@\n \n #![deny(missing_docs)]\n \n-#[phase(plugin, link)] extern crate log;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n \n pub use terminfo::TerminfoTerminal;\n #[cfg(windows)]"}, {"sha": "5f0111c7d7a84de51191dff892f86531c099cc44", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -160,12 +160,12 @@ pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tb\n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: &mut io::Reader, longnames: bool)\n              -> Result<Box<TermInfo>, String> {\n-    macro_rules! try( ($e:expr) => (\n+    macro_rules! try { ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n             Err(e) => return Err(format!(\"{}\", e))\n         }\n-    ) );\n+    ) }\n \n     let bnames;\n     let snames;"}, {"sha": "0419d85d3914ec32bde0b610532ce62649a5bbcc", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -32,7 +32,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(unknown_features)]\n-#![feature(asm, macro_rules, phase, globs, slicing_syntax)]\n+#![feature(asm, globs, slicing_syntax)]\n #![feature(unboxed_closures, default_type_params)]\n #![feature(old_orphan_check)]\n "}, {"sha": "8daabf610102256d86e1e86d8fb754977e1830a7", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -39,7 +39,7 @@ fn local_sort<T: Float>(v: &mut [T]) {\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats <T: FloatMath + FromPrimitive> for Sized? {\n+pub trait Stats <T: FloatMath + FromPrimitive> {\n \n     /// Sum of the samples.\n     ///\n@@ -169,7 +169,8 @@ impl<T: FloatMath + FromPrimitive> Stats<T> for [T] {\n     fn sum(&self) -> T {\n         let mut partials = vec![];\n \n-        for &mut x in self.iter() {\n+        for &x in self.iter() {\n+            let mut x = x;\n             let mut j = 0;\n             // This inner loop applies `hi`/`lo` summation to each\n             // partial so that the list of partial sums remains exact."}, {"sha": "13672a7b480af93459e372794e112c1755d75ab8", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -37,7 +37,7 @@ pub struct Words<'a> {\n \n /// Methods for Unicode string slices\n #[allow(missing_docs)] // docs in libcollections\n-pub trait UnicodeStr for Sized? {\n+pub trait UnicodeStr {\n     fn graphemes<'a>(&'a self, is_extended: bool) -> Graphemes<'a>;\n     fn grapheme_indices<'a>(&'a self, is_extended: bool) -> GraphemeIndices<'a>;\n     fn words<'a>(&'a self) -> Words<'a>;"}, {"sha": "b820135911e17c7a46b901db56baa48e5155bf46", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -1 +1 @@\n-Subproject commit ec1fdb3b9d3b1fb9e1dae97a65dd3a13db9bfb23\n+Subproject commit b820135911e17c7a46b901db56baa48e5155bf46"}, {"sha": "2ac855681f28b9970b1b95e770552532a30149c5", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2015-01-03\n+2015-01-05"}, {"sha": "44fbcf2150a4bf9050ad727622351f4806cd10d4", "filename": "src/test/auxiliary/associated-types-cc-lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,7 +12,6 @@\n // cross-crate scenario.\n \n #![crate_type=\"lib\"]\n-#![feature(associated_types)]\n \n pub trait Bar {\n     type T;"}, {"sha": "d12f716decf9925dfe4e53cb1e58f034dab283f8", "filename": "src/test/auxiliary/default_type_params_xc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(default_type_params)]\n-\n pub struct Heap;\n \n pub struct FakeHeap;"}, {"sha": "5510d3e2e0df18386d82ee8c10183186d608ea70", "filename": "src/test/auxiliary/issue-13560-3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fissue-13560-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fissue-13560-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-13560-3.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -11,8 +11,7 @@\n // no-prefer-dynamic\n \n #![crate_type = \"rlib\"]\n-#![feature(phase)]\n \n-#[phase(plugin)] extern crate \"issue-13560-1\" as t1;\n-#[phase(plugin, link)] extern crate \"issue-13560-2\" as t2;\n+#[macro_use] #[no_link] extern crate \"issue-13560-1\" as t1;\n+#[macro_use] extern crate \"issue-13560-2\" as t2;\n "}, {"sha": "c3f7f2d1aa1666ede0d3c29d0e33584c5cbc7f46", "filename": "src/test/auxiliary/issue-16643.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-16643.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![crate_type = \"lib\"]\n-#![feature(associated_types)]\n \n pub struct TreeBuilder<H>;\n "}, {"sha": "7a378b06df9e175ceac52066671a93b94ce8825e", "filename": "src/test/auxiliary/issue_20389.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fissue_20389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fissue_20389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_20389.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(associated_types)]\n-\n pub trait T {\n     type C;\n }"}, {"sha": "8a212f6e5a9c5050b055fa29cd6fd0cd9e87f992", "filename": "src/test/auxiliary/issue_2316_b.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fissue_2316_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fissue_2316_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2316_b.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![allow(unused_imports)]\n-#![feature(globs)]\n \n extern crate issue_2316_a;\n "}, {"sha": "e99a8f0b8773750c9e9ec77130b6a9c2bf2be8c6", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -12,7 +12,7 @@\n #![feature(lang_items)]\n \n #[lang=\"sized\"]\n-pub trait Sized for Sized? {}\n+pub trait Sized {}\n \n #[lang=\"panic\"]\n fn panic(_: &(&'static str, &'static str, uint)) -> ! { loop {} }"}, {"sha": "6cd94ee5602aa5ccf3db96b0b1f3ccda3dcae6ef", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -27,7 +27,7 @@ fn bar() { }\n fn baz() { }\n \n pub fn test() {\n-    let none: Option<Path> = None; // appease the typechecker\n+    let none: Option<&Path> = None; // appease the typechecker\n     let lib = DynamicLibrary::open(none).unwrap();\n     unsafe {\n         assert!(lib.symbol::<int>(\"foo\").is_ok());"}, {"sha": "097a5827fc4be1fe937301a2e97da7c71837a616", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,12 +10,12 @@\n \n // force-host\n \n-#![feature(phase, plugin_registrar)]\n+#![feature(plugin_registrar)]\n \n extern crate syntax;\n \n // Load rustc as a plugin to get macros\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate rustc;\n \n use syntax::ast;"}, {"sha": "01ef08c475234c3a402dd66648755eed2ce5c3ef", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,12 +10,12 @@\n \n // force-host\n \n-#![feature(phase, plugin_registrar)]\n+#![feature(plugin_registrar)]\n \n extern crate syntax;\n \n // Load rustc as a plugin to get macros\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate rustc;\n \n use syntax::ast;"}, {"sha": "708830d02598643bed2c33caa802baccd910b628", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,9 +10,6 @@\n #![crate_name=\"lint_stability\"]\n #![crate_type = \"lib\"]\n \n-#![feature(macro_rules)]\n-#![macro_escape]\n-\n #[deprecated]\n pub fn deprecated() {}\n #[deprecated=\"text\"]\n@@ -181,16 +178,16 @@ pub struct FrozenTupleStruct(pub int);\n pub struct LockedTupleStruct(pub int);\n \n #[macro_export]\n-macro_rules! macro_test(\n+macro_rules! macro_test {\n     () => (deprecated());\n-);\n+}\n \n #[macro_export]\n-macro_rules! macro_test_arg(\n+macro_rules! macro_test_arg {\n     ($func:expr) => ($func);\n-);\n+}\n \n #[macro_export]\n-macro_rules! macro_test_arg_nested(\n+macro_rules! macro_test_arg_nested {\n     ($func:ident) => (macro_test_arg!($func()));\n-);\n+}"}, {"sha": "67037a3ac9e08cde559758543ff5280e342b3849", "filename": "src/test/auxiliary/logging_right_crate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(phase)]\n-#[phase(plugin, link)] extern crate log;\n+#[macro_use] extern crate log;\n \n pub fn foo<T>() {\n     fn death() -> int { panic!() }"}, {"sha": "d50c27a4e75bb0efae4bb6c6fbd2e98e03b8bbb3", "filename": "src/test/auxiliary/macro_crate_MacroRulesTT.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![feature(plugin_registrar)]\n+\n+extern crate syntax;\n+extern crate rustc;\n+\n+use syntax::parse::token;\n+use syntax::ext::base::MacroRulesTT;\n+use rustc::plugin::Registry;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_syntax_extension(token::intern(\"bogus\"), MacroRulesTT);\n+}"}, {"sha": "4f55ac4f65fd48ee9e56f8164fc8b73dcba93419", "filename": "src/test/auxiliary/macro_crate_def_only.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n #[macro_export]\n-macro_rules! make_a_5(\n+macro_rules! make_a_5 {\n     () => (5)\n-);\n+}"}, {"sha": "922efc1aec38fa99f2a1928155a0c85c28d3f78e", "filename": "src/test/auxiliary/macro_crate_nonterminal.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn increment(x: uint) -> uint {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! increment {\n+    ($x:expr) => ($crate::increment($x))\n+}\n+\n+pub fn check_local() {\n+    assert_eq!(increment!(3), 4);\n+}"}, {"sha": "99f02cf2d58ba02ca15d5f74e348ea2d8a1fd51c", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -10,7 +10,7 @@\n \n // force-host\n \n-#![feature(globs, plugin_registrar, macro_rules, quote)]\n+#![feature(plugin_registrar, quote)]\n \n extern crate syntax;\n extern crate rustc;\n@@ -24,9 +24,9 @@ use syntax::ptr::P;\n use rustc::plugin::Registry;\n \n #[macro_export]\n-macro_rules! exported_macro (() => (2i));\n+macro_rules! exported_macro { () => (2i) }\n \n-macro_rules! unexported_macro (() => (3i));\n+macro_rules! unexported_macro { () => (3i) }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "84e944f69b98ee406dfec98baea4aaf10a1db92d", "filename": "src/test/auxiliary/macro_export_inner_module.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n pub mod inner {\n     #[macro_export]\n-    macro_rules! foo(\n+    macro_rules! foo {\n         () => (1)\n-    );\n+    }\n }"}, {"sha": "910fcd2e3671d55321f570f364cd4046bfc0e753", "filename": "src/test/auxiliary/macro_non_reexport_2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_non_reexport_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_non_reexport_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_non_reexport_2.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]\n+\n+// Since we load a serialized macro with all its attributes, accidentally\n+// re-exporting a `#[macro_export] macro_rules!` is something of a concern!\n+//\n+// We avoid it at the moment only because of the order in which we do things.\n+\n+#[macro_use] #[no_link]\n+extern crate macro_reexport_1;"}, {"sha": "a913749bc66a92397d8399a4fa85840499aaf64b", "filename": "src/test/auxiliary/macro_reexport_1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_reexport_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_reexport_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_reexport_1.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]\n+#[macro_export]\n+macro_rules! reexported {\n+    () => ( 3u )\n+}"}, {"sha": "15d9f9cc9146d0a2c5e88fd1e2e762b1cc2b1fe1", "filename": "src/test/auxiliary/macro_reexport_2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]\n+\n+#[macro_reexport(reexported)]\n+#[macro_use] #[no_link]\n+extern crate macro_reexport_1;"}, {"sha": "63142b0a69935bd63308ef2a8ff8321fece1c287", "filename": "src/test/auxiliary/macro_reexport_2_no_use.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2_no_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2_no_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2_no_use.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]\n+\n+#[macro_reexport(reexported)]\n+#[no_link]\n+extern crate macro_reexport_1;"}, {"sha": "7412c17fd45b28cf3b32854f39f94866ff241bcd", "filename": "src/test/auxiliary/namespaced_enum_emulate_flat.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs)]\n \n pub use Foo::*;\n \n@@ -34,5 +33,3 @@ pub mod nest {\n         pub fn foo() {}\n     }\n }\n-\n-"}, {"sha": "caa9bbe5736e4adb55d0c7620dfe996b0feef5dc", "filename": "src/test/auxiliary/overloaded_autoderef_xc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(associated_types)]\n-\n use std::ops::Deref;\n \n struct DerefWithHelper<H, T> {"}, {"sha": "b90c3f1d727bf6190b37539a2fcff83b1ed80aa1", "filename": "src/test/auxiliary/plugin_args.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_args.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![feature(plugin_registrar)]\n+\n+extern crate syntax;\n+extern crate rustc;\n+\n+use std::borrow::ToOwned;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacExpr, NormalTT};\n+use syntax::parse::token;\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n+use rustc::plugin::Registry;\n+\n+struct Expander {\n+    args: P<ast::MetaItem>,\n+}\n+\n+impl TTMacroExpander for Expander {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   sp: Span,\n+                   _: &[ast::TokenTree]) -> Box<MacResult+'cx> {\n+\n+        let attr = ecx.attribute(sp, self.args.clone());\n+        let src = pprust::attribute_to_string(&attr);\n+        let interned = token::intern_and_get_ident(src.as_slice());\n+        MacExpr::new(ecx.expr_str(sp, interned))\n+    }\n+}\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    let args = reg.args().clone();\n+    reg.register_syntax_extension(token::intern(\"plugin_args\"),\n+        NormalTT(box Expander { args: args, }, None));\n+}"}, {"sha": "12833daf6045854990ba64e416c6670832e64876", "filename": "src/test/auxiliary/svh-a-base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "9e74bf281358faa1e582d81080183fb0fc38f392", "filename": "src/test/auxiliary/svh-a-change-lit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "c900550041b5c82a58d243ce64e67c18a1cf72d4", "filename": "src/test/auxiliary/svh-a-change-significant-cfg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "04f8eb3cf9bc0fd4121230931631fa66da136818", "filename": "src/test/auxiliary/svh-a-change-trait-bound.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "c7e0a18768a3d36ae7271d56bd00fd5bcd3ee9fb", "filename": "src/test/auxiliary/svh-a-change-type-arg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "5100af323183b18726535987931245f269798ed0", "filename": "src/test/auxiliary/svh-a-change-type-ret.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "077c33cb90d756f3555b64c1aa81c2b1f4a7b2a0", "filename": "src/test/auxiliary/svh-a-change-type-static.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "d481fa5a1fa3b033d65967408d0f13e7209e53d2", "filename": "src/test/auxiliary/svh-a-comment.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs?ref=340ac040f7603e169a3739c65956ed2213622be5", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "9e99a355ac1ee2a17df3d10d77ed5bb798e93a6d", "filename": "src/test/auxiliary/svh-a-doc.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs?ref=340ac040f7603e169a3739c65956ed2213622be5"}, {"sha": "b8dd497ac99c8e6fae182d27dd29d4a40d0491df", "filename": "src/test/auxiliary/svh-a-macro.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs?ref=340ac040f7603e169a3739c65956ed2213622be5"}, {"sha": "12833daf6045854990ba64e416c6670832e64876", "filename": "src/test/auxiliary/svh-a-no-change.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs?ref=340ac040f7603e169a3739c65956ed2213622be5"}, {"sha": "690ddc670f5fa57bb919d670d9bf31c4b1d45a33", "filename": "src/test/auxiliary/svh-a-redundant-cfg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs?ref=340ac040f7603e169a3739c65956ed2213622be5"}, {"sha": "216e8e997f22de643e86f712dd718888965dd7a1", "filename": "src/test/auxiliary/svh-a-whitespace.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs?ref=340ac040f7603e169a3739c65956ed2213622be5"}, {"sha": "5ad1d244c926d378875b8a1b2e27bc38bcffd8ea", "filename": "src/test/auxiliary/syntax-extension-with-dll-deps-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsyntax-extension-with-dll-deps-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Fsyntax-extension-with-dll-deps-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsyntax-extension-with-dll-deps-2.rs?ref=340ac040f7603e169a3739c65956ed2213622be5"}, {"sha": "cbd2ac69c789415114f21ea2408fb8eae84d8ac8", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=340ac040f7603e169a3739c65956ed2213622be5"}, {"sha": "33824af6187a2ff6757d379737ff7c13600cfc4f", "filename": "src/test/auxiliary/traitimpl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Ftraitimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Ftraitimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftraitimpl.rs?ref=340ac040f7603e169a3739c65956ed2213622be5"}, {"sha": "060960f0dbc88cd40b16ede1144175c463a0bfdb", "filename": "src/test/auxiliary/two_macros.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Ftwo_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340ac040f7603e169a3739c65956ed2213622be5/src%2Ftest%2Fauxiliary%2Ftwo_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftwo_macros.rs?ref=340ac040f7603e169a3739c65956ed2213622be5"}]}