{"sha": "7fbff36d01e21380894a323bbf537219a8359291", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYmZmMzZkMDFlMjEzODA4OTRhMzIzYmJmNTM3MjE5YTgzNTkyOTE=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-29T02:10:56Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T11:02:24Z"}, "message": "Change `with_cond` to `build_cond_br`\n\nThis is simpler to work with than `with_cond`.", "tree": {"sha": "e5387ce66d532dca32ece23ed2d2b1eed3cd3b0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5387ce66d532dca32ece23ed2d2b1eed3cd3b0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fbff36d01e21380894a323bbf537219a8359291", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fbff36d01e21380894a323bbf537219a8359291", "html_url": "https://github.com/rust-lang/rust/commit/7fbff36d01e21380894a323bbf537219a8359291", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fbff36d01e21380894a323bbf537219a8359291/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcdb2602f8c4f6952f47c78cf41db0ad8223b929", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcdb2602f8c4f6952f47c78cf41db0ad8223b929", "html_url": "https://github.com/rust-lang/rust/commit/bcdb2602f8c4f6952f47c78cf41db0ad8223b929"}], "stats": {"total": 64, "additions": 25, "deletions": 39}, "files": [{"sha": "0236a6c0c80428cc74bf2348ed24a4e12b7a31c7", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7fbff36d01e21380894a323bbf537219a8359291/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbff36d01e21380894a323bbf537219a8359291/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=7fbff36d01e21380894a323bbf537219a8359291", "patch": "@@ -83,10 +83,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    // Helper method for generating MIR inside a conditional block.\n-    pub fn with_cond<F>(&mut self, block: BasicBlock, span: Span,\n-                        cond: Operand<'tcx>, f: F) -> BasicBlock\n-    where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>, BasicBlock) -> BasicBlock {\n+    // Helper method for generating a conditional branch\n+    // Returns (TrueBlock, FalseBlock)\n+    pub fn build_cond_br(&mut self, block: BasicBlock, span: Span,\n+                         cond: Operand<'tcx>) -> (BasicBlock, BasicBlock) {\n         let scope_id = self.innermost_scope_id();\n \n         let then_block = self.cfg.start_new_block();\n@@ -98,15 +98,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                targets: (then_block, else_block)\n                            });\n \n-        let after = f(self, then_block);\n-\n-        // If the returned block isn't terminated, add a branch to the \"else\"\n-        // block\n-        if !self.cfg.terminated(after) {\n-            self.cfg.terminate(after, scope_id, span,\n-                               TerminatorKind::Goto { target: else_block });\n-        }\n-\n-        else_block\n+        (then_block, else_block)\n     }\n }"}, {"sha": "4859257f291c9767f694b9d4171ddcfeaabb0805", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fbff36d01e21380894a323bbf537219a8359291/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbff36d01e21380894a323bbf537219a8359291/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=7fbff36d01e21380894a323bbf537219a8359291", "patch": "@@ -86,17 +86,12 @@ impl<'tcx> CFG<'tcx> {\n                      scope: ScopeId,\n                      span: Span,\n                      kind: TerminatorKind<'tcx>) {\n-        debug_assert!(!self.terminated(block),\n+        debug_assert!(self.block_data(block).terminator.is_none(),\n                       \"terminate: block {:?} already has a terminator set\", block);\n         self.block_data_mut(block).terminator = Some(Terminator {\n             span: span,\n             scope: scope,\n             kind: kind,\n         });\n     }\n-\n-    /// Returns whether or not the given block has been terminated or not\n-    pub fn terminated(&self, block: BasicBlock) -> bool {\n-        self.block_data(block).terminator.is_some()\n-    }\n }"}, {"sha": "683efdc141fbf36af9c3fef7a850ce02acb6d890", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7fbff36d01e21380894a323bbf537219a8359291/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbff36d01e21380894a323bbf537219a8359291/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=7fbff36d01e21380894a323bbf537219a8359291", "patch": "@@ -88,11 +88,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     this.cfg.push_assign(block, scope_id, expr_span, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, arg.clone(), minval));\n \n-                    block = this.with_cond(\n-                        block, expr_span, Operand::Consume(is_min), |this, block| {\n-                            this.panic(block, \"attempted to negate with overflow\", expr_span);\n-                            block\n-                        });\n+                    let (of_block, ok_block) = this.build_cond_br(block, expr_span,\n+                                                                  Operand::Consume(is_min));\n+                    this.panic(of_block, \"attempted to negate with overflow\", expr_span);\n+                    block = ok_block;\n                 }\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n@@ -243,7 +242,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn build_binary_op(&mut self, mut block: BasicBlock, op: BinOp, span: Span, ty: ty::Ty<'tcx>,\n+    pub fn build_binary_op(&mut self, mut block: BasicBlock,\n+                           op: BinOp, span: Span, ty: ty::Ty<'tcx>,\n                            lhs: Operand<'tcx>, rhs: Operand<'tcx>) -> BlockAnd<Rvalue<'tcx>> {\n         let scope_id = self.innermost_scope_id();\n         let bool_ty = self.hir.bool_ty();\n@@ -267,12 +267,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 \"arithmetic operation overflowed\"\n             };\n \n-            block = self.with_cond(block, span, Operand::Consume(of), |this, block| {\n-                this.panic(block, msg, span);\n-                block\n-            });\n+            let (of_block, ok_block) = self.build_cond_br(block, span, Operand::Consume(of));\n+            self.panic(of_block, msg, span);\n \n-            block.and(Rvalue::Use(Operand::Consume(val)))\n+            ok_block.and(Rvalue::Use(Operand::Consume(val)))\n         } else {\n             if ty.is_integral() && (op == BinOp::Div || op == BinOp::Rem) {\n                 // Checking division and remainder is more complex, since we 1. always check\n@@ -292,10 +290,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.cfg.push_assign(block, scope_id, span, &is_zero,\n                                      Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), zero));\n \n-                block = self.with_cond(block, span, Operand::Consume(is_zero), |this, block| {\n-                    this.panic(block, zero_msg, span);\n-                    block\n-                });\n+                let (zero_block, ok_block) = self.build_cond_br(block, span,\n+                                                                Operand::Consume(is_zero));\n+                self.panic(zero_block, zero_msg, span);\n+\n+                block = ok_block;\n \n                 // We only need to check for the overflow in one case:\n                 // MIN / -1, and only for signed values.\n@@ -319,10 +318,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     self.cfg.push_assign(block, scope_id, span, &of,\n                                          Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n \n-                    block = self.with_cond(block, span, Operand::Consume(of), |this, block| {\n-                        this.panic(block, overflow_msg, span);\n-                        block\n-                    });\n+                    let (of_block, ok_block) = self.build_cond_br(block, span,\n+                                                                  Operand::Consume(of));\n+                    self.panic(of_block, overflow_msg, span);\n+\n+                    block = ok_block;\n                 }\n             }\n "}]}