{"sha": "ed02344fbc7d3bed591f528304f603f9d320e919", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMDIzNDRmYmM3ZDNiZWQ1OTFmNTI4MzA0ZjYwM2Y5ZDMyMGU5MTk=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-07-31T14:33:41Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-13T13:37:09Z"}, "message": "Remove obsolete divergence related stuff\n\nReplace FnOutput with Ty\nReplace FnConverging(ty) with ty\nPurge FnDiverging, FunctionRetTy::NoReturn and FunctionRetTy::None", "tree": {"sha": "00147b88e33ce6ce3a408c14491354c8f42aa76a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00147b88e33ce6ce3a408c14491354c8f42aa76a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed02344fbc7d3bed591f528304f603f9d320e919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed02344fbc7d3bed591f528304f603f9d320e919", "html_url": "https://github.com/rust-lang/rust/commit/ed02344fbc7d3bed591f528304f603f9d320e919", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed02344fbc7d3bed591f528304f603f9d320e919/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee78f37e2a68120119dcda4312db0be3b545eabe", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee78f37e2a68120119dcda4312db0be3b545eabe", "html_url": "https://github.com/rust-lang/rust/commit/ee78f37e2a68120119dcda4312db0be3b545eabe"}], "stats": {"total": 837, "additions": 250, "deletions": 587}, "files": [{"sha": "b3f7af77691ff50df16a9075564755ecf1a88e63", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -379,7 +379,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if fn_ty.fn_ret().diverges(self.tcx) {\n+        if fn_ty.fn_ret().0.is_empty(self.tcx) {\n             self.add_unreachable_node()\n         } else {\n             ret"}, {"sha": "d8b39f1f9587b4158b06aac06c821fe143ee85dd", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -516,7 +516,6 @@ pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n             output: match output {\n                 Return(ty) => Return(fld.fold_ty(ty)),\n                 DefaultReturn(span) => DefaultReturn(span),\n-                NoReturn(span) => NoReturn(span),\n             },\n             variadic: variadic,\n         }"}, {"sha": "45eaca4100b72e5e496c81915e09e0c62f1e1b85", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -403,7 +403,6 @@ impl<'a> LoweringContext<'a> {\n             output: match decl.output {\n                 FunctionRetTy::Ty(ref ty) => hir::Return(self.lower_ty(ty)),\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n-                FunctionRetTy::None(span) => hir::NoReturn(span),\n             },\n             variadic: decl.variadic,\n         })"}, {"sha": "d726625f2fccabfe24197406017828dae6cfe478", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1286,9 +1286,6 @@ impl fmt::Debug for ImplPolarity {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum FunctionRetTy {\n-    /// Functions with return type `!`that always\n-    /// raise an error or exit (i.e. never return to the caller)\n-    NoReturn(Span),\n     /// Return type is not specified.\n     ///\n     /// Functions default to `()` and\n@@ -1302,7 +1299,6 @@ pub enum FunctionRetTy {\n impl FunctionRetTy {\n     pub fn span(&self) -> Span {\n         match *self {\n-            NoReturn(span) => span,\n             DefaultReturn(span) => span,\n             Return(ref ty) => ty.span,\n         }"}, {"sha": "20d069c126dffb97a358361a000976a61b7172ab", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1962,10 +1962,6 @@ impl<'a> State<'a> {\n                 self.maybe_print_comment(ty.span.lo)\n             }\n             hir::DefaultReturn(..) => unreachable!(),\n-            hir::NoReturn(span) => {\n-                self.word_nbsp(\"!\")?;\n-                self.maybe_print_comment(span.lo)\n-            }\n         }\n     }\n \n@@ -2198,7 +2194,6 @@ impl<'a> State<'a> {\n         self.ibox(indent_unit)?;\n         self.word_space(\"->\")?;\n         match decl.output {\n-            hir::NoReturn(_) => self.word_nbsp(\"!\")?,\n             hir::DefaultReturn(..) => unreachable!(),\n             hir::Return(ref ty) => self.print_type(&ty)?,\n         }"}, {"sha": "b0dec3277a9967686ddaf937e825947a26267000", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1326,7 +1326,6 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 self.rebuild_arg_ty_or_output(&ret_ty, lifetime, anon_nums, region_names)\n             ),\n             hir::DefaultReturn(span) => hir::DefaultReturn(span),\n-            hir::NoReturn(span) => hir::NoReturn(span)\n         }\n     }\n "}, {"sha": "24fadc549fafc221e748cdaff099c9781863b5d4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -607,7 +607,6 @@ impl_trans_normalize!('gcx,\n     Ty<'gcx>,\n     &'gcx Substs<'gcx>,\n     ty::FnSig<'gcx>,\n-    ty::FnOutput<'gcx>,\n     &'gcx ty::BareFnTy<'gcx>,\n     ty::ClosureSubsts<'gcx>,\n     ty::PolyTraitRef<'gcx>"}, {"sha": "a1a4f15b9f78edde483daf7e1dc857a613e66b09", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -161,10 +161,9 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n                     let typ = self.infcx.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n                         ty::TyFnDef(_, _, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n-                            if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n-                                let from = bare_fn_ty.sig.0.inputs[0];\n-                                self.check_transmute(expr.span, from, to, expr.id);\n-                            }\n+                            let from = bare_fn_ty.sig.0.inputs[0];\n+                            let to = bare_fn_ty.sig.0.output;\n+                            self.check_transmute(expr.span, from, to, expr.id);\n                         }\n                         _ => {\n                             span_bug!(expr.span, \"transmute wasn't a bare fn?!\");"}, {"sha": "38988affbd06b173341cdf4d6b19ad10db320713", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1112,7 +1112,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n-                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().diverges(self.ir.tcx);\n+                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().0.is_empty(self.ir.tcx);\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1125,7 +1125,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n-            let succ = if method_ty.fn_ret().diverges(self.ir.tcx) {\n+            let succ = if method_ty.fn_ret().0.is_empty(self.ir.tcx) {\n                 self.s.exit_ln\n             } else {\n                 succ\n@@ -1454,7 +1454,7 @@ fn check_fn(_v: &Liveness,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n+    fn fn_ret(&self, id: NodeId) -> ty::Binder<ty::Ty<'tcx>> {\n         let fn_ty = self.ir.tcx.node_id_to_type(id);\n         match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n@@ -1477,55 +1477,44 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 self.ir.tcx.region_maps.call_site_extent(id, body.id),\n                 &self.fn_ret(id));\n \n-        match fn_ret {\n-            ty::FnConverging(t_ret)\n-                    if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n-\n-                let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n-                let t_ret_subst = t_ret.subst(self.ir.tcx, &param_env.free_substs);\n-                let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n-                                                    Reveal::All).enter(|infcx| {\n-                    let cause = traits::ObligationCause::dummy();\n-                    traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n-                });\n-\n-                // for nil return types, it is ok to not return a value expl.\n-                if !is_nil {\n-                    let ends_with_stmt = match body.expr {\n-                        None if !body.stmts.is_empty() =>\n-                            match body.stmts.last().unwrap().node {\n-                                hir::StmtSemi(ref e, _) => {\n-                                    self.ir.tcx.expr_ty(&e) == t_ret\n-                                },\n-                                _ => false\n+        if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n+            let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n+            let t_ret_subst = fn_ret.subst(self.ir.tcx, &param_env.free_substs);\n+            let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n+                                                Reveal::All).enter(|infcx| {\n+                let cause = traits::ObligationCause::dummy();\n+                traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n+            });\n+\n+            // for nil return types, it is ok to not return a value expl.\n+            if !is_nil {\n+                let ends_with_stmt = match body.expr {\n+                    None if !body.stmts.is_empty() =>\n+                        match body.stmts.last().unwrap().node {\n+                            hir::StmtSemi(ref e, _) => {\n+                                self.ir.tcx.expr_ty(&e) == fn_ret\n                             },\n-                        _ => false\n+                            _ => false\n+                        },\n+                    _ => false\n+                };\n+                let mut err = struct_span_err!(self.ir.tcx.sess,\n+                                               sp,\n+                                               E0269,\n+                                               \"not all control paths return a value\");\n+                if ends_with_stmt {\n+                    let last_stmt = body.stmts.last().unwrap();\n+                    let original_span = original_sp(self.ir.tcx.sess.codemap(),\n+                                                    last_stmt.span, sp);\n+                    let span_semicolon = Span {\n+                        lo: original_span.hi - BytePos(1),\n+                        hi: original_span.hi,\n+                        expn_id: original_span.expn_id\n                     };\n-                    let mut err = struct_span_err!(self.ir.tcx.sess,\n-                                                   sp,\n-                                                   E0269,\n-                                                   \"not all control paths return a value\");\n-                    if ends_with_stmt {\n-                        let last_stmt = body.stmts.last().unwrap();\n-                        let original_span = original_sp(self.ir.tcx.sess.codemap(),\n-                                                        last_stmt.span, sp);\n-                        let span_semicolon = Span {\n-                            lo: original_span.hi - BytePos(1),\n-                            hi: original_span.hi,\n-                            expn_id: original_span.expn_id\n-                        };\n-                        err.span_help(span_semicolon, \"consider removing this semicolon:\");\n-                    }\n-                    err.emit();\n+                    err.span_help(span_semicolon, \"consider removing this semicolon:\");\n                 }\n+                err.emit();\n             }\n-            ty::FnDiverging\n-                if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() => {\n-                    span_err!(self.ir.tcx.sess, sp, E0270,\n-                        \"computation may converge in a function marked as diverging\");\n-                }\n-\n-            _ => {}\n         }\n     }\n "}, {"sha": "bee17c31248d782a0d5386127ed14324b4871567", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -923,7 +923,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n                 let ref_ty =\n-                    self.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n+                    self.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n@@ -1245,7 +1245,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // to skip past the binder.\n         self.tcx().no_late_bound_regions(&method_ty.fn_ret())\n            .unwrap()\n-           .unwrap() // overloaded ops do not diverge, either\n     }\n }\n "}, {"sha": "549026290c9d561f4d712bdc06040abc915916a3", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccesso\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n-use ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n+use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n use util::ppaux;\n use rustc_back::slice;\n use hir::InlineAsm;\n@@ -74,7 +74,7 @@ pub struct Mir<'tcx> {\n     pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n \n     /// Return type of the function.\n-    pub return_ty: FnOutput<'tcx>,\n+    pub return_ty: Ty<'tcx>,\n \n     /// Variables: these are stack slots corresponding to user variables. They may be\n     /// assigned many times.\n@@ -107,7 +107,7 @@ impl<'tcx> Mir<'tcx> {\n     pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n                visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n                promoted: IndexVec<Promoted, Mir<'tcx>>,\n-               return_ty: FnOutput<'tcx>,\n+               return_ty: Ty<'tcx>,\n                var_decls: IndexVec<Var, VarDecl<'tcx>>,\n                arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n                temp_decls: IndexVec<Temp, TempDecl<'tcx>>,"}, {"sha": "cf91229f1c713afa07c4baf714e51d161baa4df7", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -125,7 +125,7 @@ impl<'tcx> Lvalue<'tcx> {\n             &Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n             &Lvalue::ReturnPointer =>\n-                LvalueTy::Ty { ty: mir.return_ty.unwrap() },\n+                LvalueTy::Ty { ty: mir.return_ty },\n             &Lvalue::Projection(ref proj) =>\n                 proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n         }"}, {"sha": "66cdc7f156d9c1370c1ff36a120108846a0ad70c", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -11,7 +11,7 @@\n use middle::const_val::ConstVal;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n-use ty::{ClosureSubsts, FnOutput, Region, Ty};\n+use ty::{ClosureSubsts, Region, Ty};\n use mir::repr::*;\n use rustc_const_math::ConstUsize;\n use rustc_data_structures::tuple_slice::TupleSlice;\n@@ -38,9 +38,7 @@ use syntax_pos::Span;\n //\n // For the most part, we do not destructure things external to the\n // MIR, e.g. types, spans, etc, but simply visit them and stop. This\n-// avoids duplication with other visitors like `TypeFoldable`. But\n-// there is one exception: we do destructure the `FnOutput` to reach\n-// the type within. Just because.\n+// avoids duplication with other visitors like `TypeFoldable`.\n //\n // ## Updating\n //\n@@ -192,11 +190,6 @@ macro_rules! make_mir_visitor {\n                 self.super_source_info(source_info);\n             }\n \n-            fn visit_fn_output(&mut self,\n-                               fn_output: & $($mutability)* FnOutput<'tcx>) {\n-                self.super_fn_output(fn_output);\n-            }\n-\n             fn visit_ty(&mut self,\n                         ty: & $($mutability)* Ty<'tcx>) {\n                 self.super_ty(ty);\n@@ -261,7 +254,7 @@ macro_rules! make_mir_visitor {\n                     self.visit_visibility_scope_data(scope);\n                 }\n \n-                self.visit_fn_output(&$($mutability)* mir.return_ty);\n+                self.visit_ty(&$($mutability)* mir.return_ty);\n \n                 for var_decl in &$($mutability)* mir.var_decls {\n                     self.visit_var_decl(var_decl);\n@@ -702,16 +695,6 @@ macro_rules! make_mir_visitor {\n                 self.visit_visibility_scope(scope);\n             }\n \n-            fn super_fn_output(&mut self, fn_output: & $($mutability)* FnOutput<'tcx>) {\n-                match *fn_output {\n-                    FnOutput::FnConverging(ref $($mutability)* ty) => {\n-                        self.visit_ty(ty);\n-                    }\n-                    FnOutput::FnDiverging => {\n-                    }\n-                }\n-            }\n-\n             fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n             }\n "}, {"sha": "4889895860129144dc323c6ce52ebde00b364c89", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -269,10 +269,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 return Some(MethodViolationCode::ReferencesSelf);\n             }\n         }\n-        if let ty::FnConverging(result_type) = sig.0.output {\n-            if self.contains_illegal_self_type_reference(trait_def_id, result_type) {\n-                return Some(MethodViolationCode::ReferencesSelf);\n-            }\n+        if self.contains_illegal_self_type_reference(trait_def_id, sig.0.output) {\n+            return Some(MethodViolationCode::ReferencesSelf);\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`."}, {"sha": "d535606d1b63b9a21e2435c3a7bb1ff0855781c5", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1388,7 +1388,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: _,\n-                    output: ty::FnConverging(_),\n+                    output: _,\n                     variadic: false\n                 })\n             }) |\n@@ -1397,7 +1397,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: _,\n-                    output: ty::FnConverging(_),\n+                    output: _,\n                     variadic: false\n                 })\n             }) => {"}, {"sha": "818eb4eb2fb1e3cf1d30ce81d91d8f98852d67d5", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -515,7 +515,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             def_id: fn_trait_def_id,\n             substs: self.mk_substs(trait_substs),\n         };\n-        ty::Binder((trait_ref, sig.0.output.unwrap_or(self.mk_nil())))\n+        ty::Binder((trait_ref, sig.0.output))\n     }\n }\n "}, {"sha": "1bb92d6356c1abfce9623b37bd19f8efd4321885", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -234,8 +234,7 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n         if let Some(method_ty) = method_type(method_call) {\n             // Method calls always have all late-bound regions\n             // fully instantiated.\n-            let fn_ret = tcx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n-            adjusted_ty = fn_ret.unwrap();\n+            adjusted_ty = tcx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n         }\n         match adjusted_ty.builtin_deref(true, NoPreference) {\n             Some(mt) => mt.ty,"}, {"sha": "fa38bacba2ed43bf04a221667895d011544aa540", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -172,10 +172,7 @@ impl FlagComputation {\n         let mut computation = FlagComputation::new();\n \n         computation.add_tys(&fn_sig.0.inputs);\n-\n-        if let ty::FnConverging(output) = fn_sig.0.output {\n-            computation.add_ty(output);\n-        }\n+        computation.add_ty(fn_sig.0.output);\n \n         self.add_bound_computation(&computation);\n     }"}, {"sha": "3eeff6ee5792fe716d07d61691d10e750a2692ee", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -160,12 +160,6 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         sig.super_fold_with(self)\n     }\n \n-    fn fold_output(&mut self,\n-                      output: &ty::FnOutput<'tcx>)\n-                      -> ty::FnOutput<'tcx> {\n-        output.super_fold_with(self)\n-    }\n-\n     fn fold_bare_fn_ty(&mut self,\n                        fty: &'tcx ty::BareFnTy<'tcx>)\n                        -> &'tcx ty::BareFnTy<'tcx>"}, {"sha": "60d819bdad93454782de61515148b38bf96cde4e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -55,15 +55,14 @@ use hir::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{BuiltinBound, BuiltinBounds, ExistentialBounds};\n-pub use self::sty::{BareFnTy, FnSig, PolyFnSig, FnOutput, PolyFnOutput};\n+pub use self::sty::{BareFnTy, FnSig, PolyFnSig};\n pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n-pub use self::sty::FnOutput::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::Region::*;\n pub use self::sty::TypeVariants::*;"}, {"sha": "1997eac9728fdd2de5b20668d223da4ad890ad28", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -256,20 +256,11 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n         let inputs = relate_arg_vecs(relation,\n                                      &a.inputs,\n                                      &b.inputs)?;\n+        let output = relation.relate(&a.output, &b.output)?;\n \n-        let output = match (a.output, b.output) {\n-            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-                Ok(ty::FnConverging(relation.relate(&a_ty, &b_ty)?)),\n-            (ty::FnDiverging, ty::FnDiverging) =>\n-                Ok(ty::FnDiverging),\n-            (a, b) =>\n-                Err(TypeError::ConvergenceMismatch(\n-                    expected_found(relation, &(a != ty::FnDiverging), &(b != ty::FnDiverging)))),\n-        }?;\n-\n-        return Ok(ty::FnSig {inputs: inputs,\n-                             output: output,\n-                             variadic: a.variadic});\n+        Ok(ty::FnSig {inputs: inputs,\n+                      output: output,\n+                      variadic: a.variadic})\n     }\n }\n "}, {"sha": "840703afd6f6b25a673561e51badd6285028a601", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -220,18 +220,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoRef<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::FnOutput<'a> {\n-    type Lifted = ty::FnOutput<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            ty::FnConverging(ty) => {\n-                tcx.lift(&ty).map(ty::FnConverging)\n-            }\n-            ty::FnDiverging => Some(ty::FnDiverging)\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -587,26 +575,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::FnConverging(ref ty) => ty::FnConverging(ty.fold_with(folder)),\n-            ty::FnDiverging => ty::FnDiverging\n-        }\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_output(self)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::FnConverging(ref ty) => ty.visit_with(visitor),\n-            ty::FnDiverging => false,\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::FnSig { inputs: self.inputs.fold_with(folder),"}, {"sha": "fec2c3b5ae56eac6f1cad1462b680ae7b36d9769", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -29,7 +29,6 @@ use serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use hir;\n \n-use self::FnOutput::*;\n use self::InferTy::*;\n use self::TypeVariants::*;\n \n@@ -477,50 +476,6 @@ pub struct ClosureTy<'tcx> {\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub enum FnOutput<'tcx> {\n-    FnConverging(Ty<'tcx>),\n-    FnDiverging\n-}\n-\n-impl<'tcx> FnOutput<'tcx> {\n-    pub fn diverges(&self, tcx: TyCtxt) -> bool {\n-        match *self {\n-            FnConverging(ref ty) => ty.is_empty(tcx),\n-            FnDiverging => true,\n-        }\n-    }\n-\n-    pub fn unwrap(self) -> Ty<'tcx> {\n-        match self {\n-            ty::FnConverging(t) => t,\n-            ty::FnDiverging => bug!()\n-        }\n-    }\n-\n-    pub fn unwrap_or(self, def: Ty<'tcx>) -> Ty<'tcx> {\n-        match self {\n-            ty::FnConverging(t) => t,\n-            ty::FnDiverging => def\n-        }\n-    }\n-\n-    pub fn maybe_converging(self) -> Option<Ty<'tcx>> {\n-        match self {\n-            ty::FnConverging(t) => Some(t),\n-            ty::FnDiverging => None\n-        }\n-    }\n-}\n-\n-pub type PolyFnOutput<'tcx> = Binder<FnOutput<'tcx>>;\n-\n-impl<'tcx> PolyFnOutput<'tcx> {\n-    pub fn diverges(&self, tcx: TyCtxt) -> bool {\n-        self.0.diverges(tcx)\n-    }\n-}\n-\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n@@ -530,7 +485,7 @@ impl<'tcx> PolyFnOutput<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig<'tcx> {\n     pub inputs: Vec<Ty<'tcx>>,\n-    pub output: FnOutput<'tcx>,\n+    pub output: Ty<'tcx>,\n     pub variadic: bool\n }\n \n@@ -543,7 +498,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs[index])\n     }\n-    pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n+    pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output.clone())\n     }\n     pub fn variadic(&self) -> bool {\n@@ -1205,7 +1160,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         self.fn_sig().inputs()\n     }\n \n-    pub fn fn_ret(&self) -> Binder<FnOutput<'tcx>> {\n+    pub fn fn_ret(&self) -> Binder<Ty<'tcx>> {\n         self.fn_sig().output()\n     }\n "}, {"sha": "fef1e7a164ca2a2817b4c9dfdb4bd7091a5cb19e", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -110,10 +110,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n }\n \n fn push_sig_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, sig: &ty::PolyFnSig<'tcx>) {\n-    match sig.0.output {\n-        ty::FnConverging(output) => { stack.push(output); }\n-        ty::FnDiverging => { }\n-    }\n+    stack.push(sig.0.output);\n     push_reversed(stack, &sig.0.inputs);\n }\n "}, {"sha": "90ebf58f861560b698ce6eaec9293d2aa262a0f3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -34,7 +34,7 @@ pub fn verbose() -> bool {\n fn fn_sig(f: &mut fmt::Formatter,\n           inputs: &[Ty],\n           variadic: bool,\n-          output: ty::FnOutput)\n+          output: Ty)\n           -> fmt::Result {\n     write!(f, \"(\")?;\n     let mut inputs = inputs.iter();\n@@ -48,18 +48,11 @@ fn fn_sig(f: &mut fmt::Formatter,\n         }\n     }\n     write!(f, \")\")?;\n-\n-    match output {\n-        ty::FnConverging(ty) => {\n-            if !ty.is_nil() {\n-                write!(f, \" -> {}\", ty)?;\n-            }\n-            Ok(())\n-        }\n-        ty::FnDiverging => {\n-            write!(f, \" -> !\")\n-        }\n+    if !output.is_nil() {\n+        write!(f, \" -> {}\", output)?;\n     }\n+\n+    Ok(())\n }\n \n /// Namespace of the path given to parameterized to print.\n@@ -135,7 +128,7 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n         if let TyTuple(ref args) = substs.types.get_slice(subst::TypeSpace)[0].sty {\n-            return fn_sig(f, args, false, ty::FnConverging(projection_ty));\n+            return fn_sig(f, args, false, projection_ty);\n         }\n     }\n "}, {"sha": "b3feac2bdc5e0c2b71d83caa9207ee8303b57e4f", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use rustc::ty::{FnOutput, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -231,8 +231,7 @@ impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n     }\n }\n \n-struct MovePathDataBuilder<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+struct MovePathDataBuilder<'tcx> {\n     pre_move_paths: Vec<PreMovePath<'tcx>>,\n     rev_lookup: MovePathLookup<'tcx>,\n }\n@@ -412,7 +411,7 @@ impl<'tcx> MovePathLookup<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n+impl<'tcx> MovePathDataBuilder<'tcx> {\n     fn lookup(&mut self, lval: &Lvalue<'tcx>) -> Lookup<MovePathIndex> {\n         let proj = match *lval {\n             Lvalue::Var(var_idx) =>\n@@ -528,7 +527,6 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     // BlockContexts constructed on each iteration. (Moving is more\n     // straight-forward than mutable borrows in this instance.)\n     let mut builder = MovePathDataBuilder {\n-        mir: mir,\n         pre_move_paths: Vec::new(),\n         rev_lookup: MovePathLookup::new(mir),\n     };\n@@ -632,13 +630,8 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             TerminatorKind::Return => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n-                if let FnOutput::FnConverging(_) = bb_ctxt.builder.mir.return_ty {\n-                    debug!(\"gather_moves Return on_move_out_lval return {:?}\", source);\n-                    bb_ctxt.on_move_out_lval(SK::Return, &Lvalue::ReturnPointer, source);\n-                } else {\n-                    debug!(\"gather_moves Return on_move_out_lval \\\n-                            assuming unreachable return {:?}\", source);\n-                }\n+                debug!(\"gather_moves Return on_move_out_lval return {:?}\", source);\n+                bb_ctxt.on_move_out_lval(SK::Return, &Lvalue::ReturnPointer, source);\n             }\n \n             TerminatorKind::If { ref cond, targets: _ } => {\n@@ -749,15 +742,15 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     }\n }\n \n-struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n+struct BlockContext<'b, 'tcx: 'b> {\n     _tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     moves: &'b mut Vec<MoveOut>,\n-    builder: MovePathDataBuilder<'a, 'tcx>,\n+    builder: MovePathDataBuilder<'tcx>,\n     path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n     loc_map_bb: &'b mut Vec<Vec<MoveOutIndex>>,\n }\n \n-impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n+impl<'b, 'tcx: 'b> BlockContext<'b, 'tcx> {\n     fn on_move_out_lval(&mut self,\n                         stmt_kind: StmtKind,\n                         lval: &Lvalue<'tcx>,"}, {"sha": "7711091685d3848d4cd43ed0d3c8dd94951c5cf7", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             abi: Abi::Rust,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: input_args,\n-                output: ty::FnConverging(output_ty),\n+                output: output_ty,\n                 variadic: false,\n             }),\n         }))"}, {"sha": "ed17f3533d49f785750ff73ea7bac3b9aa63f098", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1110,10 +1110,9 @@ impl LateLintPass for MutableTransmutes {\n                 let typ = cx.tcx.node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(_, _, ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n-                        if let ty::FnConverging(to) = bare_fn.sig.0.output {\n-                            let from = bare_fn.sig.0.inputs[0];\n-                            return Some((&from.sty, &to.sty));\n-                        }\n+                        let from = bare_fn.sig.0.inputs[0];\n+                        let to = bare_fn.sig.0.output;\n+                        return Some((&from.sty, &to.sty));\n                     },\n                     _ => ()\n                 }"}, {"sha": "0ac12d77b1d96b4d97d2a8e67d154fbf0a16fcf6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -573,16 +573,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n \n                 let sig = cx.erase_late_bound_regions(&bare_fn.sig);\n-                match sig.output {\n-                    ty::FnDiverging => {}\n-                    ty::FnConverging(output) => {\n-                        if !output.is_nil() {\n-                            let r = self.check_type_for_ffi(cache, output);\n-                            match r {\n-                                FfiSafe => {}\n-                                _ => { return r; }\n-                            }\n-                        }\n+                if !sig.output.is_nil() {\n+                    let r = self.check_type_for_ffi(cache, sig.output);\n+                    match r {\n+                        FfiSafe => {}\n+                        _ => { return r; }\n                     }\n                 }\n                 for arg in sig.inputs {\n@@ -641,7 +636,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         if let hir::Return(ref ret_hir) = decl.output {\n-            let ret_ty = sig.output.unwrap();\n+            let ret_ty = sig.output;\n             if !ret_ty.is_nil() {\n                 self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty);\n             }"}, {"sha": "29dd9ba8b1b9615a1f5539806e13242d278a7ccc", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -540,13 +540,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'N' => false,\n             r => bug!(\"bad variadic: {}\", r),\n         };\n-        let output = match self.peek() {\n-            'z' => {\n-                self.pos += 1;\n-                ty::FnDiverging\n-            }\n-            _ => ty::FnConverging(self.parse_ty())\n-        };\n+        let output = self.parse_ty();\n         ty::Binder(ty::FnSig {inputs: inputs,\n                               output: output,\n                               variadic: variadic})"}, {"sha": "762a163da93b293a58d8ec968cbcedddbce2bb64", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -383,14 +383,7 @@ fn enc_fn_sig<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     } else {\n         write!(w, \"N\");\n     }\n-    match fsig.0.output {\n-        ty::FnConverging(result_type) => {\n-            enc_ty(w, cx, result_type);\n-        }\n-        ty::FnDiverging => {\n-            write!(w, \"z\");\n-        }\n-    }\n+    enc_ty(w, cx, fsig.0.output);\n }\n \n pub fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBounds) {"}, {"sha": "5c6286ae3670502be357813e15061dfabb3ff793", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -210,7 +210,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Call { ty, fun, args } => {\n                 let diverges = match ty.sty {\n                     ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n-                        f.sig.0.output.diverges(this.hir.tcx())\n+                        f.sig.0.output.is_empty(this.hir.tcx())\n                     }\n                     _ => false\n                 };"}, {"sha": "e4e1c7999a668ba95e5f8d04042a48c4724c7b1d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -162,7 +162,7 @@ macro_rules! unpack {\n pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        fn_id: ast::NodeId,\n                                        arguments: A,\n-                                       return_ty: ty::FnOutput<'gcx>,\n+                                       return_ty: ty::Ty<'gcx>,\n                                        ast_block: &'gcx hir::Block)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec)\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n@@ -255,7 +255,7 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     });\n \n     let ty = tcx.expr_ty_adjusted(ast_expr);\n-    builder.finish(vec![], IndexVec::new(), ty::FnConverging(ty))\n+    builder.finish(vec![], IndexVec::new(), ty)\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -287,7 +287,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn finish(self,\n               upvar_decls: Vec<UpvarDecl>,\n               arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n-              return_ty: ty::FnOutput<'tcx>)\n+              return_ty: ty::Ty<'tcx>)\n               -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n             if block.terminator.is_none() {\n@@ -309,7 +309,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn args_and_body<A>(&mut self,\n                         mut block: BasicBlock,\n-                        return_ty: ty::FnOutput<'tcx>,\n+                        return_ty: ty::Ty<'tcx>,\n                         arguments: A,\n                         argument_extent: CodeExtent,\n                         ast_block: &'gcx hir::Block)\n@@ -350,11 +350,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         // FIXME(#32959): temporary hack for the issue at hand\n-        let return_is_unit = if let ty::FnConverging(t) = return_ty {\n-            t.is_nil()\n-        } else {\n-            false\n-        };\n+        let return_is_unit = return_ty.is_nil();\n         // start the first basic block and translate the body\n         unpack!(block = self.ast_block(&Lvalue::ReturnPointer, return_is_unit, block, ast_block));\n "}, {"sha": "72b6d7f0e5aa514605252addab0cc268760c4650", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -12,7 +12,7 @@ use dot;\n use rustc::hir::def_id::DefId;\n use rustc::mir::repr::*;\n use rustc::mir::mir_map::MirMap;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use std::fmt::Debug;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n@@ -143,14 +143,7 @@ fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         write!(w, \"{:?}: {}\", Lvalue::Arg(Arg::new(i)), escape(&arg.ty))?;\n     }\n \n-    write!(w, \") -&gt; \")?;\n-\n-    // fn return type.\n-    match mir.return_ty {\n-        ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", escape(ty))?,\n-        ty::FnOutput::FnDiverging => write!(w, \"!\")?,\n-    }\n-\n+    write!(w, \") -&gt; {}\", escape(mir.return_ty))?;\n     write!(w, r#\"<br align=\"left\"/>\"#)?;\n \n     // User variable types (including the user's name in a comment)."}, {"sha": "bb6e9ba823ca1710f5bfeed49cb2f8f01f5c80bc", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -97,9 +97,9 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n                         let ref_ty = cx.tcx.no_late_bound_regions(&meth_ty.fn_ret());\n                         let (region, mutbl) = match ref_ty {\n-                            Some(ty::FnConverging(&ty::TyS {\n+                            Some(&ty::TyS {\n                                 sty: ty::TyRef(region, mt), ..\n-                            })) => (region, mt.mutbl),\n+                            }) => (region, mt.mutbl),\n                             _ => span_bug!(expr.span, \"autoderef returned bad type\")\n                         };\n \n@@ -955,10 +955,8 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let tables = cx.tcx.tables.borrow();\n     let callee = &tables.method_map[&method_call];\n     let ref_ty = callee.ty.fn_ret();\n-    let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap().unwrap();\n-    //                                              1~~~~~   2~~~~~\n-    // (1) callees always have all late-bound regions fully instantiated,\n-    // (2) overloaded methods don't return `!`\n+    let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n+    // callees always have all late-bound regions fully instantiated,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type"}, {"sha": "c58491096b94f0d3957442e3738f9c14c19e3b80", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::repr::*;\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::transform::MirSource;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n use std::fmt::Display;\n@@ -320,16 +320,10 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n             write!(w, \"{:?}: {}\", Lvalue::Arg(i), arg.ty)?;\n         }\n \n-        write!(w, \") -> \")?;\n-\n-        // fn return type.\n-        match mir.return_ty {\n-            ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", ty),\n-            ty::FnOutput::FnDiverging => write!(w, \"!\"),\n-        }\n+        write!(w, \") -> {}\", mir.return_ty)\n     } else {\n         assert!(mir.arg_decls.is_empty());\n-        write!(w, \": {} =\", mir.return_ty.unwrap())\n+        write!(w, \": {} =\", mir.return_ty)\n     }\n }\n "}, {"sha": "aaa20405b8d57979be1bea46a1f4e03daa2c8c34", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -25,7 +25,7 @@\n use rustc::mir::repr::*;\n use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use syntax_pos::Span;\n \n use build::Location;\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         let span = self.promoted.span;\n         let new_operand = Operand::Constant(Constant {\n             span: span,\n-            ty: self.promoted.return_ty.unwrap(),\n+            ty: self.promoted.return_ty,\n             literal: Literal::Promoted {\n                 index: Promoted::new(self.source.promoted.len())\n             }\n@@ -389,7 +389,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                     parent_scope: None\n                 }).into_iter().collect(),\n                 IndexVec::new(),\n-                ty::FnConverging(ty),\n+                ty,\n                 IndexVec::new(),\n                 IndexVec::new(),\n                 IndexVec::new(),"}, {"sha": "57c0f66448d358f12021e5b13d9772a48273b54f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -416,7 +416,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        let return_ty = mir.return_ty.unwrap();\n+        let return_ty = mir.return_ty;\n         self.qualif = self.return_qualif.unwrap_or(Qualif::NOT_CONST);\n \n         match self.mode {\n@@ -991,7 +991,7 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n \n             // Statics must be Sync.\n             if mode == Mode::Static {\n-                let ty = mir.return_ty.unwrap();\n+                let ty = mir.return_ty;\n                 tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n                     let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                     let mut fulfillment_cx = traits::FulfillmentContext::new();"}, {"sha": "501b69bb12a225cd97baa0c166cccc3915fa7a8a", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -85,9 +85,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n-        if let ty::FnConverging(t) = mir.return_ty {\n-            self.sanitize_type(&\"return type\", t);\n-        }\n+        self.sanitize_type(&\"return type\", mir.return_ty);\n         for var_decl in &mir.var_decls {\n             self.sanitize_type(var_decl, var_decl.ty);\n         }\n@@ -135,14 +133,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n             Lvalue::ReturnPointer => {\n-                if let ty::FnConverging(return_ty) = self.mir.return_ty {\n-                    LvalueTy::Ty { ty: return_ty }\n-                } else {\n-                    LvalueTy::Ty {\n-                        ty: span_mirbug_and_err!(\n-                            self, lvalue, \"return in diverging function\")\n-                    }\n-                }\n+                LvalueTy::Ty { ty: self.mir.return_ty }\n             }\n             Lvalue::Projection(ref proj) => {\n                 let base_ty = self.sanitize_lvalue(&proj.base);\n@@ -491,24 +482,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                        sig: &ty::FnSig<'tcx>,\n                        destination: &Option<(Lvalue<'tcx>, BasicBlock)>) {\n         let tcx = self.tcx();\n-        match (destination, sig.output) {\n-            (&Some(..), ty::FnDiverging) => {\n-                span_mirbug!(self, term, \"call to diverging function {:?} with dest\", sig);\n-            }\n-            (&Some((ref dest, _)), ty::FnConverging(ty)) => {\n+        match *destination {\n+            Some((ref dest, _)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(self.last_span, ty, dest_ty) {\n+                if let Err(terr) = self.sub_types(self.last_span, sig.output, dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n-                                 dest_ty, ty, terr);\n+                                 dest_ty, sig.output, terr);\n                 }\n-            }\n-            (&None, ty::FnDiverging) => {}\n-            (&None, ty::FnConverging(ref ty)) => {\n-                if !ty.is_empty(tcx) {\n+            },\n+            None => {\n+                if !sig.output.is_empty(tcx) {\n                     span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n                 }\n-            }\n+            },\n         }\n     }\n "}, {"sha": "42239a7d5a4eea216c93e2332edcec215f134a47", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -440,7 +440,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     let expr_ty = self.tcx.expr_ty(expr);\n                     let def = match expr_ty.sty {\n                         ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-                            output: ty::FnConverging(ty), ..\n+                            output: ty, ..\n                         }), ..}) => ty,\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();"}, {"sha": "16cd9186ce9bb43e251b29c5c66d61c799256457", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -671,7 +671,6 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n     sig.push_str(&decl.inputs.iter().map(arg_to_string).collect::<Vec<_>>().join(\", \"));\n     sig.push(')');\n     match decl.output {\n-        ast::FunctionRetTy::None(_) => sig.push_str(\" -> !\"),\n         ast::FunctionRetTy::Default(_) => {}\n         ast::FunctionRetTy::Ty(ref t) => sig.push_str(&format!(\" -> {}\", ty_to_string(t))),\n     }"}, {"sha": "3a7fde6a36bad02e6629ef9c27ea297b148b2d0e", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -326,10 +326,7 @@ impl FnType {\n             }\n         };\n \n-        let ret_ty = match sig.output {\n-            ty::FnConverging(ret_ty) => ret_ty,\n-            ty::FnDiverging => ccx.tcx().mk_nil()\n-        };\n+        let ret_ty = sig.output;\n         let mut ret = arg_of(ret_ty, true);\n \n         if !type_is_fat_ptr(ccx.tcx(), ret_ty) {\n@@ -470,7 +467,7 @@ impl FnType {\n             };\n             // Fat pointers are returned by-value.\n             if !self.ret.is_ignore() {\n-                if !type_is_fat_ptr(ccx.tcx(), sig.output.unwrap()) {\n+                if !type_is_fat_ptr(ccx.tcx(), sig.output) {\n                     fixup(&mut self.ret);\n                 }\n             }"}, {"sha": "70c3fdc269d682cc4143907ae0a4fad6e17ecac1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1972,7 +1972,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let sig = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_sig());\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n-    let result_ty = sig.output.unwrap();\n+    let result_ty = sig.output;\n \n     // Get location to store the result. If the user does not care about\n     // the result, just make a stack slot\n@@ -2054,7 +2054,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !fcx.fn_ty.ret.is_ignore() {\n         let dest = fcx.get_ret_slot(bcx, \"eret_slot\");\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n-        let repr = adt::represent_type(ccx, sig.output.unwrap());\n+        let repr = adt::represent_type(ccx, sig.output);\n         let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs.into_iter().enumerate() {"}, {"sha": "56b378519b4ab754f76319c5b0991f6620319216", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -641,10 +641,7 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let opt_llretslot = dest.and_then(|dest| match dest {\n         expr::SaveIn(dst) => Some(dst),\n         expr::Ignore => {\n-            let needs_drop = || match output {\n-                ty::FnConverging(ret_ty) => bcx.fcx.type_needs_drop(ret_ty),\n-                ty::FnDiverging => false\n-            };\n+            let needs_drop = || bcx.fcx.type_needs_drop(output);\n             if fn_ty.ret.is_indirect() || fn_ty.ret.cast.is_some() || needs_drop() {\n                 // Push the out-pointer if we use an out-pointer for this\n                 // return type, otherwise push \"undef\".\n@@ -706,16 +703,16 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // If the caller doesn't care about the result of this fn call,\n     // drop the temporary slot we made.\n-    match (dest, opt_llretslot, output) {\n-        (Some(expr::Ignore), Some(llretslot), ty::FnConverging(ret_ty)) => {\n+    match (dest, opt_llretslot) {\n+        (Some(expr::Ignore), Some(llretslot)) => {\n             // drop the value if it is not being saved.\n-            bcx = glue::drop_ty(bcx, llretslot, ret_ty, debug_loc);\n+            bcx = glue::drop_ty(bcx, llretslot, output, debug_loc);\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}\n     }\n \n-    if output == ty::FnDiverging {\n+    if output.is_empty(bcx.tcx()) {\n         Unreachable(bcx);\n     }\n "}, {"sha": "77b2c43167cfd280b20122f7c4bc233740141c4d", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -201,7 +201,11 @@ pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     trans_closure_expr(Dest::Ignore(ccx),\n                        &hir::FnDecl {\n                            inputs: P::new(),\n-                           output: hir::NoReturn(DUMMY_SP),\n+                           output: hir::Return(P(hir::Ty {\n+                               id: DUMMY_NODE_ID,\n+                               span: DUMMY_SP,\n+                               node: hir::Ty_::TyNever,\n+                           })),\n                            variadic: false\n                        },\n                        &hir::Block {"}, {"sha": "7683a572aaad977e20f09ae46d96d6eeb2893bb1", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -558,7 +558,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n             abi: Abi::C,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: vec![tcx.mk_mut_ptr(tcx.types.u8)],\n-                output: ty::FnDiverging,\n+                output: tcx.mk_empty(),\n                 variadic: false\n             }),\n         }));\n@@ -1240,8 +1240,8 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            inlined_vid);\n     let adt_def = match ctor_ty.sty {\n         ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-            output: ty::FnConverging(ty), ..\n-        }), ..}) => ty,\n+            output, ..\n+        }), ..}) => output,\n         _ => ctor_ty\n     }.ty_adt_def().unwrap();\n     let variant_def_id = if ccx.tcx().map.is_inlined_node_id(inlined_vid) {"}, {"sha": "08dfc97d67a716549659412b609749bfd874f1f9", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -279,16 +279,9 @@ impl<'tcx> TypeMap<'tcx> {\n                 }\n \n                 unique_type_id.push_str(\")->\");\n-                match sig.output {\n-                    ty::FnConverging(ret_ty) => {\n-                        let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n-                        let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(&return_type_id[..]);\n-                    }\n-                    ty::FnDiverging => {\n-                        unique_type_id.push_str(\"!\");\n-                    }\n-                }\n+                let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n+                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n+                unique_type_id.push_str(&return_type_id[..]);\n             },\n             ty::TyClosure(_, substs) if substs.upvar_tys.is_empty() => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n@@ -596,12 +589,9 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n-    signature_metadata.push(match signature.output {\n-        ty::FnConverging(ret_ty) => match ret_ty.sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n-            _ => type_metadata(cx, ret_ty, span)\n-        },\n-        ty::FnDiverging => diverging_type_metadata(cx)\n+    signature_metadata.push(match signature.output.sty {\n+        ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n+        _ => type_metadata(cx, signature.output, span)\n     });\n \n     // regular arguments\n@@ -916,17 +906,6 @@ pub fn scope_metadata(fcx: &FunctionContext,\n     }\n }\n \n-pub fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n-    unsafe {\n-        llvm::LLVMRustDIBuilderCreateBasicType(\n-            DIB(cx),\n-            \"!\\0\".as_ptr() as *const _,\n-            bytes_to_bits(0),\n-            bytes_to_bits(0),\n-            DW_ATE_unsigned)\n-    }\n-}\n-\n fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  t: Ty<'tcx>) -> DIType {\n "}, {"sha": "d6a4ce3c43a4ecc9b9ec67e0c1522daf93ed5889", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -17,8 +17,7 @@ use self::VariableKind::*;\n use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit};\n use self::namespace::mangled_name_of_item;\n use self::type_names::compute_debuginfo_type_name;\n-use self::metadata::{type_metadata, diverging_type_metadata};\n-use self::metadata::{file_metadata, TypeMap};\n+use self::metadata::{type_metadata, file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n@@ -325,12 +324,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let mut signature = Vec::with_capacity(sig.inputs.len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n-        signature.push(match sig.output {\n-            ty::FnConverging(ret_ty) => match ret_ty.sty {\n-                ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n-                _ => type_metadata(cx, ret_ty, syntax_pos::DUMMY_SP)\n-            },\n-            ty::FnDiverging => diverging_type_metadata(cx)\n+        signature.push(match sig.output.sty {\n+            ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n+            _ => type_metadata(cx, sig.output, syntax_pos::DUMMY_SP)\n         });\n \n         let inputs = if abi == Abi::RustCall {"}, {"sha": "190b40d41c9851c468447098f07c413ce6d5e12f", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -134,15 +134,9 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(')');\n \n-            match sig.output {\n-                ty::FnConverging(result_type) if result_type.is_nil() => {}\n-                ty::FnConverging(result_type) => {\n-                    output.push_str(\" -> \");\n-                    push_debuginfo_type_name(cx, result_type, true, output);\n-                }\n-                ty::FnDiverging => {\n-                    output.push_str(\" -> !\");\n-                }\n+            if !sig.output.is_nil() {\n+                output.push_str(\" -> \");\n+                push_debuginfo_type_name(cx, sig.output, true, output);\n             }\n         },\n         ty::TyClosure(..) => {"}, {"sha": "01eedb11ceb42a774a15abc04fbbf94ac96128f7", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -111,7 +111,7 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     let fty = FnType::new(ccx, abi, &sig, &[]);\n     let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n \n-    if sig.output == ty::FnDiverging {\n+    if sig.output.is_empty(ccx.tcx()) {\n         llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n "}, {"sha": "059532957b80551b10b485ffbb2832b7079c571b", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -803,7 +803,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n \n             let ref_ty = // invoked methods have LB regions instantiated:\n-                bcx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n+                bcx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n             let elt_ty = match ref_ty.builtin_deref(true, ty::NoPreference) {\n                 None => {\n                     span_bug!(index_expr.span,\n@@ -2060,7 +2060,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             let ref_ty = // invoked methods have their LB regions instantiated\n-                ccx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n+                ccx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             bcx = Callee::method(bcx, method)"}, {"sha": "066fe89aee5fdbaaf4909fd4788ba36552c5de47", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -132,7 +132,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // For `transmute` we can just trans the input expr directly into dest\n     if name == \"transmute\" {\n-        let llret_ty = type_of::type_of(ccx, ret_ty.unwrap());\n+        let llret_ty = type_of::type_of(ccx, ret_ty);\n         match args {\n             callee::ArgExprs(arg_exprs) => {\n                 assert_eq!(arg_exprs.len(), 1);\n@@ -315,11 +315,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         return Result::new(bcx, C_nil(ccx));\n     }\n \n-    let ret_ty = match ret_ty {\n-        ty::FnConverging(ret_ty) => ret_ty,\n-        ty::FnDiverging => bug!()\n-    };\n-\n     let llret_ty = type_of::type_of(ccx, ret_ty);\n \n     // Get location to store the result. If the user does\n@@ -1226,7 +1221,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n-                    output: ty::FnOutput<'tcx>,\n+                    output: ty::Ty<'tcx>,\n                     trans: &mut for<'b> FnMut(Block<'b, 'tcx>))\n                     -> ValueRef {\n     let ccx = fcx.ccx;\n@@ -1272,11 +1267,11 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         abi: Abi::Rust,\n         sig: ty::Binder(ty::FnSig {\n             inputs: vec![i8p],\n-            output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+            output: tcx.mk_nil(),\n             variadic: false,\n         }),\n     }));\n-    let output = ty::FnOutput::FnConverging(tcx.types.i32);\n+    let output = tcx.types.i32;\n     let rust_try = gen_fn(fcx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n     ccx.rust_try_fn().set(Some(rust_try));\n     return rust_try"}, {"sha": "784e4a32f9469df9a096605a5c128491d3c69f14", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -19,6 +19,7 @@ use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use common::{self, Block, BlockAndBuilder};\n use glue;\n+use std::iter;\n use super::rvalue;\n \n pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n@@ -31,7 +32,7 @@ pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n     let local_types = mir.arg_decls.iter().map(|a| a.ty)\n                .chain(mir.var_decls.iter().map(|v| v.ty))\n                .chain(mir.temp_decls.iter().map(|t| t.ty))\n-               .chain(mir.return_ty.maybe_converging());\n+               .chain(iter::once(mir.return_ty));\n     for (index, ty) in local_types.enumerate() {\n         let ty = bcx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);"}, {"sha": "56d02fa1fac4fbc02bdfe337ff48f77607b2e7dd", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -525,7 +525,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             // Make a fake operand for store_return\n                             let op = OperandRef {\n                                 val: Ref(dst),\n-                                ty: sig.output.unwrap()\n+                                ty: sig.output,\n                             };\n                             self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         }\n@@ -563,7 +563,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             debug_loc.apply_to_bcx(ret_bcx);\n                             let op = OperandRef {\n                                 val: Immediate(invokeret),\n-                                ty: sig.output.unwrap()\n+                                ty: sig.output,\n                             };\n                             self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n                         });\n@@ -574,7 +574,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if let Some((_, target)) = *destination {\n                         let op = OperandRef {\n                             val: Immediate(llret),\n-                            ty: sig.output.unwrap()\n+                            ty: sig.output,\n                         };\n                         self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         funclet_br(self, bcx, target);"}, {"sha": "727b680541dd7cf81579f2ce97e17982009beb0f", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -26,6 +26,7 @@ use syntax::parse::token::keywords;\n \n use std::ops::Deref;\n use std::rc::Rc;\n+use std::iter;\n \n use basic_block::BasicBlock;\n \n@@ -183,7 +184,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n         let locals = mir.temp_decls.iter().enumerate().map(|(i, decl)| {\n             (mir::Lvalue::Temp(mir::Temp::new(i)), decl.ty)\n-        }).chain(mir.return_ty.maybe_converging().map(|ty| (mir::Lvalue::ReturnPointer, ty)));\n+        }).chain(iter::once((mir::Lvalue::ReturnPointer, mir.return_ty)));\n \n         args.into_iter().chain(vars).chain(locals.map(|(lvalue, ty)| {\n             let ty = bcx.monomorphize(&ty);"}, {"sha": "9f4f8fc990aa2e7f615bd2e911cf5d7e22207451", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -233,7 +233,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         let sig = ty::FnSig {\n             inputs: vec![tcx.mk_mut_ptr(tcx.types.i8)],\n-            output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+            output: tcx.mk_nil(),\n             variadic: false,\n         };\n \n@@ -516,15 +516,9 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             output.push(')');\n \n-            match sig.output {\n-                ty::FnConverging(result_type) if result_type.is_nil() => {}\n-                ty::FnConverging(result_type) => {\n-                    output.push_str(\" -> \");\n-                    push_unique_type_name(tcx, result_type, output);\n-                }\n-                ty::FnDiverging => {\n-                    output.push_str(\" -> !\");\n-                }\n+            if !sig.output.is_nil() {\n+                output.push_str(\" -> \");\n+                push_unique_type_name(tcx, sig.output, output);\n             }\n         },\n         ty::TyClosure(def_id, ref closure_substs) => {"}, {"sha": "74fe3172b2a09952be1ac3eb4a36eebe5dfa343e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1923,11 +1923,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let output_ty = match decl.output {\n             hir::Return(ref output) =>\n-                ty::FnConverging(self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                                       &output,\n-                                                                       ret_anon_scope)),\n-            hir::DefaultReturn(..) => ty::FnConverging(self.tcx().mk_nil()),\n-            hir::NoReturn(..) => ty::FnDiverging\n+                self.convert_ty_with_lifetime_elision(implied_output_region,\n+                                                      &output,\n+                                                      ret_anon_scope),\n+            hir::DefaultReturn(..) => self.tcx().mk_nil(),\n         };\n \n         (self.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -2070,11 +2069,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             _ if is_infer && expected_ret_ty.is_some() =>\n                 expected_ret_ty.unwrap(),\n             _ if is_infer =>\n-                ty::FnConverging(self.ty_infer(None, None, None, decl.output.span())),\n+                self.ty_infer(None, None, None, decl.output.span()),\n             hir::Return(ref output) =>\n-                ty::FnConverging(self.ast_ty_to_ty(&rb, &output)),\n+                self.ast_ty_to_ty(&rb, &output),\n             hir::DefaultReturn(..) => bug!(),\n-            hir::NoReturn(..) => ty::FnDiverging\n         };\n \n         debug!(\"ty_of_closure: input_tys={:?}\", input_tys);"}, {"sha": "985c3be149617dc388a08a2e932b92f41f1eeef9", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // set up all the node type bindings.\n                 error_fn_sig = ty::Binder(ty::FnSig {\n                     inputs: self.err_args(arg_exprs.len()),\n-                    output: ty::FnConverging(self.tcx.types.err),\n+                    output: self.tcx.types.err,\n                     variadic: false\n                 });\n \n@@ -345,10 +345,9 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n                     fcx.demand_eqtype(self.call_expr.span, self_arg_ty, method_arg_ty);\n                 }\n \n-                let nilty = fcx.tcx.mk_nil();\n                 fcx.demand_eqtype(self.call_expr.span,\n-                                  method_sig.output.unwrap_or(nilty),\n-                                  self.fn_sig.output.unwrap_or(nilty));\n+                                  method_sig.output,\n+                                  self.fn_sig.output);\n \n                 fcx.write_overloaded_call_method_map(self.call_expr, method_callee);\n             }"}, {"sha": "3acb8017eec509acaadd09ef48ed36c343095c2d", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let fn_sig = ty::FnSig {\n             inputs: input_tys,\n-            output: ty::FnConverging(ret_param_ty),\n+            output: ret_param_ty,\n             variadic: false\n         };\n         debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);"}, {"sha": "38772470f3ff7a157ae92031003063bd19452cd5", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -31,7 +31,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    n_tps: usize,\n                                    abi: Abi,\n                                    inputs: Vec<ty::Ty<'tcx>>,\n-                                   output: ty::FnOutput<'tcx>) {\n+                                   output: ty::Ty<'tcx>) {\n     let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(it.id);\n     let i_ty = tcx.lookup_item_type(def_id);\n@@ -104,9 +104,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                 return;\n             }\n         };\n-        (n_tps, inputs, ty::FnConverging(output))\n+        (n_tps, inputs, output)\n     } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n-        (0, Vec::new(), ty::FnConverging(tcx.mk_empty()))\n+        (0, Vec::new(), tcx.mk_empty())\n     } else {\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n@@ -291,7 +291,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                     abi: Abi::Rust,\n                     sig: ty::Binder(FnSig {\n                         inputs: vec![mut_u8],\n-                        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+                        output: tcx.mk_nil(),\n                         variadic: false,\n                     }),\n                 });\n@@ -304,7 +304,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                 return;\n             }\n         };\n-        (n_tps, inputs, ty::FnConverging(output))\n+        (n_tps, inputs, output)\n     };\n     equate_intrinsic_type(ccx, it, n_tps, Abi::RustIntrinsic, inputs, output)\n }\n@@ -377,7 +377,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                     }\n                     match_intrinsic_type_to_type(ccx, \"return value\", it.span,\n                                                  &mut structural_to_nomimal,\n-                                                 &intr.output, sig.output.unwrap());\n+                                                 &intr.output, sig.output);\n                     return\n                 }\n                 None => {\n@@ -390,7 +390,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     };\n \n     equate_intrinsic_type(ccx, it, n_tps, Abi::PlatformIntrinsic,\n-                          inputs, ty::FnConverging(output))\n+                          inputs, output)\n }\n \n // walk the expected type and the actual type in lock step, checking they're"}, {"sha": "6d19babf41f7ebb7e646ab36943c9e605521ea48", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 46, "deletions": 74, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -372,7 +372,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // expects the types within the function to be consistent.\n     err_count_on_creation: usize,\n \n-    ret_ty: ty::FnOutput<'tcx>,\n+    ret_ty: ty::Ty<'tcx>,\n \n     ps: RefCell<UnsafetyState>,\n \n@@ -676,14 +676,9 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let mut fcx = FnCtxt::new(inherited, fn_sig.output, body.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(unsafety, unsafety_id);\n \n-    fn_sig.output = match fcx.ret_ty {\n-        ty::FnConverging(orig_ret_ty) => {\n-            fcx.require_type_is_sized(orig_ret_ty, decl.output.span(), traits::ReturnType);\n-            ty::FnConverging(fcx.instantiate_anon_types(&orig_ret_ty))\n-        }\n-        ty::FnDiverging => ty::FnDiverging\n-    };\n-    fcx.ret_ty = fn_sig.output;\n+    fcx.require_type_is_sized(fcx.ret_ty, decl.output.span(), traits::ReturnType);\n+    fcx.ret_ty = fcx.instantiate_anon_types(&fcx.ret_ty);\n+    fn_sig.output = fcx.ret_ty;\n \n     {\n         let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n@@ -714,10 +709,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n \n-    fcx.check_block_with_expected(body, match fcx.ret_ty {\n-        ty::FnConverging(result_type) => ExpectHasType(result_type),\n-        ty::FnDiverging => NoExpectation\n-    });\n+    fcx.check_block_with_expected(body, ExpectHasType(fcx.ret_ty));\n \n     fcx\n }\n@@ -1168,7 +1160,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                    expected_type: Ty<'tcx>,\n                                    id: ast::NodeId) {\n     ccx.inherited(id).enter(|inh| {\n-        let fcx = FnCtxt::new(&inh, ty::FnConverging(expected_type), expr.id);\n+        let fcx = FnCtxt::new(&inh, expected_type, expr.id);\n         fcx.require_type_is_sized(expected_type, expr.span, traits::ConstSized);\n \n         // Gather locals in statics (because of block expressions).\n@@ -1465,7 +1457,7 @@ enum TupleArgumentsFlag {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(inh: &'a Inherited<'a, 'gcx, 'tcx>,\n-               rty: ty::FnOutput<'tcx>,\n+               rty: ty::Ty<'tcx>,\n                body_id: ast::NodeId)\n                -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n@@ -2288,7 +2280,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // extract method return type, which will be &T;\n         // all LB regions should have been instantiated during method lookup\n         let ret_ty = method.ty.fn_ret();\n-        let ret_ty = self.tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap();\n+        let ret_ty = self.tcx.no_late_bound_regions(&ret_ty).unwrap();\n \n         // method returns &T, but the type as visible to user is T, so deref\n         ret_ty.builtin_deref(true, NoPreference).unwrap()\n@@ -2417,7 +2409,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                    args_no_rcvr: &'gcx [P<hir::Expr>],\n                                    tuple_arguments: TupleArgumentsFlag,\n                                    expected: Expectation<'tcx>)\n-                                   -> ty::FnOutput<'tcx> {\n+                                   -> ty::Ty<'tcx> {\n         if method_fn_ty.references_error() {\n             let err_inputs = self.err_args(args_no_rcvr.len());\n \n@@ -2428,7 +2420,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             self.check_argument_types(sp, &err_inputs[..], &[], args_no_rcvr,\n                                       false, tuple_arguments);\n-            ty::FnConverging(self.tcx.types.err)\n+            self.tcx.types.err\n         } else {\n             match method_fn_ty.sty {\n                 ty::TyFnDef(_, _, ref fty) => {\n@@ -2688,11 +2680,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn write_call(&self,\n                   call_expr: &hir::Expr,\n-                  output: ty::FnOutput<'tcx>) {\n-        self.write_ty_expr(call_expr.id, match output {\n-            ty::FnConverging(output_ty) => output_ty,\n-            ty::FnDiverging => self.next_diverging_ty_var()\n-        });\n+                  output: ty::Ty<'tcx>) {\n+        self.write_ty_expr(call_expr.id, output);\n     }\n \n     // AST fragment checking\n@@ -2815,35 +2804,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn expected_types_for_fn_args(&self,\n                                   call_span: Span,\n                                   expected_ret: Expectation<'tcx>,\n-                                  formal_ret: ty::FnOutput<'tcx>,\n+                                  formal_ret: ty::Ty<'tcx>,\n                                   formal_args: &[Ty<'tcx>])\n                                   -> Vec<Ty<'tcx>> {\n         let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n-            if let ty::FnConverging(formal_ret_ty) = formal_ret {\n-                self.commit_regions_if_ok(|| {\n-                    // Attempt to apply a subtyping relationship between the formal\n-                    // return type (likely containing type variables if the function\n-                    // is polymorphic) and the expected return type.\n-                    // No argument expectations are produced if unification fails.\n-                    let origin = TypeOrigin::Misc(call_span);\n-                    let ures = self.sub_types(false, origin, formal_ret_ty, ret_ty);\n-                    // FIXME(#15760) can't use try! here, FromError doesn't default\n-                    // to identity so the resulting type is not constrained.\n-                    match ures {\n-                        // FIXME(#32730) propagate obligations\n-                        Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n-                        Err(e) => return Err(e),\n-                    }\n+            self.commit_regions_if_ok(|| {\n+                // Attempt to apply a subtyping relationship between the formal\n+                // return type (likely containing type variables if the function\n+                // is polymorphic) and the expected return type.\n+                // No argument expectations are produced if unification fails.\n+                let origin = TypeOrigin::Misc(call_span);\n+                let ures = self.sub_types(false, origin, formal_ret, ret_ty);\n+                // FIXME(#15760) can't use try! here, FromError doesn't default\n+                // to identity so the resulting type is not constrained.\n+                match ures {\n+                    // FIXME(#32730) propagate obligations\n+                    Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n+                    Err(e) => return Err(e),\n+                }\n \n-                    // Record all the argument types, with the substitutions\n-                    // produced from the above subtyping unification.\n-                    Ok(formal_args.iter().map(|ty| {\n-                        self.resolve_type_vars_if_possible(ty)\n-                    }).collect())\n-                }).ok()\n-            } else {\n-                None\n-            }\n+                // Record all the argument types, with the substitutions\n+                // produced from the above subtyping unification.\n+                Ok(formal_args.iter().map(|ty| {\n+                    self.resolve_type_vars_if_possible(ty)\n+                }).collect())\n+            }).ok()\n         }).unwrap_or(vec![]);\n         debug!(\"expected_types_for_fn_args(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n                formal_args, formal_ret,\n@@ -3503,32 +3488,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprBreak(_) => { self.write_empty(id); }\n           hir::ExprAgain(_) => { self.write_empty(id); }\n           hir::ExprRet(ref expr_opt) => {\n-            match self.ret_ty {\n-                ty::FnConverging(result_type) => {\n-                    if let Some(ref e) = *expr_opt {\n-                        self.check_expr_coercable_to_type(&e, result_type);\n-                    } else {\n-                        let eq_result = self.eq_types(false,\n-                                                      TypeOrigin::Misc(expr.span),\n-                                                      result_type,\n-                                                      tcx.mk_nil())\n-                            // FIXME(#32730) propagate obligations\n-                            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()));\n-                        if eq_result.is_err() {\n-                            struct_span_err!(tcx.sess, expr.span, E0069,\n-                                     \"`return;` in a function whose return type is not `()`\")\n-                                .span_label(expr.span, &format!(\"return type is not ()\"))\n-                                .emit();\n-                        }\n-                    }\n-                }\n-                ty::FnDiverging => {\n-                    if let Some(ref e) = *expr_opt {\n-                        self.check_expr(&e);\n-                    }\n-                    struct_span_err!(tcx.sess, expr.span, E0166,\n-                        \"`return` in a function declared as diverging\")\n-                        .span_label(expr.span, &format!(\"diverging function cannot return\"))\n+            if let Some(ref e) = *expr_opt {\n+                self.check_expr_coercable_to_type(&e, self.ret_ty);\n+            } else {\n+                let eq_result = self.eq_types(false,\n+                                              TypeOrigin::Misc(expr.span),\n+                                              self.ret_ty,\n+                                              tcx.mk_nil())\n+                    // FIXME(#32730) propagate obligations\n+                    .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()));\n+                if eq_result.is_err() {\n+                    struct_span_err!(tcx.sess, expr.span, E0069,\n+                             \"`return;` in a function whose return type is not `()`\")\n+                        .span_label(expr.span, &format!(\"return type is not ()\"))\n                         .emit();\n                 }\n             }"}, {"sha": "b8db8e226ab1d46870a68b96515bfef7be17437c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -343,7 +343,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // extract return type for method; all late bound regions\n                 // should have been instantiated by now\n                 let ret_ty = method_ty.fn_ret();\n-                Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap())\n+                Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap())\n             }\n             None => {\n                 Err(())"}, {"sha": "22ffcfbaae111df894576ee75b2fdce6675fb10e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let fn_sig_tys: Vec<_> =\n             fn_sig.inputs.iter()\n                          .cloned()\n-                         .chain(Some(fn_sig.output.unwrap_or(self.tcx.types.bool)))\n+                         .chain(Some(fn_sig.output))\n                          .collect();\n \n         let old_body_id = self.set_body_id(body.id);\n@@ -708,7 +708,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                                             None::<hir::Expr>.iter(), true);\n                         // late-bound regions in overloaded method calls are instantiated\n                         let fn_ret = self.tcx.no_late_bound_regions(&method.ty.fn_ret());\n-                        fn_ret.unwrap().unwrap()\n+                        fn_ret.unwrap()\n                     }\n                     None => self.resolve_node_type(base.id)\n                 };\n@@ -980,14 +980,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     // Specialized version of constrain_call.\n                     self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n                                            self_ty, r_deref_expr);\n-                    match fn_sig.output {\n-                        ty::FnConverging(return_type) => {\n-                            self.type_must_outlive(infer::CallReturn(deref_expr.span),\n-                                                   return_type, r_deref_expr);\n-                            return_type\n-                        }\n-                        ty::FnDiverging => bug!()\n-                    }\n+                    self.type_must_outlive(infer::CallReturn(deref_expr.span),\n+                                           fn_sig.output, r_deref_expr);\n+                    fn_sig.output\n                 }\n                 None => derefd_ty\n             };"}, {"sha": "2e629dc4312d11a8c5ec94b85a18ce567e402de3", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         let id = self.id;\n         let span = self.span;\n         self.inherited.enter(|inh| {\n-            let fcx = FnCtxt::new(&inh, ty::FnDiverging, id);\n+            let fcx = FnCtxt::new(&inh, inh.ccx.tcx.mk_empty(), id);\n             let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n                 ccx: fcx.ccx,\n                 code: code\n@@ -394,15 +394,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         }\n         implied_bounds.extend(sig.inputs);\n \n-        match sig.output {\n-            ty::FnConverging(output) => {\n-                fcx.register_wf_obligation(output, span, self.code.clone());\n+        fcx.register_wf_obligation(sig.output, span, self.code.clone());\n \n-                // FIXME(#25759) return types should not be implied bounds\n-                implied_bounds.push(output);\n-            }\n-            ty::FnDiverging => { }\n-        }\n+        // FIXME(#25759) return types should not be implied bounds\n+        implied_bounds.push(sig.output);\n \n         self.check_where_clauses(fcx, span, predicates);\n     }"}, {"sha": "d38065f4f1238912f3624ef2dbff74702f5c0c5e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -971,7 +971,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 abi: abi::Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: inputs,\n-                    output: ty::FnConverging(scheme.ty),\n+                    output: scheme.ty,\n                     variadic: false\n                 })\n             }))\n@@ -2155,11 +2155,9 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n \n     let output = match decl.output {\n         hir::Return(ref ty) =>\n-            ty::FnConverging(AstConv::ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty)),\n+            AstConv::ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty),\n         hir::DefaultReturn(..) =>\n-            ty::FnConverging(ccx.tcx.mk_nil()),\n-        hir::NoReturn(..) =>\n-            ty::FnDiverging\n+            ccx.tcx.mk_nil(),\n     };\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n@@ -2180,7 +2178,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n             check(&input.ty, ty)\n         }\n         if let hir::Return(ref ty) = decl.output {\n-            check(&ty, output.unwrap())\n+            check(&ty, output)\n         }\n     }\n "}, {"sha": "11743ade2d469260008a5b01688be69e48a938d5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -238,7 +238,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n-                    output: ty::FnConverging(tcx.mk_nil()),\n+                    output: tcx.mk_nil(),\n                     variadic: false\n                 })\n             }));\n@@ -294,7 +294,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                         tcx.types.isize,\n                         tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n                     ),\n-                    output: ty::FnConverging(tcx.types.isize),\n+                    output: tcx.types.isize,\n                     variadic: false,\n                 }),\n             }));"}, {"sha": "3d4e71bed46fbeeb508f5c3606a9a23b83c3a3ae", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -490,9 +490,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         for &input in &sig.0.inputs {\n             self.add_constraints_from_ty(generics, input, contra);\n         }\n-        if let ty::FnConverging(result_type) = sig.0.output {\n-            self.add_constraints_from_ty(generics, result_type, variance);\n-        }\n+        self.add_constraints_from_ty(generics, sig.0.output, variance);\n     }\n \n     /// Adds constraints appropriate for a region appearing in a"}, {"sha": "bfb50bcbc25a467ada10dc8b57038491c38a02a1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1176,15 +1176,6 @@ impl Clean<FnDecl> for hir::FnDecl {\n     }\n }\n \n-impl<'tcx> Clean<Type> for ty::FnOutput<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Type {\n-        match *self {\n-            ty::FnConverging(ty) => ty.clean(cx),\n-            ty::FnDiverging => Bottom\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n@@ -1254,15 +1245,13 @@ impl Clean<Argument> for hir::Arg {\n pub enum FunctionRetTy {\n     Return(Type),\n     DefaultReturn,\n-    NoReturn\n }\n \n impl Clean<FunctionRetTy> for hir::FunctionRetTy {\n     fn clean(&self, cx: &DocContext) -> FunctionRetTy {\n         match *self {\n             hir::Return(ref typ) => Return(typ.clean(cx)),\n             hir::DefaultReturn(..) => DefaultReturn,\n-            hir::NoReturn(..) => NoReturn\n         }\n     }\n }"}, {"sha": "ce0cfa564393b45e1cbe28ea8abdb74741cf89ac", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -634,7 +634,6 @@ impl fmt::Display for clean::FunctionRetTy {\n             clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n             clean::Return(ref ty) => write!(f, \" -&gt; {}\", ty),\n             clean::DefaultReturn => Ok(()),\n-            clean::NoReturn => write!(f, \" -&gt; !\")\n         }\n     }\n }"}, {"sha": "9046a44fdc6d78c6ff59f90eda4bb6d1fe060a8c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -1567,9 +1567,6 @@ impl fmt::Debug for ImplPolarity {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum FunctionRetTy {\n-    /// Functions with return type `!`that always\n-    /// raise an error or exit (i.e. never return to the caller)\n-    None(Span),\n     /// Return type is not specified.\n     ///\n     /// Functions default to `()` and\n@@ -1583,7 +1580,6 @@ pub enum FunctionRetTy {\n impl FunctionRetTy {\n     pub fn span(&self) -> Span {\n         match *self {\n-            FunctionRetTy::None(span) => span,\n             FunctionRetTy::Default(span) => span,\n             FunctionRetTy::Ty(ref ty) => ty.span,\n         }"}, {"sha": "6c5cbdc645a7d521ff98266821897cdba753e0b0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -638,7 +638,6 @@ pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n         output: match output {\n             FunctionRetTy::Ty(ty) => FunctionRetTy::Ty(fld.fold_ty(ty)),\n             FunctionRetTy::Default(span) => FunctionRetTy::Default(span),\n-            FunctionRetTy::None(span) => FunctionRetTy::None(span),\n         },\n         variadic: variadic\n     })"}, {"sha": "a5d512f14ec6c42d844aefb4097dc4f93e50e15d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02344fbc7d3bed591f528304f603f9d320e919/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ed02344fbc7d3bed591f528304f603f9d320e919", "patch": "@@ -2696,10 +2696,6 @@ impl<'a> State<'a> {\n                 self.maybe_print_comment(ty.span.lo)\n             }\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n-            ast::FunctionRetTy::None(span) => {\n-                try!(self.word_nbsp(\"!\"));\n-                self.maybe_print_comment(span.lo)\n-            }\n         }\n     }\n \n@@ -2955,8 +2951,6 @@ impl<'a> State<'a> {\n         try!(self.ibox(INDENT_UNIT));\n         try!(self.word_space(\"->\"));\n         match decl.output {\n-            ast::FunctionRetTy::None(_) =>\n-                try!(self.word_nbsp(\"!\")),\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n             ast::FunctionRetTy::Ty(ref ty) =>\n                 try!(self.print_type(&ty))"}, {"sha": "795ad8fb35b82389df0ebe328083c21b6677fc0b", "filename": "src/test/run-pass/issue-10714.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee78f37e2a68120119dcda4312db0be3b545eabe/src%2Ftest%2Frun-pass%2Fissue-10714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee78f37e2a68120119dcda4312db0be3b545eabe/src%2Ftest%2Frun-pass%2Fissue-10714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10714.rs?ref=ee78f37e2a68120119dcda4312db0be3b545eabe", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pretty-expanded FIXME #23616\n-\n-enum v {}\n-pub fn main() {\n-    let y: v = unsafe { ::std::mem::uninitialized() };\n-}"}]}