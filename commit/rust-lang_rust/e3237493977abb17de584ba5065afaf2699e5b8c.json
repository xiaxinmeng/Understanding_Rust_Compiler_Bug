{"sha": "e3237493977abb17de584ba5065afaf2699e5b8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMjM3NDkzOTc3YWJiMTdkZTU4NGJhNTA2NWFmYWYyNjk5ZTViOGM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-26T03:17:58Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-10-05T20:59:05Z"}, "message": "extra: Don't truncate {u64,i64} when converting to BigInts", "tree": {"sha": "1ad06b0d793b41050ee6df518d5e77b2ed3e2c35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ad06b0d793b41050ee6df518d5e77b2ed3e2c35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3237493977abb17de584ba5065afaf2699e5b8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3237493977abb17de584ba5065afaf2699e5b8c", "html_url": "https://github.com/rust-lang/rust/commit/e3237493977abb17de584ba5065afaf2699e5b8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3237493977abb17de584ba5065afaf2699e5b8c/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb240197441723fed70e4076d9eba460d8f209ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb240197441723fed70e4076d9eba460d8f209ba", "html_url": "https://github.com/rust-lang/rust/commit/cb240197441723fed70e4076d9eba460d8f209ba"}], "stats": {"total": 140, "additions": 121, "deletions": 19}, "files": [{"sha": "8aaac486076f109bfd55078564f86c693efb57c4", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 121, "deletions": 19, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e3237493977abb17de584ba5065afaf2699e5b8c/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3237493977abb17de584ba5065afaf2699e5b8c/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=e3237493977abb17de584ba5065afaf2699e5b8c", "patch": "@@ -504,9 +504,8 @@ impl Integer for BigUint {\n impl ToPrimitive for BigUint {\n     #[inline]\n     fn to_i64(&self) -> Option<i64> {\n-        do self.to_uint().and_then |n| {\n-            // If top bit of u64 is set, it's too large to convert to\n-            // int.\n+        do self.to_u64().and_then |n| {\n+            // If top bit of u64 is set, it's too large to convert to i64.\n             if (n >> (2*BigDigit::bits - 1) != 0) {\n                 None\n             } else {\n@@ -515,12 +514,46 @@ impl ToPrimitive for BigUint {\n         }\n     }\n \n+    #[cfg(target_word_size = \"32\")]\n     #[inline]\n     fn to_u64(&self) -> Option<u64> {\n-        match self.data.len() {\n-            0 => Some(0),\n-            1 => Some(self.data[0] as u64),\n-            2 => Some(BigDigit::to_uint(self.data[1], self.data[0]) as u64),\n+        match self.data {\n+            [] => {\n+                Some(0)\n+            }\n+            [n0] => {\n+                Some(n0 as u64)\n+            }\n+            [n0, n1] => {\n+                Some(BigDigit::to_uint(n1, n0) as u64)\n+            }\n+            [n0, n1, n2] => {\n+                let n_lo = BigDigit::to_uint(n1, n0) as u64;\n+                let n_hi = n2 as u64;\n+                Some((n_hi << 32) + n_lo)\n+            }\n+            [n0, n1, n2, n3] => {\n+                let n_lo = BigDigit::to_uint(n1, n0) as u64;\n+                let n_hi = BigDigit::to_uint(n3, n2) as u64;\n+                Some((n_hi << 32) + n_lo)\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    #[cfg(target_word_size = \"64\")]\n+    #[inline]\n+    fn to_u64(&self) -> Option<u64> {\n+        match self.data {\n+            [] => {\n+                Some(0)\n+            }\n+            [n0] => {\n+                Some(n0 as u64)\n+            }\n+            [n0, n1] => {\n+                Some(BigDigit::to_uint(n1, n0) as u64)\n+            }\n             _ => None\n         }\n     }\n@@ -536,6 +569,23 @@ impl FromPrimitive for BigUint {\n         }\n     }\n \n+    #[cfg(target_word_size = \"32\")]\n+    #[inline]\n+    fn from_u64(n: u64) -> Option<BigUint> {\n+        let n_lo = (n & 0x0000_0000_FFFF_FFFF) as uint;\n+        let n_hi = (n >> 32) as uint;\n+\n+        let n = match (BigDigit::from_uint(n_hi), BigDigit::from_uint(n_lo)) {\n+            ((0,  0),  (0,  0))  => Zero::zero(),\n+            ((0,  0),  (0,  n0)) => BigUint::new(~[n0]),\n+            ((0,  0),  (n1, n0)) => BigUint::new(~[n0, n1]),\n+            ((0,  n2), (n1, n0)) => BigUint::new(~[n0, n1, n2]),\n+            ((n3, n2), (n1, n0)) => BigUint::new(~[n0, n1, n2, n3]),\n+        };\n+        Some(n)\n+    }\n+\n+    #[cfg(target_word_size = \"64\")]\n     #[inline]\n     fn from_u64(n: u64) -> Option<BigUint> {\n         let n = match BigDigit::from_uint(n as uint) {\n@@ -547,7 +597,9 @@ impl FromPrimitive for BigUint {\n     }\n }\n \n+/// A generic trait for converting a value to a `BigUint`.\n pub trait ToBigUint {\n+    /// Converts the value of `self` to a `BigUint`.\n     fn to_biguint(&self) -> Option<BigUint>;\n }\n \n@@ -696,12 +748,6 @@ impl BigUint {\n         }\n     }\n \n-    /// Converts this `BigUint` into a `BigInt.\n-    #[inline]\n-    pub fn to_bigint(&self) -> BigInt {\n-        BigInt::from_biguint(Plus, self.clone())\n-    }\n-\n     #[inline]\n     fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n@@ -1186,7 +1232,9 @@ impl FromPrimitive for BigInt {\n     }\n }\n \n+/// A generic trait for converting a value to a `BigInt`.\n pub trait ToBigInt {\n+    /// Converts the value of `self` to a `BigInt`.\n     fn to_bigint(&self) -> Option<BigInt>;\n }\n \n@@ -1330,7 +1378,7 @@ impl<R: Rng> RandBigInt for R {\n                         -> BigInt {\n         assert!(*lbound < *ubound);\n         let delta = (*ubound - *lbound).to_biguint().unwrap();\n-        return *lbound + self.gen_biguint_below(&delta).to_bigint();\n+        return *lbound + self.gen_biguint_below(&delta).to_bigint().unwrap();\n     }\n }\n \n@@ -1607,8 +1655,8 @@ mod biguint_tests {\n     #[test]\n     fn test_convert_to_bigint() {\n         fn check(n: BigUint, ans: BigInt) {\n-            assert_eq!(n.to_bigint(), ans);\n-            assert_eq!(n.to_bigint().to_biguint().unwrap(), n);\n+            assert_eq!(n.to_bigint().unwrap(), ans);\n+            assert_eq!(n.to_bigint().unwrap().to_biguint().unwrap(), n);\n         }\n         check(Zero::zero(), Zero::zero());\n         check(BigUint::new(~[1,2,3]),\n@@ -1977,11 +2025,10 @@ mod bigint_tests {\n     use super::*;\n \n     use std::cmp::{Less, Equal, Greater};\n-    use std::int;\n+    use std::{int, i64, uint, u64};\n     use std::num::{Zero, One, FromStrRadix};\n     use std::num::{ToPrimitive, FromPrimitive};\n     use std::rand::{task_rng};\n-    use std::uint;\n \n     #[test]\n     fn test_from_biguint() {\n@@ -2092,11 +2139,66 @@ mod bigint_tests {\n         assert_eq!(BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3])).to_uint(), None);\n     }\n \n+    #[test]\n+    fn test_convert_i64() {\n+        fn check(b1: BigInt, i: i64) {\n+            let b2: BigInt = FromPrimitive::from_i64(i).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_i64().unwrap() == i);\n+        }\n+\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(i64::min_value.to_bigint().unwrap(), i64::min_value);\n+        check(i64::max_value.to_bigint().unwrap(), i64::max_value);\n+\n+        assert_eq!(\n+            (i64::max_value as uint + 1).to_bigint().unwrap().to_i64(),\n+            None);\n+\n+        assert_eq!(\n+            BigInt::from_biguint(Plus, BigUint::new(~[1, 2, 3, 4, 5])).to_i64(),\n+            None);\n+\n+        check(\n+            BigInt::from_biguint(Minus, BigUint::new(~[0, 1<<(BigDigit::bits-1)])),\n+            i64::min_value);\n+\n+        assert_eq!(\n+            BigInt::from_biguint(Minus, BigUint::new(~[1, 1<<(BigDigit::bits-1)])).to_i64(),\n+            None);\n+\n+        assert_eq!(\n+            BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3, 4, 5])).to_i64(),\n+            None);\n+    }\n+\n+    #[test]\n+    fn test_convert_u64() {\n+        fn check(b1: BigInt, u: u64) {\n+            let b2: BigInt = FromPrimitive::from_u64(u).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_u64().unwrap() == u);\n+        }\n+\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(u64::max_value.to_bigint().unwrap(), u64::max_value);\n+\n+        assert_eq!(\n+            BigInt::from_biguint(Plus, BigUint::new(~[1, 2, 3, 4, 5])).to_uint(),\n+            None);\n+\n+        let max_value: BigUint = FromPrimitive::from_uint(uint::max_value).unwrap();\n+        assert_eq!(BigInt::from_biguint(Minus, max_value).to_u64(), None);\n+        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3])).to_u64(), None);\n+    }\n+\n     #[test]\n     fn test_convert_to_biguint() {\n         fn check(n: BigInt, ans_1: BigUint) {\n             assert_eq!(n.to_biguint().unwrap(), ans_1);\n-            assert_eq!(n.to_biguint().unwrap().to_bigint(), n);\n+            assert_eq!(n.to_biguint().unwrap().to_bigint().unwrap(), n);\n         }\n         let zero: BigInt = Zero::zero();\n         let unsigned_zero: BigUint = Zero::zero();"}]}