{"sha": "cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZTgwMjNjNjkwMTU4ZGFmNGY2YzNkOGJmMmQzMjI5N2ZkZmVkMGM=", "commit": {"author": {"name": "Joseph Ryan", "email": "josephryan3.14@gmail.com", "date": "2020-07-27T22:34:17Z"}, "committer": {"name": "Joseph Ryan", "email": "josephryan3.14@gmail.com", "date": "2020-07-27T22:34:17Z"}, "message": "More requested changes", "tree": {"sha": "7776fd4cb1a3d71cced4bc692c77cef14005c907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7776fd4cb1a3d71cced4bc692c77cef14005c907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEtei29J14PIgXYsIlGom1QEO7zL0FAl8fVmkACgkQGom1QEO7\nzL2dSwgAtNU2oKGH0IqjfAU9XRJu75s2oY/dNzEOy5oxot2LQ4CZWYYl+0dbsXVm\nrhtIfyrKGCSKwzRW5bjh34bKPp1k3BtBkRFKfUSt3iCqkteKa3sZzfVm7eHYdAei\nbSlZ2M+3SP64HVEYzGjpr7+/yj0fMptFVuCbN3K4PhfWOka6zaMKdWJxmpEks052\ndMYw/mnFoO6lWCbsE3GkZ0ywshndpSg7Xi6fCOxbbzaTptaiCsx8C/OIYpvBWYW3\npqeViudc6SYA6e+lJCXCpcOtx8V03peceZ2coJf82xdE6ZnKB5mOhBeWtlPWQ3/J\nM0v1xOrQN9ufaWZ8vdrjuPGlQpYNeQ==\n=QMcD\n-----END PGP SIGNATURE-----", "payload": "tree 7776fd4cb1a3d71cced4bc692c77cef14005c907\nparent 3d707a008e0822471de4adad047b5cefd281f3ac\nauthor Joseph Ryan <josephryan3.14@gmail.com> 1595889257 -0500\ncommitter Joseph Ryan <josephryan3.14@gmail.com> 1595889257 -0500\n\nMore requested changes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "html_url": "https://github.com/rust-lang/rust/commit/cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/comments", "author": {"login": "P1n3appl3", "id": 9326885, "node_id": "MDQ6VXNlcjkzMjY4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/9326885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P1n3appl3", "html_url": "https://github.com/P1n3appl3", "followers_url": "https://api.github.com/users/P1n3appl3/followers", "following_url": "https://api.github.com/users/P1n3appl3/following{/other_user}", "gists_url": "https://api.github.com/users/P1n3appl3/gists{/gist_id}", "starred_url": "https://api.github.com/users/P1n3appl3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P1n3appl3/subscriptions", "organizations_url": "https://api.github.com/users/P1n3appl3/orgs", "repos_url": "https://api.github.com/users/P1n3appl3/repos", "events_url": "https://api.github.com/users/P1n3appl3/events{/privacy}", "received_events_url": "https://api.github.com/users/P1n3appl3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "P1n3appl3", "id": 9326885, "node_id": "MDQ6VXNlcjkzMjY4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/9326885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P1n3appl3", "html_url": "https://github.com/P1n3appl3", "followers_url": "https://api.github.com/users/P1n3appl3/followers", "following_url": "https://api.github.com/users/P1n3appl3/following{/other_user}", "gists_url": "https://api.github.com/users/P1n3appl3/gists{/gist_id}", "starred_url": "https://api.github.com/users/P1n3appl3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P1n3appl3/subscriptions", "organizations_url": "https://api.github.com/users/P1n3appl3/orgs", "repos_url": "https://api.github.com/users/P1n3appl3/repos", "events_url": "https://api.github.com/users/P1n3appl3/events{/privacy}", "received_events_url": "https://api.github.com/users/P1n3appl3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d707a008e0822471de4adad047b5cefd281f3ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d707a008e0822471de4adad047b5cefd281f3ac", "html_url": "https://github.com/rust-lang/rust/commit/3d707a008e0822471de4adad047b5cefd281f3ac"}], "stats": {"total": 158, "additions": 69, "deletions": 89}, "files": [{"sha": "2c2ebc9291b98f6e7423a88c2fbe255f42f8f7cd", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "patch": "@@ -44,9 +44,9 @@ pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n pub struct DocContext<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    /// Later on moved into `formats::cache::CACHE_KEY`\n+    /// Later on moved into `CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n-    /// Later on moved through `clean::Crate` into `formats::cache::CACHE_KEY`\n+    /// Later on moved through `clean::Crate` into `CACHE_KEY`\n     pub external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time."}, {"sha": "99b31473f87a371651bbe87295d607f1eebf349b", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "patch": "@@ -148,29 +148,19 @@ impl Cache {\n             external_paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from(t)))).collect();\n \n         let mut cache = Cache {\n-            impls: Default::default(),\n             external_paths,\n             exact_paths,\n-            paths: Default::default(),\n-            implementors: Default::default(),\n-            stack: Vec::new(),\n-            parent_stack: Vec::new(),\n-            search_index: Vec::new(),\n             parent_is_trait_impl: false,\n-            extern_locations: Default::default(),\n-            primitive_locations: Default::default(),\n             stripped_mod: false,\n             access_levels,\n             crate_version: krate.version.take(),\n             document_private,\n-            orphan_impl_items: Vec::new(),\n-            orphan_trait_impls: Vec::new(),\n             traits: krate.external_traits.replace(Default::default()),\n             deref_trait_did,\n             deref_mut_trait_did,\n             owned_box_did,\n             masked_crates: mem::take(&mut krate.masked_crates),\n-            aliases: Default::default(),\n+            ..Cache::default()\n         };\n \n         // Cache where all our extern crates are located\n@@ -211,7 +201,7 @@ impl Cache {\n         for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n             if cache.traits.contains_key(&trait_did) {\n                 for did in dids {\n-                    cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n+                    cache.impls.entry(did).or_default().push(impl_.clone());\n                 }\n             }\n         }"}, {"sha": "dcb0184c58cd20c95918f6c215e7a4edda050787", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "patch": "@@ -2,7 +2,7 @@ pub mod cache;\n pub mod item_type;\n pub mod renderer;\n \n-pub use renderer::{FormatRenderer, Renderer};\n+pub use renderer::{run_format, FormatRenderer};\n \n use rustc_span::def_id::DefId;\n "}, {"sha": "90ace4d44c47dc93e1539dbf1da183df6f641d4b", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 58, "deletions": 68, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "patch": "@@ -7,7 +7,7 @@ use crate::config::{RenderInfo, RenderOptions};\n use crate::error::Error;\n use crate::formats::cache::{Cache, CACHE_KEY};\n \n-/// Allows for different backends to rustdoc to be used with the `Renderer::run()` function. Each\n+/// Allows for different backends to rustdoc to be used with the `run_format()` function. Each\n /// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n /// module, and cleanup/finalizing output.\n pub trait FormatRenderer: Clone {\n@@ -42,75 +42,65 @@ pub trait FormatRenderer: Clone {\n     fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error>;\n }\n \n-#[derive(Clone)]\n-pub struct Renderer;\n-\n-impl Renderer {\n-    pub fn new() -> Renderer {\n-        Renderer\n-    }\n+/// Main method for rendering a crate.\n+pub fn run_format<T: FormatRenderer>(\n+    krate: clean::Crate,\n+    options: RenderOptions,\n+    render_info: RenderInfo,\n+    diag: &rustc_errors::Handler,\n+    edition: Edition,\n+) -> Result<(), Error> {\n+    let (krate, mut cache) = Cache::from_krate(\n+        render_info.clone(),\n+        options.document_private,\n+        &options.extern_html_root_urls,\n+        &options.output,\n+        krate,\n+    );\n+\n+    let (mut format_renderer, mut krate) =\n+        T::init(krate, options, render_info, edition, &mut cache)?;\n+\n+    let cache = Arc::new(cache);\n+    // Freeze the cache now that the index has been built. Put an Arc into TLS for future\n+    // parallelization opportunities\n+    CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n+\n+    let mut item = match krate.module.take() {\n+        Some(i) => i,\n+        None => return Ok(()),\n+    };\n+\n+    item.name = Some(krate.name.clone());\n+\n+    // Render the crate documentation\n+    let mut work = vec![(format_renderer.clone(), item)];\n+\n+    while let Some((mut cx, item)) = work.pop() {\n+        if item.is_mod() {\n+            // modules are special because they add a namespace. We also need to\n+            // recurse into the items of the module as well.\n+            let name = item.name.as_ref().unwrap().to_string();\n+            if name.is_empty() {\n+                panic!(\"Unexpected module with empty name\");\n+            }\n \n-    /// Main method for rendering a crate.\n-    pub fn run<T: FormatRenderer + Clone>(\n-        self,\n-        krate: clean::Crate,\n-        options: RenderOptions,\n-        render_info: RenderInfo,\n-        diag: &rustc_errors::Handler,\n-        edition: Edition,\n-    ) -> Result<(), Error> {\n-        let (krate, mut cache) = Cache::from_krate(\n-            render_info.clone(),\n-            options.document_private,\n-            &options.extern_html_root_urls,\n-            &options.output,\n-            krate,\n-        );\n-\n-        let (mut format_renderer, mut krate) =\n-            T::init(krate, options, render_info, edition, &mut cache)?;\n-\n-        let cache = Arc::new(cache);\n-        // Freeze the cache now that the index has been built. Put an Arc into TLS for future\n-        // parallelization opportunities\n-        CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n-\n-        let mut item = match krate.module.take() {\n-            Some(i) => i,\n-            None => return Ok(()),\n-        };\n-\n-        item.name = Some(krate.name.clone());\n-\n-        // Render the crate documentation\n-        let mut work = vec![(format_renderer.clone(), item)];\n-\n-        while let Some((mut cx, item)) = work.pop() {\n-            if item.is_mod() {\n-                // modules are special because they add a namespace. We also need to\n-                // recurse into the items of the module as well.\n-                let name = item.name.as_ref().unwrap().to_string();\n-                if name.is_empty() {\n-                    panic!(\"Unexpected module with empty name\");\n-                }\n-\n-                cx.mod_item_in(&item, &name, &cache)?;\n-                let module = match item.inner {\n-                    clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n-                    _ => unreachable!(),\n-                };\n-                for it in module.items {\n-                    debug!(\"Adding {:?} to worklist\", it.name);\n-                    work.push((cx.clone(), it));\n-                }\n-\n-                cx.mod_item_out(&name)?;\n-            } else if item.name.is_some() {\n-                cx.item(item, &cache)?;\n+            cx.mod_item_in(&item, &name, &cache)?;\n+            let module = match item.inner {\n+                clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n+                _ => unreachable!(),\n+            };\n+            for it in module.items {\n+                debug!(\"Adding {:?} to worklist\", it.name);\n+                work.push((cx.clone(), it));\n             }\n-        }\n \n-        format_renderer.after_krate(&krate, &cache)?;\n-        format_renderer.after_run(diag)\n+            cx.mod_item_out(&name)?;\n+        } else if item.name.is_some() {\n+            cx.item(item, &cache)?;\n+        }\n     }\n+\n+    format_renderer.after_krate(&krate, &cache)?;\n+    format_renderer.after_run(diag)\n }"}, {"sha": "a6edb8ace33f1cc063e2d415ea122c5d3817dea0", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "patch": "@@ -228,7 +228,7 @@ impl Serialize for IndexItem {\n \n /// A type used for the search index.\n #[derive(Debug)]\n-pub struct RenderType {\n+crate struct RenderType {\n     ty: Option<DefId>,\n     idx: Option<usize>,\n     name: Option<String>,\n@@ -259,7 +259,7 @@ impl Serialize for RenderType {\n \n /// A type used for the search index.\n #[derive(Debug)]\n-pub struct Generic {\n+crate struct Generic {\n     name: String,\n     defid: Option<DefId>,\n     idx: Option<usize>,\n@@ -313,7 +313,7 @@ impl Serialize for IndexItemFunctionType {\n }\n \n #[derive(Debug)]\n-pub struct TypeWithKind {\n+crate struct TypeWithKind {\n     ty: RenderType,\n     kind: TypeKind,\n }"}, {"sha": "a4ce84556f3d7874260a877af1d1741c83ec0f3c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee8023c690158daf4f6c3d8bf2d32297fdfed0c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cee8023c690158daf4f6c3d8bf2d32297fdfed0c", "patch": "@@ -502,9 +502,9 @@ fn main_options(options: config::Options) -> i32 {\n         info!(\"going to format\");\n         let (error_format, edition, debugging_options) = diag_opts;\n         let diag = core::new_handler(error_format, None, &debugging_options);\n-        match formats::Renderer::new()\n-            .run::<html::render::Context>(krate, renderopts, renderinfo, &diag, edition)\n-        {\n+        match formats::run_format::<html::render::Context>(\n+            krate, renderopts, renderinfo, &diag, edition,\n+        ) {\n             Ok(_) => rustc_driver::EXIT_SUCCESS,\n             Err(e) => {\n                 diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error))"}]}