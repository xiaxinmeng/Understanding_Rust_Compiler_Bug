{"sha": "064f17c6a39af65982aa4bc33eb12ac531b4b32a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NGYxN2M2YTM5YWY2NTk4MmFhNGJjMzNlYjEyYWM1MzFiNGIzMmE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-13T21:49:16Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-04T20:48:43Z"}, "message": "Record that an import succeeded or failed in one namespace even while it is indeterminate in the other namespace (fixes #31444)", "tree": {"sha": "72d853b999133d9c7aee83ca33701ff4e2f1dac9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72d853b999133d9c7aee83ca33701ff4e2f1dac9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/064f17c6a39af65982aa4bc33eb12ac531b4b32a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/064f17c6a39af65982aa4bc33eb12ac531b4b32a", "html_url": "https://github.com/rust-lang/rust/commit/064f17c6a39af65982aa4bc33eb12ac531b4b32a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/064f17c6a39af65982aa4bc33eb12ac531b4b32a/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c97524bef9e59a80875110b402b3fc8c139d4d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97524bef9e59a80875110b402b3fc8c139d4d64", "html_url": "https://github.com/rust-lang/rust/commit/c97524bef9e59a80875110b402b3fc8c139d4d64"}], "stats": {"total": 160, "additions": 86, "deletions": 74}, "files": [{"sha": "a9443eaf072ac03be739888621026ba0643cfed7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/064f17c6a39af65982aa4bc33eb12ac531b4b32a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f17c6a39af65982aa4bc33eb12ac531b4b32a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=064f17c6a39af65982aa4bc33eb12ac531b4b32a", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n                         }\n \n-                        let subclass = SingleImport(binding, source_name);\n+                        let subclass = ImportDirectiveSubclass::single(binding, source_name);\n                         self.build_import_directive(parent,\n                                                     module_path,\n                                                     subclass,\n@@ -258,9 +258,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n+                            let subclass = ImportDirectiveSubclass::single(rename, name);\n                             self.build_import_directive(parent,\n                                                         module_path,\n-                                                        SingleImport(rename, name),\n+                                                        subclass,\n                                                         source_item.span,\n                                                         source_item.node.id(),\n                                                         is_public,\n@@ -683,11 +684,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                               id: NodeId,\n                               is_public: bool,\n                               shadowable: Shadowable) {\n-        module_.unresolved_imports\n-               .borrow_mut()\n-               .push(ImportDirective::new(module_path, subclass, span, id, is_public, shadowable));\n-        self.unresolved_imports += 1;\n-\n         if is_public {\n             module_.inc_pub_count();\n         }\n@@ -696,7 +692,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         // the appropriate flag.\n \n         match subclass {\n-            SingleImport(target, _) => {\n+            SingleImport { target, .. } => {\n                 module_.increment_outstanding_references_for(target, ValueNS);\n                 module_.increment_outstanding_references_for(target, TypeNS);\n             }\n@@ -710,6 +706,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 }\n             }\n         }\n+\n+        module_.unresolved_imports\n+               .borrow_mut()\n+               .push(ImportDirective::new(module_path, subclass, span, id, is_public, shadowable));\n+        self.unresolved_imports += 1;\n     }\n }\n "}, {"sha": "c540800324130a770d504643cae4b424b681e962", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 77, "deletions": 66, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/064f17c6a39af65982aa4bc33eb12ac531b4b32a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f17c6a39af65982aa4bc33eb12ac531b4b32a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=064f17c6a39af65982aa4bc33eb12ac531b4b32a", "patch": "@@ -32,14 +32,31 @@ use syntax::codemap::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::mem::replace;\n+use std::cell::Cell;\n \n /// Contains data for specific types of import directives.\n-#[derive(Copy, Clone,Debug)]\n+#[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass {\n-    SingleImport(Name /* target */, Name /* source */),\n+    SingleImport {\n+        target: Name,\n+        source: Name,\n+        type_determined: Cell<bool>,\n+        value_determined: Cell<bool>,\n+    },\n     GlobImport,\n }\n \n+impl ImportDirectiveSubclass {\n+    pub fn single(target: Name, source: Name) -> Self {\n+        SingleImport {\n+            target: target,\n+            source: source,\n+            type_determined: Cell::new(false),\n+            value_determined: Cell::new(false),\n+        }\n+    }\n+}\n+\n /// Whether an import can be shadowed by another import.\n #[derive(Debug,PartialEq,Clone,Copy)]\n pub enum Shadowable {\n@@ -218,7 +235,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn import_resolving_error(&self, e: ImportResolvingError<'b>) {\n         // If it's a single failed import then create a \"fake\" import\n         // resolution for it so that later resolve stages won't complain.\n-        if let SingleImport(target, _) = e.import_directive.subclass {\n+        if let SingleImport { target, .. } = e.import_directive.subclass {\n             let dummy_binding = self.resolver.new_name_binding(NameBinding {\n                 modifiers: DefModifiers::PRELUDE,\n                 kind: NameBindingKind::Def(Def::Err),\n@@ -304,15 +321,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             .and_then(|containing_module| {\n                 // We found the module that the target is contained\n                 // within. Attempt to resolve the import within it.\n-                if let SingleImport(target, source) = import_directive.subclass {\n-                    self.resolve_single_import(module_,\n-                                               containing_module,\n-                                               target,\n-                                               source,\n-                                               import_directive)\n-                } else {\n-                    self.resolve_glob_import(module_, containing_module, import_directive)\n-                }\n+                self.resolve_import(module_, containing_module, import_directive)\n             })\n             .and_then(|()| {\n                 // Decrement the count of unresolved imports.\n@@ -332,36 +341,53 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             })\n     }\n \n-    fn resolve_single_import(&mut self,\n-                             module_: Module<'b>,\n-                             target_module: Module<'b>,\n-                             target: Name,\n-                             source: Name,\n-                             directive: &ImportDirective)\n-                             -> ResolveResult<()> {\n-        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from `{}` id {}\",\n-               target,\n-               module_to_string(&target_module),\n-               source,\n-               module_to_string(module_),\n-               directive.id);\n-\n-        // If this is a circular import, we temporarily count it as determined so that\n-        // it fails (as opposed to being indeterminate) when nothing else can define it.\n-        if target_module.def_id() == module_.def_id() && source == target {\n-            module_.decrement_outstanding_references_for(target, ValueNS);\n-            module_.decrement_outstanding_references_for(target, TypeNS);\n-        }\n+    fn resolve_import(&mut self,\n+                      module_: Module<'b>,\n+                      target_module: Module<'b>,\n+                      directive: &ImportDirective)\n+                      -> ResolveResult<()> {\n+        let (source, target, value_determined, type_determined) = match directive.subclass {\n+            SingleImport { source, target, ref value_determined, ref type_determined } =>\n+                (source, target, value_determined, type_determined),\n+            GlobImport => return self.resolve_glob_import(module_, target_module, directive),\n+        };\n \n         // We need to resolve both namespaces for this to succeed.\n-        let value_result =\n-            self.resolver.resolve_name_in_module(target_module, source, ValueNS, false, true);\n-        let type_result =\n-            self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n-\n-        if target_module.def_id() == module_.def_id() && source == target {\n-            module_.increment_outstanding_references_for(target, ValueNS);\n-            module_.increment_outstanding_references_for(target, TypeNS);\n+        let (value_result, type_result) = {\n+            let mut resolve_in_ns = |ns, determined: bool| {\n+                // Temporarily count the directive as determined so that the resolution fails\n+                // (as opposed to being indeterminate) when it can only be defined by the directive.\n+                if !determined { module_.decrement_outstanding_references_for(target, ns) }\n+                let result =\n+                    self.resolver.resolve_name_in_module(target_module, source, ns, false, true);\n+                if !determined { module_.increment_outstanding_references_for(target, ns) }\n+                result\n+            };\n+            (resolve_in_ns(ValueNS, value_determined.get()),\n+             resolve_in_ns(TypeNS, type_determined.get()))\n+        };\n+\n+        for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n+                                           (TypeNS, &type_result, type_determined)] {\n+            if determined.get() { continue }\n+            if let Indeterminate = *result { continue }\n+\n+            determined.set(true);\n+            if let Success(binding) = *result {\n+                if !binding.defined_with(DefModifiers::IMPORTABLE) {\n+                    let msg = format!(\"`{}` is not directly importable\", target);\n+                    span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n+                }\n+\n+                let privacy_error = if !self.resolver.is_visible(binding, target_module) {\n+                    Some(Box::new(PrivacyError(directive.span, source, binding)))\n+                } else {\n+                    None\n+                };\n+\n+                self.define(module_, target, ns, directive.import(binding, privacy_error));\n+            }\n+            module_.decrement_outstanding_references_for(target, ns);\n         }\n \n         match (&value_result, &type_result) {\n@@ -425,37 +451,22 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => {}\n         }\n \n+        // Report a privacy error here if all successful namespaces are privacy errors.\n         let mut privacy_error = None;\n-        let mut report_privacy_error = true;\n-        for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n-            if let Success(binding) = *result {\n-                if !binding.defined_with(DefModifiers::IMPORTABLE) {\n-                    let msg = format!(\"`{}` is not directly importable\", target);\n-                    span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n-                }\n-\n-                privacy_error = if !self.resolver.is_visible(binding, target_module) {\n-                    Some(Box::new(PrivacyError(directive.span, source, binding)))\n-                } else {\n-                    report_privacy_error = false;\n-                    None\n-                };\n-\n-                self.define(module_, target, ns, directive.import(binding, privacy_error.clone()));\n-            }\n-        }\n-\n-        if report_privacy_error { // then all successful namespaces are privacy errors\n-            // We report here so there is an error even if the imported name is not used\n-            self.resolver.privacy_errors.push(*privacy_error.unwrap());\n+        for &ns in &[ValueNS, TypeNS] {\n+            privacy_error = match module_.resolve_name(target, ns, true) {\n+                Success(&NameBinding {\n+                    kind: NameBindingKind::Import { ref privacy_error, .. }, ..\n+                }) => privacy_error.as_ref().map(|error| (**error).clone()),\n+                _ => continue,\n+            };\n+            if privacy_error.is_none() { break }\n         }\n+        privacy_error.map(|error| self.resolver.privacy_errors.push(error));\n \n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        module_.decrement_outstanding_references_for(target, ValueNS);\n-        module_.decrement_outstanding_references_for(target, TypeNS);\n-\n         let def = match type_result.success().and_then(NameBinding::def) {\n             Some(def) => def,\n             None => value_result.success().and_then(NameBinding::def).unwrap(),\n@@ -610,7 +621,7 @@ fn import_path_to_string(names: &[Name], subclass: ImportDirectiveSubclass) -> S\n \n fn import_directive_subclass_to_string(subclass: ImportDirectiveSubclass) -> String {\n     match subclass {\n-        SingleImport(_, source) => source.to_string(),\n+        SingleImport { source, .. } => source.to_string(),\n         GlobImport => \"*\".to_string(),\n     }\n }"}]}