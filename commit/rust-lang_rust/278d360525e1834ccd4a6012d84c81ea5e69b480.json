{"sha": "278d360525e1834ccd4a6012d84c81ea5e69b480", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OGQzNjA1MjVlMTgzNGNjZDRhNjAxMmQ4NGM4MWVhNWU2OWI0ODA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-28T00:00:57Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-28T02:04:56Z"}, "message": "Refactor compiletest", "tree": {"sha": "7a7b12c8bdccbc13c3d5871ee03ca121cfcdd03a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a7b12c8bdccbc13c3d5871ee03ca121cfcdd03a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/278d360525e1834ccd4a6012d84c81ea5e69b480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/278d360525e1834ccd4a6012d84c81ea5e69b480", "html_url": "https://github.com/rust-lang/rust/commit/278d360525e1834ccd4a6012d84c81ea5e69b480", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/278d360525e1834ccd4a6012d84c81ea5e69b480/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1298f768c1a1cefa119fccffc7029c6110098d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1298f768c1a1cefa119fccffc7029c6110098d0", "html_url": "https://github.com/rust-lang/rust/commit/d1298f768c1a1cefa119fccffc7029c6110098d0"}], "stats": {"total": 467, "additions": 248, "deletions": 219}, "files": [{"sha": "6c453a73a45a4ecb29373622b841c9a592c4093e", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 248, "deletions": 219, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/278d360525e1834ccd4a6012d84c81ea5e69b480/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278d360525e1834ccd4a6012d84c81ea5e69b480/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=278d360525e1834ccd4a6012d84c81ea5e69b480", "patch": "@@ -172,31 +172,9 @@ fn make_test(cx: &cx, testfile: &str, configport: &port[str]) ->\n    test::test_desc {\n     {name: testfile,\n      fn: make_test_closure(testfile, chan(configport)),\n-     ignore: is_test_ignored(cx.config, testfile)}\n+            ignore: header::is_test_ignored(cx.config, testfile)}\n }\n \n-fn is_test_ignored(config: &config, testfile: &str) -> bool {\n-    let found = false;\n-    for each ln: str  in iter_header(testfile) {\n-        // FIXME: Can't return or break from iterator\n-        found = found || parse_name_directive(ln, \"xfail-\" + config.stage_id);\n-    }\n-    ret found;\n-}\n-\n-iter iter_header(testfile: &str) -> str {\n-    let rdr = io::file_reader(testfile);\n-    while !rdr.eof() {\n-        let ln = rdr.read_line();\n-\n-        // Assume that any directives will be found before the\n-        // first module or function. This doesn't seem to be an optimization\n-        // with a warm page cache. Maybe with a cold one.\n-        if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n-            break;\n-        } else { put ln; }\n-    }\n-}\n \n /*\n So this is kind of crappy:\n@@ -272,185 +250,9 @@ fn run_test_task(compile_lib_path: str, run_lib_path: str, rustc_path: str,\n \n     let cx = {config: config, procsrv: procsrv};\n \n-    log #fmt(\"running %s\", testfile);\n-    task::unsupervise();\n-    let props = load_props(testfile);\n-    alt cx.config.mode {\n-      mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n-      mode_run_fail. { run_rfail_test(cx, props, testfile); }\n-      mode_run_pass. { run_rpass_test(cx, props, testfile); }\n-    }\n-}\n-\n-type test_props = {error_patterns: str[], compile_flags: option::t[str]};\n-\n-// Load any test directives embedded in the file\n-fn load_props(testfile: &str) -> test_props {\n-    let error_patterns = ~[];\n-    let compile_flags = option::none;\n-    for each ln: str  in iter_header(testfile) {\n-        alt parse_error_pattern(ln) {\n-          option::some(ep) { error_patterns += ~[ep]; }\n-          option::none. { }\n-        }\n-\n-\n-        if option::is_none(compile_flags) {\n-            compile_flags = parse_compile_flags(ln);\n-        }\n-    }\n-    ret {error_patterns: error_patterns, compile_flags: compile_flags};\n-}\n-\n-fn parse_error_pattern(line: &str) -> option::t[str] {\n-    parse_name_value_directive(line, \"error-pattern\")\n-}\n-\n-fn parse_compile_flags(line: &str) -> option::t[str] {\n-    parse_name_value_directive(line, \"compile-flags\")\n-}\n-\n-fn parse_name_directive(line: &str, directive: &str) -> bool {\n-    str::find(line, directive) >= 0\n-}\n-\n-fn parse_name_value_directive(line: &str, directive: &str) -> option::t[str] {\n-    let keycolon = directive + \":\";\n-    if str::find(line, keycolon) >= 0 {\n-        let colon = str::find(line, keycolon) as uint;\n-        let value =\n-            str::slice(line, colon + str::byte_len(keycolon),\n-                       str::byte_len(line));\n-        log #fmt(\"%s: %s\", directive, value);\n-        option::some(value)\n-    } else { option::none }\n-}\n-\n-fn run_cfail_test(cx: &cx, props: &test_props, testfile: &str) {\n-    let procres = compile_test(cx, props, testfile);\n-\n-    if procres.status == 0 {\n-        fatal_procres(\"compile-fail test compiled successfully!\", procres);\n-    }\n-\n-    check_error_patterns(props, testfile, procres);\n-}\n-\n-fn run_rfail_test(cx: &cx, props: &test_props, testfile: &str) {\n-    let procres = compile_test(cx, props, testfile);\n-\n-    if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n-\n-    procres = exec_compiled_test(cx, testfile);\n-\n-    if procres.status == 0 {\n-        fatal_procres(\"run-fail test didn't produce an error!\", procres);\n-    }\n-\n-    check_error_patterns(props, testfile, procres);\n-}\n-\n-fn run_rpass_test(cx: &cx, props: &test_props, testfile: &str) {\n-    let procres = compile_test(cx, props, testfile);\n-\n-    if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n-\n-    procres = exec_compiled_test(cx, testfile);\n-\n-\n-    if procres.status != 0 { fatal_procres(\"test run failed!\", procres); }\n-}\n-\n-fn check_error_patterns(props: &test_props, testfile: &str,\n-                        procres: &procres) {\n-    if ivec::is_empty(props.error_patterns) {\n-        fatal(\"no error pattern specified in \" + testfile);\n-    }\n-\n-    let next_err_idx = 0u;\n-    let next_err_pat = props.error_patterns.(next_err_idx);\n-    for line: str  in str::split(procres.out, '\\n' as u8) {\n-        if str::find(line, next_err_pat) > 0 {\n-            log #fmt(\"found error pattern %s\", next_err_pat);\n-            next_err_idx += 1u;\n-            if next_err_idx == ivec::len(props.error_patterns) {\n-                log \"found all error patterns\";\n-                ret;\n-            }\n-            next_err_pat = props.error_patterns.(next_err_idx);\n-        }\n-    }\n-\n-    let missing_patterns =\n-        ivec::slice(props.error_patterns, next_err_idx,\n-                    ivec::len(props.error_patterns));\n-    if ivec::len(missing_patterns) == 1u {\n-        fatal_procres(#fmt(\"error pattern '%s' not found!\",\n-                           missing_patterns.(0)), procres);\n-    } else {\n-        for pattern: str  in missing_patterns {\n-            error(#fmt(\"error pattern '%s' not found!\", pattern));\n-        }\n-        fatal_procres(\"multiple error patterns not found\", procres);\n-    }\n-}\n-\n-type procargs = {prog: str, args: vec[str]};\n-\n-type procres = {status: int, out: str, cmdline: str};\n-\n-fn compile_test(cx: &cx, props: &test_props, testfile: &str) -> procres {\n-    compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n-                    cx.config.compile_lib_path)\n+    runtest::run(cx, testfile);\n }\n \n-fn exec_compiled_test(cx: &cx, testfile: &str) -> procres {\n-    compose_and_run(cx, testfile, make_run_args, cx.config.run_lib_path)\n-}\n-\n-fn compose_and_run(cx: &cx, testfile: &str,\n-                   make_args: fn(&config, &str) -> procargs , lib_path: &str)\n-   -> procres {\n-    let procargs = make_args(cx.config, testfile);\n-    ret program_output(cx, testfile, lib_path, procargs.prog, procargs.args);\n-}\n-\n-fn make_compile_args(config: &config, props: &test_props, testfile: &str) ->\n-   procargs {\n-    let prog = config.rustc_path;\n-    let args = [testfile, \"-o\", make_exe_name(config, testfile)];\n-    args += split_maybe_args(config.rustcflags);\n-    args += split_maybe_args(props.compile_flags);\n-    ret {prog: prog, args: args};\n-}\n-\n-fn make_run_args(config: &config, testfile: &str) -> procargs {\n-    // If we've got another tool to run under (valgrind),\n-    // then split apart its command\n-    let args =\n-        split_maybe_args(config.runtool) + [make_exe_name(config, testfile)];\n-    ret {prog: args.(0), args: vec::slice(args, 1u, vec::len(args))};\n-}\n-\n-fn split_maybe_args(argstr: &option::t[str]) -> vec[str] {\n-    alt argstr {\n-      option::some(s) { str::split(s, ' ' as u8) }\n-      option::none. { [] }\n-    }\n-}\n-\n-fn program_output(cx: &cx, testfile: &str, lib_path: &str, prog: &str,\n-                  args: &vec[str]) -> procres {\n-    let cmdline =\n-        {\n-            let cmdline = make_cmdline(lib_path, prog, args);\n-            logv(cx.config, #fmt(\"running %s\", cmdline));\n-            cmdline\n-        };\n-    let res = procsrv::run(cx.procsrv, lib_path, prog, args);\n-    dump_output(cx.config, testfile, res.out);\n-    ret {status: res.status, out: res.out, cmdline: cmdline};\n-}\n \n fn make_cmdline(libpath: &str, prog: &str, args: &vec[str]) -> str {\n     #fmt(\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n@@ -524,30 +326,257 @@ fn make_out_name(config: &config, testfile: &str) -> str {\n     output_base_name(config, testfile) + \".out\"\n }\n \n-fn error(err: &str) { io::stdout().write_line(#fmt(\"\\nerror: %s\", err)); }\n-\n-fn fatal(err: &str) -> ! { error(err); fail; }\n-\n-fn fatal_procres(err: &str, procres: procres) -> ! {\n-    let msg =\n-        #fmt(\"\\n\\\n-                     error: %s\\n\\\n-                     command: %s\\n\\\n-                     output:\\n\\\n-                     ------------------------------------------\\n\\\n-                     %s\\n\\\n-                     ------------------------------------------\\n\\\n-                     \\n\",\n-             err, procres.cmdline, procres.out);\n-    io::stdout().write_str(msg);\n-    fail;\n-}\n-\n fn logv(config: &config, s: &str) {\n     log s;\n     if config.verbose { io::stdout().write_line(s); }\n }\n \n+mod header {\n+\n+    export test_props;\n+    export load_props;\n+    export is_test_ignored;\n+\n+    type test_props = {error_patterns: str[], compile_flags: option::t[str]};\n+\n+    // Load any test directives embedded in the file\n+    fn load_props(testfile: &str) -> test_props {\n+        let error_patterns = ~[];\n+        let compile_flags = option::none;\n+        for each ln: str  in iter_header(testfile) {\n+                alt parse_error_pattern(ln) {\n+                        option::some(ep) { error_patterns += ~[ep]; }\n+                        option::none. { }\n+                    }\n+\n+\n+                if option::is_none(compile_flags) {\n+                        compile_flags = parse_compile_flags(ln);\n+                    }\n+            }\n+        ret {error_patterns: error_patterns, compile_flags: compile_flags};\n+    }\n+\n+    fn is_test_ignored(config: &config, testfile: &str) -> bool {\n+        let found = false;\n+        for each ln: str  in iter_header(testfile) {\n+                // FIXME: Can't return or break from iterator\n+                found = found\n+                    || parse_name_directive(ln, \"xfail-\" + config.stage_id);\n+            }\n+        ret found;\n+    }\n+\n+    iter iter_header(testfile: &str) -> str {\n+        let rdr = io::file_reader(testfile);\n+        while !rdr.eof() {\n+                let ln = rdr.read_line();\n+\n+                // Assume that any directives will be found before the first\n+                // module or function. This doesn't seem to be an optimization\n+                // with a warm page cache. Maybe with a cold one.\n+                if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n+                        break;\n+                    } else { put ln; }\n+            }\n+    }\n+\n+    fn parse_error_pattern(line: &str) -> option::t[str] {\n+        parse_name_value_directive(line, \"error-pattern\")\n+            }\n+\n+    fn parse_compile_flags(line: &str) -> option::t[str] {\n+        parse_name_value_directive(line, \"compile-flags\")\n+            }\n+\n+    fn parse_name_directive(line: &str, directive: &str) -> bool {\n+        str::find(line, directive) >= 0\n+            }\n+\n+    fn parse_name_value_directive(line: &str,\n+                                  directive: &str) -> option::t[str] {\n+        let keycolon = directive + \":\";\n+        if str::find(line, keycolon) >= 0 {\n+                let colon = str::find(line, keycolon) as uint;\n+                let value =\n+                    str::slice(line, colon + str::byte_len(keycolon),\n+                               str::byte_len(line));\n+                log #fmt(\"%s: %s\", directive, value);\n+                option::some(value)\n+                    } else { option::none }\n+    }\n+}\n+\n+mod runtest {\n+\n+    import header::load_props;\n+    import header::test_props;\n+\n+    export run;\n+\n+    fn run(cx: &cx, testfile: &str) {\n+        log #fmt(\"running %s\", testfile);\n+        task::unsupervise();\n+        let props = load_props(testfile);\n+        alt cx.config.mode {\n+                mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n+                mode_run_fail. { run_rfail_test(cx, props, testfile); }\n+                mode_run_pass. { run_rpass_test(cx, props, testfile); }\n+            }\n+    }\n+\n+    fn run_cfail_test(cx: &cx, props: &test_props, testfile: &str) {\n+        let procres = compile_test(cx, props, testfile);\n+\n+        if procres.status == 0 {\n+            fatal_procres(\"compile-fail test compiled successfully!\",\n+                          procres);\n+        }\n+\n+        check_error_patterns(props, testfile, procres);\n+    }\n+\n+    fn run_rfail_test(cx: &cx, props: &test_props, testfile: &str) {\n+        let procres = compile_test(cx, props, testfile);\n+\n+        if procres.status != 0 {\n+                fatal_procres(\"compilation failed!\", procres); }\n+\n+        procres = exec_compiled_test(cx, testfile);\n+\n+        if procres.status == 0 {\n+            fatal_procres(\"run-fail test didn't produce an error!\",\n+                          procres);\n+            }\n+\n+        check_error_patterns(props, testfile, procres);\n+    }\n+\n+    fn run_rpass_test(cx: &cx, props: &test_props, testfile: &str) {\n+        let procres = compile_test(cx, props, testfile);\n+\n+        if procres.status != 0 {\n+                fatal_procres(\"compilation failed!\", procres); }\n+\n+        procres = exec_compiled_test(cx, testfile);\n+\n+\n+        if procres.status != 0 { fatal_procres(\"test run failed!\", procres); }\n+    }\n+\n+    fn check_error_patterns(props: &test_props, testfile: &str,\n+                            procres: &procres) {\n+        if ivec::is_empty(props.error_patterns) {\n+                fatal(\"no error pattern specified in \" + testfile);\n+            }\n+\n+        let next_err_idx = 0u;\n+        let next_err_pat = props.error_patterns.(next_err_idx);\n+        for line: str  in str::split(procres.out, '\\n' as u8) {\n+                if str::find(line, next_err_pat) > 0 {\n+                        log #fmt(\"found error pattern %s\", next_err_pat);\n+                        next_err_idx += 1u;\n+                        if next_err_idx == ivec::len(props.error_patterns) {\n+                                log \"found all error patterns\";\n+                                ret;\n+                            }\n+                        next_err_pat = props.error_patterns.(next_err_idx);\n+                    }\n+            }\n+\n+        let missing_patterns =\n+            ivec::slice(props.error_patterns, next_err_idx,\n+                        ivec::len(props.error_patterns));\n+        if ivec::len(missing_patterns) == 1u {\n+                fatal_procres(#fmt(\"error pattern '%s' not found!\",\n+                                   missing_patterns.(0)), procres);\n+            } else {\n+            for pattern: str  in missing_patterns {\n+                    error(#fmt(\"error pattern '%s' not found!\", pattern));\n+                }\n+            fatal_procres(\"multiple error patterns not found\", procres);\n+        }\n+    }\n+\n+    type procargs = {prog: str, args: vec[str]};\n+\n+    type procres = {status: int, out: str, cmdline: str};\n+\n+    fn compile_test(cx: &cx, props: &test_props, testfile: &str) -> procres {\n+        compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n+                        cx.config.compile_lib_path)\n+            }\n+\n+    fn exec_compiled_test(cx: &cx, testfile: &str) -> procres {\n+        compose_and_run(cx, testfile, make_run_args, cx.config.run_lib_path)\n+            }\n+\n+    fn compose_and_run(cx: &cx, testfile: &str,\n+                       make_args: fn(&config, &str) -> procargs ,\n+                       lib_path: &str) -> procres {\n+        let procargs = make_args(cx.config, testfile);\n+        ret program_output(cx, testfile, lib_path,\n+                           procargs.prog, procargs.args);\n+    }\n+\n+    fn make_compile_args(config: &config,\n+                         props: &test_props, testfile: &str) ->\n+        procargs {\n+        let prog = config.rustc_path;\n+        let args = [testfile, \"-o\", make_exe_name(config, testfile)];\n+        args += split_maybe_args(config.rustcflags);\n+        args += split_maybe_args(props.compile_flags);\n+        ret {prog: prog, args: args};\n+    }\n+\n+    fn make_run_args(config: &config, testfile: &str) -> procargs {\n+        // If we've got another tool to run under (valgrind),\n+        // then split apart its command\n+        let args =\n+            split_maybe_args(config.runtool)\n+            + [make_exe_name(config, testfile)];\n+        ret {prog: args.(0), args: vec::slice(args, 1u, vec::len(args))};\n+    }\n+\n+    fn split_maybe_args(argstr: &option::t[str]) -> vec[str] {\n+        alt argstr {\n+                option::some(s) { str::split(s, ' ' as u8) }\n+                option::none. { [] }\n+            }\n+    }\n+\n+    fn program_output(cx: &cx, testfile: &str, lib_path: &str, prog: &str,\n+                      args: &vec[str]) -> procres {\n+        let cmdline =\n+            {\n+                let cmdline = make_cmdline(lib_path, prog, args);\n+                logv(cx.config, #fmt(\"running %s\", cmdline));\n+                cmdline\n+            };\n+        let res = procsrv::run(cx.procsrv, lib_path, prog, args);\n+        dump_output(cx.config, testfile, res.out);\n+        ret {status: res.status, out: res.out, cmdline: cmdline};\n+    }\n+\n+    fn error(err: &str) { io::stdout().write_line(#fmt(\"\\nerror: %s\", err)); }\n+\n+    fn fatal(err: &str) -> ! { error(err); fail; }\n+\n+    fn fatal_procres(err: &str, procres: procres) -> ! {\n+        let msg =\n+            #fmt(\"\\n\\\n+                  error: %s\\n\\\n+                  command: %s\\n\\\n+                  output:\\n\\\n+                  ------------------------------------------\\n\\\n+                  %s\\n\\\n+                  ------------------------------------------\\n\\\n+                  \\n\",\n+                 err, procres.cmdline, procres.out);\n+        io::stdout().write_str(msg);\n+        fail;\n+    }\n+}\n \n // So when running tests in parallel there's a potential race on environment\n // variables if we let each task spawn its own children - between the time the"}]}