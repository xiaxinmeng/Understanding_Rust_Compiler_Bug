{"sha": "7d1531f3c134859fc4f733ebddcfd38a8987d5cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMTUzMWYzYzEzNDg1OWZjNGY3MzNlYmRkY2ZkMzhhODk4N2Q1Y2Y=", "commit": {"author": {"name": "Henry Boisdequin", "email": "65845077+henryboisdequin@users.noreply.github.com", "date": "2021-03-02T12:36:12Z"}, "committer": {"name": "Henry Boisdequin", "email": "65845077+henryboisdequin@users.noreply.github.com", "date": "2021-03-02T12:36:12Z"}, "message": "fmt data_race.rs and intrinsics.rs", "tree": {"sha": "b324a665bc97c7781a0dc9ed50ff47e33c92e1d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b324a665bc97c7781a0dc9ed50ff47e33c92e1d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d1531f3c134859fc4f733ebddcfd38a8987d5cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d1531f3c134859fc4f733ebddcfd38a8987d5cf", "html_url": "https://github.com/rust-lang/rust/commit/7d1531f3c134859fc4f733ebddcfd38a8987d5cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d1531f3c134859fc4f733ebddcfd38a8987d5cf/comments", "author": {"login": "henryboisdequin", "id": 65845077, "node_id": "MDQ6VXNlcjY1ODQ1MDc3", "avatar_url": "https://avatars.githubusercontent.com/u/65845077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/henryboisdequin", "html_url": "https://github.com/henryboisdequin", "followers_url": "https://api.github.com/users/henryboisdequin/followers", "following_url": "https://api.github.com/users/henryboisdequin/following{/other_user}", "gists_url": "https://api.github.com/users/henryboisdequin/gists{/gist_id}", "starred_url": "https://api.github.com/users/henryboisdequin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/henryboisdequin/subscriptions", "organizations_url": "https://api.github.com/users/henryboisdequin/orgs", "repos_url": "https://api.github.com/users/henryboisdequin/repos", "events_url": "https://api.github.com/users/henryboisdequin/events{/privacy}", "received_events_url": "https://api.github.com/users/henryboisdequin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "henryboisdequin", "id": 65845077, "node_id": "MDQ6VXNlcjY1ODQ1MDc3", "avatar_url": "https://avatars.githubusercontent.com/u/65845077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/henryboisdequin", "html_url": "https://github.com/henryboisdequin", "followers_url": "https://api.github.com/users/henryboisdequin/followers", "following_url": "https://api.github.com/users/henryboisdequin/following{/other_user}", "gists_url": "https://api.github.com/users/henryboisdequin/gists{/gist_id}", "starred_url": "https://api.github.com/users/henryboisdequin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/henryboisdequin/subscriptions", "organizations_url": "https://api.github.com/users/henryboisdequin/orgs", "repos_url": "https://api.github.com/users/henryboisdequin/repos", "events_url": "https://api.github.com/users/henryboisdequin/events{/privacy}", "received_events_url": "https://api.github.com/users/henryboisdequin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e29f1379413dd5ddbcbb3199bbe9faf2745824f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e29f1379413dd5ddbcbb3199bbe9faf2745824f5", "html_url": "https://github.com/rust-lang/rust/commit/e29f1379413dd5ddbcbb3199bbe9faf2745824f5"}], "stats": {"total": 303, "additions": 205, "deletions": 98}, "files": [{"sha": "c7bafb60a61911dfb9820755df47b5a008add594", "filename": "src/data_race.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d1531f3c134859fc4f733ebddcfd38a8987d5cf/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d1531f3c134859fc4f733ebddcfd38a8987d5cf/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=7d1531f3c134859fc4f733ebddcfd38a8987d5cf", "patch": "@@ -263,7 +263,7 @@ impl MemoryCellClocks {\n             atomic_ops: None,\n         }\n     }\n-    \n+\n     /// Load the internal atomic memory cells if they exist.\n     #[inline]\n     fn atomic(&self) -> Option<&AtomicMemoryCellClocks> {\n@@ -323,7 +323,7 @@ impl MemoryCellClocks {\n     /// store relaxed semantics.\n     fn store_relaxed(&mut self, clocks: &ThreadClockSet, index: VectorIdx) -> Result<(), DataRace> {\n         self.atomic_write_detect(clocks, index)?;\n-        \n+\n         // The handling of release sequences was changed in C++20 and so\n         // the code here is different to the paper since now all relaxed\n         // stores block release sequences. The exception for same-thread\n@@ -678,7 +678,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                     // Either Release | AcqRel | SeqCst\n                     clocks.apply_release_fence();\n                 }\n-                \n+\n                 // Increment timestamp in case of release semantics.\n                 Ok(atomic != AtomicFenceOp::Acquire)\n             })"}, {"sha": "f9ec62d7514d6d3028ae39170fac0adc5d8152b7", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 202, "deletions": 95, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/7d1531f3c134859fc4f733ebddcfd38a8987d5cf/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d1531f3c134859fc4f733ebddcfd38a8987d5cf/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=7d1531f3c134859fc4f733ebddcfd38a8987d5cf", "patch": "@@ -2,9 +2,9 @@ use std::iter;\n \n use log::trace;\n \n-use rustc_middle::{mir, mir::BinOp, ty, ty::FloatTy};\n-use rustc_middle::ty::layout::IntegerExt;\n use rustc_apfloat::{Float, Round};\n+use rustc_middle::ty::layout::IntegerExt;\n+use rustc_middle::{mir, mir::BinOp, ty, ty::FloatTy};\n use rustc_target::abi::{Align, Integer, LayoutOf};\n \n use crate::*;\n@@ -67,8 +67,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let count = this.read_scalar(count)?.to_machine_usize(this)?;\n-                let byte_count = ty_layout.size.checked_mul(count, this)\n-                    .ok_or_else(|| err_ub_format!(\"overflow computing total size of `write_bytes`\"))?;\n+                let byte_count = ty_layout.size.checked_mul(count, this).ok_or_else(|| {\n+                    err_ub_format!(\"overflow computing total size of `write_bytes`\")\n+                })?;\n                 this.memory\n                     .write_bytes(ptr, iter::repeat(val_byte).take(byte_count.bytes() as usize))?;\n             }\n@@ -258,13 +259,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let val = this.read_immediate(val)?;\n \n                 let res = match val.layout.ty.kind() {\n-                    ty::Float(FloatTy::F32) => {\n-                        this.float_to_int_unchecked(val.to_scalar()?.to_f32()?, dest.layout.ty)?\n-                    }\n-                    ty::Float(FloatTy::F64) => {\n-                        this.float_to_int_unchecked(val.to_scalar()?.to_f64()?, dest.layout.ty)?\n-                    }\n-                    _ => bug!(\"`float_to_int_unchecked` called with non-float input type {:?}\", val.layout.ty),\n+                    ty::Float(FloatTy::F32) =>\n+                        this.float_to_int_unchecked(val.to_scalar()?.to_f32()?, dest.layout.ty)?,\n+                    ty::Float(FloatTy::F64) =>\n+                        this.float_to_int_unchecked(val.to_scalar()?.to_f64()?, dest.layout.ty)?,\n+                    _ => bug!(\n+                        \"`float_to_int_unchecked` called with non-float input type {:?}\",\n+                        val.layout.ty\n+                    ),\n                 };\n \n                 this.write_scalar(res, dest)?;\n@@ -286,7 +288,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             \"atomic_singlethreadfence_acq\" => this.compiler_fence(args, AtomicFenceOp::Acquire)?,\n             \"atomic_singlethreadfence_rel\" => this.compiler_fence(args, AtomicFenceOp::Release)?,\n-            \"atomic_singlethreadfence_acqrel\" => this.compiler_fence(args, AtomicFenceOp::AcqRel)?,\n+            \"atomic_singlethreadfence_acqrel\" =>\n+                this.compiler_fence(args, AtomicFenceOp::AcqRel)?,\n             \"atomic_singlethreadfence\" => this.compiler_fence(args, AtomicFenceOp::SeqCst)?,\n \n             \"atomic_xchg\" => this.atomic_exchange(args, dest, AtomicRwOp::SeqCst)?,\n@@ -295,110 +298,179 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"atomic_xchg_acqrel\" => this.atomic_exchange(args, dest, AtomicRwOp::AcqRel)?,\n             \"atomic_xchg_relaxed\" => this.atomic_exchange(args, dest, AtomicRwOp::Relaxed)?,\n \n-            \"atomic_cxchg\" => this.atomic_compare_exchange(\n-                args, dest, AtomicRwOp::SeqCst, AtomicReadOp::SeqCst\n-            )?,\n+            \"atomic_cxchg\" =>\n+                this.atomic_compare_exchange(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::SeqCst)?,\n             \"atomic_cxchg_acq\" => this.atomic_compare_exchange(\n-                args, dest, AtomicRwOp::Acquire, AtomicReadOp::Acquire\n+                args,\n+                dest,\n+                AtomicRwOp::Acquire,\n+                AtomicReadOp::Acquire,\n             )?,\n             \"atomic_cxchg_rel\" => this.atomic_compare_exchange(\n-                args, dest, AtomicRwOp::Release, AtomicReadOp::Relaxed\n-            )?,\n-            \"atomic_cxchg_acqrel\" => this.atomic_compare_exchange\n-            (args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Acquire\n+                args,\n+                dest,\n+                AtomicRwOp::Release,\n+                AtomicReadOp::Relaxed,\n             )?,\n+            \"atomic_cxchg_acqrel\" =>\n+                this.atomic_compare_exchange(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Acquire)?,\n             \"atomic_cxchg_relaxed\" => this.atomic_compare_exchange(\n-                args, dest, AtomicRwOp::Relaxed, AtomicReadOp::Relaxed\n+                args,\n+                dest,\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n             )?,\n             \"atomic_cxchg_acq_failrelaxed\" => this.atomic_compare_exchange(\n-                args, dest, AtomicRwOp::Acquire, AtomicReadOp::Relaxed\n-            )?,\n-            \"atomic_cxchg_acqrel_failrelaxed\" => this.atomic_compare_exchange(\n-                args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Relaxed\n-            )?,\n-            \"atomic_cxchg_failrelaxed\" => this.atomic_compare_exchange(\n-                args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Relaxed\n-            )?,\n-            \"atomic_cxchg_failacq\" => this.atomic_compare_exchange(\n-                args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Acquire\n+                args,\n+                dest,\n+                AtomicRwOp::Acquire,\n+                AtomicReadOp::Relaxed,\n             )?,\n+            \"atomic_cxchg_acqrel_failrelaxed\" =>\n+                this.atomic_compare_exchange(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Relaxed)?,\n+            \"atomic_cxchg_failrelaxed\" =>\n+                this.atomic_compare_exchange(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Relaxed)?,\n+            \"atomic_cxchg_failacq\" =>\n+                this.atomic_compare_exchange(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Acquire)?,\n \n             \"atomic_cxchgweak\" => this.atomic_compare_exchange_weak(\n-                args, dest, AtomicRwOp::SeqCst, AtomicReadOp::SeqCst\n+                args,\n+                dest,\n+                AtomicRwOp::SeqCst,\n+                AtomicReadOp::SeqCst,\n             )?,\n             \"atomic_cxchgweak_acq\" => this.atomic_compare_exchange_weak(\n-                args, dest, AtomicRwOp::Acquire, AtomicReadOp::Acquire\n+                args,\n+                dest,\n+                AtomicRwOp::Acquire,\n+                AtomicReadOp::Acquire,\n             )?,\n             \"atomic_cxchgweak_rel\" => this.atomic_compare_exchange_weak(\n-                args, dest, AtomicRwOp::Release, AtomicReadOp::Relaxed\n+                args,\n+                dest,\n+                AtomicRwOp::Release,\n+                AtomicReadOp::Relaxed,\n             )?,\n             \"atomic_cxchgweak_acqrel\" => this.atomic_compare_exchange_weak(\n-                args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Acquire\n+                args,\n+                dest,\n+                AtomicRwOp::AcqRel,\n+                AtomicReadOp::Acquire,\n             )?,\n             \"atomic_cxchgweak_relaxed\" => this.atomic_compare_exchange_weak(\n-                args, dest, AtomicRwOp::Relaxed, AtomicReadOp::Relaxed\n+                args,\n+                dest,\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n             )?,\n             \"atomic_cxchgweak_acq_failrelaxed\" => this.atomic_compare_exchange_weak(\n-                args, dest, AtomicRwOp::Acquire, AtomicReadOp::Relaxed\n+                args,\n+                dest,\n+                AtomicRwOp::Acquire,\n+                AtomicReadOp::Relaxed,\n             )?,\n             \"atomic_cxchgweak_acqrel_failrelaxed\" => this.atomic_compare_exchange_weak(\n-                args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Relaxed\n+                args,\n+                dest,\n+                AtomicRwOp::AcqRel,\n+                AtomicReadOp::Relaxed,\n             )?,\n             \"atomic_cxchgweak_failrelaxed\" => this.atomic_compare_exchange_weak(\n-                args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Relaxed\n+                args,\n+                dest,\n+                AtomicRwOp::SeqCst,\n+                AtomicReadOp::Relaxed,\n             )?,\n             \"atomic_cxchgweak_failacq\" => this.atomic_compare_exchange_weak(\n-                args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Acquire\n+                args,\n+                dest,\n+                AtomicRwOp::SeqCst,\n+                AtomicReadOp::Acquire,\n             )?,\n \n             \"atomic_or\" => this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_or_acq\" => this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::Acquire)?,\n-            \"atomic_or_rel\" => this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::Release)?,\n-            \"atomic_or_acqrel\" => this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_or_relaxed\" => this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::Relaxed)?,\n+            \"atomic_or_acq\" =>\n+                this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::Acquire)?,\n+            \"atomic_or_rel\" =>\n+                this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::Release)?,\n+            \"atomic_or_acqrel\" =>\n+                this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::AcqRel)?,\n+            \"atomic_or_relaxed\" =>\n+                this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::Relaxed)?,\n             \"atomic_xor\" => this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_xor_acq\" => this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::Acquire)?,\n-            \"atomic_xor_rel\" => this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::Release)?,\n-            \"atomic_xor_acqrel\" => this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_xor_relaxed\" => this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::Relaxed)?,\n+            \"atomic_xor_acq\" =>\n+                this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::Acquire)?,\n+            \"atomic_xor_rel\" =>\n+                this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::Release)?,\n+            \"atomic_xor_acqrel\" =>\n+                this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::AcqRel)?,\n+            \"atomic_xor_relaxed\" =>\n+                this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::Relaxed)?,\n             \"atomic_and\" => this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_and_acq\" => this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::Acquire)?,\n-            \"atomic_and_rel\" => this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::Release)?,\n-            \"atomic_and_acqrel\" => this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_and_relaxed\" => this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::Relaxed)?,\n+            \"atomic_and_acq\" =>\n+                this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::Acquire)?,\n+            \"atomic_and_rel\" =>\n+                this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::Release)?,\n+            \"atomic_and_acqrel\" =>\n+                this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::AcqRel)?,\n+            \"atomic_and_relaxed\" =>\n+                this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::Relaxed)?,\n             \"atomic_nand\" => this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::SeqCst)?,\n-            \"atomic_nand_acq\" => this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::Acquire)?,\n-            \"atomic_nand_rel\" => this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::Release)?,\n-            \"atomic_nand_acqrel\" => this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::AcqRel)?,\n-            \"atomic_nand_relaxed\" => this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::Relaxed)?,\n+            \"atomic_nand_acq\" =>\n+                this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::Acquire)?,\n+            \"atomic_nand_rel\" =>\n+                this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::Release)?,\n+            \"atomic_nand_acqrel\" =>\n+                this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::AcqRel)?,\n+            \"atomic_nand_relaxed\" =>\n+                this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::Relaxed)?,\n             \"atomic_xadd\" => this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_xadd_acq\" => this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::Acquire)?,\n-            \"atomic_xadd_rel\" => this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::Release)?,\n-            \"atomic_xadd_acqrel\" => this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_xadd_relaxed\" => this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::Relaxed)?,\n+            \"atomic_xadd_acq\" =>\n+                this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::Acquire)?,\n+            \"atomic_xadd_rel\" =>\n+                this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::Release)?,\n+            \"atomic_xadd_acqrel\" =>\n+                this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::AcqRel)?,\n+            \"atomic_xadd_relaxed\" =>\n+                this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::Relaxed)?,\n             \"atomic_xsub\" => this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_xsub_acq\" => this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::Acquire)?,\n-            \"atomic_xsub_rel\" => this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::Release)?,\n-            \"atomic_xsub_acqrel\" => this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_xsub_relaxed\" => this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::Relaxed)?,\n-\n+            \"atomic_xsub_acq\" =>\n+                this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::Acquire)?,\n+            \"atomic_xsub_rel\" =>\n+                this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::Release)?,\n+            \"atomic_xsub_acqrel\" =>\n+                this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::AcqRel)?,\n+            \"atomic_xsub_relaxed\" =>\n+                this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::Relaxed)?,\n \n             // Query type information\n-            \"assert_zero_valid\" |\n-            \"assert_uninit_valid\" => {\n+            \"assert_zero_valid\" | \"assert_uninit_valid\" => {\n                 let &[] = check_arg_count(args)?;\n                 let ty = instance.substs.type_at(0);\n                 let layout = this.layout_of(ty)?;\n                 // Abort here because the caller might not be panic safe.\n                 if layout.abi.is_uninhabited() {\n                     // Use this message even for the other intrinsics, as that's what codegen does\n-                    throw_machine_stop!(TerminationInfo::Abort(format!(\"aborted execution: attempted to instantiate uninhabited type `{}`\", ty)))\n+                    throw_machine_stop!(TerminationInfo::Abort(format!(\n+                        \"aborted execution: attempted to instantiate uninhabited type `{}`\",\n+                        ty\n+                    )))\n                 }\n-                if intrinsic_name == \"assert_zero_valid\" && !layout.might_permit_raw_init(this, /*zero:*/ true).unwrap() {\n-                    throw_machine_stop!(TerminationInfo::Abort(format!(\"aborted execution: attempted to zero-initialize type `{}`, which is invalid\", ty)))\n+                if intrinsic_name == \"assert_zero_valid\"\n+                    && !layout.might_permit_raw_init(this, /*zero:*/ true).unwrap()\n+                {\n+                    throw_machine_stop!(TerminationInfo::Abort(format!(\n+                        \"aborted execution: attempted to zero-initialize type `{}`, which is invalid\",\n+                        ty\n+                    )))\n                 }\n-                if intrinsic_name == \"assert_uninit_valid\" && !layout.might_permit_raw_init(this, /*zero:*/ false).unwrap() {\n-                    throw_machine_stop!(TerminationInfo::Abort(format!(\"aborted execution: attempted to leave type `{}` uninitialized, which is invalid\", ty)))\n+                if intrinsic_name == \"assert_uninit_valid\"\n+                    && !layout.might_permit_raw_init(this, /*zero:*/ false).unwrap()\n+                {\n+                    throw_machine_stop!(TerminationInfo::Abort(format!(\n+                        \"aborted execution: attempted to leave type `{}` uninitialized, which is invalid\",\n+                        ty\n+                    )))\n                 }\n             }\n \n@@ -419,12 +491,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     fn atomic_load(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        atomic: AtomicReadOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-\n         let &[ref place] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n \n@@ -440,7 +513,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n-    fn atomic_store(&mut self, args: &[OpTy<'tcx, Tag>], atomic: AtomicWriteOp) -> InterpResult<'tcx> {\n+    fn atomic_store(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        atomic: AtomicWriteOp,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         let &[ref place, ref val] = check_arg_count(args)?;\n@@ -458,23 +535,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n-    fn compiler_fence(&mut self, args: &[OpTy<'tcx, Tag>], atomic: AtomicFenceOp) -> InterpResult<'tcx> {\n+    fn compiler_fence(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        atomic: AtomicFenceOp,\n+    ) -> InterpResult<'tcx> {\n         let &[] = check_arg_count(args)?;\n         let _ = atomic;\n         //FIXME: compiler fences are currently ignored\n         Ok(())\n     }\n \n-    fn atomic_fence(&mut self, args: &[OpTy<'tcx, Tag>], atomic: AtomicFenceOp) -> InterpResult<'tcx> {\n+    fn atomic_fence(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        atomic: AtomicFenceOp,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let &[] = check_arg_count(args)?;\n         this.validate_atomic_fence(atomic)?;\n         Ok(())\n     }\n \n     fn atomic_op(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n-        op: mir::BinOp, neg: bool, atomic: AtomicRwOp\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        op: mir::BinOp,\n+        neg: bool,\n+        atomic: AtomicRwOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -490,14 +579,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n         this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n-        \n+\n         let old = this.atomic_op_immediate(&place, &rhs, op, neg, atomic)?;\n         this.write_immediate(*old, dest)?; // old value is returned\n         Ok(())\n     }\n-    \n+\n     fn atomic_exchange(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>, atomic: AtomicRwOp\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        atomic: AtomicRwOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -517,8 +609,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     fn atomic_compare_exchange_impl(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp, fail: AtomicReadOp, can_fail_spuriously: bool\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        success: AtomicRwOp,\n+        fail: AtomicReadOp,\n+        can_fail_spuriously: bool,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -527,16 +623,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let expect_old = this.read_immediate(expect_old)?; // read as immediate for the sake of `binary_op()`\n         let new = this.read_scalar(new)?;\n \n-\n         // Check alignment requirements. Atomics must always be aligned to their size,\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n         this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n-        \n         let old = this.atomic_compare_exchange_scalar(\n-            &place, &expect_old, new, success, fail, can_fail_spuriously\n+            &place,\n+            &expect_old,\n+            new,\n+            success,\n+            fail,\n+            can_fail_spuriously,\n         )?;\n \n         // Return old value.\n@@ -545,15 +644,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     fn atomic_compare_exchange(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp, fail: AtomicReadOp\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        success: AtomicRwOp,\n+        fail: AtomicReadOp,\n     ) -> InterpResult<'tcx> {\n         self.atomic_compare_exchange_impl(args, dest, success, fail, false)\n     }\n \n     fn atomic_compare_exchange_weak(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp, fail: AtomicReadOp\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+        success: AtomicRwOp,\n+        fail: AtomicReadOp,\n     ) -> InterpResult<'tcx> {\n         self.atomic_compare_exchange_impl(args, dest, success, fail, true)\n     }\n@@ -564,7 +669,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dest_ty: ty::Ty<'tcx>,\n     ) -> InterpResult<'tcx, Scalar<Tag>>\n     where\n-        F: Float + Into<Scalar<Tag>>\n+        F: Float + Into<Scalar<Tag>>,\n     {\n         let this = self.eval_context_ref();\n \n@@ -585,7 +690,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // `f` was not representable in this integer type.\n                     throw_ub_format!(\n                         \"`float_to_int_unchecked` intrinsic called on {} which cannot be represented in target type `{:?}`\",\n-                        f, dest_ty,\n+                        f,\n+                        dest_ty,\n                     );\n                 }\n             }\n@@ -600,7 +706,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // `f` was not representable in this integer type.\n                     throw_ub_format!(\n                         \"`float_to_int_unchecked` intrinsic called on {} which cannot be represented in target type `{:?}`\",\n-                        f, dest_ty,\n+                        f,\n+                        dest_ty,\n                     );\n                 }\n             }"}]}