{"sha": "045c8c86244aa69843c7f55ec91f2330a3aaec4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NWM4Yzg2MjQ0YWE2OTg0M2M3ZjU1ZWM5MWYyMzMwYTNhYWVjNGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-07-09T02:45:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-08-11T18:19:30Z"}, "message": "std: Optimize panic::catch_unwind slightly\n\nThe previous implementation of this function was overly conservative with\nliberal usage of `Option` and `.unwrap()` which in theory never triggers. This\ncommit essentially removes the `Option`s in favor of unsafe implementations,\nimproving the code generation of the fast path for LLVM to see through what's\nhappening more clearly.\n\ncc #34727", "tree": {"sha": "adea616d01ccd690c63854ae2d21ba78e56e778e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adea616d01ccd690c63854ae2d21ba78e56e778e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/045c8c86244aa69843c7f55ec91f2330a3aaec4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/045c8c86244aa69843c7f55ec91f2330a3aaec4e", "html_url": "https://github.com/rust-lang/rust/commit/045c8c86244aa69843c7f55ec91f2330a3aaec4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/045c8c86244aa69843c7f55ec91f2330a3aaec4e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42001edc998f3406ecc04afa48bf07ce91247b67", "url": "https://api.github.com/repos/rust-lang/rust/commits/42001edc998f3406ecc04afa48bf07ce91247b67", "html_url": "https://github.com/rust-lang/rust/commit/42001edc998f3406ecc04afa48bf07ce91247b67"}], "stats": {"total": 104, "additions": 68, "deletions": 36}, "files": [{"sha": "5961fd59699c1b8d0a92341e6c78f69729f0b648", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/045c8c86244aa69843c7f55ec91f2330a3aaec4e/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045c8c86244aa69843c7f55ec91f2330a3aaec4e/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=045c8c86244aa69843c7f55ec91f2330a3aaec4e", "patch": "@@ -25,9 +25,10 @@ use cell::RefCell;\n use fmt;\n use intrinsics;\n use mem;\n+use ptr;\n use raw;\n-use sys_common::rwlock::RWLock;\n use sys::stdio::Stderr;\n+use sys_common::rwlock::RWLock;\n use sys_common::thread_info;\n use sys_common::util;\n use thread;\n@@ -255,45 +256,76 @@ pub use realstd::rt::update_panic_count;\n \n /// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n pub unsafe fn try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<Any + Send>> {\n-    let mut slot = None;\n-    let mut f = Some(f);\n-    let ret;\n-\n-    {\n-        let mut to_run = || {\n-            slot = Some(f.take().unwrap()());\n-        };\n-        let fnptr = get_call(&mut to_run);\n-        let dataptr = &mut to_run as *mut _ as *mut u8;\n-        let mut any_data = 0;\n-        let mut any_vtable = 0;\n-        let fnptr = mem::transmute::<fn(&mut _), fn(*mut u8)>(fnptr);\n-        let r = __rust_maybe_catch_panic(fnptr,\n-                                         dataptr,\n-                                         &mut any_data,\n-                                         &mut any_vtable);\n-        if r == 0 {\n-            ret = Ok(());\n-        } else {\n-            update_panic_count(-1);\n-            ret = Err(mem::transmute(raw::TraitObject {\n-                data: any_data as *mut _,\n-                vtable: any_vtable as *mut _,\n-            }));\n-        }\n+    struct Data<F, R> {\n+        f: F,\n+        r: R,\n     }\n \n-    debug_assert!(update_panic_count(0) == 0);\n-    return ret.map(|()| {\n-        slot.take().unwrap()\n-    });\n+    // We do some sketchy operations with ownership here for the sake of\n+    // performance. The `Data` structure is never actually fully valid, but\n+    // instead it always contains at least one uninitialized field. We can only\n+    // pass pointers down to `__rust_maybe_catch_panic` (can't pass objects by\n+    // value), so we do all the ownership tracking here manully.\n+    //\n+    // Note that this is all invalid if any of these functions unwind, but the\n+    // whole point of this function is to prevent that! As a result we go\n+    // through a transition where:\n+    //\n+    // * First, only the closure we're going to call is initialized. The return\n+    //   value is uninitialized.\n+    // * When we make the function call, the `do_call` function below, we take\n+    //   ownership of the function pointer, replacing it with uninitialized\n+    //   data. At this point the `Data` structure is entirely uninitialized, but\n+    //   it won't drop due to an unwind because it's owned on the other side of\n+    //   the catch panic.\n+    // * If the closure successfully returns, we write the return value into the\n+    //   data's return slot. Note that `ptr::write` is used as it's overwriting\n+    //   uninitialized data.\n+    // * Finally, when we come back out of the `__rust_maybe_catch_panic` we're\n+    //   in one of two states:\n+    //\n+    //      1. The closure didn't panic, in which case the return value was\n+    //         filled in. We have to be careful to `forget` the closure,\n+    //         however, as ownership was passed to the `do_call` function.\n+    //      2. The closure panicked, in which case the return value wasn't\n+    //         filled in. In this case the entire `data` structure is invalid,\n+    //         so we forget the entire thing.\n+    //\n+    // Once we stack all that together we should have the \"most efficient'\n+    // method of calling a catch panic whilst juggling ownership.\n+    let mut any_data = 0;\n+    let mut any_vtable = 0;\n+    let mut data = Data {\n+        f: f,\n+        r: mem::uninitialized(),\n+    };\n \n-    fn get_call<F: FnMut()>(_: &mut F) -> fn(&mut F) {\n-        call\n-    }\n+    let r = __rust_maybe_catch_panic(do_call::<F, R>,\n+                                     &mut data as *mut _ as *mut u8,\n+                                     &mut any_data,\n+                                     &mut any_vtable);\n+\n+    return if r == 0 {\n+        let Data { f, r } = data;\n+        mem::forget(f);\n+        debug_assert!(update_panic_count(0) == 0);\n+        Ok(r)\n+    } else {\n+        mem::forget(data);\n+        update_panic_count(-1);\n+        debug_assert!(update_panic_count(0) == 0);\n+        Err(mem::transmute(raw::TraitObject {\n+            data: any_data as *mut _,\n+            vtable: any_vtable as *mut _,\n+        }))\n+    };\n \n-    fn call<F: FnMut()>(f: &mut F) {\n-        f()\n+    fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n+        unsafe {\n+            let data = data as *mut Data<F, R>;\n+            let f = ptr::read(&mut (*data).f);\n+            ptr::write(&mut (*data).r, f());\n+        }\n     }\n }\n "}]}