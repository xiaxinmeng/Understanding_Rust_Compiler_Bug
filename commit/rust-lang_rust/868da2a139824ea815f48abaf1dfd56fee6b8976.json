{"sha": "868da2a139824ea815f48abaf1dfd56fee6b8976", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OGRhMmExMzk4MjRlYTgxNWY0OGFiYWYxZGZkNTZmZWU2Yjg5NzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-15T08:47:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-15T08:47:20Z"}, "message": "Auto merge of #907 - christianpoveda:env-vars-shim, r=RalfJung\n\nMove env shims to its own module\n\nr? @RalfJung", "tree": {"sha": "70b4d0ca1bb492f9600a83ebd0a74ada4d3b2f8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70b4d0ca1bb492f9600a83ebd0a74ada4d3b2f8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/868da2a139824ea815f48abaf1dfd56fee6b8976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/868da2a139824ea815f48abaf1dfd56fee6b8976", "html_url": "https://github.com/rust-lang/rust/commit/868da2a139824ea815f48abaf1dfd56fee6b8976", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/868da2a139824ea815f48abaf1dfd56fee6b8976/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f504ea7be76c55bb3ba8d79599f161d65f5bb51", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f504ea7be76c55bb3ba8d79599f161d65f5bb51", "html_url": "https://github.com/rust-lang/rust/commit/1f504ea7be76c55bb3ba8d79599f161d65f5bb51"}, {"sha": "aee8f173ec46d4b98cc562c6e7cad54bef764298", "url": "https://api.github.com/repos/rust-lang/rust/commits/aee8f173ec46d4b98cc562c6e7cad54bef764298", "html_url": "https://github.com/rust-lang/rust/commit/aee8f173ec46d4b98cc562c6e7cad54bef764298"}], "stats": {"total": 139, "additions": 76, "deletions": 63}, "files": [{"sha": "ae57bcf98b96fda9c6e0496443f3f0ab756ef147", "filename": "src/eval.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/868da2a139824ea815f48abaf1dfd56fee6b8976/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868da2a139824ea815f48abaf1dfd56fee6b8976/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=868da2a139824ea815f48abaf1dfd56fee6b8976", "patch": "@@ -39,7 +39,6 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         Evaluator::new(config.communicate),\n         MemoryExtra::new(StdRng::seed_from_u64(config.seed.unwrap_or(0)), config.validate),\n     );\n-\n     // Complete initialization.\n     EnvVars::init(&mut ecx, config.communicate);\n "}, {"sha": "cea99d86eaa8aca66cde48349b23c2660bf39337", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868da2a139824ea815f48abaf1dfd56fee6b8976/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868da2a139824ea815f48abaf1dfd56fee6b8976/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=868da2a139824ea815f48abaf1dfd56fee6b8976", "patch": "@@ -33,7 +33,7 @@ pub use crate::shims::foreign_items::EvalContextExt as ForeignItemsEvalContextEx\n pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n pub use crate::shims::dlsym::{Dlsym, EvalContextExt as DlsymEvalContextExt};\n-pub use crate::shims::env::EnvVars;\n+pub use crate::shims::env::{EnvVars, EvalContextExt as EnvEvalContextExt};\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};"}, {"sha": "c941bf4f50e3f0c74afc2671bec6fe4ae4a3a382", "filename": "src/shims/env.rs", "status": "modified", "additions": 70, "deletions": 13, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/868da2a139824ea815f48abaf1dfd56fee6b8976/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868da2a139824ea815f48abaf1dfd56fee6b8976/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=868da2a139824ea815f48abaf1dfd56fee6b8976", "patch": "@@ -22,21 +22,9 @@ impl EnvVars {\n             }\n         }\n     }\n-\n-    pub(crate) fn get(&self, name: &[u8]) -> Option<&Pointer<Tag>> {\n-        self.map.get(name)\n-    }\n-\n-    pub(crate) fn unset(&mut self, name: &[u8]) -> Option<Pointer<Tag>> {\n-        self.map.remove(name)\n-    }\n-\n-    pub(crate) fn set(&mut self, name: Vec<u8>, ptr: Pointer<Tag>) -> Option<Pointer<Tag>>{\n-        self.map.insert(name, ptr)\n-    }\n }\n \n-pub(crate) fn alloc_env_value<'mir, 'tcx>(\n+fn alloc_env_value<'mir, 'tcx>(\n     bytes: &[u8],\n     memory: &mut Memory<'mir, 'tcx, Evaluator<'tcx>>,\n ) -> Pointer<Tag> {\n@@ -58,3 +46,72 @@ pub(crate) fn alloc_env_value<'mir, 'tcx>(\n     alloc.write_bytes(&tcx, trailing_zero_ptr, &[0]).unwrap();\n     ptr\n }\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn getenv(\n+        &mut self,\n+        name_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_mut();\n+\n+        let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n+        let name = this.memory().read_c_str(name_ptr)?;\n+        Ok(match this.machine.env_vars.map.get(name) {\n+            Some(&var) => Scalar::Ptr(var),\n+            None => Scalar::ptr_null(&*this.tcx),\n+        })\n+    }\n+\n+    fn setenv(\n+        &mut self,\n+        name_op: OpTy<'tcx, Tag>,\n+        value_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n+        let value_ptr = this.read_scalar(value_op)?.not_undef()?;\n+        let value = this.memory().read_c_str(value_ptr)?;\n+        let mut new = None;\n+        if !this.is_null(name_ptr)? {\n+            let name = this.memory().read_c_str(name_ptr)?;\n+            if !name.is_empty() && !name.contains(&b'=') {\n+                new = Some((name.to_owned(), value.to_owned()));\n+            }\n+        }\n+        if let Some((name, value)) = new {\n+            let value_copy = alloc_env_value(&value, this.memory_mut());\n+            if let Some(var) = this.machine.env_vars.map.insert(name.to_owned(), value_copy) {\n+                this.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n+            }\n+            Ok(0)\n+        } else {\n+            Ok(-1)\n+        }\n+    }\n+\n+    fn unsetenv(\n+        &mut self,\n+        name_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n+        let mut success = None;\n+        if !this.is_null(name_ptr)? {\n+            let name = this.memory().read_c_str(name_ptr)?.to_owned();\n+            if !name.is_empty() && !name.contains(&b'=') {\n+                success = Some(this.machine.env_vars.map.remove(&name));\n+            }\n+        }\n+        if let Some(old) = success {\n+            if let Some(var) = old {\n+                this.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n+            }\n+            Ok(0)\n+        } else {\n+            Ok(-1)\n+        }\n+    }\n+}"}, {"sha": "59e7673dcab5f58f729d5841f8594bfe771f9c21", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 5, "deletions": 48, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/868da2a139824ea815f48abaf1dfd56fee6b8976/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868da2a139824ea815f48abaf1dfd56fee6b8976/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=868da2a139824ea815f48abaf1dfd56fee6b8976", "patch": "@@ -8,7 +8,6 @@ use syntax::attr;\n use syntax::symbol::sym;\n \n use crate::*;\n-use crate::shims::env::alloc_env_value;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -423,60 +422,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"getenv\" => {\n-                let result = {\n-                    let name_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                    let name = this.memory().read_c_str(name_ptr)?;\n-                    match this.machine.env_vars.get(name) {\n-                        Some(&var) => Scalar::Ptr(var),\n-                        None => Scalar::ptr_null(&*this.tcx),\n-                    }\n-                };\n+                let result = this.getenv(args[0])?;\n                 this.write_scalar(result, dest)?;\n             }\n \n             \"unsetenv\" => {\n-                let mut success = None;\n-                {\n-                    let name_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                    if !this.is_null(name_ptr)? {\n-                        let name = this.memory().read_c_str(name_ptr)?.to_owned();\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            success = Some(this.machine.env_vars.unset(&name));\n-                        }\n-                    }\n-                }\n-                if let Some(old) = success {\n-                    if let Some(var) = old {\n-                        this.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n-                    }\n-                    this.write_null(dest)?;\n-                } else {\n-                    this.write_scalar(Scalar::from_int(-1, dest.layout.size), dest)?;\n-                }\n+                let result = this.unsetenv(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n             \"setenv\" => {\n-                let mut new = None;\n-                {\n-                    let name_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                    let value_ptr = this.read_scalar(args[1])?.not_undef()?;\n-                    let value = this.memory().read_c_str(value_ptr)?;\n-                    if !this.is_null(name_ptr)? {\n-                        let name = this.memory().read_c_str(name_ptr)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            new = Some((name.to_owned(), value.to_owned()));\n-                        }\n-                    }\n-                }\n-                if let Some((name, value)) = new {\n-                    let value_copy = alloc_env_value(&value, this.memory_mut());\n-                    if let Some(var) = this.machine.env_vars.set(name.to_owned(), value_copy) {\n-                        this.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n-                    }\n-                    this.write_null(dest)?;\n-                } else {\n-                    this.write_scalar(Scalar::from_int(-1, dest.layout.size), dest)?;\n-                }\n+                let result = this.setenv(args[0], args[1])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n             \"write\" => {"}]}