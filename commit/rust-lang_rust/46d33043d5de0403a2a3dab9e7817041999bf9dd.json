{"sha": "46d33043d5de0403a2a3dab9e7817041999bf9dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZDMzMDQzZDVkZTA0MDNhMmEzZGFiOWU3ODE3MDQxOTk5YmY5ZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-24T12:48:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-24T12:48:24Z"}, "message": "Auto merge of #5701 - ebroto:4874_cmp_owned_fp, r=flip1995\n\ncmp_owned: handle when PartialEq is not implemented symmetrically\n\nchangelog: Handle asymmetrical implementations of PartialEq in [`cmp_owned`].\n\nFixes #4874", "tree": {"sha": "560efe04f3cbb89a9069654a15f4f587dbb866db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/560efe04f3cbb89a9069654a15f4f587dbb866db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46d33043d5de0403a2a3dab9e7817041999bf9dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46d33043d5de0403a2a3dab9e7817041999bf9dd", "html_url": "https://github.com/rust-lang/rust/commit/46d33043d5de0403a2a3dab9e7817041999bf9dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46d33043d5de0403a2a3dab9e7817041999bf9dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a14eab389f6e9f8bdaffbba184b20220041b036f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a14eab389f6e9f8bdaffbba184b20220041b036f", "html_url": "https://github.com/rust-lang/rust/commit/a14eab389f6e9f8bdaffbba184b20220041b036f"}, {"sha": "b498e1d71537a79e7aff5378da625aca8b4eef96", "url": "https://api.github.com/repos/rust-lang/rust/commits/b498e1d71537a79e7aff5378da625aca8b4eef96", "html_url": "https://github.com/rust-lang/rust/commit/b498e1d71537a79e7aff5378da625aca8b4eef96"}], "stats": {"total": 324, "additions": 291, "deletions": 33}, "files": [{"sha": "76ffe6f6a1c42ca58f10370243fca90498825915", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/46d33043d5de0403a2a3dab9e7817041999bf9dd/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d33043d5de0403a2a3dab9e7817041999bf9dd/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=46d33043d5de0403a2a3dab9e7817041999bf9dd", "patch": "@@ -3,11 +3,11 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt, StmtKind, Ty,\n-    TyKind, UnOp,\n+    self as hir, def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt,\n+    StmtKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n@@ -371,8 +371,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n                 if op.is_comparison() {\n                     check_nan(cx, left, expr);\n                     check_nan(cx, right, expr);\n-                    check_to_owned(cx, left, right);\n-                    check_to_owned(cx, right, left);\n+                    check_to_owned(cx, left, right, true);\n+                    check_to_owned(cx, right, left, false);\n                 }\n                 if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n                     if is_allowed(cx, left) || is_allowed(cx, right) {\n@@ -570,19 +570,38 @@ fn is_array(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     matches!(&walk_ptrs_ty(cx.tables.expr_ty(expr)).kind, ty::Array(_, _))\n }\n \n-fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n+fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n+    #[derive(Default)]\n+    struct EqImpl {\n+        ty_eq_other: bool,\n+        other_eq_ty: bool,\n+    }\n+\n+    impl EqImpl {\n+        fn is_implemented(&self) -> bool {\n+            self.ty_eq_other || self.other_eq_ty\n+        }\n+    }\n+\n+    fn symmetric_partial_eq<'tcx>(cx: &LateContext<'_, 'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n+        cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n+            ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n+            other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n+        })\n+    }\n+\n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n-                (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                (cx.tables.expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.tables.expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -593,28 +612,19 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n         _ => return,\n     };\n \n-    let other_ty = cx.tables.expr_ty_adjusted(other);\n-    let partial_eq_trait_id = match cx.tcx.lang_items().eq_trait() {\n-        Some(id) => id,\n-        None => return,\n-    };\n+    let other_ty = cx.tables.expr_ty(other);\n \n-    let deref_arg_impl_partial_eq_other = arg_ty.builtin_deref(true).map_or(false, |tam| {\n-        implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty.into()])\n-    });\n-    let arg_impl_partial_eq_deref_other = other_ty.builtin_deref(true).map_or(false, |tam| {\n-        implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty.into()])\n-    });\n-    let arg_impl_partial_eq_other = implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty.into()]);\n+    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n+    let with_deref = arg_ty\n+        .builtin_deref(true)\n+        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n+        .unwrap_or_default();\n \n-    if !deref_arg_impl_partial_eq_other && !arg_impl_partial_eq_deref_other && !arg_impl_partial_eq_other {\n+    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n         return;\n     }\n \n-    let other_gets_derefed = match other.kind {\n-        ExprKind::Unary(UnOp::UnDeref, _) => true,\n-        _ => false,\n-    };\n+    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::UnDeref, _));\n \n     let lint_span = if other_gets_derefed {\n         expr.span.to(other.span)\n@@ -634,18 +644,34 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n                 return;\n             }\n \n-            let try_hint = if deref_arg_impl_partial_eq_other {\n-                // suggest deref on the left\n-                format!(\"*{}\", snip)\n+            let expr_snip;\n+            let eq_impl;\n+            if with_deref.is_implemented() {\n+                expr_snip = format!(\"*{}\", snip);\n+                eq_impl = with_deref;\n             } else {\n-                // suggest dropping the to_owned on the left\n-                snip.to_string()\n+                expr_snip = snip.to_string();\n+                eq_impl = without_deref;\n             };\n \n+            let span;\n+            let hint;\n+            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n+                span = expr.span;\n+                hint = expr_snip;\n+            } else {\n+                span = expr.span.to(other.span);\n+                if eq_impl.ty_eq_other {\n+                    hint = format!(\"{} == {}\", expr_snip, snippet(cx, other.span, \"..\"));\n+                } else {\n+                    hint = format!(\"{} == {}\", snippet(cx, other.span, \"..\"), expr_snip);\n+                }\n+            }\n+\n             diag.span_suggestion(\n-                lint_span,\n+                span,\n                 \"try\",\n-                try_hint,\n+                hint,\n                 Applicability::MachineApplicable, // snippet\n             );\n         },\n@@ -694,7 +720,7 @@ fn non_macro_local(cx: &LateContext<'_, '_>, res: def::Res) -> bool {\n     }\n }\n \n-fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr<'_>, ty: &Ty<'_>) {\n+fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>) {\n     if_chain! {\n         if let TyKind::Ptr(ref mut_ty) = ty.kind;\n         if let ExprKind::Lit(ref lit) = e.kind;"}, {"sha": "3305ac9bf8b6cb40ec93bc7fadea0ad83b920d4e", "filename": "tests/ui/cmp_owned/asymmetric_partial_eq.fixed", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/46d33043d5de0403a2a3dab9e7817041999bf9dd/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46d33043d5de0403a2a3dab9e7817041999bf9dd/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed?ref=46d33043d5de0403a2a3dab9e7817041999bf9dd", "patch": "@@ -0,0 +1,93 @@\n+// run-rustfix\n+#![allow(unused, clippy::redundant_clone)] // See #5700\n+\n+// Define the types in each module to avoid trait impls leaking between modules.\n+macro_rules! impl_types {\n+    () => {\n+        #[derive(PartialEq)]\n+        pub struct Owned;\n+\n+        pub struct Borrowed;\n+\n+        impl ToOwned for Borrowed {\n+            type Owned = Owned;\n+            fn to_owned(&self) -> Owned {\n+                Owned {}\n+            }\n+        }\n+\n+        impl std::borrow::Borrow<Borrowed> for Owned {\n+            fn borrow(&self) -> &Borrowed {\n+                static VALUE: Borrowed = Borrowed {};\n+                &VALUE\n+            }\n+        }\n+    };\n+}\n+\n+// Only Borrowed == Owned is implemented\n+mod borrowed_eq_owned {\n+    impl_types!();\n+\n+    impl PartialEq<Owned> for Borrowed {\n+        fn eq(&self, _: &Owned) -> bool {\n+            true\n+        }\n+    }\n+\n+    pub fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if borrowed == owned {}\n+        if borrowed == owned {}\n+    }\n+}\n+\n+// Only Owned == Borrowed is implemented\n+mod owned_eq_borrowed {\n+    impl_types!();\n+\n+    impl PartialEq<Borrowed> for Owned {\n+        fn eq(&self, _: &Borrowed) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if owned == borrowed {}\n+        if owned == borrowed {}\n+    }\n+}\n+\n+mod issue_4874 {\n+    impl_types!();\n+\n+    // NOTE: PartialEq<Borrowed> for T can't be implemented due to the orphan rules\n+    impl<T> PartialEq<T> for Borrowed\n+    where\n+        T: AsRef<str> + ?Sized,\n+    {\n+        fn eq(&self, _: &T) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl std::fmt::Display for Borrowed {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"borrowed\")\n+        }\n+    }\n+\n+    fn compare() {\n+        let borrowed = Borrowed {};\n+\n+        if borrowed == \"Hi\" {}\n+        if borrowed == \"Hi\" {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "88bc2f51dd6629a8b923f4a1a874ad424764c80f", "filename": "tests/ui/cmp_owned/asymmetric_partial_eq.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/46d33043d5de0403a2a3dab9e7817041999bf9dd/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d33043d5de0403a2a3dab9e7817041999bf9dd/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs?ref=46d33043d5de0403a2a3dab9e7817041999bf9dd", "patch": "@@ -0,0 +1,93 @@\n+// run-rustfix\n+#![allow(unused, clippy::redundant_clone)] // See #5700\n+\n+// Define the types in each module to avoid trait impls leaking between modules.\n+macro_rules! impl_types {\n+    () => {\n+        #[derive(PartialEq)]\n+        pub struct Owned;\n+\n+        pub struct Borrowed;\n+\n+        impl ToOwned for Borrowed {\n+            type Owned = Owned;\n+            fn to_owned(&self) -> Owned {\n+                Owned {}\n+            }\n+        }\n+\n+        impl std::borrow::Borrow<Borrowed> for Owned {\n+            fn borrow(&self) -> &Borrowed {\n+                static VALUE: Borrowed = Borrowed {};\n+                &VALUE\n+            }\n+        }\n+    };\n+}\n+\n+// Only Borrowed == Owned is implemented\n+mod borrowed_eq_owned {\n+    impl_types!();\n+\n+    impl PartialEq<Owned> for Borrowed {\n+        fn eq(&self, _: &Owned) -> bool {\n+            true\n+        }\n+    }\n+\n+    pub fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if borrowed.to_owned() == owned {}\n+        if owned == borrowed.to_owned() {}\n+    }\n+}\n+\n+// Only Owned == Borrowed is implemented\n+mod owned_eq_borrowed {\n+    impl_types!();\n+\n+    impl PartialEq<Borrowed> for Owned {\n+        fn eq(&self, _: &Borrowed) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if owned == borrowed.to_owned() {}\n+        if borrowed.to_owned() == owned {}\n+    }\n+}\n+\n+mod issue_4874 {\n+    impl_types!();\n+\n+    // NOTE: PartialEq<Borrowed> for T can't be implemented due to the orphan rules\n+    impl<T> PartialEq<T> for Borrowed\n+    where\n+        T: AsRef<str> + ?Sized,\n+    {\n+        fn eq(&self, _: &T) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl std::fmt::Display for Borrowed {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"borrowed\")\n+        }\n+    }\n+\n+    fn compare() {\n+        let borrowed = Borrowed {};\n+\n+        if \"Hi\" == borrowed.to_string() {}\n+        if borrowed.to_string() == \"Hi\" {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "43bf8851fc620d700fe9adcc457f8d88466c2780", "filename": "tests/ui/cmp_owned/asymmetric_partial_eq.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/46d33043d5de0403a2a3dab9e7817041999bf9dd/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46d33043d5de0403a2a3dab9e7817041999bf9dd/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr?ref=46d33043d5de0403a2a3dab9e7817041999bf9dd", "patch": "@@ -0,0 +1,46 @@\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:42:12\n+   |\n+LL |         if borrowed.to_owned() == owned {}\n+   |            ^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+   |\n+   = note: `-D clippy::cmp-owned` implied by `-D warnings`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:43:21\n+   |\n+LL |         if owned == borrowed.to_owned() {}\n+   |            ---------^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            help: try: `borrowed == owned`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:61:21\n+   |\n+LL |         if owned == borrowed.to_owned() {}\n+   |                     ^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:62:12\n+   |\n+LL |         if borrowed.to_owned() == owned {}\n+   |            ^^^^^^^^^^^^^^^^^^^---------\n+   |            |\n+   |            help: try: `owned == borrowed`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:88:20\n+   |\n+LL |         if \"Hi\" == borrowed.to_string() {}\n+   |            --------^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            help: try: `borrowed == \"Hi\"`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:89:12\n+   |\n+LL |         if borrowed.to_string() == \"Hi\" {}\n+   |            ^^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+\n+error: aborting due to 6 previous errors\n+"}]}