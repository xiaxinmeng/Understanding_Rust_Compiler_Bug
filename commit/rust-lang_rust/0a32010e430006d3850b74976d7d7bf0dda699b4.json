{"sha": "0a32010e430006d3850b74976d7d7bf0dda699b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMzIwMTBlNDMwMDA2ZDM4NTBiNzQ5NzZkN2Q3YmYwZGRhNjk5YjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-07T15:53:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-08T14:19:07Z"}, "message": "Add comments to autoderef() helper and refactor it to take\nan `Option<&Expr>` like everything else.", "tree": {"sha": "9a31823b2ff962dd601339a0ca091fee99228b37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a31823b2ff962dd601339a0ca091fee99228b37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a32010e430006d3850b74976d7d7bf0dda699b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a32010e430006d3850b74976d7d7bf0dda699b4", "html_url": "https://github.com/rust-lang/rust/commit/0a32010e430006d3850b74976d7d7bf0dda699b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a32010e430006d3850b74976d7d7bf0dda699b4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5364c4853fa61aced8fdf773d9de41b929a0d318", "url": "https://api.github.com/repos/rust-lang/rust/commits/5364c4853fa61aced8fdf773d9de41b929a0d318", "html_url": "https://github.com/rust-lang/rust/commit/5364c4853fa61aced8fdf773d9de41b929a0d318"}], "stats": {"total": 79, "additions": 58, "deletions": 21}, "files": [{"sha": "7946077485976e4cd3bbfa8128f4f7b97865f8b0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a32010e430006d3850b74976d7d7bf0dda699b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a32010e430006d3850b74976d7d7bf0dda699b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0a32010e430006d3850b74976d7d7bf0dda699b4", "patch": "@@ -143,7 +143,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // time writing the results into the various tables.\n         let (autoderefd_ty, n, result) =\n             check::autoderef(\n-                self.fcx, self.span, unadjusted_self_ty, Some(self.self_expr.id), NoPreference,\n+                self.fcx, self.span, unadjusted_self_ty, Some(self.self_expr), NoPreference,\n                 |_, n| if n == auto_deref_ref.autoderefs { Some(()) } else { None });\n         assert_eq!(n, auto_deref_ref.autoderefs);\n         assert_eq!(result, Some(()));\n@@ -492,7 +492,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                exprs.repr(self.tcx()));\n \n         // Fix up autoderefs and derefs.\n-        for (i, expr) in exprs.iter().rev().enumerate() {\n+        for (i, &expr) in exprs.iter().rev().enumerate() {\n             // Count autoderefs.\n             let autoderef_count = match self.fcx\n                                             .inh\n@@ -512,8 +512,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             if autoderef_count > 0 {\n                 check::autoderef(self.fcx,\n                                  expr.span,\n-                                 self.fcx.expr_ty(*expr),\n-                                 Some(expr.id),\n+                                 self.fcx.expr_ty(expr),\n+                                 Some(expr),\n                                  PreferMutLvalue,\n                                  |_, autoderefs| {\n                                      if autoderefs == autoderef_count + 1 {\n@@ -567,7 +567,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         let result = check::try_index_step(\n                             self.fcx,\n                             MethodCall::expr(expr.id),\n-                            *expr,\n+                            expr,\n                             &**base_expr,\n                             adjusted_base_ty,\n                             base_adjustment,\n@@ -577,7 +577,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         if let Some((input_ty, return_ty)) = result {\n                             demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n \n-                            let expr_ty = self.fcx.expr_ty(&**expr);\n+                            let expr_ty = self.fcx.expr_ty(&*expr);\n                             demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n                         }\n                     }"}, {"sha": "0c53a16a8118b2a76d746d6f0e749b2aa02c311d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a32010e430006d3850b74976d7d7bf0dda699b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a32010e430006d3850b74976d7d7bf0dda699b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0a32010e430006d3850b74976d7d7bf0dda699b4", "patch": "@@ -102,9 +102,9 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n \n-pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+pub fn lookup_in_trait<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  span: Span,\n-                                 self_expr: Option<&'a ast::Expr>,\n+                                 self_expr: Option<&ast::Expr>,\n                                  m_name: ast::Name,\n                                  trait_def_id: DefId,\n                                  self_ty: Ty<'tcx>,\n@@ -125,9 +125,9 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n /// method-lookup code. In particular, autoderef on index is basically identical to autoderef with\n /// normal probes, except that the test also looks for built-in indexing. Also, the second half of\n /// this method is basically the same as confirmation.\n-pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           span: Span,\n-                                          self_expr: Option<&'a ast::Expr>,\n+                                          self_expr: Option<&ast::Expr>,\n                                           m_name: ast::Name,\n                                           trait_def_id: DefId,\n                                           autoderefref: ty::AutoDerefRef<'tcx>,"}, {"sha": "4ade11a9a83b4fa0e2d1becae34633fca74a7a3d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0a32010e430006d3850b74976d7d7bf0dda699b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a32010e430006d3850b74976d7d7bf0dda699b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0a32010e430006d3850b74976d7d7bf0dda699b4", "patch": "@@ -2263,17 +2263,36 @@ pub enum LvaluePreference {\n /// Executes an autoderef loop for the type `t`. At each step, invokes `should_stop` to decide\n /// whether to terminate the loop. Returns the final type and number of derefs that it performed.\n ///\n+<<<<<<< HEAD\n /// Note: this method does not modify the adjustments table. The caller is responsible for\n /// inserting an AutoAdjustment record into the `fcx` using one of the suitable methods.\n pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  sp: Span,\n+||||||| merged common ancestors\n+/// Note: this method does not modify the adjustments table. The caller is responsible for\n+/// inserting an AutoAdjustment record into the `fcx` using one of the suitable methods.\n+pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+=======\n+/// Note: this method does not modify the adjustments table. The\n+/// caller is responsible for inserting an AutoAdjustment record into\n+/// the `fcx` using one of the suitable methods.  However, if\n+/// `opt_expr` is not `None`, it *will* insert the appropriate method\n+/// entries for the overloaded deref call.\n+pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 sp: Span,\n+>>>>>>> Add comments to autoderef() helper and refactor it to take\n                                  base_ty: Ty<'tcx>,\n-                                 expr_id: Option<ast::NodeId>,\n+                                 opt_expr: Option<&ast::Expr>,\n                                  mut lvalue_pref: LvaluePreference,\n                                  mut should_stop: F)\n-                                 -> (Ty<'tcx>, uint, Option<T>) where\n-    F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n+                                 -> (Ty<'tcx>, uint, Option<T>)\n+    where F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n {\n+    debug!(\"autoderef(base_ty={}, opt_expr={}, lvalue_pref={})\",\n+           base_ty.repr(fcx.tcx()),\n+           opt_expr,\n+           lvalue_pref);\n+\n     let mut t = base_ty;\n     for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n@@ -2291,7 +2310,19 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let mt = match ty::deref(resolved_t, false) {\n             Some(mt) => Some(mt),\n             None => {\n-                let method_call = expr_id.map(|id| MethodCall::autoderef(id, autoderefs));\n+                let method_call = opt_expr.map(|expr| MethodCall::autoderef(expr.id, autoderefs));\n+\n+                // Super subtle: it might seem as though we should\n+                // pass `opt_expr` to `try_overloaded_deref`, so that\n+                // the (implicit) autoref of using an overloaded deref\n+                // would get added to the adjustment table. However we\n+                // do not do that, because it's kind of a\n+                // \"meta-adjustment\" -- instead, we just leave it\n+                // unrecorded and know that there \"will be\" an\n+                // autoref. regionck and other bits of the code base,\n+                // when they encounter an overloaded autoderef, have\n+                // to do some reconstructive surgery. This is a pretty\n+                // complex mess that is begging for a proper MIR.\n                 try_overloaded_deref(fcx, sp, method_call, None, resolved_t, lvalue_pref)\n             }\n         };\n@@ -2324,7 +2355,7 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+            method::lookup_in_trait(fcx, span, base_expr,\n                                     token::intern(\"deref_mut\"), trait_did,\n                                     base_ty, None)\n         }\n@@ -2334,7 +2365,7 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Otherwise, fall back to Deref.\n     let method = match (method, fcx.tcx().lang_items.deref_trait()) {\n         (None, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+            method::lookup_in_trait(fcx, span, base_expr,\n                                     token::intern(\"deref\"), trait_did,\n                                     base_ty, None)\n         }\n@@ -2390,7 +2421,7 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // consolidated.\n \n     let (ty, autoderefs, final_mt) =\n-        autoderef(fcx, base_expr.span, base_ty, Some(base_expr.id), lvalue_pref, |adj_ty, idx| {\n+        autoderef(fcx, base_expr.span, base_ty, Some(base_expr), lvalue_pref, |adj_ty, idx| {\n             let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n             step(adj_ty, autoderefref)\n         });\n@@ -3360,7 +3391,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 fcx.expr_ty(base));\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n+            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n@@ -3421,7 +3452,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let mut tuple_like = false;\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n+            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);"}, {"sha": "c74612d3aa836df63df9071f5c903ef4522bd42d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a32010e430006d3850b74976d7d7bf0dda699b4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a32010e430006d3850b74976d7d7bf0dda699b4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0a32010e430006d3850b74976d7d7bf0dda699b4", "patch": "@@ -1049,13 +1049,16 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n /// resulting pointer is linked to the lifetime of its guarantor (if any).\n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n-               mutability: ast::Mutability, base: &ast::Expr) {\n-    debug!(\"link_addr_of(base=?)\");\n+                mutability: ast::Mutability, base: &ast::Expr) {\n+    debug!(\"link_addr_of(expr={}, base={})\", expr.repr(rcx.tcx()), base.repr(rcx.tcx()));\n \n     let cmt = {\n         let mc = mc::MemCategorizationContext::new(rcx.fcx);\n         ignore_err!(mc.cat_expr(base))\n     };\n+\n+    debug!(\"link_addr_of: cmt={}\", cmt.repr(rcx.tcx()));\n+\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n \n@@ -1182,6 +1185,9 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                         id: ast::NodeId,\n                                         mutbl: ast::Mutability,\n                                         cmt_borrowed: mc::cmt<'tcx>) {\n+    debug!(\"link_region_from_node_type(id={}, mutbl={}, cmt_borrowed={})\",\n+           id, mutbl, cmt_borrowed.repr(rcx.tcx()));\n+\n     let rptr_ty = rcx.resolve_node_type(id);\n     if !ty::type_is_error(rptr_ty) {\n         let tcx = rcx.fcx.ccx.tcx;"}]}