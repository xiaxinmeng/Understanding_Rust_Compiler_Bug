{"sha": "4bd98443ed368a781812545915cf758e2091128d", "node_id": "C_kwDOAAsO6NoAKDRiZDk4NDQzZWQzNjhhNzgxODEyNTQ1OTE1Y2Y3NThlMjA5MTEyOGQ", "commit": {"author": {"name": "ouz-a", "email": "oguz.agcayazi@gmail.com", "date": "2022-10-16T18:30:32Z"}, "committer": {"name": "ouz-a", "email": "oguz.agcayazi@gmail.com", "date": "2022-10-23T15:47:16Z"}, "message": "remove misc_cast and validate types", "tree": {"sha": "02e6c43265b55326cb6ef95097f0607cfa5365d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02e6c43265b55326cb6ef95097f0607cfa5365d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bd98443ed368a781812545915cf758e2091128d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd98443ed368a781812545915cf758e2091128d", "html_url": "https://github.com/rust-lang/rust/commit/4bd98443ed368a781812545915cf758e2091128d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bd98443ed368a781812545915cf758e2091128d/comments", "author": {"login": "ouz-a", "id": 90461915, "node_id": "MDQ6VXNlcjkwNDYxOTE1", "avatar_url": "https://avatars.githubusercontent.com/u/90461915?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ouz-a", "html_url": "https://github.com/ouz-a", "followers_url": "https://api.github.com/users/ouz-a/followers", "following_url": "https://api.github.com/users/ouz-a/following{/other_user}", "gists_url": "https://api.github.com/users/ouz-a/gists{/gist_id}", "starred_url": "https://api.github.com/users/ouz-a/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ouz-a/subscriptions", "organizations_url": "https://api.github.com/users/ouz-a/orgs", "repos_url": "https://api.github.com/users/ouz-a/repos", "events_url": "https://api.github.com/users/ouz-a/events{/privacy}", "received_events_url": "https://api.github.com/users/ouz-a/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ouz-a", "id": 90461915, "node_id": "MDQ6VXNlcjkwNDYxOTE1", "avatar_url": "https://avatars.githubusercontent.com/u/90461915?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ouz-a", "html_url": "https://github.com/ouz-a", "followers_url": "https://api.github.com/users/ouz-a/followers", "following_url": "https://api.github.com/users/ouz-a/following{/other_user}", "gists_url": "https://api.github.com/users/ouz-a/gists{/gist_id}", "starred_url": "https://api.github.com/users/ouz-a/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ouz-a/subscriptions", "organizations_url": "https://api.github.com/users/ouz-a/orgs", "repos_url": "https://api.github.com/users/ouz-a/repos", "events_url": "https://api.github.com/users/ouz-a/events{/privacy}", "received_events_url": "https://api.github.com/users/ouz-a/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d59c7ff000db581bd03c2da79046af431678fab8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d59c7ff000db581bd03c2da79046af431678fab8", "html_url": "https://github.com/rust-lang/rust/commit/d59c7ff000db581bd03c2da79046af431678fab8"}], "stats": {"total": 94, "additions": 66, "deletions": 28}, "files": [{"sha": "f980e606b932d2ae4640b6b03d4faa6741e08259", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4bd98443ed368a781812545915cf758e2091128d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd98443ed368a781812545915cf758e2091128d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=4bd98443ed368a781812545915cf758e2091128d", "patch": "@@ -42,10 +42,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let res = self.pointer_from_exposed_address_cast(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n-            // FIXME: We shouldn't use `misc_cast` for these but handle them separately.\n-            IntToInt | FloatToInt | FloatToFloat | IntToFloat | FnPtrToPtr | PtrToPtr => {\n+\n+            IntToInt | IntToFloat => {\n                 let src = self.read_immediate(src)?;\n-                let res = self.misc_cast(&src, cast_ty)?;\n+                let res = self.int_to_int_or_float(&src, cast_ty)?;\n+                self.write_immediate(res, dest)?;\n+            }\n+\n+            FloatToFloat | FloatToInt => {\n+                let src = self.read_immediate(src)?;\n+                let res = self.float_to_float_or_int(&src, cast_ty)?;\n+                self.write_immediate(res, dest)?;\n+            }\n+\n+            FnPtrToPtr | PtrToPtr => {\n+                let src = self.read_immediate(&src)?;\n+                let res = self.ptr_to_ptr(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n \n@@ -126,13 +138,27 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn misc_cast(\n+    pub fn int_to_int_or_float(\n+        &mut self,\n+        src: &ImmTy<'tcx, M::Provenance>,\n+        cast_ty: Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n+        if (src.layout.ty.is_integral() || src.layout.ty.is_char() || src.layout.ty.is_bool())\n+            && (cast_ty.is_floating_point() || cast_ty.is_integral() || cast_ty.is_char())\n+        {\n+            let scalar = src.to_scalar();\n+            Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n+        } else {\n+            bug!(\"Unexpected cast from type {:?}\", src.layout.ty)\n+        }\n+    }\n+\n+    pub fn float_to_float_or_int(\n         &mut self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         use rustc_type_ir::sty::TyKind::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n         match src.layout.ty.kind() {\n             // Floating point\n@@ -142,19 +168,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Float(FloatTy::F64) => {\n                 return Ok(self.cast_from_float(src.to_scalar().to_f64()?, cast_ty).into());\n             }\n-            // The rest is integer/pointer-\"like\", including fn ptr casts\n-            _ => assert!(\n-                src.layout.ty.is_bool()\n-                    || src.layout.ty.is_char()\n-                    || src.layout.ty.is_integral()\n-                    || src.layout.ty.is_any_ptr(),\n-                \"Unexpected cast from type {:?}\",\n-                src.layout.ty\n-            ),\n+            _ => {\n+                bug!(\"Can't cast 'Float' type into {:?}\", cast_ty);\n+            }\n         }\n+    }\n \n-        // # First handle non-scalar source values.\n-\n+    /// Handles 'FnPtrToPtr' and 'PtrToPtr' casts.\n+    pub fn ptr_to_ptr(\n+        &mut self,\n+        src: &ImmTy<'tcx, M::Provenance>,\n+        cast_ty: Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n         if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n             let dest_layout = self.layout_of(cast_ty)?;\n@@ -178,11 +203,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n                 };\n             }\n+        } else {\n+            bug!(\"Can't cast 'Ptr' or 'FnPtr' into {:?}\", cast_ty);\n         }\n-\n-        // # The remaining source values are scalar and \"int-like\".\n-        let scalar = src.to_scalar();\n-        Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n     }\n \n     pub fn pointer_expose_address_cast("}, {"sha": "40946344a35d13994376a60425d87f4e33fe7d12", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4bd98443ed368a781812545915cf758e2091128d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd98443ed368a781812545915cf758e2091128d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=4bd98443ed368a781812545915cf758e2091128d", "patch": "@@ -556,21 +556,36 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 check_kinds!(a, \"Cannot shallow init type {:?}\", ty::RawPtr(..));\n             }\n             Rvalue::Cast(kind, operand, target_type) => {\n+                let op_ty = operand.ty(self.body, self.tcx);\n                 match kind {\n                     CastKind::DynStar => {\n                         // FIXME(dyn-star): make sure nothing needs to be done here.\n                     }\n-                    // Nothing to check here\n+                    // FIXME: Add Checks for these\n                     CastKind::PointerFromExposedAddress\n                     | CastKind::PointerExposeAddress\n                     | CastKind::Pointer(_) => {}\n-                    _ => {\n-                        let op_ty = operand.ty(self.body, self.tcx);\n-                        if op_ty.is_enum() {\n+                    CastKind::IntToInt | CastKind::IntToFloat => {\n+                        let input_valid = op_ty.is_integral() || op_ty.is_char() || op_ty.is_bool();\n+                        let target_valid = target_type.is_numeric() || target_type.is_char();\n+                        if !input_valid || !target_valid {\n+                            self.fail(\n+                                location,\n+                                format!(\"Wrong cast kind {kind:?} for the type {op_ty}\",),\n+                            );\n+                        }\n+                    }\n+                    CastKind::FnPtrToPtr | CastKind::PtrToPtr => {\n+                        if !(op_ty.is_any_ptr() && target_type.is_unsafe_ptr()) {\n+                            self.fail(location, \"Can't cast {op_ty} into 'Ptr'\");\n+                        }\n+                    }\n+                    CastKind::FloatToFloat | CastKind::FloatToInt => {\n+                        if !op_ty.is_floating_point() || !target_type.is_numeric() {\n                             self.fail(\n                                 location,\n                                 format!(\n-                                    \"enum -> int casts should go through `Rvalue::Discriminant`: {operand:?}:{op_ty} as {target_type}\",\n+                                    \"Trying to cast non 'Float' as {kind:?} into {target_type:?}\"\n                                 ),\n                             );\n                         }"}, {"sha": "c1b949b1f79931de0095d18c8068cc0ec23c64e9", "filename": "src/tools/miri/src/shims/intrinsics/simd.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bd98443ed368a781812545915cf758e2091128d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd98443ed368a781812545915cf758e2091128d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs?ref=4bd98443ed368a781812545915cf758e2091128d", "patch": "@@ -437,13 +437,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     let val = match (op.layout.ty.kind(), dest.layout.ty.kind()) {\n                         // Int-to-(int|float): always safe\n                         (ty::Int(_) | ty::Uint(_), ty::Int(_) | ty::Uint(_) | ty::Float(_)) =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n+                            this.int_to_int_or_float(&op, dest.layout.ty)?,\n                         // Float-to-float: always safe\n                         (ty::Float(_), ty::Float(_)) =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n+                            this.float_to_float_or_int(&op, dest.layout.ty)?,\n                         // Float-to-int in safe mode\n                         (ty::Float(_), ty::Int(_) | ty::Uint(_)) if safe_cast =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n+                            this.float_to_float_or_int(&op, dest.layout.ty)?,\n                         // Float-to-int in unchecked mode\n                         (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n                             this.float_to_int_unchecked(op.to_scalar().to_f32()?, dest.layout.ty)?.into(),"}]}