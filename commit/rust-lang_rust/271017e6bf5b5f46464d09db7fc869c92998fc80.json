{"sha": "271017e6bf5b5f46464d09db7fc869c92998fc80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MTAxN2U2YmY1YjVmNDY0NjRkMDlkYjdmYzg2OWM5Mjk5OGZjODA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-06T15:23:28Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-06T15:23:28Z"}, "message": "Move NameKind up", "tree": {"sha": "76227de73a33f3dd51d74d6736cf425a8a89bb64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76227de73a33f3dd51d74d6736cf425a8a89bb64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/271017e6bf5b5f46464d09db7fc869c92998fc80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/271017e6bf5b5f46464d09db7fc869c92998fc80", "html_url": "https://github.com/rust-lang/rust/commit/271017e6bf5b5f46464d09db7fc869c92998fc80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/271017e6bf5b5f46464d09db7fc869c92998fc80/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8dde21fe9ccceea0b3dea83d646a45a409a0e3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8dde21fe9ccceea0b3dea83d646a45a409a0e3f", "html_url": "https://github.com/rust-lang/rust/commit/f8dde21fe9ccceea0b3dea83d646a45a409a0e3f"}], "stats": {"total": 505, "additions": 252, "deletions": 253}, "files": [{"sha": "0dca0c86c2b00555d05bd1ff9ec70cf1c8b29840", "filename": "crates/ra_ide/src/imports_locator.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fimports_locator.rs?ref=271017e6bf5b5f46464d09db7fc869c92998fc80", "patch": "@@ -4,16 +4,14 @@\n use hir::{db::HirDatabase, ModuleDef, SourceBinder};\n use ra_assists::ImportsLocator;\n use ra_ide_db::{\n+    defs::NameKind,\n     symbol_index::{self, FileSymbol},\n     RootDatabase,\n };\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, SyntaxKind::NAME};\n \n-use crate::{\n-    references::{classify_name, NameKind},\n-    Query,\n-};\n+use crate::{references::classify_name, Query};\n \n pub(crate) struct ImportsLocatorIde<'a> {\n     source_binder: SourceBinder<'a, RootDatabase>,"}, {"sha": "c215040f4711873f77587f0c64a2ca997e7f115e", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=271017e6bf5b5f46464d09db7fc869c92998fc80", "patch": "@@ -10,7 +10,6 @@\n //! resolved to the search element definition, we get a reference.\n \n mod classify;\n-mod name_definition;\n mod rename;\n mod search_scope;\n \n@@ -29,9 +28,9 @@ use crate::{display::ToNav, FilePosition, FileRange, NavigationTarget, RangeInfo\n \n pub(crate) use self::{\n     classify::{classify_name, classify_name_ref},\n-    name_definition::{NameDefinition, NameKind},\n     rename::rename,\n };\n+pub(crate) use ra_ide_db::defs::{NameDefinition, NameKind};\n \n pub use self::search_scope::SearchScope;\n \n@@ -137,7 +136,7 @@ pub(crate) fn find_all_refs(\n     };\n \n     let search_scope = {\n-        let base = def.search_scope(db);\n+        let base = SearchScope::for_def(&def, db);\n         match search_scope {\n             None => base,\n             Some(scope) => base.intersection(&scope),"}, {"sha": "0326fd379eed523281a67253b7251681206ddd42", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 3, "deletions": 109, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=271017e6bf5b5f46464d09db7fc869c92998fc80", "patch": "@@ -2,119 +2,13 @@\n \n use hir::{InFile, PathResolution, SourceBinder};\n use ra_prof::profile;\n-use ra_syntax::{ast, match_ast, AstNode};\n+use ra_syntax::{ast, AstNode};\n use test_utils::tested_by;\n \n-use super::{\n-    name_definition::{from_assoc_item, from_module_def, from_struct_field},\n-    NameDefinition, NameKind,\n-};\n+use super::{NameDefinition, NameKind};\n use ra_ide_db::RootDatabase;\n \n-pub(crate) fn classify_name(\n-    sb: &mut SourceBinder<RootDatabase>,\n-    name: InFile<&ast::Name>,\n-) -> Option<NameDefinition> {\n-    let _p = profile(\"classify_name\");\n-    let parent = name.value.syntax().parent()?;\n-\n-    match_ast! {\n-        match parent {\n-            ast::BindPat(it) => {\n-                let src = name.with_value(it);\n-                let local = sb.to_def(src)?;\n-                Some(NameDefinition {\n-                    visibility: None,\n-                    container: local.module(sb.db),\n-                    kind: NameKind::Local(local),\n-                })\n-            },\n-            ast::RecordFieldDef(it) => {\n-                let src = name.with_value(it);\n-                let field: hir::StructField = sb.to_def(src)?;\n-                Some(from_struct_field(sb.db, field))\n-            },\n-            ast::Module(it) => {\n-                let def = sb.to_def(name.with_value(it))?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::StructDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Struct = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::EnumDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Enum = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::TraitDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Trait = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::StaticDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Static = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::EnumVariant(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::EnumVariant = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::FnDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Function = sb.to_def(src)?;\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(sb.db, def.into()))\n-                } else {\n-                    Some(from_module_def(sb.db, def.into(), None))\n-                }\n-            },\n-            ast::ConstDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Const = sb.to_def(src)?;\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(sb.db, def.into()))\n-                } else {\n-                    Some(from_module_def(sb.db, def.into(), None))\n-                }\n-            },\n-            ast::TypeAliasDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::TypeAlias = sb.to_def(src)?;\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(sb.db, def.into()))\n-                } else {\n-                    Some(from_module_def(sb.db, def.into(), None))\n-                }\n-            },\n-            ast::MacroCall(it) => {\n-                let src = name.with_value(it);\n-                let def = sb.to_def(src.clone())?;\n-\n-                let module = sb.to_module_def(src.file_id.original_file(sb.db))?;\n-\n-                Some(NameDefinition {\n-                    visibility: None,\n-                    container: module,\n-                    kind: NameKind::Macro(def),\n-                })\n-            },\n-            ast::TypeParam(it) => {\n-                let src = name.with_value(it);\n-                let def = sb.to_def(src)?;\n-                Some(NameDefinition {\n-                    visibility: None,\n-                    container: def.module(sb.db),\n-                    kind: NameKind::TypeParam(def),\n-                })\n-            },\n-            _ => None,\n-        }\n-    }\n-}\n+pub use ra_ide_db::defs::{classify_name, from_assoc_item, from_module_def, from_struct_field};\n \n pub(crate) fn classify_name_ref(\n     sb: &mut SourceBinder<RootDatabase>,"}, {"sha": "71565e6d395d8031a1ca60ea9e6c855886eff28d", "filename": "crates/ra_ide/src/references/name_definition.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f8dde21fe9ccceea0b3dea83d646a45a409a0e3f/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8dde21fe9ccceea0b3dea83d646a45a409a0e3f/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs?ref=f8dde21fe9ccceea0b3dea83d646a45a409a0e3f", "patch": "@@ -1,85 +0,0 @@\n-//! `NameDefinition` keeps information about the element we want to search references for.\n-//! The element is represented by `NameKind`. It's located inside some `container` and\n-//! has a `visibility`, which defines a search scope.\n-//! Note that the reference search is possible for not all of the classified items.\n-\n-use hir::{\n-    Adt, AssocItem, HasSource, ImplBlock, Local, MacroDef, Module, ModuleDef, StructField,\n-    TypeParam, VariantDef,\n-};\n-use ra_syntax::{ast, ast::VisibilityOwner};\n-\n-use ra_ide_db::RootDatabase;\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub enum NameKind {\n-    Macro(MacroDef),\n-    Field(StructField),\n-    AssocItem(AssocItem),\n-    Def(ModuleDef),\n-    SelfType(ImplBlock),\n-    Local(Local),\n-    TypeParam(TypeParam),\n-}\n-\n-#[derive(PartialEq, Eq)]\n-pub(crate) struct NameDefinition {\n-    pub visibility: Option<ast::Visibility>,\n-    /// FIXME: this doesn't really make sense. For example, builtin types don't\n-    /// really have a module.\n-    pub container: Module,\n-    pub kind: NameKind,\n-}\n-\n-pub(super) fn from_assoc_item(db: &RootDatabase, item: AssocItem) -> NameDefinition {\n-    let container = item.module(db);\n-    let visibility = match item {\n-        AssocItem::Function(f) => f.source(db).value.visibility(),\n-        AssocItem::Const(c) => c.source(db).value.visibility(),\n-        AssocItem::TypeAlias(a) => a.source(db).value.visibility(),\n-    };\n-    let kind = NameKind::AssocItem(item);\n-    NameDefinition { kind, container, visibility }\n-}\n-\n-pub(super) fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n-    let kind = NameKind::Field(field);\n-    let parent = field.parent_def(db);\n-    let container = parent.module(db);\n-    let visibility = match parent {\n-        VariantDef::Struct(s) => s.source(db).value.visibility(),\n-        VariantDef::Union(e) => e.source(db).value.visibility(),\n-        VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n-    };\n-    NameDefinition { kind, container, visibility }\n-}\n-\n-pub(super) fn from_module_def(\n-    db: &RootDatabase,\n-    def: ModuleDef,\n-    module: Option<Module>,\n-) -> NameDefinition {\n-    let kind = NameKind::Def(def);\n-    let (container, visibility) = match def {\n-        ModuleDef::Module(it) => {\n-            let container = it.parent(db).or_else(|| Some(it)).unwrap();\n-            let visibility = it.declaration_source(db).and_then(|s| s.value.visibility());\n-            (container, visibility)\n-        }\n-        ModuleDef::EnumVariant(it) => {\n-            let container = it.module(db);\n-            let visibility = it.source(db).value.parent_enum().visibility();\n-            (container, visibility)\n-        }\n-        ModuleDef::Function(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Const(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Static(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Trait(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::BuiltinType(..) => (module.unwrap(), None),\n-    };\n-    NameDefinition { kind, container, visibility }\n-}"}, {"sha": "279f57be06a1c6f884032f80b60465eba16ec7c1", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=271017e6bf5b5f46464d09db7fc869c92998fc80", "patch": "@@ -19,59 +19,13 @@ pub struct SearchScope {\n }\n \n impl SearchScope {\n-    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n-        SearchScope { entries }\n-    }\n-    pub fn single_file(file: FileId) -> SearchScope {\n-        SearchScope::new(std::iter::once((file, None)).collect())\n-    }\n-    pub(crate) fn intersection(&self, other: &SearchScope) -> SearchScope {\n-        let (mut small, mut large) = (&self.entries, &other.entries);\n-        if small.len() > large.len() {\n-            mem::swap(&mut small, &mut large)\n-        }\n-\n-        let res = small\n-            .iter()\n-            .filter_map(|(file_id, r1)| {\n-                let r2 = large.get(file_id)?;\n-                let r = intersect_ranges(*r1, *r2)?;\n-                Some((*file_id, r))\n-            })\n-            .collect();\n-        return SearchScope::new(res);\n-\n-        fn intersect_ranges(\n-            r1: Option<TextRange>,\n-            r2: Option<TextRange>,\n-        ) -> Option<Option<TextRange>> {\n-            match (r1, r2) {\n-                (None, r) | (r, None) => Some(r),\n-                (Some(r1), Some(r2)) => {\n-                    let r = r1.intersection(&r2)?;\n-                    Some(Some(r))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl IntoIterator for SearchScope {\n-    type Item = (FileId, Option<TextRange>);\n-    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.entries.into_iter()\n-    }\n-}\n-\n-impl NameDefinition {\n-    pub(crate) fn search_scope(&self, db: &RootDatabase) -> SearchScope {\n+    pub(crate) fn for_def(def: &NameDefinition, db: &RootDatabase) -> SearchScope {\n         let _p = profile(\"search_scope\");\n \n-        let module_src = self.container.definition_source(db);\n+        let module_src = def.container.definition_source(db);\n         let file_id = module_src.file_id.original_file(db);\n \n-        if let NameKind::Local(var) = self.kind {\n+        if let NameKind::Local(var) = def.kind {\n             let range = match var.parent(db) {\n                 DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n                 DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),\n@@ -82,10 +36,10 @@ impl NameDefinition {\n             return SearchScope::new(res);\n         }\n \n-        let vis = self.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n+        let vis = def.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n \n         if vis.as_str() == \"pub(super)\" {\n-            if let Some(parent_module) = self.container.parent(db) {\n+            if let Some(parent_module) = def.container.parent(db) {\n                 let mut res = FxHashMap::default();\n                 let parent_src = parent_module.definition_source(db);\n                 let file_id = parent_src.file_id.original_file(db);\n@@ -118,7 +72,7 @@ impl NameDefinition {\n                 return SearchScope::new(res);\n             }\n             if vis.as_str() == \"pub\" {\n-                let krate = self.container.krate();\n+                let krate = def.container.krate();\n                 for rev_dep in krate.reverse_dependencies(db) {\n                     let root_file = rev_dep.root_file(db);\n                     let source_root_id = db.file_source_root(root_file);\n@@ -137,4 +91,48 @@ impl NameDefinition {\n         res.insert(file_id, range);\n         SearchScope::new(res)\n     }\n+\n+    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n+        SearchScope { entries }\n+    }\n+    pub fn single_file(file: FileId) -> SearchScope {\n+        SearchScope::new(std::iter::once((file, None)).collect())\n+    }\n+    pub(crate) fn intersection(&self, other: &SearchScope) -> SearchScope {\n+        let (mut small, mut large) = (&self.entries, &other.entries);\n+        if small.len() > large.len() {\n+            mem::swap(&mut small, &mut large)\n+        }\n+\n+        let res = small\n+            .iter()\n+            .filter_map(|(file_id, r1)| {\n+                let r2 = large.get(file_id)?;\n+                let r = intersect_ranges(*r1, *r2)?;\n+                Some((*file_id, r))\n+            })\n+            .collect();\n+        return SearchScope::new(res);\n+\n+        fn intersect_ranges(\n+            r1: Option<TextRange>,\n+            r2: Option<TextRange>,\n+        ) -> Option<Option<TextRange>> {\n+            match (r1, r2) {\n+                (None, r) | (r, None) => Some(r),\n+                (Some(r1), Some(r2)) => {\n+                    let r = r1.intersection(&r2)?;\n+                    Some(Some(r))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl IntoIterator for SearchScope {\n+    type Item = (FileId, Option<TextRange>);\n+    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.entries.into_iter()\n+    }\n }"}, {"sha": "1c983fb604e3b9e400e17eab81278f015f2c80ee", "filename": "crates/ra_ide_db/src/defs.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=271017e6bf5b5f46464d09db7fc869c92998fc80", "patch": "@@ -0,0 +1,194 @@\n+//! `NameDefinition` keeps information about the element we want to search references for.\n+//! The element is represented by `NameKind`. It's located inside some `container` and\n+//! has a `visibility`, which defines a search scope.\n+//! Note that the reference search is possible for not all of the classified items.\n+\n+use hir::{\n+    Adt, AssocItem, HasSource, ImplBlock, InFile, Local, MacroDef, Module, ModuleDef, SourceBinder,\n+    StructField, TypeParam, VariantDef,\n+};\n+use ra_prof::profile;\n+use ra_syntax::{\n+    ast::{self, AstNode, VisibilityOwner},\n+    match_ast,\n+};\n+\n+use crate::RootDatabase;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum NameKind {\n+    Macro(MacroDef),\n+    Field(StructField),\n+    AssocItem(AssocItem),\n+    Def(ModuleDef),\n+    SelfType(ImplBlock),\n+    Local(Local),\n+    TypeParam(TypeParam),\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub struct NameDefinition {\n+    pub visibility: Option<ast::Visibility>,\n+    /// FIXME: this doesn't really make sense. For example, builtin types don't\n+    /// really have a module.\n+    pub container: Module,\n+    pub kind: NameKind,\n+}\n+\n+pub fn classify_name(\n+    sb: &mut SourceBinder<RootDatabase>,\n+    name: InFile<&ast::Name>,\n+) -> Option<NameDefinition> {\n+    let _p = profile(\"classify_name\");\n+    let parent = name.value.syntax().parent()?;\n+\n+    match_ast! {\n+        match parent {\n+            ast::BindPat(it) => {\n+                let src = name.with_value(it);\n+                let local = sb.to_def(src)?;\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: local.module(sb.db),\n+                    kind: NameKind::Local(local),\n+                })\n+            },\n+            ast::RecordFieldDef(it) => {\n+                let src = name.with_value(it);\n+                let field: hir::StructField = sb.to_def(src)?;\n+                Some(from_struct_field(sb.db, field))\n+            },\n+            ast::Module(it) => {\n+                let def = sb.to_def(name.with_value(it))?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::StructDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Struct = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::EnumDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Enum = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::TraitDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Trait = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::StaticDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Static = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::EnumVariant(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::EnumVariant = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::FnDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Function = sb.to_def(src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(sb.db, def.into()))\n+                } else {\n+                    Some(from_module_def(sb.db, def.into(), None))\n+                }\n+            },\n+            ast::ConstDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Const = sb.to_def(src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(sb.db, def.into()))\n+                } else {\n+                    Some(from_module_def(sb.db, def.into(), None))\n+                }\n+            },\n+            ast::TypeAliasDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::TypeAlias = sb.to_def(src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(sb.db, def.into()))\n+                } else {\n+                    Some(from_module_def(sb.db, def.into(), None))\n+                }\n+            },\n+            ast::MacroCall(it) => {\n+                let src = name.with_value(it);\n+                let def = sb.to_def(src.clone())?;\n+\n+                let module = sb.to_module_def(src.file_id.original_file(sb.db))?;\n+\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: module,\n+                    kind: NameKind::Macro(def),\n+                })\n+            },\n+            ast::TypeParam(it) => {\n+                let src = name.with_value(it);\n+                let def = sb.to_def(src)?;\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: def.module(sb.db),\n+                    kind: NameKind::TypeParam(def),\n+                })\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub fn from_assoc_item(db: &RootDatabase, item: AssocItem) -> NameDefinition {\n+    let container = item.module(db);\n+    let visibility = match item {\n+        AssocItem::Function(f) => f.source(db).value.visibility(),\n+        AssocItem::Const(c) => c.source(db).value.visibility(),\n+        AssocItem::TypeAlias(a) => a.source(db).value.visibility(),\n+    };\n+    let kind = NameKind::AssocItem(item);\n+    NameDefinition { kind, container, visibility }\n+}\n+\n+pub fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n+    let kind = NameKind::Field(field);\n+    let parent = field.parent_def(db);\n+    let container = parent.module(db);\n+    let visibility = match parent {\n+        VariantDef::Struct(s) => s.source(db).value.visibility(),\n+        VariantDef::Union(e) => e.source(db).value.visibility(),\n+        VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n+    };\n+    NameDefinition { kind, container, visibility }\n+}\n+\n+pub fn from_module_def(\n+    db: &RootDatabase,\n+    def: ModuleDef,\n+    module: Option<Module>,\n+) -> NameDefinition {\n+    let kind = NameKind::Def(def);\n+    let (container, visibility) = match def {\n+        ModuleDef::Module(it) => {\n+            let container = it.parent(db).or_else(|| Some(it)).unwrap();\n+            let visibility = it.declaration_source(db).and_then(|s| s.value.visibility());\n+            (container, visibility)\n+        }\n+        ModuleDef::EnumVariant(it) => {\n+            let container = it.module(db);\n+            let visibility = it.source(db).value.parent_enum().visibility();\n+            (container, visibility)\n+        }\n+        ModuleDef::Function(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Const(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Static(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Trait(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::BuiltinType(..) => (module.unwrap(), None),\n+    };\n+    NameDefinition { kind, container, visibility }\n+}"}, {"sha": "0715dfc66bfd1981dd06e1b5990d85880e1cc878", "filename": "crates/ra_ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/271017e6bf5b5f46464d09db7fc869c92998fc80/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=271017e6bf5b5f46464d09db7fc869c92998fc80", "patch": "@@ -7,6 +7,7 @@ pub mod line_index_utils;\n pub mod feature_flags;\n pub mod symbol_index;\n pub mod change;\n+pub mod defs;\n mod wasm_shims;\n \n use std::sync::Arc;"}]}