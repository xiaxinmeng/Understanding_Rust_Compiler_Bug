{"sha": "a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MDI2YzdmMTlkMDQxOGM4YzBkNGQ0MDE2NDBiZGQxNWIyZTFkN2U=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-25T09:49:21Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:41:58Z"}, "message": "Memoize trans::adt::represent_type", "tree": {"sha": "bb71a6b04a6f1b0dde03fc6af6de6f1f538175af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb71a6b04a6f1b0dde03fc6af6de6f1f538175af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "html_url": "https://github.com/rust-lang/rust/commit/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8237a46f134fa00d24ef1874abc0a4b45640cbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8237a46f134fa00d24ef1874abc0a4b45640cbf", "html_url": "https://github.com/rust-lang/rust/commit/a8237a46f134fa00d24ef1874abc0a4b45640cbf"}], "stats": {"total": 106, "additions": 58, "deletions": 48}, "files": [{"sha": "96afc83904d44f55761e13d1e93a4f39211d1489", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "patch": "@@ -192,7 +192,7 @@ pub enum Lit {\n // range)\n pub enum Opt {\n     lit(Lit),\n-    var(/* disr val */int, adt::Repr),\n+    var(/* disr val */int, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n     vec_len_ge(uint)\n@@ -268,7 +268,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n             let llval = consts::get_const_val(bcx.ccx(), lit_id);\n             return single_result(rslt(bcx, llval));\n         }\n-        var(disr_val, ref repr) => {\n+        var(disr_val, repr) => {\n             return adt::trans_case(bcx, repr, disr_val);\n         }\n         range(l1, l2) => {\n@@ -1274,7 +1274,7 @@ pub fn compile_submatch(bcx: block,\n         do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n             let rec_vals = rec_fields.map(|field_name| {\n                 let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n-                adt::trans_GEP(bcx, &pat_repr, val, discr, ix)\n+                adt::trans_GEP(bcx, pat_repr, val, discr, ix)\n             });\n             compile_submatch(\n                 bcx,\n@@ -1293,7 +1293,7 @@ pub fn compile_submatch(bcx: block,\n           _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n         };\n         let tup_vals = do vec::from_fn(n_tup_elts) |i| {\n-            adt::trans_GEP(bcx, &tup_repr, val, 0, i)\n+            adt::trans_GEP(bcx, tup_repr, val, 0, i)\n         };\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n                          vec::append(tup_vals, vals_left), chk);\n@@ -1315,7 +1315,7 @@ pub fn compile_submatch(bcx: block,\n \n         let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n         let llstructvals = do vec::from_fn(struct_element_count) |i| {\n-            adt::trans_GEP(bcx, &struct_repr, val, 0, i)\n+            adt::trans_GEP(bcx, struct_repr, val, 0, i)\n         };\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n@@ -1359,7 +1359,7 @@ pub fn compile_submatch(bcx: block,\n     let mut test_val = val;\n     if opts.len() > 0u {\n         match opts[0] {\n-            var(_, ref repr) => {\n+            var(_, repr) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n                 kind = the_kind;\n                 for val_opt.each |&tval| { test_val = tval; }\n@@ -1511,7 +1511,7 @@ pub fn compile_submatch(bcx: block,\n         let mut size = 0u;\n         let mut unpacked = ~[];\n         match *opt {\n-            var(disr_val, ref repr) => {\n+            var(disr_val, repr) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n                     extract_variant_args(opt_cx, repr, disr_val, val);\n                 size = argvals.len();\n@@ -1731,7 +1731,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                                                          enum_id,\n                                                          var_id);\n                     let args = extract_variant_args(bcx,\n-                                                    &repr,\n+                                                    repr,\n                                                     vinfo.disr_val,\n                                                     val);\n                     for sub_pats.each |sub_pat| {\n@@ -1753,7 +1753,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             // This is the tuple struct case.\n                             let repr = adt::represent_node(bcx, pat.id);\n                             for vec::eachi(elems) |i, elem| {\n-                                let fldptr = adt::trans_GEP(bcx, &repr,\n+                                let fldptr = adt::trans_GEP(bcx, repr,\n                                                             val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx,\n                                                            *elem,\n@@ -1776,7 +1776,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n                 for vec::each(fields) |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n-                    let fldptr = adt::trans_GEP(bcx, &pat_repr, val,\n+                    let fldptr = adt::trans_GEP(bcx, pat_repr, val,\n                                                 discr, ix);\n                     bcx = bind_irrefutable_pat(bcx,\n                                                f.pat,\n@@ -1789,7 +1789,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n         ast::pat_tup(elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for vec::eachi(elems) |i, elem| {\n-                let fldptr = adt::trans_GEP(bcx, &repr, val, 0, i);\n+                let fldptr = adt::trans_GEP(bcx, repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx,\n                                            *elem,\n                                            fldptr,"}, {"sha": "00c620c7c8fd893c30e5b14219866bea59234b8a", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::container::Map;\n use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n use core::vec;\n@@ -43,15 +44,17 @@ struct Struct {\n }\n \n \n-pub fn represent_node(bcx: block, node: ast::node_id)\n-    -> Repr {\n+pub fn represent_node(bcx: block, node: ast::node_id) -> @Repr {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n-pub fn represent_type(cx: @CrateContext, t: ty::t) -> Repr {\n+pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n     debug!(\"Representing: %s\", ty_to_str(cx.tcx, t));\n-    // XXX: cache this\n-    match ty::get(t).sty {\n+    match cx.adt_reprs.find(&t) {\n+        Some(repr) => return *repr,\n+        None => { }\n+    }\n+    let repr = @match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n             Univariant(mk_struct(cx, *elems), NoDtor)\n         }\n@@ -97,7 +100,9 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> Repr {\n             }\n         }\n         _ => cx.sess.bug(~\"adt::represent_type called on non-ADT type\")\n-    }\n+    };\n+    cx.adt_reprs.insert(t, repr);\n+    return repr;\n }\n \n fn mk_struct(cx: @CrateContext, tys: &[ty::t]) -> Struct {"}, {"sha": "ae1441731e0f34f067c0fbc873f298c856c43614", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "patch": "@@ -67,6 +67,7 @@ use util::ppaux::{ty_to_str, ty_to_short_str};\n use util::ppaux;\n \n use core::hash;\n+use core::hashmap::linear::LinearMap;\n use core::int;\n use core::io;\n use core::libc::{c_uint, c_ulonglong};\n@@ -641,7 +642,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           let repr = adt::represent_type(cx.ccx(), t);\n           do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n               for vec::eachi(field_tys) |i, field_ty| {\n-                  let llfld_a = adt::trans_GEP(cx, &repr, av, discr, i);\n+                  let llfld_a = adt::trans_GEP(cx, repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n           }\n@@ -654,7 +655,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_tup(args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           for vec::eachi(args) |i, arg| {\n-              let llfld_a = adt::trans_GEP(cx, &repr, av, 0, i);\n+              let llfld_a = adt::trans_GEP(cx, repr, av, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n@@ -668,9 +669,9 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           // NB: we must hit the discriminant first so that structural\n           // comparison know not to proceed when the discriminants differ.\n \n-          match adt::trans_switch(cx, &repr, av) {\n+          match adt::trans_switch(cx, repr, av) {\n               (_match::single, None) => {\n-                  cx = iter_variant(cx, &repr, av, variants[0],\n+                  cx = iter_variant(cx, repr, av, variants[0],\n                                     substs.tps, f);\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n@@ -686,9 +687,9 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                           sub_block(cx, ~\"enum-iter-variant-\" +\n                                     int::to_str(variant.disr_val));\n                       let variant_cx =\n-                          iter_variant(variant_cx, &repr, av, *variant,\n+                          iter_variant(variant_cx, repr, av, *variant,\n                                        substs.tps, f);\n-                      match adt::trans_case(cx, &repr, variant.disr_val) {\n+                      match adt::trans_case(cx, repr, variant.disr_val) {\n                           _match::single_result(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n                           }\n@@ -1863,9 +1864,9 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n                                 ty::node_id_to_type(ccx.tcx, enum_id));\n     let repr = adt::represent_type(ccx, enum_ty);\n \n-    adt::trans_set_discr(bcx, &repr, fcx.llretptr, disr);\n+    adt::trans_set_discr(bcx, repr, fcx.llretptr, disr);\n     for vec::eachi(args) |i, va| {\n-        let lldestptr = adt::trans_GEP(bcx, &repr, fcx.llretptr, disr, i);\n+        let lldestptr = adt::trans_GEP(bcx, repr, fcx.llretptr, disr, i);\n \n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n@@ -1935,7 +1936,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     let repr = adt::represent_type(ccx, tup_ty);\n \n     for fields.eachi |i, field| {\n-        let lldestptr = adt::trans_GEP(bcx, &repr, fcx.llretptr, 0, i);\n+        let lldestptr = adt::trans_GEP(bcx, repr, fcx.llretptr, 0, i);\n         let llarg = match fcx.llargs.get(&field.node.id) {\n             local_mem(x) => x,\n             _ => {\n@@ -3050,6 +3051,7 @@ pub fn trans_crate(sess: session::Session,\n               module_data: HashMap(),\n               lltypes: ty::new_ty_hash(),\n               llsizingtypes: ty::new_ty_hash(),\n+              adt_reprs: @mut LinearMap::new(),\n               names: new_namegen(sess.parse_sess.interner),\n               next_addrspace: new_addrspace_gen(),\n               symbol_hasher: symbol_hasher,"}, {"sha": "a363a950f9b24763f25a5d18de7344e31d01ae06", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "patch": "@@ -26,6 +26,7 @@ use lib;\n use metadata::common::LinkMeta;\n use middle::astencode;\n use middle::resolve;\n+use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::callee;\n@@ -44,6 +45,7 @@ use util::ppaux::{expr_repr, ty_to_str};\n \n use core::cast;\n use core::hash;\n+use core::hashmap::linear::LinearMap;\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n use core::ptr;\n use core::str;\n@@ -203,6 +205,7 @@ pub struct CrateContext {\n      module_data: HashMap<~str, ValueRef>,\n      lltypes: HashMap<ty::t, TypeRef>,\n      llsizingtypes: HashMap<ty::t, TypeRef>,\n+     adt_reprs: @mut LinearMap<ty::t, @adt::Repr>,\n      names: namegen,\n      next_addrspace: addrspace_gen,\n      symbol_hasher: @hash::State,"}, {"sha": "cc5236609abddf6193ea42af4f7c1b0bada7fdfa", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "patch": "@@ -245,7 +245,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               let (bt, bv) = const_autoderef(cx, bt, bv);\n               do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n-                  adt::const_get_element(cx, &brepr, bv, discr, ix)\n+                  adt::const_get_element(cx, brepr, bv, discr, ix)\n               }\n           }\n \n@@ -326,7 +326,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               (expr::cast_enum, expr::cast_integral) |\n               (expr::cast_enum, expr::cast_float)  => {\n                 let repr = adt::represent_type(cx, basety);\n-                let iv = C_int(cx, adt::const_get_discrim(cx, &repr, v));\n+                let iv = C_int(cx, adt::const_get_discrim(cx, repr, v));\n                 let ety_cast = expr::cast_type_kind(ety);\n                 match ety_cast {\n                     expr::cast_integral => {\n@@ -356,12 +356,12 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n           ast::expr_tup(es) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n-              adt::trans_const(cx, &repr, 0, es.map(|e| const_expr(cx, *e)))\n+              adt::trans_const(cx, repr, 0, es.map(|e| const_expr(cx, *e)))\n           }\n           ast::expr_rec(ref fs, None) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n-              adt::trans_const(cx, &repr, 0,\n+              adt::trans_const(cx, repr, 0,\n                                fs.map(|f| const_expr(cx, f.node.expr)))\n           }\n           ast::expr_struct(_, ref fs, None) => {\n@@ -378,7 +378,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                           }\n                       }\n                   });\n-                  adt::trans_const(cx, &repr, discr, cs)\n+                  adt::trans_const(cx, repr, discr, cs)\n               }\n           }\n           ast::expr_vec(es, ast::m_imm) => {\n@@ -442,7 +442,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                     let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                          enum_did,\n                                                          variant_did);\n-                    adt::trans_const(cx, &repr, vinfo.disr_val, [])\n+                    adt::trans_const(cx, repr, vinfo.disr_val, [])\n                 }\n                 Some(ast::def_struct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n@@ -460,7 +460,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                   Some(ast::def_struct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n-                      adt::trans_const(cx, &repr, 0,\n+                      adt::trans_const(cx, repr, 0,\n                                        args.map(|a| const_expr(cx, *a)))\n                   }\n                   Some(ast::def_variant(enum_did, variant_did)) => {\n@@ -469,7 +469,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                       let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                            enum_did,\n                                                            variant_did);\n-                      adt::trans_const(cx, &repr, vinfo.disr_val,\n+                      adt::trans_const(cx, repr, vinfo.disr_val,\n                                        args.map(|a| const_expr(cx, *a)))\n                   }\n                   _ => cx.sess.span_bug(e.span, ~\"expected a struct or \\"}, {"sha": "7590d009f94feec1c187aaf111209d47ab1bbcfd", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "patch": "@@ -679,15 +679,15 @@ pub impl Datum {\n                 }\n \n                 let repr = adt::represent_type(ccx, self.ty);\n-                assert adt::is_newtypeish(&repr);\n+                assert adt::is_newtypeish(repr);\n                 let ty = ty::subst(ccx.tcx, substs, variants[0].args[0]);\n                 return match self.mode {\n                     ByRef => {\n                         // Recast lv.val as a pointer to the newtype\n                         // rather than a ptr to the enum type.\n                         (\n                             Some(Datum {\n-                                val: adt::trans_GEP(bcx, &repr, self.val,\n+                                val: adt::trans_GEP(bcx, repr, self.val,\n                                                     0, 0),\n                                 ty: ty,\n                                 mode: ByRef,\n@@ -719,7 +719,7 @@ pub impl Datum {\n                 }\n \n                 let repr = adt::represent_type(ccx, self.ty);\n-                assert adt::is_newtypeish(&repr);\n+                assert adt::is_newtypeish(repr);\n                 let ty = fields[0].mt.ty;\n                 return match self.mode {\n                     ByRef => {\n@@ -729,7 +729,7 @@ pub impl Datum {\n                         // destructors.\n                         (\n                             Some(Datum {\n-                                val: adt::trans_GEP(bcx, &repr, self.val,\n+                                val: adt::trans_GEP(bcx, repr, self.val,\n                                                     0, 0),\n                                 ty: ty,\n                                 mode: ByRef,"}, {"sha": "3df34e53ae3ef7ac0ce68e773b2f45531d9385da", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "patch": "@@ -604,7 +604,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_tup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n-            return trans_adt(bcx, &repr, 0, args.mapi(|i, arg| (i, *arg)),\n+            return trans_adt(bcx, repr, 0, args.mapi(|i, arg| (i, *arg)),\n                              None, dest);\n         }\n         ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), _}) => {\n@@ -726,7 +726,7 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(ccx, ty);\n-                adt::trans_set_discr(bcx, &repr, lldest,\n+                adt::trans_set_discr(bcx, repr, lldest,\n                                      variant_info.disr_val);\n                 return bcx;\n             }\n@@ -891,7 +891,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                 datum: do base_datum.get_element(bcx,\n                                                  field_tys[ix].mt.ty,\n                                                  ZeroMem) |srcval| {\n-                    adt::trans_GEP(bcx, &repr, srcval, discr, ix)\n+                    adt::trans_GEP(bcx, repr, srcval, discr, ix)\n                 },\n                 bcx: bcx\n             }\n@@ -1192,7 +1192,7 @@ fn trans_rec_or_struct(bcx: block,\n         };\n \n         let repr = adt::represent_type(bcx.ccx(), ty);\n-        trans_adt(bcx, &repr, discr, numbered_fields, optbase, dest)\n+        trans_adt(bcx, repr, discr, numbered_fields, optbase, dest)\n     }\n }\n \n@@ -1645,7 +1645,7 @@ fn trans_imm_cast(bcx: block, expr: @ast::expr,\n             (cast_enum, cast_float) => {\n                 let bcx = bcx;\n                 let repr = adt::represent_type(ccx, t_in);\n-                let lldiscrim_a = adt::trans_cast_to_int(bcx, &repr, llexpr);\n+                let lldiscrim_a = adt::trans_cast_to_int(bcx, repr, llexpr);\n                 match k_out {\n                     cast_integral => int_cast(bcx, ll_t_out,\n                                               val_ty(lldiscrim_a),"}, {"sha": "44f5e9df58bdb4e94c722bbd31ede8cf3b2c7e23", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "patch": "@@ -469,7 +469,7 @@ pub fn trans_struct_drop(bcx: block,\n                          take_ref: bool)\n                       -> block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let drop_flag = adt::trans_drop_flag_ptr(bcx, &repr, v0);\n+    let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n     do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n         let mut bcx = cx;\n \n@@ -507,7 +507,7 @@ pub fn trans_struct_drop(bcx: block,\n             ty::struct_mutable_fields(bcx.tcx(), class_did,\n                                               substs);\n         for vec::eachi(field_tys) |i, fld| {\n-            let llfld_a = adt::trans_GEP(bcx, &repr, v0, 0, i);\n+            let llfld_a = adt::trans_GEP(bcx, repr, v0, 0, i);\n             bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n         }\n "}, {"sha": "06c183f20e43ec84c3cdfc5ab201900bc92bbb4b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "patch": "@@ -147,7 +147,7 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n         ty::ty_tup(*) | ty::ty_rec(*) | ty::ty_struct(*)\n         | ty::ty_enum(*) => {\n             let repr = adt::represent_type(cx, t);\n-            T_struct(adt::sizing_fields_of(cx, &repr))\n+            T_struct(adt::sizing_fields_of(cx, repr))\n         }\n \n         ty::ty_self | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n@@ -244,7 +244,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       ty::ty_type => T_ptr(cx.tydesc_type),\n       ty::ty_tup(*) | ty::ty_rec(*) => {\n           let repr = adt::represent_type(cx, t);\n-          T_struct(adt::fields_of(cx, &repr))\n+          T_struct(adt::fields_of(cx, repr))\n       }\n       ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n       ty::ty_struct(did, ref substs) => {\n@@ -269,7 +269,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n     match ty::get(t).sty {\n       ty::ty_enum(*) | ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx, t);\n-          common::set_struct_body(llty, adt::fields_of(cx, &repr));\n+          common::set_struct_body(llty, adt::fields_of(cx, repr));\n       }\n       _ => ()\n     }"}]}