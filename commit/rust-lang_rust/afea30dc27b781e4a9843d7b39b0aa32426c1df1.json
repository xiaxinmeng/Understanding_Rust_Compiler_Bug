{"sha": "afea30dc27b781e4a9843d7b39b0aa32426c1df1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZWEzMGRjMjdiNzgxZTRhOTg0M2Q3YjM5YjBhYTMyNDI2YzFkZjE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-15T08:45:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-15T08:45:43Z"}, "message": "Rollup merge of #66721 - maxbla:exp-format-integers, r=KodrAus\n\nimplement LowerExp and UpperExp for integers\n\nAddresses https://github.com/rust-lang/rust/issues/39479\n\nThis implementation is heavily based on the preexisting `macro_rules! impl_Display` in the same file. I don't like the liberal use of unsafe in that macro and would like to modify it so `unsafe` is only present where necessary. What is Rust's policy on doing such modifications?\n\nAlso, I couldn't figure out where to put tests, can I have some help with that?", "tree": {"sha": "8f68c20c471a24dfee4d8983792bce48fdf2c113", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f68c20c471a24dfee4d8983792bce48fdf2c113"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afea30dc27b781e4a9843d7b39b0aa32426c1df1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeR6+3CRBK7hj4Ov3rIwAAdHIIAJ6vKEsI4LlifaE49f1qCDHG\ncmkmOztfgSY8CPsIXJEHoo4ZVSh2JAQ3Wj4aaRkTrwgF28OzZRGJ2vj9kfkBaBne\ns6o7pyBG4NKehbz0zgnZPzv0fjCRGsEfl1C1mHG1TSMkZ9xF7YYL54BbpaE3rmWN\nFFDmrzw3VeCDJBOgukpbCnmfc4TKY7jOosdDQfxHo8jSYkU1yrcMufxeBJkD+qre\nbTQqtb/+R8Xr4My8+E0x5mkbQF4BAIPoHPBPTqcg67AfXBSj1REdBP03hPMN2Ghg\nil8VUelPG8nq61EVTNSsdFeFdFJOoT2pB9Xpg/lj9oiSXl3pnBqwn0cSfHaMuJ8=\n=E/d+\n-----END PGP SIGNATURE-----\n", "payload": "tree 8f68c20c471a24dfee4d8983792bce48fdf2c113\nparent d28b35812fe6e72c8a499dee73e6687816fe829a\nparent a8fe47d1756df0fb68f6ed2edd2cedfb3cc66d7c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1581756343 +0100\ncommitter GitHub <noreply@github.com> 1581756343 +0100\n\nRollup merge of #66721 - maxbla:exp-format-integers, r=KodrAus\n\nimplement LowerExp and UpperExp for integers\n\nAddresses https://github.com/rust-lang/rust/issues/39479\n\nThis implementation is heavily based on the preexisting `macro_rules! impl_Display` in the same file. I don't like the liberal use of unsafe in that macro and would like to modify it so `unsafe` is only present where necessary. What is Rust's policy on doing such modifications?\n\nAlso, I couldn't figure out where to put tests, can I have some help with that?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afea30dc27b781e4a9843d7b39b0aa32426c1df1", "html_url": "https://github.com/rust-lang/rust/commit/afea30dc27b781e4a9843d7b39b0aa32426c1df1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afea30dc27b781e4a9843d7b39b0aa32426c1df1/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d28b35812fe6e72c8a499dee73e6687816fe829a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d28b35812fe6e72c8a499dee73e6687816fe829a", "html_url": "https://github.com/rust-lang/rust/commit/d28b35812fe6e72c8a499dee73e6687816fe829a"}, {"sha": "a8fe47d1756df0fb68f6ed2edd2cedfb3cc66d7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8fe47d1756df0fb68f6ed2edd2cedfb3cc66d7c", "html_url": "https://github.com/rust-lang/rust/commit/a8fe47d1756df0fb68f6ed2edd2cedfb3cc66d7c"}], "stats": {"total": 243, "additions": 243, "deletions": 0}, "files": [{"sha": "c187471fb5faa172353b2eeb65f951de3e517e41", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/afea30dc27b781e4a9843d7b39b0aa32426c1df1/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afea30dc27b781e4a9843d7b39b0aa32426c1df1/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=afea30dc27b781e4a9843d7b39b0aa32426c1df1", "patch": "@@ -4,6 +4,7 @@\n \n use crate::fmt;\n use crate::mem::MaybeUninit;\n+use crate::num::flt2dec;\n use crate::ops::{Div, Rem, Sub};\n use crate::ptr;\n use crate::slice;\n@@ -256,6 +257,161 @@ macro_rules! impl_Display {\n     };\n }\n \n+macro_rules! impl_Exp {\n+    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n+        fn $name(\n+            mut n: $u,\n+            is_nonnegative: bool,\n+            upper: bool,\n+            f: &mut fmt::Formatter<'_>\n+        ) -> fmt::Result {\n+            let (mut n, mut exponent, trailing_zeros, added_precision) = {\n+                let mut exponent = 0;\n+                // count and remove trailing decimal zeroes\n+                while n % 10 == 0 && n >= 10 {\n+                    n /= 10;\n+                    exponent += 1;\n+                }\n+                let trailing_zeros = exponent;\n+\n+                let (added_precision, subtracted_precision) = match f.precision() {\n+                    Some(fmt_prec) => {\n+                        // number of decimal digits minus 1\n+                        let mut tmp = n;\n+                        let mut prec = 0;\n+                        while tmp >= 10 {\n+                            tmp /= 10;\n+                            prec += 1;\n+                        }\n+                        (fmt_prec.saturating_sub(prec), prec.saturating_sub(fmt_prec))\n+                    }\n+                    None => (0,0)\n+                };\n+                for _ in 1..subtracted_precision {\n+                    n/=10;\n+                    exponent += 1;\n+                }\n+                if subtracted_precision != 0 {\n+                    let rem = n % 10;\n+                    n /= 10;\n+                    exponent += 1;\n+                    // round up last digit\n+                    if rem >= 5 {\n+                        n += 1;\n+                    }\n+                }\n+                (n, exponent, trailing_zeros, added_precision)\n+            };\n+\n+            // 39 digits (worst case u128) + . = 40\n+            let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n+            let mut curr = buf.len() as isize; //index for buf\n+            let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n+            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n+\n+            // decode 2 chars at a time\n+            while n >= 100 {\n+                let d1 = ((n % 100) as isize) << 1;\n+                curr -= 2;\n+                unsafe {\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                }\n+                n /= 100;\n+                exponent += 2;\n+            }\n+            // n is <= 99, so at most 2 chars long\n+            let mut n = n as isize; // possibly reduce 64bit math\n+            // decode second-to-last character\n+            if n >= 10 {\n+                curr -= 1;\n+                unsafe {\n+                    *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n+                }\n+                n /= 10;\n+                exponent += 1;\n+            }\n+            // add decimal point iff >1 mantissa digit will be printed\n+            if exponent != trailing_zeros || added_precision != 0 {\n+                curr -= 1;\n+                unsafe {\n+                    *buf_ptr.offset(curr) = b'.';\n+                }\n+            }\n+\n+            let buf_slice = unsafe {\n+                // decode last character\n+                curr -= 1;\n+                *buf_ptr.offset(curr) = (n as u8) + b'0';\n+\n+                let len = buf.len() - curr as usize;\n+                slice::from_raw_parts(buf_ptr.offset(curr), len)\n+            };\n+\n+            // stores 'e' (or 'E') and the up to 2-digit exponent\n+            let mut exp_buf = [MaybeUninit::<u8>::uninit(); 3];\n+            let exp_ptr = MaybeUninit::first_ptr_mut(&mut exp_buf);\n+            let exp_slice = unsafe {\n+                *exp_ptr.offset(0) = if upper {b'E'} else {b'e'};\n+                let len = if exponent < 10 {\n+                    *exp_ptr.offset(1) = (exponent as u8) + b'0';\n+                    2\n+                } else {\n+                    let off = exponent << 1;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(off), exp_ptr.offset(1), 2);\n+                    3\n+                };\n+                slice::from_raw_parts(exp_ptr, len)\n+            };\n+\n+            let parts = &[\n+                flt2dec::Part::Copy(buf_slice),\n+                flt2dec::Part::Zero(added_precision),\n+                flt2dec::Part::Copy(exp_slice)\n+            ];\n+            let sign = if !is_nonnegative {\n+                &b\"-\"[..]\n+            } else if f.sign_plus() {\n+                &b\"+\"[..]\n+            } else {\n+                &b\"\"[..]\n+            };\n+            let formatted = flt2dec::Formatted{sign, parts};\n+            f.pad_formatted_parts(&formatted)\n+        }\n+\n+        $(\n+            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n+            impl fmt::LowerExp for $t {\n+                #[allow(unused_comparisons)]\n+                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    let is_nonnegative = *self >= 0;\n+                    let n = if is_nonnegative {\n+                        self.$conv_fn()\n+                    } else {\n+                        // convert the negative num to positive by summing 1 to it's 2 complement\n+                        (!self.$conv_fn()).wrapping_add(1)\n+                    };\n+                    $name(n, is_nonnegative, false, f)\n+                }\n+            })*\n+        $(\n+            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n+            impl fmt::UpperExp for $t {\n+                #[allow(unused_comparisons)]\n+                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    let is_nonnegative = *self >= 0;\n+                    let n = if is_nonnegative {\n+                        self.$conv_fn()\n+                    } else {\n+                        // convert the negative num to positive by summing 1 to it's 2 complement\n+                        (!self.$conv_fn()).wrapping_add(1)\n+                    };\n+                    $name(n, is_nonnegative, true, f)\n+                }\n+            })*\n+    };\n+}\n+\n // Include wasm32 in here since it doesn't reflect the native pointer size, and\n // often cares strongly about getting a smaller code size.\n #[cfg(any(target_pointer_width = \"64\", target_arch = \"wasm32\"))]\n@@ -265,13 +421,20 @@ mod imp {\n         i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n             as u64 via to_u64 named fmt_u64\n     );\n+    impl_Exp!(\n+        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n+            as u64 via to_u64 named exp_u64\n+    );\n }\n \n #[cfg(not(any(target_pointer_width = \"64\", target_arch = \"wasm32\")))]\n mod imp {\n     use super::*;\n     impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n     impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n+    impl_Exp!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named exp_u32);\n+    impl_Exp!(i64, u64 as u64 via to_u64 named exp_u64);\n }\n \n impl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);\n+impl_Exp!(i128, u128 as u128 via to_u128 named exp_u128);"}, {"sha": "a50c2b46a919b320d68be0754608a46481bd5760", "filename": "src/libcore/tests/fmt/num.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/afea30dc27b781e4a9843d7b39b0aa32426c1df1/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afea30dc27b781e4a9843d7b39b0aa32426c1df1/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs?ref=afea30dc27b781e4a9843d7b39b0aa32426c1df1", "patch": "@@ -38,6 +38,16 @@ fn test_format_int() {\n     assert_eq!(format!(\"{:o}\", 1i16), \"1\");\n     assert_eq!(format!(\"{:o}\", 1i32), \"1\");\n     assert_eq!(format!(\"{:o}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:e}\", 1isize), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1i8), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1i16), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1i32), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1i64), \"1e0\");\n+    assert_eq!(format!(\"{:E}\", 1isize), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1i8), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1i16), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1i32), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1i64), \"1E0\");\n \n     assert_eq!(format!(\"{}\", 1usize), \"1\");\n     assert_eq!(format!(\"{}\", 1u8), \"1\");\n@@ -69,13 +79,79 @@ fn test_format_int() {\n     assert_eq!(format!(\"{:o}\", 1u16), \"1\");\n     assert_eq!(format!(\"{:o}\", 1u32), \"1\");\n     assert_eq!(format!(\"{:o}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:e}\", 1u8), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1u16), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1u32), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1u64), \"1e0\");\n+    assert_eq!(format!(\"{:E}\", 1u8), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1u16), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1u32), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1u64), \"1E0\");\n \n     // Test a larger number\n     assert_eq!(format!(\"{:b}\", 55), \"110111\");\n     assert_eq!(format!(\"{:o}\", 55), \"67\");\n     assert_eq!(format!(\"{}\", 55), \"55\");\n     assert_eq!(format!(\"{:x}\", 55), \"37\");\n     assert_eq!(format!(\"{:X}\", 55), \"37\");\n+    assert_eq!(format!(\"{:e}\", 55), \"5.5e1\");\n+    assert_eq!(format!(\"{:E}\", 55), \"5.5E1\");\n+    assert_eq!(format!(\"{:e}\", 10000000000u64), \"1e10\");\n+    assert_eq!(format!(\"{:E}\", 10000000000u64), \"1E10\");\n+    assert_eq!(format!(\"{:e}\", 10000000001u64), \"1.0000000001e10\");\n+    assert_eq!(format!(\"{:E}\", 10000000001u64), \"1.0000000001E10\");\n+}\n+\n+#[test]\n+fn test_format_int_exp_limits() {\n+    use core::{i128, i16, i32, i64, i8, u128, u16, u32, u64, u8};\n+    assert_eq!(format!(\"{:e}\", i8::MIN), \"-1.28e2\");\n+    assert_eq!(format!(\"{:e}\", i8::MAX), \"1.27e2\");\n+    assert_eq!(format!(\"{:e}\", i16::MIN), \"-3.2768e4\");\n+    assert_eq!(format!(\"{:e}\", i16::MAX), \"3.2767e4\");\n+    assert_eq!(format!(\"{:e}\", i32::MIN), \"-2.147483648e9\");\n+    assert_eq!(format!(\"{:e}\", i32::MAX), \"2.147483647e9\");\n+    assert_eq!(format!(\"{:e}\", i64::MIN), \"-9.223372036854775808e18\");\n+    assert_eq!(format!(\"{:e}\", i64::MAX), \"9.223372036854775807e18\");\n+    assert_eq!(format!(\"{:e}\", i128::MIN), \"-1.70141183460469231731687303715884105728e38\");\n+    assert_eq!(format!(\"{:e}\", i128::MAX), \"1.70141183460469231731687303715884105727e38\");\n+\n+    assert_eq!(format!(\"{:e}\", u8::MAX), \"2.55e2\");\n+    assert_eq!(format!(\"{:e}\", u16::MAX), \"6.5535e4\");\n+    assert_eq!(format!(\"{:e}\", u32::MAX), \"4.294967295e9\");\n+    assert_eq!(format!(\"{:e}\", u64::MAX), \"1.8446744073709551615e19\");\n+    assert_eq!(format!(\"{:e}\", u128::MAX), \"3.40282366920938463463374607431768211455e38\");\n+}\n+\n+#[test]\n+fn test_format_int_exp_precision() {\n+    use core::{i128, i16, i32, i64, i8};\n+\n+    //test that float and integer match\n+    let big_int: u32 = 314_159_265;\n+    assert_eq!(format!(\"{:.1e}\", big_int), format!(\"{:.1e}\", f64::from(big_int)));\n+\n+    //test adding precision\n+    assert_eq!(format!(\"{:.10e}\", i8::MIN), \"-1.2800000000e2\");\n+    assert_eq!(format!(\"{:.10e}\", i16::MIN), \"-3.2768000000e4\");\n+    assert_eq!(format!(\"{:.10e}\", i32::MIN), \"-2.1474836480e9\");\n+    assert_eq!(format!(\"{:.20e}\", i64::MIN), \"-9.22337203685477580800e18\");\n+    assert_eq!(format!(\"{:.40e}\", i128::MIN), \"-1.7014118346046923173168730371588410572800e38\");\n+\n+    //test rounding\n+    assert_eq!(format!(\"{:.1e}\", i8::MIN), \"-1.3e2\");\n+    assert_eq!(format!(\"{:.1e}\", i16::MIN), \"-3.3e4\");\n+    assert_eq!(format!(\"{:.1e}\", i32::MIN), \"-2.1e9\");\n+    assert_eq!(format!(\"{:.1e}\", i64::MIN), \"-9.2e18\");\n+    assert_eq!(format!(\"{:.1e}\", i128::MIN), \"-1.7e38\");\n+\n+    //test huge precision\n+    assert_eq!(format!(\"{:.1000e}\", 1), format!(\"1.{}e0\", \"0\".repeat(1000)));\n+    //test zero precision\n+    assert_eq!(format!(\"{:.0e}\", 1), format!(\"1e0\",));\n+\n+    //test padding with precision (and sign)\n+    assert_eq!(format!(\"{:+10.3e}\", 1), \"  +1.000e0\");\n }\n \n #[test]\n@@ -86,13 +162,17 @@ fn test_format_int_zero() {\n     assert_eq!(format!(\"{:o}\", 0), \"0\");\n     assert_eq!(format!(\"{:x}\", 0), \"0\");\n     assert_eq!(format!(\"{:X}\", 0), \"0\");\n+    assert_eq!(format!(\"{:e}\", 0), \"0e0\");\n+    assert_eq!(format!(\"{:E}\", 0), \"0E0\");\n \n     assert_eq!(format!(\"{}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:?}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:b}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:o}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:x}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:X}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:e}\", 0u32), \"0e0\");\n+    assert_eq!(format!(\"{:E}\", 0u32), \"0E0\");\n }\n \n #[test]"}]}