{"sha": "23b84e55e4dc0ed35192070cd442a0f5fd38a87e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzYjg0ZTU1ZTRkYzBlZDM1MTkyMDcwY2Q0NDJhMGY1ZmQzOGE4N2U=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-28T15:52:48Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-28T15:52:48Z"}, "message": "doc: use //! instead of /*! ... */ in std::rand", "tree": {"sha": "789746c57eed20cb50dd6d89e41d68e87323426d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/789746c57eed20cb50dd6d89e41d68e87323426d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23b84e55e4dc0ed35192070cd442a0f5fd38a87e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23b84e55e4dc0ed35192070cd442a0f5fd38a87e", "html_url": "https://github.com/rust-lang/rust/commit/23b84e55e4dc0ed35192070cd442a0f5fd38a87e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23b84e55e4dc0ed35192070cd442a0f5fd38a87e/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42ca8a70d60d066367484b153c1d84de728b14cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/42ca8a70d60d066367484b153c1d84de728b14cf", "html_url": "https://github.com/rust-lang/rust/commit/42ca8a70d60d066367484b153c1d84de728b14cf"}], "stats": {"total": 330, "additions": 163, "deletions": 167}, "files": [{"sha": "40d8f80171c4ed4ae9ce18021c7ef724fad845af", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 163, "deletions": 167, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/23b84e55e4dc0ed35192070cd442a0f5fd38a87e/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b84e55e4dc0ed35192070cd442a0f5fd38a87e/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=23b84e55e4dc0ed35192070cd442a0f5fd38a87e", "patch": "@@ -8,173 +8,169 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Utilities for random number generation\n-\n-The key functions are `random()` and `Rng::gen()`. These are polymorphic\n-and so can be used to generate any type that implements `Rand`. Type inference\n-means that often a simple call to `rand::random()` or `rng.gen()` will\n-suffice, but sometimes an annotation is required, e.g. `rand::random::<f64>()`.\n-\n-See the `distributions` submodule for sampling random numbers from\n-distributions like normal and exponential.\n-\n-# Task-local RNG\n-\n-There is built-in support for a RNG associated with each task stored\n-in task-local storage. This RNG can be accessed via `task_rng`, or\n-used implicitly via `random`. This RNG is normally randomly seeded\n-from an operating-system source of randomness, e.g. `/dev/urandom` on\n-Unix systems, and will automatically reseed itself from this source\n-after generating 32 KiB of random data.\n-\n-# Cryptographic security\n-\n-An application that requires an entropy source for cryptographic purposes\n-must use `OsRng`, which reads randomness from the source that the operating\n-system provides (e.g. `/dev/urandom` on Unixes or `CryptGenRandom()` on Windows).\n-The other random number generators provided by this module are not suitable\n-for such purposes.\n-\n-*Note*: many Unix systems provide `/dev/random` as well as `/dev/urandom`.\n-This module uses `/dev/urandom` for the following reasons:\n-\n--   On Linux, `/dev/random` may block if entropy pool is empty; `/dev/urandom` will not block.\n-    This does not mean that `/dev/random` provides better output than\n-    `/dev/urandom`; the kernel internally runs a cryptographically secure pseudorandom\n-    number generator (CSPRNG) based on entropy pool for random number generation,\n-    so the \"quality\" of `/dev/random` is not better than `/dev/urandom` in most cases.\n-    However, this means that `/dev/urandom` can yield somewhat predictable randomness\n-    if the entropy pool is very small, such as immediately after first booting.\n-    If an application likely to be run soon after first booting, or on a system with very\n-    few entropy sources, one should consider using `/dev/random` via `ReaderRng`.\n--   On some systems (e.g. FreeBSD, OpenBSD and Mac OS X) there is no difference\n-    between the two sources. (Also note that, on some systems e.g. FreeBSD, both `/dev/random`\n-    and `/dev/urandom` may block once if the CSPRNG has not seeded yet.)\n-\n-# Examples\n-\n-```rust\n-use std::rand;\n-use std::rand::Rng;\n-\n-let mut rng = rand::task_rng();\n-if rng.gen() { // random bool\n-    println!(\"int: {}, uint: {}\", rng.gen::<int>(), rng.gen::<uint>())\n-}\n-```\n-\n-```rust\n-use std::rand;\n-\n-let tuple = rand::random::<(f64, char)>();\n-println!(\"{}\", tuple)\n-```\n-\n-This is a simulation of the [Monty Hall Problem][]:\n-\n-> Suppose you're on a game show, and you're given the choice of three doors:\n-> Behind one door is a car; behind the others, goats. You pick a door, say No. 1,\n-> and the host, who knows what's behind the doors, opens another door, say No. 3,\n-> which has a goat. He then says to you, \"Do you want to pick door No. 2?\"\n-> Is it to your advantage to switch your choice?\n-\n-The rather unintuitive answer is that you will have a 2/3 chance of winning if\n-you switch and a 1/3 chance of winning of you don't, so it's better to switch.\n-\n-This program will simulate the game show and with large enough simulation steps\n-it will indeed confirm that it is better to switch.\n-\n-[Monty Hall Problem]: http://en.wikipedia.org/wiki/Monty_Hall_problem\n-\n-```\n-use std::rand;\n-use std::rand::Rng;\n-use std::rand::distributions::{IndependentSample, Range};\n-\n-struct SimulationResult {\n-    win: bool,\n-    switch: bool,\n-}\n-\n-// Run a single simulation of the Monty Hall problem.\n-fn simulate<R: Rng>(random_door: &Range<uint>, rng: &mut R) -> SimulationResult {\n-    let car = random_door.ind_sample(rng);\n-\n-    // This is our initial choice\n-    let mut choice = random_door.ind_sample(rng);\n-\n-    // The game host opens a door\n-    let open = game_host_open(car, choice, rng);\n-\n-    // Shall we switch?\n-    let switch = rng.gen();\n-    if switch {\n-        choice = switch_door(choice, open);\n-    }\n-\n-    SimulationResult { win: choice == car, switch: switch }\n-}\n-\n-// Returns the door the game host opens given our choice and knowledge of\n-// where the car is. The game host will never open the door with the car.\n-fn game_host_open<R: Rng>(car: uint, choice: uint, rng: &mut R) -> uint {\n-    let choices = free_doors(&[car, choice]);\n-    rand::sample(rng, choices.move_iter(), 1)[0]\n-}\n-\n-// Returns the door we switch to, given our current choice and\n-// the open door. There will only be one valid door.\n-fn switch_door(choice: uint, open: uint) -> uint {\n-    free_doors(&[choice, open])[0]\n-}\n-\n-fn free_doors(blocked: &[uint]) -> Vec<uint> {\n-    range(0u, 3).filter(|x| !blocked.contains(x)).collect()\n-}\n-\n-fn main() {\n-    // The estimation will be more accurate with more simulations\n-    let num_simulations = 10000u;\n-\n-    let mut rng = rand::task_rng();\n-    let random_door = Range::new(0u, 3);\n-\n-    let (mut switch_wins, mut switch_losses) = (0u, 0u);\n-    let (mut keep_wins, mut keep_losses) = (0u, 0u);\n-\n-    println!(\"Running {} simulations...\", num_simulations);\n-    for _ in range(0, num_simulations) {\n-        let result = simulate(&random_door, &mut rng);\n-\n-        match (result.win, result.switch) {\n-            (true, true) => switch_wins += 1,\n-            (true, false) => keep_wins += 1,\n-            (false, true) => switch_losses += 1,\n-            (false, false) => keep_losses += 1,\n-        }\n-    }\n-\n-    let total_switches = switch_wins + switch_losses;\n-    let total_keeps = keep_wins + keep_losses;\n-\n-    println!(\"Switched door {} times with {} wins and {} losses\",\n-             total_switches, switch_wins, switch_losses);\n-\n-    println!(\"Kept our choice {} times with {} wins and {} losses\",\n-             total_keeps, keep_wins, keep_losses);\n-\n-    // With a large number of simulations, the values should converge to\n-    // 0.667 and 0.333 respectively.\n-    println!(\"Estimated chance to win if we switch: {}\",\n-             switch_wins as f32 / total_switches as f32);\n-    println!(\"Estimated chance to win if we don't: {}\",\n-             keep_wins as f32 / total_keeps as f32);\n-}\n-```\n-\n-*/\n+//! Utilities for random number generation\n+//!\n+//! The key functions are `random()` and `Rng::gen()`. These are polymorphic\n+//! and so can be used to generate any type that implements `Rand`. Type inference\n+//! means that often a simple call to `rand::random()` or `rng.gen()` will\n+//! suffice, but sometimes an annotation is required, e.g. `rand::random::<f64>()`.\n+//!\n+//! See the `distributions` submodule for sampling random numbers from\n+//! distributions like normal and exponential.\n+//!\n+//! # Task-local RNG\n+//!\n+//! There is built-in support for a RNG associated with each task stored\n+//! in task-local storage. This RNG can be accessed via `task_rng`, or\n+//! used implicitly via `random`. This RNG is normally randomly seeded\n+//! from an operating-system source of randomness, e.g. `/dev/urandom` on\n+//! Unix systems, and will automatically reseed itself from this source\n+//! after generating 32 KiB of random data.\n+//!\n+//! # Cryptographic security\n+//!\n+//! An application that requires an entropy source for cryptographic purposes\n+//! must use `OsRng`, which reads randomness from the source that the operating\n+//! system provides (e.g. `/dev/urandom` on Unixes or `CryptGenRandom()` on Windows).\n+//! The other random number generators provided by this module are not suitable\n+//! for such purposes.\n+//!\n+//! *Note*: many Unix systems provide `/dev/random` as well as `/dev/urandom`.\n+//! This module uses `/dev/urandom` for the following reasons:\n+//!\n+//! -   On Linux, `/dev/random` may block if entropy pool is empty; `/dev/urandom` will not block.\n+//!     This does not mean that `/dev/random` provides better output than\n+//!     `/dev/urandom`; the kernel internally runs a cryptographically secure pseudorandom\n+//!     number generator (CSPRNG) based on entropy pool for random number generation,\n+//!     so the \"quality\" of `/dev/random` is not better than `/dev/urandom` in most cases.\n+//!     However, this means that `/dev/urandom` can yield somewhat predictable randomness\n+//!     if the entropy pool is very small, such as immediately after first booting.\n+//!     If an application likely to be run soon after first booting, or on a system with very\n+//!     few entropy sources, one should consider using `/dev/random` via `ReaderRng`.\n+//! -   On some systems (e.g. FreeBSD, OpenBSD and Mac OS X) there is no difference\n+//!     between the two sources. (Also note that, on some systems e.g. FreeBSD, both `/dev/random`\n+//!     and `/dev/urandom` may block once if the CSPRNG has not seeded yet.)\n+//!\n+//! # Examples\n+//!\n+//! ```rust\n+//! use std::rand;\n+//! use std::rand::Rng;\n+//!\n+//! let mut rng = rand::task_rng();\n+//! if rng.gen() { // random bool\n+//!     println!(\"int: {}, uint: {}\", rng.gen::<int>(), rng.gen::<uint>())\n+//! }\n+//! ```\n+//!\n+//! ```rust\n+//! use std::rand;\n+//!\n+//! let tuple = rand::random::<(f64, char)>();\n+//! println!(\"{}\", tuple)\n+//! ```\n+//!\n+//! This is a simulation of the [Monty Hall Problem][]:\n+//!\n+//! > Suppose you're on a game show, and you're given the choice of three doors:\n+//! > Behind one door is a car; behind the others, goats. You pick a door, say No. 1,\n+//! > and the host, who knows what's behind the doors, opens another door, say No. 3,\n+//! > which has a goat. He then says to you, \"Do you want to pick door No. 2?\"\n+//! > Is it to your advantage to switch your choice?\n+//!\n+//! The rather unintuitive answer is that you will have a 2/3 chance of winning if\n+//! you switch and a 1/3 chance of winning of you don't, so it's better to switch.\n+//!\n+//! This program will simulate the game show and with large enough simulation steps\n+//! it will indeed confirm that it is better to switch.\n+//!\n+//! [Monty Hall Problem]: http://en.wikipedia.org/wiki/Monty_Hall_problem\n+//!\n+//! ```\n+//! use std::rand;\n+//! use std::rand::Rng;\n+//! use std::rand::distributions::{IndependentSample, Range};\n+//!\n+//! struct SimulationResult {\n+//!     win: bool,\n+//!     switch: bool,\n+//! }\n+//!\n+//! // Run a single simulation of the Monty Hall problem.\n+//! fn simulate<R: Rng>(random_door: &Range<uint>, rng: &mut R) -> SimulationResult {\n+//!     let car = random_door.ind_sample(rng);\n+//!\n+//!     // This is our initial choice\n+//!     let mut choice = random_door.ind_sample(rng);\n+//!\n+//!     // The game host opens a door\n+//!     let open = game_host_open(car, choice, rng);\n+//!\n+//!     // Shall we switch?\n+//!     let switch = rng.gen();\n+//!     if switch {\n+//!         choice = switch_door(choice, open);\n+//!     }\n+//!\n+//!     SimulationResult { win: choice == car, switch: switch }\n+//! }\n+//!\n+//! // Returns the door the game host opens given our choice and knowledge of\n+//! // where the car is. The game host will never open the door with the car.\n+//! fn game_host_open<R: Rng>(car: uint, choice: uint, rng: &mut R) -> uint {\n+//!     let choices = free_doors(&[car, choice]);\n+//!     rand::sample(rng, choices.move_iter(), 1)[0]\n+//! }\n+//!\n+//! // Returns the door we switch to, given our current choice and\n+//! // the open door. There will only be one valid door.\n+//! fn switch_door(choice: uint, open: uint) -> uint {\n+//!     free_doors(&[choice, open])[0]\n+//! }\n+//!\n+//! fn free_doors(blocked: &[uint]) -> Vec<uint> {\n+//!     range(0u, 3).filter(|x| !blocked.contains(x)).collect()\n+//! }\n+//!\n+//! fn main() {\n+//!     // The estimation will be more accurate with more simulations\n+//!     let num_simulations = 10000u;\n+//!\n+//!     let mut rng = rand::task_rng();\n+//!     let random_door = Range::new(0u, 3);\n+//!\n+//!     let (mut switch_wins, mut switch_losses) = (0u, 0u);\n+//!     let (mut keep_wins, mut keep_losses) = (0u, 0u);\n+//!\n+//!     println!(\"Running {} simulations...\", num_simulations);\n+//!     for _ in range(0, num_simulations) {\n+//!         let result = simulate(&random_door, &mut rng);\n+//!\n+//!         match (result.win, result.switch) {\n+//!             (true, true) => switch_wins += 1,\n+//!             (true, false) => keep_wins += 1,\n+//!             (false, true) => switch_losses += 1,\n+//!             (false, false) => keep_losses += 1,\n+//!         }\n+//!     }\n+//!\n+//!     let total_switches = switch_wins + switch_losses;\n+//!     let total_keeps = keep_wins + keep_losses;\n+//!\n+//!     println!(\"Switched door {} times with {} wins and {} losses\",\n+//!              total_switches, switch_wins, switch_losses);\n+//!\n+//!     println!(\"Kept our choice {} times with {} wins and {} losses\",\n+//!              total_keeps, keep_wins, keep_losses);\n+//!\n+//!     // With a large number of simulations, the values should converge to\n+//!     // 0.667 and 0.333 respectively.\n+//!     println!(\"Estimated chance to win if we switch: {}\",\n+//!              switch_wins as f32 / total_switches as f32);\n+//!     println!(\"Estimated chance to win if we don't: {}\",\n+//!              keep_wins as f32 / total_keeps as f32);\n+//! }\n+//! ```\n \n #![experimental]\n "}]}