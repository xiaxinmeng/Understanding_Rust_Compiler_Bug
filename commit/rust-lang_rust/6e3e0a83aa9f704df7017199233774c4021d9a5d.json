{"sha": "6e3e0a83aa9f704df7017199233774c4021d9a5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlM2UwYTgzYWE5ZjcwNGRmNzAxNzE5OTIzMzc3NGM0MDIxZDlhNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-22T02:06:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-22T02:06:21Z"}, "message": "auto merge of #15834 : Kimundi/rust/moved_syntax_env, r=cmr\n\n- Made custom syntax extensions capable of expanding custom macros by moving `SyntaxEnv` into `ExtCtx`\r\n- Added convenience method on `ExtCtx` for getting a macro expander.\r\n- Made a few things private to force only a single way to use them (through `ExtCtx`)\r\n- Removed some ancient commented-out code\r\n\r\nCloses #14946", "tree": {"sha": "fac719a28b6d449024dd81ede3047ece0424b018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fac719a28b6d449024dd81ede3047ece0424b018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e3e0a83aa9f704df7017199233774c4021d9a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e3e0a83aa9f704df7017199233774c4021d9a5d", "html_url": "https://github.com/rust-lang/rust/commit/6e3e0a83aa9f704df7017199233774c4021d9a5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e3e0a83aa9f704df7017199233774c4021d9a5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa0e35bc64b2b1f4b21bc653e74ba986e98610e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa0e35bc64b2b1f4b21bc653e74ba986e98610e2", "html_url": "https://github.com/rust-lang/rust/commit/aa0e35bc64b2b1f4b21bc653e74ba986e98610e2"}, {"sha": "cef43782693931c62119f70351dd886681895455", "url": "https://api.github.com/repos/rust-lang/rust/commits/cef43782693931c62119f70351dd886681895455", "html_url": "https://github.com/rust-lang/rust/commit/cef43782693931c62119f70351dd886681895455"}], "stats": {"total": 481, "additions": 254, "deletions": 227}, "files": [{"sha": "07539a11113f5aaeeaf2b33833bb1581d85567bc", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e3e0a83aa9f704df7017199233774c4021d9a5d/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3e0a83aa9f704df7017199233774c4021d9a5d/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=6e3e0a83aa9f704df7017199233774c4021d9a5d", "patch": "@@ -34,6 +34,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::ext::base::{ExtCtxt, MacResult, MacExpr, DummyResult};\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::fold::Folder;\n \n use rustc::plugin::Registry;\n \n@@ -615,7 +616,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n /// Otherwise, logs an error with cx.span_err and returns None.\n fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<String> {\n     let mut parser = cx.new_parser_from_tts(tts);\n-    let entry = cx.expand_expr(parser.parse_expr());\n+    let entry = cx.expander().fold_expr(parser.parse_expr());\n     let regex = match entry.node {\n         ast::ExprLit(lit) => {\n             match lit.node {"}, {"sha": "a66d6839ab0743d5d5884c8507b1515a4784b07d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6e3e0a83aa9f704df7017199233774c4021d9a5d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3e0a83aa9f704df7017199233774c4021d9a5d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6e3e0a83aa9f704df7017199233774c4021d9a5d", "patch": "@@ -20,9 +20,11 @@ use parse::token;\n use parse::token::{InternedString, intern, str_to_ident};\n use util::small_vector::SmallVector;\n use ext::mtwt;\n+use fold::Folder;\n \n use std::collections::HashMap;\n use std::gc::{Gc, GC};\n+use std::rc::Rc;\n \n // new-style macro! tt code:\n //\n@@ -104,9 +106,9 @@ pub type IdentMacroExpanderFn =\n /// just into the compiler's internal macro table, for `make_def`).\n pub trait MacResult {\n     /// Define a new macro.\n-    // this particular flavor should go away; the idea that a macro might\n-    // expand into either a macro definition or an expression, depending\n-    // on what the context wants, is kind of silly.\n+    // this should go away; the idea that a macro might expand into\n+    // either a macro definition or an expression, depending on what\n+    // the context wants, is kind of silly.\n     fn make_def(&self) -> Option<MacroDef> {\n         None\n     }\n@@ -314,7 +316,7 @@ impl BlockInfo {\n \n /// The base map of methods for expanding syntax extension\n /// AST nodes into full ASTs\n-pub fn syntax_expander_table() -> SyntaxEnv {\n+fn initial_syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n     fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n         NormalTT(box BasicMacroExpander {\n@@ -431,7 +433,9 @@ pub struct ExtCtxt<'a> {\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n-    pub exported_macros: Vec<Gc<ast::Item>>\n+    pub exported_macros: Vec<Gc<ast::Item>>,\n+\n+    pub syntax_env: SyntaxEnv,\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -445,22 +449,18 @@ impl<'a> ExtCtxt<'a> {\n             ecfg: ecfg,\n             trace_mac: false,\n             exported_macros: Vec::new(),\n+            syntax_env: initial_syntax_expander_table(),\n         }\n     }\n \n-    pub fn expand_expr(&mut self, mut e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n-        loop {\n-            match e.node {\n-                ast::ExprMac(..) => {\n-                    let mut expander = expand::MacroExpander {\n-                        extsbox: syntax_expander_table(),\n-                        cx: self,\n-                    };\n-                    e = expand::expand_expr(e, &mut expander);\n-                }\n-                _ => return e\n-            }\n-        }\n+    #[deprecated = \"Replaced with `expander().fold_expr()`\"]\n+    pub fn expand_expr(&mut self, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+        self.expander().fold_expr(e)\n+    }\n+\n+    /// Returns a `Folder` for deeply expanding all macros in a AST node.\n+    pub fn expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> {\n+        expand::MacroExpander { cx: self }\n     }\n \n     pub fn new_parser_from_tts(&self, tts: &[ast::TokenTree])\n@@ -570,7 +570,7 @@ impl<'a> ExtCtxt<'a> {\n pub fn expr_to_string(cx: &mut ExtCtxt, expr: Gc<ast::Expr>, err_msg: &str)\n                    -> Option<(InternedString, ast::StrStyle)> {\n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n-    let expr = cx.expand_expr(expr);\n+    let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n         ast::ExprLit(l) => match l.node {\n             ast::LitStr(ref s, style) => return Some(((*s).clone(), style)),\n@@ -627,7 +627,7 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::EOF {\n-        es.push(cx.expand_expr(p.parse_expr()));\n+        es.push(cx.expander().fold_expr(p.parse_expr()));\n         if p.eat(&token::COMMA) {\n             continue;\n         }\n@@ -642,10 +642,13 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n /// In order to have some notion of scoping for macros,\n /// we want to implement the notion of a transformation\n /// environment.\n-\n+///\n /// This environment maps Names to SyntaxExtensions.\n+pub struct SyntaxEnv {\n+    chain: Vec<MapChainFrame> ,\n+}\n \n-//impl question: how to implement it? Initially, the\n+// impl question: how to implement it? Initially, the\n // env will contain only macros, so it might be painful\n // to add an empty frame for every context. Let's just\n // get it working, first....\n@@ -657,15 +660,11 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n \n struct MapChainFrame {\n     info: BlockInfo,\n-    map: HashMap<Name, SyntaxExtension>,\n-}\n-\n-pub struct SyntaxEnv {\n-    chain: Vec<MapChainFrame> ,\n+    map: HashMap<Name, Rc<SyntaxExtension>>,\n }\n \n impl SyntaxEnv {\n-    pub fn new() -> SyntaxEnv {\n+    fn new() -> SyntaxEnv {\n         let mut map = SyntaxEnv { chain: Vec::new() };\n         map.push_frame();\n         map\n@@ -692,18 +691,18 @@ impl SyntaxEnv {\n         unreachable!()\n     }\n \n-    pub fn find<'a>(&'a self, k: &Name) -> Option<&'a SyntaxExtension> {\n+    pub fn find(&self, k: &Name) -> Option<Rc<SyntaxExtension>> {\n         for frame in self.chain.iter().rev() {\n             match frame.map.find(k) {\n-                Some(v) => return Some(v),\n+                Some(v) => return Some(v.clone()),\n                 None => {}\n             }\n         }\n         None\n     }\n \n     pub fn insert(&mut self, k: Name, v: SyntaxExtension) {\n-        self.find_escape_frame().map.insert(k, v);\n+        self.find_escape_frame().map.insert(k, Rc::new(v));\n     }\n \n     pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {"}, {"sha": "123dcf366f440f57756decf58169029aeb4af22b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 195, "deletions": 195, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/6e3e0a83aa9f704df7017199233774c4021d9a5d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3e0a83aa9f704df7017199233774c4021d9a5d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6e3e0a83aa9f704df7017199233774c4021d9a5d", "patch": "@@ -32,7 +32,7 @@ use util::small_vector::SmallVector;\n use std::gc::{Gc, GC};\n \n \n-pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n+fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n     match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -208,7 +208,7 @@ fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n             }\n             let extname = pth.segments.get(0).identifier;\n             let extnamestr = token::get_ident(extname);\n-            match fld.extsbox.find(&extname.name) {\n+            match fld.cx.syntax_env.find(&extname.name) {\n                 None => {\n                     fld.cx.span_err(\n                         pth.span,\n@@ -218,46 +218,48 @@ fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n                     // let compilation continue\n                     None\n                 }\n-                Some(&NormalTT(ref expandfun, exp_span)) => {\n-                    fld.cx.bt_push(ExpnInfo {\n-                            call_site: *span,\n-                            callee: NameAndSpan {\n-                                name: extnamestr.get().to_string(),\n-                                format: MacroBang,\n-                                span: exp_span,\n-                            },\n-                        });\n-                    let fm = fresh_mark();\n-                    let marked_before = mark_tts(tts.as_slice(), fm);\n-\n-                    // The span that we pass to the expanders we want to\n-                    // be the root of the call stack. That's the most\n-                    // relevant span and it's the actual invocation of\n-                    // the macro.\n-                    let mac_span = original_span(fld.cx);\n-\n-                    let expanded = expandfun.expand(fld.cx,\n-                                                    mac_span.call_site,\n-                                                    marked_before.as_slice());\n-                    let parsed = match parse_thunk(expanded) {\n-                        Some(e) => e,\n-                        None => {\n-                            fld.cx.span_err(\n-                                pth.span,\n-                                format!(\"non-expression macro in expression position: {}\",\n-                                        extnamestr.get().as_slice()\n-                                        ).as_slice());\n-                            return None;\n-                        }\n-                    };\n-                    Some(mark_thunk(parsed,fm))\n-                }\n-                _ => {\n-                    fld.cx.span_err(\n-                        pth.span,\n-                        format!(\"'{}' is not a tt-style macro\",\n-                                extnamestr.get()).as_slice());\n-                    None\n+                Some(rc) => match *rc {\n+                    NormalTT(ref expandfun, exp_span) => {\n+                        fld.cx.bt_push(ExpnInfo {\n+                                call_site: *span,\n+                                callee: NameAndSpan {\n+                                    name: extnamestr.get().to_string(),\n+                                    format: MacroBang,\n+                                    span: exp_span,\n+                                },\n+                            });\n+                        let fm = fresh_mark();\n+                        let marked_before = mark_tts(tts.as_slice(), fm);\n+\n+                        // The span that we pass to the expanders we want to\n+                        // be the root of the call stack. That's the most\n+                        // relevant span and it's the actual invocation of\n+                        // the macro.\n+                        let mac_span = original_span(fld.cx);\n+\n+                        let expanded = expandfun.expand(fld.cx,\n+                                                        mac_span.call_site,\n+                                                        marked_before.as_slice());\n+                        let parsed = match parse_thunk(expanded) {\n+                            Some(e) => e,\n+                            None => {\n+                                fld.cx.span_err(\n+                                    pth.span,\n+                                    format!(\"non-expression macro in expression position: {}\",\n+                                            extnamestr.get().as_slice()\n+                                            ).as_slice());\n+                                return None;\n+                            }\n+                        };\n+                        Some(mark_thunk(parsed,fm))\n+                    }\n+                    _ => {\n+                        fld.cx.span_err(\n+                            pth.span,\n+                            format!(\"'{}' is not a tt-style macro\",\n+                                    extnamestr.get()).as_slice());\n+                        None\n+                    }\n                 }\n             }\n         }\n@@ -288,10 +290,10 @@ fn expand_loop_block(loop_block: P<Block>,\n             // The rename *must* be added to the enclosed syntax context for\n             // `break` or `continue` to pick up because by definition they are\n             // in a block enclosed by loop head.\n-            fld.extsbox.push_frame();\n-            fld.extsbox.info().pending_renames.push(rename);\n+            fld.cx.syntax_env.push_frame();\n+            fld.cx.syntax_env.info().pending_renames.push(rename);\n             let expanded_block = expand_block_elts(&*loop_block, fld);\n-            fld.extsbox.pop_frame();\n+            fld.cx.syntax_env.pop_frame();\n \n             (expanded_block, Some(renamed_ident))\n         }\n@@ -321,29 +323,32 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n     for attr in it.attrs.iter() {\n         let mname = attr.name();\n \n-        match fld.extsbox.find(&intern(mname.get())) {\n-            Some(&ItemDecorator(dec_fn)) => {\n-                attr::mark_used(attr);\n+        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+            Some(rc) => match *rc {\n+                ItemDecorator(dec_fn) => {\n+                    attr::mark_used(attr);\n \n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: attr.span,\n-                    callee: NameAndSpan {\n-                        name: mname.get().to_string(),\n-                        format: MacroAttribute,\n-                        span: None\n-                    }\n-                });\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.get().to_string(),\n+                            format: MacroAttribute,\n+                            span: None\n+                        }\n+                    });\n \n-                // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n-                // but that double-mut-borrows fld\n-                let mut items: SmallVector<Gc<ast::Item>> = SmallVector::zero();\n-                dec_fn(fld.cx, attr.span, attr.node.value, it,\n-                       |item| items.push(item));\n-                decorator_items.extend(items.move_iter()\n-                    .flat_map(|item| expand_item(item, fld).move_iter()));\n+                    // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n+                    // but that double-mut-borrows fld\n+                    let mut items: SmallVector<Gc<ast::Item>> = SmallVector::zero();\n+                    dec_fn(fld.cx, attr.span, attr.node.value, it,\n+                        |item| items.push(item));\n+                    decorator_items.extend(items.move_iter()\n+                        .flat_map(|item| expand_item(item, fld).move_iter()));\n \n-                fld.cx.bt_pop();\n-            }\n+                    fld.cx.bt_pop();\n+                }\n+                _ => new_attrs.push((*attr).clone()),\n+            },\n             _ => new_attrs.push((*attr).clone()),\n         }\n     }\n@@ -353,7 +358,7 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n         ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n             fld.cx.mod_push(it.ident);\n             let macro_escape = contains_macro_escape(new_attrs.as_slice());\n-            let result = with_exts_frame!(fld.extsbox,\n+            let result = with_exts_frame!(fld.cx.syntax_env,\n                                           macro_escape,\n                                           noop_fold_item(&*it, fld));\n             fld.cx.mod_pop();\n@@ -377,8 +382,8 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n                          -> Gc<ast::Item> {\n     // partition the attributes into ItemModifiers and others\n     let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n-        match fld.extsbox.find(&intern(attr.name().get())) {\n-            Some(&ItemModifier(_)) => true,\n+        match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n+            Some(rc) => match *rc { ItemModifier(_) => true, _ => false },\n             _ => false\n         }\n     });\n@@ -395,20 +400,23 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n     for attr in modifiers.iter() {\n         let mname = attr.name();\n \n-        match fld.extsbox.find(&intern(mname.get())) {\n-            Some(&ItemModifier(dec_fn)) => {\n-                attr::mark_used(attr);\n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: attr.span,\n-                    callee: NameAndSpan {\n-                        name: mname.get().to_string(),\n-                        format: MacroAttribute,\n-                        span: None,\n-                    }\n-                });\n-                it = dec_fn(fld.cx, attr.span, attr.node.value, it);\n-                fld.cx.bt_pop();\n-            }\n+        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+            Some(rc) => match *rc {\n+                ItemModifier(dec_fn) => {\n+                    attr::mark_used(attr);\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.get().to_string(),\n+                            format: MacroAttribute,\n+                            span: None,\n+                        }\n+                    });\n+                    it = dec_fn(fld.cx, attr.span, attr.node.value, it);\n+                    fld.cx.bt_pop();\n+                }\n+                _ => unreachable!()\n+            },\n             _ => unreachable!()\n         }\n     }\n@@ -452,7 +460,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n     let extname = pth.segments.get(0).identifier;\n     let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n-    let expanded = match fld.extsbox.find(&extname.name) {\n+    let expanded = match fld.cx.syntax_env.find(&extname.name) {\n         None => {\n             fld.cx.span_err(pth.span,\n                             format!(\"macro undefined: '{}!'\",\n@@ -461,70 +469,72 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             return SmallVector::zero();\n         }\n \n-        Some(&NormalTT(ref expander, span)) => {\n-            if it.ident.name != parse::token::special_idents::invalid.name {\n-                fld.cx\n-                   .span_err(pth.span,\n-                             format!(\"macro {}! expects no ident argument, \\\n-                                      given '{}'\",\n-                                     extnamestr,\n-                                     token::get_ident(it.ident)).as_slice());\n-                return SmallVector::zero();\n+        Some(rc) => match *rc {\n+            NormalTT(ref expander, span) => {\n+                if it.ident.name != parse::token::special_idents::invalid.name {\n+                    fld.cx\n+                    .span_err(pth.span,\n+                                format!(\"macro {}! expects no ident argument, \\\n+                                        given '{}'\",\n+                                        extnamestr,\n+                                        token::get_ident(it.ident)).as_slice());\n+                    return SmallVector::zero();\n+                }\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: it.span,\n+                    callee: NameAndSpan {\n+                        name: extnamestr.get().to_string(),\n+                        format: MacroBang,\n+                        span: span\n+                    }\n+                });\n+                // mark before expansion:\n+                let marked_before = mark_tts(tts.as_slice(), fm);\n+                expander.expand(fld.cx, it.span, marked_before.as_slice())\n             }\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: it.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: span\n+            IdentTT(ref expander, span) => {\n+                if it.ident.name == parse::token::special_idents::invalid.name {\n+                    fld.cx.span_err(pth.span,\n+                                    format!(\"macro {}! expects an ident argument\",\n+                                            extnamestr.get()).as_slice());\n+                    return SmallVector::zero();\n                 }\n-            });\n-            // mark before expansion:\n-            let marked_before = mark_tts(tts.as_slice(), fm);\n-            expander.expand(fld.cx, it.span, marked_before.as_slice())\n-        }\n-        Some(&IdentTT(ref expander, span)) => {\n-            if it.ident.name == parse::token::special_idents::invalid.name {\n-                fld.cx.span_err(pth.span,\n-                                format!(\"macro {}! expects an ident argument\",\n-                                        extnamestr.get()).as_slice());\n-                return SmallVector::zero();\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: it.span,\n+                    callee: NameAndSpan {\n+                        name: extnamestr.get().to_string(),\n+                        format: MacroBang,\n+                        span: span\n+                    }\n+                });\n+                // mark before expansion:\n+                let marked_tts = mark_tts(tts.as_slice(), fm);\n+                expander.expand(fld.cx, it.span, it.ident, marked_tts)\n             }\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: it.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: span\n+            LetSyntaxTT(ref expander, span) => {\n+                if it.ident.name == parse::token::special_idents::invalid.name {\n+                    fld.cx.span_err(pth.span,\n+                                    format!(\"macro {}! expects an ident argument\",\n+                                            extnamestr.get()).as_slice());\n+                    return SmallVector::zero();\n                 }\n-            });\n-            // mark before expansion:\n-            let marked_tts = mark_tts(tts.as_slice(), fm);\n-            expander.expand(fld.cx, it.span, it.ident, marked_tts)\n-        }\n-        Some(&LetSyntaxTT(ref expander, span)) => {\n-            if it.ident.name == parse::token::special_idents::invalid.name {\n-                fld.cx.span_err(pth.span,\n-                                format!(\"macro {}! expects an ident argument\",\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: it.span,\n+                    callee: NameAndSpan {\n+                        name: extnamestr.get().to_string(),\n+                        format: MacroBang,\n+                        span: span\n+                    }\n+                });\n+                // DON'T mark before expansion:\n+                expander.expand(fld.cx, it.span, it.ident, tts)\n+            }\n+            _ => {\n+                fld.cx.span_err(it.span,\n+                                format!(\"{}! is not legal in item position\",\n                                         extnamestr.get()).as_slice());\n                 return SmallVector::zero();\n             }\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: it.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: span\n-                }\n-            });\n-            // DON'T mark before expansion:\n-            expander.expand(fld.cx, it.span, it.ident, tts)\n-        }\n-        _ => {\n-            fld.cx.span_err(it.span,\n-                            format!(\"{}! is not legal in item position\",\n-                                    extnamestr.get()).as_slice());\n-            return SmallVector::zero();\n         }\n     };\n \n@@ -534,7 +544,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             // result of expanding a LetSyntaxTT, and thus doesn't\n             // need to be marked. Not that it could be marked anyway.\n             // create issue to recommend refactoring here?\n-            fld.extsbox.insert(intern(name.as_slice()), ext);\n+            fld.cx.syntax_env.insert(intern(name.as_slice()), ext);\n             if attr::contains_name(it.attrs.as_slice(), \"macro_export\") {\n                 fld.cx.exported_macros.push(it);\n             }\n@@ -641,7 +651,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                         rename_fld.fold_pat(expanded_pat)\n                     };\n                     // add them to the existing pending renames:\n-                    fld.extsbox.info().pending_renames.push_all_move(new_pending_renames);\n+                    fld.cx.syntax_env.info().pending_renames.push_all_move(new_pending_renames);\n                     // also, don't forget to expand the init:\n                     let new_init_opt = init.map(|e| fld.fold_expr(e));\n                     let rewritten_local =\n@@ -742,7 +752,7 @@ fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n-    with_exts_frame!(fld.extsbox,false,\n+    with_exts_frame!(fld.cx.syntax_env,false,\n                      expand_block_elts(blk, fld))\n }\n \n@@ -753,7 +763,7 @@ fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n         b.stmts.iter().flat_map(|x| {\n             // perform all pending renames\n             let renamed_stmt = {\n-                let pending_renames = &mut fld.extsbox.info().pending_renames;\n+                let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n                 let mut rename_fld = IdentRenamer{renames:pending_renames};\n                 rename_fld.fold_stmt(&**x).expect_one(\"rename_fold didn't return one value\")\n             };\n@@ -762,7 +772,7 @@ fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n         }).collect();\n     let new_expr = b.expr.map(|x| {\n         let expr = {\n-            let pending_renames = &mut fld.extsbox.info().pending_renames;\n+            let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n             let mut rename_fld = IdentRenamer{renames:pending_renames};\n             rename_fld.fold_expr(x)\n         };\n@@ -795,7 +805,7 @@ fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n     }\n     let extname = pth.segments.get(0).identifier;\n     let extnamestr = token::get_ident(extname);\n-    let marked_after = match fld.extsbox.find(&extname.name) {\n+    let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n         None => {\n             fld.cx.span_err(pth.span,\n                             format!(\"macro undefined: '{}!'\",\n@@ -804,43 +814,45 @@ fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n             return DummyResult::raw_pat(p.span);\n         }\n \n-        Some(&NormalTT(ref expander, span)) => {\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: p.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: span\n-                }\n-            });\n-\n-            let fm = fresh_mark();\n-            let marked_before = mark_tts(tts.as_slice(), fm);\n-            let mac_span = original_span(fld.cx);\n-            let expanded = match expander.expand(fld.cx,\n-                                   mac_span.call_site,\n-                                   marked_before.as_slice()).make_pat() {\n-                Some(e) => e,\n-                None => {\n-                    fld.cx.span_err(\n-                        pth.span,\n-                        format!(\n-                            \"non-pattern macro in pattern position: {}\",\n-                            extnamestr.get()\n-                        ).as_slice()\n-                    );\n-                    return DummyResult::raw_pat(p.span);\n-                }\n-            };\n+        Some(rc) => match *rc {\n+            NormalTT(ref expander, span) => {\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: p.span,\n+                    callee: NameAndSpan {\n+                        name: extnamestr.get().to_string(),\n+                        format: MacroBang,\n+                        span: span\n+                    }\n+                });\n \n-            // mark after:\n-            mark_pat(expanded,fm)\n-        }\n-        _ => {\n-            fld.cx.span_err(p.span,\n-                            format!(\"{}! is not legal in pattern position\",\n-                                    extnamestr.get()).as_slice());\n-            return DummyResult::raw_pat(p.span);\n+                let fm = fresh_mark();\n+                let marked_before = mark_tts(tts.as_slice(), fm);\n+                let mac_span = original_span(fld.cx);\n+                let expanded = match expander.expand(fld.cx,\n+                                    mac_span.call_site,\n+                                    marked_before.as_slice()).make_pat() {\n+                    Some(e) => e,\n+                    None => {\n+                        fld.cx.span_err(\n+                            pth.span,\n+                            format!(\n+                                \"non-pattern macro in pattern position: {}\",\n+                                extnamestr.get()\n+                            ).as_slice()\n+                        );\n+                        return DummyResult::raw_pat(p.span);\n+                    }\n+                };\n+\n+                // mark after:\n+                mark_pat(expanded,fm)\n+            }\n+            _ => {\n+                fld.cx.span_err(p.span,\n+                                format!(\"{}! is not legal in pattern position\",\n+                                        extnamestr.get()).as_slice());\n+                return DummyResult::raw_pat(p.span);\n+            }\n         }\n     };\n \n@@ -975,7 +987,6 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: &ast::FnDecl, block: Gc<ast::Blo\n \n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b> {\n-    pub extsbox: SyntaxEnv,\n     pub cx: &'a mut ExtCtxt<'b>,\n }\n \n@@ -1044,7 +1055,6 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     let mut expander = MacroExpander {\n-        extsbox: syntax_expander_table(),\n         cx: &mut cx,\n     };\n \n@@ -1063,7 +1073,7 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n     }\n \n     for (name, extension) in user_exts.move_iter() {\n-        expander.extsbox.insert(name, extension);\n+        expander.cx.syntax_env.insert(name, extension);\n     }\n \n     let mut ret = expander.fold_crate(c);\n@@ -1337,16 +1347,6 @@ mod test {\n         name_finder.ident_accumulator\n     }\n \n-    //fn expand_and_resolve(crate_str: @str) -> ast::crate {\n-        //let expanded_ast = expand_crate_str(crate_str);\n-        // println!(\"expanded: {:?}\\n\",expanded_ast);\n-        //mtwt_resolve_crate(expanded_ast)\n-    //}\n-    //fn expand_and_resolve_and_pretty_print (crate_str: @str) -> String {\n-        //let resolved_ast = expand_and_resolve(crate_str);\n-        //pprust::to_string(&resolved_ast,fake_print_crate,get_ident_interner())\n-    //}\n-\n     #[test] fn macro_tokens_should_match(){\n         expand_crate_str(\n             \"macro_rules! m((a)=>(13)) fn main(){m!(a);}\".to_string());"}, {"sha": "f85c6f1fc9349966947f518a45d38040a8162e83", "filename": "src/test/run-pass/macro-deep_expansion.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6e3e0a83aa9f704df7017199233774c4021d9a5d/src%2Ftest%2Frun-pass%2Fmacro-deep_expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3e0a83aa9f704df7017199233774c4021d9a5d/src%2Ftest%2Frun-pass%2Fmacro-deep_expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-deep_expansion.rs?ref=6e3e0a83aa9f704df7017199233774c4021d9a5d", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules)]\n+\n+macro_rules! foo2 {\n+    () => {\n+        \"foo\"\n+    }\n+}\n+\n+macro_rules! foo {\n+    () => {\n+        foo2!()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(concat!(foo!(), \"bar\"), \"foobar\")\n+}"}]}