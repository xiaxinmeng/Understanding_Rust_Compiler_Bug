{"sha": "a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "node_id": "C_kwDOAAsO6NoAKGE4ZjdlMjQ0Yjc4NWZlYjFiMWQ2OTZhYmYwYTdlZmI1Y2I3YWVkMzA", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-09-16T07:01:02Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-10-01T10:03:06Z"}, "message": "Refactor rustc lint API", "tree": {"sha": "494e24f05b9fe3dfe766207727a83d369c218c22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/494e24f05b9fe3dfe766207727a83d369c218c22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "html_url": "https://github.com/rust-lang/rust/commit/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65445a571c11f07f4ca1ed0f63bad247ae295bd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/65445a571c11f07f4ca1ed0f63bad247ae295bd0", "html_url": "https://github.com/rust-lang/rust/commit/65445a571c11f07f4ca1ed0f63bad247ae295bd0"}], "stats": {"total": 3317, "additions": 1761, "deletions": 1556}, "files": [{"sha": "09c92ae03619dcbb2195239edee7790af946b165", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -233,10 +233,10 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                 rustc_session::lint::builtin::CONST_ERR,\n                 hir_id,\n                 tcx.span,\n+                message,\n                 |lint| {\n-                    let mut lint = lint.build(message);\n-                    finish(&mut lint, Some(err_msg));\n-                    lint.emit();\n+                    finish(lint, Some(err_msg));\n+                    lint\n                 },\n             );\n             ErrorHandled::Linted"}, {"sha": "fb7f89d7a28c0f8551f257564127991a275dbe3b", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -357,6 +357,17 @@ impl<S: Into<String>> From<S> for DiagnosticMessage {\n     }\n }\n \n+/// A workaround for \"good path\" ICEs when formatting types in disables lints.\n+///\n+/// Delays formatting until `.into(): DiagnosticMessage` is used.\n+pub struct DelayDm<F>(pub F);\n+\n+impl<F: FnOnce() -> String> From<DelayDm<F>> for DiagnosticMessage {\n+    fn from(DelayDm(f): DelayDm<F>) -> Self {\n+        DiagnosticMessage::from(f())\n+    }\n+}\n+\n /// Translating *into* a subdiagnostic message from a diagnostic message is a little strange - but\n /// the subdiagnostic functions (e.g. `span_label`) take a `SubdiagnosticMessage` and the\n /// subdiagnostic derive refers to typed identifiers that are `DiagnosticMessage`s, so need to be"}, {"sha": "49dcc2ba021e4f94f01e6dd96a5f90599717c58c", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -1,6 +1,6 @@\n use crate::snippet::Style;\n use crate::{\n-    CodeSuggestion, DiagnosticMessage, EmissionGuarantee, Level, LintDiagnosticBuilder, MultiSpan,\n+    CodeSuggestion, DiagnosticBuilder, DiagnosticMessage, EmissionGuarantee, Level, MultiSpan,\n     SubdiagnosticMessage, Substitution, SubstitutionPart, SuggestionStyle,\n };\n use rustc_ast as ast;\n@@ -209,7 +209,12 @@ pub trait AddToDiagnostic {\n #[rustc_diagnostic_item = \"DecorateLint\"]\n pub trait DecorateLint<'a, G: EmissionGuarantee> {\n     /// Decorate and emit a lint.\n-    fn decorate_lint(self, diag: LintDiagnosticBuilder<'a, G>);\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut DiagnosticBuilder<'a, G>,\n+    ) -> &'b mut DiagnosticBuilder<'a, G>;\n+\n+    fn msg(&self) -> DiagnosticMessage;\n }\n \n #[must_use]"}, {"sha": "c9f912fa7aab7a626b4650f1cf544410d0cf0ec3", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -30,7 +30,7 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n pub use rustc_error_messages::{\n-    fallback_fluent_bundle, fluent, fluent_bundle, DiagnosticMessage, FluentBundle,\n+    fallback_fluent_bundle, fluent, fluent_bundle, DelayDm, DiagnosticMessage, FluentBundle,\n     LanguageIdentifier, LazyFallbackBundle, MultiSpan, SpanLabel, SubdiagnosticMessage,\n     DEFAULT_LOCALE_RESOURCES,\n };"}, {"sha": "5752b6a356de3315e0c2c27bda1f59183bf599b3", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -649,9 +649,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     LATE_BOUND_LIFETIME_ARGUMENTS,\n                     args.args[0].hir_id(),\n                     multispan,\n-                    |lint| {\n-                        lint.build(msg).emit();\n-                    },\n+                    msg,\n+                    |lint| lint,\n                 );\n             }\n "}, {"sha": "cf65bc19a5c83208f171039a7c8d2030a4d0d3fd", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -2015,30 +2015,35 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx.check_stability(item.def_id, Some(hir_ref_id), span, None);\n \n         if let Some(variant_def_id) = variant_resolution {\n-            tcx.struct_span_lint_hir(AMBIGUOUS_ASSOCIATED_ITEMS, hir_ref_id, span, |lint| {\n-                let mut err = lint.build(\"ambiguous associated item\");\n-                let mut could_refer_to = |kind: DefKind, def_id, also| {\n-                    let note_msg = format!(\n-                        \"`{}` could{} refer to the {} defined here\",\n-                        assoc_ident,\n-                        also,\n-                        kind.descr(def_id)\n-                    );\n-                    err.span_note(tcx.def_span(def_id), &note_msg);\n-                };\n+            tcx.struct_span_lint_hir(\n+                AMBIGUOUS_ASSOCIATED_ITEMS,\n+                hir_ref_id,\n+                span,\n+                \"ambiguous associated item\",\n+                |lint| {\n+                    let mut could_refer_to = |kind: DefKind, def_id, also| {\n+                        let note_msg = format!(\n+                            \"`{}` could{} refer to the {} defined here\",\n+                            assoc_ident,\n+                            also,\n+                            kind.descr(def_id)\n+                        );\n+                        lint.span_note(tcx.def_span(def_id), &note_msg);\n+                    };\n \n-                could_refer_to(DefKind::Variant, variant_def_id, \"\");\n-                could_refer_to(kind, item.def_id, \" also\");\n+                    could_refer_to(DefKind::Variant, variant_def_id, \"\");\n+                    could_refer_to(kind, item.def_id, \" also\");\n \n-                err.span_suggestion(\n-                    span,\n-                    \"use fully-qualified syntax\",\n-                    format!(\"<{} as {}>::{}\", qself_ty, tcx.item_name(trait_did), assoc_ident),\n-                    Applicability::MachineApplicable,\n-                );\n+                    lint.span_suggestion(\n+                        span,\n+                        \"use fully-qualified syntax\",\n+                        format!(\"<{} as {}>::{}\", qself_ty, tcx.item_name(trait_did), assoc_ident),\n+                        Applicability::MachineApplicable,\n+                    );\n \n-                err.emit();\n-            });\n+                    lint\n+                },\n+            );\n         }\n         Ok((ty, kind, item.def_id))\n     }\n@@ -3084,15 +3089,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     BARE_TRAIT_OBJECTS,\n                     self_ty.hir_id,\n                     self_ty.span,\n+                    msg,\n                     |lint| {\n-                        let mut diag = lint.build(msg);\n-                        diag.multipart_suggestion_verbose(\n+                        lint.multipart_suggestion_verbose(\n                             \"use `dyn`\",\n                             sugg,\n                             Applicability::MachineApplicable,\n                         );\n-                        self.maybe_lint_blanket_trait_impl(&self_ty, &mut diag);\n-                        diag.emit();\n+                        self.maybe_lint_blanket_trait_impl(&self_ty, lint);\n+                        lint\n                     },\n                 );\n             }"}, {"sha": "01badc133c918cb1a019d26a1325eb99ccee1c0c", "filename": "compiler/rustc_hir_analysis/src/check/cast.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcast.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -33,7 +33,7 @@ use super::FnCtxt;\n use crate::hir::def_id::DefId;\n use crate::type_error_struct;\n use hir::def_id::LOCAL_CRATE;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{struct_span_err, Applicability, DelayDm, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_infer::traits::{Obligation, ObligationCause, ObligationCauseCode};\n use rustc_middle::mir::Mutability;\n@@ -754,19 +754,25 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         } else {\n             (\"\", lint::builtin::TRIVIAL_CASTS)\n         };\n-        fcx.tcx.struct_span_lint_hir(lint, self.expr.hir_id, self.span, |err| {\n-            err.build(&format!(\n-                \"trivial {}cast: `{}` as `{}`\",\n-                adjective,\n-                fcx.ty_to_string(t_expr),\n-                fcx.ty_to_string(t_cast)\n-            ))\n-            .help(&format!(\n-                \"cast can be replaced by coercion; this might \\\n-                                   require {type_asc_or}a temporary variable\"\n-            ))\n-            .emit();\n-        });\n+        fcx.tcx.struct_span_lint_hir(\n+            lint,\n+            self.expr.hir_id,\n+            self.span,\n+            DelayDm(|| {\n+                format!(\n+                    \"trivial {}cast: `{}` as `{}`\",\n+                    adjective,\n+                    fcx.ty_to_string(t_expr),\n+                    fcx.ty_to_string(t_cast)\n+                )\n+            }),\n+            |lint| {\n+                lint.help(format!(\n+                    \"cast can be replaced by coercion; this might \\\n+                     require {type_asc_or}a temporary variable\"\n+                ))\n+            },\n+        );\n     }\n \n     #[instrument(skip(fcx), level = \"debug\")]\n@@ -1074,12 +1080,12 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 lint::builtin::CENUM_IMPL_DROP_CAST,\n                 self.expr.hir_id,\n                 self.span,\n-                |err| {\n-                    err.build(&format!(\n-                        \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n-                        self.expr_ty, self.cast_ty\n-                    ))\n-                    .emit();\n+                DelayDm(|| format!(\n+                    \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n+                    self.expr_ty, self.cast_ty\n+                )),\n+                |lint| {\n+                    lint\n                 },\n             );\n         }\n@@ -1090,12 +1096,11 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             lint::builtin::LOSSY_PROVENANCE_CASTS,\n             self.expr.hir_id,\n             self.span,\n-            |err| {\n-                let mut err = err.build(&format!(\n+            DelayDm(|| format!(\n                     \"under strict provenance it is considered bad style to cast pointer `{}` to integer `{}`\",\n                     self.expr_ty, self.cast_ty\n-                ));\n-\n+                )),\n+            |lint| {\n                 let msg = \"use `.addr()` to obtain the address of a pointer\";\n \n                 let expr_prec = self.expr.precedence().order();\n@@ -1114,22 +1119,22 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         (cast_span, format!(\").addr(){scalar_cast}\")),\n                     ];\n \n-                    err.multipart_suggestion(msg, suggestions, Applicability::MaybeIncorrect);\n+                    lint.multipart_suggestion(msg, suggestions, Applicability::MaybeIncorrect);\n                 } else {\n-                    err.span_suggestion(\n+                    lint.span_suggestion(\n                         cast_span,\n                         msg,\n                         format!(\".addr(){scalar_cast}\"),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n \n-                err.help(\n+                lint.help(\n                     \"if you can't comply with strict provenance and need to expose the pointer \\\n                     provenance you can use `.expose_addr()` instead\"\n                 );\n \n-                err.emit();\n+                lint\n             },\n         );\n     }\n@@ -1139,24 +1144,24 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             lint::builtin::FUZZY_PROVENANCE_CASTS,\n             self.expr.hir_id,\n             self.span,\n-            |err| {\n-                let mut err = err.build(&format!(\n-                    \"strict provenance disallows casting integer `{}` to pointer `{}`\",\n-                    self.expr_ty, self.cast_ty\n-                ));\n+            DelayDm(|| format!(\n+                \"strict provenance disallows casting integer `{}` to pointer `{}`\",\n+                self.expr_ty, self.cast_ty\n+            )),\n+            |lint| {\n                 let msg = \"use `.with_addr()` to adjust a valid pointer in the same allocation, to this address\";\n                 let suggestions = vec![\n                     (self.expr_span.shrink_to_lo(), String::from(\"(...).with_addr(\")),\n                     (self.expr_span.shrink_to_hi().to(self.cast_span), String::from(\")\")),\n                 ];\n \n-                err.multipart_suggestion(msg, suggestions, Applicability::MaybeIncorrect);\n-                err.help(\n+                lint.multipart_suggestion(msg, suggestions, Applicability::MaybeIncorrect);\n+                lint.help(\n                     \"if you can't comply with strict provenance and don't have a pointer with \\\n                     the correct provenance you can use `std::ptr::from_exposed_addr()` instead\"\n                  );\n \n-                err.emit();\n+                lint\n             },\n         );\n     }"}, {"sha": "60a4904373e965dbf031c17a5378fee3801ed16f", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -48,9 +48,13 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n             .emit();\n         }\n         None => {\n-            tcx.struct_span_lint_hir(UNSUPPORTED_CALLING_CONVENTIONS, hir_id, span, |lint| {\n-                lint.build(\"use of calling convention not supported on this target\").emit();\n-            });\n+            tcx.struct_span_lint_hir(\n+                UNSUPPORTED_CALLING_CONVENTIONS,\n+                hir_id,\n+                span,\n+                \"use of calling convention not supported on this target\",\n+                |lint| lint,\n+            );\n         }\n     }\n \n@@ -510,10 +514,10 @@ fn check_static_inhabited<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n             UNINHABITED_STATIC,\n             tcx.hir().local_def_id_to_hir_id(def_id),\n             span,\n+            \"static of uninhabited type\",\n             |lint| {\n-                lint.build(\"static of uninhabited type\")\n+                lint\n                 .note(\"uninhabited statics cannot be initialized, and any access would be an immediate error\")\n-                .emit();\n             },\n         );\n     }\n@@ -1434,17 +1438,17 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n                 REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n                 tcx.hir().local_def_id_to_hir_id(adt.did().expect_local()),\n                 span,\n+                \"zero-sized fields in `repr(transparent)` cannot contain external non-exhaustive types\",\n                 |lint| {\n                     let note = if non_exhaustive {\n                         \"is marked with `#[non_exhaustive]`\"\n                     } else {\n                         \"contains private fields\"\n                     };\n                     let field_ty = tcx.def_path_str_with_substs(def_id, substs);\n-                    lint.build(\"zero-sized fields in repr(transparent) cannot contain external non-exhaustive types\")\n+                    lint\n                         .note(format!(\"this {descr} contains `{field_ty}`, which {note}, \\\n                             and makes it not a breaking change to become non-zero-sized in the future.\"))\n-                        .emit();\n                 },\n             )\n         }"}, {"sha": "4bd5e9f6ab5797717435c00382acd4e8684c38bf", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -58,17 +58,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-                self.tcx().struct_span_lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, |lint| {\n-                    let msg = format!(\"unreachable {}\", kind);\n-                    lint.build(&msg)\n-                        .span_label(span, &msg)\n-                        .span_label(\n+                let msg = format!(\"unreachable {}\", kind);\n+                self.tcx().struct_span_lint_hir(\n+                    lint::builtin::UNREACHABLE_CODE,\n+                    id,\n+                    span,\n+                    &msg,\n+                    |lint| {\n+                        lint.span_label(span, &msg).span_label(\n                             orig_span,\n                             custom_note\n                                 .unwrap_or(\"any code following this expression is unreachable\"),\n                         )\n-                        .emit();\n-                })\n+                    },\n+                )\n             }\n         }\n     }"}, {"sha": "898419b5b237450ec2b62f9bc95001bbf6dbfaeb", "filename": "compiler/rustc_hir_analysis/src/check/generator_interior.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -6,7 +6,7 @@\n use self::drop_ranges::DropRanges;\n use super::FnCtxt;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n-use rustc_errors::pluralize;\n+use rustc_errors::{pluralize, DelayDm};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -610,33 +610,33 @@ fn check_must_not_suspend_def(\n             rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n             hir_id,\n             data.source_span,\n-            |lint| {\n-                let msg = format!(\n+            DelayDm(|| {\n+                format!(\n                     \"{}`{}`{} held across a suspend point, but should not be\",\n                     data.descr_pre,\n                     tcx.def_path_str(def_id),\n                     data.descr_post,\n-                );\n-                let mut err = lint.build(&msg);\n-\n+                )\n+            }),\n+            |lint| {\n                 // add span pointing to the offending yield/await\n-                err.span_label(data.yield_span, \"the value is held across this suspend point\");\n+                lint.span_label(data.yield_span, \"the value is held across this suspend point\");\n \n                 // Add optional reason note\n                 if let Some(note) = attr.value_str() {\n                     // FIXME(guswynn): consider formatting this better\n-                    err.span_note(data.source_span, note.as_str());\n+                    lint.span_note(data.source_span, note.as_str());\n                 }\n \n                 // Add some quick suggestions on what to do\n                 // FIXME: can `drop` work as a suggestion here as well?\n-                err.span_help(\n+                lint.span_help(\n                     data.source_span,\n                     \"consider using a block (`{ ... }`) \\\n                     to shrink the value's scope, ending before the suspend point\",\n                 );\n \n-                err.emit();\n+                lint\n             },\n         );\n "}, {"sha": "c604c8af8d25d6aff1f664f9637735484083e622", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -328,17 +328,16 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                     lint::builtin::ASM_SUB_REGISTER,\n                     expr.hir_id,\n                     spans,\n+                    \"formatting may not be suitable for sub-register argument\",\n                     |lint| {\n-                        let msg = \"formatting may not be suitable for sub-register argument\";\n-                        let mut err = lint.build(msg);\n-                        err.span_label(expr.span, \"for this argument\");\n-                        err.help(&format!(\n+                        lint.span_label(expr.span, \"for this argument\");\n+                        lint.help(&format!(\n                             \"use `{{{idx}:{suggested_modifier}}}` to have the register formatted as `{suggested_result}`\",\n                         ));\n-                        err.help(&format!(\n+                        lint.help(&format!(\n                             \"or use `{{{idx}:{default_modifier}}}` to keep the default formatting of `{default_result}`\",\n                         ));\n-                        err.emit();\n+                        lint\n                     },\n                 );\n             }"}, {"sha": "ca4cdf5a0d01c9b010216e0936f8d33f1ae10303", "filename": "compiler/rustc_hir_analysis/src/check/method/prelude2021.rs", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -82,14 +82,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 prelude_or_array_lint,\n                 self_expr.hir_id,\n                 self_expr.span,\n+                format!(\"trait method `{}` will become ambiguous in Rust 2021\", segment.ident.name),\n                 |lint| {\n                     let sp = self_expr.span;\n \n-                    let mut lint = lint.build(&format!(\n-                        \"trait method `{}` will become ambiguous in Rust 2021\",\n-                        segment.ident.name\n-                    ));\n-\n                     let derefs = \"*\".repeat(pick.autoderefs);\n \n                     let autoref = match pick.autoref_or_ptr_adjustment {\n@@ -133,7 +129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                     }\n \n-                    lint.emit();\n+                    lint\n                 },\n             );\n         } else {\n@@ -143,6 +139,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 prelude_or_array_lint,\n                 call_expr.hir_id,\n                 call_expr.span,\n+                format!(\"trait method `{}` will become ambiguous in Rust 2021\", segment.ident.name),\n                 |lint| {\n                     let sp = call_expr.span;\n                     let trait_name = self.trait_path_or_bare_name(\n@@ -151,11 +148,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         pick.item.container_id(self.tcx),\n                     );\n \n-                    let mut lint = lint.build(&format!(\n-                        \"trait method `{}` will become ambiguous in Rust 2021\",\n-                        segment.ident.name\n-                    ));\n-\n                     let (self_adjusted, precise) = self.adjust_expr(pick, self_expr, sp);\n                     if precise {\n                         let args = args\n@@ -202,7 +194,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                     }\n \n-                    lint.emit();\n+                    lint\n                 },\n             );\n         }\n@@ -257,15 +249,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        self.tcx.struct_span_lint_hir(RUST_2021_PRELUDE_COLLISIONS, expr_id, span, |lint| {\n-            // \"type\" refers to either a type or, more likely, a trait from which\n-            // the associated function or method is from.\n-            let container_id = pick.item.container_id(self.tcx);\n-            let trait_path = self.trait_path_or_bare_name(span, expr_id, container_id);\n-            let trait_generics = self.tcx.generics_of(container_id);\n-\n-            let trait_name =\n-                if trait_generics.params.len() <= trait_generics.has_self as usize {\n+        self.tcx.struct_span_lint_hir(\n+            RUST_2021_PRELUDE_COLLISIONS,\n+            expr_id,\n+            span,\n+            format!(\n+                \"trait-associated function `{}` will become ambiguous in Rust 2021\",\n+                method_name.name\n+            ),\n+            |lint| {\n+                // \"type\" refers to either a type or, more likely, a trait from which\n+                // the associated function or method is from.\n+                let container_id = pick.item.container_id(self.tcx);\n+                let trait_path = self.trait_path_or_bare_name(span, expr_id, container_id);\n+                let trait_generics = self.tcx.generics_of(container_id);\n+\n+                let trait_name = if trait_generics.params.len() <= trait_generics.has_self as usize\n+                {\n                     trait_path\n                 } else {\n                     let counts = trait_generics.own_counts();\n@@ -282,44 +282,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     )\n                 };\n \n-            let mut lint = lint.build(&format!(\n-                \"trait-associated function `{}` will become ambiguous in Rust 2021\",\n-                method_name.name\n-            ));\n-\n-            let mut self_ty_name = self_ty_span\n-                .find_ancestor_inside(span)\n-                .and_then(|span| self.sess().source_map().span_to_snippet(span).ok())\n-                .unwrap_or_else(|| self_ty.to_string());\n-\n-            // Get the number of generics the self type has (if an Adt) unless we can determine that\n-            // the user has written the self type with generics already which we (naively) do by looking\n-            // for a \"<\" in `self_ty_name`.\n-            if !self_ty_name.contains('<') {\n-                if let Adt(def, _) = self_ty.kind() {\n-                    let generics = self.tcx.generics_of(def.did());\n-                    if !generics.params.is_empty() {\n-                        let counts = generics.own_counts();\n-                        self_ty_name += &format!(\n-                            \"<{}>\",\n-                            std::iter::repeat(\"'_\")\n-                                .take(counts.lifetimes)\n-                                .chain(std::iter::repeat(\"_\").take(counts.types + counts.consts))\n-                                .collect::<Vec<_>>()\n-                                .join(\", \")\n-                        );\n+                let mut self_ty_name = self_ty_span\n+                    .find_ancestor_inside(span)\n+                    .and_then(|span| self.sess().source_map().span_to_snippet(span).ok())\n+                    .unwrap_or_else(|| self_ty.to_string());\n+\n+                // Get the number of generics the self type has (if an Adt) unless we can determine that\n+                // the user has written the self type with generics already which we (naively) do by looking\n+                // for a \"<\" in `self_ty_name`.\n+                if !self_ty_name.contains('<') {\n+                    if let Adt(def, _) = self_ty.kind() {\n+                        let generics = self.tcx.generics_of(def.did());\n+                        if !generics.params.is_empty() {\n+                            let counts = generics.own_counts();\n+                            self_ty_name += &format!(\n+                                \"<{}>\",\n+                                std::iter::repeat(\"'_\")\n+                                    .take(counts.lifetimes)\n+                                    .chain(\n+                                        std::iter::repeat(\"_\").take(counts.types + counts.consts)\n+                                    )\n+                                    .collect::<Vec<_>>()\n+                                    .join(\", \")\n+                            );\n+                        }\n                     }\n                 }\n-            }\n-            lint.span_suggestion(\n-                span,\n-                \"disambiguate the associated function\",\n-                format!(\"<{} as {}>::{}\", self_ty_name, trait_name, method_name.name,),\n-                Applicability::MachineApplicable,\n-            );\n-\n-            lint.emit();\n-        });\n+                lint.span_suggestion(\n+                    span,\n+                    \"disambiguate the associated function\",\n+                    format!(\"<{} as {}>::{}\", self_ty_name, trait_name, method_name.name,),\n+                    Applicability::MachineApplicable,\n+                );\n+\n+                lint\n+            },\n+        );\n     }\n \n     fn trait_path_or_bare_name("}, {"sha": "a761a93dea4b6882b9987218631c9f7f418a9f47", "filename": "compiler/rustc_hir_analysis/src/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -409,9 +409,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         lint::builtin::TYVAR_BEHIND_RAW_POINTER,\n                         scope_expr_id,\n                         span,\n-                        |lint| {\n-                            lint.build(\"type annotations needed\").emit();\n-                        },\n+                        \"type annotations needed\",\n+                        |lint| lint,\n                     );\n                 }\n             } else {\n@@ -1358,32 +1357,32 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         stable_pick: &Pick<'_>,\n         unstable_candidates: &[(Candidate<'tcx>, Symbol)],\n     ) {\n+        let def_kind = stable_pick.item.kind.as_def_kind();\n         self.tcx.struct_span_lint_hir(\n             lint::builtin::UNSTABLE_NAME_COLLISIONS,\n             self.scope_expr_id,\n             self.span,\n+            format!(\n+                \"{} {} with this name may be added to the standard library in the future\",\n+                def_kind.article(),\n+                def_kind.descr(stable_pick.item.def_id),\n+            ),\n             |lint| {\n-                let def_kind = stable_pick.item.kind.as_def_kind();\n-                let mut diag = lint.build(&format!(\n-                    \"{} {} with this name may be added to the standard library in the future\",\n-                    def_kind.article(),\n-                    def_kind.descr(stable_pick.item.def_id),\n-                ));\n                 match (stable_pick.item.kind, stable_pick.item.container) {\n                     (ty::AssocKind::Fn, _) => {\n                         // FIXME: This should be a `span_suggestion` instead of `help`\n                         // However `self.span` only\n                         // highlights the method name, so we can't use it. Also consider reusing\n                         // the code from `report_method_error()`.\n-                        diag.help(&format!(\n+                        lint.help(&format!(\n                             \"call with fully qualified syntax `{}(...)` to keep using the current \\\n                              method\",\n                             self.tcx.def_path_str(stable_pick.item.def_id),\n                         ));\n                     }\n                     (ty::AssocKind::Const, ty::AssocItemContainer::TraitContainer) => {\n                         let def_id = stable_pick.item.container_id(self.tcx);\n-                        diag.span_suggestion(\n+                        lint.span_suggestion(\n                             self.span,\n                             \"use the fully qualified path to the associated const\",\n                             format!(\n@@ -1399,15 +1398,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n                 if self.tcx.sess.is_nightly_build() {\n                     for (candidate, feature) in unstable_candidates {\n-                        diag.help(&format!(\n+                        lint.help(&format!(\n                             \"add `#![feature({})]` to the crate attributes to enable `{}`\",\n                             feature,\n                             self.tcx.def_path_str(candidate.item.def_id),\n                         ));\n                     }\n                 }\n \n-                diag.emit();\n+                lint\n             },\n         );\n     }"}, {"sha": "178326cfdc4fb96e79b030a69b94eb7696047441", "filename": "compiler/rustc_hir_analysis/src/check/pat.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fpat.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -1790,18 +1790,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             &unmentioned_fields.iter().map(|(_, i)| i).collect::<Vec<_>>(),\n         );\n \n-        self.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, pat.hir_id, pat.span, |build| {\n-        let mut lint = build.build(\"some fields are not explicitly listed\");\n+        self.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, pat.hir_id, pat.span, \"some fields are not explicitly listed\", |lint| {\n         lint.span_label(pat.span, format!(\"field{} {} not listed\", rustc_errors::pluralize!(unmentioned_fields.len()), joined_patterns));\n-\n         lint.help(\n             \"ensure that all fields are mentioned explicitly by adding the suggested fields\",\n         );\n         lint.note(&format!(\n             \"the pattern is of type `{}` and the `non_exhaustive_omitted_patterns` attribute was found\",\n             ty,\n         ));\n-        lint.emit();\n+\n+        lint\n     });\n     }\n "}, {"sha": "4f4956416917331b61a62f8eddce02459bc4eaa6", "filename": "compiler/rustc_hir_analysis/src/check/upvar.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fupvar.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -749,24 +749,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 lint::builtin::RUST_2021_INCOMPATIBLE_CLOSURE_CAPTURES,\n                 closure_hir_id,\n                 closure_head_span,\n+                reasons.migration_message(),\n                 |lint| {\n-                    let mut diagnostics_builder = lint.build(\n-                        &reasons.migration_message(),\n-                    );\n                     for NeededMigration { var_hir_id, diagnostics_info } in &need_migrations {\n                         // Labels all the usage of the captured variable and why they are responsible\n                         // for migration being needed\n                         for lint_note in diagnostics_info.iter() {\n                             match &lint_note.captures_info {\n                                 UpvarMigrationInfo::CapturingPrecise { source_expr: Some(capture_expr_id), var_name: captured_name } => {\n                                     let cause_span = self.tcx.hir().span(*capture_expr_id);\n-                                    diagnostics_builder.span_label(cause_span, format!(\"in Rust 2018, this closure captures all of `{}`, but in Rust 2021, it will only capture `{}`\",\n+                                    lint.span_label(cause_span, format!(\"in Rust 2018, this closure captures all of `{}`, but in Rust 2021, it will only capture `{}`\",\n                                         self.tcx.hir().name(*var_hir_id),\n                                         captured_name,\n                                     ));\n                                 }\n                                 UpvarMigrationInfo::CapturingNothing { use_span } => {\n-                                    diagnostics_builder.span_label(*use_span, format!(\"in Rust 2018, this causes the closure to capture `{}`, but in Rust 2021, it has no effect\",\n+                                    lint.span_label(*use_span, format!(\"in Rust 2018, this causes the closure to capture `{}`, but in Rust 2021, it has no effect\",\n                                         self.tcx.hir().name(*var_hir_id),\n                                     ));\n                                 }\n@@ -781,13 +779,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                                 match &lint_note.captures_info {\n                                     UpvarMigrationInfo::CapturingPrecise { var_name: captured_name, .. } => {\n-                                        diagnostics_builder.span_label(drop_location_span, format!(\"in Rust 2018, `{}` is dropped here, but in Rust 2021, only `{}` will be dropped here as part of the closure\",\n+                                        lint.span_label(drop_location_span, format!(\"in Rust 2018, `{}` is dropped here, but in Rust 2021, only `{}` will be dropped here as part of the closure\",\n                                             self.tcx.hir().name(*var_hir_id),\n                                             captured_name,\n                                         ));\n                                     }\n                                     UpvarMigrationInfo::CapturingNothing { use_span: _ } => {\n-                                        diagnostics_builder.span_label(drop_location_span, format!(\"in Rust 2018, `{v}` is dropped here along with the closure, but in Rust 2021 `{v}` is not part of the closure\",\n+                                        lint.span_label(drop_location_span, format!(\"in Rust 2018, `{v}` is dropped here along with the closure, but in Rust 2021 `{v}` is not part of the closure\",\n                                             v = self.tcx.hir().name(*var_hir_id),\n                                         ));\n                                     }\n@@ -800,7 +798,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 match &lint_note.captures_info {\n                                     UpvarMigrationInfo::CapturingPrecise { var_name: captured_name, .. } => {\n                                         let var_name = self.tcx.hir().name(*var_hir_id);\n-                                        diagnostics_builder.span_label(closure_head_span, format!(\"\\\n+                                        lint.span_label(closure_head_span, format!(\"\\\n                                         in Rust 2018, this closure implements {missing_trait} \\\n                                         as `{var_name}` implements {missing_trait}, but in Rust 2021, \\\n                                         this closure will no longer implement {missing_trait} \\\n@@ -814,7 +812,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    diagnostics_builder.note(\"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\");\n+                    lint.note(\"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\");\n \n                     let diagnostic_msg = format!(\n                         \"add a dummy let to cause {} to be fully captured\",\n@@ -857,7 +855,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // We take the indentation from the next non-empty line.\n                             let line2 = lines.find(|line| !line.is_empty()).unwrap_or_default();\n                             let indent = line2.split_once(|c: char| !c.is_whitespace()).unwrap_or_default().0;\n-                            diagnostics_builder.span_suggestion(\n+                            lint.span_suggestion(\n                                 closure_body_span.with_lo(closure_body_span.lo() + BytePos::from_usize(line1.len())).shrink_to_lo(),\n                                 &diagnostic_msg,\n                                 format!(\"\\n{indent}{migration_string};\"),\n@@ -868,7 +866,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // braces, but with more than just the opening\n                             // brace on the first line. We put the `let`\n                             // directly after the `{`.\n-                            diagnostics_builder.span_suggestion(\n+                            lint.span_suggestion(\n                                 closure_body_span.with_lo(closure_body_span.lo() + BytePos(1)).shrink_to_lo(),\n                                 &diagnostic_msg,\n                                 format!(\" {migration_string};\"),\n@@ -877,7 +875,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             // This is a closure without braces around the body.\n                             // We add braces to add the `let` before the body.\n-                            diagnostics_builder.multipart_suggestion(\n+                            lint.multipart_suggestion(\n                                 &diagnostic_msg,\n                                 vec![\n                                     (closure_body_span.shrink_to_lo(), format!(\"{{ {migration_string}; \")),\n@@ -887,15 +885,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             );\n                         }\n                     } else {\n-                        diagnostics_builder.span_suggestion(\n+                        lint.span_suggestion(\n                             closure_span,\n                             &diagnostic_msg,\n                             migration_string,\n                             Applicability::HasPlaceholders\n                         );\n                     }\n \n-                    diagnostics_builder.emit();\n+                    lint\n                 },\n             );\n         }"}, {"sha": "922833f85806cb30fae864152be3d04e0d02e00e", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -29,14 +29,18 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n             continue;\n         }\n         let hir::ItemKind::Use(path, _) = item.kind else { unreachable!() };\n-        tcx.struct_span_lint_hir(lint::builtin::UNUSED_IMPORTS, item.hir_id(), path.span, |lint| {\n-            let msg = if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(path.span) {\n-                format!(\"unused import: `{}`\", snippet)\n-            } else {\n-                \"unused import\".to_owned()\n-            };\n-            lint.build(&msg).emit();\n-        });\n+        let msg = if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(path.span) {\n+            format!(\"unused import: `{}`\", snippet)\n+        } else {\n+            \"unused import\".to_owned()\n+        };\n+        tcx.struct_span_lint_hir(\n+            lint::builtin::UNUSED_IMPORTS,\n+            item.hir_id(),\n+            path.span,\n+            msg,\n+            |lint| lint,\n+        );\n     }\n \n     unused_crates_lint(tcx);"}, {"sha": "1307f74f2107196135377179bc27ddde2130440f", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -2,7 +2,7 @@\n //! crate or pertains to a type defined in this crate.\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n+use rustc_errors::{struct_span_err, DelayDm};\n use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_middle::ty::subst::GenericArgKind;\n@@ -412,30 +412,31 @@ fn lint_auto_trait_impl<'tcx>(\n         lint::builtin::SUSPICIOUS_AUTO_TRAIT_IMPLS,\n         tcx.hir().local_def_id_to_hir_id(impl_def_id),\n         tcx.def_span(impl_def_id),\n-        |err| {\n-            let item_span = tcx.def_span(self_type_did);\n-            let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n-            let mut err = err.build(&format!(\n+        DelayDm(|| {\n+            format!(\n                 \"cross-crate traits with a default impl, like `{}`, \\\n                          should not be specialized\",\n                 tcx.def_path_str(trait_ref.def_id),\n-            ));\n+            )\n+        }),\n+        |lint| {\n+            let item_span = tcx.def_span(self_type_did);\n+            let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n             match arg {\n                 ty::util::NotUniqueParam::DuplicateParam(arg) => {\n-                    err.note(&format!(\"`{}` is mentioned multiple times\", arg));\n+                    lint.note(&format!(\"`{}` is mentioned multiple times\", arg));\n                 }\n                 ty::util::NotUniqueParam::NotParam(arg) => {\n-                    err.note(&format!(\"`{}` is not a generic parameter\", arg));\n+                    lint.note(&format!(\"`{}` is not a generic parameter\", arg));\n                 }\n             }\n-            err.span_note(\n+            lint.span_note(\n                 item_span,\n                 &format!(\n                     \"try using the same sequence of generic parameters as the {} definition\",\n                     self_descr,\n                 ),\n-            );\n-            err.emit();\n+            )\n         },\n     );\n }"}, {"sha": "ab4b861b6cb6081299a2dff365f08c3b120ac205", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -2067,11 +2067,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                     lint::builtin::INLINE_NO_SANITIZE,\n                     hir_id,\n                     no_sanitize_span,\n-                    |lint| {\n-                        lint.build(\"`no_sanitize` will have no effect after inlining\")\n-                            .span_note(inline_span, \"inlining requested here\")\n-                            .emit();\n-                    },\n+                    \"`no_sanitize` will have no effect after inlining\",\n+                    |lint| lint.span_note(inline_span, \"inlining requested here\"),\n                 )\n             }\n         }"}, {"sha": "7ffacbecf5f021d2cbfb8e3709c13e70f59650b7", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -266,9 +266,8 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                             lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n                             param.hir_id,\n                             param.span,\n-                            |lint| {\n-                                lint.build(TYPE_DEFAULT_NOT_ALLOWED).emit();\n-                            },\n+                            TYPE_DEFAULT_NOT_ALLOWED,\n+                            |lint| lint,\n                         );\n                     }\n                     Defaults::Deny => {"}, {"sha": "bd6b637f76fcdd88a9526b2cff54c7ada93343df", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -118,37 +118,41 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n                 // to an array or to a slice.\n                 _ => bug!(\"array type coerced to something other than array or slice\"),\n             };\n-            cx.struct_span_lint(ARRAY_INTO_ITER, call.ident.span, |lint| {\n-                let mut diag = lint.build(fluent::lint::array_into_iter);\n-                diag.set_arg(\"target\", target);\n-                diag.span_suggestion(\n-                    call.ident.span,\n-                    fluent::lint::use_iter_suggestion,\n-                    \"iter\",\n-                    Applicability::MachineApplicable,\n-                );\n-                if self.for_expr_span == expr.span {\n+            cx.struct_span_lint(\n+                ARRAY_INTO_ITER,\n+                call.ident.span,\n+                fluent::lint::array_into_iter,\n+                |diag| {\n+                    diag.set_arg(\"target\", target);\n                     diag.span_suggestion(\n-                        receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n-                        fluent::lint::remove_into_iter_suggestion,\n-                        \"\",\n-                        Applicability::MaybeIncorrect,\n+                        call.ident.span,\n+                        fluent::lint::use_iter_suggestion,\n+                        \"iter\",\n+                        Applicability::MachineApplicable,\n                     );\n-                } else if receiver_ty.is_array() {\n-                    diag.multipart_suggestion(\n-                        fluent::lint::use_explicit_into_iter_suggestion,\n-                        vec![\n-                            (expr.span.shrink_to_lo(), \"IntoIterator::into_iter(\".into()),\n-                            (\n-                                receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n-                                \")\".into(),\n-                            ),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                diag.emit();\n-            })\n+                    if self.for_expr_span == expr.span {\n+                        diag.span_suggestion(\n+                            receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n+                            fluent::lint::remove_into_iter_suggestion,\n+                            \"\",\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else if receiver_ty.is_array() {\n+                        diag.multipart_suggestion(\n+                            fluent::lint::use_explicit_into_iter_suggestion,\n+                            vec![\n+                                (expr.span.shrink_to_lo(), \"IntoIterator::into_iter(\".into()),\n+                                (\n+                                    receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n+                                    \")\".into(),\n+                                ),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    diag\n+                },\n+            )\n         }\n     }\n }"}, {"sha": "f28cfbd8b4c46ada549d67685bc848a72bebc933", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 341, "deletions": 282, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -33,8 +33,8 @@ use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n-    fluent, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString,\n-    LintDiagnosticBuilder, MultiSpan,\n+    fluent, Applicability, DelayDm, Diagnostic, DiagnosticBuilder, DiagnosticMessage,\n+    DiagnosticStyledString, MultiSpan,\n };\n use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, GateIssue, Stability};\n use rustc_hir as hir;\n@@ -103,9 +103,12 @@ impl EarlyLintPass for WhileTrue {\n             && !lit.span.from_expansion()\n         {\n             let condition_span = e.span.with_hi(cond.span.hi());\n-            cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n-                lint.build(fluent::lint::builtin_while_true)\n-                    .span_suggestion_short(\n+            cx.struct_span_lint(\n+                            WHILE_TRUE,\n+                            condition_span,\n+                fluent::lint::builtin_while_true,\n+                            |lint| {\n+                    lint.span_suggestion_short(\n                         condition_span,\n                         fluent::lint::suggestion,\n                         format!(\n@@ -117,8 +120,8 @@ impl EarlyLintPass for WhileTrue {\n                         ),\n                         Applicability::MachineApplicable,\n                     )\n-                    .emit();\n-            })\n+                },\n+            )\n         }\n     }\n }\n@@ -154,9 +157,12 @@ impl BoxPointers {\n         for leaf in ty.walk() {\n             if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n                 if leaf_ty.is_box() {\n-                    cx.struct_span_lint(BOX_POINTERS, span, |lint| {\n-                        lint.build(fluent::lint::builtin_box_pointers).set_arg(\"ty\", ty).emit();\n-                    });\n+                    cx.struct_span_lint(\n+                        BOX_POINTERS,\n+                        span,\n+                        fluent::lint::builtin_box_pointers,\n+                        |lint| lint.set_arg(\"ty\", ty),\n+                    );\n                 }\n             }\n         }\n@@ -255,19 +261,21 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                     if cx.tcx.find_field_index(ident, &variant)\n                         == Some(cx.tcx.field_index(fieldpat.hir_id, cx.typeck_results()))\n                     {\n-                        cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span, |lint| {\n-                            let suggested_ident =\n-                                format!(\"{}{}\", binding_annot.prefix_str(), ident);\n-                            lint.build(fluent::lint::builtin_non_shorthand_field_patterns)\n-                                .set_arg(\"ident\", ident.clone())\n-                                .span_suggestion(\n+                        cx.struct_span_lint(\n+                            NON_SHORTHAND_FIELD_PATTERNS,\n+                            fieldpat.span,\n+                            fluent::lint::builtin_non_shorthand_field_patterns,\n+                            |lint| {\n+                                let suggested_ident =\n+                                    format!(\"{}{}\", binding_annot.prefix_str(), ident);\n+                                lint.set_arg(\"ident\", ident.clone()).span_suggestion(\n                                     fieldpat.span,\n                                     fluent::lint::suggestion,\n                                     suggested_ident,\n                                     Applicability::MachineApplicable,\n                                 )\n-                                .emit();\n-                        });\n+                            },\n+                        );\n                     }\n                 }\n             }\n@@ -307,14 +315,17 @@ impl UnsafeCode {\n         &self,\n         cx: &EarlyContext<'_>,\n         span: Span,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n     ) {\n         // This comes from a macro that has `#[allow_internal_unsafe]`.\n         if span.allows_unsafe() {\n             return;\n         }\n \n-        cx.struct_span_lint(UNSAFE_CODE, span, decorate);\n+        cx.struct_span_lint(UNSAFE_CODE, span, msg, decorate);\n     }\n \n     fn report_overridden_symbol_name(\n@@ -323,8 +334,8 @@ impl UnsafeCode {\n         span: Span,\n         msg: DiagnosticMessage,\n     ) {\n-        self.report_unsafe(cx, span, |lint| {\n-            lint.build(msg).note(fluent::lint::builtin_overridden_symbol_name).emit();\n+        self.report_unsafe(cx, span, msg, |lint| {\n+            lint.note(fluent::lint::builtin_overridden_symbol_name)\n         })\n     }\n \n@@ -334,43 +345,42 @@ impl UnsafeCode {\n         span: Span,\n         msg: DiagnosticMessage,\n     ) {\n-        self.report_unsafe(cx, span, |lint| {\n-            lint.build(msg).note(fluent::lint::builtin_overridden_symbol_section).emit();\n+        self.report_unsafe(cx, span, msg, |lint| {\n+            lint.note(fluent::lint::builtin_overridden_symbol_section)\n         })\n     }\n }\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         if attr.has_name(sym::allow_internal_unsafe) {\n-            self.report_unsafe(cx, attr.span, |lint| {\n-                lint.build(fluent::lint::builtin_allow_internal_unsafe).emit();\n-            });\n+            self.report_unsafe(\n+                cx,\n+                attr.span,\n+                fluent::lint::builtin_allow_internal_unsafe,\n+                |lint| lint,\n+            );\n         }\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n-                self.report_unsafe(cx, blk.span, |lint| {\n-                    lint.build(fluent::lint::builtin_unsafe_block).emit();\n-                });\n+                self.report_unsafe(cx, blk.span, fluent::lint::builtin_unsafe_block, |lint| lint);\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         match it.kind {\n-            ast::ItemKind::Trait(box ast::Trait { unsafety: ast::Unsafe::Yes(_), .. }) => self\n-                .report_unsafe(cx, it.span, |lint| {\n-                    lint.build(fluent::lint::builtin_unsafe_trait).emit();\n-                }),\n+            ast::ItemKind::Trait(box ast::Trait { unsafety: ast::Unsafe::Yes(_), .. }) => {\n+                self.report_unsafe(cx, it.span, fluent::lint::builtin_unsafe_trait, |lint| lint)\n+            }\n \n-            ast::ItemKind::Impl(box ast::Impl { unsafety: ast::Unsafe::Yes(_), .. }) => self\n-                .report_unsafe(cx, it.span, |lint| {\n-                    lint.build(fluent::lint::builtin_unsafe_impl).emit();\n-                }),\n+            ast::ItemKind::Impl(box ast::Impl { unsafety: ast::Unsafe::Yes(_), .. }) => {\n+                self.report_unsafe(cx, it.span, fluent::lint::builtin_unsafe_impl, |lint| lint)\n+            }\n \n             ast::ItemKind::Fn(..) => {\n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n@@ -463,9 +473,7 @@ impl EarlyLintPass for UnsafeCode {\n                 FnCtxt::Assoc(_) if body.is_none() => fluent::lint::builtin_decl_unsafe_method,\n                 FnCtxt::Assoc(_) => fluent::lint::builtin_impl_unsafe_method,\n             };\n-            self.report_unsafe(cx, span, |lint| {\n-                lint.build(msg).emit();\n-            });\n+            self.report_unsafe(cx, span, msg, |lint| lint);\n         }\n     }\n }\n@@ -566,12 +574,12 @@ impl MissingDoc {\n         let attrs = cx.tcx.hir().attrs(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n         let has_doc = attrs.iter().any(has_doc);\n         if !has_doc {\n-            cx.struct_span_lint(MISSING_DOCS, cx.tcx.def_span(def_id), |lint| {\n-                lint.build(fluent::lint::builtin_missing_doc)\n-                    .set_arg(\"article\", article)\n-                    .set_arg(\"desc\", desc)\n-                    .emit();\n-            });\n+            cx.struct_span_lint(\n+                MISSING_DOCS,\n+                cx.tcx.def_span(def_id),\n+                fluent::lint::builtin_missing_doc,\n+                |lint| lint.set_arg(\"article\", article).set_arg(\"desc\", desc),\n+            );\n         }\n     }\n }\n@@ -758,9 +766,12 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n         )\n         .is_ok()\n         {\n-            cx.struct_span_lint(MISSING_COPY_IMPLEMENTATIONS, item.span, |lint| {\n-                lint.build(fluent::lint::builtin_missing_copy_impl).emit();\n-            })\n+            cx.struct_span_lint(\n+                MISSING_COPY_IMPLEMENTATIONS,\n+                item.span,\n+                fluent::lint::builtin_missing_copy_impl,\n+                |lint| lint,\n+            )\n         }\n     }\n }\n@@ -834,11 +845,12 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n         }\n \n         if !self.impling_types.as_ref().unwrap().contains(&item.def_id.def_id) {\n-            cx.struct_span_lint(MISSING_DEBUG_IMPLEMENTATIONS, item.span, |lint| {\n-                lint.build(fluent::lint::builtin_missing_debug_impl)\n-                    .set_arg(\"debug\", cx.tcx.def_path_str(debug))\n-                    .emit();\n-            });\n+            cx.struct_span_lint(\n+                MISSING_DEBUG_IMPLEMENTATIONS,\n+                item.span,\n+                fluent::lint::builtin_missing_debug_impl,\n+                |lint| lint.set_arg(\"debug\", cx.tcx.def_path_str(debug)),\n+            );\n         }\n     }\n }\n@@ -906,24 +918,26 @@ impl EarlyLintPass for AnonymousParameters {\n             for arg in sig.decl.inputs.iter() {\n                 if let ast::PatKind::Ident(_, ident, None) = arg.pat.kind {\n                     if ident.name == kw::Empty {\n-                        cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n-                            let ty_snip = cx.sess().source_map().span_to_snippet(arg.ty.span);\n-\n-                            let (ty_snip, appl) = if let Ok(ref snip) = ty_snip {\n-                                (snip.as_str(), Applicability::MachineApplicable)\n-                            } else {\n-                                (\"<type>\", Applicability::HasPlaceholders)\n-                            };\n+                        let ty_snip = cx.sess().source_map().span_to_snippet(arg.ty.span);\n \n-                            lint.build(fluent::lint::builtin_anonymous_params)\n-                                .span_suggestion(\n+                        let (ty_snip, appl) = if let Ok(ref snip) = ty_snip {\n+                            (snip.as_str(), Applicability::MachineApplicable)\n+                        } else {\n+                            (\"<type>\", Applicability::HasPlaceholders)\n+                        };\n+                        cx.struct_span_lint(\n+                            ANONYMOUS_PARAMETERS,\n+                            arg.pat.span,\n+                            fluent::lint::builtin_anonymous_params,\n+                            |lint| {\n+                                lint.span_suggestion(\n                                     arg.pat.span,\n                                     fluent::lint::suggestion,\n                                     format!(\"_: {}\", ty_snip),\n                                     appl,\n                                 )\n-                                .emit();\n-                        })\n+                            },\n+                        )\n                     }\n                 }\n             }\n@@ -958,38 +972,44 @@ impl EarlyLintPass for DeprecatedAttr {\n                     _,\n                 ) = gate\n                 {\n-                    cx.struct_span_lint(DEPRECATED, attr.span, |lint| {\n-                        // FIXME(davidtwco) translatable deprecated attr\n-                        lint.build(fluent::lint::builtin_deprecated_attr_link)\n-                            .set_arg(\"name\", name)\n-                            .set_arg(\"reason\", reason)\n-                            .set_arg(\"link\", link)\n-                            .span_suggestion_short(\n-                                attr.span,\n-                                suggestion.map(|s| s.into()).unwrap_or(\n-                                    fluent::lint::builtin_deprecated_attr_default_suggestion,\n-                                ),\n-                                \"\",\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n-                    });\n+                    // FIXME(davidtwco) translatable deprecated attr\n+                    cx.struct_span_lint(\n+                        DEPRECATED,\n+                        attr.span,\n+                        fluent::lint::builtin_deprecated_attr_link,\n+                        |lint| {\n+                            lint.set_arg(\"name\", name)\n+                                .set_arg(\"reason\", reason)\n+                                .set_arg(\"link\", link)\n+                                .span_suggestion_short(\n+                                    attr.span,\n+                                    suggestion.map(|s| s.into()).unwrap_or(\n+                                        fluent::lint::builtin_deprecated_attr_default_suggestion,\n+                                    ),\n+                                    \"\",\n+                                    Applicability::MachineApplicable,\n+                                )\n+                        },\n+                    );\n                 }\n                 return;\n             }\n         }\n         if attr.has_name(sym::no_start) || attr.has_name(sym::crate_id) {\n-            cx.struct_span_lint(DEPRECATED, attr.span, |lint| {\n-                lint.build(fluent::lint::builtin_deprecated_attr_used)\n-                    .set_arg(\"name\", pprust::path_to_string(&attr.get_normal_item().path))\n-                    .span_suggestion_short(\n-                        attr.span,\n-                        fluent::lint::builtin_deprecated_attr_default_suggestion,\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-            });\n+            cx.struct_span_lint(\n+                DEPRECATED,\n+                attr.span,\n+                fluent::lint::builtin_deprecated_attr_used,\n+                |lint| {\n+                    lint.set_arg(\"name\", pprust::path_to_string(&attr.get_normal_item().path))\n+                        .span_suggestion_short(\n+                            attr.span,\n+                            fluent::lint::builtin_deprecated_attr_default_suggestion,\n+                            \"\",\n+                            Applicability::MachineApplicable,\n+                        )\n+                },\n+            );\n         }\n     }\n }\n@@ -1016,20 +1036,21 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n         let span = sugared_span.take().unwrap_or(attr.span);\n \n         if is_doc_comment || attr.has_name(sym::doc) {\n-            cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, |lint| {\n-                let mut err = lint.build(fluent::lint::builtin_unused_doc_comment);\n-                err.set_arg(\"kind\", node_kind);\n-                err.span_label(node_span, fluent::lint::label);\n-                match attr.kind {\n-                    AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n-                        err.help(fluent::lint::plain_help);\n-                    }\n-                    AttrKind::DocComment(CommentKind::Block, _) => {\n-                        err.help(fluent::lint::block_help);\n-                    }\n-                }\n-                err.emit();\n-            });\n+            cx.struct_span_lint(\n+                UNUSED_DOC_COMMENTS,\n+                span,\n+                fluent::lint::builtin_unused_doc_comment,\n+                |lint| {\n+                    lint.set_arg(\"kind\", node_kind).span_label(node_span, fluent::lint::label).help(\n+                        match attr.kind {\n+                            AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n+                                fluent::lint::plain_help\n+                            }\n+                            AttrKind::DocComment(CommentKind::Block, _) => fluent::lint::block_help,\n+                        },\n+                    )\n+                },\n+            );\n         }\n     }\n }\n@@ -1143,18 +1164,21 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n                     GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                        cx.struct_span_lint(NO_MANGLE_GENERIC_ITEMS, span, |lint| {\n-                            lint.build(fluent::lint::builtin_no_mangle_generic)\n-                                .span_suggestion_short(\n+                        cx.struct_span_lint(\n+                            NO_MANGLE_GENERIC_ITEMS,\n+                            span,\n+                            fluent::lint::builtin_no_mangle_generic,\n+                            |lint| {\n+                                lint.span_suggestion_short(\n                                     no_mangle_attr.span,\n                                     fluent::lint::suggestion,\n                                     \"\",\n                                     // Use of `#[no_mangle]` suggests FFI intent; correct\n                                     // fix may be to monomorphize source by hand\n                                     Applicability::MaybeIncorrect,\n                                 )\n-                                .emit();\n-                        });\n+                            },\n+                        );\n                         break;\n                     }\n                 }\n@@ -1170,27 +1194,29 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                 if cx.sess().contains_name(attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n-                    cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, |lint| {\n-                        let mut err = lint.build(fluent::lint::builtin_const_no_mangle);\n-\n-                        // account for \"pub const\" (#45562)\n-                        let start = cx\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(it.span)\n-                            .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n-                            .unwrap_or(0) as u32;\n-                        // `const` is 5 chars\n-                        let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n-                        err.span_suggestion(\n-                            const_span,\n-                            fluent::lint::suggestion,\n-                            \"pub static\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n-                    });\n+                    cx.struct_span_lint(\n+                        NO_MANGLE_CONST_ITEMS,\n+                        it.span,\n+                        fluent::lint::builtin_const_no_mangle,\n+                        |lint| {\n+                            // account for \"pub const\" (#45562)\n+                            let start = cx\n+                                .tcx\n+                                .sess\n+                                .source_map()\n+                                .span_to_snippet(it.span)\n+                                .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n+                                .unwrap_or(0) as u32;\n+                            // `const` is 5 chars\n+                            let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n+                            lint.span_suggestion(\n+                                const_span,\n+                                fluent::lint::suggestion,\n+                                \"pub static\",\n+                                Applicability::MachineApplicable,\n+                            )\n+                        },\n+                    );\n                 }\n             }\n             hir::ItemKind::Impl(hir::Impl { generics, items, .. }) => {\n@@ -1250,9 +1276,12 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n             if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n-                cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| {\n-                    lint.build(fluent::lint::builtin_mutable_transmutes).emit();\n-                });\n+                cx.struct_span_lint(\n+                    MUTABLE_TRANSMUTES,\n+                    expr.span,\n+                    fluent::lint::builtin_mutable_transmutes,\n+                    |lint| lint,\n+                );\n             }\n         }\n \n@@ -1300,9 +1329,12 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n         if attr.has_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n-                    cx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| {\n-                        lint.build(fluent::lint::builtin_unstable_features).emit();\n-                    });\n+                    cx.struct_span_lint(\n+                        UNSTABLE_FEATURES,\n+                        item.span(),\n+                        fluent::lint::builtin_unstable_features,\n+                        |lint| lint,\n+                    );\n                 }\n             }\n         }\n@@ -1361,21 +1393,25 @@ impl UnreachablePub {\n                 applicability = Applicability::MaybeIncorrect;\n             }\n             let def_span = cx.tcx.def_span(def_id);\n-            cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n-                let mut err = lint.build(fluent::lint::builtin_unreachable_pub);\n-                err.set_arg(\"what\", what);\n-\n-                err.span_suggestion(\n-                    vis_span,\n-                    fluent::lint::suggestion,\n-                    \"pub(crate)\",\n-                    applicability,\n-                );\n-                if exportable {\n-                    err.help(fluent::lint::help);\n-                }\n-                err.emit();\n-            });\n+            cx.struct_span_lint(\n+                UNREACHABLE_PUB,\n+                def_span,\n+                fluent::lint::builtin_unreachable_pub,\n+                |lint| {\n+                    lint.set_arg(\"what\", what);\n+\n+                    lint.span_suggestion(\n+                        vis_span,\n+                        fluent::lint::suggestion,\n+                        \"pub(crate)\",\n+                        applicability,\n+                    );\n+                    if exportable {\n+                        lint.help(fluent::lint::help);\n+                    }\n+                    lint\n+                },\n+            );\n         }\n     }\n }\n@@ -1505,36 +1541,34 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n \n         let mut suggested_changing_assoc_types = false;\n         if !where_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, |lint| {\n-                let mut err = lint.build(fluent::lint::builtin_type_alias_where_clause);\n-                err.set_span(where_spans);\n-                err.span_suggestion(\n+            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint::builtin_type_alias_where_clause, |lint| {\n+                lint.set_span(where_spans);\n+                lint.span_suggestion(\n                     type_alias_generics.where_clause_span,\n                     fluent::lint::suggestion,\n                     \"\",\n                     Applicability::MachineApplicable,\n                 );\n                 if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                    TypeAliasBounds::suggest_changing_assoc_types(ty, lint);\n                     suggested_changing_assoc_types = true;\n                 }\n-                err.emit();\n+                lint\n             });\n         }\n \n         if !inline_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, |lint| {\n-                let mut err = lint.build(fluent::lint::builtin_type_alias_generic_bounds);\n-                err.set_span(inline_spans);\n-                err.multipart_suggestion(\n+            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint::builtin_type_alias_generic_bounds, |lint| {\n+                lint.set_span(inline_spans);\n+                lint.multipart_suggestion(\n                     fluent::lint::suggestion,\n                     inline_sugg,\n                     Applicability::MachineApplicable,\n                 );\n                 if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                    TypeAliasBounds::suggest_changing_assoc_types(ty, lint);\n                 }\n-                err.emit();\n+                lint\n             });\n         }\n     }\n@@ -1633,12 +1667,15 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {\n-                    cx.struct_span_lint(TRIVIAL_BOUNDS, span, |lint| {\n-                        lint.build(fluent::lint::builtin_trivial_bounds)\n-                            .set_arg(\"predicate_kind_name\", predicate_kind_name)\n-                            .set_arg(\"predicate\", predicate)\n-                            .emit();\n-                    });\n+                    cx.struct_span_lint(\n+                        TRIVIAL_BOUNDS,\n+                        span,\n+                        fluent::lint::builtin_trivial_bounds,\n+                        |lint| {\n+                            lint.set_arg(\"predicate_kind_name\", predicate_kind_name)\n+                                .set_arg(\"predicate\", predicate)\n+                        },\n+                    );\n                 }\n             }\n         }\n@@ -1754,15 +1791,13 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                         replace,\n                     });\n                 } else {\n-                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, |lint| {\n-                        lint.build(msg)\n-                            .span_suggestion(\n-                                pat.span,\n-                                suggestion,\n-                                replace,\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, msg, |lint| {\n+                        lint.span_suggestion(\n+                            pat.span,\n+                            suggestion,\n+                            replace,\n+                            Applicability::MachineApplicable,\n+                        )\n                     });\n                 }\n             } else {\n@@ -1774,15 +1809,13 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                         replace: replace.to_string(),\n                     });\n                 } else {\n-                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, |lint| {\n-                        lint.build(msg)\n-                            .span_suggestion_short(\n-                                join,\n-                                suggestion,\n-                                replace,\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, msg, |lint| {\n+                        lint.span_suggestion_short(\n+                            join,\n+                            suggestion,\n+                            replace,\n+                            Applicability::MachineApplicable,\n+                        )\n                     });\n                 }\n             };\n@@ -1863,9 +1896,12 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n-            cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| {\n-                lint.build(fluent::lint::builtin_unnameable_test_items).emit();\n-            });\n+            cx.struct_span_lint(\n+                UNNAMEABLE_TEST_ITEMS,\n+                attr.span,\n+                fluent::lint::builtin_unnameable_test_items,\n+                |lint| lint,\n+            );\n         }\n     }\n \n@@ -1981,18 +2017,19 @@ impl KeywordIdents {\n             return;\n         }\n \n-        cx.struct_span_lint(KEYWORD_IDENTS, ident.span, |lint| {\n-            lint.build(fluent::lint::builtin_keyword_idents)\n-                .set_arg(\"kw\", ident.clone())\n-                .set_arg(\"next\", next_edition)\n-                .span_suggestion(\n+        cx.struct_span_lint(\n+            KEYWORD_IDENTS,\n+            ident.span,\n+            fluent::lint::builtin_keyword_idents,\n+            |lint| {\n+                lint.set_arg(\"kw\", ident.clone()).set_arg(\"next\", next_edition).span_suggestion(\n                     ident.span,\n                     fluent::lint::suggestion,\n                     format!(\"r#{}\", ident),\n                     Applicability::MachineApplicable,\n                 )\n-                .emit();\n-        });\n+            },\n+        );\n     }\n }\n \n@@ -2243,19 +2280,21 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             }\n \n             if !lint_spans.is_empty() {\n-                cx.struct_span_lint(EXPLICIT_OUTLIVES_REQUIREMENTS, lint_spans.clone(), |lint| {\n-                    lint.build(fluent::lint::builtin_explicit_outlives)\n-                        .set_arg(\"count\", bound_count)\n-                        .multipart_suggestion(\n+                cx.struct_span_lint(\n+                    EXPLICIT_OUTLIVES_REQUIREMENTS,\n+                    lint_spans.clone(),\n+                    fluent::lint::builtin_explicit_outlives,\n+                    |lint| {\n+                        lint.set_arg(\"count\", bound_count).multipart_suggestion(\n                             fluent::lint::suggestion,\n                             lint_spans\n                                 .into_iter()\n                                 .map(|span| (span, String::new()))\n                                 .collect::<Vec<_>>(),\n                             Applicability::MachineApplicable,\n                         )\n-                        .emit();\n-                });\n+                    },\n+                );\n             }\n         }\n     }\n@@ -2302,18 +2341,24 @@ impl EarlyLintPass for IncompleteFeatures {\n             .chain(features.declared_lib_features.iter().map(|(name, span)| (name, span)))\n             .filter(|(&name, _)| features.incomplete(name))\n             .for_each(|(&name, &span)| {\n-                cx.struct_span_lint(INCOMPLETE_FEATURES, span, |lint| {\n-                    let mut builder = lint.build(fluent::lint::builtin_incomplete_features);\n-                    builder.set_arg(\"name\", name);\n-                    if let Some(n) = rustc_feature::find_feature_issue(name, GateIssue::Language) {\n-                        builder.set_arg(\"n\", n);\n-                        builder.note(fluent::lint::note);\n-                    }\n-                    if HAS_MIN_FEATURES.contains(&name) {\n-                        builder.help(fluent::lint::help);\n-                    }\n-                    builder.emit();\n-                })\n+                cx.struct_span_lint(\n+                    INCOMPLETE_FEATURES,\n+                    span,\n+                    fluent::lint::builtin_incomplete_features,\n+                    |lint| {\n+                        lint.set_arg(\"name\", name);\n+                        if let Some(n) =\n+                            rustc_feature::find_feature_issue(name, GateIssue::Language)\n+                        {\n+                            lint.set_arg(\"n\", n);\n+                            lint.note(fluent::lint::note);\n+                        }\n+                        if HAS_MIN_FEATURES.contains(&name) {\n+                            lint.help(fluent::lint::help);\n+                        }\n+                        lint\n+                    },\n+                )\n             });\n     }\n }\n@@ -2628,28 +2673,37 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n             {\n                 // FIXME(davidtwco): make translatable\n-                cx.struct_span_lint(INVALID_VALUE, expr.span, |lint| {\n-                    let mut err = lint.build(&format!(\n-                        \"the type `{}` does not permit {}\",\n-                        conjured_ty,\n-                        match init {\n-                            InitKind::Zeroed => \"zero-initialization\",\n-                            InitKind::Uninit => \"being left uninitialized\",\n-                        },\n-                    ));\n-                    err.span_label(expr.span, \"this code causes undefined behavior when executed\");\n-                    err.span_label(\n-                        expr.span,\n-                        \"help: use `MaybeUninit<T>` instead, \\\n+                cx.struct_span_lint(\n+                    INVALID_VALUE,\n+                    expr.span,\n+                    DelayDm(|| {\n+                        format!(\n+                            \"the type `{}` does not permit {}\",\n+                            conjured_ty,\n+                            match init {\n+                                InitKind::Zeroed => \"zero-initialization\",\n+                                InitKind::Uninit => \"being left uninitialized\",\n+                            },\n+                        )\n+                    }),\n+                    |lint| {\n+                        lint.span_label(\n+                            expr.span,\n+                            \"this code causes undefined behavior when executed\",\n+                        );\n+                        lint.span_label(\n+                            expr.span,\n+                            \"help: use `MaybeUninit<T>` instead, \\\n                             and only call `assume_init` after initialization is done\",\n-                    );\n-                    if let Some(span) = span {\n-                        err.span_note(span, &msg);\n-                    } else {\n-                        err.note(&msg);\n-                    }\n-                    err.emit();\n-                });\n+                        );\n+                        if let Some(span) = span {\n+                            lint.span_note(span, &msg);\n+                        } else {\n+                            lint.note(&msg);\n+                        }\n+                        lint\n+                    },\n+                );\n             }\n         }\n     }\n@@ -2995,31 +3049,35 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                             SymbolName::Link(_, annot_span) => fi.span.to(annot_span),\n                         };\n                     // Finally, emit the diagnostic.\n+\n+                    let msg = if orig.get_name() == this_fi.ident.name {\n+                        fluent::lint::builtin_clashing_extern_same_name\n+                    } else {\n+                        fluent::lint::builtin_clashing_extern_diff_name\n+                    };\n                     tcx.struct_span_lint_hir(\n                         CLASHING_EXTERN_DECLARATIONS,\n                         this_fi.hir_id(),\n                         get_relevant_span(this_fi),\n+                        msg,\n                         |lint| {\n                             let mut expected_str = DiagnosticStyledString::new();\n                             expected_str.push(existing_decl_ty.fn_sig(tcx).to_string(), false);\n                             let mut found_str = DiagnosticStyledString::new();\n                             found_str.push(this_decl_ty.fn_sig(tcx).to_string(), true);\n \n-                            lint.build(if orig.get_name() == this_fi.ident.name {\n-                                fluent::lint::builtin_clashing_extern_same_name\n-                            } else {\n-                                fluent::lint::builtin_clashing_extern_diff_name\n-                            })\n-                            .set_arg(\"this_fi\", this_fi.ident.name)\n-                            .set_arg(\"orig\", orig.get_name())\n-                            .span_label(\n-                                get_relevant_span(orig_fi),\n-                                fluent::lint::previous_decl_label,\n-                            )\n-                            .span_label(get_relevant_span(this_fi), fluent::lint::mismatch_label)\n-                            // FIXME(davidtwco): translatable expected/found\n-                            .note_expected_found(&\"\", expected_str, &\"\", found_str)\n-                            .emit();\n+                            lint.set_arg(\"this_fi\", this_fi.ident.name)\n+                                .set_arg(\"orig\", orig.get_name())\n+                                .span_label(\n+                                    get_relevant_span(orig_fi),\n+                                    fluent::lint::previous_decl_label,\n+                                )\n+                                .span_label(\n+                                    get_relevant_span(this_fi),\n+                                    fluent::lint::mismatch_label,\n+                                )\n+                                // FIXME(davidtwco): translatable expected/found\n+                                .note_expected_found(&\"\", expected_str, &\"\", found_str)\n                         },\n                     );\n                 }\n@@ -3100,11 +3158,12 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n \n         if let rustc_hir::ExprKind::Unary(rustc_hir::UnOp::Deref, expr_deref) = expr.kind {\n             if is_null_ptr(cx, expr_deref) {\n-                cx.struct_span_lint(DEREF_NULLPTR, expr.span, |lint| {\n-                    let mut err = lint.build(fluent::lint::builtin_deref_nullptr);\n-                    err.span_label(expr.span, fluent::lint::label);\n-                    err.emit();\n-                });\n+                cx.struct_span_lint(\n+                    DEREF_NULLPTR,\n+                    expr.span,\n+                    fluent::lint::builtin_deref_nullptr,\n+                    |lint| lint.span_label(expr.span, fluent::lint::label),\n+                );\n             }\n         }\n     }\n@@ -3214,9 +3273,8 @@ impl<'tcx> LateLintPass<'tcx> for NamedAsmLabels {\n                     cx.lookup_with_diagnostics(\n                             NAMED_ASM_LABELS,\n                             Some(target_spans),\n-                            |diag| {\n-                                diag.build(fluent::lint::builtin_asm_labels).emit();\n-                            },\n+                            fluent::lint::builtin_asm_labels,\n+                            |lint| lint,\n                             BuiltinLintDiagnostics::NamedAsmLabel(\n                                 \"only local labels of the form `<number>:` should be used in inline asm\"\n                                     .to_string(),\n@@ -3288,16 +3346,14 @@ impl EarlyLintPass for SpecialModuleName {\n                 }\n \n                 match item.ident.name.as_str() {\n-                    \"lib\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, |lint| {\n-                        lint.build(\"found module declaration for lib.rs\")\n+                    \"lib\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, \"found module declaration for lib.rs\", |lint| {\n+                        lint\n                             .note(\"lib.rs is the root of this crate's library target\")\n                             .help(\"to refer to it from other targets, use the library's name as the path\")\n-                            .emit()\n                     }),\n-                    \"main\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, |lint| {\n-                        lint.build(\"found module declaration for main.rs\")\n+                    \"main\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, \"found module declaration for main.rs\", |lint| {\n+                        lint\n                             .note(\"a binary crate cannot be used as library\")\n-                            .emit()\n                     }),\n                     _ => continue\n                 }\n@@ -3317,24 +3373,27 @@ impl EarlyLintPass for UnexpectedCfgs {\n         for &(name, value) in cfg {\n             if let Some(names_valid) = &check_cfg.names_valid {\n                 if !names_valid.contains(&name) {\n-                    cx.lookup(UNEXPECTED_CFGS, None::<MultiSpan>, |diag| {\n-                        diag.build(fluent::lint::builtin_unexpected_cli_config_name)\n-                            .help(fluent::lint::help)\n-                            .set_arg(\"name\", name)\n-                            .emit();\n-                    });\n+                    cx.lookup(\n+                        UNEXPECTED_CFGS,\n+                        None::<MultiSpan>,\n+                        fluent::lint::builtin_unexpected_cli_config_name,\n+                        |diag| diag.help(fluent::lint::help).set_arg(\"name\", name),\n+                    );\n                 }\n             }\n             if let Some(value) = value {\n                 if let Some(values) = &check_cfg.values_valid.get(&name) {\n                     if !values.contains(&value) {\n-                        cx.lookup(UNEXPECTED_CFGS, None::<MultiSpan>, |diag| {\n-                            diag.build(fluent::lint::builtin_unexpected_cli_config_value)\n-                                .help(fluent::lint::help)\n-                                .set_arg(\"name\", name)\n-                                .set_arg(\"value\", value)\n-                                .emit();\n-                        });\n+                        cx.lookup(\n+                            UNEXPECTED_CFGS,\n+                            None::<MultiSpan>,\n+                            fluent::lint::builtin_unexpected_cli_config_value,\n+                            |diag| {\n+                                diag.help(fluent::lint::help)\n+                                    .set_arg(\"name\", name)\n+                                    .set_arg(\"value\", value)\n+                            },\n+                        );\n                     }\n                 }\n             }"}, {"sha": "9df6e0f534e61d61a442b174c110a32b337af93d", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -25,10 +25,8 @@ use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n use rustc_ast::util::unicode::TEXT_FLOW_CONTROL_CHARS;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n-use rustc_errors::add_elided_lifetime_in_path_suggestion;\n-use rustc_errors::{\n-    Applicability, DecorateLint, LintDiagnosticBuilder, MultiSpan, SuggestionStyle,\n-};\n+use rustc_errors::{add_elided_lifetime_in_path_suggestion, DiagnosticBuilder, DiagnosticMessage};\n+use rustc_errors::{Applicability, DecorateLint, MultiSpan, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId};\n@@ -580,13 +578,14 @@ pub trait LintContext: Sized {\n         &self,\n         lint: &'static Lint,\n         span: Option<impl Into<MultiSpan>>,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n         diagnostic: BuiltinLintDiagnostics,\n     ) {\n-        self.lookup(lint, span, |lint| {\n-            // We first generate a blank diagnostic.\n-            let mut db = lint.build(\"\");\n-\n+        // We first generate a blank diagnostic.\n+        self.lookup(lint, span, msg,|db| {\n             // Now, set up surrounding context.\n             let sess = self.sess();\n             match diagnostic {\n@@ -660,7 +659,7 @@ pub trait LintContext: Sized {\n                 ) => {\n                     add_elided_lifetime_in_path_suggestion(\n                         sess.source_map(),\n-                        &mut db,\n+                        db,\n                         n,\n                         path_span,\n                         incl_angl_brckt,\n@@ -696,7 +695,7 @@ pub trait LintContext: Sized {\n                     }\n                 }\n                 BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span) => {\n-                    stability::deprecation_suggestion(&mut db, \"macro\", suggestion, span)\n+                    stability::deprecation_suggestion(db, \"macro\", suggestion, span)\n                 }\n                 BuiltinLintDiagnostics::UnusedDocComment(span) => {\n                     db.span_label(span, \"rustdoc does not generate documentation for macro invocations\");\n@@ -867,7 +866,7 @@ pub trait LintContext: Sized {\n                 }\n             }\n             // Rewrap `db`, and pass control to the user.\n-            decorate(LintDiagnosticBuilder::new(db));\n+            decorate(db)\n         });\n     }\n \n@@ -877,7 +876,10 @@ pub trait LintContext: Sized {\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n     );\n \n     /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,\n@@ -888,31 +890,39 @@ pub trait LintContext: Sized {\n         span: S,\n         decorator: impl for<'a> DecorateLint<'a, ()>,\n     ) {\n-        self.lookup(lint, Some(span), |diag| decorator.decorate_lint(diag));\n+        self.lookup(lint, Some(span), decorator.msg(), |diag| decorator.decorate_lint(diag));\n     }\n \n     fn struct_span_lint<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n         span: S,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n     ) {\n-        self.lookup(lint, Some(span), decorate);\n+        self.lookup(lint, Some(span), msg, decorate);\n     }\n \n     /// Emit a lint from a lint struct (some type that implements `DecorateLint`, typically\n     /// generated by `#[derive(LintDiagnostic)]`).\n     fn emit_lint(&self, lint: &'static Lint, decorator: impl for<'a> DecorateLint<'a, ()>) {\n-        self.lookup(lint, None as Option<Span>, |diag| decorator.decorate_lint(diag));\n+        self.lookup(lint, None as Option<Span>, decorator.msg(), |diag| {\n+            decorator.decorate_lint(diag)\n+        });\n     }\n \n     /// Emit a lint at the appropriate level, with no associated span.\n     fn lint(\n         &self,\n         lint: &'static Lint,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: DiagnosticMessage,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n     ) {\n-        self.lookup(lint, None as Option<Span>, decorate);\n+        self.lookup(lint, None as Option<Span>, msg, decorate);\n     }\n \n     /// This returns the lint level for the given lint at the current location.\n@@ -975,13 +985,16 @@ impl<'tcx> LintContext for LateContext<'tcx> {\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n     ) {\n         let hir_id = self.last_node_with_lint_attrs;\n \n         match span {\n-            Some(s) => self.tcx.struct_span_lint_hir(lint, hir_id, s, decorate),\n-            None => self.tcx.struct_lint_node(lint, hir_id, decorate),\n+            Some(s) => self.tcx.struct_span_lint_hir(lint, hir_id, s, msg, decorate),\n+            None => self.tcx.struct_lint_node(lint, hir_id, msg, decorate),\n         }\n     }\n \n@@ -1006,9 +1019,12 @@ impl LintContext for EarlyContext<'_> {\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n     ) {\n-        self.builder.struct_lint(lint, span.map(|s| s.into()), decorate)\n+        self.builder.struct_lint(lint, span.map(|s| s.into()), msg, decorate)\n     }\n \n     fn get_lint_level(&self, lint: &'static Lint) -> Level {"}, {"sha": "18d30e1435be8f74937e544d3ccfbe050ea2ea47", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -43,9 +43,8 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n             self.context.lookup_with_diagnostics(\n                 lint_id.lint,\n                 Some(span),\n-                |lint| {\n-                    lint.build(msg).emit();\n-                },\n+                msg,\n+                |lint| lint,\n                 diagnostic,\n             );\n         }"}, {"sha": "e8d307814b9d50c6834cdfae1e15e41a660af470", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -50,26 +50,24 @@ fn enforce_mem_discriminant(\n ) {\n     let ty_param = cx.typeck_results().node_substs(func_expr.hir_id).type_at(0);\n     if is_non_enum(ty_param) {\n-        cx.struct_span_lint(ENUM_INTRINSICS_NON_ENUMS, expr_span, |builder| {\n-            builder\n-                .build(fluent::lint::enum_intrinsics_mem_discriminant)\n-                .set_arg(\"ty_param\", ty_param)\n-                .span_note(args_span, fluent::lint::note)\n-                .emit();\n-        });\n+        cx.struct_span_lint(\n+            ENUM_INTRINSICS_NON_ENUMS,\n+            expr_span,\n+            fluent::lint::enum_intrinsics_mem_discriminant,\n+            |lint| lint.set_arg(\"ty_param\", ty_param).span_note(args_span, fluent::lint::note),\n+        );\n     }\n }\n \n fn enforce_mem_variant_count(cx: &LateContext<'_>, func_expr: &hir::Expr<'_>, span: Span) {\n     let ty_param = cx.typeck_results().node_substs(func_expr.hir_id).type_at(0);\n     if is_non_enum(ty_param) {\n-        cx.struct_span_lint(ENUM_INTRINSICS_NON_ENUMS, span, |builder| {\n-            builder\n-                .build(fluent::lint::enum_intrinsics_mem_variant)\n-                .set_arg(\"ty_param\", ty_param)\n-                .note(fluent::lint::note)\n-                .emit();\n-        });\n+        cx.struct_span_lint(\n+            ENUM_INTRINSICS_NON_ENUMS,\n+            span,\n+            fluent::lint::enum_intrinsics_mem_variant,\n+            |lint| lint.set_arg(\"ty_param\", ty_param).note(fluent::lint::note),\n+        );\n     }\n }\n "}, {"sha": "af13f453a509842c7272078359464f8e5f53cda6", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -43,17 +43,17 @@ fn emit_unfulfilled_expectation_lint(\n         builtin::UNFULFILLED_LINT_EXPECTATIONS,\n         hir_id,\n         expectation.emission_span,\n-        |diag| {\n-            let mut diag = diag.build(fluent::lint::expectation);\n+        fluent::lint::expectation,\n+        |lint| {\n             if let Some(rationale) = expectation.reason {\n-                diag.note(rationale.as_str());\n+                lint.note(rationale.as_str());\n             }\n \n             if expectation.is_unfulfilled_lint_expectations {\n-                diag.note(fluent::lint::note);\n+                lint.note(fluent::lint::note);\n             }\n \n-            diag.emit();\n+            lint\n         },\n     );\n }"}, {"sha": "42557068bd3d7e585f4354acfeb327ad619e684e", "filename": "compiler/rustc_lint/src/hidden_unicode_codepoints.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -60,52 +60,56 @@ impl HiddenUnicodeCodepoints {\n             })\n             .collect();\n \n-        cx.struct_span_lint(TEXT_DIRECTION_CODEPOINT_IN_LITERAL, span, |lint| {\n-            let mut err = lint.build(fluent::lint::hidden_unicode_codepoints);\n-            err.set_arg(\"label\", label);\n-            err.set_arg(\"count\", spans.len());\n-            err.span_label(span, fluent::lint::label);\n-            err.note(fluent::lint::note);\n-            if point_at_inner_spans {\n-                for (c, span) in &spans {\n-                    err.span_label(*span, format!(\"{:?}\", c));\n+        cx.struct_span_lint(\n+            TEXT_DIRECTION_CODEPOINT_IN_LITERAL,\n+            span,\n+            fluent::lint::hidden_unicode_codepoints,\n+            |lint| {\n+                lint.set_arg(\"label\", label);\n+                lint.set_arg(\"count\", spans.len());\n+                lint.span_label(span, fluent::lint::label);\n+                lint.note(fluent::lint::note);\n+                if point_at_inner_spans {\n+                    for (c, span) in &spans {\n+                        lint.span_label(*span, format!(\"{:?}\", c));\n+                    }\n                 }\n-            }\n-            if point_at_inner_spans && !spans.is_empty() {\n-                err.multipart_suggestion_with_style(\n-                    fluent::lint::suggestion_remove,\n-                    spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n-                    Applicability::MachineApplicable,\n-                    SuggestionStyle::HideCodeAlways,\n-                );\n-                err.multipart_suggestion(\n-                    fluent::lint::suggestion_escape,\n-                    spans\n-                        .into_iter()\n-                        .map(|(c, span)| {\n-                            let c = format!(\"{:?}\", c);\n-                            (span, c[1..c.len() - 1].to_string())\n-                        })\n-                        .collect(),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else {\n-                // FIXME: in other suggestions we've reversed the inner spans of doc comments. We\n-                // should do the same here to provide the same good suggestions as we do for\n-                // literals above.\n-                err.set_arg(\n-                    \"escaped\",\n-                    spans\n-                        .into_iter()\n-                        .map(|(c, _)| format!(\"{:?}\", c))\n-                        .collect::<Vec<String>>()\n-                        .join(\", \"),\n-                );\n-                err.note(fluent::lint::suggestion_remove);\n-                err.note(fluent::lint::no_suggestion_note_escape);\n-            }\n-            err.emit();\n-        });\n+                if point_at_inner_spans && !spans.is_empty() {\n+                    lint.multipart_suggestion_with_style(\n+                        fluent::lint::suggestion_remove,\n+                        spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n+                        Applicability::MachineApplicable,\n+                        SuggestionStyle::HideCodeAlways,\n+                    );\n+                    lint.multipart_suggestion(\n+                        fluent::lint::suggestion_escape,\n+                        spans\n+                            .into_iter()\n+                            .map(|(c, span)| {\n+                                let c = format!(\"{:?}\", c);\n+                                (span, c[1..c.len() - 1].to_string())\n+                            })\n+                            .collect(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    // FIXME: in other suggestions we've reversed the inner spans of doc comments. We\n+                    // should do the same here to provide the same good suggestions as we do for\n+                    // literals above.\n+                    lint.set_arg(\n+                        \"escaped\",\n+                        spans\n+                            .into_iter()\n+                            .map(|(c, _)| format!(\"{:?}\", c))\n+                            .collect::<Vec<String>>()\n+                            .join(\", \"),\n+                    );\n+                    lint.note(fluent::lint::suggestion_remove);\n+                    lint.note(fluent::lint::no_suggestion_note_escape);\n+                }\n+                lint\n+            },\n+        );\n     }\n }\n impl EarlyLintPass for HiddenUnicodeCodepoints {"}, {"sha": "ed28620fc3619a30ad9a12f06d066a4c6ddc3fd1", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 105, "deletions": 100, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -34,13 +34,16 @@ impl LateLintPass<'_> for DefaultHashTypes {\n             Some(sym::HashSet) => \"FxHashSet\",\n             _ => return,\n         };\n-        cx.struct_span_lint(DEFAULT_HASH_TYPES, path.span, |lint| {\n-            lint.build(fluent::lint::default_hash_types)\n-                .set_arg(\"preferred\", replace)\n-                .set_arg(\"used\", cx.tcx.item_name(def_id))\n-                .note(fluent::lint::note)\n-                .emit();\n-        });\n+        cx.struct_span_lint(\n+            DEFAULT_HASH_TYPES,\n+            path.span,\n+            fluent::lint::default_hash_types,\n+            |lint| {\n+                lint.set_arg(\"preferred\", replace)\n+                    .set_arg(\"used\", cx.tcx.item_name(def_id))\n+                    .note(fluent::lint::note)\n+            },\n+        );\n     }\n }\n \n@@ -80,12 +83,12 @@ impl LateLintPass<'_> for QueryStability {\n         if let Ok(Some(instance)) = ty::Instance::resolve(cx.tcx, cx.param_env, def_id, substs) {\n             let def_id = instance.def_id();\n             if cx.tcx.has_attr(def_id, sym::rustc_lint_query_instability) {\n-                cx.struct_span_lint(POTENTIAL_QUERY_INSTABILITY, span, |lint| {\n-                    lint.build(fluent::lint::query_instability)\n-                        .set_arg(\"query\", cx.tcx.item_name(def_id))\n-                        .note(fluent::lint::note)\n-                        .emit();\n-                })\n+                cx.struct_span_lint(\n+                    POTENTIAL_QUERY_INSTABILITY,\n+                    span,\n+                    fluent::lint::query_instability,\n+                    |lint| lint.set_arg(\"query\", cx.tcx.item_name(def_id)).note(fluent::lint::note),\n+                )\n             }\n         }\n     }\n@@ -123,15 +126,14 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n             let span = path.span.with_hi(\n                 segment.args.map_or(segment.ident.span, |a| a.span_ext).hi()\n             );\n-            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n-                lint.build(fluent::lint::tykind_kind)\n+            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, fluent::lint::tykind_kind, |lint| {\n+                lint\n                     .span_suggestion(\n                         span,\n                         fluent::lint::suggestion,\n                         \"ty\",\n                         Applicability::MaybeIncorrect, // ty maybe needs an import\n                     )\n-                    .emit();\n             });\n         }\n     }\n@@ -140,76 +142,77 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n         match &ty.kind {\n             TyKind::Path(QPath::Resolved(_, path)) => {\n                 if lint_ty_kind_usage(cx, &path.res) {\n-                    cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n-                        let hir = cx.tcx.hir();\n-                        match hir.find(hir.get_parent_node(ty.hir_id)) {\n-                            Some(Node::Pat(Pat {\n-                                kind:\n-                                    PatKind::Path(qpath)\n-                                    | PatKind::TupleStruct(qpath, ..)\n-                                    | PatKind::Struct(qpath, ..),\n-                                ..\n-                            })) => {\n-                                if let QPath::TypeRelative(qpath_ty, ..) = qpath\n-                                    && qpath_ty.hir_id == ty.hir_id\n-                                {\n-                                    lint.build(fluent::lint::tykind_kind)\n-                                        .span_suggestion(\n-                                            path.span,\n-                                            fluent::lint::suggestion,\n-                                            \"ty\",\n-                                            Applicability::MaybeIncorrect, // ty maybe needs an import\n-                                        )\n-                                        .emit();\n-                                    return;\n-                                }\n+                    let hir = cx.tcx.hir();\n+                    let span = match hir.find(hir.get_parent_node(ty.hir_id)) {\n+                        Some(Node::Pat(Pat {\n+                            kind:\n+                                PatKind::Path(qpath)\n+                                | PatKind::TupleStruct(qpath, ..)\n+                                | PatKind::Struct(qpath, ..),\n+                            ..\n+                        })) => {\n+                            if let QPath::TypeRelative(qpath_ty, ..) = qpath\n+                                && qpath_ty.hir_id == ty.hir_id\n+                            {\n+                                Some(path.span)\n+                            } else {\n+                                None\n                             }\n-                            Some(Node::Expr(Expr {\n-                                kind: ExprKind::Path(qpath),\n-                                ..\n-                            })) => {\n-                                if let QPath::TypeRelative(qpath_ty, ..) = qpath\n-                                    && qpath_ty.hir_id == ty.hir_id\n-                                {\n-                                    lint.build(fluent::lint::tykind_kind)\n-                                        .span_suggestion(\n-                                            path.span,\n-                                            fluent::lint::suggestion,\n-                                            \"ty\",\n-                                            Applicability::MaybeIncorrect, // ty maybe needs an import\n-                                        )\n-                                        .emit();\n-                                    return;\n-                                }\n+                        }\n+                        Some(Node::Expr(Expr {\n+                            kind: ExprKind::Path(qpath),\n+                            ..\n+                        })) => {\n+                            if let QPath::TypeRelative(qpath_ty, ..) = qpath\n+                                && qpath_ty.hir_id == ty.hir_id\n+                            {\n+                                Some(path.span)\n+                            } else {\n+                                None\n                             }\n-                            // Can't unify these two branches because qpath below is `&&` and above is `&`\n-                            // and `A | B` paths don't play well together with adjustments, apparently.\n-                            Some(Node::Expr(Expr {\n-                                kind: ExprKind::Struct(qpath, ..),\n-                                ..\n-                            })) => {\n-                                if let QPath::TypeRelative(qpath_ty, ..) = qpath\n-                                    && qpath_ty.hir_id == ty.hir_id\n-                                {\n-                                    lint.build(fluent::lint::tykind_kind)\n-                                        .span_suggestion(\n-                                            path.span,\n-                                            fluent::lint::suggestion,\n-                                            \"ty\",\n-                                            Applicability::MaybeIncorrect, // ty maybe needs an import\n-                                        )\n-                                        .emit();\n-                                    return;\n-                                }\n+                        }\n+                        // Can't unify these two branches because qpath below is `&&` and above is `&`\n+                        // and `A | B` paths don't play well together with adjustments, apparently.\n+                        Some(Node::Expr(Expr {\n+                            kind: ExprKind::Struct(qpath, ..),\n+                            ..\n+                        })) => {\n+                            if let QPath::TypeRelative(qpath_ty, ..) = qpath\n+                                && qpath_ty.hir_id == ty.hir_id\n+                            {\n+                                Some(path.span)\n+                            } else {\n+                                None\n                             }\n-                            _ => {}\n                         }\n-                        lint.build(fluent::lint::tykind).help(fluent::lint::help).emit();\n-                    })\n+                        _ => None\n+                    };\n+\n+                    match span {\n+                        Some(span) => {\n+                            cx.struct_span_lint(\n+                                USAGE_OF_TY_TYKIND,\n+                                path.span,\n+                                fluent::lint::tykind_kind,\n+                                |lint| lint.span_suggestion(\n+                                    span,\n+                                    fluent::lint::suggestion,\n+                                    \"ty\",\n+                                    Applicability::MaybeIncorrect, // ty maybe needs an import\n+                                )\n+                            )\n+                        },\n+                        None => cx.struct_span_lint(\n+                            USAGE_OF_TY_TYKIND,\n+                            path.span,\n+                            fluent::lint::tykind,\n+                            |lint| lint.help(fluent::lint::help)\n+                        )\n+                    }\n                 } else if !ty.span.from_expansion() && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n                     if path.segments.len() > 1 {\n-                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n-                            lint.build(fluent::lint::ty_qualified)\n+                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, fluent::lint::ty_qualified, |lint| {\n+                            lint\n                                 .set_arg(\"ty\", t.clone())\n                                 .span_suggestion(\n                                     path.span,\n@@ -218,7 +221,6 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                                     // The import probably needs to be changed\n                                     Applicability::MaybeIncorrect,\n                                 )\n-                                .emit();\n                         })\n                     }\n                 }\n@@ -308,11 +310,8 @@ impl EarlyLintPass for LintPassImpl {\n                         cx.struct_span_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,\n-                            |lint| {\n-                                lint.build(fluent::lint::lintpass_by_hand)\n-                                    .help(fluent::lint::help)\n-                                    .emit();\n-                            },\n+                            fluent::lint::lintpass_by_hand,\n+                            |lint| lint.help(fluent::lint::help),\n                         )\n                     }\n                 }\n@@ -349,12 +348,12 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n                         if is_doc_keyword(v) {\n                             return;\n                         }\n-                        cx.struct_span_lint(EXISTING_DOC_KEYWORD, attr.span, |lint| {\n-                            lint.build(fluent::lint::non_existant_doc_keyword)\n-                                .set_arg(\"keyword\", v)\n-                                .help(fluent::lint::help)\n-                                .emit();\n-                        });\n+                        cx.struct_span_lint(\n+                            EXISTING_DOC_KEYWORD,\n+                            attr.span,\n+                            fluent::lint::non_existant_doc_keyword,\n+                            |lint| lint.set_arg(\"keyword\", v).help(fluent::lint::help),\n+                        );\n                     }\n                 }\n             }\n@@ -412,9 +411,12 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n         debug!(?found_impl);\n         if !found_parent_with_attr && !found_impl {\n-            cx.struct_span_lint(DIAGNOSTIC_OUTSIDE_OF_IMPL, span, |lint| {\n-                lint.build(fluent::lint::diag_out_of_impl).emit();\n-            })\n+            cx.struct_span_lint(\n+                DIAGNOSTIC_OUTSIDE_OF_IMPL,\n+                span,\n+                fluent::lint::diag_out_of_impl,\n+                |lint| lint,\n+            )\n         }\n \n         let mut found_diagnostic_message = false;\n@@ -430,9 +432,12 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n         debug!(?found_diagnostic_message);\n         if !found_parent_with_attr && !found_diagnostic_message {\n-            cx.struct_span_lint(UNTRANSLATABLE_DIAGNOSTIC, span, |lint| {\n-                lint.build(fluent::lint::untranslatable_diag).emit();\n-            })\n+            cx.struct_span_lint(\n+                UNTRANSLATABLE_DIAGNOSTIC,\n+                span,\n+                fluent::lint::untranslatable_diag,\n+                |lint| lint,\n+            )\n         }\n     }\n }\n@@ -464,8 +469,8 @@ impl LateLintPass<'_> for BadOptAccess {\n                 let Some(literal) = item.literal()  &&\n                 let ast::LitKind::Str(val, _) = literal.kind\n             {\n-                cx.struct_span_lint(BAD_OPT_ACCESS, expr.span, |lint| {\n-                    lint.build(val.as_str()).emit(); }\n+                cx.struct_span_lint(BAD_OPT_ACCESS, expr.span, val.as_str(), |lint|\n+                    lint\n                 );\n             }\n         }"}, {"sha": "78f355ec3d0ae309716db0b02da3e1dc1e0161c0", "filename": "compiler/rustc_lint/src/let_underscore.rs", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -1,5 +1,5 @@\n use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_errors::{Applicability, LintDiagnosticBuilder, MultiSpan};\n+use rustc_errors::{Applicability, DiagnosticBuilder, MultiSpan};\n use rustc_hir as hir;\n use rustc_middle::ty;\n use rustc_span::Symbol;\n@@ -128,48 +128,41 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                     init.span,\n                     \"this binding will immediately drop the value assigned to it\".to_string(),\n                 );\n-                cx.struct_span_lint(LET_UNDERSCORE_LOCK, span, |lint| {\n-                    build_and_emit_lint(\n-                        lint,\n-                        local,\n-                        init.span,\n-                        \"non-binding let on a synchronization lock\",\n-                    )\n-                })\n+                cx.struct_span_lint(\n+                    LET_UNDERSCORE_LOCK,\n+                    span,\n+                    \"non-binding let on a synchronization lock\",\n+                    |lint| build_lint(lint, local, init.span),\n+                )\n             } else {\n-                cx.struct_span_lint(LET_UNDERSCORE_DROP, local.span, |lint| {\n-                    build_and_emit_lint(\n-                        lint,\n-                        local,\n-                        init.span,\n-                        \"non-binding let on a type that implements `Drop`\",\n-                    );\n-                })\n+                cx.struct_span_lint(\n+                    LET_UNDERSCORE_DROP,\n+                    local.span,\n+                    \"non-binding let on a type that implements `Drop`\",\n+                    |lint| build_lint(lint, local, init.span),\n+                )\n             }\n         }\n     }\n }\n \n-fn build_and_emit_lint(\n-    lint: LintDiagnosticBuilder<'_, ()>,\n+fn build_lint<'a, 'b>(\n+    lint: &'a mut DiagnosticBuilder<'b, ()>,\n     local: &hir::Local<'_>,\n     init_span: rustc_span::Span,\n-    msg: &str,\n-) {\n-    lint.build(msg)\n-        .span_suggestion_verbose(\n-            local.pat.span,\n-            \"consider binding to an unused variable to avoid immediately dropping the value\",\n-            \"_unused\",\n-            Applicability::MachineApplicable,\n-        )\n-        .multipart_suggestion(\n-            \"consider immediately dropping the value\",\n-            vec![\n-                (local.span.until(init_span), \"drop(\".to_string()),\n-                (init_span.shrink_to_hi(), \")\".to_string()),\n-            ],\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+) -> &'a mut DiagnosticBuilder<'b, ()> {\n+    lint.span_suggestion_verbose(\n+        local.pat.span,\n+        \"consider binding to an unused variable to avoid immediately dropping the value\",\n+        \"_unused\",\n+        Applicability::MachineApplicable,\n+    )\n+    .multipart_suggestion(\n+        \"consider immediately dropping the value\",\n+        vec![\n+            (local.span.until(init_span), \"drop(\".to_string()),\n+            (init_span.shrink_to_hi(), \")\".to_string()),\n+        ],\n+        Applicability::MachineApplicable,\n+    )\n }"}, {"sha": "8238235082381729518cc1148b5742fc5e42d6ea", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 73, "deletions": 59, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -3,7 +3,7 @@ use crate::late::unerased_lint_store;\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{Applicability, Diagnostic, LintDiagnosticBuilder, MultiSpan};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::{intravisit, HirId};\n use rustc_middle::hir::nested_filter;\n@@ -214,14 +214,14 @@ impl<'s> LintLevelsBuilder<'s> {\n                     self.struct_lint(\n                         FORBIDDEN_LINT_GROUPS,\n                         Some(src.span().into()),\n-                        |diag_builder| {\n-                            let mut diag_builder = diag_builder.build(&format!(\n-                                \"{}({}) incompatible with previous forbid\",\n-                                level.as_str(),\n-                                src.name(),\n-                            ));\n-                            decorate_diag(&mut diag_builder);\n-                            diag_builder.emit();\n+                        format!(\n+                            \"{}({}) incompatible with previous forbid\",\n+                            level.as_str(),\n+                            src.name(),\n+                        ),\n+                        |lint| {\n+                            decorate_diag(lint);\n+                            lint\n                         },\n                     );\n                 }\n@@ -466,20 +466,18 @@ impl<'s> LintLevelsBuilder<'s> {\n                                     lvl,\n                                     src,\n                                     Some(sp.into()),\n+                                    format!(\n+                                        \"lint name `{}` is deprecated \\\n+                                         and may not have an effect in the future.\",\n+                                        name\n+                                    ),\n                                     |lint| {\n-                                        let msg = format!(\n-                                            \"lint name `{}` is deprecated \\\n-                                             and may not have an effect in the future.\",\n-                                            name\n-                                        );\n-                                        lint.build(&msg)\n-                                            .span_suggestion(\n-                                                sp,\n-                                                \"change it to\",\n-                                                new_lint_name,\n-                                                Applicability::MachineApplicable,\n-                                            )\n-                                            .emit();\n+                                        lint.span_suggestion(\n+                                            sp,\n+                                            \"change it to\",\n+                                            new_lint_name,\n+                                            Applicability::MachineApplicable,\n+                                        )\n                                     },\n                                 );\n \n@@ -533,17 +531,17 @@ impl<'s> LintLevelsBuilder<'s> {\n                             renamed_lint_level,\n                             src,\n                             Some(sp.into()),\n+                            msg,\n                             |lint| {\n-                                let mut err = lint.build(msg);\n                                 if let Some(new_name) = &renamed {\n-                                    err.span_suggestion(\n+                                    lint.span_suggestion(\n                                         sp,\n                                         \"use the new name\",\n                                         new_name,\n                                         Applicability::MachineApplicable,\n                                     );\n                                 }\n-                                err.emit();\n+                                lint\n                             },\n                         );\n                     }\n@@ -555,23 +553,30 @@ impl<'s> LintLevelsBuilder<'s> {\n                             Some(self.current_specs()),\n                             self.sess,\n                         );\n-                        struct_lint_level(self.sess, lint, level, src, Some(sp.into()), |lint| {\n-                            let name = if let Some(tool_ident) = tool_ident {\n-                                format!(\"{}::{}\", tool_ident.name, name)\n-                            } else {\n-                                name.to_string()\n-                            };\n-                            let mut db = lint.build(format!(\"unknown lint: `{}`\", name));\n-                            if let Some(suggestion) = suggestion {\n-                                db.span_suggestion(\n-                                    sp,\n-                                    \"did you mean\",\n-                                    suggestion,\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            db.emit();\n-                        });\n+                        let name = if let Some(tool_ident) = tool_ident {\n+                            format!(\"{}::{}\", tool_ident.name, name)\n+                        } else {\n+                            name.to_string()\n+                        };\n+                        struct_lint_level(\n+                            self.sess,\n+                            lint,\n+                            level,\n+                            src,\n+                            Some(sp.into()),\n+                            format!(\"unknown lint: `{}`\", name),\n+                            |lint| {\n+                                if let Some(suggestion) = suggestion {\n+                                    lint.span_suggestion(\n+                                        sp,\n+                                        \"did you mean\",\n+                                        suggestion,\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                }\n+                                lint\n+                            },\n+                        );\n                     }\n                 }\n                 // If this lint was renamed, apply the new lint instead of ignoring the attribute.\n@@ -621,14 +626,12 @@ impl<'s> LintLevelsBuilder<'s> {\n                     lint_level,\n                     lint_src,\n                     Some(lint_attr_span.into()),\n-                    |lint| {\n-                        let mut db = lint.build(&format!(\n-                            \"{}({}) is ignored unless specified at crate level\",\n-                            level.as_str(),\n-                            lint_attr_name\n-                        ));\n-                        db.emit();\n-                    },\n+                    format!(\n+                        \"{}({}) is ignored unless specified at crate level\",\n+                        level.as_str(),\n+                        lint_attr_name\n+                    ),\n+                    |lint| lint,\n                 );\n                 // don't set a separate error for every lint in the group\n                 break;\n@@ -665,13 +668,21 @@ impl<'s> LintLevelsBuilder<'s> {\n             if !self.sess.features_untracked().enabled(feature) {\n                 let lint = builtin::UNKNOWN_LINTS;\n                 let (level, src) = self.lint_level(builtin::UNKNOWN_LINTS);\n-                struct_lint_level(self.sess, lint, level, src, Some(span.into()), |lint_db| {\n-                    let mut db =\n-                        lint_db.build(&format!(\"unknown lint: `{}`\", lint_id.lint.name_lower()));\n-                    db.note(&format!(\"the `{}` lint is unstable\", lint_id.lint.name_lower(),));\n-                    add_feature_diagnostics(&mut db, &self.sess.parse_sess, feature);\n-                    db.emit();\n-                });\n+                struct_lint_level(\n+                    self.sess,\n+                    lint,\n+                    level,\n+                    src,\n+                    Some(span.into()),\n+                    format!(\"unknown lint: `{}`\", lint_id.lint.name_lower()),\n+                    |lint| {\n+                        lint.note(\n+                            &format!(\"the `{}` lint is unstable\", lint_id.lint.name_lower(),),\n+                        );\n+                        add_feature_diagnostics(lint, &self.sess.parse_sess, feature);\n+                        lint\n+                    },\n+                );\n                 return false;\n             }\n         }\n@@ -694,10 +705,13 @@ impl<'s> LintLevelsBuilder<'s> {\n         &self,\n         lint: &'static Lint,\n         span: Option<MultiSpan>,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n     ) {\n         let (level, src) = self.lint_level(lint);\n-        struct_lint_level(self.sess, lint, level, src, span, decorate)\n+        struct_lint_level(self.sess, lint, level, src, span, msg, decorate)\n     }\n \n     /// Registers the ID provided with the current set of lints stored in"}, {"sha": "313119637bc9c1a10686797a1d1ae43d1524bfca", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -90,14 +90,17 @@ fn lint_cstring_as_ptr(\n         if cx.tcx.is_diagnostic_item(sym::Result, def.did()) {\n             if let ty::Adt(adt, _) = substs.type_at(0).kind() {\n                 if cx.tcx.is_diagnostic_item(sym::cstring_type, adt.did()) {\n-                    cx.struct_span_lint(TEMPORARY_CSTRING_AS_PTR, as_ptr_span, |diag| {\n-                        diag.build(fluent::lint::cstring_ptr)\n-                            .span_label(as_ptr_span, fluent::lint::as_ptr_label)\n-                            .span_label(unwrap.span, fluent::lint::unwrap_label)\n-                            .note(fluent::lint::note)\n-                            .help(fluent::lint::help)\n-                            .emit();\n-                    });\n+                    cx.struct_span_lint(\n+                        TEMPORARY_CSTRING_AS_PTR,\n+                        as_ptr_span,\n+                        fluent::lint::cstring_ptr,\n+                        |diag| {\n+                            diag.span_label(as_ptr_span, fluent::lint::as_ptr_label)\n+                                .span_label(unwrap.span, fluent::lint::unwrap_label)\n+                                .note(fluent::lint::note)\n+                                .help(fluent::lint::help)\n+                        },\n+                    );\n                 }\n             }\n         }"}, {"sha": "b2626efb6d73a901fec3b333fc14cb15bd8f5472", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -180,15 +180,21 @@ impl EarlyLintPass for NonAsciiIdents {\n                 continue;\n             }\n             has_non_ascii_idents = true;\n-            cx.struct_span_lint(NON_ASCII_IDENTS, sp, |lint| {\n-                lint.build(fluent::lint::identifier_non_ascii_char).emit();\n-            });\n+            cx.struct_span_lint(\n+                NON_ASCII_IDENTS,\n+                sp,\n+                fluent::lint::identifier_non_ascii_char,\n+                |lint| lint,\n+            );\n             if check_uncommon_codepoints\n                 && !symbol_str.chars().all(GeneralSecurityProfile::identifier_allowed)\n             {\n-                cx.struct_span_lint(UNCOMMON_CODEPOINTS, sp, |lint| {\n-                    lint.build(fluent::lint::identifier_uncommon_codepoints).emit();\n-                })\n+                cx.struct_span_lint(\n+                    UNCOMMON_CODEPOINTS,\n+                    sp,\n+                    fluent::lint::identifier_uncommon_codepoints,\n+                    |lint| lint,\n+                )\n             }\n         }\n \n@@ -216,13 +222,16 @@ impl EarlyLintPass for NonAsciiIdents {\n                     .entry(skeleton_sym)\n                     .and_modify(|(existing_symbol, existing_span, existing_is_ascii)| {\n                         if !*existing_is_ascii || !is_ascii {\n-                            cx.struct_span_lint(CONFUSABLE_IDENTS, sp, |lint| {\n-                                lint.build(fluent::lint::confusable_identifier_pair)\n-                                    .set_arg(\"existing_sym\", *existing_symbol)\n-                                    .set_arg(\"sym\", symbol)\n-                                    .span_label(*existing_span, fluent::lint::label)\n-                                    .emit();\n-                            });\n+                            cx.struct_span_lint(\n+                                CONFUSABLE_IDENTS,\n+                                sp,\n+                                fluent::lint::confusable_identifier_pair,\n+                                |lint| {\n+                                    lint.set_arg(\"existing_sym\", *existing_symbol)\n+                                        .set_arg(\"sym\", symbol)\n+                                        .span_label(*existing_span, fluent::lint::label)\n+                                },\n+                            );\n                         }\n                         if *existing_is_ascii && !is_ascii {\n                             *existing_symbol = symbol;\n@@ -322,22 +331,25 @@ impl EarlyLintPass for NonAsciiIdents {\n                 }\n \n                 for ((sp, ch_list), script_set) in lint_reports {\n-                    cx.struct_span_lint(MIXED_SCRIPT_CONFUSABLES, sp, |lint| {\n-                        let mut includes = String::new();\n-                        for (idx, ch) in ch_list.into_iter().enumerate() {\n-                            if idx != 0 {\n-                                includes += \", \";\n+                    cx.struct_span_lint(\n+                        MIXED_SCRIPT_CONFUSABLES,\n+                        sp,\n+                        fluent::lint::mixed_script_confusables,\n+                        |lint| {\n+                            let mut includes = String::new();\n+                            for (idx, ch) in ch_list.into_iter().enumerate() {\n+                                if idx != 0 {\n+                                    includes += \", \";\n+                                }\n+                                let char_info = format!(\"'{}' (U+{:04X})\", ch, ch as u32);\n+                                includes += &char_info;\n                             }\n-                            let char_info = format!(\"'{}' (U+{:04X})\", ch, ch as u32);\n-                            includes += &char_info;\n-                        }\n-                        lint.build(fluent::lint::mixed_script_confusables)\n-                            .set_arg(\"set\", script_set.to_string())\n-                            .set_arg(\"includes\", includes)\n-                            .note(fluent::lint::includes_note)\n-                            .note(fluent::lint::note)\n-                            .emit();\n-                    });\n+                            lint.set_arg(\"set\", script_set.to_string())\n+                                .set_arg(\"includes\", includes)\n+                                .note(fluent::lint::includes_note)\n+                                .note(fluent::lint::note)\n+                        },\n+                    );\n                 }\n             }\n         }"}, {"sha": "9d2a23f2b5fb644bfb1792556c9c898c74919528", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -119,21 +119,19 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n         arg_span = expn.call_site;\n     }\n \n-    cx.struct_span_lint(NON_FMT_PANICS, arg_span, |lint| {\n-        let mut l = lint.build(fluent::lint::non_fmt_panic);\n-        l.set_arg(\"name\", symbol);\n-        l.note(fluent::lint::note);\n-        l.note(fluent::lint::more_info_note);\n+    cx.struct_span_lint(NON_FMT_PANICS, arg_span, fluent::lint::non_fmt_panic, |lint| {\n+        lint.set_arg(\"name\", symbol);\n+        lint.note(fluent::lint::note);\n+        lint.note(fluent::lint::more_info_note);\n         if !is_arg_inside_call(arg_span, span) {\n             // No clue where this argument is coming from.\n-            l.emit();\n-            return;\n+            return lint;\n         }\n         if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n             // A case of `panic!(format!(..))`.\n-            l.note(fluent::lint::supports_fmt_note);\n+            lint.note(fluent::lint::supports_fmt_note);\n             if let Some((open, close, _)) = find_delimiters(cx, arg_span) {\n-                l.multipart_suggestion(\n+                lint.multipart_suggestion(\n                     fluent::lint::supports_fmt_suggestion,\n                     vec![\n                         (arg_span.until(open.shrink_to_hi()), \"\".into()),\n@@ -180,15 +178,15 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n             };\n \n             if suggest_display {\n-                l.span_suggestion_verbose(\n+                lint.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n                     fluent::lint::display_suggestion,\n                     \"\\\"{}\\\", \",\n                     fmt_applicability,\n                 );\n             } else if suggest_debug {\n-                l.set_arg(\"ty\", ty);\n-                l.span_suggestion_verbose(\n+                lint.set_arg(\"ty\", ty);\n+                lint.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n                     fluent::lint::debug_suggestion,\n                     \"\\\"{:?}\\\", \",\n@@ -198,8 +196,8 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n \n             if suggest_panic_any {\n                 if let Some((open, close, del)) = find_delimiters(cx, span) {\n-                    l.set_arg(\"already_suggested\", suggest_display || suggest_debug);\n-                    l.multipart_suggestion(\n+                    lint.set_arg(\"already_suggested\", suggest_display || suggest_debug);\n+                    lint.multipart_suggestion(\n                         fluent::lint::panic_suggestion,\n                         if del == '(' {\n                             vec![(span.until(open), \"std::panic::panic_any\".into())]\n@@ -214,7 +212,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                 }\n             }\n         }\n-        l.emit();\n+        lint\n     });\n }\n \n@@ -258,26 +256,30 @@ fn check_panic_str<'tcx>(\n                 .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n                 .collect(),\n         };\n-        cx.struct_span_lint(NON_FMT_PANICS, arg_spans, |lint| {\n-            let mut l = lint.build(fluent::lint::non_fmt_panic_unused);\n-            l.set_arg(\"count\", n_arguments);\n-            l.note(fluent::lint::note);\n-            if is_arg_inside_call(arg.span, span) {\n-                l.span_suggestion(\n-                    arg.span.shrink_to_hi(),\n-                    fluent::lint::add_args_suggestion,\n-                    \", ...\",\n-                    Applicability::HasPlaceholders,\n-                );\n-                l.span_suggestion(\n-                    arg.span.shrink_to_lo(),\n-                    fluent::lint::add_fmt_suggestion,\n-                    \"\\\"{}\\\", \",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            l.emit();\n-        });\n+        cx.struct_span_lint(\n+            NON_FMT_PANICS,\n+            arg_spans,\n+            fluent::lint::non_fmt_panic_unused,\n+            |lint| {\n+                lint.set_arg(\"count\", n_arguments);\n+                lint.note(fluent::lint::note);\n+                if is_arg_inside_call(arg.span, span) {\n+                    lint.span_suggestion(\n+                        arg.span.shrink_to_hi(),\n+                        fluent::lint::add_args_suggestion,\n+                        \", ...\",\n+                        Applicability::HasPlaceholders,\n+                    );\n+                    lint.span_suggestion(\n+                        arg.span.shrink_to_lo(),\n+                        fluent::lint::add_fmt_suggestion,\n+                        \"\\\"{}\\\", \",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                lint\n+            },\n+        );\n     } else {\n         let brace_spans: Option<Vec<_>> =\n             snippet.filter(|s| s.starts_with('\"') || s.starts_with(\"r#\")).map(|s| {\n@@ -287,20 +289,24 @@ fn check_panic_str<'tcx>(\n                     .collect()\n             });\n         let count = brace_spans.as_ref().map(|v| v.len()).unwrap_or(/* any number >1 */ 2);\n-        cx.struct_span_lint(NON_FMT_PANICS, brace_spans.unwrap_or_else(|| vec![span]), |lint| {\n-            let mut l = lint.build(fluent::lint::non_fmt_panic_braces);\n-            l.set_arg(\"count\", count);\n-            l.note(fluent::lint::note);\n-            if is_arg_inside_call(arg.span, span) {\n-                l.span_suggestion(\n-                    arg.span.shrink_to_lo(),\n-                    fluent::lint::suggestion,\n-                    \"\\\"{}\\\", \",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            l.emit();\n-        });\n+        cx.struct_span_lint(\n+            NON_FMT_PANICS,\n+            brace_spans.unwrap_or_else(|| vec![span]),\n+            fluent::lint::non_fmt_panic_braces,\n+            |lint| {\n+                lint.set_arg(\"count\", count);\n+                lint.note(fluent::lint::note);\n+                if is_arg_inside_call(arg.span, span) {\n+                    lint.span_suggestion(\n+                        arg.span.shrink_to_lo(),\n+                        fluent::lint::suggestion,\n+                        \"\\\"{}\\\", \",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                lint\n+            },\n+        );\n     }\n }\n "}, {"sha": "9f800e9c8c9a19520f9c6852199b4665195ed363", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -136,26 +136,30 @@ impl NonCamelCaseTypes {\n         let name = ident.name.as_str();\n \n         if !is_camel_case(name) {\n-            cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, |lint| {\n-                let mut err = lint.build(fluent::lint::non_camel_case_type);\n-                let cc = to_camel_case(name);\n-                // We cannot provide meaningful suggestions\n-                // if the characters are in the category of \"Lowercase Letter\".\n-                if *name != cc {\n-                    err.span_suggestion(\n-                        ident.span,\n-                        fluent::lint::suggestion,\n-                        to_camel_case(name),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                } else {\n-                    err.span_label(ident.span, fluent::lint::label);\n-                }\n+            cx.struct_span_lint(\n+                NON_CAMEL_CASE_TYPES,\n+                ident.span,\n+                fluent::lint::non_camel_case_type,\n+                |lint| {\n+                    let cc = to_camel_case(name);\n+                    // We cannot provide meaningful suggestions\n+                    // if the characters are in the category of \"Lowercase Letter\".\n+                    if *name != cc {\n+                        lint.span_suggestion(\n+                            ident.span,\n+                            fluent::lint::suggestion,\n+                            to_camel_case(name),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        lint.span_label(ident.span, fluent::lint::label);\n+                    }\n \n-                err.set_arg(\"sort\", sort);\n-                err.set_arg(\"name\", name);\n-                err.emit();\n-            })\n+                    lint.set_arg(\"sort\", sort);\n+                    lint.set_arg(\"name\", name);\n+                    lint\n+                },\n+            )\n         }\n     }\n }\n@@ -280,9 +284,8 @@ impl NonSnakeCase {\n         let name = ident.name.as_str();\n \n         if !is_snake_case(name) {\n-            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, |lint| {\n+            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, fluent::lint::non_snake_case, |lint| {\n                 let sc = NonSnakeCase::to_snake_case(name);\n-                let mut err = lint.build(fluent::lint::non_snake_case);\n                 // We cannot provide meaningful suggestions\n                 // if the characters are in the category of \"Uppercase Letter\".\n                 if name != sc {\n@@ -297,30 +300,30 @@ impl NonSnakeCase {\n                             if sc_ident.name.can_be_raw() {\n                                 (fluent::lint::rename_or_convert_suggestion, sc_ident.to_string())\n                             } else {\n-                                err.note(fluent::lint::cannot_convert_note);\n+                                lint.note(fluent::lint::cannot_convert_note);\n                                 (fluent::lint::rename_suggestion, String::new())\n                             }\n                         } else {\n                             (fluent::lint::convert_suggestion, sc.clone())\n                         };\n \n-                        err.span_suggestion(\n+                        lint.span_suggestion(\n                             ident.span,\n                             message,\n                             suggestion,\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n-                        err.help(fluent::lint::help);\n+                        lint.help(fluent::lint::help);\n                     }\n                 } else {\n-                    err.span_label(ident.span, fluent::lint::label);\n+                    lint.span_label(ident.span, fluent::lint::label);\n                 }\n \n-                err.set_arg(\"sort\", sort);\n-                err.set_arg(\"name\", name);\n-                err.set_arg(\"sc\", sc);\n-                err.emit();\n+                lint.set_arg(\"sort\", sort);\n+                lint.set_arg(\"name\", name);\n+                lint.set_arg(\"sc\", sc);\n+                lint\n             });\n         }\n     }\n@@ -478,26 +481,30 @@ impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext<'_>, sort: &str, ident: &Ident) {\n         let name = ident.name.as_str();\n         if name.chars().any(|c| c.is_lowercase()) {\n-            cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, |lint| {\n-                let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n-                let mut err = lint.build(fluent::lint::non_upper_case_global);\n-                // We cannot provide meaningful suggestions\n-                // if the characters are in the category of \"Lowercase Letter\".\n-                if *name != uc {\n-                    err.span_suggestion(\n-                        ident.span,\n-                        fluent::lint::suggestion,\n-                        uc,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                } else {\n-                    err.span_label(ident.span, fluent::lint::label);\n-                }\n+            cx.struct_span_lint(\n+                NON_UPPER_CASE_GLOBALS,\n+                ident.span,\n+                fluent::lint::non_upper_case_global,\n+                |lint| {\n+                    let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n+                    // We cannot provide meaningful suggestions\n+                    // if the characters are in the category of \"Lowercase Letter\".\n+                    if *name != uc {\n+                        lint.span_suggestion(\n+                            ident.span,\n+                            fluent::lint::suggestion,\n+                            uc,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        lint.span_label(ident.span, fluent::lint::label);\n+                    }\n \n-                err.set_arg(\"sort\", sort);\n-                err.set_arg(\"name\", name);\n-                err.emit();\n-            })\n+                    lint.set_arg(\"sort\", sort);\n+                    lint.set_arg(\"name\", name);\n+                    lint\n+                },\n+            )\n         }\n     }\n }"}, {"sha": "19188d5c376513a418f392aee7f8baa4c7d4de38", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -90,13 +90,11 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n         }\n         let expr_span = expr.span;\n         let span = expr_span.with_lo(receiver.span.hi());\n-        cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n-            lint.build(fluent::lint::noop_method_call)\n-                .set_arg(\"method\", call.ident.name)\n+        cx.struct_span_lint(NOOP_METHOD_CALL, span, fluent::lint::noop_method_call, |lint| {\n+            lint.set_arg(\"method\", call.ident.name)\n                 .set_arg(\"receiver_ty\", receiver_ty)\n                 .span_label(span, fluent::lint::label)\n                 .note(fluent::lint::note)\n-                .emit();\n         });\n     }\n }"}, {"sha": "7e5a20a3bc16a87401294374dadc12b1861e9792", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -29,18 +29,20 @@ impl<'tcx> LateLintPass<'tcx> for PassByValue {\n                     }\n                 }\n                 if let Some(t) = path_for_pass_by_value(cx, &inner_ty) {\n-                    cx.struct_span_lint(PASS_BY_VALUE, ty.span, |lint| {\n-                        lint.build(fluent::lint::pass_by_value)\n-                            .set_arg(\"ty\", t.clone())\n-                            .span_suggestion(\n+                    cx.struct_span_lint(\n+                        PASS_BY_VALUE,\n+                        ty.span,\n+                        fluent::lint::pass_by_value,\n+                        |lint| {\n+                            lint.set_arg(\"ty\", t.clone()).span_suggestion(\n                                 ty.span,\n                                 fluent::lint::suggestion,\n                                 t,\n                                 // Changing type of function argument\n                                 Applicability::MaybeIncorrect,\n                             )\n-                            .emit();\n-                    })\n+                        },\n+                    )\n                 }\n             }\n             _ => {}"}, {"sha": "46c84550e9f5f758b5be45d31fa13044b6b9d35f", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -48,11 +48,18 @@ fn maybe_lint_redundant_semis(cx: &EarlyContext<'_>, seq: &mut Option<(Span, boo\n             return;\n         }\n \n-        cx.struct_span_lint(REDUNDANT_SEMICOLONS, span, |lint| {\n-            lint.build(fluent::lint::redundant_semicolons)\n-                .set_arg(\"multiple\", multiple)\n-                .span_suggestion(span, fluent::lint::suggestion, \"\", Applicability::MaybeIncorrect)\n-                .emit();\n-        });\n+        cx.struct_span_lint(\n+            REDUNDANT_SEMICOLONS,\n+            span,\n+            fluent::lint::redundant_semicolons,\n+            |lint| {\n+                lint.set_arg(\"multiple\", multiple).span_suggestion(\n+                    span,\n+                    fluent::lint::suggestion,\n+                    \"\",\n+                    Applicability::MaybeIncorrect,\n+                )\n+            },\n+        );\n     }\n }"}, {"sha": "078465bdce675548f132ce4aa32cd162fba03f02", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -100,15 +100,18 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n                 if trait_predicate.trait_ref.self_ty().is_impl_trait() {\n                     continue;\n                 }\n-                cx.struct_span_lint(DROP_BOUNDS, span, |lint| {\n-                    let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n-                        return\n-                    };\n-                    lint.build(fluent::lint::drop_trait_constraints)\n-                        .set_arg(\"predicate\", predicate)\n-                        .set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n-                        .emit();\n-                });\n+                let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n+                    continue;\n+                };\n+                cx.struct_span_lint(\n+                    DROP_BOUNDS,\n+                    span,\n+                    fluent::lint::drop_trait_constraints,\n+                    |lint| {\n+                        lint.set_arg(\"predicate\", predicate)\n+                            .set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n+                    },\n+                );\n             }\n         }\n     }\n@@ -119,14 +122,11 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n         };\n         for bound in &bounds[..] {\n             let def_id = bound.trait_ref.trait_def_id();\n-            if cx.tcx.lang_items().drop_trait() == def_id {\n-                cx.struct_span_lint(DYN_DROP, bound.span, |lint| {\n-                    let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n-                        return\n-                    };\n-                    lint.build(fluent::lint::drop_glue)\n-                        .set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n-                        .emit();\n+            if cx.tcx.lang_items().drop_trait() == def_id\n+                && let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop)\n+            {\n+                cx.struct_span_lint(DYN_DROP, bound.span, fluent::lint::drop_glue, |lint| {\n+                    lint.set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n                 });\n             }\n         }"}, {"sha": "b6009bd800a5f1b66d05b7f748b835cff5cccd7e", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 132, "deletions": 125, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -144,12 +144,18 @@ fn lint_overflowing_range_endpoint<'tcx>(\n     // We can suggest using an inclusive range\n     // (`..=`) instead only if it is the `end` that is\n     // overflowing and only by 1.\n-    if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n-        cx.struct_span_lint(OVERFLOWING_LITERALS, struct_expr.span, |lint| {\n-            let mut err = lint.build(fluent::lint::range_endpoint_out_of_range);\n-            err.set_arg(\"ty\", ty);\n-            if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n+    if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max\n+        && let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span)\n+    {\n+        cx.struct_span_lint(\n+            OVERFLOWING_LITERALS,\n+            struct_expr.span,\n+            fluent::lint::range_endpoint_out_of_range,\n+            |lint| {\n                 use ast::{LitIntType, LitKind};\n+\n+                lint.set_arg(\"ty\", ty);\n+\n                 // We need to preserve the literal's suffix,\n                 // as it may determine typing information.\n                 let suffix = match lit.node {\n@@ -159,16 +165,17 @@ fn lint_overflowing_range_endpoint<'tcx>(\n                     _ => bug!(),\n                 };\n                 let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-                err.span_suggestion(\n+                lint.span_suggestion(\n                     struct_expr.span,\n                     fluent::lint::suggestion,\n                     suggestion,\n                     Applicability::MachineApplicable,\n                 );\n-                err.emit();\n                 overwritten = true;\n-            }\n-        });\n+\n+                lint\n+            },\n+        );\n     }\n     overwritten\n }\n@@ -221,52 +228,58 @@ fn report_bin_hex_error(\n     negative: bool,\n ) {\n     let size = Integer::from_attr(&cx.tcx, ty).size();\n-    cx.struct_span_lint(OVERFLOWING_LITERALS, expr.span, |lint| {\n-        let (t, actually) = match ty {\n-            attr::IntType::SignedInt(t) => {\n-                let actually = if negative {\n-                    -(size.sign_extend(val) as i128)\n-                } else {\n-                    size.sign_extend(val) as i128\n-                };\n-                (t.name_str(), actually.to_string())\n-            }\n-            attr::IntType::UnsignedInt(t) => {\n-                let actually = size.truncate(val);\n-                (t.name_str(), actually.to_string())\n-            }\n-        };\n-        let mut err = lint.build(fluent::lint::overflowing_bin_hex);\n-        if negative {\n-            // If the value is negative,\n-            // emits a note about the value itself, apart from the literal.\n-            err.note(fluent::lint::negative_note);\n-            err.note(fluent::lint::negative_becomes_note);\n-        } else {\n-            err.note(fluent::lint::positive_note);\n-        }\n-        if let Some(sugg_ty) =\n-            get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n-        {\n-            err.set_arg(\"suggestion_ty\", sugg_ty);\n-            if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-                let (sans_suffix, _) = repr_str.split_at(pos);\n-                err.span_suggestion(\n-                    expr.span,\n-                    fluent::lint::suggestion,\n-                    format!(\"{}{}\", sans_suffix, sugg_ty),\n-                    Applicability::MachineApplicable,\n-                );\n+    cx.struct_span_lint(\n+        OVERFLOWING_LITERALS,\n+        expr.span,\n+        fluent::lint::overflowing_bin_hex,\n+        |lint| {\n+            let (t, actually) = match ty {\n+                attr::IntType::SignedInt(t) => {\n+                    let actually = if negative {\n+                        -(size.sign_extend(val) as i128)\n+                    } else {\n+                        size.sign_extend(val) as i128\n+                    };\n+                    (t.name_str(), actually.to_string())\n+                }\n+                attr::IntType::UnsignedInt(t) => {\n+                    let actually = size.truncate(val);\n+                    (t.name_str(), actually.to_string())\n+                }\n+            };\n+\n+            if negative {\n+                // If the value is negative,\n+                // emits a note about the value itself, apart from the literal.\n+                lint.note(fluent::lint::negative_note);\n+                lint.note(fluent::lint::negative_becomes_note);\n             } else {\n-                err.help(fluent::lint::help);\n+                lint.note(fluent::lint::positive_note);\n             }\n-        }\n-        err.set_arg(\"ty\", t);\n-        err.set_arg(\"lit\", repr_str);\n-        err.set_arg(\"dec\", val);\n-        err.set_arg(\"actually\", actually);\n-        err.emit();\n-    });\n+            if let Some(sugg_ty) =\n+                get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n+            {\n+                lint.set_arg(\"suggestion_ty\", sugg_ty);\n+                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                    let (sans_suffix, _) = repr_str.split_at(pos);\n+                    lint.span_suggestion(\n+                        expr.span,\n+                        fluent::lint::suggestion,\n+                        format!(\"{}{}\", sans_suffix, sugg_ty),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    lint.help(fluent::lint::help);\n+                }\n+            }\n+            lint.set_arg(\"ty\", t)\n+                .set_arg(\"lit\", repr_str)\n+                .set_arg(\"dec\", val)\n+                .set_arg(\"actually\", actually);\n+\n+            lint\n+        },\n+    );\n }\n \n // This function finds the next fitting type and generates a suggestion string.\n@@ -349,26 +362,27 @@ fn lint_int_literal<'tcx>(\n             return;\n         }\n \n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n-            let mut err = lint.build(fluent::lint::overflowing_int);\n-            err.set_arg(\"ty\", t.name_str());\n-            err.set_arg(\n-                \"lit\",\n-                cx.sess()\n-                    .source_map()\n-                    .span_to_snippet(lit.span)\n-                    .expect(\"must get snippet from literal\"),\n-            );\n-            err.set_arg(\"min\", min);\n-            err.set_arg(\"max\", max);\n-            err.note(fluent::lint::note);\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint::overflowing_int, |lint| {\n+            lint.set_arg(\"ty\", t.name_str())\n+                .set_arg(\n+                    \"lit\",\n+                    cx.sess()\n+                        .source_map()\n+                        .span_to_snippet(lit.span)\n+                        .expect(\"must get snippet from literal\"),\n+                )\n+                .set_arg(\"min\", min)\n+                .set_arg(\"max\", max)\n+                .note(fluent::lint::note);\n+\n             if let Some(sugg_ty) =\n                 get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n             {\n-                err.set_arg(\"suggestion_ty\", sugg_ty);\n-                err.help(fluent::lint::help);\n+                lint.set_arg(\"suggestion_ty\", sugg_ty);\n+                lint.help(fluent::lint::help);\n             }\n-            err.emit();\n+\n+            lint\n         });\n     }\n }\n@@ -393,16 +407,19 @@ fn lint_uint_literal<'tcx>(\n             match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.typeck_results().expr_ty(par_e).kind() {\n-                        cx.struct_span_lint(OVERFLOWING_LITERALS, par_e.span, |lint| {\n-                            lint.build(fluent::lint::only_cast_u8_to_char)\n-                                .span_suggestion(\n+                        cx.struct_span_lint(\n+                            OVERFLOWING_LITERALS,\n+                            par_e.span,\n+                            fluent::lint::only_cast_u8_to_char,\n+                            |lint| {\n+                                lint.span_suggestion(\n                                     par_e.span,\n                                     fluent::lint::suggestion,\n                                     format!(\"'\\\\u{{{:X}}}'\", lit_val),\n                                     Applicability::MachineApplicable,\n                                 )\n-                                .emit();\n-                        });\n+                            },\n+                        );\n                         return;\n                     }\n                 }\n@@ -424,9 +441,8 @@ fn lint_uint_literal<'tcx>(\n             );\n             return;\n         }\n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n-            lint.build(fluent::lint::overflowing_uint)\n-                .set_arg(\"ty\", t.name_str())\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint::overflowing_uint, |lint| {\n+            lint.set_arg(\"ty\", t.name_str())\n                 .set_arg(\n                     \"lit\",\n                     cx.sess()\n@@ -437,7 +453,6 @@ fn lint_uint_literal<'tcx>(\n                 .set_arg(\"min\", min)\n                 .set_arg(\"max\", max)\n                 .note(fluent::lint::note)\n-                .emit();\n         });\n     }\n }\n@@ -467,19 +482,22 @@ fn lint_literal<'tcx>(\n                 _ => bug!(),\n             };\n             if is_infinite == Ok(true) {\n-                cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n-                    lint.build(fluent::lint::overflowing_literal)\n-                        .set_arg(\"ty\", t.name_str())\n-                        .set_arg(\n-                            \"lit\",\n-                            cx.sess()\n-                                .source_map()\n-                                .span_to_snippet(lit.span)\n-                                .expect(\"must get snippet from literal\"),\n-                        )\n-                        .note(fluent::lint::note)\n-                        .emit();\n-                });\n+                cx.struct_span_lint(\n+                    OVERFLOWING_LITERALS,\n+                    e.span,\n+                    fluent::lint::overflowing_literal,\n+                    |lint| {\n+                        lint.set_arg(\"ty\", t.name_str())\n+                            .set_arg(\n+                                \"lit\",\n+                                cx.sess()\n+                                    .source_map()\n+                                    .span_to_snippet(lit.span)\n+                                    .expect(\"must get snippet from literal\"),\n+                            )\n+                            .note(fluent::lint::note)\n+                    },\n+                );\n             }\n         }\n         _ => {}\n@@ -497,9 +515,12 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n-                    cx.struct_span_lint(UNUSED_COMPARISONS, e.span, |lint| {\n-                        lint.build(fluent::lint::unused_comparisons).emit();\n-                    });\n+                    cx.struct_span_lint(\n+                        UNUSED_COMPARISONS,\n+                        e.span,\n+                        fluent::lint::unused_comparisons,\n+                        |lint| lint,\n+                    );\n                 }\n             }\n             hir::ExprKind::Lit(ref lit) => lint_literal(cx, self, e, lit),\n@@ -1150,25 +1171,24 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             CItemKind::Definition => IMPROPER_CTYPES_DEFINITIONS,\n         };\n \n-        self.cx.struct_span_lint(lint, sp, |lint| {\n+        self.cx.struct_span_lint(lint, sp, fluent::lint::improper_ctypes, |lint| {\n             let item_description = match self.mode {\n                 CItemKind::Declaration => \"block\",\n                 CItemKind::Definition => \"fn\",\n             };\n-            let mut diag = lint.build(fluent::lint::improper_ctypes);\n-            diag.set_arg(\"ty\", ty);\n-            diag.set_arg(\"desc\", item_description);\n-            diag.span_label(sp, fluent::lint::label);\n+            lint.set_arg(\"ty\", ty);\n+            lint.set_arg(\"desc\", item_description);\n+            lint.span_label(sp, fluent::lint::label);\n             if let Some(help) = help {\n-                diag.help(help);\n+                lint.help(help);\n             }\n-            diag.note(note);\n+            lint.note(note);\n             if let ty::Adt(def, _) = ty.kind() {\n                 if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n-                    diag.span_note(sp, fluent::lint::note);\n+                    lint.span_note(sp, fluent::lint::note);\n                 }\n             }\n-            diag.emit();\n+            lint\n         });\n     }\n \n@@ -1381,11 +1401,8 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n                 cx.struct_span_lint(\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n-                    |lint| {\n-                        lint.build(fluent::lint::variant_size_differences)\n-                            .set_arg(\"largest\", largest)\n-                            .emit();\n-                    },\n+                    fluent::lint::variant_size_differences,\n+                    |lint| lint.set_arg(\"largest\", largest),\n                 );\n             }\n         }\n@@ -1493,25 +1510,16 @@ impl InvalidAtomicOrdering {\n \n     fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store])\n-            && let Some((ordering_arg, invalid_ordering)) = match method {\n-                sym::load => Some((&args[0], sym::Release)),\n-                sym::store => Some((&args[1], sym::Acquire)),\n+            && let Some((ordering_arg, invalid_ordering, msg)) = match method {\n+                sym::load => Some((&args[0], sym::Release, fluent::lint::atomic_ordering_load)),\n+                sym::store => Some((&args[1], sym::Acquire, fluent::lint::atomic_ordering_store)),\n                 _ => None,\n             }\n             && let Some(ordering) = Self::match_ordering(cx, ordering_arg)\n             && (ordering == invalid_ordering || ordering == sym::AcqRel)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, |diag| {\n-                if method == sym::load {\n-                    diag.build(fluent::lint::atomic_ordering_load)\n-                        .help(fluent::lint::help)\n-                        .emit()\n-                } else {\n-                    debug_assert_eq!(method, sym::store);\n-                    diag.build(fluent::lint::atomic_ordering_store)\n-                        .help(fluent::lint::help)\n-                        .emit();\n-                }\n+            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, msg, |lint| {\n+                lint.help(fluent::lint::help)\n             });\n         }\n     }\n@@ -1523,10 +1531,9 @@ impl InvalidAtomicOrdering {\n             && matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence))\n             && Self::match_ordering(cx, &args[0]) == Some(sym::Relaxed)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, |diag| {\n-                diag.build(fluent::lint::atomic_ordering_fence)\n+            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, fluent::lint::atomic_ordering_fence, |lint| {\n+                lint\n                     .help(fluent::lint::help)\n-                    .emit();\n             });\n         }\n     }"}, {"sha": "787c9518b50893165ddd1091ce53b8b230dbf0a3", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 82, "deletions": 66, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -154,24 +154,22 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         };\n \n         if let Some(must_use_op) = must_use_op {\n-            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, |lint| {\n-                lint.build(fluent::lint::unused_op)\n-                    .set_arg(\"op\", must_use_op)\n+            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint::unused_op, |lint| {\n+                lint.set_arg(\"op\", must_use_op)\n                     .span_label(expr.span, fluent::lint::label)\n                     .span_suggestion_verbose(\n                         expr.span.shrink_to_lo(),\n                         fluent::lint::suggestion,\n                         \"let _ = \",\n                         Applicability::MachineApplicable,\n                     )\n-                    .emit();\n             });\n             op_warned = true;\n         }\n \n         if !(type_permits_lack_of_use || fn_warned || op_warned) {\n-            cx.struct_span_lint(UNUSED_RESULTS, s.span, |lint| {\n-                lint.build(fluent::lint::unused_result).set_arg(\"ty\", ty).emit();\n+            cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint::unused_result, |lint| {\n+                lint.set_arg(\"ty\", ty)\n             });\n         }\n \n@@ -267,29 +265,35 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     }\n                 },\n                 ty::Closure(..) => {\n-                    cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n-                        // FIXME(davidtwco): this isn't properly translatable because of the\n-                        // pre/post strings\n-                        lint.build(fluent::lint::unused_closure)\n-                            .set_arg(\"count\", plural_len)\n-                            .set_arg(\"pre\", descr_pre)\n-                            .set_arg(\"post\", descr_post)\n-                            .note(fluent::lint::note)\n-                            .emit();\n-                    });\n+                    cx.struct_span_lint(\n+                        UNUSED_MUST_USE,\n+                        span,\n+                        fluent::lint::unused_closure,\n+                        |lint| {\n+                            // FIXME(davidtwco): this isn't properly translatable because of the\n+                            // pre/post strings\n+                            lint.set_arg(\"count\", plural_len)\n+                                .set_arg(\"pre\", descr_pre)\n+                                .set_arg(\"post\", descr_post)\n+                                .note(fluent::lint::note)\n+                        },\n+                    );\n                     true\n                 }\n                 ty::Generator(..) => {\n-                    cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n-                        // FIXME(davidtwco): this isn't properly translatable because of the\n-                        // pre/post strings\n-                        lint.build(fluent::lint::unused_generator)\n-                            .set_arg(\"count\", plural_len)\n-                            .set_arg(\"pre\", descr_pre)\n-                            .set_arg(\"post\", descr_post)\n-                            .note(fluent::lint::note)\n-                            .emit();\n-                    });\n+                    cx.struct_span_lint(\n+                        UNUSED_MUST_USE,\n+                        span,\n+                        fluent::lint::unused_generator,\n+                        |lint| {\n+                            // FIXME(davidtwco): this isn't properly translatable because of the\n+                            // pre/post strings\n+                            lint.set_arg(\"count\", plural_len)\n+                                .set_arg(\"pre\", descr_pre)\n+                                .set_arg(\"post\", descr_post)\n+                                .note(fluent::lint::note)\n+                        },\n+                    );\n                     true\n                 }\n                 _ => false,\n@@ -309,18 +313,17 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n-                cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n+                cx.struct_span_lint(UNUSED_MUST_USE, span, fluent::lint::unused_def, |lint| {\n                     // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n                     // strings\n-                    let mut err = lint.build(fluent::lint::unused_def);\n-                    err.set_arg(\"pre\", descr_pre_path);\n-                    err.set_arg(\"post\", descr_post_path);\n-                    err.set_arg(\"def\", cx.tcx.def_path_str(def_id));\n+                    lint.set_arg(\"pre\", descr_pre_path);\n+                    lint.set_arg(\"post\", descr_post_path);\n+                    lint.set_arg(\"def\", cx.tcx.def_path_str(def_id));\n                     // check for #[must_use = \"...\"]\n                     if let Some(note) = attr.value_str() {\n-                        err.note(note.as_str());\n+                        lint.note(note.as_str());\n                     }\n-                    err.emit();\n+                    lint\n                 });\n                 true\n             } else {\n@@ -357,25 +360,34 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext<'_>, s: &hir::Stmt<'_>) {\n         if let hir::StmtKind::Semi(expr) = s.kind {\n             if let hir::ExprKind::Path(_) = expr.kind {\n-                cx.struct_span_lint(PATH_STATEMENTS, s.span, |lint| {\n-                    let ty = cx.typeck_results().expr_ty(expr);\n-                    if ty.needs_drop(cx.tcx, cx.param_env) {\n-                        let mut lint = lint.build(fluent::lint::path_statement_drop);\n-                        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span) {\n-                            lint.span_suggestion(\n-                                s.span,\n-                                fluent::lint::suggestion,\n-                                format!(\"drop({});\", snippet),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            lint.span_help(s.span, fluent::lint::suggestion);\n-                        }\n-                        lint.emit();\n-                    } else {\n-                        lint.build(fluent::lint::path_statement_no_effect).emit();\n-                    }\n-                });\n+                let ty = cx.typeck_results().expr_ty(expr);\n+                if ty.needs_drop(cx.tcx, cx.param_env) {\n+                    cx.struct_span_lint(\n+                        PATH_STATEMENTS,\n+                        s.span,\n+                        fluent::lint::path_statement_drop,\n+                        |lint| {\n+                            if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span) {\n+                                lint.span_suggestion(\n+                                    s.span,\n+                                    fluent::lint::suggestion,\n+                                    format!(\"drop({});\", snippet),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            } else {\n+                                lint.span_help(s.span, fluent::lint::suggestion);\n+                            }\n+                            lint\n+                        },\n+                    );\n+                } else {\n+                    cx.struct_span_lint(\n+                        PATH_STATEMENTS,\n+                        s.span,\n+                        fluent::lint::path_statement_no_effect,\n+                        |lint| lint,\n+                    );\n+                }\n             }\n         }\n     }\n@@ -545,22 +557,21 @@ trait UnusedDelimLint {\n         } else {\n             MultiSpan::from(value_span)\n         };\n-        cx.struct_span_lint(self.lint(), primary_span, |lint| {\n-            let mut db = lint.build(fluent::lint::unused_delim);\n-            db.set_arg(\"delim\", Self::DELIM_STR);\n-            db.set_arg(\"item\", msg);\n+        cx.struct_span_lint(self.lint(), primary_span, fluent::lint::unused_delim, |lint| {\n+            lint.set_arg(\"delim\", Self::DELIM_STR);\n+            lint.set_arg(\"item\", msg);\n             if let Some((lo, hi)) = spans {\n                 let replacement = vec![\n                     (lo, if keep_space.0 { \" \".into() } else { \"\".into() }),\n                     (hi, if keep_space.1 { \" \".into() } else { \"\".into() }),\n                 ];\n-                db.multipart_suggestion(\n+                lint.multipart_suggestion(\n                     fluent::lint::suggestion,\n                     replacement,\n                     Applicability::MachineApplicable,\n                 );\n             }\n-            db.emit();\n+            lint\n         });\n     }\n \n@@ -1128,9 +1139,12 @@ impl UnusedImportBraces {\n                 ast::UseTreeKind::Nested(_) => return,\n             };\n \n-            cx.struct_span_lint(UNUSED_IMPORT_BRACES, item.span, |lint| {\n-                lint.build(fluent::lint::unused_import_braces).set_arg(\"node\", node_name).emit();\n-            });\n+            cx.struct_span_lint(\n+                UNUSED_IMPORT_BRACES,\n+                item.span,\n+                fluent::lint::unused_import_braces,\n+                |lint| lint.set_arg(\"node\", node_name),\n+            );\n         }\n     }\n }\n@@ -1179,15 +1193,17 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n \n         for adj in cx.typeck_results().expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n-                cx.struct_span_lint(UNUSED_ALLOCATION, e.span, |lint| {\n-                    lint.build(match m {\n+                cx.struct_span_lint(\n+                    UNUSED_ALLOCATION,\n+                    e.span,\n+                    match m {\n                         adjustment::AutoBorrowMutability::Not => fluent::lint::unused_allocation,\n                         adjustment::AutoBorrowMutability::Mut { .. } => {\n                             fluent::lint::unused_allocation_mut\n                         }\n-                    })\n-                    .emit();\n-                });\n+                    },\n+                    |lint| lint,\n+                );\n             }\n         }\n     }"}, {"sha": "3a0bd1ba50d3ba4b27f21d1e38558ebee8d8a851", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -96,38 +96,43 @@ impl<'a> LintDiagnosticDerive<'a> {\n             let body = builder.body(&variant);\n \n             let diag = &builder.parent.diag;\n-            let init = match builder.slug.value_ref() {\n+\n+            quote! {\n+                #preamble\n+                #body\n+                #diag\n+            }\n+        });\n+\n+        let msg = builder.each_variant(&mut structure, |mut builder, variant| {\n+            // HACK(wafflelapkin): initialize slug (???)\n+            let _preamble = builder.preamble(&variant);\n+\n+            match builder.slug.value_ref() {\n                 None => {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n                         .help(&format!(\n                             \"specify the slug as the first argument to the attribute, such as \\\n-                             `#[diag(typeck::example_error)]`\",\n+                            `#[diag(typeck::example_error)]`\",\n                         ))\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                 }\n-                Some(slug) => {\n-                    quote! {\n-                        let mut #diag = #diag.build(rustc_errors::fluent::#slug);\n-                    }\n-                }\n-            };\n-\n-            quote! {\n-                #init\n-                #preamble\n-                #body\n-                #diag.emit();\n+                Some(slug) => quote! { rustc_errors::fluent::#slug.into() },\n             }\n         });\n \n         let diag = &builder.diag;\n         structure.gen_impl(quote! {\n             gen impl<'__a> rustc_errors::DecorateLint<'__a, ()> for @Self {\n-                fn decorate_lint(self, #diag: rustc_errors::LintDiagnosticBuilder<'__a, ()>) {\n+                fn decorate_lint<'__b>(self, #diag: &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()>) -> &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()> {\n                     use rustc_errors::IntoDiagnosticArg;\n                     #implementation\n                 }\n+\n+                fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+                    #msg\n+                }\n             }\n         })\n     }"}, {"sha": "b4fbf3b668ddfd420297743a5e2adc6cff28e0e9", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -2,7 +2,7 @@ use std::cmp;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_errors::{Diagnostic, DiagnosticId, LintDiagnosticBuilder, MultiSpan};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticId, DiagnosticMessage, MultiSpan};\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_query_system::ich::StableHashingContext;\n@@ -283,7 +283,11 @@ pub fn struct_lint_level<'s, 'd>(\n     level: Level,\n     src: LintLevelSource,\n     span: Option<MultiSpan>,\n-    decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>) + 'd,\n+    msg: impl Into<DiagnosticMessage>,\n+    decorate: impl 'd\n+    + for<'a, 'b> FnOnce(\n+        &'b mut DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut DiagnosticBuilder<'a, ()>,\n ) {\n     // Avoid codegen bloat from monomorphization by immediately doing dyn dispatch of `decorate` to\n     // the \"real\" work.\n@@ -293,7 +297,13 @@ pub fn struct_lint_level<'s, 'd>(\n         level: Level,\n         src: LintLevelSource,\n         span: Option<MultiSpan>,\n-        decorate: Box<dyn for<'b> FnOnce(LintDiagnosticBuilder<'b, ()>) + 'd>,\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: Box<\n+            dyn 'd\n+                + for<'a, 'b> FnOnce(\n+                    &'b mut DiagnosticBuilder<'a, ()>,\n+                ) -> &'b mut DiagnosticBuilder<'a, ()>,\n+        >,\n     ) {\n         // Check for future incompatibility lints and issue a stronger warning.\n         let future_incompatible = lint.future_incompatible;\n@@ -344,6 +354,9 @@ pub fn struct_lint_level<'s, 'd>(\n             (Level::Deny | Level::Forbid, None) => sess.diagnostic().struct_err_lint(\"\"),\n         };\n \n+        err.set_primary_message(msg);\n+        err.set_is_lint();\n+\n         // If this code originates in a foreign macro, aka something that this crate\n         // did not itself author, then it's likely that there's nothing this crate\n         // can do about it. We probably want to skip the lint entirely.\n@@ -373,11 +386,13 @@ pub fn struct_lint_level<'s, 'd>(\n         if let Level::Expect(_) = level {\n             let name = lint.name_lower();\n             err.code(DiagnosticId::Lint { name, has_future_breakage, is_force_warn: false });\n-            decorate(LintDiagnosticBuilder::new(err));\n+\n+            decorate(&mut err);\n+            err.emit();\n             return;\n         }\n \n-        explain_lint_level_source(lint, level, src, &mut err);\n+        explain_lint_level_source(lint, level, src, &mut *err);\n \n         let name = lint.name_lower();\n         let is_force_warn = matches!(level, Level::ForceWarn(_));\n@@ -417,10 +432,11 @@ pub fn struct_lint_level<'s, 'd>(\n             }\n         }\n \n-        // Finally, run `decorate`. This function is also responsible for emitting the diagnostic.\n-        decorate(LintDiagnosticBuilder::new(err));\n+        // Finally, run `decorate`.\n+        decorate(&mut err);\n+        err.emit()\n     }\n-    struct_lint_level_impl(sess, lint, level, src, span, Box::new(decorate))\n+    struct_lint_level_impl(sess, lint, level, src, span, msg, Box::new(decorate))\n }\n \n /// Returns whether `span` originates in a foreign crate's external macro."}, {"sha": "61bc089e431bb4e407d38337bc364629ab20d3aa", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -253,13 +253,12 @@ fn late_report_deprecation(\n         return;\n     }\n     let method_span = method_span.unwrap_or(span);\n-    tcx.struct_span_lint_hir(lint, hir_id, method_span, |lint| {\n-        let mut diag = lint.build(message);\n+    tcx.struct_span_lint_hir(lint, hir_id, method_span, message, |diag| {\n         if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n             let kind = tcx.def_kind(def_id).descr(def_id);\n-            deprecation_suggestion(&mut diag, kind, suggestion, method_span);\n+            deprecation_suggestion(diag, kind, suggestion, method_span);\n         }\n-        diag.emit();\n+        diag\n     });\n }\n \n@@ -621,9 +620,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         unmarked: impl FnOnce(Span, DefId),\n     ) -> bool {\n         let soft_handler = |lint, span, msg: &_| {\n-            self.struct_span_lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, |lint| {\n-                lint.build(msg).emit();\n-            })\n+            self.struct_span_lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, msg, |lint| lint)\n         };\n         let eval_result =\n             self.eval_stability_allow_unstable(def_id, id, span, method_span, allow_unstable);"}, {"sha": "a3489226f62b00d0198007b3ef944c990d16f8a7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -35,7 +35,9 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, RwLock, WorkerLocal};\n use rustc_data_structures::vec_map::VecMap;\n-use rustc_errors::{DecorateLint, ErrorGuaranteed, LintDiagnosticBuilder, MultiSpan};\n+use rustc_errors::{\n+    DecorateLint, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n@@ -2857,18 +2859,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         span: impl Into<MultiSpan>,\n         decorator: impl for<'a> DecorateLint<'a, ()>,\n     ) {\n-        self.struct_span_lint_hir(lint, hir_id, span, |diag| decorator.decorate_lint(diag))\n+        self.struct_span_lint_hir(lint, hir_id, span, decorator.msg(), |diag| {\n+            decorator.decorate_lint(diag)\n+        })\n     }\n \n     pub fn struct_span_lint_hir(\n         self,\n         lint: &'static Lint,\n         hir_id: HirId,\n         span: impl Into<MultiSpan>,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n     ) {\n         let (level, src) = self.lint_level_at_node(lint, hir_id);\n-        struct_lint_level(self.sess, lint, level, src, Some(span.into()), decorate);\n+        struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg, decorate);\n     }\n \n     /// Emit a lint from a lint struct (some type that implements `DecorateLint`, typically\n@@ -2879,17 +2886,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         id: HirId,\n         decorator: impl for<'a> DecorateLint<'a, ()>,\n     ) {\n-        self.struct_lint_node(lint, id, |diag| decorator.decorate_lint(diag))\n+        self.struct_lint_node(lint, id, decorator.msg(), |diag| decorator.decorate_lint(diag))\n     }\n \n     pub fn struct_lint_node(\n         self,\n         lint: &'static Lint,\n         id: HirId,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'b mut DiagnosticBuilder<'a, ()>,\n+        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n     ) {\n         let (level, src) = self.lint_level_at_node(lint, id);\n-        struct_lint_level(self.sess, lint, level, src, None, decorate);\n+        struct_lint_level(self.sess, lint, level, src, None, msg, decorate);\n     }\n \n     pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx [TraitCandidate]> {"}, {"sha": "5e8ce65daf0fc451ae750d10923c5bdbe7fdb17c", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -89,15 +89,8 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n                     UNSAFE_OP_IN_UNSAFE_FN,\n                     self.hir_context,\n                     span,\n-                    |lint| {\n-                        lint.build(&format!(\n-                            \"{} is unsafe and requires unsafe block (error E0133)\",\n-                            description,\n-                        ))\n-                        .span_label(span, kind.simple_description())\n-                        .note(note)\n-                        .emit();\n-                    },\n+                    format!(\"{} is unsafe and requires unsafe block (error E0133)\", description,),\n+                    |lint| lint.span_label(span, kind.simple_description()).note(note),\n                 )\n             }\n             SafetyContext::Safe => {\n@@ -125,14 +118,13 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n         enclosing_unsafe: Option<(Span, &'static str)>,\n     ) {\n         let block_span = self.tcx.sess.source_map().guess_head_span(block_span);\n-        self.tcx.struct_span_lint_hir(UNUSED_UNSAFE, hir_id, block_span, |lint| {\n-            let msg = \"unnecessary `unsafe` block\";\n-            let mut db = lint.build(msg);\n-            db.span_label(block_span, msg);\n+        let msg = \"unnecessary `unsafe` block\";\n+        self.tcx.struct_span_lint_hir(UNUSED_UNSAFE, hir_id, block_span, msg, |lint| {\n+            lint.span_label(block_span, msg);\n             if let Some((span, kind)) = enclosing_unsafe {\n-                db.span_label(span, format!(\"because it's nested under this `unsafe` {}\", kind));\n+                lint.span_label(span, format!(\"because it's nested under this `unsafe` {}\", kind));\n             }\n-            db.emit();\n+            lint\n         });\n     }\n "}, {"sha": "b21f30efce8076dcd993c481dd5f78cbe517e515", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -36,16 +36,20 @@ pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n \n         let sp = tcx.def_span(def_id);\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n-            let mut db = lint.build(\"function cannot return without recursing\");\n-            db.span_label(sp, \"cannot return without recursing\");\n-            // offer some help to the programmer.\n-            for call_span in vis.reachable_recursive_calls {\n-                db.span_label(call_span, \"recursive call site\");\n-            }\n-            db.help(\"a `loop` may express intention better if this is on purpose\");\n-            db.emit();\n-        });\n+        tcx.struct_span_lint_hir(\n+            UNCONDITIONAL_RECURSION,\n+            hir_id,\n+            sp,\n+            \"function cannot return without recursing\",\n+            |lint| {\n+                lint.span_label(sp, \"cannot return without recursing\");\n+                // offer some help to the programmer.\n+                for call_span in vis.reachable_recursive_calls {\n+                    lint.span_label(call_span, \"recursive call site\");\n+                }\n+                lint.help(\"a `loop` may express intention better if this is on purpose\")\n+            },\n+        );\n     }\n }\n "}, {"sha": "8fca94119c2114b16cb56241ac7b4654a6bb4b6a", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -7,7 +7,7 @@ use super::{PatCtxt, PatternError};\n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n use rustc_errors::{\n-    error_code, pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder,\n+    error_code, pluralize, struct_span_err, Applicability, DelayDm, Diagnostic, DiagnosticBuilder,\n     ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n@@ -347,19 +347,23 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             let span_end = affix.last().unwrap().unwrap().0;\n             let span = span_start.to(span_end);\n             let cnt = affix.len();\n-            cx.tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, top, span, |lint| {\n-                let s = pluralize!(cnt);\n-                let mut diag = lint.build(&format!(\"{kind} irrefutable pattern{s} in let chain\"));\n-                diag.note(&format!(\n-                    \"{these} pattern{s} will always match\",\n-                    these = pluralize!(\"this\", cnt),\n-                ));\n-                diag.help(&format!(\n-                    \"consider moving {} {suggestion}\",\n-                    if cnt > 1 { \"them\" } else { \"it\" }\n-                ));\n-                diag.emit()\n-            });\n+            let s = pluralize!(cnt);\n+            cx.tcx.struct_span_lint_hir(\n+                IRREFUTABLE_LET_PATTERNS,\n+                top,\n+                span,\n+                format!(\"{kind} irrefutable pattern{s} in let chain\"),\n+                |lint| {\n+                    lint.note(format!(\n+                        \"{these} pattern{s} will always match\",\n+                        these = pluralize!(\"this\", cnt),\n+                    ))\n+                    .help(format!(\n+                        \"consider moving {} {suggestion}\",\n+                        if cnt > 1 { \"them\" } else { \"it\" }\n+                    ))\n+                },\n+            );\n         };\n         if let Some(until) = chain_refutabilities.iter().position(|r| !matches!(*r, Some((_, false)))) && until > 0 {\n             // The chain has a non-zero prefix of irrefutable `let` statements.\n@@ -561,26 +565,28 @@ fn check_for_bindings_named_same_as_variants(\n                 BINDINGS_WITH_VARIANT_NAME,\n                 p.hir_id,\n                 p.span,\n+                DelayDm(|| format!(\n+                    \"pattern binding `{}` is named the same as one \\\n+                        of the variants of the type `{}`\",\n+                    ident, cx.tcx.def_path_str(edef.did())\n+                )),\n                 |lint| {\n                     let ty_path = cx.tcx.def_path_str(edef.did());\n-                    let mut err = lint.build(&format!(\n-                        \"pattern binding `{}` is named the same as one \\\n-                         of the variants of the type `{}`\",\n-                        ident, ty_path\n-                    ));\n-                    err.code(error_code!(E0170));\n+                    lint.code(error_code!(E0170));\n+\n                     // If this is an irrefutable pattern, and there's > 1 variant,\n                     // then we can't actually match on this. Applying the below\n                     // suggestion would produce code that breaks on `check_irrefutable`.\n                     if rf == Refutable || variant_count == 1 {\n-                        err.span_suggestion(\n+                        lint.span_suggestion(\n                             p.span,\n                             \"to match on the variant, qualify the path\",\n                             format!(\"{}::{}\", ty_path, ident),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n-                    err.emit();\n+\n+                    lint\n                 },\n             )\n         }\n@@ -598,14 +604,13 @@ fn pat_is_catchall(pat: &DeconstructedPat<'_, '_>) -> bool {\n }\n \n fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<Span>) {\n-    tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, |lint| {\n-        let mut err = lint.build(\"unreachable pattern\");\n+    tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, \"unreachable pattern\", |lint| {\n         if let Some(catchall) = catchall {\n             // We had a catchall pattern, hint at that.\n-            err.span_label(span, \"unreachable pattern\");\n-            err.span_label(catchall, \"matches any value\");\n+            lint.span_label(span, \"unreachable pattern\");\n+            lint.span_label(catchall, \"matches any value\");\n         }\n-        err.emit();\n+        lint\n     });\n }\n \n@@ -621,6 +626,11 @@ fn irrefutable_let_patterns(\n     count: usize,\n     span: Span,\n ) {\n+    let span = match source {\n+        LetSource::LetElse(span) => span,\n+        _ => span,\n+    };\n+\n     macro_rules! emit_diag {\n         (\n             $lint:expr,\n@@ -630,18 +640,23 @@ fn irrefutable_let_patterns(\n         ) => {{\n             let s = pluralize!(count);\n             let these = pluralize!(\"this\", count);\n-            let mut diag = $lint.build(&format!(\"irrefutable {} pattern{s}\", $source_name));\n-            diag.note(&format!(\"{these} pattern{s} will always match, so the {}\", $note_sufix));\n-            diag.help(concat!(\"consider \", $help_sufix));\n-            diag.emit()\n+            tcx.struct_span_lint_hir(\n+                IRREFUTABLE_LET_PATTERNS,\n+                id,\n+                span,\n+                format!(\"irrefutable {} pattern{s}\", $source_name),\n+                |lint| {\n+                    lint.note(&format!(\n+                        \"{these} pattern{s} will always match, so the {}\",\n+                        $note_sufix\n+                    ))\n+                    .help(concat!(\"consider \", $help_sufix))\n+                },\n+            )\n         }};\n     }\n \n-    let span = match source {\n-        LetSource::LetElse(span) => span,\n-        _ => span,\n-    };\n-    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| match source {\n+    match source {\n         LetSource::GenericLet => {\n             emit_diag!(lint, \"`let`\", \"`let` is useless\", \"removing `let`\");\n         }\n@@ -677,7 +692,7 @@ fn irrefutable_let_patterns(\n                 \"instead using a `loop { ... }` with a `let` inside it\"\n             );\n         }\n-    });\n+    };\n }\n \n fn is_let_irrefutable<'p, 'tcx>("}, {"sha": "f2935ca0e3aecc1caed1dd45f528fb3f6c245625", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -1,3 +1,4 @@\n+use rustc_errors::DelayDm;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n@@ -205,9 +206,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n                         self.span,\n-                        |lint| {\n-                            lint.build(&msg).emit();\n-                        },\n+                        msg,\n+                        |lint| lint,\n                     );\n                 } else {\n                     debug!(\n@@ -286,9 +286,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                         id,\n                         span,\n-                        |lint| {\n-                            lint.build(\"floating-point types cannot be used in patterns\").emit();\n-                        },\n+                        \"floating-point types cannot be used in patterns\",\n+                        |lint| lint,\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n@@ -340,15 +339,15 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        |lint| {\n-                            let msg = format!(\n+                        DelayDm(|| {\n+                            format!(\n                                 \"to use a constant of type `{}` in a pattern, \\\n                                  `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n                                 cv.ty(),\n                                 cv.ty(),\n-                            );\n-                            lint.build(&msg).emit();\n-                        },\n+                            )\n+                        }),\n+                        |lint| lint,\n                     );\n                 }\n                 // Since we are behind a reference, we can just bubble the error up so we get a\n@@ -488,7 +487,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                                 lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                                 self.id,\n                                 self.span,\n-                                |lint| {lint.build(&msg).emit();},\n+                                msg,\n+                                |lint| lint,\n                             );\n                         }\n                         PatKind::Constant { value: cv }\n@@ -556,9 +556,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         lint::builtin::POINTER_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        |lint| {\n-                            lint.build(msg).emit();\n-                        },\n+                        msg,\n+                        |lint| lint,\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n@@ -594,9 +593,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 lint::builtin::NONTRIVIAL_STRUCTURAL_MATCH,\n                 id,\n                 span,\n-                |lint| {\n-                    lint.build(&msg).emit();\n-                },\n+                msg,\n+                |lint| lint,\n             );\n         }\n "}, {"sha": "91ecfccdb5f746f481ce2a2de514fa86842ec8da", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -299,20 +299,20 @@ impl IntRange {\n                 lint::builtin::OVERLAPPING_RANGE_ENDPOINTS,\n                 hir_id,\n                 pcx.span,\n+                \"multiple patterns overlap on their endpoints\",\n                 |lint| {\n-                    let mut err = lint.build(\"multiple patterns overlap on their endpoints\");\n                     for (int_range, span) in overlaps {\n-                        err.span_label(\n+                        lint.span_label(\n                             span,\n                             &format!(\n                                 \"this range overlaps on `{}`...\",\n                                 int_range.to_pat(pcx.cx.tcx, pcx.ty)\n                             ),\n                         );\n                     }\n-                    err.span_label(pcx.span, \"... with this range\");\n-                    err.note(\"you likely meant to write mutually exclusive ranges\");\n-                    err.emit();\n+                    lint.span_label(pcx.span, \"... with this range\");\n+                    lint.note(\"you likely meant to write mutually exclusive ranges\");\n+                    lint\n                 },\n             );\n         }"}, {"sha": "f127907284425e1e885c8642ddee85265fae6d04", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -754,9 +754,8 @@ fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n     hir_id: HirId,\n     witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n ) {\n-    cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, |build| {\n+    cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, \"some variants are not matched explicitly\", |lint| {\n         let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n-        let mut lint = build.build(\"some variants are not matched explicitly\");\n         lint.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n         lint.help(\n             \"ensure that all variants are matched explicitly by adding the suggested match arms\",\n@@ -765,7 +764,7 @@ fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n             \"the matched value is of type `{}` and the `non_exhaustive_omitted_patterns` attribute was found\",\n             scrut_ty,\n         ));\n-        lint.emit();\n+        lint\n     });\n }\n "}, {"sha": "fa5f392fa74f6cc03bf351690741aeb4bf642035", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -1,4 +1,4 @@\n-use rustc_errors::{DiagnosticBuilder, LintDiagnosticBuilder};\n+use rustc_errors::{DiagnosticBuilder, DiagnosticMessage};\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n@@ -63,7 +63,10 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n         place: &Place<'tcx>,\n         const_item: DefId,\n         location: Location,\n-        decorate: impl for<'b> FnOnce(LintDiagnosticBuilder<'b, ()>) -> DiagnosticBuilder<'b, ()>,\n+        msg: impl Into<DiagnosticMessage>,\n+        decorate: impl for<'a, 'b> FnOnce(\n+            &'a mut DiagnosticBuilder<'b, ()>,\n+        ) -> &'a mut DiagnosticBuilder<'b, ()>,\n     ) {\n         // Don't lint on borrowing/assigning when a dereference is involved.\n         // If we 'leave' the temporary via a dereference, we must\n@@ -84,10 +87,10 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n                 CONST_ITEM_MUTATION,\n                 lint_root,\n                 source_info.span,\n+                msg,\n                 |lint| {\n                     decorate(lint)\n                         .span_note(self.tcx.def_span(const_item), \"`const` item defined here\")\n-                        .emit();\n                 },\n             );\n         }\n@@ -102,10 +105,8 @@ impl<'tcx> Visitor<'tcx> for ConstMutationChecker<'_, 'tcx> {\n             // so emitting a lint would be redundant.\n             if !lhs.projection.is_empty() {\n                 if let Some(def_id) = self.is_const_item_without_destructor(lhs.local) {\n-                    self.lint_const_item_usage(&lhs, def_id, loc, |lint| {\n-                        let mut lint = lint.build(\"attempting to modify a `const` item\");\n-                        lint.note(\"each usage of a `const` item creates a new temporary; the original `const` item will not be modified\");\n-                        lint\n+                    self.lint_const_item_usage(&lhs, def_id, loc, \"attempting to modify a `const` item\",|lint| {\n+                        lint.note(\"each usage of a `const` item creates a new temporary; the original `const` item will not be modified\")\n                     })\n                 }\n             }\n@@ -137,8 +138,7 @@ impl<'tcx> Visitor<'tcx> for ConstMutationChecker<'_, 'tcx> {\n                 });\n                 let lint_loc =\n                     if method_did.is_some() { self.body.terminator_loc(loc.block) } else { loc };\n-                self.lint_const_item_usage(place, def_id, lint_loc, |lint| {\n-                    let mut lint = lint.build(\"taking a mutable reference to a `const` item\");\n+                self.lint_const_item_usage(place, def_id, lint_loc, \"taking a mutable reference to a `const` item\", |lint| {\n                     lint\n                         .note(\"each usage of a `const` item creates a new temporary\")\n                         .note(\"the mutable reference will refer to this temporary, not the original `const` item\");"}, {"sha": "51abcf51189f62b92984d8db0838fa1741f5d6fb", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -33,21 +33,27 @@ struct PackedRefChecker<'a, 'tcx> {\n fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    tcx.struct_span_lint_hir(UNALIGNED_REFERENCES, lint_hir_id, tcx.def_span(def_id), |lint| {\n-        // FIXME: when we make this a hard error, this should have its\n-        // own error code.\n-        let extra = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-            \"with type or const parameters\"\n-        } else {\n-            \"that does not derive `Copy`\"\n-        };\n-        let message = format!(\n-            \"`{}` can't be derived on this `#[repr(packed)]` struct {}\",\n-            tcx.item_name(tcx.trait_id_of_impl(def_id.to_def_id()).expect(\"derived trait name\")),\n-            extra\n-        );\n-        lint.build(message).emit();\n-    });\n+    // FIXME: when we make this a hard error, this should have its\n+    // own error code.\n+\n+    let extra = if tcx.generics_of(def_id).own_requires_monomorphization() {\n+        \"with type or const parameters\"\n+    } else {\n+        \"that does not derive `Copy`\"\n+    };\n+    let message = format!(\n+        \"`{}` can't be derived on this `#[repr(packed)]` struct {}\",\n+        tcx.item_name(tcx.trait_id_of_impl(def_id.to_def_id()).expect(\"derived trait name\")),\n+        extra\n+    );\n+\n+    tcx.struct_span_lint_hir(\n+        UNALIGNED_REFERENCES,\n+        lint_hir_id,\n+        tcx.def_span(def_id),\n+        message,\n+        |lint| lint,\n+    );\n }\n \n impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n@@ -86,8 +92,9 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n                         UNALIGNED_REFERENCES,\n                         lint_root,\n                         source_info.span,\n+                        \"reference to packed field is unaligned\",\n                         |lint| {\n-                            lint.build(\"reference to packed field is unaligned\")\n+                            lint\n                                 .note(\n                                     \"fields of packed structs are not properly aligned, and creating \\\n                                     a misaligned reference is undefined behavior (even if that \\\n@@ -98,7 +105,6 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n                                     reference with a raw pointer and use `read_unaligned`/`write_unaligned` \\\n                                     (loads and stores via `*p` must be properly aligned even when using raw pointers)\"\n                                 )\n-                                .emit();\n                         },\n                     );\n                 }"}, {"sha": "4730be1244bdaeb9320f190b91811727da477b3d", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -489,21 +489,20 @@ fn unsafety_check_result<'tcx>(\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, kind: UnusedUnsafe, id: HirId) {\n     let span = tcx.sess.source_map().guess_head_span(tcx.hir().span(id));\n-    tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, |lint| {\n-        let msg = \"unnecessary `unsafe` block\";\n-        let mut db = lint.build(msg);\n-        db.span_label(span, msg);\n+    let msg = \"unnecessary `unsafe` block\";\n+    tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg, |lint| {\n+        lint.span_label(span, msg);\n         match kind {\n             UnusedUnsafe::Unused => {}\n             UnusedUnsafe::InUnsafeBlock(id) => {\n-                db.span_label(\n+                lint.span_label(\n                     tcx.sess.source_map().guess_head_span(tcx.hir().span(id)),\n                     \"because it's nested under this `unsafe` block\",\n                 );\n             }\n         }\n \n-        db.emit();\n+        lint\n     });\n }\n \n@@ -543,15 +542,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 lint_root,\n                 source_info.span,\n-                |lint| {\n-                    lint.build(&format!(\n-                        \"{} is unsafe and requires unsafe block (error E0133)\",\n-                        description,\n-                    ))\n-                    .span_label(source_info.span, description)\n-                    .note(note)\n-                    .emit();\n-                },\n+                format!(\"{} is unsafe and requires unsafe block (error E0133)\", description,),\n+                |lint| lint.span_label(source_info.span, description).note(note),\n             ),\n         }\n     }"}, {"sha": "cda3702c83d1c262b7210af3ffef82236950c870", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -347,10 +347,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         panic: AssertKind<impl std::fmt::Debug>,\n     ) {\n         if let Some(lint_root) = self.lint_root(source_info) {\n-            self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, |lint| {\n-                let mut err = lint.build(message);\n-                err.span_label(source_info.span, format!(\"{:?}\", panic));\n-                err.emit();\n+            self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, message, |lint| {\n+                lint.span_label(source_info.span, format!(\"{:?}\", panic))\n             });\n         }\n     }"}, {"sha": "1244c18020ddd3985a002dbe97600c9fca83afc1", "filename": "compiler/rustc_mir_transform/src/ffi_unwind_calls.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -106,14 +106,12 @@ fn has_ffi_unwind_calls(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> bool {\n                 .lint_root;\n             let span = terminator.source_info.span;\n \n-            tcx.struct_span_lint_hir(FFI_UNWIND_CALLS, lint_root, span, |lint| {\n-                let msg = match fn_def_id {\n-                    Some(_) => \"call to foreign function with FFI-unwind ABI\",\n-                    None => \"call to function pointer with FFI-unwind ABI\",\n-                };\n-                let mut db = lint.build(msg);\n-                db.span_label(span, msg);\n-                db.emit();\n+            let msg = match fn_def_id {\n+                Some(_) => \"call to foreign function with FFI-unwind ABI\",\n+                None => \"call to function pointer with FFI-unwind ABI\",\n+            };\n+            tcx.struct_span_lint_hir(FFI_UNWIND_CALLS, lint_root, span, msg, |lint| {\n+                lint.span_label(span, msg)\n             });\n \n             tainted = true;"}, {"sha": "469566694a3ef6b366d807056f5ceca8192705ce", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -179,11 +179,15 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n         let num_args = fn_sig.inputs().map_bound(|inputs| inputs.len()).skip_binder();\n         let variadic = if fn_sig.c_variadic() { \", ...\" } else { \"\" };\n         let ret = if fn_sig.output().skip_binder().is_unit() { \"\" } else { \" -> _\" };\n-        self.tcx.struct_span_lint_hir(FUNCTION_ITEM_REFERENCES, lint_root, span, |lint| {\n-            lint.build(\"taking a reference to a function item does not give a function pointer\")\n-                .span_suggestion(\n+        self.tcx.struct_span_lint_hir(\n+            FUNCTION_ITEM_REFERENCES,\n+            lint_root,\n+            span,\n+            \"taking a reference to a function item does not give a function pointer\",\n+            |lint| {\n+                lint.span_suggestion(\n                     span,\n-                    &format!(\"cast `{}` to obtain a function pointer\", ident),\n+                    format!(\"cast `{}` to obtain a function pointer\", ident),\n                     format!(\n                         \"{} as {}{}fn({}{}){}\",\n                         if params.is_empty() { ident } else { format!(\"{}::<{}>\", ident, params) },\n@@ -195,7 +199,7 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n                     ),\n                     Applicability::Unspecified,\n                 )\n-                .emit();\n-        });\n+            },\n+        );\n     }\n }"}, {"sha": "87433538512b9dd974ebf7d2d99393a70ac951a4", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -370,10 +370,13 @@ impl CheckAttrVisitor<'_> {\n                 b.push_str(&(allowed_target.to_string() + \"s\"));\n                 b\n             });\n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                lint.build(&format!(\"`#[{name}]` only has an effect on {}\", supported_names))\n-                    .emit();\n-            });\n+            self.tcx.struct_span_lint_hir(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                attr.span,\n+                &format!(\"`#[{name}]` only has an effect on {}\", supported_names),\n+                |lint| lint,\n+            );\n         }\n     }\n \n@@ -877,25 +880,31 @@ impl CheckAttrVisitor<'_> {\n         hir_id: HirId,\n     ) -> bool {\n         if hir_id != CRATE_HIR_ID {\n-            self.tcx.struct_span_lint_hir(INVALID_DOC_ATTRIBUTES, hir_id, meta.span(), |lint| {\n-                let mut err = lint.build(fluent::passes::attr_crate_level);\n-                if attr.style == AttrStyle::Outer\n-                    && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID\n-                {\n-                    if let Ok(mut src) = self.tcx.sess.source_map().span_to_snippet(attr.span) {\n-                        src.insert(1, '!');\n-                        err.span_suggestion_verbose(\n-                            attr.span,\n-                            fluent::passes::suggestion,\n-                            src,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        err.span_help(attr.span, fluent::passes::help);\n+            self.tcx.struct_span_lint_hir(\n+                INVALID_DOC_ATTRIBUTES,\n+                hir_id,\n+                meta.span(),\n+                fluent::passes::attr_crate_level,\n+                |err| {\n+                    if attr.style == AttrStyle::Outer\n+                        && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID\n+                    {\n+                        if let Ok(mut src) = self.tcx.sess.source_map().span_to_snippet(attr.span) {\n+                            src.insert(1, '!');\n+                            err.span_suggestion_verbose(\n+                                attr.span,\n+                                fluent::passes::suggestion,\n+                                src,\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            err.span_help(attr.span, fluent::passes::help);\n+                        }\n                     }\n-                }\n-                err.note(fluent::passes::note).emit();\n-            });\n+                    err.note(fluent::passes::note);\n+                    err\n+                },\n+            );\n             return false;\n         }\n         true"}, {"sha": "5e28a900e55e785cc621bcc091894c9df20ef6bf", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -4,7 +4,7 @@\n \n use itertools::Itertools;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, Applicability, MultiSpan};\n+use rustc_errors::{pluralize, Applicability, DelayDm, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -190,13 +190,14 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                     lint::builtin::DEAD_CODE,\n                     assign.hir_id,\n                     assign.span,\n-                    |lint| {\n-                        lint.build(&format!(\n+                    DelayDm(|| format!(\n                             \"useless assignment of {} of type `{}` to itself\",\n                             if is_field_assign { \"field\" } else { \"variable\" },\n                             self.typeck_results().expr_ty(lhs),\n-                        ))\n-                        .emit();\n+                        )),\n+                    |lint| {\n+                        lint\n+\n                     },\n                 )\n         }\n@@ -723,6 +724,26 @@ impl<'tcx> DeadVisitor<'tcx> {\n                 })\n                 .collect();\n \n+            let descr = tcx.def_kind(first_id).descr(first_id.to_def_id());\n+            let span_len = dead_codes.len();\n+            let names = match &names[..] {\n+                _ if span_len > 6 => String::new(),\n+                [name] => format!(\"`{name}` \"),\n+                [names @ .., last] => {\n+                    format!(\n+                        \"{} and `{last}` \",\n+                        names.iter().map(|name| format!(\"`{name}`\")).join(\", \")\n+                    )\n+                }\n+                [] => unreachable!(),\n+            };\n+            let msg = format!(\n+                \"{these}{descr}{s} {names}{are} never {participle}\",\n+                these = if span_len > 6 { \"multiple \" } else { \"\" },\n+                s = pluralize!(span_len),\n+                are = pluralize!(\"is\", span_len),\n+            );\n+\n             tcx.struct_span_lint_hir(\n                 if is_positional {\n                     lint::builtin::UNUSED_TUPLE_STRUCT_FIELDS\n@@ -731,27 +752,8 @@ impl<'tcx> DeadVisitor<'tcx> {\n                 },\n                 tcx.hir().local_def_id_to_hir_id(first_id),\n                 MultiSpan::from_spans(spans.clone()),\n-                |lint| {\n-                    let descr = tcx.def_kind(first_id).descr(first_id.to_def_id());\n-                    let span_len = dead_codes.len();\n-                    let names = match &names[..] {\n-                        _ if span_len > 6 => String::new(),\n-                        [name] => format!(\"`{name}` \"),\n-                        [names @ .., last] => {\n-                            format!(\n-                                \"{} and `{last}` \",\n-                                names.iter().map(|name| format!(\"`{name}`\")).join(\", \")\n-                            )\n-                        }\n-                        [] => unreachable!(),\n-                    };\n-                    let mut err = lint.build(&format!(\n-                        \"{these}{descr}{s} {names}{are} never {participle}\",\n-                        these = if span_len > 6 { \"multiple \" } else { \"\" },\n-                        s = pluralize!(span_len),\n-                        are = pluralize!(\"is\", span_len),\n-                    ));\n-\n+                msg,\n+                |err| {\n                     if is_positional {\n                         err.multipart_suggestion(\n                             &format!(\n@@ -797,7 +799,7 @@ impl<'tcx> DeadVisitor<'tcx> {\n                         );\n                         err.note(&msg);\n                     }\n-                    err.emit();\n+                    err\n                 },\n             );\n         }"}, {"sha": "c6fe40f72fc634c4994661be8952e24018b7e4eb", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 23, "deletions": 42, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -1319,14 +1319,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             // that we do not emit the same warning twice if the uninhabited type\n             // is indeed `!`.\n \n+            let msg = format!(\"unreachable {}\", descr);\n             self.ir.tcx.struct_span_lint_hir(\n                 lint::builtin::UNREACHABLE_CODE,\n                 expr_id,\n                 expr_span,\n-                |lint| {\n-                    let msg = format!(\"unreachable {}\", descr);\n-                    lint.build(&msg)\n-                        .span_label(expr_span, &msg)\n+                &msg,\n+                |diag| {\n+                    diag.span_label(expr_span, &msg)\n                         .span_label(orig_span, \"any code following this expression is unreachable\")\n                         .span_note(\n                             orig_span,\n@@ -1335,7 +1335,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                                 orig_ty\n                             ),\n                         )\n-                        .emit();\n                 },\n             );\n         }\n@@ -1491,14 +1490,8 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                                 lint::builtin::UNUSED_ASSIGNMENTS,\n                                 var_hir_id,\n                                 vec![span],\n-                                |lint| {\n-                                    lint.build(&format!(\n-                                        \"value captured by `{}` is never read\",\n-                                        name\n-                                    ))\n-                                    .help(\"did you mean to capture by reference instead?\")\n-                                    .emit();\n-                                },\n+                                format!(\"value captured by `{}` is never read\", name),\n+                                |lint| lint.help(\"did you mean to capture by reference instead?\"),\n                             );\n                         }\n                     }\n@@ -1508,11 +1501,8 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                             lint::builtin::UNUSED_VARIABLES,\n                             var_hir_id,\n                             vec![span],\n-                            |lint| {\n-                                lint.build(&format!(\"unused variable: `{}`\", name))\n-                                    .help(\"did you mean to capture by reference instead?\")\n-                                    .emit();\n-                            },\n+                            format!(\"unused variable: `{}`\", name),\n+                            |lint| lint.help(\"did you mean to capture by reference instead?\"),\n                         );\n                     }\n                 }\n@@ -1601,20 +1591,17 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                         .into_iter()\n                         .map(|(_, _, ident_span)| ident_span)\n                         .collect::<Vec<_>>(),\n-                    |lint| {\n-                        lint.build(&format!(\"variable `{}` is assigned to, but never used\", name))\n-                            .note(&format!(\"consider using `_{}` instead\", name))\n-                            .emit();\n-                    },\n+                    format!(\"variable `{}` is assigned to, but never used\", name),\n+                    |lint| lint.note(&format!(\"consider using `_{}` instead\", name)),\n                 )\n             } else if can_remove {\n                 self.ir.tcx.struct_span_lint_hir(\n                     lint::builtin::UNUSED_VARIABLES,\n                     first_hir_id,\n                     hir_ids_and_spans.iter().map(|(_, pat_span, _)| *pat_span).collect::<Vec<_>>(),\n+                    format!(\"unused variable: `{}`\", name),\n                     |lint| {\n-                        let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n-                        err.multipart_suggestion(\n+                        lint.multipart_suggestion(\n                             \"try removing the field\",\n                             hir_ids_and_spans\n                                 .iter()\n@@ -1629,8 +1616,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                                 })\n                                 .collect(),\n                             Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n+                        )\n                     },\n                 );\n             } else {\n@@ -1661,14 +1647,13 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                             .iter()\n                             .map(|(_, pat_span, _)| *pat_span)\n                             .collect::<Vec<_>>(),\n+                        format!(\"unused variable: `{}`\", name),\n                         |lint| {\n-                            let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n-                            err.multipart_suggestion(\n+                            lint.multipart_suggestion(\n                                 \"try ignoring the field\",\n                                 shorthands,\n                                 Applicability::MachineApplicable,\n-                            );\n-                            err.emit();\n+                            )\n                         },\n                     );\n                 } else {\n@@ -1684,17 +1669,16 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                             .iter()\n                             .map(|(_, _, ident_span)| *ident_span)\n                             .collect::<Vec<_>>(),\n+                        format!(\"unused variable: `{}`\", name),\n                         |lint| {\n-                            let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n-                            if self.has_added_lit_match_name_span(&name, opt_body, &mut err) {\n-                                err.span_label(pat.span, \"unused variable\");\n+                            if self.has_added_lit_match_name_span(&name, opt_body, lint) {\n+                                lint.span_label(pat.span, \"unused variable\");\n                             }\n-                            err.multipart_suggestion(\n+                            lint.multipart_suggestion(\n                                 \"if this is intentional, prefix it with an underscore\",\n                                 non_shorthands,\n                                 Applicability::MachineApplicable,\n-                            );\n-                            err.emit();\n+                            )\n                         },\n                     );\n                 }\n@@ -1758,11 +1742,8 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 lint::builtin::UNUSED_ASSIGNMENTS,\n                 hir_id,\n                 spans,\n-                |lint| {\n-                    lint.build(&message(&name))\n-                        .help(\"maybe it is overwritten before being read?\")\n-                        .emit();\n-                },\n+                message(&name),\n+                |lint| lint.help(\"maybe it is overwritten before being read?\"),\n             )\n         }\n     }"}, {"sha": "2690be66c21e5ae8456dfad9330dfda967c574d7", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -65,9 +65,13 @@ fn check_abi(tcx: TyCtxt<'_>, def_id: LocalDefId, abi: Abi) {\n     if abi == Abi::Rust {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let span = tcx.def_span(def_id);\n-        tcx.struct_span_lint_hir(UNDEFINED_NAKED_FUNCTION_ABI, hir_id, span, |lint| {\n-            lint.build(\"Rust ABI is unsupported in naked functions\").emit();\n-        });\n+        tcx.struct_span_lint_hir(\n+            UNDEFINED_NAKED_FUNCTION_ABI,\n+            hir_id,\n+            span,\n+            \"Rust ABI is unsupported in naked functions\",\n+            |lint| lint,\n+        );\n     }\n }\n "}, {"sha": "34fa80228df89d883b5e7f3b8ee18d4afcd7052d", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -752,10 +752,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                                 INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n                                 item.hir_id(),\n                                 span,\n-                                |lint| {lint\n-                                    .build(\"an `#[unstable]` annotation here has no effect\")\n-                                    .note(\"see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\")\n-                                    .emit();}\n+                                \"an `#[unstable]` annotation here has no effect\",\n+                                |lint| lint.note(\"see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\")\n                             );\n                         }\n                     }\n@@ -1081,11 +1079,16 @@ fn unnecessary_partially_stable_feature_lint(\n     implies: Symbol,\n     since: Symbol,\n ) {\n-    tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, |lint| {\n-        lint.build(&format!(\n+    tcx.struct_span_lint_hir(\n+        lint::builtin::STABLE_FEATURES,\n+        hir::CRATE_HIR_ID,\n+        span,\n+        format!(\n             \"the feature `{feature}` has been partially stabilized since {since} and is succeeded \\\n              by the feature `{implies}`\"\n-        ))\n+        ),\n+        |lint| {\n+            lint\n         .span_suggestion(\n             span,\n             &format!(\n@@ -1100,8 +1103,8 @@ fn unnecessary_partially_stable_feature_lint(\n             \"\",\n             Applicability::MaybeIncorrect,\n         )\n-        .emit();\n-    });\n+        },\n+    );\n }\n \n fn unnecessary_stable_feature_lint(\n@@ -1113,12 +1116,8 @@ fn unnecessary_stable_feature_lint(\n     if since.as_str() == VERSION_PLACEHOLDER {\n         since = rust_version_symbol();\n     }\n-    tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, |lint| {\n-        lint.build(&format!(\n-            \"the feature `{feature}` has been stable since {since} and no longer requires an \\\n-             attribute to enable\",\n-        ))\n-        .emit();\n+    tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, format!(\"the feature `{feature}` has been stable since {since} and no longer requires an attribute to enable\"), |lint| {\n+        lint\n     });\n }\n "}, {"sha": "3f98db6b2a924adfb9de5ee661a5d683cc58fd53", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -235,38 +235,42 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                   .emit()\n             }\n \n-            Err(ErrorHandled::TooGeneric) => Err(if uv.has_infer_types_or_consts() {\n-                NotConstEvaluatable::MentionsInfer\n+            Err(ErrorHandled::TooGeneric) => {\n+                let err = if uv.has_infer_types_or_consts() {\n+                    NotConstEvaluatable::MentionsInfer\n                 } else if uv.has_param_types_or_consts() {\n-                NotConstEvaluatable::MentionsParam\n-            } else {\n-                let guar = infcx.tcx.sess.delay_span_bug(span, format!(\"Missing value for constant, but no error reported?\"));\n-                NotConstEvaluatable::Error(guar)\n-            }),\n+                    NotConstEvaluatable::MentionsParam\n+                } else {\n+                    let guar = infcx.tcx.sess.delay_span_bug(span, format!(\"Missing value for constant, but no error reported?\"));\n+                    NotConstEvaluatable::Error(guar)\n+                };\n+\n+                Err(err)\n+            },\n             Err(ErrorHandled::Linted) => {\n                 let reported =\n                     infcx.tcx.sess.delay_span_bug(span, \"constant in type had error reported as lint\");\n                 Err(NotConstEvaluatable::Error(reported))\n             }\n             Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n             Ok(_) => {\n-              if uv.substs.has_param_types_or_consts() {\n-                  assert!(matches!(infcx.tcx.def_kind(uv.def.did), DefKind::AnonConst));\n-                  let mir_body = infcx.tcx.mir_for_ctfe_opt_const_arg(uv.def);\n+                if uv.substs.has_param_types_or_consts() {\n+                    assert!(matches!(infcx.tcx.def_kind(uv.def.did), DefKind::AnonConst));\n+                    let mir_body = infcx.tcx.mir_for_ctfe_opt_const_arg(uv.def);\n \n-                  if mir_body.is_polymorphic {\n-                      let Some(local_def_id) = uv.def.did.as_local() else { return Ok(()) };\n-                      tcx.struct_span_lint_hir(\n-                          lint::builtin::CONST_EVALUATABLE_UNCHECKED,\n-                          tcx.hir().local_def_id_to_hir_id(local_def_id),\n-                          span,\n-                          |err| {\n-                              err.build(\"cannot use constants which depend on generic parameters in types\").emit();\n-                        })\n-                  }\n-              }\n+                    if mir_body.is_polymorphic {\n+                        let Some(local_def_id) = uv.def.did.as_local() else { return Ok(()) };\n+                        tcx.struct_span_lint_hir(\n+                            lint::builtin::CONST_EVALUATABLE_UNCHECKED,\n+                            tcx.hir().local_def_id_to_hir_id(local_def_id),\n+                            span,\n+                            \"cannot use constants which depend on generic parameters in types\",\n+                            |err| err\n+                        )\n+                    }\n+                }\n \n-              Ok(())\n+                Ok(())\n             },\n         }\n     }"}, {"sha": "8f87a7fdeba5eaf7ac69a83eeb9e6ba29fee22b2", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -14,7 +14,7 @@ use crate::infer::TyCtxtInferExt;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use hir::def::DefKind;\n-use rustc_errors::{FatalError, MultiSpan};\n+use rustc_errors::{DelayDm, FatalError, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst};\n@@ -164,37 +164,42 @@ fn lint_object_unsafe_trait(\n ) {\n     // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n     // It's also hard to get a use site span, so we use the method definition span.\n-    tcx.struct_span_lint_hir(WHERE_CLAUSES_OBJECT_SAFETY, hir::CRATE_HIR_ID, span, |lint| {\n-        let mut err = lint.build(&format!(\n-            \"the trait `{}` cannot be made into an object\",\n-            tcx.def_path_str(trait_def_id)\n-        ));\n-        let node = tcx.hir().get_if_local(trait_def_id);\n-        let mut spans = MultiSpan::from_span(span);\n-        if let Some(hir::Node::Item(item)) = node {\n-            spans.push_span_label(item.ident.span, \"this trait cannot be made into an object...\");\n-            spans.push_span_label(span, format!(\"...because {}\", violation.error_msg()));\n-        } else {\n-            spans.push_span_label(\n-                span,\n-                format!(\n-                    \"the trait cannot be made into an object because {}\",\n-                    violation.error_msg()\n-                ),\n+    tcx.struct_span_lint_hir(\n+        WHERE_CLAUSES_OBJECT_SAFETY,\n+        hir::CRATE_HIR_ID,\n+        span,\n+        DelayDm(|| format!(\"the trait `{}` cannot be made into an object\", tcx.def_path_str(trait_def_id))),\n+        |err| {\n+            let node = tcx.hir().get_if_local(trait_def_id);\n+            let mut spans = MultiSpan::from_span(span);\n+            if let Some(hir::Node::Item(item)) = node {\n+                spans.push_span_label(\n+                    item.ident.span,\n+                    \"this trait cannot be made into an object...\",\n+                );\n+                spans.push_span_label(span, format!(\"...because {}\", violation.error_msg()));\n+            } else {\n+                spans.push_span_label(\n+                    span,\n+                    format!(\n+                        \"the trait cannot be made into an object because {}\",\n+                        violation.error_msg()\n+                    ),\n+                );\n+            };\n+            err.span_note(\n+                spans,\n+                \"for a trait to be \\\"object safe\\\" it needs to allow building a vtable to allow the \\\n+                call to be resolvable dynamically; for more information visit \\\n+                <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\",\n             );\n-        };\n-        err.span_note(\n-            spans,\n-            \"for a trait to be \\\"object safe\\\" it needs to allow building a vtable to allow the \\\n-             call to be resolvable dynamically; for more information visit \\\n-             <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\",\n-        );\n-        if node.is_some() {\n-            // Only provide the help if its a local trait, otherwise it's not\n-            violation.solution(&mut err);\n-        }\n-        err.emit();\n-    });\n+            if node.is_some() {\n+                // Only provide the help if its a local trait, otherwise it's not\n+                violation.solution(err);\n+            }\n+            err\n+        },\n+    );\n }\n \n fn sized_trait_bound_spans<'tcx>("}, {"sha": "6d856435355ed47fdaa94ed40040a7db69f98e4c", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -6,6 +6,7 @@\n //!\n //! [rustc dev guide]:https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n use hir::LangItem;\n+use rustc_errors::DelayDm;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::ObligationCause;\n@@ -825,13 +826,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     DEREF_INTO_DYN_SUPERTRAIT,\n                                     obligation.cause.body_id,\n                                     obligation.cause.span,\n-                                    |lint| {\n-                                        lint.build(&format!(\n-                                            \"`{}` implements `Deref` with supertrait `{}` as output\",\n-                                            source,\n-                                            deref_output_ty\n-                                        )).emit();\n-                                    },\n+                                    DelayDm(|| format!(\n+                                        \"`{}` implements `Deref` with supertrait `{}` as output\",\n+                                        source, deref_output_ty\n+                                    )),\n+                                    |lint| lint,\n                                 );\n                                 return;\n                             }"}, {"sha": "eac3f0f30e8b553e5dea47f44801a213e55c0fcf", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f7e244b785feb1b1d696abf0a7efb5cb7aed30/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=a8f7e244b785feb1b1d696abf0a7efb5cb7aed30", "patch": "@@ -17,7 +17,7 @@ use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause};\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n-use rustc_errors::{struct_span_err, EmissionGuarantee, LintDiagnosticBuilder};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder, EmissionGuarantee};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::{self, ImplSubject, TyCtxt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n@@ -350,26 +350,12 @@ fn report_conflicting_impls(\n     // Work to be done after we've built the DiagnosticBuilder. We have to define it\n     // now because the struct_lint methods don't return back the DiagnosticBuilder\n     // that's passed in.\n-    fn decorate<G: EmissionGuarantee>(\n+    fn decorate<'a, 'b, G: EmissionGuarantee>(\n         tcx: TyCtxt<'_>,\n         overlap: OverlapError,\n-        used_to_be_allowed: Option<FutureCompatOverlapErrorKind>,\n         impl_span: Span,\n-        err: LintDiagnosticBuilder<'_, G>,\n-    ) -> G {\n-        let msg = format!(\n-            \"conflicting implementations of trait `{}`{}{}\",\n-            overlap.trait_desc,\n-            overlap\n-                .self_desc\n-                .clone()\n-                .map_or_else(String::new, |ty| { format!(\" for type `{}`\", ty) }),\n-            match used_to_be_allowed {\n-                Some(FutureCompatOverlapErrorKind::Issue33140) => \": (E0119)\",\n-                _ => \"\",\n-            }\n-        );\n-        let mut err = err.build(&msg);\n+        err: &'b mut DiagnosticBuilder<'a, G>,\n+    ) -> &'b mut DiagnosticBuilder<'a, G> {\n         match tcx.span_of_impl(overlap.with_impl) {\n             Ok(span) => {\n                 err.span_label(span, \"first implementation here\");\n@@ -384,36 +370,43 @@ fn report_conflicting_impls(\n             }\n             Err(cname) => {\n                 let msg = match to_pretty_impl_header(tcx, overlap.with_impl) {\n-                    Some(s) => format!(\"conflicting implementation in crate `{}`:\\n- {}\", cname, s),\n+                    Some(s) => {\n+                        format!(\"conflicting implementation in crate `{}`:\\n- {}\", cname, s)\n+                    }\n                     None => format!(\"conflicting implementation in crate `{}`\", cname),\n                 };\n                 err.note(&msg);\n             }\n         }\n \n         for cause in &overlap.intercrate_ambiguity_causes {\n-            cause.add_intercrate_ambiguity_hint(&mut err);\n+            cause.add_intercrate_ambiguity_hint(err);\n         }\n \n         if overlap.involves_placeholder {\n-            coherence::add_placeholder_note(&mut err);\n+            coherence::add_placeholder_note(err);\n         }\n-        err.emit()\n+        err\n     }\n \n+    let msg = format!(\n+        \"conflicting implementations of trait `{}`{}{}\",\n+        overlap.trait_desc,\n+        overlap.self_desc.as_deref().map_or_else(String::new, |ty| format!(\" for type `{ty}`\")),\n+        match used_to_be_allowed {\n+            Some(FutureCompatOverlapErrorKind::Issue33140) => \": (E0119)\",\n+            _ => \"\",\n+        }\n+    );\n+\n     match used_to_be_allowed {\n         None => {\n             let reported = if overlap.with_impl.is_local()\n                 || tcx.orphan_check_impl(impl_def_id).is_ok()\n             {\n-                let err = struct_span_err!(tcx.sess, impl_span, E0119, \"\");\n-                Some(decorate(\n-                    tcx,\n-                    overlap,\n-                    used_to_be_allowed,\n-                    impl_span,\n-                    LintDiagnosticBuilder::new(err),\n-                ))\n+                let mut err = struct_span_err!(tcx.sess, impl_span, E0119, \"{msg}\",);\n+                decorate(tcx, overlap, impl_span, &mut err);\n+                Some(err.emit())\n             } else {\n                 Some(tcx.sess.delay_span_bug(impl_span, \"impl should have failed the orphan check\"))\n             };\n@@ -428,9 +421,8 @@ fn report_conflicting_impls(\n                 lint,\n                 tcx.hir().local_def_id_to_hir_id(impl_def_id),\n                 impl_span,\n-                |ldb| {\n-                    decorate(tcx, overlap, used_to_be_allowed, impl_span, ldb);\n-                },\n+                msg,\n+                |err| decorate(tcx, overlap, impl_span, err),\n             );\n         }\n     };"}]}