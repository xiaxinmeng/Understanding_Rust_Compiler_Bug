{"sha": "65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZThhMTM0NDFjYjQxNjljZTRmYjQzYmU3ZjEzNjlkNWM5ZDcxZTA=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-14T00:48:32Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-08T14:42:46Z"}, "message": "Adapt backend to trans::partitioning dictating the codegen-unit setup.", "tree": {"sha": "c276c19e9ac8e65be76c6a43a03b392459497d94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c276c19e9ac8e65be76c6a43a03b392459497d94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "html_url": "https://github.com/rust-lang/rust/commit/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cd8cf92fcfa349750b520fb26293ae585656eea", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cd8cf92fcfa349750b520fb26293ae585656eea", "html_url": "https://github.com/rust-lang/rust/commit/2cd8cf92fcfa349750b520fb26293ae585656eea"}], "stats": {"total": 276, "additions": 181, "deletions": 95}, "files": [{"sha": "5ccc96210be78d7d56cc8b739544ec05a1fce18e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "patch": "@@ -197,23 +197,70 @@ pub struct OutputFilenames {\n     pub outputs: HashMap<OutputType, Option<PathBuf>>,\n }\n \n+/// Codegen unit names generated by the numbered naming scheme will contain this\n+/// marker right before the index of the codegen unit.\n+pub const NUMBERED_CODEGEN_UNIT_MARKER: &'static str = \".cgu-\";\n+\n impl OutputFilenames {\n     pub fn path(&self, flavor: OutputType) -> PathBuf {\n         self.outputs.get(&flavor).and_then(|p| p.to_owned())\n             .or_else(|| self.single_output_file.clone())\n-            .unwrap_or_else(|| self.temp_path(flavor))\n+            .unwrap_or_else(|| self.temp_path(flavor, None))\n     }\n \n-    pub fn temp_path(&self, flavor: OutputType) -> PathBuf {\n+    /// Get the path where a compilation artifact of the given type for the\n+    /// given codegen unit should be placed on disk. If codegen_unit_name is\n+    /// None, a path distinct from those of any codegen unit will be generated.\n+    pub fn temp_path(&self,\n+                     flavor: OutputType,\n+                     codegen_unit_name: Option<&str>)\n+                     -> PathBuf {\n+        let extension = match flavor {\n+            OutputType::Bitcode => \"bc\",\n+            OutputType::Assembly => \"s\",\n+            OutputType::LlvmAssembly => \"ll\",\n+            OutputType::Object => \"o\",\n+            OutputType::DepInfo => \"d\",\n+            OutputType::Exe => \"\",\n+        };\n+\n+        self.temp_path_ext(extension, codegen_unit_name)\n+    }\n+\n+    /// Like temp_path, but also supports things where there is no corresponding\n+    /// OutputType, like no-opt-bitcode or lto-bitcode.\n+    pub fn temp_path_ext(&self,\n+                         ext: &str,\n+                         codegen_unit_name: Option<&str>)\n+                         -> PathBuf {\n         let base = self.out_directory.join(&self.filestem());\n-        match flavor {\n-            OutputType::Bitcode => base.with_extension(\"bc\"),\n-            OutputType::Assembly => base.with_extension(\"s\"),\n-            OutputType::LlvmAssembly => base.with_extension(\"ll\"),\n-            OutputType::Object => base.with_extension(\"o\"),\n-            OutputType::DepInfo => base.with_extension(\"d\"),\n-            OutputType::Exe => base,\n+\n+        let mut extension = String::new();\n+\n+        if let Some(codegen_unit_name) = codegen_unit_name {\n+            if codegen_unit_name.contains(NUMBERED_CODEGEN_UNIT_MARKER) {\n+                // If we use the numbered naming scheme for modules, we don't want\n+                // the files to look like <crate-name><extra>.<crate-name>.<index>.<ext>\n+                // but simply <crate-name><extra>.<index>.<ext>\n+                let marker_offset = codegen_unit_name.rfind(NUMBERED_CODEGEN_UNIT_MARKER)\n+                                                     .unwrap();\n+                let index_offset = marker_offset + NUMBERED_CODEGEN_UNIT_MARKER.len();\n+                extension.push_str(&codegen_unit_name[index_offset .. ]);\n+            } else {\n+                extension.push_str(codegen_unit_name);\n+            };\n+        }\n+\n+        if !ext.is_empty() {\n+            if !extension.is_empty() {\n+                extension.push_str(\".\");\n+            }\n+\n+            extension.push_str(ext);\n         }\n+\n+        let path = base.with_extension(&extension[..]);\n+        path\n     }\n \n     pub fn with_extension(&self, extension: &str) -> PathBuf {"}, {"sha": "eef2b6e6f37b412c0df669583a8ea4bc920e88e5", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "patch": "@@ -1081,7 +1081,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n \n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.cg.save_temps {\n-            fs::remove_file(&outputs.temp_path(OutputType::Assembly)).unwrap();\n+            fs::remove_file(&outputs.temp_path(OutputType::Assembly, None)).unwrap();\n         }\n     } else {\n         time(sess.time_passes(),"}, {"sha": "a9f3d2f8a175485b954c016e6d2e207a7c4084ff", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "patch": "@@ -205,7 +205,7 @@ pub fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        for obj in object_filenames(sess, outputs) {\n+        for obj in object_filenames(trans, outputs) {\n             remove(sess, &obj);\n         }\n         remove(sess, &outputs.with_extension(\"metadata.o\"));\n@@ -316,7 +316,7 @@ fn link_binary_output(sess: &Session,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n                       crate_name: &str) -> PathBuf {\n-    let objects = object_filenames(sess, outputs);\n+    let objects = object_filenames(trans, outputs);\n     let default_filename = filename_for_input(sess, crate_type, crate_name,\n                                               outputs);\n     let out_filename = outputs.outputs.get(&OutputType::Exe)\n@@ -356,10 +356,11 @@ fn link_binary_output(sess: &Session,\n     out_filename\n }\n \n-fn object_filenames(sess: &Session, outputs: &OutputFilenames) -> Vec<PathBuf> {\n-    (0..sess.opts.cg.codegen_units).map(|i| {\n-        let ext = format!(\"{}.o\", i);\n-        outputs.temp_path(OutputType::Object).with_extension(&ext)\n+fn object_filenames(trans: &CrateTranslation,\n+                    outputs: &OutputFilenames)\n+                    -> Vec<PathBuf> {\n+    trans.modules.iter().map(|module| {\n+        outputs.temp_path(OutputType::Object, Some(&module.name[..]))\n     }).collect()\n }\n \n@@ -497,7 +498,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                 ab.add_file(&bc_deflated_filename);\n \n                 // See the bottom of back::write::run_passes for an explanation\n-                // of when we do and don't keep .0.bc files around.\n+                // of when we do and don't keep .#module-name#.bc files around.\n                 let user_wants_numbered_bitcode =\n                         sess.opts.output_types.contains_key(&OutputType::Bitcode) &&\n                         sess.opts.cg.codegen_units > 1;"}, {"sha": "69e4a50804fadc5ca4c7a5f917ff4452cf3e9987", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "patch": "@@ -22,12 +22,12 @@ use libc;\n use flate;\n \n use std::ffi::CString;\n+use std::path::Path;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[String],\n            config: &ModuleConfig,\n-           name_extra: &str,\n-           output_names: &config::OutputFilenames) {\n+           temp_no_opt_bc_filename: &Path) {\n     if sess.opts.cg.prefer_dynamic {\n         sess.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n             .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n@@ -132,8 +132,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     }\n \n     if sess.opts.cg.save_temps {\n-        let path = output_names.with_extension(&format!(\"{}.no-opt.lto.bc\", name_extra));\n-        let cstr = path2cstr(&path);\n+        let cstr = path2cstr(temp_no_opt_bc_filename);\n         unsafe {\n             llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n         }"}, {"sha": "28804e4ed9e4ff3910dd74ff81880b1ccaf35ae6", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 99, "deletions": 71, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "patch": "@@ -423,9 +423,9 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                mtrans: ModuleTranslation,\n                                config: ModuleConfig,\n-                               name_extra: String,\n                                output_names: OutputFilenames) {\n-    let ModuleTranslation { llmod, llcx } = mtrans;\n+    let llmod = mtrans.llmod;\n+    let llcx = mtrans.llcx;\n     let tm = config.tm;\n \n     // llcx doesn't outlive this function, so we can put this on the stack.\n@@ -438,9 +438,10 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     llvm::LLVMSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n     llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, fv);\n \n+    let module_name = Some(&mtrans.name[..]);\n+\n     if config.emit_no_opt_bc {\n-        let ext = format!(\"{}.no-opt.bc\", name_extra);\n-        let out = output_names.with_extension(&ext);\n+        let out = output_names.temp_path_ext(\"no-opt.bc\", module_name);\n         let out = path2cstr(&out);\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n@@ -512,13 +513,18 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         match cgcx.lto_ctxt {\n             Some((sess, reachable)) if sess.lto() =>  {\n-                time(sess.time_passes(), \"all lto passes\", ||\n-                     lto::run(sess, llmod, tm, reachable, &config,\n-                              &name_extra, &output_names));\n-\n+                time(sess.time_passes(), \"all lto passes\", || {\n+                    let temp_no_opt_bc_filename =\n+                        output_names.temp_path_ext(\"no-opt.lto.bc\", module_name);\n+                    lto::run(sess,\n+                             llmod,\n+                             tm,\n+                             reachable,\n+                             &config,\n+                             &temp_no_opt_bc_filename);\n+                });\n                 if config.emit_lto_bc {\n-                    let name = format!(\"{}.lto.bc\", name_extra);\n-                    let out = output_names.with_extension(&name);\n+                    let out = output_names.temp_path_ext(\"lto.bc\", module_name);\n                     let out = path2cstr(&out);\n                     llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n                 }\n@@ -556,8 +562,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     let write_obj = config.emit_obj && !config.obj_is_bitcode;\n     let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n \n-    let bc_out = output_names.with_extension(&format!(\"{}.bc\", name_extra));\n-    let obj_out = output_names.with_extension(&format!(\"{}.o\", name_extra));\n+    let bc_out = output_names.temp_path(OutputType::Bitcode, module_name);\n+    let obj_out = output_names.temp_path(OutputType::Object, module_name);\n \n     if write_bc {\n         let bc_out_c = path2cstr(&bc_out);\n@@ -566,8 +572,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     time(config.time_passes, &format!(\"codegen passes [{}]\", cgcx.worker), || {\n         if config.emit_ir {\n-            let ext = format!(\"{}.ll\", name_extra);\n-            let out = output_names.with_extension(&ext);\n+            let out = output_names.temp_path(OutputType::LlvmAssembly, module_name);\n             let out = path2cstr(&out);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n@@ -576,7 +581,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(&format!(\"{}.s\", name_extra));\n+            let path = output_names.temp_path(OutputType::Assembly, module_name);\n \n             // We can't use the same module for asm and binary output, because that triggers\n             // various errors like invalid IR or broken binaries, so we might have to clone the\n@@ -713,27 +718,29 @@ pub fn run_passes(sess: &Session,\n \n     {\n         let work = build_work_item(sess,\n-                                   trans.metadata_module,\n+                                   trans.metadata_module.clone(),\n                                    metadata_config.clone(),\n-                                   crate_output.clone(),\n-                                   \"metadata\".to_string());\n+                                   crate_output.clone());\n         work_items.push(work);\n     }\n \n-    for (index, mtrans) in trans.modules.iter().enumerate() {\n+    for mtrans in trans.modules.iter() {\n         let work = build_work_item(sess,\n-                                   *mtrans,\n+                                   mtrans.clone(),\n                                    modules_config.clone(),\n-                                   crate_output.clone(),\n-                                   format!(\"{}\", index));\n+                                   crate_output.clone());\n         work_items.push(work);\n     }\n \n     // Process the work items, optionally using worker threads.\n-    if sess.opts.cg.codegen_units == 1 {\n+    // NOTE: This code is not really adapted to incremental compilation where\n+    //       the compiler decides the number of codegen units (and will\n+    //       potentially create hundreds of them).\n+    let num_workers = work_items.len() - 1;\n+    if num_workers == 1 {\n         run_work_singlethreaded(sess, &trans.reachable, work_items);\n     } else {\n-        run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n+        run_work_multithreaded(sess, work_items, num_workers);\n     }\n \n     // All codegen is finished.\n@@ -748,32 +755,42 @@ pub fn run_passes(sess: &Session,\n         }\n     };\n \n-    let copy_if_one_unit = |ext: &str,\n-                            output_type: OutputType,\n+    let copy_if_one_unit = |output_type: OutputType,\n                             keep_numbered: bool| {\n-        if sess.opts.cg.codegen_units == 1 {\n+        if trans.modules.len() == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n-            copy_gracefully(&crate_output.with_extension(ext),\n+            let module_name = Some(&(trans.modules[0].name)[..]);\n+            let path = crate_output.temp_path(output_type, module_name);\n+            copy_gracefully(&path,\n                             &crate_output.path(output_type));\n             if !sess.opts.cg.save_temps && !keep_numbered {\n-                // The user just wants `foo.x`, not `foo.0.x`.\n-                remove(sess, &crate_output.with_extension(ext));\n+                // The user just wants `foo.x`, not `foo.#module-name#.x`.\n+                remove(sess, &path);\n             }\n-        } else if crate_output.outputs.contains_key(&output_type) {\n-            // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n-            //    no good solution for this case, so warn the user.\n-            sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n-                                were produced\", ext));\n-        } else if crate_output.single_output_file.is_some() {\n-            // 3) Multiple codegen units, with `-o some_name`.  We have\n-            //    no good solution for this case, so warn the user.\n-            sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n-                                were produced\", ext));\n         } else {\n-            // 4) Multiple codegen units, but no explicit name.  We\n-            //    just leave the `foo.0.x` files in place.\n-            // (We don't have to do any work in this case.)\n+            let ext = crate_output.temp_path(output_type, None)\n+                                  .extension()\n+                                  .unwrap()\n+                                  .to_str()\n+                                  .unwrap()\n+                                  .to_owned();\n+\n+            if crate_output.outputs.contains_key(&output_type) {\n+                // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n+                                    were produced\", ext));\n+            } else if crate_output.single_output_file.is_some() {\n+                // 3) Multiple codegen units, with `-o some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n+                                    were produced\", ext));\n+            } else {\n+                // 4) Multiple codegen units, but no explicit name.  We\n+                //    just leave the `foo.0.x` files in place.\n+                // (We don't have to do any work in this case.)\n+            }\n         }\n     };\n \n@@ -789,17 +806,19 @@ pub fn run_passes(sess: &Session,\n                 // Copy to .bc, but always keep the .0.bc.  There is a later\n                 // check to figure out if we should delete .0.bc files, or keep\n                 // them for making an rlib.\n-                copy_if_one_unit(\"0.bc\", OutputType::Bitcode, true);\n+                copy_if_one_unit(OutputType::Bitcode, true);\n             }\n             OutputType::LlvmAssembly => {\n-                copy_if_one_unit(\"0.ll\", OutputType::LlvmAssembly, false);\n+                copy_if_one_unit(OutputType::LlvmAssembly, false);\n             }\n             OutputType::Assembly => {\n-                copy_if_one_unit(\"0.s\", OutputType::Assembly, false);\n+                // TODO: These are probably wrong\n+                copy_if_one_unit(OutputType::Assembly, false);\n             }\n             OutputType::Object => {\n                 user_wants_objects = true;\n-                copy_if_one_unit(\"0.o\", OutputType::Object, true);\n+                // TODO: These are probably wrong\n+                copy_if_one_unit(OutputType::Object, true);\n             }\n             OutputType::Exe |\n             OutputType::DepInfo => {}\n@@ -810,51 +829,55 @@ pub fn run_passes(sess: &Session,\n     // Clean up unwanted temporary files.\n \n     // We create the following files by default:\n-    //  - crate.0.bc\n-    //  - crate.0.o\n+    //  - crate.#module-name#.bc\n+    //  - crate.#module-name#.o\n     //  - crate.metadata.bc\n     //  - crate.metadata.o\n     //  - crate.o (linked from crate.##.o)\n-    //  - crate.bc (copied from crate.0.bc)\n+    //  - crate.bc (copied from crate.##.bc)\n     // We may create additional files if requested by the user (through\n     // `-C save-temps` or `--emit=` flags).\n \n     if !sess.opts.cg.save_temps {\n-        // Remove the temporary .0.o objects.  If the user didn't\n+        // Remove the temporary .#module-name#.o objects.  If the user didn't\n         // explicitly request bitcode (with --emit=bc), and the bitcode is not\n-        // needed for building an rlib, then we must remove .0.bc as well.\n+        // needed for building an rlib, then we must remove .#module-name#.bc as\n+        // well.\n \n-        // Specific rules for keeping .0.bc:\n+        // Specific rules for keeping .#module-name#.bc:\n         //  - If we're building an rlib (`needs_crate_bitcode`), then keep\n         //    it.\n         //  - If the user requested bitcode (`user_wants_bitcode`), and\n         //    codegen_units > 1, then keep it.\n         //  - If the user requested bitcode but codegen_units == 1, then we\n-        //    can toss .0.bc because we copied it to .bc earlier.\n+        //    can toss .#module-name#.bc because we copied it to .bc earlier.\n         //  - If we're not building an rlib and the user didn't request\n-        //    bitcode, then delete .0.bc.\n+        //    bitcode, then delete .#module-name#.bc.\n         // If you change how this works, also update back::link::link_rlib,\n-        // where .0.bc files are (maybe) deleted after making an rlib.\n+        // where .#module-name#.bc files are (maybe) deleted after making an\n+        // rlib.\n         let keep_numbered_bitcode = needs_crate_bitcode ||\n                 (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n \n         let keep_numbered_objects = needs_crate_object ||\n                 (user_wants_objects && sess.opts.cg.codegen_units > 1);\n \n-        for i in 0..trans.modules.len() {\n+        for module_name in trans.modules.iter().map(|m| Some(&m.name[..])) {\n             if modules_config.emit_obj && !keep_numbered_objects {\n-                let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(&ext));\n+                let path = crate_output.temp_path(OutputType::Object, module_name);\n+                remove(sess, &path);\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n-                let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(&ext));\n+                let path = crate_output.temp_path(OutputType::Bitcode, module_name);\n+                remove(sess, &path);\n             }\n         }\n \n         if metadata_config.emit_bc && !user_wants_bitcode {\n-            remove(sess, &crate_output.with_extension(\"metadata.bc\"));\n+            let path = crate_output.temp_path(OutputType::Bitcode,\n+                                              Some(&trans.metadata_module.name[..]));\n+            remove(sess, &path);\n         }\n     }\n \n@@ -874,28 +897,31 @@ pub fn run_passes(sess: &Session,\n struct WorkItem {\n     mtrans: ModuleTranslation,\n     config: ModuleConfig,\n-    output_names: OutputFilenames,\n-    name_extra: String\n+    output_names: OutputFilenames\n }\n \n fn build_work_item(sess: &Session,\n                    mtrans: ModuleTranslation,\n                    config: ModuleConfig,\n-                   output_names: OutputFilenames,\n-                   name_extra: String)\n+                   output_names: OutputFilenames)\n                    -> WorkItem\n {\n     let mut config = config;\n     config.tm = create_target_machine(sess);\n-    WorkItem { mtrans: mtrans, config: config, output_names: output_names,\n-               name_extra: name_extra }\n+    WorkItem {\n+        mtrans: mtrans,\n+        config: config,\n+        output_names: output_names\n+    }\n }\n \n fn execute_work_item(cgcx: &CodegenContext,\n                      work_item: WorkItem) {\n     unsafe {\n-        optimize_and_codegen(cgcx, work_item.mtrans, work_item.config,\n-                             work_item.name_extra, work_item.output_names);\n+        optimize_and_codegen(cgcx,\n+                             work_item.mtrans,\n+                             work_item.config,\n+                             work_item.output_names);\n     }\n }\n \n@@ -914,6 +940,8 @@ fn run_work_singlethreaded(sess: &Session,\n fn run_work_multithreaded(sess: &Session,\n                           work_items: Vec<WorkItem>,\n                           num_workers: usize) {\n+    assert!(num_workers > 0);\n+\n     // Run some workers to process the work items.\n     let work_items_arc = Arc::new(Mutex::new(work_items));\n     let mut diag_emitter = SharedEmitter::new();\n@@ -981,7 +1009,7 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let (pname, mut cmd, _) = get_linker(sess);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(&outputs.path(OutputType::Object))\n-                           .arg(&outputs.temp_path(OutputType::Assembly));\n+                           .arg(&outputs.temp_path(OutputType::Assembly, None));\n     debug!(\"{:?}\", cmd);\n \n     match cmd.output() {"}, {"sha": "41c214fe1b32649dea11d294ff6b01379bd200e5", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "patch": "@@ -2630,6 +2630,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n \n     let metadata_module = ModuleTranslation {\n+        name: \"metadata\".to_string(),\n         llcx: shared_ccx.metadata_llcx(),\n         llmod: shared_ccx.metadata_llmod(),\n     };\n@@ -2644,7 +2645,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let crate_context_list = CrateContextList::new(&shared_ccx, codegen_units);\n \n     let modules = crate_context_list.iter()\n-        .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n+        .map(|ccx| ModuleTranslation {\n+            name: String::from(&ccx.codegen_unit().name[..]),\n+            llcx: ccx.llcx(),\n+            llmod: ccx.llmod()\n+        })\n         .collect();\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n@@ -2790,6 +2795,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let linker_info = LinkerInfo::new(&shared_ccx, &reachable_symbols);\n+\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,"}, {"sha": "c465edc7311af7e23976d4770cc46ca9dd9055ed", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "patch": "@@ -129,8 +129,9 @@ mod type_;\n mod type_of;\n mod value;\n \n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub struct ModuleTranslation {\n+    pub name: String,\n     pub llcx: llvm::ContextRef,\n     pub llmod: llvm::ModuleRef,\n }"}, {"sha": "d15519a87d98015c2336d6d6efb5c03e96bc2606", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e8a13441cb4169ce4fb43be7f1369d5c9d71e0/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=65e8a13441cb4169ce4fb43be7f1369d5c9d71e0", "patch": "@@ -121,6 +121,7 @@ use llvm;\n use monomorphize;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n+use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use syntax::parse::token::{self, InternedString};\n@@ -283,7 +284,10 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     }\n \n     fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n-        token::intern_and_get_ident(&format!(\"{}.{}\", crate_name, index)[..])\n+        token::intern_and_get_ident(&format!(\"{}{}{}\",\n+            crate_name,\n+            NUMBERED_CODEGEN_UNIT_MARKER,\n+            index)[..])\n     }\n }\n "}]}