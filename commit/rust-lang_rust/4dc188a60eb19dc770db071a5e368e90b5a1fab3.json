{"sha": "4dc188a60eb19dc770db071a5e368e90b5a1fab3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYzE4OGE2MGViMTlkYzc3MGRiMDcxYTVlMzY4ZTkwYjVhMWZhYjM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-23T15:26:12Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-23T18:19:26Z"}, "message": "adjust for refactored memory pointer checks", "tree": {"sha": "010a580bb021e0e960ab266f986131d958d3dbb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/010a580bb021e0e960ab266f986131d958d3dbb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dc188a60eb19dc770db071a5e368e90b5a1fab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dc188a60eb19dc770db071a5e368e90b5a1fab3", "html_url": "https://github.com/rust-lang/rust/commit/4dc188a60eb19dc770db071a5e368e90b5a1fab3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dc188a60eb19dc770db071a5e368e90b5a1fab3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c65fbc49d7b9269b277b7207f1044ee851f16b16", "url": "https://api.github.com/repos/rust-lang/rust/commits/c65fbc49d7b9269b277b7207f1044ee851f16b16", "html_url": "https://github.com/rust-lang/rust/commit/c65fbc49d7b9269b277b7207f1044ee851f16b16"}], "stats": {"total": 131, "additions": 86, "deletions": 45}, "files": [{"sha": "b053d8c51e70ca66e6536b1f588dd0a1d25da493", "filename": "src/fn_call.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -654,7 +654,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem.\n             \"pthread_key_create\" => {\n-                let key_ptr = this.read_scalar(args[0])?.to_ptr()?;\n+                let key_ptr = this.read_scalar(args[0])?.not_undef()?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n                 let dtor = match this.read_scalar(args[1])?.not_undef()? {\n@@ -681,7 +681,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     return err!(OutOfTls);\n                 }\n \n-                this.memory().check_align(key_ptr.into(), key_layout.align.abi)?;\n+                let key_ptr = this.memory().check_ptr_access(key_ptr, key_layout.size, key_layout.align.abi)?\n+                    .expect(\"cannot be a ZST\");\n                 this.memory_mut().get_mut(key_ptr.alloc_id)?.write_scalar(\n                     tcx,\n                     key_ptr,"}, {"sha": "3f9c4e53f09d6f25ea15955c49f8355172055839", "filename": "src/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -517,13 +517,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let val_byte = this.read_scalar(args[1])?.to_u8()?;\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let count = this.read_scalar(args[2])?.to_usize(this)?;\n-                this.memory().check_align(ptr, ty_layout.align.abi)?;\n                 let byte_count = ty_layout.size * count;\n-                if byte_count.bytes() != 0 {\n-                    let ptr = ptr.to_ptr()?;\n-                    this.memory_mut()\n-                        .get_mut(ptr.alloc_id)?\n-                        .write_repeat(tcx, ptr, val_byte, byte_count)?;\n+                match this.memory().check_ptr_access(ptr, byte_count, ty_layout.align.abi)? {\n+                    Some(ptr) => {\n+                        this.memory_mut()\n+                            .get_mut(ptr.alloc_id)?\n+                            .write_repeat(tcx, ptr, val_byte, byte_count)?;\n+                    }\n+                    None => {\n+                        // Size is 0, nothing to do.\n+                    }\n                 }\n             }\n "}, {"sha": "b735cbcba4eceb07d9ef5476f25e309af4085f25", "filename": "src/operator.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -4,6 +4,11 @@ use rustc::mir;\n use crate::*;\n \n pub trait EvalContextExt<'tcx> {\n+    fn pointer_inbounds(\n+        &self,\n+        ptr: Pointer<Tag>\n+    ) -> InterpResult<'tcx>;\n+\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n@@ -34,6 +39,13 @@ pub trait EvalContextExt<'tcx> {\n }\n \n impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n+    /// Test if the pointer is in-bounds of a live allocation.\n+    #[inline]\n+    fn pointer_inbounds(&self, ptr: Pointer<Tag>) -> InterpResult<'tcx> {\n+        let (size, _align) = self.memory().get_size_and_align(ptr.alloc_id, AllocCheck::Live)?;\n+        ptr.check_in_alloc(size, CheckInAllocMsg::InboundsTest)\n+    }\n+\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n@@ -114,8 +126,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 let left = left.to_ptr().expect(\"we checked is_ptr\");\n                 let right = right.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\");\n                 let (_alloc_size, alloc_align) = self.memory()\n-                    .get_size_and_align(left.alloc_id, InboundsCheck::MaybeDead)\n-                    .expect(\"determining size+align of dead ptr cannot fail\");\n+                    .get_size_and_align(left.alloc_id, AllocCheck::MaybeDead)\n+                    .expect(\"alloc info with MaybeDead cannot fail\");\n                 let min_ptr_val = u128::from(alloc_align.bytes()) + u128::from(left.offset.bytes());\n                 let result = match bin_op {\n                     Gt => min_ptr_val > right,\n@@ -170,6 +182,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 if left.alloc_id == right.alloc_id {\n                     left.offset == right.offset\n                 } else {\n+                    // Make sure both pointers are in-bounds.\n                     // This accepts one-past-the end. Thus, there is still technically\n                     // some non-determinism that we do not fully rule out when two\n                     // allocations sit right next to each other. The C/C++ standards are\n@@ -179,10 +192,12 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                     // Dead allocations in miri cannot overlap with live allocations, but\n                     // on read hardware this can easily happen. Thus for comparisons we require\n                     // both pointers to be live.\n-                    self.memory().check_bounds_ptr(left, InboundsCheck::Live, CheckInAllocMsg::InboundsTest)?;\n-                    self.memory().check_bounds_ptr(right, InboundsCheck::Live, CheckInAllocMsg::InboundsTest)?;\n-                    // Two in-bounds pointers, we can compare across allocations.\n-                    left == right\n+                    if self.pointer_inbounds(left).is_ok() && self.pointer_inbounds(right).is_ok() {\n+                        // Two in-bounds pointers, we can compare across allocations.\n+                        left == right\n+                    } else {\n+                        return err!(InvalidPointerMath);\n+                    }\n                 }\n             }\n             // Comparing ptr and integer.\n@@ -202,16 +217,16 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 // alignment 32 or higher, hence the limit of 32.\n                 // FIXME: Once we support intptrcast, we could try to fix these holes.\n                 if bits < 32 {\n-                    // Test if the ptr is in-bounds. Then it cannot be NULL.\n-                    // Even dangling pointers cannot be NULL.\n-                    if self.memory().check_bounds_ptr(ptr, InboundsCheck::MaybeDead, CheckInAllocMsg::NullPointerTest).is_ok() {\n+                    // Test if the pointer can be different from NULL or not.\n+                    // We assume that pointers that are not NULL are also not \"small\".\n+                    if !self.memory().ptr_may_be_null(ptr) {\n                         return Ok(false);\n                     }\n                 }\n \n                 let (alloc_size, alloc_align) = self.memory()\n-                    .get_size_and_align(ptr.alloc_id, InboundsCheck::MaybeDead)\n-                    .expect(\"determining size+align of dead ptr cannot fail\");\n+                    .get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n+                    .expect(\"alloc info with MaybeDead cannot fail\");\n \n                 // Case II: Alignment gives it away\n                 if ptr.offset.bytes() % alloc_align.bytes() == 0 {\n@@ -359,9 +374,9 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         if let Scalar::Ptr(ptr) = ptr {\n             // Both old and new pointer must be in-bounds of a *live* allocation.\n             // (Of the same allocation, but that part is trivial with our representation.)\n-            self.memory().check_bounds_ptr(ptr, InboundsCheck::Live, CheckInAllocMsg::InboundsTest)?;\n+            self.pointer_inbounds(ptr)?;\n             let ptr = ptr.signed_offset(offset, self)?;\n-            self.memory().check_bounds_ptr(ptr, InboundsCheck::Live, CheckInAllocMsg::InboundsTest)?;\n+            self.pointer_inbounds(ptr)?;\n             Ok(Scalar::Ptr(ptr))\n         } else {\n             // An integer pointer. They can only be offset by 0, and we pretend there"}, {"sha": "3a0c257428e11c5b62de1242eb01795e2e24e734", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -10,7 +10,7 @@ use rustc::mir::RetagKind;\n \n use crate::{\n     InterpResult, InterpError, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n-    MemoryKind, MiriMemoryKind, RangeMap, Allocation, AllocationExtra, AllocId, CheckInAllocMsg,\n+    MemoryKind, MiriMemoryKind, RangeMap, Allocation, AllocationExtra, AllocId,\n     Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n@@ -531,13 +531,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let protector = if protect { Some(this.frame().extra) } else { None };\n-        let ptr = place.ptr.to_ptr()?;\n+        let ptr = this.memory().check_ptr_access(place.ptr, size, place.align)\n+            .expect(\"validity checks should have excluded dangling/unaligned pointer\")\n+            .expect(\"we shouldn't get here for ZST\");\n         trace!(\"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             kind, new_tag, ptr.tag, place.layout.ty, ptr.erase_tag(), size.bytes());\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let alloc = this.memory().get(ptr.alloc_id)?;\n-        alloc.check_bounds(this, ptr, size, CheckInAllocMsg::InboundsTest)?;\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!"}, {"sha": "5badf099e4391ae5b939aa4f23abbdd2b5826224", "filename": "tests/compile-fail/ptr_eq_dangling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fptr_eq_dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fptr_eq_dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_dangling.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let y = &*b as *const i32; // different allocation\n     // We cannot compare these even though both are inbounds -- they *could* be\n     // equal if memory was reused.\n-    assert!(x != y); //~ ERROR dangling pointer\n+    assert!(x != y); //~ ERROR invalid arithmetic on pointers\n }"}, {"sha": "7efa446d7fca489f97254dd90bb0bdd9b428d979", "filename": "tests/compile-fail/ptr_eq_out_of_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let y = &*b as *const i32; // different allocation\n     // We cannot compare these even though both allocations are live -- they *could* be\n     // equal (with the right base addresses).\n-    assert!(x != y); //~ ERROR outside bounds\n+    assert!(x != y); //~ ERROR invalid arithmetic on pointers\n }"}, {"sha": "086467eea311bea6d365fbbf20b9e82cd957b88f", "filename": "tests/compile-fail/rc_as_raw.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Frc_as_raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Frc_as_raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frc_as_raw.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -1,3 +1,5 @@\n+// This should fail even without validation\n+// compile-flags: -Zmiri-disable-validation\n #![feature(weak_into_raw)]\n \n use std::rc::{Rc, Weak};"}, {"sha": "92e1fae75a045e44447a12d19536934903a70b73", "filename": "tests/compile-fail/unaligned_ptr_cast1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Funaligned_ptr_cast1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Funaligned_ptr_cast1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast1.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -2,8 +2,8 @@\n // compile-flags: -Zmiri-disable-validation\n \n fn main() {\n-    let x = &2u16;\n-    let x = x as *const _ as *const u32;\n+    let x = [2u16, 3, 4]; // Make it big enough so we don't get an out-of-bounds error.\n+    let x = &x[0] as *const _ as *const u32;\n     // This must fail because alignment is violated\n     let _x = unsafe { *x }; //~ ERROR tried to access memory with alignment 2, but alignment 4 is required\n }"}, {"sha": "783661c55710396bbcd49cf543b276a6955bc8b2", "filename": "tests/compile-fail/unaligned_ptr_cast2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -2,8 +2,8 @@\n // compile-flags: -Zmiri-disable-validation\n \n fn main() {\n-    let x = &2u16;\n-    let x = x as *const _ as *const *const u8;\n+    let x = [2u16, 3, 4, 5]; // Make it big enough so we don't get an out-of-bounds error.\n+    let x = &x[0] as *const _ as *const *const u8;\n     // This must fail because alignment is violated. Test specifically for loading pointers,\n     // which have special code in miri's memory.\n     let _x = unsafe { *x };"}, {"sha": "4318c7c90271f00825e9ad4572b86760cdcc7f5e", "filename": "tests/compile-fail/validity/dangling_ref1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref1.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -1,5 +1,5 @@\n use std::mem;\n \n fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR tried to interpret some bytes as a pointer\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR integer pointer in non-ZST reference\n }"}, {"sha": "ef76b93d11e2d15bbbb8ee5bc60905b0e49d3e26", "filename": "tests/compile-fail/validity/dangling_ref2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref2.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -3,5 +3,5 @@ use std::mem;\n fn main() {\n     let val = 14;\n     let ptr = (&val as *const i32).wrapping_offset(1);\n-    let _x: &i32 = unsafe { mem::transmute(ptr) }; //~ ERROR outside bounds of allocation\n+    let _x: &i32 = unsafe { mem::transmute(ptr) }; //~ ERROR encountered dangling (not entirely in bounds) reference\n }"}, {"sha": "0488926870a21bd8bc00bbee72b12bc76305d100", "filename": "tests/compile-fail/zst.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65fbc49d7b9269b277b7207f1044ee851f16b16/tests%2Fcompile-fail%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65fbc49d7b9269b277b7207f1044ee851f16b16/tests%2Fcompile-fail%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst.rs?ref=c65fbc49d7b9269b277b7207f1044ee851f16b16", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let x = &() as *const () as *const i32;\n-    let _val = unsafe { *x }; //~ ERROR access memory with alignment 1, but alignment 4 is required\n-}"}, {"sha": "e4ce7b8ecdf8cef956f17c579ab579c50c6ce38b", "filename": "tests/compile-fail/zst1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fzst1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fzst1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst1.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    // make sure ZST locals cannot be accessed\n+    let x = &() as *const () as *const i8;\n+    let _val = unsafe { *x }; //~ ERROR pointer must be in-bounds\n+}"}, {"sha": "950f7b3d60e6d192c3e8ea27d13f84fc702debb4", "filename": "tests/compile-fail/zst2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fzst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fzst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst2.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -0,0 +1,12 @@\n+fn main() {\n+    // Not using the () type here, as writes of that type do not even have MIR generated.\n+    // Also not assigning directly as that's array initialization, not assignment.\n+    let zst_val = [1u8; 0];\n+\n+    // make sure ZST accesses are checked against being \"truly\" dangling pointers\n+    // (into deallocated allocations).\n+    let mut x_box = Box::new(1u8);\n+    let x = &mut *x_box as *mut _ as *mut [u8; 0];\n+    drop(x_box);\n+    unsafe { *x = zst_val; } //~ ERROR dangling pointer was dereferenced\n+}"}, {"sha": "a16ec0186d77683622f4507f770765a9eaf3384b", "filename": "tests/compile-fail/zst3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fzst3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Fcompile-fail%2Fzst3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst3.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -0,0 +1,15 @@\n+fn main() {\n+    // Not using the () type here, as writes of that type do not even have MIR generated.\n+    // Also not assigning directly as that's array initialization, not assignment.\n+    let zst_val = [1u8; 0];\n+\n+    // make sure ZST accesses are checked against being \"truly\" dangling pointers\n+    // (that are out-of-bounds).\n+    let mut x_box = Box::new(1u8);\n+    let x = (&mut *x_box as *mut u8).wrapping_offset(1);\n+    // This one is just \"at the egde\", but still okay\n+    unsafe { *(x as *mut [u8; 0]) = zst_val; }\n+    // One byte further is OOB.\n+    let x = x.wrapping_offset(1);\n+    unsafe { *(x as *mut [u8; 0]) = zst_val; } //~ ERROR pointer must be in-bounds\n+}"}, {"sha": "988473570913999fc83c0dd9d224f5d64b604000", "filename": "tests/run-pass/zst.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Frun-pass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc188a60eb19dc770db071a5e368e90b5a1fab3/tests%2Frun-pass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst.rs?ref=4dc188a60eb19dc770db071a5e368e90b5a1fab3", "patch": "@@ -21,13 +21,4 @@ fn main() {\n     // Reading and writing is ok.\n     unsafe { *x = zst_val; }\n     unsafe { let _y = *x; }\n-\n-    // We should even be able to use \"true\" pointers for ZST when the allocation has been\n-    // removed already. The box is for a non-ZST to make sure there actually is an allocation.\n-    let mut x_box = Box::new(((), 1u8));\n-    let x = &mut x_box.0 as *mut _ as *mut [u8; 0];\n-    drop(x_box);\n-    // Reading and writing is ok.\n-    unsafe { *x = zst_val; }\n-    unsafe { let _y = *x; }\n }"}]}