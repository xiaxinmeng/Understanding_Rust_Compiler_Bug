{"sha": "2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNDVhOWFiNTRmYmY1OTNjNmRmODRlODg1MmZjMWIzZjFmMDgxMGE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-09-03T18:25:52Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-09-04T16:14:13Z"}, "message": "Support bitcasts in platform intrinsic generator.", "tree": {"sha": "8eee2a96776bc088dbef628185b58d4afea0482e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eee2a96776bc088dbef628185b58d4afea0482e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a", "html_url": "https://github.com/rust-lang/rust/commit/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62e346af4b7a1aac43db627f19d2511d5649e5d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/62e346af4b7a1aac43db627f19d2511d5649e5d7", "html_url": "https://github.com/rust-lang/rust/commit/62e346af4b7a1aac43db627f19d2511d5649e5d7"}], "stats": {"total": 158, "additions": 120, "deletions": 38}, "files": [{"sha": "8708e7c2f0f8b3d816007bfe49a66a3a12c4e4ec", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 105, "deletions": 34, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a", "patch": "@@ -19,8 +19,8 @@\n SPEC = re.compile(\n     r'^(?:(?P<void>V)|(?P<id>[iusfIUSF])(?:\\((?P<start>\\d+)-(?P<end>\\d+)\\)|'\n     r'(?P<width>\\d+)(:?/(?P<llvm_width>\\d+))?)'\n-    r'|(?P<reference>\\d+)(?P<modifiers>[vShdnwusDMC]*)(?P<force_width>x\\d+)?)'\n-    r'(?:(?P<pointer>Pm|Pc)(?P<llvm_pointer>/.*)?)?$'\n+    r'|(?P<reference>\\d+))(?P<modifiers>[vShdnwusDMC]*)(?P<force_width>x\\d+)?'\n+    r'(?:(?P<pointer>Pm|Pc)(?P<llvm_pointer>/.*)?|(?P<bitcast>->.*))?$'\n )\n \n class PlatformInfo(object):\n@@ -74,6 +74,9 @@ def __init__(self, llvm_name, properties):\n         self.properties = properties\n         self.llvm_name = llvm_name\n \n+    def __repr__(self):\n+        return '<PlatformTypeInfo {}, {}>'.format(self.llvm_name, self.properties)\n+\n     def __getattr__(self, name):\n         return self.properties[name]\n \n@@ -94,9 +97,12 @@ def __init__(self, bitwidth):\n     def bitwidth(self):\n         return self._bitwidth\n \n-    def modify(self, spec, width):\n+    def modify(self, spec, width, previous):\n         raise NotImplementedError()\n \n+    def __ne__(self, other):\n+        return not (self == other)\n+\n class Void(Type):\n     def __init__(self):\n         Type.__init__(self, 0)\n@@ -110,11 +116,14 @@ def rust_name(self):\n     def type_info(self, platform_info):\n         return None\n \n+    def __eq__(self, other):\n+        return isinstance(other, Void)\n+\n class Number(Type):\n     def __init__(self, bitwidth):\n         Type.__init__(self, bitwidth)\n \n-    def modify(self, spec, width):\n+    def modify(self, spec, width, previous):\n         if spec == 'u':\n             return Unsigned(self.bitwidth())\n         elif spec == 's':\n@@ -131,11 +140,16 @@ def modify(self, spec, width):\n     def type_info(self, platform_info):\n         return platform_info.number_type_info(self)\n \n+    def __eq__(self, other):\n+        # print(self, other)\n+        return self.__class__ == other.__class__ and self.bitwidth() == other.bitwidth()\n+\n class Signed(Number):\n     def __init__(self, bitwidth, llvm_bitwidth = None):\n         Number.__init__(self, bitwidth)\n         self._llvm_bitwidth = llvm_bitwidth\n \n+\n     def compiler_ctor(self):\n         if self._llvm_bitwidth is None:\n             return 'i({})'.format(self.bitwidth())\n@@ -184,26 +198,47 @@ def rust_name(self):\n         return 'f{}'.format(self.bitwidth())\n \n class Vector(Type):\n-    def __init__(self, elem, length):\n+    def __init__(self, elem, length, bitcast = None):\n         assert isinstance(elem, Type) and not isinstance(elem, Vector)\n         Type.__init__(self,\n                       elem.bitwidth() * length)\n         self._length = length\n         self._elem = elem\n+        assert bitcast is None or (isinstance(bitcast, Vector) and\n+                                   bitcast._bitcast is None and\n+                                   bitcast._elem.bitwidth() == elem.bitwidth())\n+        if bitcast is not None and bitcast._elem != elem:\n+            self._bitcast = bitcast._elem\n+        else:\n+            self._bitcast = None\n \n-    def modify(self, spec, width):\n-        if spec == 'h':\n+    def modify(self, spec, width, previous):\n+        if spec == 'S':\n+            return self._elem\n+        elif spec == 'h':\n             return Vector(self._elem, self._length // 2)\n         elif spec == 'd':\n             return Vector(self._elem, self._length * 2)\n         elif spec.startswith('x'):\n             new_bitwidth = int(spec[1:])\n             return Vector(self._elem, new_bitwidth // self._elem.bitwidth())\n+        elif spec.startswith('->'):\n+            bitcast_to = TypeSpec(spec[2:])\n+            choices = list(bitcast_to.enumerate(width, previous))\n+            assert len(choices) == 1\n+            bitcast_to = choices[0]\n+            return Vector(self._elem, self._length, bitcast_to)\n         else:\n-            return Vector(self._elem.modify(spec, width), self._length)\n+            return Vector(self._elem.modify(spec, width, previous), self._length)\n \n     def compiler_ctor(self):\n-        return 'v({}, {})'.format(self._elem.compiler_ctor(), self._length)\n+        if self._bitcast is None:\n+            return 'v({}, {})'.format(self._elem.compiler_ctor(),\n+                                      self._length)\n+        else:\n+            return 'v_({}, {}, {})'.format(self._elem.compiler_ctor(),\n+                                           self._bitcast.compiler_ctor(),\n+                                           self._length)\n \n     def rust_name(self):\n         return '{}x{}'.format(self._elem.rust_name(), self._length)\n@@ -213,22 +248,26 @@ def type_info(self, platform_info):\n         return elem_info.vectorize(self._length,\n                                    platform_info.width_info(self.bitwidth()))\n \n+    def __eq__(self, other):\n+        return isinstance(other, Vector) and self._length == other._length and \\\n+            self._elem == other._elem and self._bitcast == other._bitcast\n+\n class Pointer(Type):\n     def __init__(self, elem, llvm_elem, const):\n         self._elem = elem;\n         self._llvm_elem = llvm_elem\n         self._const = const\n         Type.__init__(self, BITWIDTH_POINTER)\n \n-    def modify(self, spec, width):\n+    def modify(self, spec, width, previous):\n         if spec == 'D':\n             return self._elem\n         elif spec == 'M':\n             return Pointer(self._elem, self._llvm_elem, False)\n         elif spec == 'C':\n             return Pointer(self._elem, self._llvm_elem, True)\n         else:\n-            return Pointer(self._elem.modify(spec, width), self._llvm_elem, self._const)\n+            return Pointer(self._elem.modify(spec, width, previous), self._llvm_elem, self._const)\n \n     def compiler_ctor(self):\n         if self._llvm_elem is None:\n@@ -246,6 +285,10 @@ def rust_name(self):\n     def type_info(self, platform_info):\n         return self._elem.type_info(platform_info).pointer()\n \n+    def __eq__(self, other):\n+        return isinstance(other, Pointer) and self._const == other._const \\\n+            and self._elem == other._elem and self._llvm_elem == other._llvm_elem\n+\n class Aggregate(Type):\n     def __init__(self, flatten, elems):\n         self._flatten = flatten\n@@ -266,6 +309,10 @@ def type_info(self, platform_info):\n         #return PlatformTypeInfo(None, None, self._llvm_name)\n         return None\n \n+    def __eq__(self, other):\n+        return isinstance(other, Aggregate) and self._flatten == other._flatten and \\\n+            self._elems == other._elems\n+\n \n TYPE_ID_LOOKUP = {'i': [Signed, Unsigned],\n                   's': [Signed],\n@@ -302,6 +349,14 @@ def enumerate(self, width, previous):\n                 id = match.group('id')\n                 reference = match.group('reference')\n \n+                modifiers = list(match.group('modifiers') or '')\n+                force = match.group('force_width')\n+                if force is not None:\n+                    modifiers.append(force)\n+                bitcast = match.group('bitcast')\n+                if bitcast is not None:\n+                    modifiers.append(bitcast)\n+\n                 if match.group('void') is not None:\n                     assert spec == 'V'\n                     yield Void()\n@@ -333,7 +388,11 @@ def enumerate(self, width, previous):\n                             if is_vector:\n                                 elem = Vector(scalar, width // bitwidth)\n                             else:\n+                                assert bitcast is None\n                                 elem = scalar\n+\n+                            for x in modifiers:\n+                                elem = elem.modify(x, width, previous)\n                             yield ptrify(match, elem, width, previous)\n                         bitwidth *= 2\n                 elif reference is not None:\n@@ -342,15 +401,13 @@ def enumerate(self, width, previous):\n                         'referring to argument {}, but only {} are known'.format(reference,\n                                                                                  len(previous))\n                     ret = previous[reference]\n-                    for x in match.group('modifiers') or []:\n-                        ret = ret.modify(x, width)\n-                    force = match.group('force_width')\n-                    if force is not None:\n-                        ret = ret.modify(force, width)\n+                    for x in modifiers:\n+                        ret = ret.modify(x, width, previous)\n                     yield ptrify(match, ret, width, previous)\n                 else:\n                     assert False, 'matched `{}`, but didn\\'t understand it?'.format(spec)\n             elif spec.startswith('('):\n+                assert bitcast is None\n                 if spec.endswith(')'):\n                     raise NotImplementedError()\n                 elif spec.endswith(')f'):\n@@ -452,12 +509,16 @@ def parse_args():\n         ## Type specifier grammar\n \n         ```\n-        type := core_type pointer?\n+        type := core_type modifier* suffix?\n \n         core_type := void | vector | scalar | aggregate | reference\n \n+        modifier := 'v' | 'h' | 'd' | 'n' | 'w' | 'u' | 's' |\n+                     'x' number\n+        suffix := pointer | bitcast\n         pointer := 'Pm' llvm_pointer? | 'Pc' llvm_pointer?\n         llvm_pointer := '/' type\n+        bitcast := '->' type\n \n         void := 'V'\n \n@@ -470,28 +531,13 @@ def parse_args():\n \n         aggregate := '(' (type),* ')' 'f'?\n \n-        reference := number modifiers*\n-        modifiers := 'v' | 'h' | 'd' | 'n' | 'w' | 'u' | 's' |\n-                     'x' number\n-\n+        reference := number\n \n         width = number | '(' number '-' number ')'\n \n         number = [0-9]+\n         ```\n \n-        ## Pointers\n-\n-        Pointers can be created to any type. The `m` vs. `c` chooses\n-        mut vs. const. e.g. `S32Pm` corresponds to `*mut i32`, and\n-        `i32Pc` corresponds (with width 128) to `*const i8x16`,\n-        `*const u32x4`, etc.\n-\n-        The type after the `/` (optional) represents the type used\n-        internally to LLVM, e.g. `S32pm/S8` is exposed as `*mut i32`\n-        in Rust, but is `i8*` in LLVM. (This defaults to the main\n-        type).\n-\n         ## Void\n \n         The `V` type corresponds to `void` in LLVM (`()` in\n@@ -550,6 +596,11 @@ def parse_args():\n         with 0 == return value, 1 == first argument, 2 == second\n         argument, etc.\n \n+        ## Affixes\n+\n+        The `modifier` and `suffix` adaptors change the precise\n+        representation.\n+\n         ### Modifiers\n \n         - 'v': put a scalar into a vector of the current width (u32 -> u32x4, when width == 128)\n@@ -563,6 +614,26 @@ def parse_args():\n         - 'D': dereference a pointer (*mut u32 -> u32)\n         - 'C': make a pointer const (*mut u32 -> *const u32)\n         - 'M': make a pointer mut (*const u32 -> *mut u32)\n+\n+        ### Pointers\n+\n+        Pointers can be created of any type by appending a `P*`\n+        suffix. The `m` vs. `c` chooses mut vs. const. e.g. `S32Pm`\n+        corresponds to `*mut i32`, and `i32Pc` corresponds (with width\n+        128) to `*const i8x16`, `*const u32x4`, etc.\n+\n+        The type after the `/` (optional) represents the type used\n+        internally to LLVM, e.g. `S32pm/S8` is exposed as `*mut i32`\n+        in Rust, but is `i8*` in LLVM. (This defaults to the main\n+        type).\n+\n+        ### Bitcast\n+\n+        The `'->' type` bitcast suffix will cause the value to be\n+        bitcast to the right-hand type when calling the intrinsic,\n+        e.g. `s32->f32` will expose the intrinsic as `i32x4` at the\n+        Rust level, but will cast that vector to `f32x4` when calling\n+        the LLVM intrinsic.\n         '''))\n     parser.add_argument('--format', choices=FORMATS, required=True,\n                         help = 'Output format.')\n@@ -611,7 +682,7 @@ def open(self, platform):\n \n #![allow(unused_imports)]\n \n-use {{Intrinsic, i, i_, u, u_, f, v, agg, p, void}};\n+use {{Intrinsic, i, i_, u, u_, f, v, v_, agg, p, void}};\n use IntrinsicDef::Named;\n use rustc::middle::ty;\n "}, {"sha": "9aee15b05df4cd212af49b76d251300fd33b6fef", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a", "patch": "@@ -34,7 +34,7 @@ pub enum Type {\n     Integer(/* signed */ bool, u8, /* llvm width */ u8),\n     Float(u8),\n     Pointer(Box<Type>, Option<Box<Type>>, /* const */ bool),\n-    Vector(Box<Type>, u8),\n+    Vector(Box<Type>, Option<Box<Type>>, u8),\n     Aggregate(bool, Vec<Type>),\n }\n \n@@ -48,7 +48,10 @@ fn u(width: u8) -> Type { Type::Integer(false, width, width) }\n #[allow(dead_code)]\n fn u_(width: u8, llvm_width: u8) -> Type { Type::Integer(false, width, llvm_width) }\n fn f(width: u8) -> Type { Type::Float(width) }\n-fn v(x: Type, length: u8) -> Type { Type::Vector(Box::new(x), length) }\n+fn v(x: Type, length: u8) -> Type { Type::Vector(Box::new(x), None, length) }\n+fn v_(x: Type, bitcast: Type, length: u8) -> Type {\n+    Type::Vector(Box::new(x), Some(Box::new(bitcast)), length)\n+}\n fn agg(flatten: bool, types: Vec<Type>) -> Type {\n     Type::Aggregate(flatten, types)\n }"}, {"sha": "becdd71f1d37f775c4973dd30f300a7dfd6297be", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a", "patch": "@@ -956,7 +956,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                   any_changes_needed));\n                         vec![elem.ptr_to()]\n                     }\n-                    Vector(ref t, length) => {\n+                    Vector(ref t, ref llvm_elem, length) => {\n+                        *any_changes_needed |= llvm_elem.is_some();\n+\n+                        let t = llvm_elem.as_ref().unwrap_or(t);\n                         let elem = one(ty_to_type(ccx, t,\n                                                   any_changes_needed));\n                         vec![Type::vector(&elem,\n@@ -1005,6 +1008,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         vec![PointerCast(bcx, llarg,\n                                          llvm_elem.ptr_to())]\n                     }\n+                    intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n+                        let llvm_elem = one(ty_to_type(bcx.ccx(), llvm_elem, &mut false));\n+                        vec![BitCast(bcx, llarg,\n+                                     Type::vector(&llvm_elem, length as u64))]\n+                    }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n                         // size than the C intrinsic's signature, so"}, {"sha": "d1f898d82fdd395bd17fd29e13fd5b7a765f1cec", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=2b45a9ab54fbf593c6df84e8852fc1b3f1f0810a", "patch": "@@ -503,7 +503,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                                   &format!(\"raw pointer\")),\n             }\n         }\n-        Vector(ref inner_expected, len) => {\n+        Vector(ref inner_expected, ref _llvm_type, len) => {\n             if !t.is_simd() {\n                 simple_error(&format!(\"non-simd type `{}`\", t),\n                              \"simd type\");"}]}