{"sha": "e2d5cebe32c0b1fae7f612a16a9e7b62ed740660", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZDVjZWJlMzJjMGIxZmFlN2Y2MTJhMTZhOWU3YjYyZWQ3NDA2NjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-13T12:00:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-13T12:00:57Z"}, "message": "auto merge of #5761 : Dretch/rust/murder-death-kill, r=thestinger\n\nAs proposed in issue #5632.\r\n\r\nI added some new stuff to libc - hopefully correctly. I only added a single signal constant (SIGKILL) because adding more seems complicated by differences between platforms - and since it is not required for issue #5632 then I figure that I can use a further pull request to flesh out the SIG* constants more.", "tree": {"sha": "b96d36235e174212434135a84b765e8894328817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b96d36235e174212434135a84b765e8894328817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660", "html_url": "https://github.com/rust-lang/rust/commit/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d57aaae02525f6e3c7a051fed94966dbbad5e7cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d57aaae02525f6e3c7a051fed94966dbbad5e7cf", "html_url": "https://github.com/rust-lang/rust/commit/d57aaae02525f6e3c7a051fed94966dbbad5e7cf"}, {"sha": "995d44416b203b5b3ba619250ff8effdcf205049", "url": "https://api.github.com/repos/rust-lang/rust/commits/995d44416b203b5b3ba619250ff8effdcf205049", "html_url": "https://github.com/rust-lang/rust/commit/995d44416b203b5b3ba619250ff8effdcf205049"}], "stats": {"total": 151, "additions": 136, "deletions": 15}, "files": [{"sha": "02c72bcd2f0d09218aef8bc6ac73a9567f598f0b", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=e2d5cebe32c0b1fae7f612a16a9e7b62ed740660", "patch": "@@ -863,6 +863,8 @@ pub mod consts {\n             pub static F_TEST : int = 3;\n             pub static F_TLOCK : int = 2;\n             pub static F_ULOCK : int = 0;\n+            pub static SIGKILL : int = 9;\n+            pub static SIGTERM : int = 15;\n         }\n         pub mod posix01 {\n         }\n@@ -930,6 +932,8 @@ pub mod consts {\n             pub static F_TEST : int = 3;\n             pub static F_TLOCK : int = 2;\n             pub static F_ULOCK : int = 0;\n+            pub static SIGKILL : int = 9;\n+            pub static SIGTERM : int = 15;\n         }\n         pub mod posix01 {\n         }\n@@ -998,6 +1002,8 @@ pub mod consts {\n             pub static F_TEST : int = 3;\n             pub static F_TLOCK : int = 2;\n             pub static F_ULOCK : int = 0;\n+            pub static SIGKILL : int = 9;\n+            pub static SIGTERM : int = 15;\n         }\n         pub mod posix01 {\n         }\n@@ -1482,6 +1488,17 @@ pub mod funcs {\n                              -> ssize_t;\n             }\n         }\n+\n+        #[nolink]\n+        #[abi = \"cdecl\"]\n+        pub mod signal {\n+            use libc::types::os::arch::c95::{c_int};\n+            use libc::types::os::arch::posix88::{pid_t};\n+\n+            pub extern {\n+                unsafe fn kill(pid: pid_t, sig: c_int) -> c_int;\n+            }\n+        }\n     }\n \n     #[cfg(target_os = \"linux\")]\n@@ -1623,6 +1640,7 @@ pub mod funcs {\n     pub mod extra {\n \n         pub mod kernel32 {\n+            use libc::types::os::arch::c95::{c_uint};\n             use libc::types::os::arch::extra::{BOOL, DWORD, HMODULE};\n             use libc::types::os::arch::extra::{LPCWSTR, LPWSTR, LPTCH};\n             use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES};\n@@ -1663,6 +1681,7 @@ pub mod funcs {\n                                        findFileData: HANDLE)\n                     -> BOOL;\n                 unsafe fn FindClose(findFile: HANDLE) -> BOOL;\n+                unsafe fn TerminateProcess(hProcess: HANDLE, uExitCode: c_uint) -> BOOL;\n             }\n         }\n "}, {"sha": "f6f4b9a397d81d09e8c97c5f70fcd9ad2d447686", "filename": "src/libcore/run.rs", "status": "modified", "additions": 117, "deletions": 15, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=e2d5cebe32c0b1fae7f612a16a9e7b62ed740660", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -44,13 +44,13 @@ pub trait Program {\n     /// Returns the process id of the program\n     fn get_id(&mut self) -> pid_t;\n \n-    /// Returns an io::writer that can be used to write to stdin\n+    /// Returns an io::Writer that can be used to write to stdin\n     fn input(&mut self) -> @io::Writer;\n \n-    /// Returns an io::reader that can be used to read from stdout\n+    /// Returns an io::Reader that can be used to read from stdout\n     fn output(&mut self) -> @io::Reader;\n \n-    /// Returns an io::reader that can be used to read from stderr\n+    /// Returns an io::Reader that can be used to read from stderr\n     fn err(&mut self) -> @io::Reader;\n \n     /// Closes the handle to the child processes standard input\n@@ -62,8 +62,23 @@ pub trait Program {\n      */\n     fn finish(&mut self) -> int;\n \n-    /// Closes open handles\n+    /**\n+     * Terminate the program, giving it a chance to clean itself up if\n+     * this is supported by the operating system.\n+     *\n+     * On Posix OSs SIGTERM will be sent to the process. On Win32\n+     * TerminateProcess(..) will be called.\n+     */\n     fn destroy(&mut self);\n+\n+    /**\n+     * Terminate the program as soon as possible without giving it a\n+     * chance to clean itself up.\n+     *\n+     * On Posix OSs SIGKILL will be sent to the process. On Win32\n+     * TerminateProcess(..) will be called.\n+     */\n+    fn force_destroy(&mut self);\n }\n \n \n@@ -172,6 +187,14 @@ fn with_dirp<T>(d: &Option<~str>,\n     }\n }\n \n+/// helper function that closes non-NULL files and then makes them NULL\n+priv unsafe fn fclose_and_null(f: &mut *libc::FILE) {\n+    if *f != 0 as *libc::FILE {\n+        libc::fclose(*f);\n+        *f = 0 as *libc::FILE;\n+    }\n+}\n+\n /**\n  * Spawns a process and waits for it to terminate\n  *\n@@ -192,9 +215,9 @@ pub fn run_program(prog: &str, args: &[~str]) -> int {\n }\n \n /**\n- * Spawns a process and returns a program\n+ * Spawns a process and returns a Program\n  *\n- * The returned value is a boxed class containing a <program> object that can\n+ * The returned value is a boxed class containing a <Program> object that can\n  * be used for sending and receiving data over the standard file descriptors.\n  * The class will ensure that file descriptors are closed properly.\n  *\n@@ -240,28 +263,59 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n             r.in_fd = invalid_fd;\n         }\n     }\n+\n+    fn close_repr_outputs(r: &mut ProgRepr) {\n+        unsafe {\n+            fclose_and_null(&mut r.out_file);\n+            fclose_and_null(&mut r.err_file);\n+        }\n+    }\n+\n     fn finish_repr(r: &mut ProgRepr) -> int {\n         if r.finished { return 0; }\n         r.finished = true;\n         close_repr_input(&mut *r);\n         return waitpid(r.pid);\n     }\n-    fn destroy_repr(r: &mut ProgRepr) {\n-        unsafe {\n-            finish_repr(&mut *r);\n-            libc::fclose(r.out_file);\n-            libc::fclose(r.err_file);\n+\n+    fn destroy_repr(r: &mut ProgRepr, force: bool) {\n+        killpid(r.pid, force);\n+        finish_repr(&mut *r);\n+        close_repr_outputs(&mut *r);\n+\n+        #[cfg(windows)]\n+        fn killpid(pid: pid_t, _force: bool) {\n+            unsafe {\n+                libc::funcs::extra::kernel32::TerminateProcess(\n+                    cast::transmute(pid), 1);\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn killpid(pid: pid_t, force: bool) {\n+\n+            let signal = if force {\n+                libc::consts::os::posix88::SIGKILL\n+            } else {\n+                libc::consts::os::posix88::SIGTERM\n+            };\n+\n+            unsafe {\n+                libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+            }\n         }\n     }\n+\n     struct ProgRes {\n         r: ProgRepr,\n     }\n \n     impl Drop for ProgRes {\n         fn finalize(&self) {\n             unsafe {\n-                // FIXME #4943: This is bad.\n-                destroy_repr(cast::transmute(&self.r));\n+                // FIXME #4943: transmute is bad.\n+                finish_repr(cast::transmute(&self.r));\n+                close_repr_outputs(cast::transmute(&self.r));\n             }\n         }\n     }\n@@ -285,8 +339,10 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n         }\n         fn close_input(&mut self) { close_repr_input(&mut self.r); }\n         fn finish(&mut self) -> int { finish_repr(&mut self.r) }\n-        fn destroy(&mut self) { destroy_repr(&mut self.r); }\n+        fn destroy(&mut self) { destroy_repr(&mut self.r, false); }\n+        fn force_destroy(&mut self) { destroy_repr(&mut self.r, true); }\n     }\n+\n     let mut repr = ProgRepr {\n         pid: pid,\n         in_fd: pipe_input.out,\n@@ -458,8 +514,10 @@ pub fn waitpid(pid: pid_t) -> int {\n \n #[cfg(test)]\n mod tests {\n+    use libc;\n     use option::None;\n     use os;\n+    use path::Path;\n     use run::{readclose, writeclose};\n     use run;\n \n@@ -507,6 +565,50 @@ mod tests {\n         assert!(status == 1);\n     }\n \n+    #[test]\n+    pub fn test_destroy_once() {\n+        let mut p = run::start_program(\"echo\", []);\n+        p.destroy(); // this shouldn't crash (and nor should the destructor)\n+    }\n+\n+    #[test]\n+    pub fn test_destroy_twice() {\n+        let mut p = run::start_program(\"echo\", []);\n+        p.destroy(); // this shouldnt crash...\n+        p.destroy(); // ...and nor should this (and nor should the destructor)\n+    }\n+\n+    #[cfg(unix)] // there is no way to sleep on windows from inside libcore...\n+    pub fn test_destroy_actually_kills(force: bool) {\n+        let path = Path(fmt!(\"test/core-run-test-destroy-actually-kills-%?.tmp\", force));\n+\n+        os::remove_file(&path);\n+\n+        let cmd = fmt!(\"sleep 5 && echo MurderDeathKill > %s\", path.to_str());\n+        let mut p = run::start_program(\"sh\", [~\"-c\", cmd]);\n+\n+        p.destroy(); // destroy the program before it has a chance to echo its message\n+\n+        unsafe {\n+            // wait to ensure the program is really destroyed and not just waiting itself\n+            libc::sleep(10);\n+        }\n+\n+        // the program should not have had chance to echo its message\n+        assert!(!path.exists());\n+    }\n+\n+    #[test]\n+    #[cfg(unix)]\n+    pub fn test_unforced_destroy_actually_kills() {\n+        test_destroy_actually_kills(false);\n+    }\n+\n+    #[test]\n+    #[cfg(unix)]\n+    pub fn test_forced_destroy_actually_kills() {\n+        test_destroy_actually_kills(true);\n+    }\n }\n \n // Local Variables:"}]}