{"sha": "84284472533b1e48e6365f6c37b644d0fe00647a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0Mjg0NDcyNTMzYjFlNDhlNjM2NWY2YzM3YjY0NGQwZmUwMDY0N2E=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-24T03:26:10Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-09T02:31:04Z"}, "message": "Move resolution to before lowering", "tree": {"sha": "d8b210e2de7f08084b215fd35a26f0e63de06f6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8b210e2de7f08084b215fd35a26f0e63de06f6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84284472533b1e48e6365f6c37b644d0fe00647a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84284472533b1e48e6365f6c37b644d0fe00647a", "html_url": "https://github.com/rust-lang/rust/commit/84284472533b1e48e6365f6c37b644d0fe00647a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84284472533b1e48e6365f6c37b644d0fe00647a/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16c8f2cca89d071738443a2143880e0079553632", "url": "https://api.github.com/repos/rust-lang/rust/commits/16c8f2cca89d071738443a2143880e0079553632", "html_url": "https://github.com/rust-lang/rust/commit/16c8f2cca89d071738443a2143880e0079553632"}], "stats": {"total": 719, "additions": 398, "deletions": 321}, "files": [{"sha": "25ccfb8d6bcbc76d56236a80d254422191e79d00", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=84284472533b1e48e6365f6c37b644d0fe00647a", "patch": "@@ -1438,7 +1438,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let loop_expr = hir::ExprLoop(loop_block,\n                                               opt_ident.map(|ident| lower_ident(lctx, ident)));\n                 // add attributes to the outer returned expr node\n-                return expr(lctx, e.span, loop_expr, e.attrs.clone());\n+                let attrs = e.attrs.clone();\n+                return P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: attrs });\n             }\n \n             // Desugar ExprForLoop\n@@ -1515,7 +1516,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let loop_block = block_expr(lctx, match_expr);\n                 let loop_expr = hir::ExprLoop(loop_block,\n                                               opt_ident.map(|ident| lower_ident(lctx, ident)));\n-                let loop_expr = expr(lctx, e.span, loop_expr, None);\n+                let loop_expr =\n+                    P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: None });\n \n                 // `mut iter => { ... }`\n                 let iter_arm = {"}, {"sha": "358301ab4042a2f3a085287cc6268da8916de59a", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=84284472533b1e48e6365f6c37b644d0fe00647a", "patch": "@@ -195,6 +195,10 @@ impl Definitions {\n         self.opt_def_index(node).map(DefId::local)\n     }\n \n+    pub fn local_def_id(&self, node: ast::NodeId) -> DefId {\n+        self.opt_local_def_id(node).unwrap()\n+    }\n+\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n             assert!(def_id.index.as_usize() < self.data.len());"}, {"sha": "35dad578e0e8b004b2d31b4263a7d30a8f1f9a38", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=84284472533b1e48e6365f6c37b644d0fe00647a", "patch": "@@ -10,7 +10,8 @@\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n+use rustc::hir::def::DefMap;\n use rustc_mir as mir;\n use rustc::mir::mir_map::MirMap;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n@@ -139,9 +140,32 @@ pub fn compile_input(sess: &Session,\n \n         time(sess.time_passes(),\n              \"external crate/lib resolution\",\n-             || LocalCrateReader::new(sess, &cstore, &defs, &expanded_crate, &id)\n+             || LocalCrateReader::new(sess, &cstore, defs, &expanded_crate, &id)\n                     .read_crates(&dep_graph));\n \n+        time(sess.time_passes(),\n+             \"early lint checks\",\n+             || lint::check_ast_crate(sess, &expanded_crate));\n+\n+        let resolve::CrateMap {\n+            def_map,\n+            freevars,\n+            maybe_unused_trait_imports,\n+            export_map,\n+            trait_map,\n+            glob_map,\n+        } = time(sess.time_passes(), \"name resolution\", || {\n+            resolve::resolve_crate(sess, &expanded_crate, &defs.borrow(), control.make_glob_map)\n+        });\n+\n+        let analysis = ty::CrateAnalysis {\n+            export_map: export_map,\n+            access_levels: AccessLevels::default(),\n+            reachable: NodeSet(),\n+            name: &id,\n+            glob_map: glob_map,\n+        };\n+\n         // Lower ast -> hir.\n         let lcx = LoweringContext::new(sess, Some(&expanded_crate), defs);\n         let hir_forest = &mut time(sess.time_passes(),\n@@ -185,10 +209,6 @@ pub fn compile_input(sess: &Session,\n             hir::check_attr::check_crate(sess, &expanded_crate);\n         });\n \n-        time(sess.time_passes(),\n-             \"early lint checks\",\n-             || lint::check_ast_crate(sess, &expanded_crate));\n-\n         let opt_crate = if keep_ast(sess) {\n             Some(&expanded_crate)\n         } else {\n@@ -200,7 +220,11 @@ pub fn compile_input(sess: &Session,\n                                     hir_map,\n                                     &arenas,\n                                     &id,\n-                                    control.make_glob_map,\n+                                    analysis,\n+                                    def_map,\n+                                    freevars,\n+                                    trait_map,\n+                                    maybe_unused_trait_imports,\n                                     |tcx, mir_map, analysis, result| {\n             {\n                 // Eventually, we will want to track plugins.\n@@ -763,7 +787,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                hir_map: hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n-                                               make_glob_map: resolve::MakeGlobMap,\n+                                               mut analysis: ty::CrateAnalysis,\n+                                               def_map: RefCell<DefMap>,\n+                                               freevars: FreevarMap,\n+                                               trait_map: TraitMap,\n+                                               maybe_unused_trait_imports: NodeSet,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: FnOnce(&TyCtxt<'tcx>, Option<MirMap<'tcx>>, ty::CrateAnalysis, CompileResult) -> R\n@@ -788,25 +816,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         })\n     })?;\n \n-    let resolve::CrateMap {\n-        def_map,\n-        freevars,\n-        maybe_unused_trait_imports,\n-        export_map,\n-        trait_map,\n-        glob_map,\n-    } = time(sess.time_passes(),\n-             \"name resolution\",\n-             || resolve::resolve_crate(sess, &hir_map, make_glob_map));\n-\n-    let mut analysis = ty::CrateAnalysis {\n-        export_map: export_map,\n-        access_levels: AccessLevels::default(),\n-        reachable: NodeSet(),\n-        name: name,\n-        glob_map: glob_map,\n-    };\n-\n     let named_region_map = time(time_passes,\n                                 \"lifetime resolution\",\n                                 || middle::resolve_lifetime::krate(sess,"}, {"sha": "f56b22f924891bf0dca827a52e473e273b91b82e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 75, "deletions": 81, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=84284472533b1e48e6365f6c37b644d0fe00647a", "patch": "@@ -29,18 +29,15 @@ use rustc::ty::{self, VariantKind};\n \n use syntax::ast::{Name, NodeId};\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token::keywords;\n+use syntax::parse::token::{self, keywords};\n use syntax::codemap::{Span, DUMMY_SP};\n \n-use rustc::hir;\n-use rustc::hir::{Block, DeclItem};\n-use rustc::hir::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n-use rustc::hir::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n-use rustc::hir::{ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaultImpl};\n-use rustc::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n-use rustc::hir::{PathListIdent, PathListMod, StmtDecl};\n-use rustc::hir::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use rustc::hir::intravisit::{self, Visitor};\n+use syntax::ast::{Block, Crate, DeclKind};\n+use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n+use syntax::ast::{Mutability, PathListItemKind};\n+use syntax::ast::{SelfKind, Stmt, StmtKind, TraitItemKind};\n+use syntax::ast::{Variant, ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::visit::{self, Visitor};\n \n trait ToNameBinding<'a> {\n     fn to_name_binding(self) -> NameBinding<'a>;\n@@ -58,14 +55,14 @@ impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n     }\n }\n \n-impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n+impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for the entire crate.\n-    pub fn build_reduced_graph(&mut self, krate: &hir::Crate) {\n+    pub fn build_reduced_graph(&mut self, krate: &Crate) {\n         let mut visitor = BuildReducedGraphVisitor {\n             parent: self.graph_root,\n             resolver: self,\n         };\n-        intravisit::walk_crate(&mut visitor, krate);\n+        visit::walk_crate(&mut visitor, krate);\n     }\n \n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined.\n@@ -85,9 +82,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        fn is_item(statement: &hir::Stmt) -> bool {\n-            if let StmtDecl(ref declaration, _) = statement.node {\n-                if let DeclItem(_) = declaration.node {\n+        fn is_item(statement: &Stmt) -> bool {\n+            if let StmtKind::Decl(ref declaration, _) = statement.node {\n+                if let DeclKind::Item(_) = declaration.node {\n                     return true;\n                 }\n             }\n@@ -98,7 +95,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         block.stmts.iter().any(is_item)\n     }\n \n-    fn sanity_check_import(&self, view_path: &hir::ViewPath, id: NodeId) {\n+    fn sanity_check_import(&self, view_path: &ViewPath, id: NodeId) {\n         let path = match view_path.node {\n             ViewPathSimple(_, ref path) |\n             ViewPathGlob (ref path) |\n@@ -131,13 +128,13 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, parent_ref: &mut Module<'b>) {\n         let parent = *parent_ref;\n-        let name = item.name;\n+        let name = item.ident.name;\n         let sp = item.span;\n         self.current_module = parent;\n         let vis = self.resolve_visibility(&item.vis);\n \n         match item.node {\n-            ItemUse(ref view_path) => {\n+            ItemKind::Use(ref view_path) => {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n@@ -175,21 +172,20 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n                         }\n \n-                        let subclass = ImportDirectiveSubclass::single(binding, source_name);\n+                        let subclass = ImportDirectiveSubclass::single(binding.name, source_name);\n                         let span = view_path.span;\n                         parent.add_import_directive(module_path, subclass, span, item.id, vis);\n                         self.unresolved_imports += 1;\n                     }\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter()\n-                                                    .filter_map(|item| {\n-                                                        match item.node {\n-                                                            PathListMod { .. } => Some(item.span),\n-                                                            _ => None,\n-                                                        }\n-                                                    })\n-                                                    .collect::<Vec<Span>>();\n+                        let mod_spans = source_items.iter().filter_map(|item| {\n+                            match item.node {\n+                                PathListItemKind::Mod { .. } => Some(item.span),\n+                                _ => None,\n+                            }\n+                        }).collect::<Vec<Span>>();\n+\n                         if mod_spans.len() > 1 {\n                             let mut e = resolve_struct_error(self,\n                                           mod_spans[0],\n@@ -202,9 +198,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n                         for source_item in source_items {\n                             let (module_path, name, rename) = match source_item.node {\n-                                PathListIdent { name, rename, .. } =>\n-                                    (module_path.clone(), name, rename.unwrap_or(name)),\n-                                PathListMod { rename, .. } => {\n+                                PathListItemKind::Ident { name, rename, .. } =>\n+                                    (module_path.clone(), name.name, rename.unwrap_or(name).name),\n+                                PathListItemKind::Mod { rename, .. } => {\n                                     let name = match module_path.last() {\n                                         Some(name) => *name,\n                                         None => {\n@@ -218,7 +214,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                         }\n                                     };\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = rename.unwrap_or(name);\n+                                    let rename = rename.map(|i| i.name).unwrap_or(name);\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n@@ -237,7 +233,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 }\n             }\n \n-            ItemExternCrate(_) => {\n+            ItemKind::ExternCrate(_) => {\n                 // n.b. we don't need to look at the path option here, because cstore already\n                 // did\n                 if let Some(crate_id) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n@@ -254,76 +250,77 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 }\n             }\n \n-            ItemMod(..) => {\n+            ItemKind::Mod(..) => {\n                 let parent_link = ModuleParentLink(parent, name);\n-                let def = Def::Mod(self.ast_map.local_def_id(item.id));\n+                let def = Def::Mod(self.definitions.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n                 self.module_map.insert(item.id, module);\n                 *parent_ref = module;\n             }\n \n-            ItemForeignMod(..) => {}\n+            ItemKind::ForeignMod(..) => {}\n \n             // These items live in the value namespace.\n-            ItemStatic(_, m, _) => {\n-                let mutbl = m == hir::MutMutable;\n-                let def = Def::Static(self.ast_map.local_def_id(item.id), mutbl);\n+            ItemKind::Static(_, m, _) => {\n+                let mutbl = m == Mutability::Mutable;\n+                let def = Def::Static(self.definitions.local_def_id(item.id), mutbl);\n                 self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n-            ItemConst(_, _) => {\n-                let def = Def::Const(self.ast_map.local_def_id(item.id));\n+            ItemKind::Const(_, _) => {\n+                let def = Def::Const(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n-            ItemFn(_, _, _, _, _, _) => {\n-                let def = Def::Fn(self.ast_map.local_def_id(item.id));\n+            ItemKind::Fn(_, _, _, _, _, _) => {\n+                let def = Def::Fn(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n \n             // These items live in the type namespace.\n-            ItemTy(..) => {\n-                let def = Def::TyAlias(self.ast_map.local_def_id(item.id));\n+            ItemKind::Ty(..) => {\n+                let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, TypeNS, (def, sp, vis));\n             }\n \n-            ItemEnum(ref enum_definition, _) => {\n+            ItemKind::Enum(ref enum_definition, _) => {\n                 let parent_link = ModuleParentLink(parent, name);\n-                let def = Def::Enum(self.ast_map.local_def_id(item.id));\n+                let def = Def::Enum(self.definitions.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n-                    let item_def_id = self.ast_map.local_def_id(item.id);\n+                    let item_def_id = self.definitions.local_def_id(item.id);\n                     self.build_reduced_graph_for_variant(variant, item_def_id, module, vis);\n                 }\n             }\n \n             // These items live in both the type and value namespaces.\n-            ItemStruct(ref struct_def, _) => {\n+            ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n-                let def = Def::Struct(self.ast_map.local_def_id(item.id));\n+                let def = Def::Struct(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, TypeNS, (def, sp, vis));\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if !struct_def.is_struct() {\n-                    let def = Def::Struct(self.ast_map.local_def_id(struct_def.id()));\n+                    let def = Def::Struct(self.definitions.local_def_id(struct_def.id()));\n                     self.define(parent, name, ValueNS, (def, sp, vis));\n                 }\n \n                 // Record the def ID and fields of this struct.\n-                let field_names = struct_def.fields().iter().map(|field| {\n+                let field_names = struct_def.fields().iter().enumerate().map(|(index, field)| {\n                     self.resolve_visibility(&field.vis);\n-                    field.name\n+                    field.ident.map(|ident| ident.name)\n+                               .unwrap_or_else(|| token::intern(&index.to_string()))\n                 }).collect();\n-                let item_def_id = self.ast_map.local_def_id(item.id);\n+                let item_def_id = self.definitions.local_def_id(item.id);\n                 self.structs.insert(item_def_id, field_names);\n             }\n \n-            ItemDefaultImpl(_, _) | ItemImpl(..) => {}\n+            ItemKind::DefaultImpl(_, _) | ItemKind::Impl(..) => {}\n \n-            ItemTrait(_, _, _, ref items) => {\n-                let def_id = self.ast_map.local_def_id(item.id);\n+            ItemKind::Trait(_, _, _, ref items) => {\n+                let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n                 let parent_link = ModuleParentLink(parent, name);\n@@ -333,22 +330,23 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n                 // Add the names of all the items to the trait info.\n                 for item in items {\n-                    let item_def_id = self.ast_map.local_def_id(item.id);\n+                    let item_def_id = self.definitions.local_def_id(item.id);\n                     let mut is_static_method = false;\n                     let (def, ns) = match item.node {\n-                        hir::ConstTraitItem(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n-                        hir::MethodTraitItem(ref sig, _) => {\n-                            is_static_method = sig.explicit_self.node == hir::SelfStatic;\n+                        TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n+                        TraitItemKind::Method(ref sig, _) => {\n+                            is_static_method = sig.explicit_self.node == SelfKind::Static;\n                             (Def::Method(item_def_id), ValueNS)\n                         }\n-                        hir::TypeTraitItem(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n+                        TraitItemKind::Type(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n                     };\n \n-                    self.define(module_parent, item.name, ns, (def, item.span, vis));\n+                    self.define(module_parent, item.ident.name, ns, (def, item.span, vis));\n \n-                    self.trait_item_map.insert((item.name, def_id), is_static_method);\n+                    self.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n                 }\n             }\n+            ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n         }\n     }\n \n@@ -359,16 +357,16 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                        item_id: DefId,\n                                        parent: Module<'b>,\n                                        vis: ty::Visibility) {\n-        let name = variant.node.name;\n+        let name = variant.node.name.name;\n         if variant.node.data.is_struct() {\n             // Not adding fields for variants as they are not accessed with a self receiver\n-            let variant_def_id = self.ast_map.local_def_id(variant.node.data.id());\n+            let variant_def_id = self.definitions.local_def_id(variant.node.data.id());\n             self.structs.insert(variant_def_id, Vec::new());\n         }\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let def = Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id()));\n+        let def = Def::Variant(item_id, self.definitions.local_def_id(variant.node.data.id()));\n         self.define(parent, name, ValueNS, (def, variant.span, vis));\n         self.define(parent, name, TypeNS, (def, variant.span, vis));\n     }\n@@ -377,14 +375,14 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n                                             parent: Module<'b>) {\n-        let name = foreign_item.name;\n+        let name = foreign_item.ident.name;\n \n         let def = match foreign_item.node {\n-            ForeignItemFn(..) => {\n-                Def::Fn(self.ast_map.local_def_id(foreign_item.id))\n+            ForeignItemKind::Fn(..) => {\n+                Def::Fn(self.definitions.local_def_id(foreign_item.id))\n             }\n-            ForeignItemStatic(_, m) => {\n-                Def::Static(self.ast_map.local_def_id(foreign_item.id), m)\n+            ForeignItemKind::Static(_, m) => {\n+                Def::Static(self.definitions.local_def_id(foreign_item.id), m)\n             }\n         };\n         self.current_module = parent;\n@@ -526,20 +524,16 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     }\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>,\n+struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n+    resolver: &'a mut Resolver<'b>,\n     parent: Module<'b>,\n }\n \n-impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.resolver.ast_map.expect_item(item.id))\n-    }\n-\n+impl<'a, 'b, 'v> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &Item) {\n         let old_parent = self.parent;\n         self.resolver.build_reduced_graph_for_item(item, &mut self.parent);\n-        intravisit::walk_item(self, item);\n+        visit::walk_item(self, item);\n         self.parent = old_parent;\n     }\n \n@@ -550,7 +544,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     fn visit_block(&mut self, block: &Block) {\n         let old_parent = self.parent;\n         self.resolver.build_reduced_graph_for_block(block, &mut self.parent);\n-        intravisit::walk_block(self, block);\n+        visit::walk_block(self, block);\n         self.parent = old_parent;\n     }\n }"}, {"sha": "64347d7b84d3c4fb5ead87a6a58c6d4fbf84fc92", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=84284472533b1e48e6365f6c37b644d0fe00647a", "patch": "@@ -25,33 +25,31 @@ use Resolver;\n use Namespace::{TypeNS, ValueNS};\n \n use rustc::lint;\n-use syntax::ast;\n+use syntax::ast::{self, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::visit::{self, Visitor};\n use syntax::codemap::{Span, DUMMY_SP};\n \n-use rustc::hir;\n-use rustc::hir::{ViewPathGlob, ViewPathList, ViewPathSimple};\n-use rustc::hir::intravisit::Visitor;\n \n-struct UnusedImportCheckVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>,\n+struct UnusedImportCheckVisitor<'a, 'b: 'a> {\n+    resolver: &'a mut Resolver<'b>,\n }\n \n // Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n-impl<'a, 'b, 'tcx:'b> Deref for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    type Target = Resolver<'b, 'tcx>;\n+impl<'a, 'b> Deref for UnusedImportCheckVisitor<'a, 'b> {\n+    type Target = Resolver<'b>;\n \n-    fn deref<'c>(&'c self) -> &'c Resolver<'b, 'tcx> {\n+    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b, 'tcx:'b> DerefMut for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b, 'tcx> {\n+impl<'a, 'b> DerefMut for UnusedImportCheckVisitor<'a, 'b> {\n+    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n         &mut *self.resolver\n     }\n }\n \n-impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     // We have information about whether `use` (import) directives are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, id: ast::NodeId, span: Span) {\n@@ -73,18 +71,19 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        visit::walk_item(self, item);\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if item.vis == hir::Public || item.span.source_equal(&DUMMY_SP) {\n+        if item.vis == ast::Visibility::Public || item.span.source_equal(&DUMMY_SP) {\n             return;\n         }\n \n         match item.node {\n-            hir::ItemExternCrate(_) => {\n+            ast::ItemKind::ExternCrate(_) => {\n                 if let Some(crate_num) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n                     if !self.used_crates.contains(&crate_num) {\n                         self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n@@ -94,7 +93,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemUse(ref p) => {\n+            ast::ItemKind::Use(ref p) => {\n                 match p.node {\n                     ViewPathSimple(_, _) => {\n                         self.check_import(item.id, p.span)\n@@ -115,7 +114,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     }\n }\n \n-pub fn check_crate(resolver: &mut Resolver, krate: &hir::Crate) {\n+pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n     let mut visitor = UnusedImportCheckVisitor { resolver: resolver };\n-    krate.visit_all_items(&mut visitor);\n+    visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "f90f8481a25fe159838a54ac0ca926e2dbe5e203", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 219, "deletions": 188, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=84284472533b1e48e6365f6c37b644d0fe00647a", "patch": "@@ -43,42 +43,31 @@ use self::AssocItemResolveResult::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n \n-use rustc::dep_graph::DepNode;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::Definitions;\n+use rustc::hir::{PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::pat_util::pat_bindings;\n use rustc::ty;\n use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n+use syntax::ext::mtwt;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::codemap::{self, Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n-use rustc::hir::intravisit::{self, FnKind, Visitor};\n-use rustc::hir;\n-use rustc::hir::{Arm, BindByRef, BindByValue, BindingMode, Block};\n-use rustc::hir::Crate;\n-use rustc::hir::{Expr, ExprAgain, ExprBreak, ExprField};\n-use rustc::hir::{ExprLoop, ExprWhile, ExprMethodCall};\n-use rustc::hir::{ExprPath, ExprStruct, FnDecl};\n-use rustc::hir::{ForeignItemFn, ForeignItemStatic, Generics};\n-use rustc::hir::{ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n-use rustc::hir::{ItemFn, ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaultImpl};\n-use rustc::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n-use rustc::hir::Local;\n-use rustc::hir::{Pat, PatKind, Path, PrimTy};\n-use rustc::hir::{PathSegment, PathParameters};\n-use rustc::hir::HirVec;\n-use rustc::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n-use rustc::hir::{TyRptr, TyStr, TyUint, TyPath};\n+use syntax::visit::{self, FnKind, Visitor};\n+use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n+use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n+use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n+use syntax::ast::{Local, Pat, PatKind, Path};\n+use syntax::ast::{PathSegment, PathParameters, TraitItemKind, TraitRef, Ty, TyKind};\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -197,16 +186,16 @@ enum UnresolvedNameContext<'a> {\n     Other,\n }\n \n-fn resolve_error<'b, 'a: 'b, 'tcx: 'a, 'c>(resolver: &'b Resolver<'a, 'tcx>,\n-                                           span: syntax::codemap::Span,\n-                                           resolution_error: ResolutionError<'c>) {\n+fn resolve_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n+                                 span: syntax::codemap::Span,\n+                                 resolution_error: ResolutionError<'c>) {\n     resolve_struct_error(resolver, span, resolution_error).emit();\n }\n \n-fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a, 'c>(resolver: &'b Resolver<'a, 'tcx>,\n-                                                  span: syntax::codemap::Span,\n-                                                  resolution_error: ResolutionError<'b>)\n-                                                  -> DiagnosticBuilder<'c> {\n+fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n+                                        span: syntax::codemap::Span,\n+                                        resolution_error: ResolutionError<'c>)\n+                                        -> DiagnosticBuilder<'a> {\n     if !resolver.emit_errors {\n         return resolver.session.diagnostic().struct_dummy();\n     }\n@@ -424,13 +413,13 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a, 'c>(resolver: &'b Resolver<'a, 'tc\n                 UnresolvedNameContext::Other => { } // no help available\n                 UnresolvedNameContext::PathIsMod(parent) => {\n                     err.help(&match parent.map(|parent| &parent.node) {\n-                        Some(&ExprField(_, ident)) => {\n+                        Some(&ExprKind::Field(_, ident)) => {\n                             format!(\"To reference an item from the `{module}` module, \\\n                                      use `{module}::{ident}`\",\n                                     module = path,\n                                     ident = ident.node)\n                         }\n-                        Some(&ExprMethodCall(ident, _, _)) => {\n+                        Some(&ExprKind::MethodCall(ident, _, _)) => {\n                             format!(\"To call a function from the `{module}` module, \\\n                                      use `{module}::{ident}(..)`\",\n                                     module = path,\n@@ -528,10 +517,7 @@ pub enum Namespace {\n     ValueNS,\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.ast_map.expect_item(item.id))\n-    }\n+impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n     }\n@@ -553,18 +539,18 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_generics(&mut self, generics: &Generics) {\n         self.resolve_generics(generics);\n     }\n-    fn visit_poly_trait_ref(&mut self, tref: &hir::PolyTraitRef, m: &hir::TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, tref: &ast::PolyTraitRef, m: &ast::TraitBoundModifier) {\n         match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0) {\n             Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n             Err(_) => {\n                 // error already reported\n                 self.record_def(tref.trait_ref.ref_id, err_path_resolution())\n             }\n         }\n-        intravisit::walk_poly_trait_ref(self, tref, m);\n+        visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_variant(&mut self,\n-                     variant: &hir::Variant,\n+                     variant: &ast::Variant,\n                      generics: &Generics,\n                      item_id: ast::NodeId) {\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n@@ -574,22 +560,22 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n             });\n         }\n \n-        // `intravisit::walk_variant` without the discriminant expression.\n+        // `visit::walk_variant` without the discriminant expression.\n         self.visit_variant_data(&variant.node.data,\n                                 variant.node.name,\n                                 generics,\n                                 item_id,\n                                 variant.span);\n     }\n-    fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         let type_parameters = match foreign_item.node {\n-            ForeignItemFn(_, ref generics) => {\n+            ForeignItemKind::Fn(_, ref generics) => {\n                 HasTypeParameters(generics, FnSpace, ItemRibKind)\n             }\n-            ForeignItemStatic(..) => NoTypeParameters,\n+            ForeignItemKind::Static(..) => NoTypeParameters,\n         };\n         self.with_type_parameter_rib(type_parameters, |this| {\n-            intravisit::walk_foreign_item(this, foreign_item);\n+            visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n     fn visit_fn(&mut self,\n@@ -599,16 +585,16 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n-            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n+            FnKind::ItemFn(_, generics, _, _, _, _) => {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            FnKind::Method(_, sig, _, _) => {\n+            FnKind::Method(_, sig, _) => {\n                 self.visit_generics(&sig.generics);\n                 self.visit_explicit_self(&sig.explicit_self);\n                 MethodRibKind\n             }\n-            FnKind::Closure(_) => ClosureRibKind(node_id),\n+            FnKind::Closure => ClosureRibKind(node_id),\n         };\n         self.resolve_function(rib_kind, declaration, block);\n     }\n@@ -648,17 +634,17 @@ enum FallbackSuggestion {\n }\n \n #[derive(Copy, Clone)]\n-enum TypeParameters<'tcx, 'a> {\n+enum TypeParameters<'a, 'b> {\n     NoTypeParameters,\n     HasTypeParameters(// Type parameters.\n-                      &'a Generics,\n+                      &'b Generics,\n \n                       // Identifies the things that these parameters\n                       // were declared on (type, fn, etc)\n                       ParamSpace,\n \n                       // The kind of the rib used for type parameters.\n-                      RibKind<'tcx>),\n+                      RibKind<'a>),\n }\n \n // The rib kind controls the translation of local\n@@ -973,10 +959,10 @@ impl PrimitiveTypeTable {\n }\n \n /// The main resolver class.\n-pub struct Resolver<'a, 'tcx: 'a> {\n+pub struct Resolver<'a> {\n     session: &'a Session,\n \n-    ast_map: &'a hir_map::Map<'tcx>,\n+    definitions: &'a Definitions,\n \n     graph_root: Module<'a>,\n \n@@ -1081,9 +1067,9 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n-impl<'a, 'tcx> ty::NodeIdTree for Resolver<'a, 'tcx> {\n+impl<'a> ty::NodeIdTree for Resolver<'a> {\n     fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n-        let ancestor = self.ast_map.local_def_id(ancestor);\n+        let ancestor = self.definitions.local_def_id(ancestor);\n         let mut module = *self.module_map.get(&node).unwrap();\n         while module.def_id() != Some(ancestor) {\n             let module_parent = match self.get_nearest_normal_module_parent(module) {\n@@ -1096,13 +1082,13 @@ impl<'a, 'tcx> ty::NodeIdTree for Resolver<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Resolver<'a, 'tcx> {\n+impl<'a> Resolver<'a> {\n     fn new(session: &'a Session,\n-           ast_map: &'a hir_map::Map<'tcx>,\n+           definitions: &'a Definitions,\n            make_glob_map: MakeGlobMap,\n            arenas: &'a ResolverArenas<'a>)\n-           -> Resolver<'a, 'tcx> {\n-        let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n+           -> Resolver<'a> {\n+        let root_def_id = definitions.local_def_id(CRATE_NODE_ID);\n         let graph_root =\n             ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, arenas);\n         let graph_root = arenas.alloc_module(graph_root);\n@@ -1112,7 +1098,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         Resolver {\n             session: session,\n \n-            ast_map: ast_map,\n+            definitions: definitions,\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1335,7 +1321,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        let ident = hir::Ident::from_name(module_path[0]);\n+                        let ident = ast::Ident::with_empty_ctxt(module_path[0]);\n                         match self.resolve_ident_in_lexical_scope(ident, TypeNS, true)\n                                   .and_then(LexicalScopeBinding::module) {\n                             None => return Failed(None),\n@@ -1377,11 +1363,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_ident_in_lexical_scope(&mut self,\n-                                      ident: hir::Ident,\n+                                      ident: ast::Ident,\n                                       ns: Namespace,\n                                       record_used: bool)\n                                       -> Option<LexicalScopeBinding<'a>> {\n-        let name = match ns { ValueNS => ident.name, TypeNS => ident.unhygienic_name };\n+        let name = match ns { ValueNS => mtwt::resolve(ident), TypeNS => ident.name };\n \n         // Walk backwards up the ribs in scope.\n         for i in (0 .. self.get_ribs(ns).len()).rev() {\n@@ -1394,7 +1380,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             if let ModuleRibKind(module) = self.get_ribs(ns)[i].kind {\n-                let name = ident.unhygienic_name;\n+                let name = ident.name;\n                 let item = self.resolve_name_in_module(module, name, ns, true, record_used);\n                 if let Success(binding) = item {\n                     // The ident resolves to an item.\n@@ -1563,77 +1549,76 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         None\n     }\n \n-    fn resolve_crate(&mut self, krate: &hir::Crate) {\n+    fn resolve_crate(&mut self, krate: &Crate) {\n         debug!(\"(resolving crate) starting\");\n         self.current_module = self.graph_root;\n-        intravisit::walk_crate(self, krate);\n+        visit::walk_crate(self, krate);\n     }\n \n     fn resolve_item(&mut self, item: &Item) {\n-        let name = item.name;\n+        let name = item.ident.name;\n \n         debug!(\"(resolving item) resolving {}\", name);\n \n         match item.node {\n-            ItemEnum(_, ref generics) |\n-            ItemTy(_, ref generics) |\n-            ItemStruct(_, ref generics) => {\n+            ItemKind::Enum(_, ref generics) |\n+            ItemKind::Ty(_, ref generics) |\n+            ItemKind::Struct(_, ref generics) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics, TypeSpace, ItemRibKind),\n-                                             |this| intravisit::walk_item(this, item));\n+                                             |this| visit::walk_item(this, item));\n             }\n-            ItemFn(_, _, _, _, ref generics, _) => {\n+            ItemKind::Fn(_, _, _, _, ref generics, _) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics, FnSpace, ItemRibKind),\n-                                             |this| intravisit::walk_item(this, item));\n+                                             |this| visit::walk_item(this, item));\n             }\n \n-            ItemDefaultImpl(_, ref trait_ref) => {\n+            ItemKind::DefaultImpl(_, ref trait_ref) => {\n                 self.with_optional_trait_ref(Some(trait_ref), |_, _| {});\n             }\n-            ItemImpl(_, _, ref generics, ref opt_trait_ref, ref self_type, ref impl_items) => {\n+            ItemKind::Impl(_, _, ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n                 self.resolve_implementation(generics,\n                                             opt_trait_ref,\n                                             &self_type,\n                                             item.id,\n-                                            impl_items);\n-            }\n+                                            impl_items),\n \n-            ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n+            ItemKind::Trait(_, ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                TypeSpace,\n                                                                ItemRibKind),\n                                              |this| {\n-                    let local_def_id = this.ast_map.local_def_id(item.id);\n+                    let local_def_id = this.definitions.local_def_id(item.id);\n                     this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_ty_param_bound, bounds);\n \n                         for trait_item in trait_items {\n                             match trait_item.node {\n-                                hir::ConstTraitItem(_, ref default) => {\n+                                TraitItemKind::Const(_, ref default) => {\n                                     // Only impose the restrictions of\n                                     // ConstRibKind if there's an actual constant\n                                     // expression in a provided default.\n                                     if default.is_some() {\n                                         this.with_constant_rib(|this| {\n-                                            intravisit::walk_trait_item(this, trait_item)\n+                                            visit::walk_trait_item(this, trait_item)\n                                         });\n                                     } else {\n-                                        intravisit::walk_trait_item(this, trait_item)\n+                                        visit::walk_trait_item(this, trait_item)\n                                     }\n                                 }\n-                                hir::MethodTraitItem(ref sig, _) => {\n+                                TraitItemKind::Method(ref sig, _) => {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n                                                           FnSpace,\n                                                           MethodRibKind);\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n-                                        intravisit::walk_trait_item(this, trait_item)\n+                                        visit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n-                                hir::TypeTraitItem(..) => {\n+                                TraitItemKind::Type(..) => {\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n-                                        intravisit::walk_trait_item(this, trait_item)\n+                                        visit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n                             };\n@@ -1642,21 +1627,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 });\n             }\n \n-            ItemMod(_) | ItemForeignMod(_) => {\n+            ItemKind::Mod(_) | ItemKind::ForeignMod(_) => {\n                 self.with_scope(item.id, |this| {\n-                    intravisit::walk_item(this, item);\n+                    visit::walk_item(this, item);\n                 });\n             }\n \n-            ItemConst(..) | ItemStatic(..) => {\n+            ItemKind::Const(..) | ItemKind::Static(..) => {\n                 self.with_constant_rib(|this| {\n-                    intravisit::walk_item(this, item);\n+                    visit::walk_item(this, item);\n                 });\n             }\n \n-            ItemUse(ref view_path) => {\n+            ItemKind::Use(ref view_path) => {\n                 match view_path.node {\n-                    hir::ViewPathList(ref prefix, ref items) => {\n+                    ast::ViewPathList(ref prefix, ref items) => {\n                         // Resolve prefix of an import with empty braces (issue #28388)\n                         if items.is_empty() && !prefix.segments.is_empty() {\n                             match self.resolve_crate_relative_path(prefix.span,\n@@ -1681,9 +1666,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            ItemExternCrate(_) => {\n+            ItemKind::ExternCrate(_) => {\n                 // do nothing, these are just around to be encoded\n             }\n+\n+            ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n         }\n     }\n \n@@ -1695,7 +1682,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = HashSet::new();\n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n-                    let name = type_parameter.name;\n+                    let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n@@ -1706,7 +1693,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     seen_bindings.insert(name);\n \n                     // plain insert (no renaming)\n-                    let def_id = self.ast_map.local_def_id(type_parameter.id);\n+                    let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(space, index as u32, def_id, name);\n                     function_type_rib.bindings.insert(name, def);\n                 }\n@@ -1759,7 +1746,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             debug!(\"(resolving function) recorded argument\");\n         }\n-        intravisit::walk_fn_ret_ty(self, &declaration.output);\n+        visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body.\n         self.visit_block(block);\n@@ -1836,9 +1823,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_generics(&mut self, generics: &Generics) {\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &hir::WherePredicate::BoundPredicate(_) |\n-                &hir::WherePredicate::RegionPredicate(_) => {}\n-                &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n+                &ast::WherePredicate::BoundPredicate(_) |\n+                &ast::WherePredicate::RegionPredicate(_) => {}\n+                &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                     self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS).and_then(|path_res| {\n                         if let PathResolution { base_def: Def::TyParam(..), .. } = path_res {\n                             Ok(self.record_def(eq_pred.id, path_res))\n@@ -1854,7 +1841,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n         }\n-        intravisit::walk_generics(self, generics);\n+        visit::walk_generics(self, generics);\n     }\n \n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n@@ -1883,7 +1870,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 self.record_def(trait_ref.ref_id, err_path_resolution());\n             }\n-            intravisit::walk_trait_ref(self, trait_ref);\n+            visit::walk_trait_ref(self, trait_ref);\n         }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n         let result = f(self, new_id);\n@@ -1927,20 +1914,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         for impl_item in impl_items {\n                             this.resolve_visibility(&impl_item.vis);\n                             match impl_item.node {\n-                                hir::ImplItemKind::Const(..) => {\n+                                ImplItemKind::Const(..) => {\n                                     // If this is a trait impl, ensure the const\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.name,\n+                                    this.check_trait_item(impl_item.ident.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n                                     this.with_constant_rib(|this| {\n-                                        intravisit::walk_impl_item(this, impl_item);\n+                                        visit::walk_impl_item(this, impl_item);\n                                     });\n                                 }\n-                                hir::ImplItemKind::Method(ref sig, _) => {\n+                                ImplItemKind::Method(ref sig, _) => {\n                                     // If this is a trait impl, ensure the method\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.name,\n+                                    this.check_trait_item(impl_item.ident.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n \n@@ -1951,18 +1938,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                           FnSpace,\n                                                           MethodRibKind);\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n-                                        intravisit::walk_impl_item(this, impl_item);\n+                                        visit::walk_impl_item(this, impl_item);\n                                     });\n                                 }\n-                                hir::ImplItemKind::Type(ref ty) => {\n+                                ImplItemKind::Type(ref ty) => {\n                                     // If this is a trait impl, ensure the type\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.name,\n+                                    this.check_trait_item(impl_item.ident.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n \n                                     this.visit_ty(ty);\n                                 }\n+                                ImplItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n                             }\n                         }\n                     });\n@@ -2000,18 +1988,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // that expands into an or-pattern where one 'x' was from the\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n-        let mut result = HashMap::new();\n-        let def_map = RefCell::new(::std::mem::replace(&mut self.def_map, NodeMap()));\n-        pat_bindings(&def_map, pat, |binding_mode, _id, sp, path1| {\n-            let name = path1.node;\n-            result.insert(name,\n-                          BindingInfo {\n-                              span: sp,\n-                              binding_mode: binding_mode,\n-                          });\n+        let mut binding_map = HashMap::new();\n+\n+        pat.walk(&mut |pat| {\n+            if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n+                if sub_pat.is_some() || match self.def_map.get(&pat.id) {\n+                    Some(&PathResolution { base_def: Def::Local(..), .. }) => true,\n+                    _ => false,\n+                } {\n+                    let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n+                    binding_map.insert(mtwt::resolve(ident.node), binding_info);\n+                }\n+            }\n+            true\n         });\n-        self.def_map = def_map.into_inner();\n-        return result;\n+\n+        binding_map\n     }\n \n     // check that all of the arms in an or-pattern have exactly the\n@@ -2086,7 +2078,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Descend into the block.\n-        intravisit::walk_block(self, block);\n+        visit::walk_block(self, block);\n \n         // Move back up.\n         self.current_module = orig_module;\n@@ -2099,15 +2091,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n-            TyPath(ref maybe_qself, ref path) => {\n+            TyKind::Path(ref maybe_qself, ref path) => {\n                 let resolution = match self.resolve_possibly_assoc_item(ty.id,\n                                                                         maybe_qself.as_ref(),\n                                                                         path,\n                                                                         TypeNS) {\n                     // `<T>::a::b::c` is resolved by typeck alone.\n                     TypecheckRequired => {\n                         // Resolve embedded types.\n-                        intravisit::walk_ty(self, ty);\n+                        visit::walk_ty(self, ty);\n                         return;\n                     }\n                     ResolveAttempt(resolution) => resolution,\n@@ -2176,7 +2168,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             _ => {}\n         }\n         // Resolve embedded types.\n-        intravisit::walk_ty(self, ty);\n+        visit::walk_ty(self, ty);\n     }\n \n     fn resolve_pattern(&mut self,\n@@ -2186,7 +2178,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                        // pattern that binds them\n                        bindings_list: &mut HashMap<Name, NodeId>) {\n         let pat_id = pattern.id;\n-        pattern.walk(|pattern| {\n+        pattern.walk(&mut |pattern| {\n             match pattern.node {\n                 PatKind::Ident(binding_mode, ref path1, ref at_rhs) => {\n                     // The meaning of PatKind::Ident with no type parameters\n@@ -2200,7 +2192,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let const_ok = mode == RefutableMode && at_rhs.is_none();\n \n                     let ident = path1.node;\n-                    let renamed = ident.name;\n+                    let renamed = mtwt::resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n                         FoundStructOrEnumVariant(def) if const_ok => {\n@@ -2246,7 +2238,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `{}`\", renamed);\n \n-                            let def_id = self.ast_map.local_def_id(pattern.id);\n+                            let def_id = self.definitions.local_def_id(pattern.id);\n                             let def = Def::Local(def_id, pattern.id);\n \n                             // Record the definition so that later passes\n@@ -2370,7 +2362,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         );\n                         self.record_def(pattern.id, err_path_resolution());\n                     }\n-                    intravisit::walk_path(self, path);\n+                    visit::walk_path(self, path);\n                 }\n \n                 PatKind::QPath(ref qself, ref path) => {\n@@ -2390,7 +2382,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  .name;\n                             let traits = self.get_traits_containing_item(const_name);\n                             self.trait_map.insert(pattern.id, traits);\n-                            intravisit::walk_pat(self, pattern);\n+                            visit::walk_pat(self, pattern);\n                             return true;\n                         }\n                         ResolveAttempt(resolution) => resolution,\n@@ -2424,7 +2416,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                                       .as_str()));\n                         self.record_def(pattern.id, err_path_resolution());\n                     }\n-                    intravisit::walk_pat(self, pattern);\n+                    visit::walk_pat(self, pattern);\n                 }\n \n                 PatKind::Struct(ref path, _, _) => {\n@@ -2443,11 +2435,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.record_def(pattern.id, err_path_resolution());\n                         }\n                     }\n-                    intravisit::walk_path(self, path);\n+                    visit::walk_path(self, path);\n                 }\n \n                 PatKind::Lit(_) | PatKind::Range(..) => {\n-                    intravisit::walk_pat(self, pattern);\n+                    visit::walk_pat(self, pattern);\n                 }\n \n                 _ => {\n@@ -2458,7 +2450,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         });\n     }\n \n-    fn resolve_bare_identifier_pattern(&mut self, ident: hir::Ident, span: Span)\n+    fn resolve_bare_identifier_pattern(&mut self, ident: ast::Ident, span: Span)\n                                        -> BareIdentifierPatternResolution {\n         let binding = match self.resolve_ident_in_lexical_scope(ident, ValueNS, true) {\n             Some(LexicalScopeBinding::Item(binding)) => binding,\n@@ -2468,7 +2460,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         match def {\n             Def::Variant(..) | Def::Struct(..) => FoundStructOrEnumVariant(def),\n-            Def::Const(..) | Def::AssociatedConst(..) => FoundConst(def, ident.unhygienic_name),\n+            Def::Const(..) | Def::AssociatedConst(..) => FoundConst(def, ident.name),\n             Def::Static(..) => {\n                 let error = ResolutionError::StaticVariableReference(binding);\n                 resolve_error(self, span, error);\n@@ -2481,7 +2473,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Handles paths that may refer to associated items\n     fn resolve_possibly_assoc_item(&mut self,\n                                    id: NodeId,\n-                                   maybe_qself: Option<&hir::QSelf>,\n+                                   maybe_qself: Option<&ast::QSelf>,\n                                    path: &Path,\n                                    namespace: Namespace)\n                                    -> AssocItemResolveResult {\n@@ -2542,7 +2534,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 None | Some(LocalDef{def: Def::Mod(..), ..}) if namespace == TypeNS =>\n                     this.primitive_type_table\n                         .primitive_types\n-                        .get(&last_ident.unhygienic_name)\n+                        .get(&last_ident.name)\n                         .map_or(def, |prim_ty| Some(LocalDef::from_def(Def::PrimTy(*prim_ty)))),\n                 _ => def\n             }\n@@ -2583,11 +2575,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     // Resolve a single identifier\n     fn resolve_identifier(&mut self,\n-                          identifier: hir::Ident,\n+                          identifier: ast::Ident,\n                           namespace: Namespace,\n                           record_used: bool)\n                           -> Option<LocalDef> {\n-        if identifier.unhygienic_name == keywords::Invalid.name() {\n+        if identifier.name == keywords::Invalid.name() {\n             return Some(LocalDef::from_def(Def::Err));\n         }\n \n@@ -2615,7 +2607,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         ClosureRibKind(function_id) => {\n                             let prev_def = def;\n-                            let node_def_id = self.ast_map.local_def_id(node_id);\n+                            let node_def_id = self.definitions.local_def_id(node_id);\n \n                             let seen = self.freevars_seen\n                                            .entry(function_id)\n@@ -2687,7 +2679,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // resolve a \"module-relative\" path, e.g. a::b::c\n     fn resolve_module_relative_path(&mut self,\n                                     span: Span,\n-                                    segments: &[hir::PathSegment],\n+                                    segments: &[ast::PathSegment],\n                                     namespace: Namespace)\n                                     -> Result<&'a NameBinding<'a>,\n                                               bool /* true if an error was reported */> {\n@@ -2731,7 +2723,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// import resolution.\n     fn resolve_crate_relative_path(&mut self,\n                                    span: Span,\n-                                   segments: &[hir::PathSegment],\n+                                   segments: &[ast::PathSegment],\n                                    namespace: Namespace)\n                                    -> Result<&'a NameBinding<'a>,\n                                              bool /* true if an error was reported */> {\n@@ -2790,8 +2782,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n         fn extract_node_id(t: &Ty) -> Option<NodeId> {\n             match t.node {\n-                TyPath(None, _) => Some(t.id),\n-                TyRptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n+                TyKind::Path(None, _) => Some(t.id),\n+                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future.\n@@ -2849,6 +2841,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         } SuggestionType::NotFound\n     }\n \n+    fn resolve_labeled_block(&mut self, label: Option<ast::Ident>, id: NodeId, block: &Block) {\n+        if let Some(label) = label {\n+            let (label, def) = (mtwt::resolve(label), Def::Label(id));\n+            self.with_label_rib(|this| {\n+                this.label_ribs.last_mut().unwrap().bindings.insert(label, def);\n+                this.visit_block(block);\n+            });\n+        } else {\n+            self.visit_block(block);\n+        }\n+    }\n+\n     fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -2857,7 +2861,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Next, resolve the node.\n         match expr.node {\n-            ExprPath(ref maybe_qself, ref path) => {\n+            ExprKind::Path(ref maybe_qself, ref path) => {\n                 let resolution = match self.resolve_possibly_assoc_item(expr.id,\n                                                                         maybe_qself.as_ref(),\n                                                                         path,\n@@ -2867,7 +2871,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let method_name = path.segments.last().unwrap().identifier.name;\n                         let traits = self.get_traits_containing_item(method_name);\n                         self.trait_map.insert(expr.id, traits);\n-                        intravisit::walk_expr(self, expr);\n+                        visit::walk_expr(self, expr);\n                         return;\n                     }\n                     ResolveAttempt(resolution) => resolution,\n@@ -3009,10 +3013,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                intravisit::walk_expr(self, expr);\n+                visit::walk_expr(self, expr);\n             }\n \n-            ExprStruct(ref path, _, _) => {\n+            ExprKind::Struct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to. We don't\n                 // check to ensure that the path is actually a structure; that\n                 // is checked later during typeck.\n@@ -3031,24 +3035,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                intravisit::walk_expr(self, expr);\n+                visit::walk_expr(self, expr);\n             }\n \n-            ExprLoop(_, Some(label)) | ExprWhile(_, _, Some(label)) => {\n+            ExprKind::Loop(_, Some(label)) | ExprKind::While(_, _, Some(label)) => {\n                 self.with_label_rib(|this| {\n                     let def = Def::Label(expr.id);\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        rib.bindings.insert(label.name, def);\n+                        rib.bindings.insert(mtwt::resolve(label), def);\n                     }\n \n-                    intravisit::walk_expr(this, expr);\n+                    visit::walk_expr(this, expr);\n                 })\n             }\n \n-            ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n-                match self.search_label(label.node.name) {\n+            ExprKind::Break(Some(label)) | ExprKind::Again(Some(label)) => {\n+                match self.search_label(mtwt::resolve(label.node)) {\n                     None => {\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n@@ -3068,10 +3072,42 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             }\n-            ExprField(ref subexpression, _) => {\n+\n+            ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n+                self.visit_expr(subexpression);\n+\n+                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n+                self.visit_block(if_block);\n+                self.value_ribs.pop();\n+\n+                optional_else.as_ref().map(|expr| self.visit_expr(expr));\n+            }\n+\n+            ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n+                self.visit_expr(subexpression);\n+                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n+\n+                self.resolve_labeled_block(label, expr.id, block);\n+\n+                self.value_ribs.pop();\n+            }\n+\n+            ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n+                self.visit_expr(subexpression);\n+                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.resolve_pattern(pattern, LocalIrrefutableMode, &mut HashMap::new());\n+\n+                self.resolve_labeled_block(label, expr.id, block);\n+\n+                self.value_ribs.pop();\n+            }\n+\n+            ExprKind::Field(ref subexpression, _) => {\n                 self.resolve_expr(subexpression, Some(expr));\n             }\n-            ExprMethodCall(_, ref types, ref arguments) => {\n+            ExprKind::MethodCall(_, ref types, ref arguments) => {\n                 let mut arguments = arguments.iter();\n                 self.resolve_expr(arguments.next().unwrap(), Some(expr));\n                 for argument in arguments {\n@@ -3083,25 +3119,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             _ => {\n-                intravisit::walk_expr(self, expr);\n+                visit::walk_expr(self, expr);\n             }\n         }\n     }\n \n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n         match expr.node {\n-            ExprField(_, name) => {\n+            ExprKind::Field(_, name) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(name.node);\n+                let traits = self.get_traits_containing_item(name.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n-            ExprMethodCall(name, _, _) => {\n+            ExprKind::MethodCall(name, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\",\n                        expr.id);\n-                let traits = self.get_traits_containing_item(name.node);\n+                let traits = self.get_traits_containing_item(name.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -3211,7 +3247,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(def) = name_binding.def() {\n                     if name == lookup_name && ns == namespace && filter_fn(def) {\n                         // create the path\n-                        let ident = hir::Ident::from_name(name);\n+                        let ident = ast::Ident::with_empty_ctxt(name);\n                         let params = PathParameters::none();\n                         let segment = PathSegment {\n                             identifier: ident,\n@@ -3220,7 +3256,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let span = name_binding.span;\n                         let mut segms = path_segments.clone();\n                         segms.push(segment);\n-                        let segms = HirVec::from_vec(segms);\n                         let path = Path {\n                             span: span,\n                             global: true,\n@@ -3246,7 +3281,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         NoParentLink => path_segments.clone(),\n                         ModuleParentLink(_, name) => {\n                             let mut paths = path_segments.clone();\n-                            let ident = hir::Ident::from_name(name);\n+                            let ident = ast::Ident::with_empty_ctxt(name);\n                             let params = PathParameters::none();\n                             let segm = PathSegment {\n                                 identifier: ident,\n@@ -3276,11 +3311,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n         debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.def_map.insert(node_id, resolution) {\n-            let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n-            span_bug!(span,\n-                      \"path resolved multiple times ({:?} before, {:?} now)\",\n-                      prev_res,\n-                      resolution);\n+            panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n     }\n \n@@ -3289,24 +3320,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     pat_binding_mode: BindingMode,\n                                     descr: &str) {\n         match pat_binding_mode {\n-            BindByValue(_) => {}\n-            BindByRef(..) => {\n+            BindingMode::ByValue(_) => {}\n+            BindingMode::ByRef(..) => {\n                 resolve_error(self,\n                               pat.span,\n                               ResolutionError::CannotUseRefBindingModeWith(descr));\n             }\n         }\n     }\n \n-    fn resolve_visibility(&mut self, vis: &hir::Visibility) -> ty::Visibility {\n+    fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n         let (path, id) = match *vis {\n-            hir::Public => return ty::Visibility::Public,\n-            hir::Visibility::Crate => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n-            hir::Visibility::Restricted { ref path, id } => (path, id),\n-            hir::Inherited => {\n+            ast::Visibility::Public => return ty::Visibility::Public,\n+            ast::Visibility::Crate(_) => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n+            ast::Visibility::Restricted { ref path, id } => (path, id),\n+            ast::Visibility::Inherited => {\n                 let current_module =\n                     self.get_nearest_normal_module_parent_or_self(self.current_module);\n-                let id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n+                let id =\n+                    self.definitions.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n                 return ty::Visibility::Restricted(id);\n             }\n         };\n@@ -3317,7 +3349,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let def = module.def.unwrap();\n                 let path_resolution = PathResolution { base_def: def, depth: 0 };\n                 self.def_map.insert(id, path_resolution);\n-                ty::Visibility::Restricted(self.ast_map.as_local_node_id(def.def_id()).unwrap())\n+                ty::Visibility::Restricted(self.definitions.as_local_node_id(def.def_id()).unwrap())\n             }\n             Failed(Some((span, msg))) => {\n                 self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n@@ -3337,7 +3369,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn is_accessible(&self, vis: ty::Visibility) -> bool {\n         let current_module = self.get_nearest_normal_module_parent_or_self(self.current_module);\n-        let node_id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n+        let node_id = self.definitions.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n         vis.is_accessible_from(node_id, self)\n     }\n \n@@ -3547,22 +3579,21 @@ pub enum MakeGlobMap {\n }\n \n /// Entry point to crate resolution.\n-pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n-                               ast_map: &'a hir_map::Map<'tcx>,\n-                               make_glob_map: MakeGlobMap)\n-                               -> CrateMap {\n+pub fn resolve_crate<'a>(session: &'a Session,\n+                         krate: &'a Crate,\n+                         definitions: &'a Definitions,\n+                         make_glob_map: MakeGlobMap)\n+                         -> CrateMap {\n     // Currently, we ignore the name resolution data structures for\n     // the purposes of dependency tracking. Instead we will run name\n     // resolution and include its output in the hash of each item,\n     // much like we do for macro expansion. In other words, the hash\n     // reflects not just its contents but the results of name\n     // resolution on those contents. Hopefully we'll push this back at\n     // some point.\n-    let _task = ast_map.dep_graph.in_task(DepNode::Resolve);\n \n-    let krate = ast_map.krate();\n     let arenas = Resolver::arenas();\n-    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, &arenas);\n+    let mut resolver = create_resolver(session, definitions, krate, make_glob_map, &arenas);\n \n     resolver.resolve_crate(krate);\n \n@@ -3584,13 +3615,13 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n }\n \n /// Builds a name resolution walker.\n-fn create_resolver<'a, 'tcx>(session: &'a Session,\n-                             ast_map: &'a hir_map::Map<'tcx>,\n-                             krate: &'a Crate,\n-                             make_glob_map: MakeGlobMap,\n-                             arenas: &'a ResolverArenas<'a>)\n-                             -> Resolver<'a, 'tcx> {\n-    let mut resolver = Resolver::new(session, ast_map, make_glob_map, arenas);\n+fn create_resolver<'a>(session: &'a Session,\n+                       definitions: &'a Definitions,\n+                       krate: &'a Crate,\n+                       make_glob_map: MakeGlobMap,\n+                       arenas: &'a ResolverArenas<'a>)\n+                       -> Resolver<'a> {\n+    let mut resolver = Resolver::new(session, definitions, make_glob_map, arenas);\n \n     resolver.build_reduced_graph(krate);\n "}, {"sha": "9bd16117f9a8e25ccbcb14abc123b7bc383d89c2", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=84284472533b1e48e6365f6c37b644d0fe00647a", "patch": "@@ -344,11 +344,11 @@ struct ImportResolvingError<'a> {\n     help: String,\n }\n \n-struct ImportResolver<'a, 'b: 'a, 'tcx: 'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>,\n+struct ImportResolver<'a, 'b: 'a> {\n+    resolver: &'a mut Resolver<'b>,\n }\n \n-impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n+impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     // Import resolution\n     //\n     // This is a fixed-point algorithm. We resolve imports until our efforts\n@@ -700,7 +700,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {\n-                let node_id = self.resolver.ast_map.as_local_node_id(def_id).unwrap();\n+                let node_id = self.resolver.definitions.as_local_node_id(def_id).unwrap();\n                 self.resolver.export_map.insert(node_id, reexports);\n             }\n         }"}, {"sha": "d1ad330c58ce88f4830d1d71e4657797f3172e8d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84284472533b1e48e6365f6c37b644d0fe00647a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=84284472533b1e48e6365f6c37b644d0fe00647a", "patch": "@@ -551,6 +551,44 @@ impl fmt::Debug for Pat {\n     }\n }\n \n+impl Pat {\n+    pub fn walk<F>(&self, it: &mut F) -> bool\n+        where F: FnMut(&Pat) -> bool\n+    {\n+        if !it(self) {\n+            return false;\n+        }\n+\n+        match self.node {\n+            PatKind::Ident(_, _, Some(ref p)) => p.walk(it),\n+            PatKind::Struct(_, ref fields, _) => {\n+                fields.iter().all(|field| field.node.pat.walk(it))\n+            }\n+            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n+                s.iter().all(|p| p.walk(it))\n+            }\n+            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n+                s.walk(it)\n+            }\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n+                before.iter().all(|p| p.walk(it)) &&\n+                slice.iter().all(|p| p.walk(it)) &&\n+                after.iter().all(|p| p.walk(it))\n+            }\n+            PatKind::Wild |\n+            PatKind::Lit(_) |\n+            PatKind::Range(_, _) |\n+            PatKind::Ident(_, _, _) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Path(..) |\n+            PatKind::QPath(_, _) |\n+            PatKind::Mac(_) => {\n+                true\n+            }\n+        }\n+    }\n+}\n+\n /// A single field in a struct pattern\n ///\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`"}]}