{"sha": "e4cbd43c430ef0d5f63ca7cb86a65a618521e175", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0Y2JkNDNjNDMwZWYwZDVmNjNjYTdjYjg2YTY1YTYxODUyMWUxNzU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-09T10:43:46Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T08:41:21Z"}, "message": "Huge kludge to get intrinsics' type parameters passed", "tree": {"sha": "b9c37f5d7584bf5f619509aab5cabe8717fe5976", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9c37f5d7584bf5f619509aab5cabe8717fe5976"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4cbd43c430ef0d5f63ca7cb86a65a618521e175", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4cbd43c430ef0d5f63ca7cb86a65a618521e175", "html_url": "https://github.com/rust-lang/rust/commit/e4cbd43c430ef0d5f63ca7cb86a65a618521e175", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4cbd43c430ef0d5f63ca7cb86a65a618521e175/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aa78e34e47074db22777c35bbf6cf2b3f973c40", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aa78e34e47074db22777c35bbf6cf2b3f973c40", "html_url": "https://github.com/rust-lang/rust/commit/9aa78e34e47074db22777c35bbf6cf2b3f973c40"}], "stats": {"total": 80, "additions": 53, "deletions": 27}, "files": [{"sha": "0ea5408c8ed1c51f1f3f99bff227c1e4e20c72cf", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e4cbd43c430ef0d5f63ca7cb86a65a618521e175/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4cbd43c430ef0d5f63ca7cb86a65a618521e175/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e4cbd43c430ef0d5f63ca7cb86a65a618521e175", "patch": "@@ -865,7 +865,7 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, substs: [ty::t])\n         maybe_instantiate_inline(ccx, did)\n     } else { did };\n     assert did.crate == ast::local_crate;\n-    monomorphic_fn(ccx, did, substs, none)\n+    monomorphic_fn(ccx, did, substs, none).val\n }\n \n fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n@@ -1951,7 +1951,9 @@ enum callee_env {\n type lval_maybe_callee = {bcx: block,\n                           val: ValueRef,\n                           kind: lval_kind,\n-                          env: callee_env};\n+                          env: callee_env,\n+                          // Tydescs to pass. Only used to call intrinsics\n+                          tds: option<[ValueRef]>};\n \n fn null_env_ptr(bcx: block) -> ValueRef {\n     C_null(T_opaque_box_ptr(bcx.ccx()))\n@@ -1970,7 +1972,7 @@ fn lval_temp(bcx: block, val: ValueRef) -> lval_result {\n \n fn lval_no_env(bcx: block, val: ValueRef, kind: lval_kind)\n     -> lval_maybe_callee {\n-    ret {bcx: bcx, val: val, kind: kind, env: is_closure};\n+    ret {bcx: bcx, val: val, kind: kind, env: is_closure, tds: none};\n }\n \n fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n@@ -1984,10 +1986,12 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n }\n \n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n-                  vtables: option<typeck::vtable_res>) -> ValueRef {\n+                  vtables: option<typeck::vtable_res>)\n+    -> {val: ValueRef, must_cast: bool, intrinsic: bool} {\n+    let mut must_cast = false;\n     let substs = vec::map(substs, {|t|\n         alt ty::get(t).struct {\n-          ty::ty_box(mt) { ty::mk_opaque_box(ccx.tcx) }\n+          ty::ty_box(mt) { must_cast = true; ty::mk_opaque_box(ccx.tcx) }\n           _ { t }\n         }\n     });\n@@ -1996,7 +2000,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       none { no_vts }\n     }};\n     alt ccx.monomorphized.find(hash_id) {\n-      some(val) { ret val; }\n+      some(val) { ret {val: val, must_cast: must_cast, intrinsic: false}; }\n       none {}\n     }\n \n@@ -2017,9 +2021,11 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       }\n       ast_map::node_variant(v, _, pt) { (pt, v.node.name) }\n       ast_map::node_method(m, _, pt) { (pt, m.ident) }\n-      ast_map::node_native_item(_, _, _) {\n+      ast_map::node_native_item(_, abi, _) {\n         // Natives don't have to be monomorphized.\n-        ret get_item_val(ccx, fn_id.node);\n+        ret {val: get_item_val(ccx, fn_id.node),\n+             must_cast: true,\n+             intrinsic: abi == ast::native_abi_rust_intrinsic};\n       }\n       ast_map::node_ctor(i) {\n         alt check ccx.tcx.items.get(i.id) {\n@@ -2073,7 +2079,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n         }\n       }\n     }\n-    lldecl\n+    {val: lldecl, must_cast: must_cast, intrinsic: false}\n }\n \n fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n@@ -2130,11 +2136,20 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     }\n }\n \n+fn add_tydesc_params(ccx: crate_ctxt, llfty: TypeRef, n: uint) -> TypeRef {\n+    let out_ty = llvm::LLVMGetReturnType(llfty);\n+    let n_args = llvm::LLVMCountParamTypes(llfty);\n+    let args = vec::init_elt(n_args as uint, 0 as TypeRef);\n+    unsafe { llvm::LLVMGetParamTypes(llfty, vec::unsafe::to_ptr(args)); }\n+    T_fn(vec::slice(args, 0u, first_real_arg) +\n+         vec::init_elt(n, T_ptr(ccx.tydesc_type)) +\n+         vec::tail_n(args, first_real_arg), out_ty)\n+}\n+\n fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                   substs: option<([ty::t], typeck::vtable_res)>)\n     -> lval_maybe_callee {\n-    let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n+    let bcx = bcx, ccx = bcx.ccx(), tcx = ccx.tcx;\n     let tys = node_id_type_params(bcx, id);\n     let tpt = ty::lookup_item_type(tcx, fn_id);\n \n@@ -2151,11 +2166,24 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                            impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts)})) }\n         };\n         if tys.len() > 0u {\n-            let val = monomorphic_fn(ccx, fn_id, tys, vtables);\n-            let cast = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n-                ccx, node_id_type(bcx, id))));\n-            ret {bcx: bcx, val: cast,\n-                 kind: owned, env: null_env};\n+            let {val, must_cast, intrinsic} = monomorphic_fn(ccx, fn_id, tys,\n+                                                             vtables);\n+            let tds = none;\n+            if intrinsic {\n+                tds = some(vec::map(tys, {|t|\n+                    let ti = none, td_res = get_tydesc(bcx, t, ti);\n+                    bcx = td_res.bcx;\n+                    lazily_emit_all_tydesc_glue(ccx, ti);\n+                    td_res.val\n+                }));\n+                let llfty = type_of_fn_from_ty(ccx, node_id_type(bcx, id));\n+                val = PointerCast(bcx, val, T_ptr(add_tydesc_params(\n+                    ccx, llfty, tys.len())));\n+            } else if must_cast {\n+                val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n+                    ccx, node_id_type(bcx, id))));\n+            }\n+            ret {bcx: bcx, val: val, kind: owned, env: null_env, tds: tds};\n         }\n     }\n \n@@ -2185,7 +2213,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         }\n     }\n \n-    ret {bcx: bcx, val: val, kind: owned, env: null_env};\n+    ret {bcx: bcx, val: val, kind: owned, env: null_env, tds: none};\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n@@ -2736,6 +2764,11 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n         let args_res = trans_args(bcx, llenv, args, fn_expr_ty, dest);\n         bcx = args_res.bcx;\n         let llargs = args_res.args;\n+        option::may(f_res.tds) {|vals|\n+            llargs = vec::slice(llargs, 0u, first_real_arg) + vals +\n+                vec::tail_n(llargs, first_real_arg);\n+        }\n+\n         let llretslot = args_res.retslot;\n \n         /* If the block is terminated,"}, {"sha": "8ed1cf01a7af6d79c5d986dcb174cd152d874dd2", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4cbd43c430ef0d5f63ca7cb86a65a618521e175/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4cbd43c430ef0d5f63ca7cb86a65a618521e175/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=e4cbd43c430ef0d5f63ca7cb86a65a618521e175", "patch": "@@ -446,6 +446,7 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n                 f_res: lval_maybe_callee,\n                 args: [option<@ast::expr>], pair_ty: ty::t,\n                 dest: dest) -> block {\n+    assert option::is_none(f_res.tds);\n     let ccx = cx.ccx();\n     let bound: [@ast::expr] = [];\n     for argopt: option<@ast::expr> in args {"}, {"sha": "00782c0a11b6d60cdfeb59219949d779b2af7ee7", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4cbd43c430ef0d5f63ca7cb86a65a618521e175/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4cbd43c430ef0d5f63ca7cb86a65a618521e175/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=e4cbd43c430ef0d5f63ca7cb86a65a618521e175", "patch": "@@ -83,7 +83,7 @@ fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n-    {bcx: bcx, val: mptr, kind: owned, env: env}\n+    {bcx: bcx, val: mptr, kind: owned, env: env, tds: none}\n }\n \n fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n@@ -148,14 +148,6 @@ fn trans_iface_callee(bcx: block, base: @ast::expr,\n                         callee_id, n_method)\n }\n \n-fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n-    let out_ty = llvm::LLVMGetReturnType(ft);\n-    let n_args = llvm::LLVMCountParamTypes(ft);\n-    let args = vec::from_elem(n_args as uint, 0 as TypeRef);\n-    unsafe { llvm::LLVMGetParamTypes(ft, vec::unsafe::to_ptr(args)); }\n-    {inputs: args, output: out_ty}\n-}\n-\n fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n     -> typeck::vtable_origin {\n     let vtable_off = n_bound, i = 0u;\n@@ -251,7 +243,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n             C_null(type_of_fn_from_ty(ccx, fty))\n         } else {\n             let m_id = method_with_name(ccx, impl_id, im.ident);\n-            monomorphic_fn(ccx, m_id, substs, some(vtables))\n+            monomorphic_fn(ccx, m_id, substs, some(vtables)).val\n         }\n     }))\n }"}]}