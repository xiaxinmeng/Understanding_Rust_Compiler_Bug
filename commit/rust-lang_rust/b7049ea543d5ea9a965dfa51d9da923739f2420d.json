{"sha": "b7049ea543d5ea9a965dfa51d9da923739f2420d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MDQ5ZWE1NDNkNWVhOWE5NjVkZmE1MWQ5ZGE5MjM3MzlmMjQyMGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-27T20:33:36Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-27T20:33:36Z"}, "message": "move query definitions", "tree": {"sha": "4cfda71ca655fc13479413825b452419fdc0e281", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cfda71ca655fc13479413825b452419fdc0e281"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7049ea543d5ea9a965dfa51d9da923739f2420d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7049ea543d5ea9a965dfa51d9da923739f2420d", "html_url": "https://github.com/rust-lang/rust/commit/b7049ea543d5ea9a965dfa51d9da923739f2420d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7049ea543d5ea9a965dfa51d9da923739f2420d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90bc832b22aefb2a382b3465793df7e528351aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/90bc832b22aefb2a382b3465793df7e528351aa1", "html_url": "https://github.com/rust-lang/rust/commit/90bc832b22aefb2a382b3465793df7e528351aa1"}], "stats": {"total": 431, "additions": 232, "deletions": 199}, "files": [{"sha": "78bbfcf2d5fc4b38bce2ca45ce53acac9278ee58", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=b7049ea543d5ea9a965dfa51d9da923739f2420d", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     hir,\n     symbol_index::SymbolIndex,\n     syntax_ptr::SyntaxPtr,\n-    loc2id::{IdMaps, IdDatabase},\n+    loc2id::{IdMaps},\n     Cancelable, Canceled, FileId,\n };\n \n@@ -77,7 +77,14 @@ impl salsa::ParallelDatabase for RootDatabase {\n     }\n }\n \n-impl IdDatabase for RootDatabase {\n+pub(crate) trait BaseDatabase: salsa::Database {\n+    fn id_maps(&self) -> &IdMaps;\n+    fn check_canceled(&self) -> Cancelable<()> {\n+        check_canceled(self)\n+    }\n+}\n+\n+impl BaseDatabase for RootDatabase {\n     fn id_maps(&self) -> &IdMaps {\n         &self.id_maps\n     }\n@@ -136,7 +143,7 @@ salsa::database_storage! {\n }\n \n salsa::query_group! {\n-    pub(crate) trait SyntaxDatabase: crate::input::FilesDatabase {\n+    pub(crate) trait SyntaxDatabase: crate::input::FilesDatabase + BaseDatabase {\n         fn file_syntax(file_id: FileId) -> SourceFileNode {\n             type FileSyntaxQuery;\n         }"}, {"sha": "c6dbde79b9b0be02da803ed93e3ab155cb1291b8", "filename": "crates/ra_analysis/src/hir/db.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fdb.rs?ref=b7049ea543d5ea9a965dfa51d9da923739f2420d", "patch": "@@ -8,56 +8,59 @@ use ra_syntax::{\n use crate::{\n     FileId,\n     db::SyntaxDatabase,\n+    hir::query_definitions,\n     hir::function::{FnId, FnScopes},\n     hir::module::{\n         ModuleId, ModuleTree, ModuleSource,\n         nameres::{ItemMap, InputModuleItems, FileItems, FileItemId}\n     },\n     input::SourceRootId,\n-    loc2id::{IdDatabase},\n     Cancelable,\n };\n \n salsa::query_group! {\n-pub(crate) trait HirDatabase: SyntaxDatabase + IdDatabase {\n-        fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n-            type FnScopesQuery;\n-            use fn crate::hir::function::imp::fn_scopes;\n-        }\n-\n-        fn file_items(file_id: FileId) -> Arc<FileItems> {\n-            type FileItemsQuery;\n-            storage dependencies;\n-            use fn crate::hir::module::nameres::file_items;\n-        }\n-\n-        fn file_item(file_id: FileId, file_item_id: FileItemId) -> SyntaxNode {\n-            type FileItemQuery;\n-            storage dependencies;\n-            use fn crate::hir::module::nameres::file_item;\n-        }\n-\n-        fn input_module_items(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<InputModuleItems>> {\n-            type InputModuleItemsQuery;\n-            use fn crate::hir::module::nameres::input_module_items;\n-        }\n-        fn item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n-            type ItemMapQuery;\n-            use fn crate::hir::module::nameres::item_map;\n-        }\n-        fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n-            type ModuleTreeQuery;\n-            use fn crate::hir::module::imp::module_tree;\n-        }\n-        fn fn_syntax(fn_id: FnId) -> FnDefNode {\n-            type FnSyntaxQuery;\n-            // Don't retain syntax trees in memory\n-            storage dependencies;\n-            use fn crate::hir::function::imp::fn_syntax;\n-        }\n-        fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::hir::module::imp::Submodule>>> {\n-            type SubmodulesQuery;\n-            use fn crate::hir::module::imp::submodules;\n-        }\n+\n+pub(crate) trait HirDatabase: SyntaxDatabase {\n+    fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n+        type FnScopesQuery;\n+        use fn query_definitions::fn_scopes;\n+    }\n+    fn fn_syntax(fn_id: FnId) -> FnDefNode {\n+        type FnSyntaxQuery;\n+        // Don't retain syntax trees in memory\n+        storage dependencies;\n+        use fn query_definitions::fn_syntax;\n+    }\n+\n+    fn file_items(file_id: FileId) -> Arc<FileItems> {\n+        type FileItemsQuery;\n+        storage dependencies;\n+        use fn query_definitions::file_items;\n+    }\n+\n+    fn file_item(file_id: FileId, file_item_id: FileItemId) -> SyntaxNode {\n+        type FileItemQuery;\n+        storage dependencies;\n+        use fn query_definitions::file_item;\n+    }\n+\n+    fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::hir::module::imp::Submodule>>> {\n+        type SubmodulesQuery;\n+        use fn query_definitions::submodules;\n+    }\n+\n+    fn input_module_items(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<InputModuleItems>> {\n+        type InputModuleItemsQuery;\n+        use fn query_definitions::input_module_items;\n+    }\n+    fn item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n+        type ItemMapQuery;\n+        use fn query_definitions::item_map;\n     }\n+    fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n+        type ModuleTreeQuery;\n+        use fn crate::hir::module::imp::module_tree;\n+    }\n+}\n+\n }"}, {"sha": "5f5f68ac5739f69277941e22e5cb2b406b5bdcdf", "filename": "crates/ra_analysis/src/hir/function/imp.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/90bc832b22aefb2a382b3465793df7e528351aa1/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90bc832b22aefb2a382b3465793df7e528351aa1/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fimp.rs?ref=90bc832b22aefb2a382b3465793df7e528351aa1", "patch": "@@ -1,21 +0,0 @@\n-use std::sync::Arc;\n-\n-use ra_syntax::ast::{AstNode, FnDef, FnDefNode};\n-\n-use crate::hir::{\n-    function::{FnId, FnScopes},\n-    HirDatabase,\n-};\n-\n-/// Resolve `FnId` to the corresponding `SyntaxNode`\n-pub(crate) fn fn_syntax(db: &impl HirDatabase, fn_id: FnId) -> FnDefNode {\n-    let ptr = db.id_maps().fn_ptr(fn_id);\n-    let syntax = db.resolve_syntax_ptr(ptr);\n-    FnDef::cast(syntax.borrowed()).unwrap().owned()\n-}\n-\n-pub(crate) fn fn_scopes(db: &impl HirDatabase, fn_id: FnId) -> Arc<FnScopes> {\n-    let syntax = db.fn_syntax(fn_id);\n-    let res = FnScopes::new(syntax.borrowed());\n-    Arc::new(res)\n-}"}, {"sha": "5de9806e30edc622b107fc6ba8439676c016b859", "filename": "crates/ra_analysis/src/hir/function/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fmod.rs?ref=b7049ea543d5ea9a965dfa51d9da923739f2420d", "patch": "@@ -1,4 +1,3 @@\n-pub(super) mod imp;\n mod scope;\n \n use std::{\n@@ -14,14 +13,13 @@ use ra_syntax::{\n use crate::{\n     hir::HirDatabase,\n     syntax_ptr::SyntaxPtr, FileId,\n-    loc2id::IdDatabase,\n };\n \n pub(crate) use self::scope::{resolve_local_name, FnScopes};\n pub(crate) use crate::loc2id::FnId;\n \n impl FnId {\n-    pub(crate) fn get(db: &impl IdDatabase, file_id: FileId, fn_def: ast::FnDef) -> FnId {\n+    pub(crate) fn get(db: &impl HirDatabase, file_id: FileId, fn_def: ast::FnDef) -> FnId {\n         let ptr = SyntaxPtr::new(file_id, fn_def.syntax());\n         db.id_maps().fn_id(ptr)\n     }"}, {"sha": "dc52fa4ef22281acb263bdcce38dd5023f030242", "filename": "crates/ra_analysis/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmod.rs?ref=b7049ea543d5ea9a965dfa51d9da923739f2420d", "patch": "@@ -9,6 +9,7 @@ pub(crate) mod function;\n pub(crate) mod module;\n pub(crate) mod db;\n mod path;\n+mod query_definitions;\n \n use ra_syntax::{\n     ast::{self, AstNode},"}, {"sha": "3b1baff76c22d2c26df484850871c11ddd79785a", "filename": "crates/ra_analysis/src/hir/module/imp.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fimp.rs?ref=b7049ea543d5ea9a965dfa51d9da923739f2420d", "patch": "@@ -15,7 +15,7 @@ use crate::{\n };\n \n use super::{\n-    LinkData, LinkId, ModuleData, ModuleId, ModuleSource, ModuleSourceNode,\n+    LinkData, LinkId, ModuleData, ModuleId, ModuleSource,\n     ModuleTree, Problem,\n };\n \n@@ -34,39 +34,6 @@ impl Submodule {\n     }\n }\n \n-pub(crate) fn submodules(\n-    db: &impl HirDatabase,\n-    source: ModuleSource,\n-) -> Cancelable<Arc<Vec<Submodule>>> {\n-    db::check_canceled(db)?;\n-    let file_id = source.file_id();\n-    let submodules = match source.resolve(db) {\n-        ModuleSourceNode::SourceFile(it) => collect_submodules(file_id, it.borrowed()),\n-        ModuleSourceNode::Module(it) => it\n-            .borrowed()\n-            .item_list()\n-            .map(|it| collect_submodules(file_id, it))\n-            .unwrap_or_else(Vec::new),\n-    };\n-    return Ok(Arc::new(submodules));\n-\n-    fn collect_submodules<'a>(\n-        file_id: FileId,\n-        root: impl ast::ModuleItemOwner<'a>,\n-    ) -> Vec<Submodule> {\n-        modules(root)\n-            .map(|(name, m)| {\n-                if m.has_semi() {\n-                    Submodule::Declaration(name)\n-                } else {\n-                    let src = ModuleSource::new_inline(file_id, m);\n-                    Submodule::Definition(name, src)\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n pub(crate) fn modules<'a>(\n     root: impl ast::ModuleItemOwner<'a>,\n ) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {"}, {"sha": "4d5945b1ae784fd0609106bd99436f620ccf8705", "filename": "crates/ra_analysis/src/hir/module/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fmod.rs?ref=b7049ea543d5ea9a965dfa51d9da923739f2420d", "patch": "@@ -196,7 +196,7 @@ pub(crate) struct ModuleTree {\n }\n \n impl ModuleTree {\n-    fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n+    pub(in crate::hir) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n         self.mods.iter().map(|(id, _)| id)\n     }\n \n@@ -224,7 +224,7 @@ pub(crate) enum ModuleSource {\n \n /// An owned syntax node for a module. Unlike `ModuleSource`,\n /// this holds onto the AST for the whole file.\n-enum ModuleSourceNode {\n+pub(crate) enum ModuleSourceNode {\n     SourceFile(ast::SourceFileNode),\n     Module(ast::ModuleNode),\n }\n@@ -244,7 +244,7 @@ pub enum Problem {\n }\n \n impl ModuleId {\n-    fn source(self, tree: &ModuleTree) -> ModuleSource {\n+    pub(in crate::hir) fn source(self, tree: &ModuleTree) -> ModuleSource {\n         tree.mods[self].source\n     }\n     fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n@@ -318,7 +318,7 @@ pub(crate) struct ModuleData {\n }\n \n impl ModuleSource {\n-    fn new_inline(file_id: FileId, module: ast::Module) -> ModuleSource {\n+    pub(crate) fn new_inline(file_id: FileId, module: ast::Module) -> ModuleSource {\n         assert!(!module.has_semi());\n         let ptr = SyntaxPtr::new(file_id, module.syntax());\n         ModuleSource::Module(ptr)\n@@ -338,7 +338,7 @@ impl ModuleSource {\n         }\n     }\n \n-    fn resolve(self, db: &impl SyntaxDatabase) -> ModuleSourceNode {\n+    pub(crate) fn resolve(self, db: &impl SyntaxDatabase) -> ModuleSourceNode {\n         match self {\n             ModuleSource::SourceFile(file_id) => {\n                 let syntax = db.file_syntax(file_id);"}, {"sha": "db5d6d9c0b2852bb26e56c03b43eca4376fc86a5", "filename": "crates/ra_analysis/src/hir/module/nameres.rs", "status": "modified", "additions": 12, "deletions": 88, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fnameres.rs?ref=b7049ea543d5ea9a965dfa51d9da923739f2420d", "patch": "@@ -16,7 +16,6 @@\n //! structure itself is modified.\n use std::{\n     sync::Arc,\n-    time::Instant,\n     ops::Index,\n };\n \n@@ -25,7 +24,7 @@ use rustc_hash::FxHashMap;\n use ra_syntax::{\n     SyntaxNode, SyntaxNodeRef, TextRange,\n     SmolStr, SyntaxKind::{self, *},\n-    ast::{self, ModuleItemOwner, AstNode}\n+    ast::{self, AstNode}\n };\n \n use crate::{\n@@ -34,7 +33,7 @@ use crate::{\n     hir::{\n         Path, PathKind,\n         HirDatabase,\n-        module::{ModuleId, ModuleTree, ModuleSourceNode},\n+        module::{ModuleId, ModuleTree},\n     },\n     input::SourceRootId,\n     arena::{Arena, Id}\n@@ -51,7 +50,7 @@ pub(crate) struct FileItems {\n }\n \n impl FileItems {\n-    fn alloc(&mut self, item: SyntaxNode) -> FileItemId {\n+    pub(crate) fn alloc(&mut self, item: SyntaxNode) -> FileItemId {\n         self.arena.alloc(item)\n     }\n     fn id_of(&self, item: SyntaxNodeRef) -> FileItemId {\n@@ -71,29 +70,6 @@ impl Index<FileItemId> for FileItems {\n     }\n }\n \n-pub(crate) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<FileItems> {\n-    let source_file = db.file_syntax(file_id);\n-    let source_file = source_file.borrowed();\n-    let mut res = FileItems::default();\n-    source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::ModuleItem::cast)\n-        .map(|it| it.syntax().owned())\n-        .for_each(|it| {\n-            res.alloc(it);\n-        });\n-    Arc::new(res)\n-}\n-\n-pub(crate) fn file_item(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    file_item_id: FileItemId,\n-) -> SyntaxNode {\n-    db.file_items(file_id)[file_item_id].clone()\n-}\n-\n /// Item map is the result of the name resolution. Item map contains, for each\n /// module, the set of visible items.\n #[derive(Default, Debug, PartialEq, Eq)]\n@@ -167,58 +143,6 @@ enum ImportKind {\n     Named(NamedImport),\n }\n \n-pub(crate) fn input_module_items(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-    module_id: ModuleId,\n-) -> Cancelable<Arc<InputModuleItems>> {\n-    let module_tree = db.module_tree(source_root)?;\n-    let source = module_id.source(&module_tree);\n-    let file_items = db.file_items(source.file_id());\n-    let res = match source.resolve(db) {\n-        ModuleSourceNode::SourceFile(it) => {\n-            let items = it.borrowed().items();\n-            InputModuleItems::new(&file_items, items)\n-        }\n-        ModuleSourceNode::Module(it) => {\n-            let items = it\n-                .borrowed()\n-                .item_list()\n-                .into_iter()\n-                .flat_map(|it| it.items());\n-            InputModuleItems::new(&file_items, items)\n-        }\n-    };\n-    Ok(Arc::new(res))\n-}\n-\n-pub(crate) fn item_map(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<Arc<ItemMap>> {\n-    let start = Instant::now();\n-    let module_tree = db.module_tree(source_root)?;\n-    let input = module_tree\n-        .modules()\n-        .map(|id| {\n-            let items = db.input_module_items(source_root, id)?;\n-            Ok((id, items))\n-        })\n-        .collect::<Cancelable<FxHashMap<_, _>>>()?;\n-    let mut resolver = Resolver {\n-        db: db,\n-        input: &input,\n-        source_root,\n-        module_tree,\n-        result: ItemMap::default(),\n-    };\n-    resolver.resolve()?;\n-    let res = resolver.result;\n-    let elapsed = start.elapsed();\n-    log::info!(\"item_map: {:?}\", elapsed);\n-    Ok(Arc::new(res))\n-}\n-\n /// Resolution is basically `DefId` atm, but it should account for stuff like\n /// multiple namespaces, ambiguity and errors.\n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -242,7 +166,7 @@ pub(crate) struct Resolution {\n // }\n \n impl InputModuleItems {\n-    fn new<'a>(\n+    pub(in crate::hir) fn new<'a>(\n         file_items: &FileItems,\n         items: impl Iterator<Item = ast::ModuleItem<'a>>,\n     ) -> InputModuleItems {\n@@ -306,19 +230,19 @@ impl ModuleItem {\n     }\n }\n \n-struct Resolver<'a, DB> {\n-    db: &'a DB,\n-    input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n-    source_root: SourceRootId,\n-    module_tree: Arc<ModuleTree>,\n-    result: ItemMap,\n+pub(in crate::hir) struct Resolver<'a, DB> {\n+    pub db: &'a DB,\n+    pub input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n+    pub source_root: SourceRootId,\n+    pub module_tree: Arc<ModuleTree>,\n+    pub result: ItemMap,\n }\n \n impl<'a, DB> Resolver<'a, DB>\n where\n     DB: HirDatabase,\n {\n-    fn resolve(&mut self) -> Cancelable<()> {\n+    pub(in crate::hir) fn resolve(mut self) -> Cancelable<ItemMap> {\n         for (&module_id, items) in self.input.iter() {\n             self.populate_module(module_id, items)\n         }\n@@ -327,7 +251,7 @@ where\n             crate::db::check_canceled(self.db)?;\n             self.resolve_imports(module_id);\n         }\n-        Ok(())\n+        Ok(self.result)\n     }\n \n     fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) {"}, {"sha": "8584a8d64c2cd6d5bac67785f62438d00e9c3750", "filename": "crates/ra_analysis/src/hir/query_definitions.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Fhir%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fquery_definitions.rs?ref=b7049ea543d5ea9a965dfa51d9da923739f2420d", "patch": "@@ -0,0 +1,158 @@\n+use std::{\n+    sync::Arc,\n+    time::Instant,\n+};\n+\n+use rustc_hash::FxHashMap;\n+use ra_syntax::{\n+    AstNode,  SyntaxNode, SmolStr,\n+    ast::{self, FnDef, FnDefNode, NameOwner, ModuleItemOwner}\n+};\n+\n+use crate::{\n+    FileId, Cancelable,\n+    hir::{\n+        db::HirDatabase,\n+        function::{FnId, FnScopes},\n+        module::{\n+            ModuleSource, ModuleSourceNode, ModuleId,\n+            imp::Submodule,\n+            nameres::{FileItems, FileItemId, InputModuleItems, ItemMap, Resolver},\n+        },\n+    },\n+    input::SourceRootId,\n+};\n+\n+/// Resolve `FnId` to the corresponding `SyntaxNode`\n+pub(super) fn fn_syntax(db: &impl HirDatabase, fn_id: FnId) -> FnDefNode {\n+    let ptr = db.id_maps().fn_ptr(fn_id);\n+    let syntax = db.resolve_syntax_ptr(ptr);\n+    FnDef::cast(syntax.borrowed()).unwrap().owned()\n+}\n+\n+pub(super) fn fn_scopes(db: &impl HirDatabase, fn_id: FnId) -> Arc<FnScopes> {\n+    let syntax = db.fn_syntax(fn_id);\n+    let res = FnScopes::new(syntax.borrowed());\n+    Arc::new(res)\n+}\n+\n+pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<FileItems> {\n+    let source_file = db.file_syntax(file_id);\n+    let source_file = source_file.borrowed();\n+    let mut res = FileItems::default();\n+    source_file\n+        .syntax()\n+        .descendants()\n+        .filter_map(ast::ModuleItem::cast)\n+        .map(|it| it.syntax().owned())\n+        .for_each(|it| {\n+            res.alloc(it);\n+        });\n+    Arc::new(res)\n+}\n+\n+pub(super) fn file_item(\n+    db: &impl HirDatabase,\n+    file_id: FileId,\n+    file_item_id: FileItemId,\n+) -> SyntaxNode {\n+    db.file_items(file_id)[file_item_id].clone()\n+}\n+\n+pub(crate) fn submodules(\n+    db: &impl HirDatabase,\n+    source: ModuleSource,\n+) -> Cancelable<Arc<Vec<Submodule>>> {\n+    db.check_canceled()?;\n+    let file_id = source.file_id();\n+    let submodules = match source.resolve(db) {\n+        ModuleSourceNode::SourceFile(it) => collect_submodules(file_id, it.borrowed()),\n+        ModuleSourceNode::Module(it) => it\n+            .borrowed()\n+            .item_list()\n+            .map(|it| collect_submodules(file_id, it))\n+            .unwrap_or_else(Vec::new),\n+    };\n+    return Ok(Arc::new(submodules));\n+\n+    fn collect_submodules<'a>(\n+        file_id: FileId,\n+        root: impl ast::ModuleItemOwner<'a>,\n+    ) -> Vec<Submodule> {\n+        modules(root)\n+            .map(|(name, m)| {\n+                if m.has_semi() {\n+                    Submodule::Declaration(name)\n+                } else {\n+                    let src = ModuleSource::new_inline(file_id, m);\n+                    Submodule::Definition(name, src)\n+                }\n+            })\n+            .collect()\n+    }\n+}\n+\n+pub(crate) fn modules<'a>(\n+    root: impl ast::ModuleItemOwner<'a>,\n+) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+    root.items()\n+        .filter_map(|item| match item {\n+            ast::ModuleItem::Module(m) => Some(m),\n+            _ => None,\n+        })\n+        .filter_map(|module| {\n+            let name = module.name()?.text();\n+            Some((name, module))\n+        })\n+}\n+\n+pub(super) fn input_module_items(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+    module_id: ModuleId,\n+) -> Cancelable<Arc<InputModuleItems>> {\n+    let module_tree = db.module_tree(source_root)?;\n+    let source = module_id.source(&module_tree);\n+    let file_items = db.file_items(source.file_id());\n+    let res = match source.resolve(db) {\n+        ModuleSourceNode::SourceFile(it) => {\n+            let items = it.borrowed().items();\n+            InputModuleItems::new(&file_items, items)\n+        }\n+        ModuleSourceNode::Module(it) => {\n+            let items = it\n+                .borrowed()\n+                .item_list()\n+                .into_iter()\n+                .flat_map(|it| it.items());\n+            InputModuleItems::new(&file_items, items)\n+        }\n+    };\n+    Ok(Arc::new(res))\n+}\n+\n+pub(super) fn item_map(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<Arc<ItemMap>> {\n+    let start = Instant::now();\n+    let module_tree = db.module_tree(source_root)?;\n+    let input = module_tree\n+        .modules()\n+        .map(|id| {\n+            let items = db.input_module_items(source_root, id)?;\n+            Ok((id, items))\n+        })\n+        .collect::<Cancelable<FxHashMap<_, _>>>()?;\n+    let resolver = Resolver {\n+        db: db,\n+        input: &input,\n+        source_root,\n+        module_tree,\n+        result: ItemMap::default(),\n+    };\n+    let res = resolver.resolve()?;\n+    let elapsed = start.elapsed();\n+    log::info!(\"item_map: {:?}\", elapsed);\n+    Ok(Arc::new(res))\n+}"}, {"sha": "40da8366542c133dfc6d8ccaa5f448ea331be35f", "filename": "crates/ra_analysis/src/loc2id.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7049ea543d5ea9a965dfa51d9da923739f2420d/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Floc2id.rs?ref=b7049ea543d5ea9a965dfa51d9da923739f2420d", "patch": "@@ -109,10 +109,6 @@ pub(crate) enum DefLoc {\n     },\n }\n \n-pub(crate) trait IdDatabase: salsa::Database {\n-    fn id_maps(&self) -> &IdMaps;\n-}\n-\n #[derive(Debug, Default, Clone)]\n pub(crate) struct IdMaps {\n     inner: Arc<IdMapsInner>,"}]}