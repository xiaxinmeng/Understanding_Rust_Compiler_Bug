{"sha": "48582b360c784a536bd502f9611cfe66c753ce64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NTgyYjM2MGM3ODRhNTM2YmQ1MDJmOTYxMWNmZTY2Yzc1M2NlNjQ=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2012-10-22T02:24:56Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2012-10-22T02:43:28Z"}, "message": "Replace rust_atomic_increment/decrement and rust_compare_and_swap_ptr with intrinsics.", "tree": {"sha": "8941a1bf7ca339f8fe70f1a76c5e50baa0140bb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8941a1bf7ca339f8fe70f1a76c5e50baa0140bb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48582b360c784a536bd502f9611cfe66c753ce64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48582b360c784a536bd502f9611cfe66c753ce64", "html_url": "https://github.com/rust-lang/rust/commit/48582b360c784a536bd502f9611cfe66c753ce64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48582b360c784a536bd502f9611cfe66c753ce64/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1db959ec22712376763e062dc2fbffc18f33d9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1db959ec22712376763e062dc2fbffc18f33d9c", "html_url": "https://github.com/rust-lang/rust/commit/e1db959ec22712376763e062dc2fbffc18f33d9c"}], "stats": {"total": 171, "additions": 146, "deletions": 25}, "files": [{"sha": "fcc01ca42ffdee66953a2ad1c40b2c6bd6fb2130", "filename": "src/libcore/private.rs", "status": "modified", "additions": 145, "deletions": 12, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/48582b360c784a536bd502f9611cfe66c753ce64/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48582b360c784a536bd502f9611cfe66c753ce64/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=48582b360c784a536bd502f9611cfe66c753ce64", "patch": "@@ -14,14 +14,6 @@ extern mod rustrt {\n     fn rust_task_weaken(ch: rust_port_id);\n     fn rust_task_unweaken(ch: rust_port_id);\n \n-    #[rust_stack]\n-    fn rust_atomic_increment(p: &mut libc::intptr_t)\n-        -> libc::intptr_t;\n-\n-    #[rust_stack]\n-    fn rust_atomic_decrement(p: &mut libc::intptr_t)\n-        -> libc::intptr_t;\n-\n     #[rust_stack]\n     fn rust_compare_and_swap_ptr(address: &mut libc::uintptr_t,\n                                  oldval: libc::uintptr_t,\n@@ -33,6 +25,15 @@ extern mod rustrt {\n     fn rust_unlock_little_lock(lock: rust_little_lock);\n }\n \n+#[abi = \"rust-intrinsic\"]\n+extern mod rusti {\n+\n+    #[cfg(stage1)] #[cfg(stage2)] #[cfg(stage3)]    \n+    fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n+    fn atomic_xadd(dst: &mut int, src: int) -> int;\n+    fn atomic_xsub(dst: &mut int, src: int) -> int;\n+}\n+\n #[allow(non_camel_case_types)] // runtime type\n type rust_port_id = uint;\n \n@@ -43,6 +44,7 @@ type GlobalPtr = *libc::uintptr_t;\n  * or, if no channel exists creates and installs a new channel and sets up a\n  * new task to receive from it.\n  */\n+#[cfg(stage0)]\n pub unsafe fn chan_from_global_ptr<T: Send>(\n     global: GlobalPtr,\n     task_fn: fn() -> task::TaskBuilder,\n@@ -103,6 +105,68 @@ pub unsafe fn chan_from_global_ptr<T: Send>(\n     }\n }\n \n+#[cfg(stage1)] #[cfg(stage2)] #[cfg(stage3)]    \n+pub unsafe fn chan_from_global_ptr<T: Send>(\n+    global: GlobalPtr,\n+    task_fn: fn() -> task::TaskBuilder,\n+    f: fn~(comm::Port<T>)\n+) -> comm::Chan<T> {\n+\n+    enum Msg {\n+        Proceed,\n+        Abort\n+    }\n+\n+    log(debug,~\"ENTERING chan_from_global_ptr, before is_prob_zero check\");\n+    let is_probably_zero = *global == 0u;\n+    log(debug,~\"after is_prob_zero check\");\n+    if is_probably_zero {\n+        log(debug,~\"is probably zero...\");\n+        // There's no global channel. We must make it\n+\n+        let (setup_po, setup_ch) = do task_fn().spawn_conversation\n+            |move f, setup_po, setup_ch| {\n+            let po = comm::Port::<T>();\n+            let ch = comm::Chan(&po);\n+            comm::send(setup_ch, ch);\n+\n+            // Wait to hear if we are the official instance of\n+            // this global task\n+            match comm::recv::<Msg>(setup_po) {\n+              Proceed => f(move po),\n+              Abort => ()\n+            }\n+        };\n+\n+        log(debug,~\"before setup recv..\");\n+        // This is the proposed global channel\n+        let ch = comm::recv(setup_po);\n+        // 0 is our sentinal value. It is not a valid channel\n+        assert *ch != 0;\n+\n+        // Install the channel\n+        log(debug,~\"BEFORE COMPARE AND SWAP\");\n+        rusti::atomic_cxchg(\n+            cast::reinterpret_cast(&global),\n+            0, cast::reinterpret_cast(&ch));\n+        let swapped = *global != 0;\n+        log(debug,fmt!(\"AFTER .. swapped? %?\", swapped));\n+\n+        if swapped {\n+            // Success!\n+            comm::send(setup_ch, Proceed);\n+            ch\n+        } else {\n+            // Somebody else got in before we did\n+            comm::send(setup_ch, Abort);\n+            cast::reinterpret_cast(&*global)\n+        }\n+    } else {\n+        log(debug, ~\"global != 0\");\n+        cast::reinterpret_cast(&*global)\n+    }\n+}\n+\n #[test]\n pub fn test_from_global_chan1() {\n \n@@ -305,7 +369,7 @@ struct ArcDestruct<T> {\n         }\n         do task::unkillable {\n             let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n-            let new_count = rustrt::rust_atomic_decrement(&mut data.count);\n+            let new_count = rusti::atomic_xsub(&mut data.count, 1) - 1;\n             assert new_count >= 0;\n             if new_count == 0 {\n                 // Were we really last, or should we hand off to an unwrapper?\n@@ -341,6 +405,7 @@ fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n     }\n }\n \n+#[cfg(stage0)]\n pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n@@ -373,8 +438,76 @@ pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n             // Got in. Step 0: Tell destructor not to run. We are now it.\n             rc.data = ptr::null();\n             // Step 1 - drop our own reference.\n-            let new_count = rustrt::rust_atomic_decrement(&mut ptr.count);\n-        //    assert new_count >= 0;\n+            let new_count = rusti::atomic_xsub(&mut ptr.count, 1) - 1;\n+            //assert new_count >= 0;\n+            if new_count == 0 {\n+                // We were the last owner. Can unwrap immediately.\n+                // Also we have to free the server endpoints.\n+                let _server: UnwrapProto = cast::transmute(move serverp);\n+                option::swap_unwrap(&mut ptr.data)\n+                // drop glue takes over.\n+            } else {\n+                // The *next* person who sees the refcount hit 0 will wake us.\n+                let end_result =\n+                    DeathThroes { ptr: Some(move ptr),\n+                                  response: Some(move c2) };\n+                let mut p1 = Some(move p1); // argh\n+                do task::rekillable {\n+                    pipes::recv_one(option::swap_unwrap(&mut p1));\n+                }\n+                // Got here. Back in the 'unkillable' without getting killed.\n+                // Recover ownership of ptr, then take the data out.\n+                let ptr = option::swap_unwrap(&mut end_result.ptr);\n+                option::swap_unwrap(&mut ptr.data)\n+                // drop glue takes over.\n+            }\n+        } else {\n+            // Somebody else was trying to unwrap. Avoid guaranteed deadlock.\n+            cast::forget(move ptr);\n+            // Also we have to free the (rejected) server endpoints.\n+            let _server: UnwrapProto = cast::transmute(move serverp);\n+            fail ~\"Another task is already unwrapping this ARC!\";\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)] #[cfg(stage2)] #[cfg(stage3)]    \n+pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n+        -> T {\n+    struct DeathThroes<T> {\n+        mut ptr:      Option<~ArcData<T>>,\n+        mut response: Option<pipes::ChanOne<bool>>,\n+        drop unsafe {\n+            let response = option::swap_unwrap(&mut self.response);\n+            // In case we get killed early, we need to tell the person who\n+            // tried to wake us whether they should hand-off the data to us.\n+            if task::failing() {\n+                pipes::send_one(move response, false);\n+                // Either this swap_unwrap or the one below (at \"Got here\")\n+                // ought to run.\n+                cast::forget(option::swap_unwrap(&mut self.ptr));\n+            } else {\n+                assert self.ptr.is_none();\n+                pipes::send_one(move response, true);\n+            }\n+        }\n+    }\n+\n+    do task::unkillable {\n+        let ptr: ~ArcData<T> = cast::reinterpret_cast(&rc.data);\n+        let (c1,p1) = pipes::oneshot(); // ()\n+        let (c2,p2) = pipes::oneshot(); // bool\n+        let server: UnwrapProto = ~mut Some((move c1,move p2));\n+        let serverp: libc::uintptr_t = cast::transmute(move server);\n+        // Try to put our server end in the unwrapper slot.\n+        rusti::atomic_cxchg(cast::reinterpret_cast(&ptr.unwrapper),\n+                            0, serverp as int);\n+        if ptr.unwrapper != 0 {\n+            // Got in. Step 0: Tell destructor not to run. We are now it.\n+            rc.data = ptr::null();\n+            // Step 1 - drop our own reference.\n+            let new_count = rusti::atomic_xsub(&mut ptr.count, 1) - 1;\n+            //assert new_count >= 0;\n             if new_count == 0 {\n                 // We were the last owner. Can unwrap immediately.\n                 // Also we have to free the server endpoints.\n@@ -452,7 +585,7 @@ pub unsafe fn clone_shared_mutable_state<T: Send>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n+        let new_count = rusti::atomic_xadd(&mut ptr.count, 1) + 1;\n         assert new_count >= 2;\n         cast::forget(move ptr);\n     }"}, {"sha": "67281cbee5a365d6bcc2ca60c877f846d6a8a541", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48582b360c784a536bd502f9611cfe66c753ce64/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/48582b360c784a536bd502f9611cfe66c753ce64/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=48582b360c784a536bd502f9611cfe66c753ce64", "patch": "@@ -830,16 +830,6 @@ rust_compare_and_swap_ptr(intptr_t *address,\n     return sync::compare_and_swap(address, oldval, newval);\n }\n \n-extern \"C\" CDECL intptr_t\n-rust_atomic_increment(intptr_t *address) {\n-    return sync::increment(address);\n-}\n-\n-extern \"C\" CDECL intptr_t\n-rust_atomic_decrement(intptr_t *address) {\n-    return sync::decrement(address);\n-}\n-\n extern \"C\" CDECL void\n rust_task_weaken(rust_port_id chan) {\n     rust_task *task = rust_get_current_task();"}, {"sha": "3760c9ff09f4a2e607a387bf403b1056933c7e19", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48582b360c784a536bd502f9611cfe66c753ce64/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/48582b360c784a536bd502f9611cfe66c753ce64/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=48582b360c784a536bd502f9611cfe66c753ce64", "patch": "@@ -178,8 +178,6 @@ rust_dbg_do_nothing\n rust_dbg_breakpoint\n rust_osmain_sched_id\n rust_compare_and_swap_ptr\n-rust_atomic_increment\n-rust_atomic_decrement\n rust_global_env_chan_ptr\n rust_port_take\n rust_port_drop\n@@ -207,4 +205,4 @@ rust_gc_metadata\n rust_uv_ip4_port\n rust_uv_ip6_port\n rust_uv_tcp_getpeername\n-rust_uv_tcp_getpeername6\n\\ No newline at end of file\n+rust_uv_tcp_getpeername6"}]}