{"sha": "0347b32a26ef0e02f1a1117581271431c6c94a63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNDdiMzJhMjZlZjBlMDJmMWExMTE3NTgxMjcxNDMxYzZjOTRhNjM=", "commit": {"author": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2018-06-04T11:57:56Z"}, "committer": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2018-06-04T16:21:14Z"}, "message": "Refactor the chalkify lowering process", "tree": {"sha": "044e0c75f1f2629312e6d1a21ca34bc9d27d060f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/044e0c75f1f2629312e6d1a21ca34bc9d27d060f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0347b32a26ef0e02f1a1117581271431c6c94a63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0347b32a26ef0e02f1a1117581271431c6c94a63", "html_url": "https://github.com/rust-lang/rust/commit/0347b32a26ef0e02f1a1117581271431c6c94a63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0347b32a26ef0e02f1a1117581271431c6c94a63/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6eafab06cf76fd1461aabc2c6a4fc0daa516da13", "url": "https://api.github.com/repos/rust-lang/rust/commits/6eafab06cf76fd1461aabc2c6a4fc0daa516da13", "html_url": "https://github.com/rust-lang/rust/commit/6eafab06cf76fd1461aabc2c6a4fc0daa516da13"}], "stats": {"total": 372, "additions": 234, "deletions": 138}, "files": [{"sha": "ad255fb8417f25b26be12ccf117b606e948d5f38", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=0347b32a26ef0e02f1a1117581271431c6c94a63", "patch": "@@ -1382,16 +1382,46 @@ impl_stable_hash_for!(enum infer::canonical::Certainty {\n     Proven, Ambiguous\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClauseAtom<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClause<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::WhereClauseAtom::*;\n+        use traits::WhereClause::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n             Implemented(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n             ProjectionEq(projection) => projection.hash_stable(hcx, hasher),\n+            TypeOutlives(ty_outlives) => ty_outlives.hash_stable(hcx, hasher),\n+            RegionOutlives(region_outlives) => region_outlives.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WellFormed<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::WellFormed::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Trait(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n+            Ty(ty) => ty.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::FromEnv<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::FromEnv::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Trait(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n+            Ty(ty) => ty.hash_stable(hcx, hasher),\n         }\n     }\n }\n@@ -1404,15 +1434,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx>\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n-            Holds(where_clause) |\n-            WellFormed(where_clause) |\n-            FromEnv(where_clause) => where_clause.hash_stable(hcx, hasher),\n-\n-            WellFormedTy(ty) => ty.hash_stable(hcx, hasher),\n+            Holds(wc) => wc.hash_stable(hcx, hasher),\n+            WellFormed(wf) => wf.hash_stable(hcx, hasher),\n+            FromEnv(from_env) => from_env.hash_stable(hcx, hasher),\n             Normalize(projection) => projection.hash_stable(hcx, hasher),\n-            FromEnvTy(ty) => ty.hash_stable(hcx, hasher),\n-            RegionOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n-            TypeOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n         }\n     }\n }"}, {"sha": "4e4c60b1c11818bbc8d0742d290602ea189bc972", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=0347b32a26ef0e02f1a1117581271431c6c94a63", "patch": "@@ -269,29 +269,41 @@ pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n /// The following types:\n-/// * `WhereClauseAtom`\n+/// * `WhereClause`\n+/// * `WellFormed`\n+/// * `FromEnv`\n /// * `DomainGoal`\n /// * `Goal`\n /// * `Clause`\n /// are used for representing the trait system in the form of\n /// logic programming clauses. They are part of the interface\n /// for the chalk SLG solver.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum WhereClauseAtom<'tcx> {\n+pub enum WhereClause<'tcx> {\n     Implemented(ty::TraitPredicate<'tcx>),\n     ProjectionEq(ty::ProjectionPredicate<'tcx>),\n+    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n+    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum WellFormed<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum FromEnv<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum DomainGoal<'tcx> {\n-    Holds(WhereClauseAtom<'tcx>),\n-    WellFormed(WhereClauseAtom<'tcx>),\n-    FromEnv(WhereClauseAtom<'tcx>),\n-    WellFormedTy(Ty<'tcx>),\n+    Holds(WhereClause<'tcx>),\n+    WellFormed(WellFormed<'tcx>),\n+    FromEnv(FromEnv<'tcx>),\n     Normalize(ty::ProjectionPredicate<'tcx>),\n-    FromEnvTy(Ty<'tcx>),\n-    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n-    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n }\n \n pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n@@ -314,27 +326,27 @@ pub enum Goal<'tcx> {\n \n pub type Goals<'tcx> = &'tcx Slice<Goal<'tcx>>;\n \n+impl<'tcx> DomainGoal<'tcx> {\n+    pub fn into_goal(self) -> Goal<'tcx> {\n+        Goal::DomainGoal(self)\n+    }\n+}\n+\n impl<'tcx> Goal<'tcx> {\n     pub fn from_poly_domain_goal<'a>(\n         domain_goal: PolyDomainGoal<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ) -> Goal<'tcx> {\n         match domain_goal.no_late_bound_regions() {\n-            Some(p) => p.into(),\n+            Some(p) => p.into_goal(),\n             None => Goal::Quantified(\n                 QuantifierKind::Universal,\n-                domain_goal.map_bound(|p| tcx.mk_goal(Goal::from(p)))\n+                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal()))\n             ),\n         }\n     }\n }\n \n-impl<'tcx> From<DomainGoal<'tcx>> for Goal<'tcx> {\n-    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n-        Goal::DomainGoal(domain_goal)\n-    }\n-}\n-\n /// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n /// Harrop Formulas\".\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "d24c84b2556f860653902fb8aace1aa896b6940c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 73, "deletions": 30, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=0347b32a26ef0e02f1a1117581271431c6c94a63", "patch": "@@ -405,33 +405,50 @@ BraceStructTypeFoldableImpl! {\n     } where T: TypeFoldable<'tcx>\n }\n \n-impl<'tcx> fmt::Display for traits::WhereClauseAtom<'tcx> {\n+impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        use traits::WhereClauseAtom::*;\n+        use traits::WhereClause::*;\n \n         match self {\n             Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n             ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+            RegionOutlives(predicate) => write!(fmt, \"RegionOutlives({})\", predicate),\n+            TypeOutlives(predicate) => write!(fmt, \"TypeOutlives({})\", predicate),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::WellFormed::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::FromEnv::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n         }\n     }\n }\n \n impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         use traits::DomainGoal::*;\n-        use traits::WhereClauseAtom::*;\n \n         match self {\n             Holds(wc) => write!(fmt, \"{}\", wc),\n-            WellFormed(Implemented(trait_ref)) => write!(fmt, \"WellFormed({})\", trait_ref),\n-            WellFormed(ProjectionEq(projection)) => write!(fmt, \"WellFormed({})\", projection),\n-            FromEnv(Implemented(trait_ref)) => write!(fmt, \"FromEnv({})\", trait_ref),\n-            FromEnv(ProjectionEq(projection)) => write!(fmt, \"FromEnv({})\", projection),\n-            WellFormedTy(ty) => write!(fmt, \"WellFormed({})\", ty),\n+            WellFormed(wf) => write!(fmt, \"{}\", wf),\n+            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n             Normalize(projection) => write!(fmt, \"Normalize({})\", projection),\n-            FromEnvTy(ty) => write!(fmt, \"FromEnv({})\", ty),\n-            RegionOutlives(predicate) => write!(fmt, \"RegionOutlives({})\", predicate),\n-            TypeOutlives(predicate) => write!(fmt, \"TypeOutlives({})\", predicate),\n         }\n     }\n }\n@@ -506,44 +523,70 @@ impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n }\n \n EnumTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for traits::WhereClauseAtom<'tcx> {\n-        (traits::WhereClauseAtom::Implemented)(trait_ref),\n-        (traits::WhereClauseAtom::ProjectionEq)(projection),\n+    impl<'tcx> TypeFoldable<'tcx> for traits::WhereClause<'tcx> {\n+        (traits::WhereClause::Implemented)(trait_ref),\n+        (traits::WhereClause::ProjectionEq)(projection),\n+        (traits::WhereClause::TypeOutlives)(ty_outlives),\n+        (traits::WhereClause::RegionOutlives)(region_outlives),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClause<'a> {\n+        type Lifted = traits::WhereClause<'tcx>;\n+        (traits::WhereClause::Implemented)(trait_ref),\n+        (traits::WhereClause::ProjectionEq)(projection),\n+        (traits::WhereClause::TypeOutlives)(ty_outlives),\n+        (traits::WhereClause::RegionOutlives)(region_outlives),\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::WellFormed<'tcx> {\n+        (traits::WellFormed::Trait)(trait_ref),\n+        (traits::WellFormed::Ty)(ty),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WellFormed<'a> {\n+        type Lifted = traits::WellFormed<'tcx>;\n+        (traits::WellFormed::Trait)(trait_ref),\n+        (traits::WellFormed::Ty)(ty),\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::FromEnv<'tcx> {\n+        (traits::FromEnv::Trait)(trait_ref),\n+        (traits::FromEnv::Ty)(ty),\n     }\n }\n \n EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClauseAtom<'a> {\n-        type Lifted = traits::WhereClauseAtom<'tcx>;\n-        (traits::WhereClauseAtom::Implemented)(trait_ref),\n-        (traits::WhereClauseAtom::ProjectionEq)(projection),\n+    impl<'a, 'tcx> Lift<'tcx> for traits::FromEnv<'a> {\n+        type Lifted = traits::FromEnv<'tcx>;\n+        (traits::FromEnv::Trait)(trait_ref),\n+        (traits::FromEnv::Ty)(ty),\n     }\n }\n \n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n         (traits::DomainGoal::Holds)(wc),\n-        (traits::DomainGoal::WellFormed)(wc),\n-        (traits::DomainGoal::FromEnv)(wc),\n-        (traits::DomainGoal::WellFormedTy)(ty),\n+        (traits::DomainGoal::WellFormed)(wf),\n+        (traits::DomainGoal::FromEnv)(from_env),\n         (traits::DomainGoal::Normalize)(projection),\n-        (traits::DomainGoal::FromEnvTy)(ty),\n-        (traits::DomainGoal::RegionOutlives)(predicate),\n-        (traits::DomainGoal::TypeOutlives)(predicate),\n     }\n }\n \n EnumLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for traits::DomainGoal<'a> {\n         type Lifted = traits::DomainGoal<'tcx>;\n         (traits::DomainGoal::Holds)(wc),\n-        (traits::DomainGoal::WellFormed)(wc),\n-        (traits::DomainGoal::FromEnv)(wc),\n-        (traits::DomainGoal::WellFormedTy)(ty),\n+        (traits::DomainGoal::WellFormed)(wf),\n+        (traits::DomainGoal::FromEnv)(from_env),\n         (traits::DomainGoal::Normalize)(projection),\n-        (traits::DomainGoal::FromEnvTy)(ty),\n-        (traits::DomainGoal::RegionOutlives)(predicate),\n-        (traits::DomainGoal::TypeOutlives)(predicate),\n     }\n }\n "}, {"sha": "d22cb4a93a52924506955b4188bd3697fbaa1e55", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=0347b32a26ef0e02f1a1117581271431c6c94a63", "patch": "@@ -14,7 +14,16 @@ use rustc::infer::canonical::{\n     Canonical, CanonicalVarValues, Canonicalize, QueryRegionConstraint, QueryResult,\n };\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use rustc::traits::{DomainGoal, ExClauseFold, ExClauseLift, Goal, ProgramClause, QuantifierKind};\n+use rustc::traits::{\n+    WellFormed, \n+    FromEnv,\n+    DomainGoal,\n+    ExClauseFold,\n+    ExClauseLift,\n+    Goal,\n+    ProgramClause,\n+    QuantifierKind\n+};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, TyCtxt};\n@@ -314,43 +323,42 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         _environment: &ty::ParamEnv<'tcx>,\n         goal: &DomainGoal<'tcx>,\n     ) -> Vec<ProgramClause<'tcx>> {\n-        use rustc::traits::DomainGoal::*;\n-        use rustc::traits::WhereClauseAtom::*;\n+        use rustc::traits::WhereClause::*;\n \n         match goal {\n-            Holds(Implemented(_trait_predicate)) => {\n+            DomainGoal::Holds(Implemented(_trait_predicate)) => {\n                 // These come from:\n                 //\n                 // - Trait definitions (implied bounds)\n                 // - Implementations of the trait itself\n                 panic!()\n             }\n \n-            Holds(ProjectionEq(_projection_predicate)) => {\n+            DomainGoal::Holds(ProjectionEq(_projection_predicate)) => {\n                 // These come from:\n                 panic!()\n             }\n \n-            WellFormed(Implemented(_trait_predicate)) => {\n-                // These come from -- the trait decl.\n+            DomainGoal::Holds(RegionOutlives(_region_outlives)) => {\n                 panic!()\n             }\n \n-            WellFormed(ProjectionEq(_projection_predicate)) => panic!(),\n-\n-            FromEnv(Implemented(_trait_predicate)) => panic!(),\n-\n-            FromEnv(ProjectionEq(_projection_predicate)) => panic!(),\n+            DomainGoal::Holds(TypeOutlives(_type_outlives)) => {\n+                panic!()\n+            }\n \n-            WellFormedTy(_ty) => panic!(),\n+            DomainGoal::WellFormed(WellFormed::Trait(_trait_predicate)) => {\n+                // These come from -- the trait decl.\n+                panic!()\n+            }\n \n-            FromEnvTy(_ty) => panic!(),\n+            DomainGoal::WellFormed(WellFormed::Ty(_ty)) => panic!(),\n \n-            RegionOutlives(_region_outlives) => panic!(),\n+            DomainGoal::FromEnv(FromEnv::Trait(_trait_predicate)) => panic!(),\n \n-            TypeOutlives(_type_outlives) => panic!(),\n+            DomainGoal::FromEnv(FromEnv::Ty(_ty)) => panic!(),\n \n-            Normalize(_) => panic!(),\n+            DomainGoal::Normalize(_) => panic!(),\n         }\n     }\n "}, {"sha": "baa26c9e15716a2b79ee58c4b9475ed4d82ce1ce", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 72, "deletions": 64, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0347b32a26ef0e02f1a1117581271431c6c94a63/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=0347b32a26ef0e02f1a1117581271431c6c94a63", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::map::definitions::DefPathData;\n use rustc::hir::{self, ImplPolarity};\n use rustc::traits::{Clause, Clauses, DomainGoal, Goal, PolyDomainGoal, ProgramClause,\n-                    WhereClauseAtom};\n+                    WhereClause, FromEnv, WellFormed};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Slice, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n@@ -23,7 +23,7 @@ use syntax::ast;\n use std::iter;\n \n crate trait Lower<T> {\n-    /// Lower a rustc construction (e.g. `ty::TraitPredicate`) to a chalk-like type.\n+    /// Lower a rustc construct (e.g. `ty::TraitPredicate`) to a chalk-like type.\n     fn lower(&self) -> T;\n }\n \n@@ -36,36 +36,36 @@ where\n     }\n }\n \n-impl<'tcx> Lower<WhereClauseAtom<'tcx>> for ty::TraitPredicate<'tcx> {\n-    fn lower(&self) -> WhereClauseAtom<'tcx> {\n-        WhereClauseAtom::Implemented(*self)\n+impl<'tcx> Lower<WhereClause<'tcx>> for ty::TraitPredicate<'tcx> {\n+    fn lower(&self) -> WhereClause<'tcx> {\n+        WhereClause::Implemented(*self)\n     }\n }\n \n-impl<'tcx> Lower<WhereClauseAtom<'tcx>> for ty::ProjectionPredicate<'tcx> {\n-    fn lower(&self) -> WhereClauseAtom<'tcx> {\n-        WhereClauseAtom::ProjectionEq(*self)\n+impl<'tcx> Lower<WhereClause<'tcx>> for ty::ProjectionPredicate<'tcx> {\n+    fn lower(&self) -> WhereClause<'tcx> {\n+        WhereClause::ProjectionEq(*self)\n     }\n }\n \n-impl<'tcx, T> Lower<DomainGoal<'tcx>> for T\n-where\n-    T: Lower<WhereClauseAtom<'tcx>>,\n-{\n-    fn lower(&self) -> DomainGoal<'tcx> {\n-        DomainGoal::Holds(self.lower())\n+impl<'tcx> Lower<WhereClause<'tcx>> for ty::RegionOutlivesPredicate<'tcx> {\n+    fn lower(&self) -> WhereClause<'tcx> {\n+        WhereClause::RegionOutlives(*self)\n     }\n }\n \n-impl<'tcx> Lower<DomainGoal<'tcx>> for ty::RegionOutlivesPredicate<'tcx> {\n-    fn lower(&self) -> DomainGoal<'tcx> {\n-        DomainGoal::RegionOutlives(*self)\n+impl<'tcx> Lower<WhereClause<'tcx>> for ty::TypeOutlivesPredicate<'tcx> {\n+    fn lower(&self) -> WhereClause<'tcx> {\n+        WhereClause::TypeOutlives(*self)\n     }\n }\n \n-impl<'tcx> Lower<DomainGoal<'tcx>> for ty::TypeOutlivesPredicate<'tcx> {\n+impl<'tcx, T> Lower<DomainGoal<'tcx>> for T\n+where\n+    T: Lower<WhereClause<'tcx>>,\n+{\n     fn lower(&self) -> DomainGoal<'tcx> {\n-        DomainGoal::TypeOutlives(*self)\n+        DomainGoal::Holds(self.lower())\n     }\n }\n \n@@ -86,15 +86,20 @@ where\n \n impl<'tcx> Lower<PolyDomainGoal<'tcx>> for ty::Predicate<'tcx> {\n     fn lower(&self) -> PolyDomainGoal<'tcx> {\n-        use rustc::ty::Predicate::*;\n+        use rustc::ty::Predicate;\n \n         match self {\n-            Trait(predicate) => predicate.lower(),\n-            RegionOutlives(predicate) => predicate.lower(),\n-            TypeOutlives(predicate) => predicate.lower(),\n-            Projection(predicate) => predicate.lower(),\n-            WellFormed(ty) => ty::Binder::dummy(DomainGoal::WellFormedTy(*ty)),\n-            ObjectSafe(..) | ClosureKind(..) | Subtype(..) | ConstEvaluatable(..) => {\n+            Predicate::Trait(predicate) => predicate.lower(),\n+            Predicate::RegionOutlives(predicate) => predicate.lower(),\n+            Predicate::TypeOutlives(predicate) => predicate.lower(),\n+            Predicate::Projection(predicate) => predicate.lower(),\n+            Predicate::WellFormed(ty) => ty::Binder::dummy(\n+                DomainGoal::WellFormed(WellFormed::Ty(*ty))\n+            ),\n+            Predicate::ObjectSafe(..) |\n+            Predicate::ClosureKind(..) |\n+            Predicate::Subtype(..) |\n+            Predicate::ConstEvaluatable(..) => {\n                 unimplemented!()\n             }\n         }\n@@ -110,11 +115,13 @@ trait IntoFromEnvGoal {\n \n impl<'tcx> IntoFromEnvGoal for DomainGoal<'tcx> {\n     fn into_from_env_goal(self) -> DomainGoal<'tcx> {\n-        use self::DomainGoal::*;\n+        use self::WhereClause::*;\n+\n         match self {\n-            Holds(wc_atom) => FromEnv(wc_atom),\n-            WellFormed(..) | FromEnv(..) | WellFormedTy(..) | FromEnvTy(..) | Normalize(..)\n-            | RegionOutlives(..) | TypeOutlives(..) => self,\n+            DomainGoal::Holds(Implemented(trait_ref)) => DomainGoal::FromEnv(\n+                FromEnv::Trait(trait_ref)\n+            ),\n+            other => other,\n         }\n     }\n }\n@@ -212,16 +219,20 @@ fn program_clauses_for_trait<'a, 'tcx>(\n             substs: Substs::identity_for_item(tcx, def_id),\n         },\n     };\n-    // `FromEnv(Self: Trait<P1..Pn>)`\n-    let from_env = Goal::from(DomainGoal::FromEnv(trait_pred.lower()));\n+\n     // `Implemented(Self: Trait<P1..Pn>)`\n-    let impl_trait = DomainGoal::Holds(WhereClauseAtom::Implemented(trait_pred));\n+    let impl_trait: DomainGoal = trait_pred.lower();\n+\n+     // `FromEnv(Self: Trait<P1..Pn>)`\n+    let from_env = impl_trait.into_from_env_goal().into_goal();\n \n     // `Implemented(Self: Trait<P1..Pn>) :- FromEnv(Self: Trait<P1..Pn>)`\n+    let hypotheses = tcx.intern_goals(&[from_env]);\n     let implemented_from_env = ProgramClause {\n         goal: impl_trait,\n-        hypotheses: tcx.intern_goals(&[from_env]),\n+        hypotheses,\n     };\n+\n     let clauses = iter::once(Clause::ForAll(ty::Binder::dummy(implemented_from_env)));\n \n     // Rule Implied-Bound-From-Trait\n@@ -239,25 +250,17 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     let where_clauses = &tcx.predicates_of(def_id).predicates;\n     let implied_bound_clauses = where_clauses[1..]\n         .into_iter()\n-        .map(|wc| implied_bound_from_trait(tcx, trait_pred, wc));\n+        .map(|wc| wc.lower())\n \n-    tcx.mk_clauses(clauses.chain(implied_bound_clauses))\n-}\n+        // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`\n+        .map(|wc| wc.map_bound(|goal| ProgramClause {\n+            goal: goal.into_from_env_goal(),\n+            hypotheses,\n+        }))\n \n-/// For a given `where_clause`, returns a clause `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`.\n-fn implied_bound_from_trait<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    trait_pred: ty::TraitPredicate<'tcx>,\n-    where_clause: &ty::Predicate<'tcx>,\n-) -> Clause<'tcx> {\n-    // `FromEnv(Self: Trait<P1..Pn>)`\n-    let impl_trait = DomainGoal::FromEnv(WhereClauseAtom::Implemented(trait_pred));\n-\n-    // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`\n-    Clause::ForAll(where_clause.lower().map_bound(|goal| ProgramClause {\n-        goal: goal.into_from_env_goal(),\n-        hypotheses: tcx.intern_goals(&[Goal::from(impl_trait)]),\n-    }))\n+        .map(Clause::ForAll);\n+\n+    tcx.mk_clauses(clauses.chain(implied_bound_clauses))\n }\n \n fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n@@ -275,9 +278,11 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     // }\n     // ```\n \n-    let trait_ref = tcx.impl_trait_ref(def_id).unwrap();\n+    let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+\n     // `Implemented(A0: Trait<A1..An>)`\n     let trait_pred = ty::TraitPredicate { trait_ref }.lower();\n+\n     // `WC`\n     let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n \n@@ -301,45 +306,48 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     //\n     // ```impl<P0..Pn> Trait<A1..An> for A0\n     // {\n-    //     type AssocType<Pn+1..Pm> where WC = T;\n+    //     type AssocType<Pn+1..Pm> = T;\n     // }```\n     //\n     // ```\n     // forall<P0..Pm> {\n     //   forall<Pn+1..Pm> {\n     //     Normalize(<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm> -> T) :-\n-    //       Implemented(A0: Trait<A1..An>) && WC\n+    //       Implemented(A0: Trait<A1..An>)\n     //   }\n     // }\n     // ```\n \n     let item = tcx.associated_item(item_id);\n     debug_assert_eq!(item.kind, ty::AssociatedKind::Type);\n-    let impl_id = if let ty::AssociatedItemContainer::ImplContainer(impl_id) = item.container {\n-        impl_id\n-    } else {\n-        bug!()\n+    let impl_id = match item.container {\n+        ty::AssociatedItemContainer::ImplContainer(impl_id) => impl_id,\n+        _ => bug!(\"not an impl container\"),\n     };\n+    \n     // `A0 as Trait<A1..An>`\n     let trait_ref = tcx.impl_trait_ref(impl_id).unwrap();\n+\n     // `T`\n     let ty = tcx.type_of(item_id);\n+\n     // `Implemented(A0: Trait<A1..An>)`\n     let trait_implemented = ty::Binder::dummy(ty::TraitPredicate { trait_ref }.lower());\n-    // `WC`\n-    let item_where_clauses = tcx.predicates_of(item_id).predicates.lower();\n-    // `Implemented(A0: Trait<A1..An>) && WC`\n-    let mut where_clauses = vec![trait_implemented];\n-    where_clauses.extend(item_where_clauses);\n+\n+    // `Implemented(A0: Trait<A1..An>)`\n+    let hypotheses = vec![trait_implemented];\n+\n     // `<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm>`\n     let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.name);\n+\n     // `Normalize(<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm> -> T)`\n     let normalize_goal = DomainGoal::Normalize(ty::ProjectionPredicate { projection_ty, ty });\n+\n     // `Normalize(... -> T) :- ...`\n     let clause = ProgramClause {\n         goal: normalize_goal,\n         hypotheses: tcx.mk_goals(\n-            where_clauses\n+            hypotheses\n                 .into_iter()\n                 .map(|wc| Goal::from_poly_domain_goal(wc, tcx)),\n         ),"}]}