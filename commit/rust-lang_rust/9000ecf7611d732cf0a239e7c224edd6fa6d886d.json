{"sha": "9000ecf7611d732cf0a239e7c224edd6fa6d886d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMDBlY2Y3NjExZDczMmNmMGEyMzllN2MyMjRlZGQ2ZmE2ZDg4NmQ=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2015-12-19T01:29:03Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2015-12-28T23:17:53Z"}, "message": "Rewrite MIR graphviz printing and improve MIR debug printing.", "tree": {"sha": "76cdc01e688fd3efc3c52624f3fa273a7701a9d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76cdc01e688fd3efc3c52624f3fa273a7701a9d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9000ecf7611d732cf0a239e7c224edd6fa6d886d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9000ecf7611d732cf0a239e7c224edd6fa6d886d", "html_url": "https://github.com/rust-lang/rust/commit/9000ecf7611d732cf0a239e7c224edd6fa6d886d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9000ecf7611d732cf0a239e7c224edd6fa6d886d/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27a1834ce522e3ec7fe4726b1661de16ee30c503", "url": "https://api.github.com/repos/rust-lang/rust/commits/27a1834ce522e3ec7fe4726b1661de16ee30c503", "html_url": "https://github.com/rust-lang/rust/commit/27a1834ce522e3ec7fe4726b1661de16ee30c503"}], "stats": {"total": 436, "additions": 236, "deletions": 200}, "files": [{"sha": "e0893476770fbd54d158f0efbe64a18ecfbf5ced", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 112, "deletions": 31, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9000ecf7611d732cf0a239e7c224edd6fa6d886d/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9000ecf7611d732cf0a239e7c224edd6fa6d886d/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=9000ecf7611d732cf0a239e7c224edd6fa6d886d", "patch": "@@ -11,14 +11,15 @@\n use middle::const_eval::ConstVal;\n use middle::def_id::DefId;\n use middle::subst::Substs;\n-use middle::ty::{AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n+use middle::ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n use rustc_back::slice;\n use rustc_data_structures::tuple_slice::TupleSlice;\n use rustc_front::hir::InlineAsm;\n use syntax::ast::Name;\n use syntax::codemap::Span;\n-use std::fmt::{Debug, Formatter, Error};\n-use std::u32;\n+use std::borrow::{Cow, IntoCow};\n+use std::fmt::{Debug, Formatter, Error, Write};\n+use std::{iter, u32};\n \n /// Lowered representation of a single function.\n #[derive(RustcEncodable, RustcDecodable)]\n@@ -317,31 +318,77 @@ impl<'tcx> BasicBlockData<'tcx> {\n \n impl<'tcx> Debug for Terminator<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        try!(self.fmt_head(fmt));\n+        let successors = self.successors();\n+        let labels = self.fmt_successor_labels();\n+        assert_eq!(successors.len(), labels.len());\n+\n+        match successors.len() {\n+            0 => Ok(()),\n+\n+            1 => write!(fmt, \" -> {:?}\", successors[0]),\n+\n+            _ => {\n+                try!(write!(fmt, \" -> [\"));\n+                for (i, target) in successors.iter().enumerate() {\n+                    if i > 0 {\n+                        try!(write!(fmt, \", \"));\n+                    }\n+                    try!(write!(fmt, \"{}: {:?}\", labels[i], target));\n+                }\n+                write!(fmt, \"]\")\n+            }\n+\n+        }\n+    }\n+}\n+\n+impl<'tcx> Terminator<'tcx> {\n+    pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> Result<(), Error> {\n         use self::Terminator::*;\n         match *self {\n-            Goto { target } =>\n-                write!(fmt, \"goto -> {:?}\", target),\n-            Panic { target } =>\n-                write!(fmt, \"panic -> {:?}\", target),\n-            If { cond: ref lv, ref targets } =>\n-                write!(fmt, \"if({:?}) -> {:?}\", lv, targets),\n-            Switch { discr: ref lv, adt_def: _, ref targets } =>\n-                write!(fmt, \"switch({:?}) -> {:?}\", lv, targets),\n-            SwitchInt { discr: ref lv, switch_ty: _, ref values, ref targets } =>\n-                write!(fmt, \"switchInt({:?}, {:?}) -> {:?}\", lv, values, targets),\n-            Diverge =>\n-                write!(fmt, \"diverge\"),\n-            Return =>\n-                write!(fmt, \"return\"),\n-            Call { data: ref c, targets } => {\n+            Goto { .. } => write!(fmt, \"goto\"),\n+            Panic { .. } => write!(fmt, \"panic\"),\n+            If { cond: ref lv, .. } => write!(fmt, \"if({:?})\", lv),\n+            Switch { discr: ref lv, .. } => write!(fmt, \"switch({:?})\", lv),\n+            SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n+            Diverge => write!(fmt, \"diverge\"),\n+            Return => write!(fmt, \"return\"),\n+            Call { data: ref c, .. } => {\n                 try!(write!(fmt, \"{:?} = {:?}(\", c.destination, c.func));\n                 for (index, arg) in c.args.iter().enumerate() {\n                     if index > 0 {\n                         try!(write!(fmt, \", \"));\n                     }\n                     try!(write!(fmt, \"{:?}\", arg));\n                 }\n-                write!(fmt, \") -> {:?}\", targets)\n+                write!(fmt, \")\")\n+            }\n+        }\n+    }\n+\n+    pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n+        use self::Terminator::*;\n+        match *self {\n+            Diverge | Return => vec![],\n+            Goto { .. } | Panic { .. } => vec![\"\".into_cow()],\n+            If { .. } => vec![\"true\".into_cow(), \"false\".into_cow()],\n+            Call { .. } => vec![\"return\".into_cow(), \"unwind\".into_cow()],\n+            Switch { ref adt_def, .. } => {\n+                adt_def.variants\n+                       .iter()\n+                       .map(|variant| variant.name.to_string().into_cow())\n+                       .collect()\n+            }\n+            SwitchInt { ref values, .. } => {\n+                values.iter()\n+                      .map(|const_val| {\n+                          let mut buf = String::new();\n+                          fmt_const_val(&mut buf, const_val).unwrap();\n+                          buf.into_cow()\n+                      })\n+                      .chain(iter::once(String::from(\"otherwise\").into_cow()))\n+                      .collect()\n             }\n         }\n     }\n@@ -495,19 +542,19 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n \n         match *self {\n             Var(id) =>\n-                write!(fmt,\"Var({:?})\", id),\n+                write!(fmt,\"v{:?}\", id),\n             Arg(id) =>\n-                write!(fmt,\"Arg({:?})\", id),\n+                write!(fmt,\"a{:?}\", id),\n             Temp(id) =>\n-                write!(fmt,\"Temp({:?})\", id),\n+                write!(fmt,\"t{:?}\", id),\n             Static(id) =>\n                 write!(fmt,\"Static({:?})\", id),\n             ReturnPointer =>\n                 write!(fmt,\"ReturnPointer\"),\n             Projection(ref data) =>\n                 match data.elem {\n-                    ProjectionElem::Downcast(_, variant_index) =>\n-                        write!(fmt,\"({:?} as {:?})\", data.base, variant_index),\n+                    ProjectionElem::Downcast(ref adt_def, index) =>\n+                        write!(fmt,\"({:?} as {})\", data.base, adt_def.variants[index].name),\n                     ProjectionElem::Deref =>\n                         write!(fmt,\"(*{:?})\", data.base),\n                     ProjectionElem::Field(field) =>\n@@ -671,12 +718,12 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             Use(ref lvalue) => write!(fmt, \"{:?}\", lvalue),\n             Repeat(ref a, ref b) => write!(fmt, \"[{:?}; {:?}]\", a, b),\n             Ref(ref a, bk, ref b) => write!(fmt, \"&{:?} {:?} {:?}\", a, bk, b),\n-            Len(ref a) => write!(fmt, \"LEN({:?})\", a),\n-            Cast(ref kind, ref lv, ref ty) => write!(fmt, \"{:?} as {:?} ({:?}\", lv, ty, kind),\n-            BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?},{:?})\", op, a, b),\n+            Len(ref a) => write!(fmt, \"Len({:?})\", a),\n+            Cast(ref kind, ref lv, ref ty) => write!(fmt, \"{:?} as {:?} ({:?})\", lv, ty, kind),\n+            BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?}, {:?})\", op, a, b),\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n-            Box(ref t) => write!(fmt, \"Box {:?}\", t),\n-            Aggregate(ref kind, ref lvs) => write!(fmt, \"Aggregate<{:?}>({:?})\", kind, lvs),\n+            Box(ref t) => write!(fmt, \"Box({:?})\", t),\n+            Aggregate(ref kind, ref lvs) => write!(fmt, \"Aggregate<{:?}>{:?}\", kind, lvs),\n             InlineAsm(ref asm) => write!(fmt, \"InlineAsm({:?})\", asm),\n             Slice { ref input, from_start, from_end } =>\n                 write!(fmt, \"{:?}[{:?}..-{:?}]\", input, from_start, from_end),\n@@ -691,7 +738,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n // this does not necessarily mean that they are \"==\" in Rust -- in\n // particular one must be wary of `NaN`!\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n@@ -707,7 +754,7 @@ pub enum ItemKind {\n     Method,\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n         def_id: DefId,\n@@ -718,3 +765,37 @@ pub enum Literal<'tcx> {\n         value: ConstVal,\n     },\n }\n+\n+impl<'tcx> Debug for Constant<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        write!(fmt, \"{:?}\", self.literal)\n+    }\n+}\n+\n+impl<'tcx> Debug for Literal<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        use self::Literal::*;\n+        match *self {\n+            Item { def_id, .. } =>\n+                write!(fmt, \"{}\", ty::tls::with(|tcx| tcx.item_path_str(def_id))),\n+            Value { ref value } => fmt_const_val(fmt, value),\n+        }\n+    }\n+}\n+\n+pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> Result<(), Error> {\n+    use middle::const_eval::ConstVal::*;\n+    match *const_val {\n+        Float(f) => write!(fmt, \"{:?}\", f),\n+        Int(n) => write!(fmt, \"{:?}\", n),\n+        Uint(n) => write!(fmt, \"{:?}\", n),\n+        Str(ref s) => write!(fmt, \"Str({:?})\", s),\n+        ByteStr(ref bytes) => write!(fmt, \"ByteStr{:?}\", bytes),\n+        Bool(b) => write!(fmt, \"{:?}\", b),\n+        Struct(id) => write!(fmt, \"Struct({:?})\", id),\n+        Tuple(id) => write!(fmt, \"Tuple({:?})\", id),\n+        Function(def_id) => write!(fmt, \"Function({:?})\", def_id),\n+        Array(id, n) => write!(fmt, \"Array({:?}, {:?})\", id, n),\n+        Repeat(id, n) => write!(fmt, \"Repeat({:?}, {:?})\", id, n),\n+    }\n+}"}, {"sha": "bf477d910f7f7f7cf4f6274aded8046d70bf93af", "filename": "src/librustc_mir/graphviz.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9000ecf7611d732cf0a239e7c224edd6fa6d886d/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9000ecf7611d732cf0a239e7c224edd6fa6d886d/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=9000ecf7611d732cf0a239e7c224edd6fa6d886d", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dot;\n+use rustc::mir::repr::*;\n+use rustc::middle::ty;\n+use std::io::{self, Write};\n+\n+pub fn write_mir_graphviz<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n+    try!(writeln!(w, \"digraph Mir {{\"));\n+\n+    // Global graph properties\n+    try!(writeln!(w, r#\"graph [fontname=\"monospace\"];\"#));\n+    try!(writeln!(w, r#\"node [fontname=\"monospace\"];\"#));\n+    try!(writeln!(w, r#\"edge [fontname=\"monospace\"];\"#));\n+\n+    // Graph label\n+    try!(write_graph_label(mir, w));\n+\n+    // Nodes\n+    for block in mir.all_basic_blocks() {\n+        try!(write_node(block, mir, w));\n+    }\n+\n+    // Edges\n+    for source in mir.all_basic_blocks() {\n+        try!(write_edges(source, mir, w));\n+    }\n+\n+    writeln!(w, \"}}\")\n+}\n+\n+fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+    let data = mir.basic_block_data(block);\n+\n+    try!(write!(w, r#\"bb{} [shape=\"none\", label=<\"#, block.index()));\n+    try!(write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#));\n+\n+    try!(write!(w, r#\"<tr><td bgcolor=\"gray\" align=\"center\">\"#));\n+    try!(write!(w, \"{}\", block.index()));\n+    try!(write!(w, \"</td></tr>\"));\n+\n+    if !data.statements.is_empty() {\n+        try!(write!(w, r#\"<tr><td align=\"left\" balign=\"left\">\"#));\n+        for statement in &data.statements {\n+            try!(write!(w, \"{}\", dot::escape_html(&format!(\"{:?}\", statement))));\n+            try!(write!(w, \"<br/>\"));\n+        }\n+        try!(write!(w, \"</td></tr>\"));\n+    }\n+\n+    try!(write!(w, r#\"<tr><td align=\"left\">\"#));\n+\n+    let mut terminator_head = String::new();\n+    data.terminator.fmt_head(&mut terminator_head).unwrap();\n+    try!(write!(w, \"{}\", dot::escape_html(&terminator_head)));\n+    try!(write!(w, \"</td></tr>\"));\n+\n+    try!(write!(w, \"</table>\"));\n+    writeln!(w, \">];\")\n+}\n+\n+fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+    let terminator = &mir.basic_block_data(source).terminator;\n+    let labels = terminator.fmt_successor_labels();\n+\n+    for (i, target) in terminator.successors().into_iter().enumerate() {\n+        try!(write!(w, \"bb{} -> bb{}\", source.index(), target.index()));\n+        try!(writeln!(w, r#\" [label=\"{}\"];\"#, labels[i]));\n+    }\n+\n+    Ok(())\n+}\n+\n+fn write_graph_label<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n+    try!(write!(w, \"label=<\"));\n+    try!(write!(w, \"fn(\"));\n+\n+    for (i, arg) in mir.arg_decls.iter().enumerate() {\n+        if i > 0 {\n+            try!(write!(w, \", \"));\n+        }\n+        try!(write!(w, \"{}\", dot::escape_html(&format!(\"a{}: {:?}\", i, arg.ty))));\n+    }\n+\n+    try!(write!(w, \"{}\", dot::escape_html(\") -> \")));\n+\n+    match mir.return_ty {\n+        ty::FnOutput::FnConverging(ty) =>\n+            try!(write!(w, \"{}\", dot::escape_html(&format!(\"{:?}\", ty)))),\n+        ty::FnOutput::FnDiverging =>\n+            try!(write!(w, \"{}\", dot::escape_html(\"!\"))),\n+    }\n+\n+    try!(write!(w, r#\"<br align=\"left\"/>\"#));\n+\n+    for (i, var) in mir.var_decls.iter().enumerate() {\n+        try!(write!(w, \"let \"));\n+        if var.mutability == Mutability::Mut {\n+            try!(write!(w, \"mut \"));\n+        }\n+        let text = format!(\"v{}: {:?}; // {}\", i, var.ty, var.name);\n+        try!(write!(w, \"{}\", dot::escape_html(&text)));\n+        try!(write!(w, r#\"<br align=\"left\"/>\"#));\n+    }\n+\n+    for (i, temp) in mir.temp_decls.iter().enumerate() {\n+        try!(write!(w, \"{}\", dot::escape_html(&format!(\"let t{}: {:?};\", i, temp.ty))));\n+        try!(write!(w, r#\"<br align=\"left\"/>\"#));\n+    }\n+\n+    writeln!(w, \">;\")\n+}"}, {"sha": "d5da606d76e80906f8b71efc0ebf5eb93c553c60", "filename": "src/librustc_mir/graphviz/mod.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/27a1834ce522e3ec7fe4726b1661de16ee30c503/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27a1834ce522e3ec7fe4726b1661de16ee30c503/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs?ref=27a1834ce522e3ec7fe4726b1661de16ee30c503", "patch": "@@ -1,166 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use dot;\n-use rustc::mir::repr::*;\n-use std::borrow::IntoCow;\n-\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub struct EdgeIndex {\n-    source: BasicBlock,\n-    target: BasicBlock,\n-    index: usize,\n-}\n-\n-impl<'a,'tcx> dot::Labeller<'a, BasicBlock, EdgeIndex> for Mir<'tcx> {\n-    fn graph_id(&'a self) -> dot::Id<'a> {\n-        dot::Id::new(\"Mir\").unwrap()\n-    }\n-\n-    fn node_id(&'a self, n: &BasicBlock) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"BB{}\", n.index())).unwrap()\n-    }\n-\n-    fn node_shape(&'a self, _: &BasicBlock) -> Option<dot::LabelText<'a>> {\n-        Some(dot::LabelText::label(\"none\"))\n-    }\n-\n-    fn node_label(&'a self, &n: &BasicBlock) -> dot::LabelText<'a> {\n-        let mut buffer = String::new();\n-        buffer.push_str(\"<table border=\\\"0\\\" cellborder=\\\"1\\\" cellspacing=\\\"0\\\">\");\n-\n-        buffer.push_str(\"<tr><td><b>\");\n-        buffer.push_str(&escape(format!(\"{:?}\", n)));\n-        buffer.push_str(\"</b></td></tr>\");\n-\n-        let data = self.basic_block_data(n);\n-        for statement in &data.statements {\n-            buffer.push_str(\"<tr><td align=\\\"left\\\">\");\n-            buffer.push_str(&escape(format!(\"{:?}\", statement)));\n-            buffer.push_str(\"</td></tr>\");\n-        }\n-\n-        buffer.push_str(\"<tr><td align=\\\"left\\\" bgcolor=\\\"cornsilk\\\">\");\n-        buffer.push_str(&escape(format!(\"{:?}\", &data.terminator)));\n-        buffer.push_str(\"</td></tr>\");\n-\n-        buffer.push_str(\"</table>\");\n-\n-        dot::LabelText::html(buffer)\n-    }\n-\n-    fn edge_label(&'a self, edge: &EdgeIndex) -> dot::LabelText<'a> {\n-        dot::LabelText::label(format!(\"{}\", edge.index))\n-    }\n-}\n-\n-impl<'a,'tcx> dot::GraphWalk<'a, BasicBlock, EdgeIndex> for Mir<'tcx> {\n-    fn nodes(&'a self) -> dot::Nodes<'a, BasicBlock> {\n-        self.all_basic_blocks().into_cow()\n-    }\n-\n-    fn edges(&'a self) -> dot::Edges<'a, EdgeIndex> {\n-        self.all_basic_blocks()\n-            .into_iter()\n-            .flat_map(|source| {\n-                self.basic_block_data(source)\n-                    .terminator\n-                    .successors()\n-                    .iter()\n-                    .enumerate()\n-                    .map(move |(index, &target)| {\n-                        EdgeIndex {\n-                            source: source,\n-                            target: target,\n-                            index: index,\n-                        }\n-                    })\n-            })\n-            .collect::<Vec<_>>()\n-            .into_cow()\n-    }\n-\n-    fn source(&'a self, edge: &EdgeIndex) -> BasicBlock {\n-        edge.source\n-    }\n-\n-    fn target(&'a self, edge: &EdgeIndex) -> BasicBlock {\n-        edge.target\n-    }\n-}\n-\n-fn escape(text: String) -> String {\n-    let text = dot::escape_html(&text);\n-    let text = all_to_subscript(\"Temp\", text);\n-    let text = all_to_subscript(\"Var\", text);\n-    let text = all_to_subscript(\"Arg\", text);\n-    let text = all_to_subscript(\"BB\", text);\n-    text\n-}\n-\n-/// A call like `all_to_subscript(\"Temp\", \"Temp(123)\")` will convert\n-/// to `Temp\u2081\u2082\u2083`.\n-fn all_to_subscript(header: &str, mut text: String) -> String {\n-    let mut offset = 0;\n-    while offset < text.len() {\n-        if let Some(text1) = to_subscript1(header, &text, &mut offset) {\n-            text = text1;\n-        }\n-    }\n-    return text;\n-\n-    /// Looks for `Foo(\\d*)` where `header==\"Foo\"` and replaces the `\\d` with subscripts.\n-    /// Updates `offset` to point to the next location where we might want to search.\n-    /// Returns an updated string if changes were made, else None.\n-    fn to_subscript1(header: &str, text: &str, offset: &mut usize) -> Option<String> {\n-        let a = match text[*offset..].find(header) {\n-            None => {\n-                *offset = text.len();\n-                return None;\n-            }\n-            Some(a) => a + *offset,\n-        };\n-\n-        // Example:\n-        //\n-        // header: \"Foo\"\n-        // text:   ....Foo(123)...\n-        //             ^  ^\n-        //             a  b\n-\n-        let b = a + header.len();\n-        *offset = b;\n-\n-        let mut chars = text[b..].chars();\n-        if Some('(') != chars.next() {\n-            return None;\n-        }\n-\n-        let mut result = String::new();\n-        result.push_str(&text[..b]);\n-\n-        while let Some(c) = chars.next() {\n-            if c == ')' {\n-                break;\n-            }\n-            if !c.is_digit(10) {\n-                return None;\n-            }\n-\n-            // 0x208 is _0 in unicode, 0x209 is _1, etc\n-            const SUBSCRIPTS: &'static str = \"\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\";\n-            let n = (c as usize) - ('0' as usize);\n-            result.extend(SUBSCRIPTS.chars().skip(n).take(1));\n-        }\n-\n-        result.extend(chars);\n-        return Some(result);\n-    }\n-}"}, {"sha": "6a1134385d96725764047a09ef1896d453e86584", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9000ecf7611d732cf0a239e7c224edd6fa6d886d/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9000ecf7611d732cf0a239e7c224edd6fa6d886d/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=9000ecf7611d732cf0a239e7c224edd6fa6d886d", "patch": "@@ -19,7 +19,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![crate_type = \"dylib\"]\n \n #![feature(rustc_private)]\n-#![feature(into_cow)]\n \n #[macro_use] extern crate log;\n extern crate graphviz as dot;"}, {"sha": "5c9399ebdadf7ff5128bad01f3d414ca5cfa9417", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9000ecf7611d732cf0a239e7c224edd6fa6d886d/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9000ecf7611d732cf0a239e7c224edd6fa6d886d/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=9000ecf7611d732cf0a239e7c224edd6fa6d886d", "patch": "@@ -21,7 +21,7 @@ extern crate rustc;\n extern crate rustc_front;\n \n use build;\n-use dot;\n+use graphviz;\n use transform::*;\n use rustc::mir::repr::Mir;\n use hair::cx::Cx;\n@@ -157,7 +157,9 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n                             Some(s) => {\n                                 match\n                                     File::create(format!(\"{}{}\", prefix, s))\n-                                    .and_then(|ref mut output| dot::render(&mir, output))\n+                                    .and_then(|ref mut output| {\n+                                        graphviz::write_mir_graphviz(&mir, output)\n+                                    })\n                                 {\n                                     Ok(()) => { }\n                                     Err(e) => {"}]}