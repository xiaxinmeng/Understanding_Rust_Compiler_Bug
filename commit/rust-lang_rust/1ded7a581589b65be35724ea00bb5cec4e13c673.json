{"sha": "1ded7a581589b65be35724ea00bb5cec4e13c673", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZWQ3YTU4MTU4OWI2NWJlMzU3MjRlYTAwYmI1Y2VjNGUxM2M2NzM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-06-29T13:55:28Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-07-01T16:42:31Z"}, "message": "Handle `None`-delimited groups when parsing `macro_rules!` macro\n\nWhen a `macro_rules!` macro expands to another `macro_rules!` macro, we\nmay see `None`-delimited groups in odd places when another crate\ndeserializes the 'inner' macro. This commit 'unwraps' an outer\n`None`-delimited group to avoid breaking existing code.\n\nSee https://github.com/rust-lang/rust/pull/73569#issuecomment-650860457\nfor more details.\n\nThe proper fix is to handle `None`-delimited groups systematically\nthroughout the parser, but that will require significant work. In the\nmeantime, this hack lets us fix important hygiene bugs in macros", "tree": {"sha": "8038e5240492ac2759a5718b8f6ac2364b83efb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8038e5240492ac2759a5718b8f6ac2364b83efb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ded7a581589b65be35724ea00bb5cec4e13c673", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl78vPcACgkQtAh+UQ6Y\nsWT8+w//cpyMnl7Yf1CiFmuXgpowXFtwnEExL8g7QqNPjphLB2uvjlnpsQD8u/w/\nFPyynWq9j+r96hTKVi3UJbGJzShbbnInBJ+YNpnVRwZycn/XBEaq6dyq/Cjl/wzF\nvwSWqSjRaCdbOSglFhtrf94Ix8hNETbgXSwSvJHjUA84CUXdBI4O0HNFbI48pPb9\nIbiHl0128ZdB0bI61/thRHA5ndapiKo7y+0iPRMFwefyGjO0nyfjkIwAqZesOkZC\n8c+6FxvheGLvwr0lf5qhrrNSNYVlTsRxb7Jswl8nqOScjkqqy6o6UocgynKqqb+A\nwbA6+aCeK5vkeq6yhkxKKYAmcHZAlfHArIfM4UYQNaA0ARhZbMkTqQZUmcFmh8Xc\nRMHjvag5ndIHjhZMD16MzEH5MmjEGBQxSi+hkxFg5fO3lzJJ6nRSDtWthwwcsU35\nC9+dOX2cedq4JpdJokmTxaG+1roOcsyMcK9UonhNO9+8eFNVIul1HA8LKEd3H0rO\nEX2geiMs2ElZXdaBjb/eXF2FfRsPMOyv4NGTQKb5m+Ze1AdouH/4tzcVRyhXjcSZ\nE3cWkbFXxxnF11OjTb4WPeEIXYV7cI9q8IFZYHzAfjEHrxp4cFiUH380SaPp9QhK\nJ3Gppr1fSgDsplpHmRPu1XN1kBD2NuYakZxXN1WKRtscUwPUgwo=\n=E1DP\n-----END PGP SIGNATURE-----", "payload": "tree 8038e5240492ac2759a5718b8f6ac2364b83efb5\nparent c84402872ec9ced6f5ba16b48c4f45fef96ad591\nauthor Aaron Hill <aa1ronham@gmail.com> 1593438928 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1593621751 -0400\n\nHandle `None`-delimited groups when parsing `macro_rules!` macro\n\nWhen a `macro_rules!` macro expands to another `macro_rules!` macro, we\nmay see `None`-delimited groups in odd places when another crate\ndeserializes the 'inner' macro. This commit 'unwraps' an outer\n`None`-delimited group to avoid breaking existing code.\n\nSee https://github.com/rust-lang/rust/pull/73569#issuecomment-650860457\nfor more details.\n\nThe proper fix is to handle `None`-delimited groups systematically\nthroughout the parser, but that will require significant work. In the\nmeantime, this hack lets us fix important hygiene bugs in macros\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ded7a581589b65be35724ea00bb5cec4e13c673", "html_url": "https://github.com/rust-lang/rust/commit/1ded7a581589b65be35724ea00bb5cec4e13c673", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ded7a581589b65be35724ea00bb5cec4e13c673/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c84402872ec9ced6f5ba16b48c4f45fef96ad591", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84402872ec9ced6f5ba16b48c4f45fef96ad591", "html_url": "https://github.com/rust-lang/rust/commit/c84402872ec9ced6f5ba16b48c4f45fef96ad591"}], "stats": {"total": 134, "additions": 87, "deletions": 47}, "files": [{"sha": "09306f26ee0adb76436b0781ca37b6551e6cc9c7", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 63, "deletions": 47, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/1ded7a581589b65be35724ea00bb5cec4e13c673/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ded7a581589b65be35724ea00bb5cec4e13c673/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=1ded7a581589b65be35724ea00bb5cec4e13c673", "patch": "@@ -90,72 +90,88 @@ pub(super) fn parse(\n /// # Parameters\n ///\n /// - `tree`: the tree we wish to convert.\n-/// - `trees`: an iterator over trees. We may need to read more tokens from it in order to finish\n+/// - `outer_trees`: an iterator over trees. We may need to read more tokens from it in order to finish\n ///   converting `tree`\n /// - `expect_matchers`: same as for `parse` (see above).\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n ///   unstable features or not.\n fn parse_tree(\n     tree: tokenstream::TokenTree,\n-    trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n+    outer_trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n         // `tree` is a `$` token. Look at the next token in `trees`\n-        tokenstream::TokenTree::Token(Token { kind: token::Dollar, span }) => match trees.next() {\n-            // `tree` is followed by a delimited set of token trees. This indicates the beginning\n-            // of a repetition sequence in the macro (e.g. `$(pat)*`).\n-            Some(tokenstream::TokenTree::Delimited(span, delim, tts)) => {\n-                // Must have `(` not `{` or `[`\n-                if delim != token::Paren {\n-                    let tok = pprust::token_kind_to_string(&token::OpenDelim(delim));\n-                    let msg = format!(\"expected `(`, found `{}`\", tok);\n-                    sess.span_diagnostic.span_err(span.entire(), &msg);\n-                }\n-                // Parse the contents of the sequence itself\n-                let sequence = parse(tts, expect_matchers, sess, node_id);\n-                // Get the Kleene operator and optional separator\n-                let (separator, kleene) = parse_sep_and_kleene_op(trees, span.entire(), sess);\n-                // Count the number of captured \"names\" (i.e., named metavars)\n-                let name_captures = macro_parser::count_names(&sequence);\n-                TokenTree::Sequence(\n-                    span,\n-                    Lrc::new(SequenceRepetition {\n-                        tts: sequence,\n-                        separator,\n-                        kleene,\n-                        num_captures: name_captures,\n-                    }),\n-                )\n+        tokenstream::TokenTree::Token(Token { kind: token::Dollar, span }) => {\n+            // FIXME: Handle `None`-delimited groups in a more systematic way\n+            // during parsing.\n+            let mut next = outer_trees.next();\n+            let mut trees: Box<dyn Iterator<Item = tokenstream::TokenTree>>;\n+            if let Some(tokenstream::TokenTree::Delimited(_, token::NoDelim, tts)) = next {\n+                trees = Box::new(tts.into_trees());\n+                next = trees.next();\n+            } else {\n+                trees = Box::new(outer_trees);\n             }\n \n-            // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate` special\n-            // metavariable that names the crate of the invocation.\n-            Some(tokenstream::TokenTree::Token(token)) if token.is_ident() => {\n-                let (ident, is_raw) = token.ident().unwrap();\n-                let span = ident.span.with_lo(span.lo());\n-                if ident.name == kw::Crate && !is_raw {\n-                    TokenTree::token(token::Ident(kw::DollarCrate, is_raw), span)\n-                } else {\n-                    TokenTree::MetaVar(span, ident)\n+            match next {\n+                // `tree` is followed by a delimited set of token trees. This indicates the beginning\n+                // of a repetition sequence in the macro (e.g. `$(pat)*`).\n+                Some(tokenstream::TokenTree::Delimited(span, delim, tts)) => {\n+                    // Must have `(` not `{` or `[`\n+                    if delim != token::Paren {\n+                        let tok = pprust::token_kind_to_string(&token::OpenDelim(delim));\n+                        let msg = format!(\"expected `(`, found `{}`\", tok);\n+                        sess.span_diagnostic.span_err(span.entire(), &msg);\n+                    }\n+                    // Parse the contents of the sequence itself\n+                    let sequence = parse(tts, expect_matchers, sess, node_id);\n+                    // Get the Kleene operator and optional separator\n+                    let (separator, kleene) =\n+                        parse_sep_and_kleene_op(&mut trees, span.entire(), sess);\n+                    // Count the number of captured \"names\" (i.e., named metavars)\n+                    let name_captures = macro_parser::count_names(&sequence);\n+                    TokenTree::Sequence(\n+                        span,\n+                        Lrc::new(SequenceRepetition {\n+                            tts: sequence,\n+                            separator,\n+                            kleene,\n+                            num_captures: name_captures,\n+                        }),\n+                    )\n                 }\n-            }\n \n-            // `tree` is followed by a random token. This is an error.\n-            Some(tokenstream::TokenTree::Token(token)) => {\n-                let msg =\n-                    format!(\"expected identifier, found `{}`\", pprust::token_to_string(&token),);\n-                sess.span_diagnostic.span_err(token.span, &msg);\n-                TokenTree::MetaVar(token.span, Ident::invalid())\n-            }\n+                // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate` special\n+                // metavariable that names the crate of the invocation.\n+                Some(tokenstream::TokenTree::Token(token)) if token.is_ident() => {\n+                    let (ident, is_raw) = token.ident().unwrap();\n+                    let span = ident.span.with_lo(span.lo());\n+                    if ident.name == kw::Crate && !is_raw {\n+                        TokenTree::token(token::Ident(kw::DollarCrate, is_raw), span)\n+                    } else {\n+                        TokenTree::MetaVar(span, ident)\n+                    }\n+                }\n \n-            // There are no more tokens. Just return the `$` we already have.\n-            None => TokenTree::token(token::Dollar, span),\n-        },\n+                // `tree` is followed by a random token. This is an error.\n+                Some(tokenstream::TokenTree::Token(token)) => {\n+                    let msg = format!(\n+                        \"expected identifier, found `{}`\",\n+                        pprust::token_to_string(&token),\n+                    );\n+                    sess.span_diagnostic.span_err(token.span, &msg);\n+                    TokenTree::MetaVar(token.span, Ident::invalid())\n+                }\n+\n+                // There are no more tokens. Just return the `$` we already have.\n+                None => TokenTree::token(token::Dollar, span),\n+            }\n+        }\n \n         // `tree` is an arbitrary token. Keep it.\n         tokenstream::TokenTree::Token(token) => TokenTree::Token(token),"}, {"sha": "54e3d7857267b9efdf23520444b8c6bfe31fa068", "filename": "src/test/ui/proc-macro/auxiliary/meta-delim.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ded7a581589b65be35724ea00bb5cec4e13c673/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmeta-delim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ded7a581589b65be35724ea00bb5cec4e13c673/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmeta-delim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmeta-delim.rs?ref=1ded7a581589b65be35724ea00bb5cec4e13c673", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! produce_it {\n+    ($dollar_one:tt $foo:ident $my_name:ident) => {\n+        #[macro_export]\n+        macro_rules! meta_delim {\n+            ($dollar_one ($dollar_one $my_name:ident)*) => {\n+                stringify!($dollar_one ($dollar_one $my_name)*)\n+            }\n+        }\n+    }\n+}\n+\n+produce_it!($my_name name);"}, {"sha": "964291bc6784c822c095502aa87ad0e916ef2563", "filename": "src/test/ui/proc-macro/meta-delim.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ded7a581589b65be35724ea00bb5cec4e13c673/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-delim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ded7a581589b65be35724ea00bb5cec4e13c673/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-delim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-delim.rs?ref=1ded7a581589b65be35724ea00bb5cec4e13c673", "patch": "@@ -0,0 +1,12 @@\n+// aux-build:meta-delim.rs\n+// edition:2018\n+// run-pass\n+\n+// Tests that we can properly deserialize a macro with strange delimiters\n+// See https://github.com/rust-lang/rust/pull/73569#issuecomment-650860457\n+\n+extern crate meta_delim;\n+\n+fn main() {\n+    assert_eq!(\"a bunch of idents\", meta_delim::meta_delim!(a bunch of idents));\n+}"}]}