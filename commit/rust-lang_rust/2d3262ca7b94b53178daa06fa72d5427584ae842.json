{"sha": "2d3262ca7b94b53178daa06fa72d5427584ae842", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMzI2MmNhN2I5NGI1MzE3OGRhYTA2ZmE3MmQ1NDI3NTg0YWU4NDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-06-20T19:23:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-08T17:55:10Z"}, "message": "Update trans to use type to decide when to move, not the moves table (simpler\nfor cases where it's hard to decide what id to use for the lookup); modify\nirrefutable bindings code to move or copy depending on the type, rather than\nthreading through a flag. Also updates how local variables and arguments are\nregistered. These changes were hard to isolate.", "tree": {"sha": "dedbb99dc7506e50c842483c06420a6e9fdb0023", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dedbb99dc7506e50c842483c06420a6e9fdb0023"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d3262ca7b94b53178daa06fa72d5427584ae842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3262ca7b94b53178daa06fa72d5427584ae842", "html_url": "https://github.com/rust-lang/rust/commit/2d3262ca7b94b53178daa06fa72d5427584ae842", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d3262ca7b94b53178daa06fa72d5427584ae842/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41efcdf2996f842394277298a2f8045c432ba169", "url": "https://api.github.com/repos/rust-lang/rust/commits/41efcdf2996f842394277298a2f8045c432ba169", "html_url": "https://github.com/rust-lang/rust/commit/41efcdf2996f842394277298a2f8045c432ba169"}], "stats": {"total": 662, "additions": 387, "deletions": 275}, "files": [{"sha": "7412eba11563136d39a7ed99770287c6a81fc13a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2d3262ca7b94b53178daa06fa72d5427584ae842", "patch": "@@ -53,7 +53,6 @@ pub struct Maps {\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n     write_guard_map: middle::borrowck::write_guard_map,\n-    moves_map: middle::moves::MovesMap,\n     capture_map: middle::moves::CaptureMap,\n }\n \n@@ -952,12 +951,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    if maps.moves_map.contains(&id) {\n-        do ebml_w.tag(c::tag_table_moves_map) |ebml_w| {\n-            ebml_w.id(id);\n-        }\n-    }\n-\n     {\n         let r = maps.capture_map.find(&id);\n         for r.iter().advance |&cap_vars| {\n@@ -1121,9 +1114,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 xcx.dcx.tcx.sess.bug(\n                     fmt!(\"unknown tag found in side tables: %x\", tag));\n             }\n-            Some(value) => if value == c::tag_table_moves_map {\n-                dcx.maps.moves_map.insert(id);\n-            } else {\n+            Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n                 let mut val_dsr = reader::Decoder(val_doc);\n                 let val_dsr = &mut val_dsr;"}, {"sha": "af39dea6d79e1f66122d651dd7228bcd5742d088", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=2d3262ca7b94b53178daa06fa72d5427584ae842", "patch": "@@ -187,7 +187,6 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n             method_map: @mut HashMap::new(),\n             vtable_map: @mut HashMap::new(),\n             write_guard_map: @mut HashSet::new(),\n-            moves_map: @mut HashSet::new(),\n             capture_map: @mut HashMap::new()\n         };\n         match csearch::maybe_get_item_ast(tcx, def_id,"}, {"sha": "a9a3c9317b44f0d5a7c3cb4b31321fb5caf4c871", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 224, "deletions": 88, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=2d3262ca7b94b53178daa06fa72d5427584ae842", "patch": "@@ -316,7 +316,7 @@ pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n }\n \n pub enum TransBindingMode {\n-    TrByValue(/*ismove:*/ bool, /*llbinding:*/ ValueRef),\n+    TrByValue(/*llbinding:*/ ValueRef),\n     TrByRef,\n }\n \n@@ -1138,18 +1138,11 @@ fn store_non_ref_bindings(bcx: block,\n     let mut bcx = bcx;\n     for bindings_map.each_value |&binding_info| {\n         match binding_info.trmode {\n-            TrByValue(is_move, lldest) => {\n+            TrByValue(lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n                 let datum = Datum {val: llval, ty: binding_info.ty,\n                                    mode: ByRef(ZeroMem)};\n-                bcx = {\n-                    if is_move {\n-                        datum.move_to(bcx, INIT, lldest)\n-                    } else {\n-                        datum.copy_to(bcx, INIT, lldest)\n-                    }\n-                };\n-\n+                bcx = datum.store_to(bcx, INIT, lldest);\n                 do opt_temp_cleanups.mutate |temp_cleanups| {\n                     add_clean_temp_mem(bcx, lldest, binding_info.ty);\n                     temp_cleanups.push(lldest);\n@@ -1181,7 +1174,7 @@ fn insert_lllocals(bcx: block,\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n-            TrByValue(_, lldest) => {\n+            TrByValue(lldest) => {\n                 if add_cleans {\n                     add_clean(bcx, lldest, binding_info.ty);\n                 }\n@@ -1245,7 +1238,7 @@ pub fn compile_guard(bcx: block,\n         let mut bcx = bcx;\n         for data.bindings_map.each_value |&binding_info| {\n             match binding_info.trmode {\n-                TrByValue(_, llval) => {\n+                TrByValue(llval) => {\n                     bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n                 }\n                 TrByRef => {}\n@@ -1737,53 +1730,204 @@ pub enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-// Not match-related, but similar to the pattern-munging code above\n-pub fn bind_irrefutable_pat(bcx: block,\n-                            pat: @ast::pat,\n-                            val: ValueRef,\n-                            make_copy: bool,\n-                            binding_mode: IrrefutablePatternBindingMode)\n-                         -> block {\n-    let _icx = push_ctxt(\"match::bind_irrefutable_pat\");\n-    let ccx = bcx.fcx.ccx;\n+pub fn store_local(bcx: block,\n+                   pat: @ast::pat,\n+                   opt_init_expr: Option<@ast::expr>)\n+                               -> block {\n+    /*!\n+     * Generates code for a local variable declaration like\n+     * `let <pat>;` or `let <pat> = <opt_init_expr>`.\n+     */\n     let mut bcx = bcx;\n \n-    // Necessary since bind_irrefutable_pat is called outside trans_match\n-    match pat.node {\n-        ast::pat_ident(_, _, ref inner) => {\n-            if pat_is_variant_or_struct(bcx.tcx().def_map, pat) {\n-                return bcx;\n+    return match opt_init_expr {\n+        Some(init_expr) => {\n+            // Optimize the \"let x = expr\" case. This just writes\n+            // the result of evaluating `expr` directly into the alloca\n+            // for `x`. Often the general path results in similar or the\n+            // same code post-optimization, but not always. In particular,\n+            // in unsafe code, you can have expressions like\n+            //\n+            //    let x = intrinsics::uninit();\n+            //\n+            // In such cases, the more general path is unsafe, because\n+            // it assumes it is matching against a valid value.\n+            match simple_identifier(pat) {\n+                Some(path) => {\n+                    return mk_binding_alloca(\n+                        bcx, pat.id, path, BindLocal,\n+                        |bcx, _, llval| expr::trans_into(bcx, init_expr,\n+                                                         expr::SaveIn(llval)));\n+                }\n+\n+                None => {}\n             }\n \n-            if make_copy {\n-                let binding_ty = node_id_type(bcx, pat.id);\n-                let datum = Datum {val: val, ty: binding_ty,\n-                                   mode: ByRef(RevokeClean)};\n-                let scratch = scratch_datum(bcx, binding_ty, false);\n-                datum.copy_to_datum(bcx, INIT, scratch);\n-                match binding_mode {\n-                    BindLocal => {\n-                        bcx.fcx.lllocals.insert(pat.id, scratch.val);\n-                    }\n-                    BindArgument => {\n-                        bcx.fcx.llargs.insert(pat.id, scratch.val);\n-                    }\n-                }\n-                add_clean(bcx, scratch.val, binding_ty);\n+            // General path.\n+            let init_datum =\n+                unpack_datum!(\n+                    bcx,\n+                    expr::trans_to_datum(bcx, init_expr));\n+            if ty::type_is_bot(expr_ty(bcx, init_expr)) {\n+                create_dummy_locals(bcx, pat)\n             } else {\n-                match binding_mode {\n-                    BindLocal => {\n-                        bcx.fcx.lllocals.insert(pat.id, val);\n-                    }\n-                    BindArgument => {\n-                        bcx.fcx.llargs.insert(pat.id, val);\n-                    }\n+                if bcx.sess().asm_comments() {\n+                    add_comment(bcx, \"creating zeroable ref llval\");\n                 }\n+                let llptr = init_datum.to_zeroable_ref_llval(bcx);\n+                return bind_irrefutable_pat(bcx, pat, llptr, BindLocal);\n             }\n+        }\n+        None => {\n+            create_dummy_locals(bcx, pat)\n+        }\n+    };\n \n-            for inner.iter().advance |inner_pat| {\n-                bcx = bind_irrefutable_pat(\n-                    bcx, *inner_pat, val, true, binding_mode);\n+    fn create_dummy_locals(mut bcx: block, pat: @ast::pat) -> block {\n+        // create dummy memory for the variables if we have no\n+        // value to store into them immediately\n+        let tcx = bcx.tcx();\n+        do pat_bindings(tcx.def_map, pat) |_, p_id, _, path| {\n+            bcx = mk_binding_alloca(\n+                bcx, p_id, path, BindLocal,\n+                |bcx, var_ty, llval| { zero_mem(bcx, llval, var_ty); bcx });\n+        }\n+        bcx\n+    }\n+}\n+\n+pub fn store_arg(mut bcx: block,\n+                 pat: @ast::pat,\n+                 llval: ValueRef)\n+                 -> block {\n+    /*!\n+     * Generates code for argument patterns like `fn foo(<pat>: T)`.\n+     * Creates entries in the `llargs` map for each of the bindings\n+     * in `pat`.\n+     *\n+     * # Arguments\n+     *\n+     * - `pat` is the argument pattern\n+     * - `llval` is a pointer to the argument value (in other words,\n+     *   if the argument type is `T`, then `llval` is a `T*`). In some\n+     *   cases, this code may zero out the memory `llval` points at.\n+     */\n+\n+    // We always need to cleanup the argument as we exit the fn scope.\n+    // Note that we cannot do it before for fear of a fn like\n+    //    fn getaddr(~ref x: ~uint) -> *uint {....}\n+    // (From test `run-pass/func-arg-ref-pattern.rs`)\n+    let arg_ty = node_id_type(bcx, pat.id);\n+    add_clean(bcx, llval, arg_ty);\n+\n+    match simple_identifier(pat) {\n+        Some(_) => {\n+            // Optimized path for `x: T` case. This just adopts\n+            // `llval` wholesale as the pointer for `x`, avoiding the\n+            // general logic which may copy out of `llval`.\n+            bcx.fcx.llargs.insert(pat.id, llval);\n+        }\n+\n+        None => {\n+            // General path. Copy out the values that are used in the\n+            // pattern.\n+            bcx = bind_irrefutable_pat(bcx, pat, llval, BindArgument);\n+        }\n+    }\n+\n+    return bcx;\n+}\n+\n+fn mk_binding_alloca(mut bcx: block,\n+                     p_id: ast::node_id,\n+                     path: @ast::Path,\n+                     binding_mode: IrrefutablePatternBindingMode,\n+                     populate: &fn(block, ty::t, ValueRef) -> block) -> block {\n+    let var_ty = node_id_type(bcx, p_id);\n+    let ident = ast_util::path_to_ident(path);\n+    let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n+    bcx = populate(bcx, var_ty, llval);\n+    let llmap = match binding_mode {\n+        BindLocal => bcx.fcx.lllocals,\n+        BindArgument => bcx.fcx.llargs\n+    };\n+    llmap.insert(p_id, llval);\n+    add_clean(bcx, llval, var_ty);\n+    return bcx;\n+}\n+\n+fn bind_irrefutable_pat(bcx: block,\n+                        pat: @ast::pat,\n+                        val: ValueRef,\n+                        binding_mode: IrrefutablePatternBindingMode)\n+                        -> block {\n+    /*!\n+     * A simple version of the pattern matching code that only handles\n+     * irrefutable patterns. This is used in let/argument patterns,\n+     * not in match statements. Unifying this code with the code above\n+     * sounds nice, but in practice it produces very inefficient code,\n+     * since the match code is so much more general. In most cases,\n+     * LLVM is able to optimize the code, but it causes longer compile\n+     * times and makes the generated code nigh impossible to read.\n+     *\n+     * # Arguments\n+     * - bcx: starting basic block context\n+     * - pat: the irrefutable pattern being matched.\n+     * - val: a pointer to the value being matched. If pat matches a value\n+     *   of type T, then this is a T*. If the value is moved from `pat`,\n+     *   then `*pat` will be zeroed; otherwise, it's existing cleanup\n+     *   applies.\n+     * - binding_mode: is this for an argument or a local variable?\n+     */\n+\n+    debug!(\"bind_irrefutable_pat(bcx=%s, pat=%s, val=%s, binding_mode=%?)\",\n+           bcx.to_str(),\n+           pat_to_str(pat, bcx.sess().intr()),\n+           val_str(bcx.ccx().tn, val),\n+           binding_mode);\n+\n+    if bcx.sess().asm_comments() {\n+        add_comment(bcx, fmt!(\"bind_irrefutable_pat(pat=%s)\",\n+                              pat_to_str(pat, bcx.sess().intr())));\n+    }\n+\n+    let _indenter = indenter();\n+\n+    let _icx = bcx.insn_ctxt(\"alt::bind_irrefutable_pat\");\n+    let mut bcx = bcx;\n+    let tcx = bcx.tcx();\n+    let ccx = bcx.ccx();\n+    match pat.node {\n+        ast::pat_ident(pat_binding_mode, path, inner) => {\n+            if pat_is_binding(tcx.def_map, pat) {\n+                // Allocate the stack slot where the value of this\n+                // binding will live and place it into the appropriate\n+                // map.\n+                bcx = mk_binding_alloca(\n+                    bcx, pat.id, path, binding_mode,\n+                    |bcx, variable_ty, llvariable_val| {\n+                        match pat_binding_mode {\n+                            ast::bind_infer => {\n+                                // By value binding: move the value that `val`\n+                                // points at into the binding's stack slot.\n+                                let datum = Datum {val: val,\n+                                                   ty: variable_ty,\n+                                                   mode: ByRef(ZeroMem)};\n+                                datum.store_to(bcx, INIT, llvariable_val)\n+                            }\n+\n+                            ast::bind_by_ref(_) => {\n+                                // By ref binding: the value of the variable\n+                                // is the pointer `val` itself.\n+                                Store(bcx, val, llvariable_val);\n+                                bcx\n+                            }\n+                        }\n+                    });\n+            }\n+\n+            for inner.iter().advance |&inner_pat| {\n+                bcx = bind_irrefutable_pat(bcx, inner_pat, val, binding_mode);\n             }\n         }\n         ast::pat_enum(_, ref sub_pats) => {\n@@ -1799,11 +1943,8 @@ pub fn bind_irrefutable_pat(bcx: block,\n                                                     val);\n                     for sub_pats.iter().advance |sub_pat| {\n                         for args.vals.iter().enumerate().advance |(i, argval)| {\n-                            bcx = bind_irrefutable_pat(bcx,\n-                                                       sub_pat[i],\n-                                                       *argval,\n-                                                       make_copy,\n-                                                       binding_mode);\n+                            bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n+                                                       *argval, binding_mode);\n                         }\n                     }\n                 }\n@@ -1818,19 +1959,14 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             let repr = adt::represent_node(bcx, pat.id);\n                             for elems.iter().enumerate().advance |(i, elem)| {\n                                 let fldptr = adt::trans_field_ptr(bcx, repr,\n-                                                            val, 0, i);\n-                                bcx = bind_irrefutable_pat(bcx,\n-                                                           *elem,\n-                                                           fldptr,\n-                                                           make_copy,\n-                                                           binding_mode);\n+                                                                  val, 0, i);\n+                                bcx = bind_irrefutable_pat(bcx, *elem,\n+                                                           fldptr, binding_mode);\n                             }\n                         }\n                     }\n                 }\n                 Some(&ast::def_static(_, false)) => {\n-                    bcx = bind_irrefutable_pat(bcx, pat, val, make_copy,\n-                                               binding_mode);\n                 }\n                 _ => {\n                     // Nothing to do here.\n@@ -1845,24 +1981,16 @@ pub fn bind_irrefutable_pat(bcx: block,\n                 for fields.iter().advance |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n-                                                discr, ix);\n-                    bcx = bind_irrefutable_pat(bcx,\n-                                               f.pat,\n-                                               fldptr,\n-                                               make_copy,\n-                                               binding_mode);\n+                                                      discr, ix);\n+                    bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, binding_mode);\n                 }\n             }\n         }\n         ast::pat_tup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for elems.iter().enumerate().advance |(i, elem)| {\n                 let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n-                bcx = bind_irrefutable_pat(bcx,\n-                                           *elem,\n-                                           fldptr,\n-                                           make_copy,\n-                                           binding_mode);\n+                bcx = bind_irrefutable_pat(bcx, *elem, fldptr, binding_mode);\n             }\n         }\n         ast::pat_box(inner) | ast::pat_uniq(inner) => {\n@@ -1872,22 +2000,30 @@ pub fn bind_irrefutable_pat(bcx: block,\n                 ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n                     _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n             };\n-            bcx = bind_irrefutable_pat(bcx,\n-                                       inner,\n-                                       unboxed,\n-                                       true,\n-                                       binding_mode);\n+            bcx = bind_irrefutable_pat(bcx, inner, unboxed, binding_mode);\n         }\n         ast::pat_region(inner) => {\n             let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx,\n-                                       inner,\n-                                       loaded_val,\n-                                       true,\n-                                       binding_mode);\n-        }\n-        ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) |\n-        ast::pat_vec(*) => ()\n+            bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode);\n+        }\n+        ast::pat_vec(*) => {\n+            bcx.tcx().sess.span_bug(\n+                pat.span,\n+                fmt!(\"vector patterns are never irrefutable!\"));\n+        }\n+        ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) => ()\n     }\n     return bcx;\n }\n+\n+fn simple_identifier(pat: @ast::pat) -> Option<@ast::Path> {\n+    match pat.node {\n+        ast::pat_ident(ast::bind_infer, path, None) => {\n+            Some(path)\n+        }\n+        _ => {\n+            None\n+        }\n+    }\n+}\n+"}, {"sha": "75d9f89a8d7d5e34d0612106e1056616cb9a57ba", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 125, "deletions": 134, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2d3262ca7b94b53178daa06fa72d5427584ae842", "patch": "@@ -59,6 +59,7 @@ use middle::trans::type_of::*;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n+use middle::pat_util;\n \n use middle::trans::type_::Type;\n \n@@ -75,7 +76,7 @@ use extra::time;\n use extra::sort;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n-use syntax::ast_util::{local_def, path_to_ident};\n+use syntax::ast_util::{local_def};\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::parse::token;\n@@ -1121,9 +1122,6 @@ pub fn init_local(bcx: block, local: &ast::local) -> block {\n     let _indenter = indenter();\n \n     let _icx = push_ctxt(\"init_local\");\n-    let ty = node_id_type(bcx, local.node.id);\n-\n-    debug!(\"ty=%s\", bcx.ty_to_str(ty));\n \n     if ignore_lhs(bcx, local) {\n         // Handle let _ = e; just like e;\n@@ -1135,36 +1133,7 @@ pub fn init_local(bcx: block, local: &ast::local) -> block {\n         }\n     }\n \n-    let llptr = match bcx.fcx.lllocals.find_copy(&local.node.id) {\n-        Some(v) => v,\n-        _ => {\n-            bcx.tcx().sess.span_bug(local.span,\n-                                    \"init_local: Someone forgot to document why it's\\\n-                                     safe to assume local.node.init must be local_mem!\");\n-        }\n-    };\n-\n-    let mut bcx = bcx;\n-    match local.node.init {\n-        Some(init) => {\n-            bcx = expr::trans_into(bcx, init, expr::SaveIn(llptr));\n-        }\n-        _ => {\n-            zero_mem(bcx, llptr, ty);\n-        }\n-    }\n-\n-    // Make a note to drop this slot on the way out.\n-    debug!(\"adding clean for %?/%s to bcx=%s\",\n-           local.node.id, bcx.ty_to_str(ty),\n-           bcx.to_str());\n-    add_clean(bcx, llptr, ty);\n-\n-    return _match::bind_irrefutable_pat(bcx,\n-                                       local.node.pat,\n-                                       llptr,\n-                                       false,\n-                                       _match::BindLocal);\n+    _match::store_local(bcx, local.node.pat, local.node.init)\n }\n \n pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n@@ -1469,6 +1438,7 @@ pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n     }\n }\n \n+<<<<<<< variant A\n pub fn alloc_local(cx: block, local: &ast::local) -> block {\n     let _icx = push_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n@@ -1491,6 +1461,31 @@ pub fn alloc_local(cx: block, local: &ast::local) -> block {\n }\n \n \n+>>>>>>> variant B\n+####### Ancestor\n+pub fn alloc_local(cx: block, local: @ast::local) -> block {\n+    let _icx = push_ctxt(\"alloc_local\");\n+    let t = node_id_type(cx, local.node.id);\n+    let simple_name = match local.node.pat.node {\n+      ast::pat_ident(_, pth, None) => Some(path_to_ident(pth)),\n+      _ => None\n+    };\n+    let val = alloc_ty(cx, t);\n+    if cx.sess().opts.debuginfo {\n+        for simple_name.iter().advance |name| {\n+            str::as_c_str(cx.ccx().sess.str_of(*name), |buf| {\n+                unsafe {\n+                    llvm::LLVMSetValueName(val, buf)\n+                }\n+            });\n+        }\n+    }\n+    cx.fcx.lllocals.insert(local.node.id, val);\n+    cx\n+}\n+\n+\n+======= end\n pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n     let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n@@ -1739,6 +1734,7 @@ pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n             let arg = &args[i];\n             let llarg = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n \n+            // FIXME #7260: aliasing should be determined by monomorphized ty::t\n             match arg.ty.node {\n                 // `~` pointers never alias other parameters, because ownership was transferred\n                 ast::ty_uniq(_) => {\n@@ -1783,7 +1779,6 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n     for uint::range(0, arg_tys.len()) |arg_n| {\n         let arg_ty = arg_tys[arg_n];\n         let raw_llarg = raw_llargs[arg_n];\n-        let arg_id = args[arg_n].id;\n \n         // For certain mode/type combinations, the raw llarg values are passed\n         // by value.  However, within the fn body itself, we want to always\n@@ -1794,22 +1789,13 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         // the event it's not truly needed.\n         // only by value if immediate:\n         let llarg = if datum::appropriate_mode(bcx.tcx(), arg_ty).is_by_value() {\n-            let alloc = alloc_ty(bcx, arg_ty);\n+            let alloc = alloc_ty(bcx, arg_ty, \"__arg\");\n             Store(bcx, raw_llarg, alloc);\n             alloc\n         } else {\n             raw_llarg\n         };\n-\n-        add_clean(bcx, llarg, arg_ty);\n-\n-        bcx = _match::bind_irrefutable_pat(bcx,\n-                                          args[arg_n].pat,\n-                                          llarg,\n-                                          false,\n-                                          _match::BindArgument);\n-\n-        fcx.llargs.insert(arg_id, llarg);\n+        bcx = _match::store_arg(bcx, args[arg_n].pat, llarg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n             debuginfo::create_arg(bcx, &args[arg_n], args[arg_n].ty.span);\n@@ -1968,143 +1954,148 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   |_bcx| { });\n }\n \n+fn insert_synthetic_type_entries(bcx: block,\n+                                 fn_args: &[ast::arg],\n+                                 arg_tys: &[ty::t])\n+{\n+    /*!\n+     * For tuple-like structs and enum-variants, we generate\n+     * synthetic AST nodes for the arguments.  These have no types\n+     * in the type table and no entries in the moves table,\n+     * so the code in `copy_args_to_allocas` and `bind_irrefutable_pat`\n+     * gets upset. This hack of a function bridges the gap by inserting types.\n+     *\n+     * This feels horrible. I think we should just have a special path\n+     * for these functions and not try to use the generic code, but\n+     * that's not the problem I'm trying to solve right now. - nmatsakis\n+     */\n+\n+    let tcx = bcx.tcx();\n+    for uint::range(0, fn_args.len()) |i| {\n+        debug!(\"setting type of argument %u (pat node %d) to %s\",\n+               i, fn_args[i].pat.id, bcx.ty_to_str(arg_tys[i]));\n+\n+        let pat_id = fn_args[i].pat.id;\n+        let arg_ty = arg_tys[i];\n+        tcx.node_types.insert(pat_id as uint, arg_ty);\n+    }\n+}\n+\n pub fn trans_enum_variant(ccx: @mut CrateContext,\n-                          enum_id: ast::node_id,\n+                          _enum_id: ast::node_id,\n                           variant: &ast::variant,\n                           args: &[ast::variant_arg],\n                           disr: int,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n-    // Translate variant arguments to function arguments.\n-    let fn_args = do args.map |varg| {\n-        ast::arg {\n-            is_mutbl: false,\n-            ty: copy varg.ty,\n-            pat: ast_util::ident_to_pat(\n-                ccx.tcx.sess.next_node_id(),\n-                codemap::dummy_sp(),\n-                special_idents::arg),\n-            id: varg.id,\n-        }\n-    };\n \n-    let ty_param_substs = match param_substs {\n-        Some(ref substs) => { copy substs.tys }\n-        None => ~[]\n-    };\n-    let enum_ty = ty::subst_tps(ccx.tcx,\n-                                ty_param_substs,\n-                                None,\n-                                ty::node_id_to_type(ccx.tcx, enum_id));\n-    let fcx = new_fn_ctxt_w_id(ccx,\n-                               ~[],\n-                               llfndecl,\n-                               variant.node.id,\n-                               enum_ty,\n-                               param_substs,\n-                               None);\n-\n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n-    let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n-    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n-\n-    // XXX is there a better way to reconstruct the ty::t?\n-    let repr = adt::represent_type(ccx, enum_ty);\n-\n-    debug!(\"trans_enum_variant: name=%s tps=%s repr=%? enum_ty=%s\",\n-           unsafe { str::raw::from_c_str(llvm::LLVMGetValueName(llfndecl)) },\n-           ~\"[\" + ty_param_substs.map(|&t| ty_to_str(ccx.tcx, t)).connect(\", \") + \"]\",\n-           repr, ty_to_str(ccx.tcx, enum_ty));\n-\n-    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n-    for args.iter().enumerate().advance |(i, va)| {\n-        let lldestptr = adt::trans_field_ptr(bcx,\n-                                             repr,\n-                                             fcx.llretptr.get(),\n-                                             disr,\n-                                             i);\n-\n-        // If this argument to this function is a enum, it'll have come in to\n-        // this function as an opaque blob due to the way that type_of()\n-        // works. So we have to cast to the destination's view of the type.\n-        let llarg = match fcx.llargs.find(&va.id) {\n-            Some(&x) => x,\n-            _ => fail!(\"trans_enum_variant: how do we know this works?\"),\n-        };\n-        let arg_ty = arg_tys[i];\n-        memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n-    }\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n+    trans_enum_variant_or_tuple_like_struct(\n+        ccx,\n+        variant.node.id,\n+        args,\n+        disr,\n+        param_substs,\n+        llfndecl);\n }\n \n-// NB: In theory this should be merged with the function above. But the AST\n-// structures are completely different, so very little code would be shared.\n pub fn trans_tuple_struct(ccx: @mut CrateContext,\n                           fields: &[@ast::struct_field],\n                           ctor_id: ast::node_id,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n-    // Translate struct fields to function arguments.\n-    let fn_args = do fields.map |field| {\n+    trans_enum_variant_or_tuple_like_struct(\n+        ccx,\n+        ctor_id,\n+        fields,\n+        0,\n+        param_substs,\n+        llfndecl);\n+}\n+\n+trait IdAndTy {\n+    fn id(&self) -> ast::node_id;\n+    fn ty(&self) -> @ast::Ty;\n+}\n+\n+impl IdAndTy for ast::variant_arg {\n+    fn id(&self) -> ast::node_id { self.id }\n+    fn ty(&self) -> @ast::Ty { self.ty }\n+}\n+\n+impl IdAndTy for @ast::struct_field {\n+    fn id(&self) -> ast::node_id { self.node.id }\n+    fn ty(&self) -> @ast::Ty { self.node.ty }\n+}\n+\n+pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n+    ccx: @mut CrateContext,\n+    ctor_id: ast::node_id,\n+    args: &[A],\n+    disr: int,\n+    param_substs: Option<@param_substs>,\n+    llfndecl: ValueRef)\n+{\n+    // Translate variant arguments to function arguments.\n+    let fn_args = do args.map |varg| {\n         ast::arg {\n             is_mutbl: false,\n-            ty: copy field.node.ty,\n-            pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n-                                        codemap::dummy_sp(),\n-                                        special_idents::arg),\n-            id: field.node.id\n+            ty: varg.ty(),\n+            pat: ast_util::ident_to_pat(\n+                ccx.tcx.sess.next_node_id(),\n+                codemap::dummy_sp(),\n+                special_idents::arg),\n+            id: varg.id(),\n         }\n     };\n \n-    // XXX is there a better way to reconstruct the ty::t?\n     let ty_param_substs = match param_substs {\n         Some(ref substs) => { copy substs.tys }\n         None => ~[]\n     };\n+\n     let ctor_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n                                 ty::node_id_to_type(ccx.tcx, ctor_id));\n-    let tup_ty = match ty::get(ctor_ty).sty {\n+\n+    let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n-        _ => ccx.sess.bug(fmt!(\"trans_tuple_struct: unexpected ctor \\\n-                                return type %s\",\n-                               ty_to_str(ccx.tcx, ctor_ty)))\n+        _ => ccx.sess.bug(\n+            fmt!(\"trans_enum_variant_or_tuple_like_struct: \\\n+                  unexpected ctor return type %s\",\n+                 ty_to_str(ccx.tcx, ctor_ty)))\n     };\n \n     let fcx = new_fn_ctxt_w_id(ccx,\n                                ~[],\n                                llfndecl,\n                                ctor_id,\n-                               tup_ty,\n+                               result_ty,\n                                param_substs,\n                                None);\n \n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n-    let arg_tys = ty::ty_fn_args(node_id_type(bcx, ctor_id));\n-    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n+    let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let repr = adt::represent_type(ccx, tup_ty);\n-    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), 0);\n+    insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n+    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n-    for fields.iter().enumerate().advance |(i, field)| {\n+    let repr = adt::represent_type(ccx, result_ty);\n+    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n+    for fn_args.iter().enumerate().advance |(i, fn_arg)| {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n                                              fcx.llretptr.get(),\n-                                             0,\n+                                             disr,\n                                              i);\n-        let llarg = fcx.llargs.get_copy(&field.node.id);\n+        let llarg = fcx.llargs.get_copy(&fn_arg.pat.id);\n         let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n-\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n }\n@@ -3039,8 +3030,8 @@ pub fn trans_crate(sess: session::Session,\n         }\n     }\n     if ccx.sess.count_llvm_insns() {\n-        for ccx.stats.llvm_insns.iter().advance |(&k, &v)| {\n-            io::println(fmt!(\"%-7u %s\", v, k));\n+        for ccx.stats.llvm_insns.each |k, v| {\n+            io::println(fmt!(\"%-7u %s\", *v, *k));\n         }\n     }\n "}, {"sha": "216338e111787de0a7ea5676479945e7e99b909f", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2d3262ca7b94b53178daa06fa72d5427584ae842", "patch": "@@ -860,8 +860,6 @@ pub fn trans_arg_expr(bcx: block,\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n             DoAutorefArg => {\n-                assert!(!\n-                    bcx.ccx().maps.moves_map.contains(&arg_expr.id));\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {"}, {"sha": "904e6e14e28db9b4f8a2506ffee08438cebaea40", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=2d3262ca7b94b53178daa06fa72d5427584ae842", "patch": "@@ -35,9 +35,6 @@ use syntax::codemap::span;\n pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n-    do block_locals(b) |local| {\n-        bcx = alloc_local(bcx, local);\n-    };\n     for b.node.stmts.iter().advance |s| {\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);"}, {"sha": "1de619433afbd86f09f84d81ab1f3fe82f1de3fc", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=2d3262ca7b94b53178daa06fa72d5427584ae842", "patch": "@@ -70,8 +70,8 @@\n  *   This is a \"shallow\" clone.  After `move_to()`, the current datum\n  *   is invalid and should no longer be used.\n  *\n- * - `store_to()` either performs a copy or a move by consulting the\n- *   moves_map computed by `middle::moves`.\n+ * - `store_to()` either performs a copy or a move depending on the\n+ *   Rust type of the datum.\n  *\n  * # Scratch datum\n  *\n@@ -208,7 +208,6 @@ pub fn appropriate_mode(tcx: ty::ctxt, ty: ty::t) -> DatumMode {\n impl Datum {\n     pub fn store_to(&self,\n                     bcx: block,\n-                    id: ast::node_id,\n                     action: CopyAction,\n                     dst: ValueRef)\n                     -> block {\n@@ -218,7 +217,7 @@ impl Datum {\n          * `id` is located in the move table, but copies otherwise.\n          */\n \n-        if bcx.ccx().maps.moves_map.contains(&id) {\n+        if ty::type_moves_by_default(bcx.tcx(), self.ty) {\n             self.move_to(bcx, action, dst)\n         } else {\n             self.copy_to(bcx, action, dst)\n@@ -227,29 +226,27 @@ impl Datum {\n \n     pub fn store_to_dest(&self,\n                          bcx: block,\n-                         id: ast::node_id,\n                          dest: expr::Dest)\n                          -> block {\n         match dest {\n             expr::Ignore => {\n                 return bcx;\n             }\n             expr::SaveIn(addr) => {\n-                return self.store_to(bcx, id, INIT, addr);\n+                return self.store_to(bcx, INIT, addr);\n             }\n         }\n     }\n \n     pub fn store_to_datum(&self,\n                           bcx: block,\n-                          id: ast::node_id,\n                           action: CopyAction,\n                           datum: Datum)\n                           -> block {\n         debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n-        self.store_to(bcx, id, action, datum.val)\n+        self.store_to(bcx, action, datum.val)\n     }\n \n     pub fn move_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n@@ -828,11 +825,10 @@ impl DatumBlock {\n     }\n \n     pub fn store_to(&self,\n-                    id: ast::node_id,\n                     action: CopyAction,\n                     dst: ValueRef)\n                     -> block {\n-        self.datum.store_to(self.bcx, id, action, dst)\n+        self.datum.store_to(self.bcx, action, dst)\n     }\n \n     pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> block {"}, {"sha": "19a0f7262ff6e697c242bfa802dedf6fc0c735f5", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3262ca7b94b53178daa06fa72d5427584ae842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=2d3262ca7b94b53178daa06fa72d5427584ae842", "patch": "@@ -23,7 +23,8 @@ This will generate code that evaluates `expr`, storing the result into\n `Dest`, which must either be the special flag ignore (throw the result\n away) or be a pointer to memory of the same type/size as the\n expression.  It returns the resulting basic block.  This form will\n-handle all automatic adjustments and moves for you.\n+handle all automatic adjustments for you. The value will be moved if\n+its type is linear and copied otherwise.\n \n ## Translation to a datum\n \n@@ -42,18 +43,18 @@ This function generates code to evaluate the expression and return a\n tries to return its result in the most efficient way possible, without\n introducing extra copies or sacrificing information.  Therefore, for\n lvalue expressions, you always get a by-ref `Datum` in return that\n-points at the memory for this lvalue (almost, see [1]).  For rvalue\n-expressions, we will return a by-value `Datum` whenever possible, but\n-it is often necessary to allocate a stack slot, store the result of\n-the rvalue in there, and then return a pointer to the slot (see the\n-discussion later on about the different kinds of rvalues).\n+points at the memory for this lvalue.  For rvalue expressions, we will\n+return a by-value `Datum` whenever possible, but it is often necessary\n+to allocate a stack slot, store the result of the rvalue in there, and\n+then return a pointer to the slot (see the discussion later on about\n+the different kinds of rvalues).\n \n NB: The `trans_to_datum()` function does perform adjustments, but\n since it returns a pointer to the value \"in place\" it does not handle\n-any moves that may be relevant.  If you are transing an expression\n-whose result should be moved, you should either use the Datum methods\n-`move_to()` (for unconditional moves) or `store_to()` (for moves\n-conditioned on the type of the expression) at some point.\n+moves.  If you wish to copy/move the value returned into a new\n+location, you should use the Datum method `store_to()` (move or copy\n+depending on type). You can also use `move_to()` (force move) or\n+`copy_to()` (force copy) for special situations.\n \n ## Translating local variables\n \n@@ -110,13 +111,6 @@ generate phi nodes).\n Finally, statement rvalues are rvalues that always produce a nil\n return type, such as `while` loops or assignments (`a = b`).\n \n-## Caveats\n-\n-[1] Actually, some lvalues are only stored by value and not by\n-reference.  An example (as of this writing) would be immutable\n-arguments or pattern bindings of immediate type.  However, mutable\n-lvalues are *never* stored by value.\n-\n */\n \n \n@@ -315,7 +309,7 @@ pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n         let datumblock = trans_to_datum(bcx, expr);\n         return match dest {\n             Ignore => datumblock.bcx,\n-            SaveIn(lldest) => datumblock.store_to(expr.id, INIT, lldest)\n+            SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n         };\n     }\n \n@@ -343,16 +337,17 @@ pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n             let datumblock = trans_lvalue_unadjusted(bcx, expr);\n             match dest {\n                 Ignore => datumblock.bcx,\n-                SaveIn(lldest) => datumblock.store_to(expr.id, INIT, lldest)\n+                SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n             }\n         }\n         ty::RvalueDatumExpr => {\n             let datumblock = trans_rvalue_datum_unadjusted(bcx, expr);\n             match dest {\n                 Ignore => datumblock.drop_val(),\n \n-                // NB: We always do `move_to()` regardless of the\n-                // moves_map because we're processing an rvalue\n+                // When processing an rvalue, the value will be newly\n+                // allocated, so we always `move_to` so as not to\n+                // unnecessarily inc ref counts and so forth:\n                 SaveIn(lldest) => datumblock.move_to(INIT, lldest)\n             }\n         }\n@@ -386,11 +381,11 @@ fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     /*!\n-     *\n      * Translates an expression into a datum.  If this expression\n      * is an rvalue, this will result in a temporary value being\n-     * created.  If you already know where the result should be stored,\n-     * you should use `trans_into()` instead. */\n+     * created.  If you plan to store the value somewhere else,\n+     * you should prefer `trans_into()` instead.\n+     */\n \n     let mut bcx = bcx;\n \n@@ -535,7 +530,7 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n             let dst_datum = unpack_datum!(\n                 bcx, trans_lvalue(bcx, dst));\n             return src_datum.store_to_datum(\n-                bcx, src.id, DROP_EXISTING, dst_datum);\n+                bcx, DROP_EXISTING, dst_datum);\n         }\n         ast::expr_assign_op(callee_id, op, dst, src) => {\n             return trans_assign_op(bcx, expr, callee_id, op, dst, src);\n@@ -638,7 +633,15 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return trans_into(bcx, blk, dest);\n         }\n         ast::expr_copy(a) => {\n-            return trans_into(bcx, a, dest);\n+            // If we just called `trans_into(bcx, a, dest)`, then this\n+            // might *move* the value into `dest` if the value is\n+            // non-copyable. So first get a datum and then do an\n+            // explicit copy.\n+            let datumblk = trans_to_datum(bcx, a);\n+            return match dest {\n+                Ignore => datumblk.bcx,\n+                SaveIn(llval) => datumblk.copy_to(INIT, llval)\n+            };\n         }\n         ast::expr_call(f, ref args, _) => {\n             return callee::trans_call(\n@@ -1221,6 +1224,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n                 bcx = trans_into(bcx, e, Ignore);\n             }\n             for optbase.iter().advance |sbi| {\n+                // FIXME #7261: this moves entire base, not just certain fields\n                 bcx = trans_into(bcx, sbi.expr, Ignore);\n             }\n             return bcx;\n@@ -1245,7 +1249,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n                 adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n             };\n             let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n-            bcx = datum.store_to(bcx, base.expr.id, INIT, dest);\n+            bcx = datum.store_to(bcx, INIT, dest);\n         }\n     }\n "}]}