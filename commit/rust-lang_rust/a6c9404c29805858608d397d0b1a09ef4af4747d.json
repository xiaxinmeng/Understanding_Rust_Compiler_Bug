{"sha": "a6c9404c29805858608d397d0b1a09ef4af4747d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2Yzk0MDRjMjk4MDU4NTg2MDhkMzk3ZDBiMWEwOWVmNGFmNDc0N2Q=", "commit": {"author": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-07-21T01:31:14Z"}, "committer": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-08-04T17:38:13Z"}, "message": "run rustfmt on librustc_passes folder", "tree": {"sha": "363cba68d003687e8ae5a4dc90d592060c41b02c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/363cba68d003687e8ae5a4dc90d592060c41b02c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6c9404c29805858608d397d0b1a09ef4af4747d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXo32KAAoJEAkcWPS/w2VxxFkP/i7LobzVi1xmtZ6C1IhntgnU\nXUKQx458SmPODkoETwiHwkIPMuaCkv8I+wTreEt0xR2O73iSHAKHzC3TEymAu/a1\nmKjKDTb6abB8Ixnrtnk9tcLQOCVsvIKU/RlWGALeFayg8Qw+WN5NJHW/huOCO4ZZ\n56HBQSQSR2Gcdsy5kHZk6ZHUHMwgrQT4/UC4R6NCt0xA2XfyR8EevAyoHOwAQn3c\njEe1Z7LfFCaNh+WQ7uJoKk/L4afjOjMdilynNNppBpPCqJu9+Y0VAMQrm6Jt0EUv\nCw/VKhwUUBGNqP8xfS1577HA0+ZD8ncO65J9VyCt5wLK/aI9pA9/w1Ahf9TNMPp/\nosfYwPkzt/btT/e7UgLyGj1Ixb+SvgocK2onzvuAWCfzpAfGERDNIoRohw7/gABL\nDSWfVKDkSeM5IaCxEKHzhIPS+zYvvDzCkpsFBx1RaC7Z27aMZVNAgvrAPWaUHUGk\n0GzoGvbka9C/dApIgfQSqRAZdfPMK1O42Ooer53NftvojctFMasAQ6xfuGCQ9ZM+\n42jIhFRXhSd5J/gzy+FJexo32jiJNWXP8Wa8XsDrYhI2yyYwvlkohm8rsxdeFCtR\nWN+SEOoXGk1vP8asVuLMPTzl0Gw7enPt61u/5pmsqvgoYqe5I/9Q07RvabyrKAXe\nPdFRkEE7nhMgabi/NkYO\n=yQC2\n-----END PGP SIGNATURE-----", "payload": "tree 363cba68d003687e8ae5a4dc90d592060c41b02c\nparent e804a3cf256106c097d44f6e0212cd183122da07\nauthor Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1469064674 +0530\ncommitter Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1470332293 +0530\n\nrun rustfmt on librustc_passes folder\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6c9404c29805858608d397d0b1a09ef4af4747d", "html_url": "https://github.com/rust-lang/rust/commit/a6c9404c29805858608d397d0b1a09ef4af4747d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6c9404c29805858608d397d0b1a09ef4af4747d/comments", "author": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e804a3cf256106c097d44f6e0212cd183122da07", "url": "https://api.github.com/repos/rust-lang/rust/commits/e804a3cf256106c097d44f6e0212cd183122da07", "html_url": "https://github.com/rust-lang/rust/commit/e804a3cf256106c097d44f6e0212cd183122da07"}], "stats": {"total": 373, "additions": 200, "deletions": 173}, "files": [{"sha": "91d2500564fd3b7d246f406fcb8d117fb0fede0b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=a6c9404c29805858608d397d0b1a09ef4af4747d", "patch": "@@ -38,16 +38,18 @@ impl<'a> AstValidator<'a> {\n             self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n         }\n         if label.name.as_str() == \"'_\" {\n-            self.session.add_lint(\n-                lint::builtin::LIFETIME_UNDERSCORE, id, span,\n-                format!(\"invalid label name `{}`\", label.name)\n-            );\n+            self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n+                                  id,\n+                                  span,\n+                                  format!(\"invalid label name `{}`\", label.name));\n         }\n     }\n \n     fn invalid_visibility(&self, vis: &Visibility, span: Span, note: Option<&str>) {\n         if vis != &Visibility::Inherited {\n-            let mut err = struct_span_err!(self.session, span, E0449,\n+            let mut err = struct_span_err!(self.session,\n+                                           span,\n+                                           E0449,\n                                            \"unnecessary visibility qualifier\");\n             if let Some(note) = note {\n                 err.span_note(span, note);\n@@ -71,20 +73,23 @@ impl<'a> AstValidator<'a> {\n impl<'a> Visitor for AstValidator<'a> {\n     fn visit_lifetime(&mut self, lt: &Lifetime) {\n         if lt.name.as_str() == \"'_\" {\n-            self.session.add_lint(\n-                lint::builtin::LIFETIME_UNDERSCORE, lt.id, lt.span,\n-                format!(\"invalid lifetime name `{}`\", lt.name)\n-            );\n+            self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n+                                  lt.id,\n+                                  lt.span,\n+                                  format!(\"invalid lifetime name `{}`\", lt.name));\n         }\n \n         visit::walk_lifetime(self, lt)\n     }\n \n     fn visit_expr(&mut self, expr: &Expr) {\n         match expr.node {\n-            ExprKind::While(_, _, Some(ident)) | ExprKind::Loop(_, Some(ident)) |\n-            ExprKind::WhileLet(_, _, _, Some(ident)) | ExprKind::ForLoop(_, _, _, Some(ident)) |\n-            ExprKind::Break(Some(ident)) | ExprKind::Continue(Some(ident)) => {\n+            ExprKind::While(_, _, Some(ident)) |\n+            ExprKind::Loop(_, Some(ident)) |\n+            ExprKind::WhileLet(_, _, _, Some(ident)) |\n+            ExprKind::ForLoop(_, _, _, Some(ident)) |\n+            ExprKind::Break(Some(ident)) |\n+            ExprKind::Continue(Some(ident)) => {\n                 self.check_label(ident.node, ident.span, expr.id);\n             }\n             _ => {}\n@@ -97,10 +102,13 @@ impl<'a> Visitor for AstValidator<'a> {\n         match ty.node {\n             TyKind::BareFn(ref bfty) => {\n                 self.check_decl_no_pat(&bfty.decl, |span, _| {\n-                    let mut err = struct_span_err!(self.session, span, E0561,\n-                                            \"patterns aren't allowed in function pointer types\");\n-                    err.span_note(span, \"this is a recent error, see \\\n-                                         issue #35203 for more details\");\n+                    let mut err = struct_span_err!(self.session,\n+                                                   span,\n+                                                   E0561,\n+                                                   \"patterns aren't allowed in function pointer \\\n+                                                    types\");\n+                    err.span_note(span,\n+                                  \"this is a recent error, see issue #35203 for more details\");\n                     err.emit();\n                 });\n             }\n@@ -114,10 +122,10 @@ impl<'a> Visitor for AstValidator<'a> {\n         if path.global && path.segments.len() > 0 {\n             let ident = path.segments[0].identifier;\n             if token::Ident(ident).is_path_segment_keyword() {\n-                self.session.add_lint(\n-                    lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH, id, path.span,\n-                    format!(\"global paths cannot start with `{}`\", ident)\n-                );\n+                self.session.add_lint(lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH,\n+                                      id,\n+                                      path.span,\n+                                      format!(\"global paths cannot start with `{}`\", ident));\n             }\n         }\n \n@@ -129,8 +137,8 @@ impl<'a> Visitor for AstValidator<'a> {\n             ItemKind::Use(ref view_path) => {\n                 let path = view_path.node.path();\n                 if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n-                    self.err_handler().span_err(path.span, \"type or lifetime parameters \\\n-                                                            in import path\");\n+                    self.err_handler()\n+                        .span_err(path.span, \"type or lifetime parameters in import path\");\n                 }\n             }\n             ItemKind::Impl(_, _, _, Some(..), _, ref impl_items) => {\n@@ -140,15 +148,18 @@ impl<'a> Visitor for AstValidator<'a> {\n                 }\n             }\n             ItemKind::Impl(_, _, _, None, _, _) => {\n-                self.invalid_visibility(&item.vis, item.span, Some(\"place qualifiers on individual \\\n-                                                                    impl items instead\"));\n+                self.invalid_visibility(&item.vis,\n+                                        item.span,\n+                                        Some(\"place qualifiers on individual impl items instead\"));\n             }\n             ItemKind::DefaultImpl(..) => {\n                 self.invalid_visibility(&item.vis, item.span, None);\n             }\n             ItemKind::ForeignMod(..) => {\n-                self.invalid_visibility(&item.vis, item.span, Some(\"place qualifiers on individual \\\n-                                                                    foreign items instead\"));\n+                self.invalid_visibility(&item.vis,\n+                                        item.span,\n+                                        Some(\"place qualifiers on individual foreign items \\\n+                                              instead\"));\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n@@ -167,11 +178,14 @@ impl<'a> Visitor for AstValidator<'a> {\n         match fi.node {\n             ForeignItemKind::Fn(ref decl, _) => {\n                 self.check_decl_no_pat(decl, |span, is_recent| {\n-                    let mut err = struct_span_err!(self.session, span, E0130,\n-                                        \"patterns aren't allowed in foreign function declarations\");\n+                    let mut err = struct_span_err!(self.session,\n+                                                   span,\n+                                                   E0130,\n+                                                   \"patterns aren't allowed in foreign function \\\n+                                                    declarations\");\n                     if is_recent {\n-                        err.span_note(span, \"this is a recent error, see \\\n-                                             issue #35203 for more details\");\n+                        err.span_note(span,\n+                                      \"this is a recent error, see issue #35203 for more details\");\n                     }\n                     err.emit();\n                 });\n@@ -182,16 +196,21 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_foreign_item(self, fi)\n     }\n \n-    fn visit_variant_data(&mut self, vdata: &VariantData, _: Ident,\n-                          _: &Generics, _: NodeId, span: Span) {\n+    fn visit_variant_data(&mut self,\n+                          vdata: &VariantData,\n+                          _: Ident,\n+                          _: &Generics,\n+                          _: NodeId,\n+                          span: Span) {\n         if vdata.fields().is_empty() {\n             if vdata.is_tuple() {\n-                self.err_handler().struct_span_err(span, \"empty tuple structs and enum variants \\\n-                                                          are not allowed, use unit structs and \\\n-                                                          enum variants instead\")\n-                                         .span_help(span, \"remove trailing `()` to make a unit \\\n-                                                           struct or unit enum variant\")\n-                                         .emit();\n+                self.err_handler()\n+                    .struct_span_err(span,\n+                                     \"empty tuple structs and enum variants are not allowed, use \\\n+                                      unit structs and enum variants instead\")\n+                    .span_help(span,\n+                               \"remove trailing `()` to make a unit struct or unit enum variant\")\n+                    .emit();\n             }\n         }\n \n@@ -200,10 +219,10 @@ impl<'a> Visitor for AstValidator<'a> {\n \n     fn visit_vis(&mut self, vis: &Visibility) {\n         match *vis {\n-            Visibility::Restricted{ref path, ..} => {\n+            Visibility::Restricted { ref path, .. } => {\n                 if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n-                    self.err_handler().span_err(path.span, \"type or lifetime parameters \\\n-                                                            in visibility path\");\n+                    self.err_handler()\n+                        .span_err(path.span, \"type or lifetime parameters in visibility path\");\n                 }\n             }\n             _ => {}"}, {"sha": "fc55118c9f4c518ed0fa989067cf40f95f580f9e", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 70, "deletions": 78, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=a6c9404c29805858608d397d0b1a09ef4af4747d", "patch": "@@ -25,7 +25,7 @@\n // by borrowck::gather_loans\n \n use rustc::dep_graph::DepNode;\n-use rustc::ty::cast::{CastKind};\n+use rustc::ty::cast::CastKind;\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, compare_lit_exprs};\n use rustc_const_eval::{eval_const_expr_partial, lookup_const_by_id};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n@@ -71,12 +71,12 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mode: Mode,\n     qualif: ConstQualif,\n-    rvalue_borrows: NodeMap<hir::Mutability>\n+    rvalue_borrows: NodeMap<hir::Mutability>,\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n-    fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R where\n-        F: FnOnce(&mut CheckCrateVisitor<'a, 'gcx>) -> R,\n+    fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R\n+        where F: FnOnce(&mut CheckCrateVisitor<'a, 'gcx>) -> R\n     {\n         let (old_mode, old_qualif) = (self.mode, self.qualif);\n         self.mode = mode;\n@@ -87,17 +87,17 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         r\n     }\n \n-    fn with_euv<F, R>(&mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n-        F: for<'b, 'tcx> FnOnce(&mut euv::ExprUseVisitor<'b, 'gcx, 'tcx>) -> R,\n+    fn with_euv<F, R>(&mut self, item_id: Option<ast::NodeId>, f: F) -> R\n+        where F: for<'b, 'tcx> FnOnce(&mut euv::ExprUseVisitor<'b, 'gcx, 'tcx>) -> R\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n-            None => self.tcx.empty_parameter_environment()\n+            None => self.tcx.empty_parameter_environment(),\n         };\n \n-        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal).enter(|infcx| {\n-            f(&mut euv::ExprUseVisitor::new(self, &infcx))\n-        })\n+        self.tcx\n+            .infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal)\n+            .enter(|infcx| f(&mut euv::ExprUseVisitor::new(self, &infcx)))\n     }\n \n     fn global_expr(&mut self, mode: Mode, expr: &hir::Expr) -> ConstQualif {\n@@ -111,13 +111,17 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         }\n         if let Err(err) = eval_const_expr_partial(self.tcx, expr, ExprTypeChecked, None) {\n             match err.kind {\n-                UnimplementedConstVal(_) => {},\n-                IndexOpFeatureGated => {},\n-                ErroneousReferencedConstant(_) => {},\n-                _ => self.tcx.sess.add_lint(CONST_ERR, expr.id, expr.span,\n-                                         format!(\"constant evaluation error: {}. This will \\\n-                                                 become a HARD ERROR in the future\",\n-                                                 err.description().into_oneline())),\n+                UnimplementedConstVal(_) => {}\n+                IndexOpFeatureGated => {}\n+                ErroneousReferencedConstant(_) => {}\n+                _ => {\n+                    self.tcx.sess.add_lint(CONST_ERR,\n+                                           expr.id,\n+                                           expr.span,\n+                                           format!(\"constant evaluation error: {}. This will \\\n+                                                    become a HARD ERROR in the future\",\n+                                                   err.description().into_oneline()))\n+                }\n             }\n         }\n         self.with_mode(mode, |this| {\n@@ -143,17 +147,15 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         }\n \n         let mode = match fk {\n-            FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _, _) => {\n-                Mode::ConstFn\n-            }\n+            FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _, _) => Mode::ConstFn,\n             FnKind::Method(_, m, _, _) => {\n                 if m.constness == hir::Constness::Const {\n                     Mode::ConstFn\n                 } else {\n                     Mode::Var\n                 }\n             }\n-            _ => Mode::Var\n+            _ => Mode::Var,\n         };\n \n         let qualif = self.with_mode(mode, |this| {\n@@ -175,11 +177,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     }\n \n     /// Returns true if the call is to a const fn or method.\n-    fn handle_const_fn_call(&mut self,\n-                            _expr: &hir::Expr,\n-                            def_id: DefId,\n-                            ret_ty: Ty<'gcx>)\n-                            -> bool {\n+    fn handle_const_fn_call(&mut self, _expr: &hir::Expr, def_id: DefId, ret_ty: Ty<'gcx>) -> bool {\n         if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n             let qualif = self.fn_like(fn_like.kind(),\n                                       fn_like.decl(),\n@@ -285,13 +283,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     Ok(Ordering::Less) |\n                     Ok(Ordering::Equal) => {}\n                     Ok(Ordering::Greater) => {\n-                        span_err!(self.tcx.sess, start.span, E0030,\n-                            \"lower range bound must be less than or equal to upper\");\n+                        span_err!(self.tcx.sess,\n+                                  start.span,\n+                                  E0030,\n+                                  \"lower range bound must be less than or equal to upper\");\n                     }\n                     Err(ErrorReported) => {}\n                 }\n             }\n-            _ => intravisit::walk_pat(self, p)\n+            _ => intravisit::walk_pat(self, p),\n         }\n     }\n \n@@ -301,13 +301,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n             match stmt.node {\n                 hir::StmtDecl(ref decl, _) => {\n                     match decl.node {\n-                        hir::DeclLocal(_) => {},\n+                        hir::DeclLocal(_) => {}\n                         // Item statements are allowed\n-                        hir::DeclItem(_) => continue\n+                        hir::DeclItem(_) => continue,\n                     }\n                 }\n-                hir::StmtExpr(_, _) => {},\n-                hir::StmtSemi(_, _) => {},\n+                hir::StmtExpr(_, _) => {}\n+                hir::StmtSemi(_, _) => {}\n             }\n             self.add_qualif(ConstQualif::NOT_CONST);\n         }\n@@ -340,7 +340,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // The count is checked elsewhere (typeck).\n                 let count = match node_ty.sty {\n                     ty::TyArray(_, n) => n,\n-                    _ => bug!()\n+                    _ => bug!(),\n                 };\n                 // [element; 0] is always zero-sized.\n                 if count == 0 {\n@@ -354,7 +354,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 for pat in arms.iter().flat_map(|arm| &arm.pats) {\n                     let pat_borrow = self.rvalue_borrows.remove(&pat.id);\n                     match (borrow, pat_borrow) {\n-                        (None, _) | (_, Some(hir::MutMutable)) => {\n+                        (None, _) |\n+                        (_, Some(hir::MutMutable)) => {\n                             borrow = pat_borrow;\n                         }\n                         _ => {}\n@@ -365,7 +366,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 }\n                 intravisit::walk_expr(self, ex);\n             }\n-            _ => intravisit::walk_expr(self, ex)\n+            _ => intravisit::walk_expr(self, ex),\n         }\n \n         // Handle borrows on (or inside the autorefs of) this expression.\n@@ -405,17 +406,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         if self.mode == Mode::Var && !self.qualif.intersects(ConstQualif::NOT_CONST) {\n             match eval_const_expr_partial(self.tcx, ex, ExprTypeChecked, None) {\n                 Ok(_) => {}\n-                Err(ConstEvalErr { kind: UnimplementedConstVal(_), ..}) |\n-                Err(ConstEvalErr { kind: MiscCatchAll, ..}) |\n-                Err(ConstEvalErr { kind: MiscBinaryOp, ..}) |\n-                Err(ConstEvalErr { kind: NonConstPath, ..}) |\n-                Err(ConstEvalErr { kind: UnresolvedPath, ..}) |\n-                Err(ConstEvalErr { kind: ErroneousReferencedConstant(_), ..}) |\n-                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), ..}) |\n-                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), ..}) |\n-                Err(ConstEvalErr { kind: IndexOpFeatureGated, ..}) => {},\n+                Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n+                Err(ConstEvalErr { kind: MiscCatchAll, .. }) |\n+                Err(ConstEvalErr { kind: MiscBinaryOp, .. }) |\n+                Err(ConstEvalErr { kind: NonConstPath, .. }) |\n+                Err(ConstEvalErr { kind: UnresolvedPath, .. }) |\n+                Err(ConstEvalErr { kind: ErroneousReferencedConstant(_), .. }) |\n+                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), .. }) |\n+                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), .. }) |\n+                Err(ConstEvalErr { kind: IndexOpFeatureGated, .. }) => {}\n                 Err(msg) => {\n-                    self.tcx.sess.add_lint(CONST_ERR, ex.id,\n+                    self.tcx.sess.add_lint(CONST_ERR,\n+                                           ex.id,\n                                            msg.span,\n                                            msg.description().into_oneline().into_owned())\n                 }\n@@ -434,8 +436,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n /// every nested expression. If the expression is not part\n /// of a const/static item, it is qualified for promotion\n /// instead of producing errors.\n-fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n-                        e: &hir::Expr, node_ty: Ty<'tcx>) {\n+fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyStruct(def, _) |\n         ty::TyEnum(def, _) if def.has_dtor() => {\n@@ -635,25 +636,23 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n         Some(&ty::adjustment::AdjustUnsafeFnPointer) |\n         Some(&ty::adjustment::AdjustMutToConstPointer) => {}\n \n-        Some(&ty::adjustment::AdjustDerefRef(\n-            ty::adjustment::AutoDerefRef { autoderefs, .. }\n-        )) => {\n-            if (0..autoderefs as u32).any(|autoderef| {\n-                    v.tcx.is_overloaded_autoderef(e.id, autoderef)\n-            }) {\n+        Some(&ty::adjustment::AdjustDerefRef(ty::adjustment::AutoDerefRef { autoderefs, .. })) => {\n+            if (0..autoderefs as u32)\n+                .any(|autoderef| v.tcx.is_overloaded_autoderef(e.id, autoderef)) {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n             }\n         }\n     }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::CheckConst, &mut CheckCrateVisitor {\n-        tcx: tcx,\n-        mode: Mode::Var,\n-        qualif: ConstQualif::NOT_CONST,\n-        rvalue_borrows: NodeMap()\n-    });\n+    tcx.visit_all_items_in_krate(DepNode::CheckConst,\n+                                 &mut CheckCrateVisitor {\n+                                     tcx: tcx,\n+                                     mode: Mode::Var,\n+                                     qualif: ConstQualif::NOT_CONST,\n+                                     rvalue_borrows: NodeMap(),\n+                                 });\n     tcx.sess.abort_if_errors();\n }\n \n@@ -675,7 +674,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n \n                 Categorization::Rvalue(..) |\n                 Categorization::Upvar(..) |\n-                Categorization::Local(..) => break\n+                Categorization::Local(..) => break,\n             }\n         }\n     }\n@@ -685,8 +684,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n               cmt: mc::cmt<'tcx>,\n               _loan_region: ty::Region,\n               bk: ty::BorrowKind,\n-              loan_cause: euv::LoanCause)\n-    {\n+              loan_cause: euv::LoanCause) {\n         // Kind of hacky, but we allow Unsafe coercions in constants.\n         // These occur when we convert a &T or *T to a *U, as well as\n         // when making a thin pointer (e.g., `*T`) into a fat pointer\n@@ -695,7 +693,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n             euv::LoanCause::AutoUnsafe => {\n                 return;\n             }\n-            _ => { }\n+            _ => {}\n         }\n \n         let mut cur = &cmt;\n@@ -715,7 +713,8 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n                         // type of the expression.  `&mut [1]` has exactly the\n                         // same representation as &mut 1.\n                         match cmt.ty.sty {\n-                            ty::TyArray(_, _) | ty::TySlice(_) => break,\n+                            ty::TyArray(_, _) |\n+                            ty::TySlice(_) => break,\n                             _ => {}\n                         }\n                     }\n@@ -732,27 +731,20 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n                 }\n \n                 Categorization::Upvar(..) |\n-                Categorization::Local(..) => break\n+                Categorization::Local(..) => break,\n             }\n         }\n     }\n \n-    fn decl_without_init(&mut self,\n-                         _id: ast::NodeId,\n-                         _span: Span) {}\n+    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n     fn mutate(&mut self,\n               _assignment_id: ast::NodeId,\n               _assignment_span: Span,\n               _assignee_cmt: mc::cmt,\n-              _mode: euv::MutateMode) {}\n+              _mode: euv::MutateMode) {\n+    }\n \n-    fn matched_pat(&mut self,\n-                   _: &hir::Pat,\n-                   _: mc::cmt,\n-                   _: euv::MatchMode) {}\n+    fn matched_pat(&mut self, _: &hir::Pat, _: mc::cmt, _: euv::MatchMode) {}\n \n-    fn consume_pat(&mut self,\n-                   _consume_pat: &hir::Pat,\n-                   _cmt: mc::cmt,\n-                   _mode: euv::ConsumeMode) {}\n+    fn consume_pat(&mut self, _consume_pat: &hir::Pat, _cmt: mc::cmt, _mode: euv::ConsumeMode) {}\n }"}, {"sha": "e59c4a6fc4186bfbb9664dcf7042a630ce574de9", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=a6c9404c29805858608d397d0b1a09ef4af4747d", "patch": "@@ -28,12 +28,15 @@\n #![feature(rustc_private)]\n \n extern crate core;\n-#[macro_use] extern crate rustc;\n+#[macro_use]\n+extern crate rustc;\n extern crate rustc_const_eval;\n extern crate rustc_const_math;\n \n-#[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n "}, {"sha": "4e251793f6917ae645fc6c14c7581aa26c3f658d", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=a6c9404c29805858608d397d0b1a09ef4af4747d", "patch": "@@ -19,19 +19,24 @@ use syntax_pos::Span;\n \n #[derive(Clone, Copy, PartialEq)]\n enum Context {\n-    Normal, Loop, Closure\n+    Normal,\n+    Loop,\n+    Closure,\n }\n \n #[derive(Copy, Clone)]\n struct CheckLoopVisitor<'a> {\n     sess: &'a Session,\n-    cx: Context\n+    cx: Context,\n }\n \n pub fn check_crate(sess: &Session, map: &Map) {\n     let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n     let krate = map.krate();\n-    krate.visit_all_items(&mut CheckLoopVisitor { sess: sess, cx: Normal });\n+    krate.visit_all_items(&mut CheckLoopVisitor {\n+        sess: sess,\n+        cx: Normal,\n+    });\n }\n \n impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n@@ -53,14 +58,14 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n             }\n             hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n             hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n-            _ => intravisit::walk_expr(self, e)\n+            _ => intravisit::walk_expr(self, e),\n         }\n     }\n }\n \n impl<'a> CheckLoopVisitor<'a> {\n-    fn with_context<F>(&mut self, cx: Context, f: F) where\n-        F: FnOnce(&mut CheckLoopVisitor<'a>),\n+    fn with_context<F>(&mut self, cx: Context, f: F)\n+        where F: FnOnce(&mut CheckLoopVisitor<'a>)\n     {\n         let old_cx = self.cx;\n         self.cx = cx;\n@@ -72,12 +77,10 @@ impl<'a> CheckLoopVisitor<'a> {\n         match self.cx {\n             Loop => {}\n             Closure => {\n-                span_err!(self.sess, span, E0267,\n-                                   \"`{}` inside of a closure\", name);\n+                span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name);\n             }\n             Normal => {\n-                span_err!(self.sess, span, E0268,\n-                                   \"`{}` outside of loop\", name);\n+                span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name);\n             }\n         }\n     }"}, {"sha": "af3065d64e8db08bc7fd8ee36cca33a93971fff3", "filename": "src/librustc_passes/no_asm.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Fno_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Fno_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fno_asm.rs?ref=a6c9404c29805858608d397d0b1a09ef4af4747d", "patch": "@@ -19,9 +19,11 @@ use syntax::visit::Visitor;\n use syntax::visit;\n \n pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n-    if sess.target.target.options.allow_asm { return; }\n+    if sess.target.target.options.allow_asm {\n+        return;\n+    }\n \n-    visit::walk_crate(&mut CheckNoAsm { sess: sess, }, krate);\n+    visit::walk_crate(&mut CheckNoAsm { sess: sess }, krate);\n }\n \n #[derive(Copy, Clone)]\n@@ -32,9 +34,13 @@ struct CheckNoAsm<'a> {\n impl<'a> Visitor for CheckNoAsm<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprKind::InlineAsm(_) => span_err!(self.sess, e.span, E0472,\n-                                                     \"asm! is unsupported on this target\"),\n-            _ => {},\n+            ast::ExprKind::InlineAsm(_) => {\n+                span_err!(self.sess,\n+                          e.span,\n+                          E0472,\n+                          \"asm! is unsupported on this target\")\n+            }\n+            _ => {}\n         }\n         visit::walk_expr(self, e)\n     }"}, {"sha": "8b2943a33c006aaced7fd7cee377a241ff187467", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c9404c29805858608d397d0b1a09ef4af4747d/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=a6c9404c29805858608d397d0b1a09ef4af4747d", "patch": "@@ -13,11 +13,11 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as ast_map;\n-use rustc::session::{Session, CompileResult};\n+use rustc::session::{CompileResult, Session};\n use rustc::hir::def::{Def, DefMap};\n use rustc::util::nodemap::NodeMap;\n \n-use syntax::{ast};\n+use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor};\n@@ -41,18 +41,17 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n         match it.node {\n             hir::ItemStatic(..) |\n             hir::ItemConst(..) => {\n-                let mut recursion_visitor =\n-                    CheckItemRecursionVisitor::new(self, &it.span);\n+                let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &it.span);\n                 recursion_visitor.visit_item(it);\n-            },\n+            }\n             hir::ItemEnum(ref enum_def, ref generics) => {\n                 // We could process the whole enum, but handling the variants\n                 // with discriminant expressions one by one gives more specific,\n                 // less redundant output.\n                 for variant in &enum_def.variants {\n                     if let Some(_) = variant.node.disr_expr {\n-                        let mut recursion_visitor =\n-                            CheckItemRecursionVisitor::new(self, &variant.span);\n+                        let mut recursion_visitor = CheckItemRecursionVisitor::new(self,\n+                                                                                   &variant.span);\n                         recursion_visitor.populate_enum_discriminants(enum_def);\n                         recursion_visitor.visit_variant(variant, generics, it.id);\n                     }\n@@ -67,8 +66,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n         match ti.node {\n             hir::ConstTraitItem(_, ref default) => {\n                 if let Some(_) = *default {\n-                    let mut recursion_visitor =\n-                        CheckItemRecursionVisitor::new(self, &ti.span);\n+                    let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &ti.span);\n                     recursion_visitor.visit_trait_item(ti);\n                 }\n             }\n@@ -80,8 +78,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n     fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Const(..) => {\n-                let mut recursion_visitor =\n-                    CheckItemRecursionVisitor::new(self, &ii.span);\n+                let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &ii.span);\n                 recursion_visitor.visit_impl_item(ii);\n             }\n             _ => {}\n@@ -117,7 +114,8 @@ struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n }\n \n impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n-    fn new(v: &'a CheckCrateVisitor<'a, 'ast>, span: &'a Span)\n+    fn new(v: &'a CheckCrateVisitor<'a, 'ast>,\n+           span: &'a Span)\n            -> CheckItemRecursionVisitor<'a, 'ast> {\n         CheckItemRecursionVisitor {\n             root_span: span,\n@@ -129,7 +127,8 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n         }\n     }\n     fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F)\n-          where F: Fn(&mut Self) {\n+        where F: Fn(&mut Self)\n+    {\n         if self.idstack.iter().any(|&x| x == id) {\n             let any_static = self.idstack.iter().any(|&x| {\n                 if let ast_map::NodeItem(item) = self.ast_map.get(x) {\n@@ -146,7 +145,9 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n                 if !self.sess.features.borrow().static_recursion {\n                     emit_feature_err(&self.sess.parse_sess.span_diagnostic,\n                                      \"static_recursion\",\n-                                     *self.root_span, GateIssue::Language, \"recursive static\");\n+                                     *self.root_span,\n+                                     GateIssue::Language,\n+                                     \"recursive static\");\n                 }\n             } else {\n                 span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n@@ -170,7 +171,9 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n         // has no variants.\n         let mut discriminant_map = self.discriminant_map.borrow_mut();\n         match enum_definition.variants.first() {\n-            None => { return; }\n+            None => {\n+                return;\n+            }\n             Some(variant) if discriminant_map.contains_key(&variant.node.data.id()) => {\n                 return;\n             }\n@@ -203,14 +206,19 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n         self.with_item_id_pushed(it.id, |v| intravisit::walk_item(v, it));\n     }\n \n-    fn visit_enum_def(&mut self, enum_definition: &'ast hir::EnumDef,\n-                      generics: &'ast hir::Generics, item_id: ast::NodeId, _: Span) {\n+    fn visit_enum_def(&mut self,\n+                      enum_definition: &'ast hir::EnumDef,\n+                      generics: &'ast hir::Generics,\n+                      item_id: ast::NodeId,\n+                      _: Span) {\n         self.populate_enum_discriminants(enum_definition);\n         intravisit::walk_enum_def(self, enum_definition, generics, item_id);\n     }\n \n-    fn visit_variant(&mut self, variant: &'ast hir::Variant,\n-                     _: &'ast hir::Generics, _: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     variant: &'ast hir::Variant,\n+                     _: &'ast hir::Generics,\n+                     _: ast::NodeId) {\n         let variant_id = variant.node.data.id();\n         let maybe_expr;\n         if let Some(get_expr) = self.discriminant_map.borrow().get(&variant_id) {\n@@ -246,18 +254,14 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     Some(Def::Const(def_id)) => {\n                         if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n                             match self.ast_map.get(node_id) {\n-                                ast_map::NodeItem(item) =>\n-                                    self.visit_item(item),\n-                                ast_map::NodeTraitItem(item) =>\n-                                    self.visit_trait_item(item),\n-                                ast_map::NodeImplItem(item) =>\n-                                    self.visit_impl_item(item),\n-                                ast_map::NodeForeignItem(_) => {},\n+                                ast_map::NodeItem(item) => self.visit_item(item),\n+                                ast_map::NodeTraitItem(item) => self.visit_trait_item(item),\n+                                ast_map::NodeImplItem(item) => self.visit_impl_item(item),\n+                                ast_map::NodeForeignItem(_) => {}\n                                 _ => {\n-                                    span_bug!(\n-                                        e.span,\n-                                        \"expected item, found {}\",\n-                                        self.ast_map.node_to_string(node_id));\n+                                    span_bug!(e.span,\n+                                              \"expected item, found {}\",\n+                                              self.ast_map.node_to_string(node_id));\n                                 }\n                             }\n                         }\n@@ -268,9 +272,9 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // might be (if any).\n                     Some(Def::Variant(enum_id, variant_id)) => {\n                         if let Some(enum_node_id) = self.ast_map.as_local_node_id(enum_id) {\n-                            if let hir::ItemEnum(ref enum_def, ref generics) =\n-                                self.ast_map.expect_item(enum_node_id).node\n-                            {\n+                            if let hir::ItemEnum(ref enum_def, ref generics) = self.ast_map\n+                                .expect_item(enum_node_id)\n+                                .node {\n                                 self.populate_enum_discriminants(enum_def);\n                                 let enum_id = self.ast_map.as_local_node_id(enum_id).unwrap();\n                                 let variant_id = self.ast_map.as_local_node_id(variant_id).unwrap();\n@@ -283,10 +287,10 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                             }\n                         }\n                     }\n-                    _ => ()\n+                    _ => (),\n                 }\n-            },\n-            _ => ()\n+            }\n+            _ => (),\n         }\n         intravisit::walk_expr(self, e);\n     }"}]}