{"sha": "697fdc568e28fbb376567eda4edb2c2a05db68de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5N2ZkYzU2OGUyOGZiYjM3NjU2N2VkYTRlZGIyYzJhMDVkYjY4ZGU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-01-22T07:01:21Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-01-26T18:57:18Z"}, "message": "Suggest defining type parameter when appropriate\n\n```\nerror[E0412]: cannot find type `T` in this scope\n --> file.rs:3:12\n  |\n3 | impl Trait<T> for Struct {}\n  |     -      ^ not found in this scope\n  |     |\n  |     help: you might be missing a type parameter: `<T>`\n```\n\nFix #64298.", "tree": {"sha": "2353388fac15725d1de0ef61d3c729dda69ba9ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2353388fac15725d1de0ef61d3c729dda69ba9ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/697fdc568e28fbb376567eda4edb2c2a05db68de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/697fdc568e28fbb376567eda4edb2c2a05db68de", "html_url": "https://github.com/rust-lang/rust/commit/697fdc568e28fbb376567eda4edb2c2a05db68de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/697fdc568e28fbb376567eda4edb2c2a05db68de/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ad83afe5bcfa983a24b6f720c9ef389350f414b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad83afe5bcfa983a24b6f720c9ef389350f414b", "html_url": "https://github.com/rust-lang/rust/commit/8ad83afe5bcfa983a24b6f720c9ef389350f414b"}], "stats": {"total": 244, "additions": 178, "deletions": 66}, "files": [{"sha": "b762e0b08ac044bbeb420814fb5428aac5c26ee8", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -1415,11 +1415,15 @@ crate fn show_candidates(\n     better: bool,\n     found_use: bool,\n ) {\n+    if candidates.is_empty() {\n+        return;\n+    }\n     // we want consistent results across executions, but candidates are produced\n     // by iterating through a hash map, so make sure they are ordered:\n     let mut path_strings: Vec<_> =\n         candidates.into_iter().map(|c| path_names_to_string(&c.path)).collect();\n     path_strings.sort();\n+    path_strings.dedup();\n \n     let better = if better { \"better \" } else { \"\" };\n     let msg_diff = match path_strings.len() {\n@@ -1444,6 +1448,7 @@ crate fn show_candidates(\n             msg.push('\\n');\n             msg.push_str(&candidate);\n         }\n+        err.note(&msg);\n     }\n }\n "}, {"sha": "faa9eb3bc2fa7ae8dca55e22db975c120651ef30", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 61, "deletions": 49, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -323,7 +323,7 @@ impl<'a> PathSource<'a> {\n }\n \n #[derive(Default)]\n-struct DiagnosticMetadata {\n+struct DiagnosticMetadata<'ast> {\n     /// The current trait's associated types' ident, used for diagnostic suggestions.\n     current_trait_assoc_types: Vec<Ident>,\n \n@@ -333,6 +333,13 @@ struct DiagnosticMetadata {\n     /// The current self item if inside an ADT (used for better errors).\n     current_self_item: Option<NodeId>,\n \n+    /// The current trait (used to suggest).\n+    current_item: Option<&'ast Item>,\n+\n+    /// When processing generics and encountering a type not found, suggest introducing a type\n+    /// param.\n+    currently_processing_generics: bool,\n+\n     /// The current enclosing function (used for better errors).\n     current_function: Option<Span>,\n \n@@ -347,7 +354,7 @@ struct DiagnosticMetadata {\n     current_let_binding: Option<(Span, Option<Span>, Option<Span>)>,\n }\n \n-struct LateResolutionVisitor<'a, 'b> {\n+struct LateResolutionVisitor<'a, 'b, 'ast> {\n     r: &'b mut Resolver<'a>,\n \n     /// The module that represents the current item scope.\n@@ -364,30 +371,32 @@ struct LateResolutionVisitor<'a, 'b> {\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n \n     /// Fields used to add information to diagnostic errors.\n-    diagnostic_metadata: DiagnosticMetadata,\n+    diagnostic_metadata: DiagnosticMetadata<'ast>,\n }\n \n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n-impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n-    fn visit_item(&mut self, item: &'tcx Item) {\n+impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n+    fn visit_item(&mut self, item: &'ast Item) {\n+        let prev = replace(&mut self.diagnostic_metadata.current_item, Some(item));\n         self.resolve_item(item);\n+        self.diagnostic_metadata.current_item = prev;\n     }\n-    fn visit_arm(&mut self, arm: &'tcx Arm) {\n+    fn visit_arm(&mut self, arm: &'ast Arm) {\n         self.resolve_arm(arm);\n     }\n-    fn visit_block(&mut self, block: &'tcx Block) {\n+    fn visit_block(&mut self, block: &'ast Block) {\n         self.resolve_block(block);\n     }\n-    fn visit_anon_const(&mut self, constant: &'tcx AnonConst) {\n+    fn visit_anon_const(&mut self, constant: &'ast AnonConst) {\n         debug!(\"visit_anon_const {:?}\", constant);\n         self.with_constant_rib(|this| {\n             visit::walk_anon_const(this, constant);\n         });\n     }\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.resolve_expr(expr, None);\n     }\n-    fn visit_local(&mut self, local: &'tcx Local) {\n+    fn visit_local(&mut self, local: &'ast Local) {\n         let local_spans = match local.pat.kind {\n             // We check for this to avoid tuple struct fields.\n             PatKind::Wild => None,\n@@ -401,7 +410,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         self.resolve_local(local);\n         self.diagnostic_metadata.current_let_binding = original;\n     }\n-    fn visit_ty(&mut self, ty: &'tcx Ty) {\n+    fn visit_ty(&mut self, ty: &'ast Ty) {\n         match ty.kind {\n             TyKind::Path(ref qself, ref path) => {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n@@ -417,7 +426,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         }\n         visit::walk_ty(self, ty);\n     }\n-    fn visit_poly_trait_ref(&mut self, tref: &'tcx PolyTraitRef, m: &'tcx TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, tref: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n         self.smart_resolve_path(\n             tref.trait_ref.ref_id,\n             None,\n@@ -426,7 +435,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         );\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n-    fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         match foreign_item.kind {\n             ForeignItemKind::Fn(_, ref generics) => {\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n@@ -443,7 +452,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             }\n         }\n     }\n-    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, sp: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'ast>, declaration: &'ast FnDecl, sp: Span, _: NodeId) {\n         let previous_value = replace(&mut self.diagnostic_metadata.current_function, Some(sp));\n         debug!(\"(resolving function) entering function\");\n         let rib_kind = match fn_kind {\n@@ -472,7 +481,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         self.diagnostic_metadata.current_function = previous_value;\n     }\n \n-    fn visit_generics(&mut self, generics: &'tcx Generics) {\n+    fn visit_generics(&mut self, generics: &'ast Generics) {\n         // For type parameter defaults, we have to ban access\n         // to following type parameters, as the InternalSubsts can only\n         // provide previous type parameters as they're built. We\n@@ -534,11 +543,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn visit_generic_arg(&mut self, arg: &'tcx GenericArg) {\n+    fn visit_generic_arg(&mut self, arg: &'ast GenericArg) {\n         debug!(\"visit_generic_arg({:?})\", arg);\n+        let prev = replace(&mut self.diagnostic_metadata.currently_processing_generics, true);\n         match arg {\n             GenericArg::Type(ref ty) => {\n-                // We parse const arguments as path types as we cannot distiguish them durring\n+                // We parse const arguments as path types as we cannot distiguish them during\n                 // parsing. We try to resolve that ambiguity by attempting resolution the type\n                 // namespace first, and if that fails we try again in the value namespace. If\n                 // resolution in the value namespace succeeds, we have an generic const argument on\n@@ -556,7 +566,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                             )\n                             .is_some()\n                         };\n-\n                         if !check_ns(TypeNS) && check_ns(ValueNS) {\n                             // This must be equivalent to `visit_anon_const`, but we cannot call it\n                             // directly due to visitor lifetimes so we have to copy-paste some code.\n@@ -574,6 +583,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                                 this.visit_path(path, ty.id);\n                             });\n \n+                            self.diagnostic_metadata.currently_processing_generics = prev;\n                             return;\n                         }\n                     }\n@@ -584,11 +594,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n             GenericArg::Const(ct) => self.visit_anon_const(ct),\n         }\n+        self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n }\n \n-impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n-    fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b> {\n+impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n+    fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b, 'ast> {\n         // During late resolution we only track the module component of the parent scope,\n         // although it may be useful to track other components as well for diagnostics.\n         let graph_root = resolver.graph_root;\n@@ -724,7 +735,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         None\n     }\n \n-    fn resolve_adt(&mut self, item: &Item, generics: &Generics) {\n+    fn resolve_adt(&mut self, item: &'ast Item, generics: &'ast Generics) {\n         debug!(\"resolve_adt\");\n         self.with_current_self_item(item, |this| {\n             this.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n@@ -778,7 +789,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn resolve_item(&mut self, item: &Item) {\n+    fn resolve_item(&mut self, item: &'ast Item) {\n         let name = item.ident.name;\n         debug!(\"(resolving item) resolving {} ({:?})\", name, item.kind);\n \n@@ -1024,16 +1035,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             let path: Vec<_> = Segment::from_path(&trait_ref.path);\n-            let res = self\n-                .smart_resolve_path_fragment(\n-                    trait_ref.ref_id,\n-                    None,\n-                    &path,\n-                    trait_ref.path.span,\n-                    PathSource::Trait(AliasPossibility::No),\n-                    CrateLint::SimplePath(trait_ref.ref_id),\n-                )\n-                .base_res();\n+            let res = self.smart_resolve_path_fragment(\n+                trait_ref.ref_id,\n+                None,\n+                &path,\n+                trait_ref.path.span,\n+                PathSource::Trait(AliasPossibility::No),\n+                CrateLint::SimplePath(trait_ref.ref_id),\n+            );\n+            let res = res.base_res();\n             if res != Res::Err {\n                 new_id = Some(res.def_id());\n                 let span = trait_ref.path.span;\n@@ -1070,11 +1080,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn resolve_implementation(\n         &mut self,\n-        generics: &Generics,\n-        opt_trait_reference: &Option<TraitRef>,\n-        self_type: &Ty,\n+        generics: &'ast Generics,\n+        opt_trait_reference: &'ast Option<TraitRef>,\n+        self_type: &'ast Ty,\n         item_id: NodeId,\n-        impl_items: &[AssocItem],\n+        impl_items: &'ast [AssocItem],\n     ) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n@@ -1179,7 +1189,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn resolve_params(&mut self, params: &[Param]) {\n+    fn resolve_params(&mut self, params: &'ast [Param]) {\n         let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n         for Param { pat, ty, .. } in params {\n             self.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n@@ -1188,7 +1198,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn resolve_local(&mut self, local: &Local) {\n+    fn resolve_local(&mut self, local: &'ast Local) {\n         // Resolve the type.\n         walk_list!(self, visit_ty, &local.ty);\n \n@@ -1307,7 +1317,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     /// Check the consistency of the outermost or-patterns.\n-    fn check_consistent_bindings_top(&mut self, pat: &Pat) {\n+    fn check_consistent_bindings_top(&mut self, pat: &'ast Pat) {\n         pat.walk(&mut |pat| match pat.kind {\n             PatKind::Or(ref ps) => {\n                 self.check_consistent_bindings(ps);\n@@ -1317,7 +1327,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         })\n     }\n \n-    fn resolve_arm(&mut self, arm: &Arm) {\n+    fn resolve_arm(&mut self, arm: &'ast Arm) {\n         self.with_rib(ValueNS, NormalRibKind, |this| {\n             this.resolve_pattern_top(&arm.pat, PatternSource::Match);\n             walk_list!(this, visit_expr, &arm.guard);\n@@ -1326,14 +1336,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     /// Arising from `source`, resolve a top level pattern.\n-    fn resolve_pattern_top(&mut self, pat: &Pat, pat_src: PatternSource) {\n+    fn resolve_pattern_top(&mut self, pat: &'ast Pat, pat_src: PatternSource) {\n         let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n         self.resolve_pattern(pat, pat_src, &mut bindings);\n     }\n \n     fn resolve_pattern(\n         &mut self,\n-        pat: &Pat,\n+        pat: &'ast Pat,\n         pat_src: PatternSource,\n         bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n     ) {\n@@ -1544,7 +1554,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         id: NodeId,\n         qself: Option<&QSelf>,\n         path: &Path,\n-        source: PathSource<'_>,\n+        source: PathSource<'ast>,\n     ) {\n         self.smart_resolve_path_fragment(\n             id,\n@@ -1562,7 +1572,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         qself: Option<&QSelf>,\n         path: &[Segment],\n         span: Span,\n-        source: PathSource<'_>,\n+        source: PathSource<'ast>,\n         crate_lint: CrateLint,\n     ) -> PartialRes {\n         let ns = source.namespace();\n@@ -1573,7 +1583,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             let def_id = this.parent_scope.module.normal_ancestor_id;\n             let node_id = this.r.definitions.as_local_node_id(def_id).unwrap();\n             let better = res.is_some();\n-            this.r.use_injections.push(UseError { err, candidates, node_id, better });\n+            let suggestion =\n+                if res.is_none() { this.report_missing_type_error(path) } else { None };\n+            this.r.use_injections.push(UseError { err, candidates, node_id, better, suggestion });\n             PartialRes::new(Res::Err)\n         };\n \n@@ -1838,11 +1850,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn resolve_labeled_block(&mut self, label: Option<Label>, id: NodeId, block: &Block) {\n+    fn resolve_labeled_block(&mut self, label: Option<Label>, id: NodeId, block: &'ast Block) {\n         self.with_resolved_label(label, id, |this| this.visit_block(block));\n     }\n \n-    fn resolve_block(&mut self, block: &Block) {\n+    fn resolve_block(&mut self, block: &'ast Block) {\n         debug!(\"(resolving block) entering block\");\n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.parent_scope.module;\n@@ -1885,7 +1897,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n+    fn resolve_expr(&mut self, expr: &'ast Expr, parent: Option<&'ast Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -2023,7 +2035,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n+    fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &'ast Expr) {\n         match expr.kind {\n             ExprKind::Field(_, ident) => {\n                 // FIXME(#6890): Even though you can't treat a method like a"}, {"sha": "6ec4a13500edcf205175cbb048c22d36d745f9f9", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -12,9 +12,9 @@ use rustc_hir::def::{self, CtorKind, DefKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::PrimTy;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n-use syntax::ast::{self, Expr, ExprKind, Ident, NodeId, Path, Ty, TyKind};\n+use syntax::ast::{self, Expr, ExprKind, Ident, Item, ItemKind, NodeId, Path, Ty, TyKind};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use log::debug;\n@@ -51,7 +51,7 @@ fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, Str\n     (variant_path_string, enum_path_string)\n }\n \n-impl<'a> LateResolutionVisitor<'a, '_> {\n+impl<'a> LateResolutionVisitor<'a, '_, '_> {\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n     /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n     pub(crate) fn smart_resolve_report_errors(\n@@ -858,4 +858,49 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             variants\n         })\n     }\n+\n+    crate fn report_missing_type_error(\n+        &self,\n+        path: &[Segment],\n+    ) -> Option<(Span, &'static str, String, Applicability)> {\n+        let ident = match path {\n+            [segment] => segment.ident,\n+            _ => return None,\n+        };\n+        match (\n+            self.diagnostic_metadata.current_item,\n+            self.diagnostic_metadata.currently_processing_generics,\n+        ) {\n+            (Some(Item { kind: ItemKind::Fn(..), ident, .. }), true) if ident.name == sym::main => {\n+                // Ignore `fn main()` as we don't want to suggest `fn main<T>()`\n+            }\n+            (Some(Item { kind, .. }), true) => {\n+                // Likely missing type parameter.\n+                if let Some(generics) = kind.generics() {\n+                    let msg = \"you might be missing a type parameter\";\n+                    let (span, sugg) = if let [.., param] = &generics.params[..] {\n+                        let span = if let [.., bound] = &param.bounds[..] {\n+                            bound.span()\n+                        } else {\n+                            param.ident.span\n+                        };\n+                        (span, format!(\", {}\", ident))\n+                    } else {\n+                        (generics.span, format!(\"<{}>\", ident))\n+                    };\n+                    // Do not suggest if this is coming from macro expansion.\n+                    if !span.from_expansion() {\n+                        return Some((\n+                            span.shrink_to_hi(),\n+                            msg,\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        ));\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        None\n+    }\n }"}, {"sha": "0b1752419b889642d2622f56aa72e814b8e86caf", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -614,6 +614,8 @@ struct UseError<'a> {\n     node_id: NodeId,\n     /// Whether the diagnostic should state that it's \"better\".\n     better: bool,\n+    /// Extra free form suggestion. Currently used to suggest new type parameter.\n+    suggestion: Option<(Span, &'static str, String, Applicability)>,\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -2474,11 +2476,16 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn report_with_use_injections(&mut self, krate: &Crate) {\n-        for UseError { mut err, candidates, node_id, better } in self.use_injections.drain(..) {\n+        for UseError { mut err, candidates, node_id, better, suggestion } in\n+            self.use_injections.drain(..)\n+        {\n             let (span, found_use) = UsePlacementFinder::check(krate, node_id);\n             if !candidates.is_empty() {\n                 diagnostics::show_candidates(&mut err, span, &candidates, better, found_use);\n             }\n+            if let Some((span, msg, sugg, appl)) = suggestion {\n+                err.span_suggestion(span, msg, sugg, appl);\n+            }\n             err.emit();\n         }\n     }"}, {"sha": "5c64cc440cef3afc60233acda0061d8fd8cac685", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -2655,6 +2655,20 @@ impl ItemKind {\n             ItemKind::Mac(..) | ItemKind::MacroDef(..) | ItemKind::Impl { .. } => \"item\",\n         }\n     }\n+\n+    pub fn generics(&self) -> Option<&Generics> {\n+        match self {\n+            Self::Fn(_, generics, _)\n+            | Self::TyAlias(_, generics)\n+            | Self::Enum(_, generics)\n+            | Self::Struct(_, generics)\n+            | Self::Union(_, generics)\n+            | Self::Trait(_, _, generics, ..)\n+            | Self::TraitAlias(generics, _)\n+            | Self::Impl { generics, .. } => Some(generics),\n+            _ => None,\n+        }\n+    }\n }\n \n pub type ForeignItem = Item<ForeignItemKind>;"}, {"sha": "8fe8ceb4d0a6054bb6608c9f5d6c430e07aeb230", "filename": "src/test/ui/dyn-trait-compatibility.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fdyn-trait-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fdyn-trait-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-trait-compatibility.stderr?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -26,13 +26,17 @@ error[E0412]: cannot find type `dyn` in this scope\n   --> $DIR/dyn-trait-compatibility.rs:5:15\n    |\n LL | type A2 = dyn<dyn, dyn>;\n-   |               ^^^ not found in this scope\n+   |        -      ^^^ not found in this scope\n+   |        |\n+   |        help: you might be missing a type parameter: `<dyn>`\n \n error[E0412]: cannot find type `dyn` in this scope\n   --> $DIR/dyn-trait-compatibility.rs:5:20\n    |\n LL | type A2 = dyn<dyn, dyn>;\n-   |                    ^^^ not found in this scope\n+   |        -           ^^^ not found in this scope\n+   |        |\n+   |        help: you might be missing a type parameter: `<dyn>`\n \n error[E0412]: cannot find type `dyn` in this scope\n   --> $DIR/dyn-trait-compatibility.rs:9:11\n@@ -44,7 +48,9 @@ error[E0412]: cannot find type `dyn` in this scope\n   --> $DIR/dyn-trait-compatibility.rs:9:16\n    |\n LL | type A3 = dyn<<dyn as dyn>::dyn>;\n-   |                ^^^ not found in this scope\n+   |        -       ^^^ not found in this scope\n+   |        |\n+   |        help: you might be missing a type parameter: `<dyn>`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "f9fbf295aecc99b91f47f9facec8096f6c2faba3", "filename": "src/test/ui/hygiene/globs.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -4,11 +4,7 @@ error[E0425]: cannot find function `f` in this scope\n LL |         f();\n    |         ^ not found in this scope\n    |\n-help: possible candidates are found in other modules, you can import them into scope\n-   |\n-LL | use foo::f;\n-   |\n-LL | use foo::f;\n+help: possible candidate is found in another module, you can import it into scope\n    |\n LL | use foo::f;\n    |\n@@ -32,11 +28,8 @@ LL | use bar::g;\n    |\n LL | use foo::test2::test::g;\n    |\n-LL | use foo::test2::test::g;\n-   |\n LL | use foo::test::g;\n    |\n-     and 2 other candidates\n \n error[E0425]: cannot find function `f` in this scope\n   --> $DIR/globs.rs:61:12\n@@ -46,6 +39,9 @@ LL | n!(f);\n ...\n LL |         n!(f);\n    |            ^ not found in this scope\n+   |\n+   = note: possible candidate is found in another module, you can import it into scope:\n+           foo::f\n \n error[E0425]: cannot find function `f` in this scope\n   --> $DIR/globs.rs:65:17\n@@ -55,6 +51,9 @@ LL | n!(f);\n ...\n LL |                 f\n    |                 ^ not found in this scope\n+   |\n+   = note: possible candidate is found in another module, you can import it into scope:\n+           foo::f\n \n error: aborting due to 4 previous errors\n "}, {"sha": "87c16aa993b67c4780fcfaf01cca9058194a9bf7", "filename": "src/test/ui/issues/issue-58712.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fissues%2Fissue-58712.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fissues%2Fissue-58712.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58712.stderr?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -2,7 +2,9 @@ error[E0412]: cannot find type `DeviceId` in this scope\n   --> $DIR/issue-58712.rs:6:20\n    |\n LL | impl<H> AddrVec<H, DeviceId> {\n-   |                    ^^^^^^^^ not found in this scope\n+   |       -            ^^^^^^^^ not found in this scope\n+   |       |\n+   |       help: you might be missing a type parameter: `, DeviceId`\n \n error[E0412]: cannot find type `DeviceId` in this scope\n   --> $DIR/issue-58712.rs:8:29"}, {"sha": "66e9b78f6764a1e1dc7b538073f71646e77e279f", "filename": "src/test/ui/privacy/privacy-ns1.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.stderr?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -63,6 +63,10 @@ LL | use foo2::Bar;\n    |\n LL | use foo3::Bar;\n    |\n+help: you might be missing a type parameter\n+   |\n+LL | fn test_glob3<Bar>() {\n+   |              ^^^^^\n \n error[E0107]: wrong number of const arguments: expected 0, found 1\n   --> $DIR/privacy-ns1.rs:35:17"}, {"sha": "fe53fb242f49b13d620a7f841bd7c89db00f1f83", "filename": "src/test/ui/proc-macro/generate-mod.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -6,6 +6,9 @@ LL | generate_mod::check!();\n    | |\n    | not found in this scope\n    | in this macro invocation\n+   |\n+   = note: possible candidate is found in another module, you can import it into scope:\n+           FromOutside\n \n error[E0412]: cannot find type `Outer` in this scope\n   --> $DIR/generate-mod.rs:9:1\n@@ -15,18 +18,27 @@ LL | generate_mod::check!();\n    | |\n    | not found in this scope\n    | in this macro invocation\n+   |\n+   = note: possible candidate is found in another module, you can import it into scope:\n+           Outer\n \n error[E0412]: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:12:1\n    |\n LL | #[generate_mod::check_attr]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   |\n+   = note: possible candidate is found in another module, you can import it into scope:\n+           FromOutside\n \n error[E0412]: cannot find type `OuterAttr` in this scope\n   --> $DIR/generate-mod.rs:12:1\n    |\n LL | #[generate_mod::check_attr]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   |\n+   = note: possible candidate is found in another module, you can import it into scope:\n+           OuterAttr\n \n warning: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:16:10"}, {"sha": "0a73a269134ef6b39ad2227fb6abf3ecee5d9432", "filename": "src/test/ui/suggestions/no-extern-crate-in-type.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fsuggestions%2Fno-extern-crate-in-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Fsuggestions%2Fno-extern-crate-in-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fno-extern-crate-in-type.stderr?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -8,6 +8,10 @@ help: possible candidate is found in another module, you can import it into scop\n    |\n LL | use foo::Foo;\n    |\n+help: you might be missing a type parameter\n+   |\n+LL | type Output<Foo> = Option<Foo>;\n+   |            ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "cae41672eadb2a2e8079638cb99bcd946da059c5", "filename": "src/test/ui/type-alias/issue-62364-self-ty-arg.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Ftype-alias%2Fissue-62364-self-ty-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/697fdc568e28fbb376567eda4edb2c2a05db68de/src%2Ftest%2Fui%2Ftype-alias%2Fissue-62364-self-ty-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias%2Fissue-62364-self-ty-arg.stderr?ref=697fdc568e28fbb376567eda4edb2c2a05db68de", "patch": "@@ -2,7 +2,9 @@ error[E0411]: cannot find type `Self` in this scope\n   --> $DIR/issue-62364-self-ty-arg.rs:5:29\n    |\n LL | type Alias<'a> = Struct<&'a Self>;\n-   |                             ^^^^ `Self` is only available in impls, traits, and type definitions\n+   |              -              ^^^^ `Self` is only available in impls, traits, and type definitions\n+   |              |\n+   |              help: you might be missing a type parameter: `, Self`\n \n error: aborting due to previous error\n "}]}