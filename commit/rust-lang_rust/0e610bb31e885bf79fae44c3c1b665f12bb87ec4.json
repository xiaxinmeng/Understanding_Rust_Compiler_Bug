{"sha": "0e610bb31e885bf79fae44c3c1b665f12bb87ec4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNjEwYmIzMWU4ODViZjc5ZmFlNDRjM2MxYjY2NWYxMmJiODdlYzQ=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-08-14T20:52:23Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-08-14T20:52:23Z"}, "message": "Document the unsafe keyword", "tree": {"sha": "9c121f36897f676485f6edcce5c9f64d993f1905", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c121f36897f676485f6edcce5c9f64d993f1905"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e610bb31e885bf79fae44c3c1b665f12bb87ec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e610bb31e885bf79fae44c3c1b665f12bb87ec4", "html_url": "https://github.com/rust-lang/rust/commit/0e610bb31e885bf79fae44c3c1b665f12bb87ec4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e610bb31e885bf79fae44c3c1b665f12bb87ec4/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e21bd0633b8d970646ee6eb706c9e8acfad19af", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e21bd0633b8d970646ee6eb706c9e8acfad19af", "html_url": "https://github.com/rust-lang/rust/commit/8e21bd0633b8d970646ee6eb706c9e8acfad19af"}], "stats": {"total": 184, "additions": 181, "deletions": 3}, "files": [{"sha": "c39989a60c92b5c62d4615de8c46192064f45963", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 181, "deletions": 3, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/0e610bb31e885bf79fae44c3c1b665f12bb87ec4/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e610bb31e885bf79fae44c3c1b665f12bb87ec4/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=0e610bb31e885bf79fae44c3c1b665f12bb87ec4", "patch": "@@ -1813,12 +1813,190 @@ mod type_keyword {}\n \n #[doc(keyword = \"unsafe\")]\n //\n-/// Code or interfaces whose [memory safety] cannot be verified by the type system.\n+/// Code or interfaces whose [memory safety] cannot be verified by the type\n+/// system.\n+///\n+/// The `unsafe` keyword has two uses: to declare the existence of contracts the\n+/// compiler can't check (`unsafe fn` and `unsafe trait`), and to declare that a\n+/// programmer has checked that these contracts have been upheld (`unsafe {}`\n+/// and `unsafe impl`, but also `unsafe fn` -- see below). They are not mutually\n+/// exclusive, as can be seen in `unsafe fn`.\n+///\n+/// # Unsafe abilities\n+///\n+/// **No matter what, Safe Rust can't cause Undefined Behavior**. This is\n+/// referred to as [soundness]: a well-typed program actually has the desired\n+/// properties. The [Nomicon][nomicon-soundness] has a more detailed explanation\n+/// on the subject.\n+///\n+/// To ensure soundness, Safe Rust is restricted enough that it can be\n+/// automatically checked. Sometimes, however, it is necessary to write code\n+/// that is correct for reasons which are too clever for the compiler to\n+/// understand. In those cases, you need to use Unsafe Rust.\n+///\n+/// Here are the abilities Unsafe Rust has in addition to Safe Rust:\n+///\n+/// - Dereference [raw pointers]\n+/// - Implement `unsafe` [`trait`]s\n+/// - Call `unsafe` functions\n+/// - Mutate [`static`]s (including [`extern`]al ones)\n+/// - Access fields of [`union`]s\n+///\n+/// However, this extra power comes with extra responsibilities: it is now up to\n+/// you to ensure soundness. The `unsafe` keyword helps by clearly marking the\n+/// pieces of code that need to worry about this.\n+///\n+/// ## The different meanings of `unsafe`\n+///\n+/// Not all uses of `unsafe` are equivalent: some are here to mark the existence\n+/// of a contract the programmer must check, others are to say \"I have checked\n+/// the contract, go ahead and do this\". The following\n+/// [discussion on Rust Internals] has more in-depth explanations about this but\n+/// here is a summary of the main points:\n+///\n+/// - `unsafe fn`: calling this function means abiding by a contract the\n+/// compiler cannot enforce.\n+/// - `unsafe trait`: implementing the [`trait`] means abiding by a\n+/// contract the compiler cannot enforce.\n+/// - `unsafe {}`: the contract necessary to call the operations inside the\n+/// block has been checked by the programmer and is guaranteed to be respected.\n+/// - `unsafe impl`: the contract necessary to implement the trait has been\n+/// checked by the programmer and is guaranteed to be respected.\n+///\n+/// `unsafe fn` also acts like an `unsafe {}` block\n+/// around the code inside the function. This means it is not just a signal to\n+/// the caller, but also promises that the preconditions for the operations\n+/// inside the function are upheld. Mixing these two meanings can be confusing\n+/// and [proposal]s exist to use `unsafe {}` blocks inside such functions when\n+/// making `unsafe` operations.\n+///\n+/// See the [Rustnomicon] and the [Reference] for more informations.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// # Examples\n+///\n+/// ## Marking elements as `unsafe`\n+///\n+/// `unsafe` can be used on functions. Note that functions and statics declared\n+/// in [`extern`] blocks are implicitly marked as `unsafe` (but not functions\n+/// declared as `extern \"something\" fn ...`). Mutable statics are always unsafe,\n+/// wherever they are declared. Methods can also be declared as `unsafe`:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// static mut FOO: &str = \"hello\";\n+///\n+/// unsafe fn unsafe_fn() {}\n+///\n+/// extern \"C\" {\n+///     fn unsafe_extern_fn();\n+///     static BAR: *mut u32;\n+/// }\n+///\n+/// trait SafeTraitWithUnsafeMethod {\n+///     unsafe fn unsafe_method(&self);\n+/// }\n+///\n+/// struct S;\n+///\n+/// impl S {\n+///     unsafe fn unsafe_method_on_struct() {}\n+/// }\n+/// ```\n+///\n+/// Traits can also be declared as `unsafe`:\n+///\n+/// ```rust\n+/// unsafe trait UnsafeTrait {}\n+/// ```\n ///\n+/// Since `unsafe fn` and `unsafe trait` indicate that there is a safety\n+/// contract that the compiler cannot enforce, documenting it is important. The\n+/// standard library has many examples of this, like the following which is an\n+/// extract from [`Vec::set_len`]. The `# Safety` section explains the contract\n+/// that must be fulfilled to safely call the function.\n+///\n+/// ```rust,ignore (stub-to-show-doc-example)\n+/// /// Forces the length of the vector to `new_len`.\n+/// ///\n+/// /// This is a low-level operation that maintains none of the normal\n+/// /// invariants of the type. Normally changing the length of a vector\n+/// /// is done using one of the safe operations instead, such as\n+/// /// `truncate`, `resize`, `extend`, or `clear`.\n+/// ///\n+/// /// # Safety\n+/// ///\n+/// /// - `new_len` must be less than or equal to `capacity()`.\n+/// /// - The elements at `old_len..new_len` must be initialized.\n+/// pub unsafe fn set_len(&mut self, new_len: usize)\n+/// ```\n+///\n+/// ## Using `unsafe {}` blocks and `impl`s\n+///\n+/// Performing `unsafe` operations requires an `unsafe {}` block:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// /// Dereference the given pointer.\n+/// ///\n+/// /// # Safety\n+/// ///\n+/// /// `ptr` must be aligned and must not be dangling.\n+/// unsafe fn deref_unchecked(ptr: *const i32) -> i32 {\n+///     *ptr\n+/// }\n+///\n+/// let a = 3;\n+/// let b = &a as *const _;\n+/// // SAFETY: `a` has not been dropped and references are always aligned,\n+/// // so `b` is a valid address.\n+/// unsafe { assert_eq!(*b, deref_unchecked(b)); };\n+/// ```\n+///\n+/// Traits marked as `unsafe` must be [`impl`]emented using `unsafe impl`. This\n+/// makes a guarantee to other `unsafe` code that the implementation satisfies\n+/// the trait's safety contract. The [Send] and [Sync] traits are examples of\n+/// this behaviour in the standard library.\n+///\n+/// ```rust\n+/// /// Implementors of this trait must guarantee an element is always\n+/// /// accessible with index 3.\n+/// unsafe trait ThreeIndexable<T> {\n+///     /// Returns a reference to the element with index 3 in `&self`.\n+///     fn three(&self) -> &T;\n+/// }\n+///\n+/// // The implementation of `ThreeIndexable` for `[T; 4]` is `unsafe`\n+/// // because the implementor must abide by a contract the compiler cannot\n+/// // check but as a programmer we know there will always be a valid element\n+/// // at index 3 to access.\n+/// unsafe impl<T> ThreeIndexable<T> for [T; 4] {\n+///     fn three(&self) -> &T {\n+///         // SAFETY: implementing the trait means there always is an element\n+///         // with index 3 accessible.\n+///         unsafe { self.get_unchecked(3) }\n+///     }\n+/// }\n+///\n+/// let a = [1, 2, 4, 8];\n+/// assert_eq!(a.three(), &8);\n+/// ```\n+///\n+/// [`extern`]: keyword.extern.html\n+/// [`trait`]: keyword.trait.html\n+/// [`static`]: keyword.static.html\n+/// [`union`]: keyword.union.html\n+/// [`impl`]: keyword.impl.html\n+/// [Send]: marker/trait.Send.html\n+/// [Sync]: marker/trait.Sync.html\n+/// [`Vec::set_len`]: vec/struct.Vec.html#method.set_len\n+/// [raw pointers]: ../reference/types/pointer.html\n /// [memory safety]: ../book/ch19-01-unsafe-rust.html\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// [Rustnomicon]: ../nomicon/index.html\n+/// [nomicon-soundness]: ../nomicon/safe-unsafe-meaning.html\n+/// [soundness]: https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library\n+/// [Reference]: ../reference/unsafety.html\n+/// [proposal]: https://github.com/rust-lang/rfcs/pull/2585\n+/// [discussion on Rust Internals]: https://internals.rust-lang.org/t/what-does-unsafe-mean/6696\n mod unsafe_keyword {}\n \n #[doc(keyword = \"use\")]"}]}