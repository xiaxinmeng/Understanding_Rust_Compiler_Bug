{"sha": "bb5960aa57a04920614fce021c6792ad8a9a0305", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNTk2MGFhNTdhMDQ5MjA2MTRmY2UwMjFjNjc5MmFkOGE5YTAzMDU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-02-22T22:00:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-29T01:56:15Z"}, "message": "moving new uv stuff into uv.rs and rust_uv.cpp\n\n- removing the remains of uvtmp.rs and rust_uvtmp.rs\n- removing the displaced, low-level libuv bindings\nin uv.rs and rust_uv.cpp", "tree": {"sha": "0ab7ded812141b2a858e623d39af36e9034f7788", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ab7ded812141b2a858e623d39af36e9034f7788"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb5960aa57a04920614fce021c6792ad8a9a0305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5960aa57a04920614fce021c6792ad8a9a0305", "html_url": "https://github.com/rust-lang/rust/commit/bb5960aa57a04920614fce021c6792ad8a9a0305", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb5960aa57a04920614fce021c6792ad8a9a0305/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf08ed64584cd13eb3fb98ca07d3e3b987103c16", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf08ed64584cd13eb3fb98ca07d3e3b987103c16", "html_url": "https://github.com/rust-lang/rust/commit/cf08ed64584cd13eb3fb98ca07d3e3b987103c16"}], "stats": {"total": 2242, "additions": 691, "deletions": 1551}, "files": [{"sha": "83e4a04f0dfa06d7378f5a7ffc2657553d151674", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb5960aa57a04920614fce021c6792ad8a9a0305/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bb5960aa57a04920614fce021c6792ad8a9a0305/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=bb5960aa57a04920614fce021c6792ad8a9a0305", "patch": "@@ -7,7 +7,7 @@\n #[license = \"MIT\"];\n #[crate_type = \"lib\"];\n \n-export fs, io, net, run, uv, uvtmp;\n+export fs, io, net, run, uv;\n export c_vec, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n@@ -25,7 +25,6 @@ mod net;\n #[path =  \"run_program.rs\"]\n mod run;\n mod uv;\n-mod uvtmp;\n \n \n // Utility modules"}, {"sha": "90ac5ce4b1cfba451234f6de5be25d92e9f57043", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 520, "deletions": 150, "changes": 670, "blob_url": "https://github.com/rust-lang/rust/blob/bb5960aa57a04920614fce021c6792ad8a9a0305/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5960aa57a04920614fce021c6792ad8a9a0305/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=bb5960aa57a04920614fce021c6792ad8a9a0305", "patch": "@@ -1,188 +1,558 @@\n-/*\n-This is intended to be a low-level binding to libuv that very closely mimics\n-the C libuv API. Does very little right now pending scheduler improvements.\n-*/\n-\n-export sanity_check;\n-export loop_t, idle_t;\n-export loop_new, loop_delete, default_loop, run, unref;\n-export idle_init, idle_start;\n-export idle_new;\n-\n-import core::ctypes;\n-\n-#[link_name = \"rustrt\"]\n-native mod uv {\n-    fn rust_uv_loop_new() -> *loop_t;\n-    fn rust_uv_loop_delete(loop: *loop_t);\n-    fn rust_uv_default_loop() -> *loop_t;\n-    fn rust_uv_run(loop: *loop_t) -> ctypes::c_int;\n-    fn rust_uv_unref(loop: *loop_t);\n-    fn rust_uv_idle_init(loop: *loop_t, idle: *idle_t) -> ctypes::c_int;\n-    fn rust_uv_idle_start(idle: *idle_t, cb: idle_cb) -> ctypes::c_int;\n-}\n-\n-#[link_name = \"rustrt\"]\n-native mod helpers {\n-    fn rust_uv_size_of_idle_t() -> ctypes::size_t;\n-}\n-\n-type opaque_cb = *ctypes::void;\n-\n-type handle_type = ctypes::enum;\n-\n-type close_cb = opaque_cb;\n-type idle_cb = opaque_cb;\n-\n-type handle_private_fields = {\n-    a00: ctypes::c_int,\n-    a01: ctypes::c_int,\n-    a02: ctypes::c_int,\n-    a03: ctypes::c_int,\n-    a04: ctypes::c_int,\n-    a05: ctypes::c_int,\n-    a06: int,\n-    a07: int,\n-    a08: int,\n-    a09: int,\n-    a10: int,\n-    a11: int,\n-    a12: int\n-};\n-\n-type handle_fields = {\n-    loop: *loop_t,\n-    type_: handle_type,\n-    close_cb: close_cb,\n-    data: *ctypes::void,\n-    private: handle_private_fields\n-};\n-\n-type handle_t = {\n-    fields: handle_fields\n-};\n+export loop_new, run, close, run_in_bg, async_init, async_send,\n+       timer_init, timer_start, timer_stop;\n+\n+// these are processed solely in the\n+// process_operation() crust fn below\n+enum uv_operation {\n+    op_async_init([u8]),\n+    op_close(uv_handle, *ctypes::void),\n+    op_timer_init([u8]),\n+    op_timer_start([u8], *ctypes::void, u32, u32),\n+    op_timer_stop([u8], *ctypes::void, fn~(uv_handle))\n+}\n \n-type loop_t = int;\n+enum uv_handle {\n+    uv_async([u8], uv_loop),\n+    uv_timer([u8], uv_loop)\n+}\n \n+enum uv_msg {\n+    // requests from library users\n+    msg_run(comm::chan<bool>),\n+    msg_run_in_bg(),\n+    msg_async_init(fn~(uv_handle), fn~(uv_handle)),\n+    msg_async_send([u8]),\n+    msg_close(uv_handle, fn~()),\n+    msg_timer_init(fn~(uv_handle)),\n+    msg_timer_start([u8], u32, u32, fn~(uv_handle)),\n+    msg_timer_stop([u8], fn~(uv_handle)),\n+\n+    // dispatches from libuv\n+    uv_async_init([u8], *ctypes::void),\n+    uv_async_send([u8]),\n+    uv_close([u8]),\n+    uv_timer_init([u8], *ctypes::void),\n+    uv_timer_call([u8]),\n+    uv_timer_stop([u8], fn~(uv_handle)),\n+    uv_end()\n+}\n \n+type uv_loop_data = {\n+    operation_port: comm::port<uv_operation>,\n+    rust_loop_chan: comm::chan<uv_msg>\n+};\n \n+type uv_loop = comm::chan<uv_msg>;\n+\n+#[nolink]\n+native mod rustrt {\n+    fn rust_uv_loop_new() -> *ctypes::void;\n+    fn rust_uv_loop_set_data(\n+        loop: *ctypes::void,\n+        data: *uv_loop_data);\n+    fn rust_uv_bind_op_cb(loop: *ctypes::void, cb: *u8)\n+        -> *ctypes::void;\n+    fn rust_uv_stop_op_cb(handle: *ctypes::void);\n+    fn rust_uv_run(loop_handle: *ctypes::void);\n+    fn rust_uv_close(handle: *ctypes::void, cb: *u8);\n+    fn rust_uv_close_async(handle: *ctypes::void);\n+    fn rust_uv_close_timer(handle: *ctypes::void);\n+    fn rust_uv_async_send(handle: *ctypes::void);\n+    fn rust_uv_async_init(\n+        loop_handle: *ctypes::void,\n+        cb: *u8,\n+        id: *u8) -> *ctypes::void;\n+    fn rust_uv_timer_init(\n+        loop_handle: *ctypes::void,\n+        cb: *u8,\n+        id: *u8) -> *ctypes::void;\n+    fn rust_uv_timer_start(\n+        timer_handle: *ctypes::void,\n+        timeout: ctypes::c_uint,\n+        repeat: ctypes::c_uint);\n+    fn rust_uv_timer_stop(handle: *ctypes::void);\n+}\n \n-type idle_t = {\n-    fields: handle_fields\n-    /* private: idle_private_fields */\n-};\n+// public functions\n+fn loop_new() -> uv_loop unsafe {\n+    let ret_recv_port: comm::port<uv_loop> =\n+        comm::port();\n+    let ret_recv_chan: comm::chan<uv_loop> =\n+        comm::chan(ret_recv_port);\n+\n+    task::spawn_sched(task::manual_threads(4u)) {||\n+        // our beloved uv_loop_t ptr\n+        let loop_handle = rustrt::\n+            rust_uv_loop_new();\n+\n+        // this port/chan pair are used to send messages to\n+        // libuv. libuv processes any pending messages on the\n+        // port (via crust) after receiving an async \"wakeup\"\n+        // on a special uv_async_t handle created below\n+        let operation_port = comm::port::<uv_operation>();\n+        let operation_chan = comm::chan::<uv_operation>(\n+            operation_port);\n+\n+        // this port/chan pair as used in the while() loop\n+        // below. It takes dispatches, originating from libuv\n+        // callbacks, to invoke handles registered by the\n+        // user\n+        let rust_loop_port = comm::port::<uv_msg>();\n+        let rust_loop_chan =\n+            comm::chan::<uv_msg>(rust_loop_port);\n+        // let the task-spawner return\n+        comm::send(ret_recv_chan, copy(rust_loop_chan));\n+\n+        // create our \"special\" async handle that will\n+        // allow all operations against libuv to be\n+        // \"buffered\" in the operation_port, for processing\n+        // from the thread that libuv runs on\n+        let loop_data: uv_loop_data = {\n+            operation_port: operation_port,\n+            rust_loop_chan: rust_loop_chan\n+        };\n+        rustrt::rust_uv_loop_set_data(\n+            loop_handle,\n+            ptr::addr_of(loop_data)); // pass an opaque C-ptr\n+                                      // to libuv, this will be\n+                                      // in the process_operation\n+                                      // crust fn\n+        let op_handle = rustrt::rust_uv_bind_op_cb(\n+            loop_handle,\n+            process_operation);\n+\n+        // all state goes here\n+        let handles: map::map<[u8], *ctypes::void> =\n+            map::new_bytes_hash();\n+        let id_to_handle: map::map<[u8], uv_handle> =\n+            map::new_bytes_hash();\n+        let after_cbs: map::map<[u8], fn~(uv_handle)> =\n+            map::new_bytes_hash();\n+        let close_callbacks: map::map<[u8], fn~()> =\n+            map::new_bytes_hash();\n+        let async_cbs: map::map<[u8], fn~(uv_handle)> =\n+            map::new_bytes_hash();\n+        let timer_cbs: map::map<[u8], fn~(uv_handle)> =\n+            map::new_bytes_hash();\n+\n+        // the main loop that this task blocks on.\n+        // should have the same lifetime as the C libuv\n+        // event loop.\n+        let keep_going = true;\n+        while (keep_going) {\n+            alt comm::recv(rust_loop_port) {\n+              msg_run(end_chan) {\n+                // start the libuv event loop\n+                // we'll also do a uv_async_send with\n+                // the operation handle to have the\n+                // loop process any pending operations\n+                // once its up and running\n+                task::spawn_sched(task::manual_threads(1u)) {||\n+                    // this call blocks\n+                    rustrt::rust_uv_run(loop_handle);\n+                    // when we're done, msg the\n+                    // end chan\n+                    rustrt::rust_uv_stop_op_cb(op_handle);\n+                    comm::send(end_chan, true);\n+                    comm::send(rust_loop_chan, uv_end);\n+                };\n+              }\n+\n+              msg_run_in_bg {\n+                task::spawn_sched(task::manual_threads(1u)) {||\n+                    // this call blocks\n+                    rustrt::rust_uv_run(loop_handle);\n+                };\n+              }\n+\n+              msg_close(handle, cb) {\n+                let id = get_id_from_handle(handle);\n+                close_callbacks.insert(id, cb);\n+                let handle_ptr = handles.get(id);\n+                let op = op_close(handle, handle_ptr);\n+\n+                pass_to_libuv(op_handle, operation_chan, op);\n+              }\n+              uv_close(id) {\n+                handles.remove(id);\n+                let handle = id_to_handle.get(id);\n+                id_to_handle.remove(id);\n+                alt handle {\n+                  uv_async(id, _) {\n+                    async_cbs.remove(id);\n+                  }\n+                  uv_timer(id, _) {\n+                    timer_cbs.remove(id);\n+                  }\n+                  _ {\n+                    fail \"unknown form of uv_handle encountered \"\n+                        + \"in uv_close handler\";\n+                  }\n+                }\n+                let cb = close_callbacks.get(id);\n+                close_callbacks.remove(id);\n+                task::spawn {||\n+                    cb();\n+                };\n+              }\n+\n+              msg_async_init(callback, after_cb) {\n+                // create a new async handle\n+                // with the id as the handle's\n+                // data and save the callback for\n+                // invocation on msg_async_send\n+                let id = gen_handle_id();\n+                async_cbs.insert(id, callback);\n+                after_cbs.insert(id, after_cb);\n+                let op = op_async_init(id);\n+                pass_to_libuv(op_handle, operation_chan, op);\n+              }\n+              uv_async_init(id, async_handle) {\n+                // libuv created a handle, which is\n+                // passed back to us. save it and\n+                // then invoke the supplied callback\n+                // for after completion\n+                handles.insert(id, async_handle);\n+                let after_cb = after_cbs.get(id);\n+                after_cbs.remove(id);\n+                let async = uv_async(id, rust_loop_chan);\n+                id_to_handle.insert(id, copy(async));\n+                task::spawn {||\n+                    after_cb(async);\n+                };\n+              }\n+\n+              msg_async_send(id) {\n+                let async_handle = handles.get(id);\n+                do_send(async_handle);\n+              }\n+              uv_async_send(id) {\n+                let async_cb = async_cbs.get(id);\n+                task::spawn {||\n+                    async_cb(uv_async(id, rust_loop_chan));\n+                };\n+              }\n+\n+              msg_timer_init(after_cb) {\n+                let id = gen_handle_id();\n+                after_cbs.insert(id, after_cb);\n+                let op = op_timer_init(id);\n+                pass_to_libuv(op_handle, operation_chan, op);\n+              }\n+              uv_timer_init(id, handle) {\n+                handles.insert(id, handle);\n+                let after_cb = after_cbs.get(id);\n+                after_cbs.remove(id);\n+                let new_timer = uv_timer(id, rust_loop_chan);\n+                id_to_handle.insert(id, copy(new_timer));\n+                task::spawn {||\n+                    after_cb(new_timer);\n+                };\n+              }\n+\n+              uv_timer_call(id) {\n+                let cb = timer_cbs.get(id);\n+                let the_timer = id_to_handle.get(id);\n+                task::spawn {||\n+                    cb(the_timer);\n+                };\n+              }\n+\n+              msg_timer_start(id, timeout, repeat, timer_call_cb) {\n+                timer_cbs.insert(id, timer_call_cb);\n+                let handle = handles.get(id);\n+                let op = op_timer_start(id, handle, timeout,\n+                                        repeat);\n+                pass_to_libuv(op_handle, operation_chan, op);\n+              }\n+\n+              msg_timer_stop(id, after_cb) {\n+                let handle = handles.get(id);\n+                let op = op_timer_stop(id, handle, after_cb);\n+                pass_to_libuv(op_handle, operation_chan, op);\n+              }\n+              uv_timer_stop(id, after_cb) {\n+                let the_timer = id_to_handle.get(id);\n+                after_cb(the_timer);\n+              }\n+\n+              uv_end() {\n+                keep_going = false;\n+              }\n+\n+              _ { fail \"unknown form of uv_msg received\"; }\n+            }\n+        }\n+    };\n+    ret comm::recv(ret_recv_port);\n+}\n \n-fn idle_init(loop: *loop_t, idle: *idle_t) -> ctypes::c_int {\n-    uv::rust_uv_idle_init(loop, idle)\n+fn run(loop: uv_loop) {\n+    let end_port = comm::port::<bool>();\n+    let end_chan = comm::chan::<bool>(end_port);\n+    comm::send(loop, msg_run(end_chan));\n+    comm::recv(end_port);\n }\n \n-fn idle_start(idle: *idle_t, cb: idle_cb) -> ctypes::c_int {\n-    uv::rust_uv_idle_start(idle, cb)\n+fn run_in_bg(loop: uv_loop) {\n+    comm::send(loop, msg_run_in_bg);\n }\n \n+fn async_init (\n+    loop: uv_loop,\n+    async_cb: fn~(uv_handle),\n+    after_cb: fn~(uv_handle)) {\n+    let msg = msg_async_init(async_cb, after_cb);\n+    comm::send(loop, msg);\n+}\n \n+fn async_send(async: uv_handle) {\n+    alt async {\n+      uv_async(id, loop) {\n+        comm::send(loop, msg_async_send(id));\n+      }\n+      _ {\n+        fail \"attempting to call async_send() with a\" +\n+            \" uv_async uv_handle\";\n+      }\n+    }\n+}\n \n+fn close(h: uv_handle, cb: fn~()) {\n+    let loop_chan = get_loop_chan_from_handle(h);\n+    comm::send(loop_chan, msg_close(h, cb));\n+}\n \n-fn default_loop() -> *loop_t {\n-    uv::rust_uv_default_loop()\n+fn timer_init(loop: uv_loop, after_cb: fn~(uv_handle)) {\n+    let msg = msg_timer_init(after_cb);\n+    comm::send(loop, msg);\n }\n \n-fn loop_new() -> *loop_t {\n-    uv::rust_uv_loop_new()\n+fn timer_start(the_timer: uv_handle, timeout: u32, repeat:u32,\n+               timer_cb: fn~(uv_handle)) {\n+    alt the_timer {\n+      uv_timer(id, loop_chan) {\n+        let msg = msg_timer_start(id, timeout, repeat, timer_cb);\n+        comm::send(loop_chan, msg);\n+      }\n+      _ {\n+        fail \"can only pass a uv_timer form of uv_handle to \"+\n+             \" uv::timer_start()\";\n+      }\n+    }\n }\n \n-fn loop_delete(loop: *loop_t) {\n-    uv::rust_uv_loop_delete(loop)\n+fn timer_stop(the_timer: uv_handle, after_cb: fn~(uv_handle)) {\n+    alt the_timer {\n+      uv_timer(id, loop_chan) {\n+        let msg = msg_timer_stop(id, after_cb);\n+        comm::send(loop_chan, msg);\n+      }\n+      _ {\n+        fail \"only uv_timer form is allowed in calls to \"+\n+             \" uv::timer_stop()\";\n+      }\n+    }\n }\n \n-fn run(loop: *loop_t) -> ctypes::c_int {\n-    uv::rust_uv_run(loop)\n+// internal functions\n+fn pass_to_libuv(\n+        op_handle: *ctypes::void,\n+        operation_chan: comm::chan<uv_operation>,\n+        op: uv_operation) unsafe {\n+    comm::send(operation_chan, copy(op));\n+    do_send(op_handle);\n+}\n+fn do_send(h: *ctypes::void) {\n+    rustrt::rust_uv_async_send(h);\n+}\n+fn gen_handle_id() -> [u8] {\n+    ret rand::mk_rng().gen_bytes(16u);\n+}\n+fn get_handle_id_from(buf: *u8) -> [u8] unsafe {\n+    ret vec::unsafe::from_buf(buf, 16u);\n }\n \n-fn unref(loop: *loop_t) {\n-    uv::rust_uv_unref(loop)\n+fn get_loop_chan_from_data(data: *uv_loop_data)\n+        -> uv_loop unsafe {\n+    ret (*data).rust_loop_chan;\n }\n \n+fn get_loop_chan_from_handle(handle: uv_handle)\n+    -> uv_loop {\n+    alt handle {\n+      uv_async(id,loop) | uv_timer(id,loop) {\n+        ret loop;\n+      }\n+      _ {\n+        fail \"unknown form of uv_handle for get_loop_chan_from \"\n+             + \" handle\";\n+      }\n+    }\n+}\n \n-fn sanity_check() {\n-    fn check_size(t: str, uv: ctypes::size_t, rust: ctypes::size_t) {\n-        #debug(\"size of %s: uv: %u, rust: %u\", t, uv, rust);\n-        assert uv <= rust;\n+fn get_id_from_handle(handle: uv_handle) -> [u8] {\n+    alt handle {\n+      uv_async(id,loop) | uv_timer(id,loop) {\n+        ret id;\n+      }\n+      _ {\n+        fail \"unknown form of uv_handle for get_id_from handle\";\n+      }\n     }\n-    check_size(\"idle_t\",\n-               helpers::rust_uv_size_of_idle_t(),\n-               sys::size_of::<idle_t>());\n-}\n-\n-fn handle_fields_new() -> handle_fields {\n-    {\n-        loop: ptr::null(),\n-        type_: 0u32,\n-        close_cb: ptr::null(),\n-        data: ptr::null(),\n-        private: {\n-            a00: 0i32,\n-            a01: 0i32,\n-            a02: 0i32,\n-            a03: 0i32,\n-            a04: 0i32,\n-            a05: 0i32,\n-            a06: 0,\n-            a07: 0,\n-            a08: 0,\n-            a09: 0,\n-            a10: 0,\n-            a11: 0,\n-            a12: 0\n+}\n+\n+// crust\n+crust fn process_operation(\n+        loop: *ctypes::void,\n+        data: *uv_loop_data) unsafe {\n+    let op_port = (*data).operation_port;\n+    let loop_chan = get_loop_chan_from_data(data);\n+    let op_pending = comm::peek(op_port);\n+    while(op_pending) {\n+        alt comm::recv(op_port) {\n+          op_async_init(id) {\n+            let id_ptr = vec::unsafe::to_ptr(id);\n+            let async_handle = rustrt::rust_uv_async_init(\n+                loop,\n+                process_async_send,\n+                id_ptr);\n+            comm::send(loop_chan, uv_async_init(\n+                id,\n+                async_handle));\n+          }\n+          op_close(handle, handle_ptr) {\n+            handle_op_close(handle, handle_ptr);\n+          }\n+          op_timer_init(id) {\n+            let id_ptr = vec::unsafe::to_ptr(id);\n+            let timer_handle = rustrt::rust_uv_timer_init(\n+                loop,\n+                process_timer_call,\n+                id_ptr);\n+            comm::send(loop_chan, uv_timer_init(\n+                id,\n+                timer_handle));\n+          }\n+          op_timer_start(id, handle, timeout, repeat) {\n+            rustrt::rust_uv_timer_start(handle, timeout,\n+                                              repeat);\n+          }\n+          op_timer_stop(id, handle, after_cb) {\n+            rustrt::rust_uv_timer_stop(handle);\n+            comm::send(loop_chan, uv_timer_stop(id, after_cb));\n+          }\n+          _ { fail \"unknown form of uv_operation received\"; }\n         }\n+        op_pending = comm::peek(op_port);\n     }\n }\n \n-fn idle_new() -> idle_t {\n-    {\n-        fields: handle_fields_new()\n+fn handle_op_close(handle: uv_handle, handle_ptr: *ctypes::void) {\n+    // it's just like im doing C\n+    alt handle {\n+      uv_async(id, loop) {\n+        let cb = process_close_async;\n+        rustrt::rust_uv_close(\n+            handle_ptr, cb);\n+      }\n+      uv_timer(id, loop) {\n+        let cb = process_close_timer;\n+        rustrt::rust_uv_close(\n+            handle_ptr, cb);\n+      }\n+      _ {\n+        fail \"unknown form of uv_handle encountered \" +\n+            \"in process_operation/op_close\";\n+      }\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n+crust fn process_async_send(id_buf: *u8, data: *uv_loop_data)\n+    unsafe {\n+    let handle_id = get_handle_id_from(id_buf);\n+    let loop_chan = get_loop_chan_from_data(data);\n+    comm::send(loop_chan, uv_async_send(handle_id));\n+}\n \n-    #[test]\n-    fn test_sanity_check() {\n-        sanity_check();\n-    }\n+crust fn process_timer_call(id_buf: *u8, data: *uv_loop_data)\n+    unsafe {\n+    let handle_id = get_handle_id_from(id_buf);\n+    let loop_chan = get_loop_chan_from_data(data);\n+    comm::send(loop_chan, uv_timer_call(handle_id));\n+}\n+\n+fn process_close_common(id: [u8], data: *uv_loop_data)\n+    unsafe {\n+    // notify the rust loop that their handle is closed, then\n+    // the caller will invoke a per-handle-type c++ func to\n+    // free allocated memory\n+    let loop_chan = get_loop_chan_from_data(data);\n+    comm::send(loop_chan, uv_close(id));\n+}\n \n-    // From test-ref.c\n-    mod test_ref {\n+crust fn process_close_async(\n+    id_buf: *u8,\n+    handle_ptr: *ctypes::void,\n+    data: *uv_loop_data)\n+    unsafe {\n+    let id = get_handle_id_from(id_buf);\n+    rustrt::rust_uv_close_async(handle_ptr);\n+    // at this point, the handle and its data has been\n+    // released. notify the rust loop to remove the\n+    // handle and its data and call the user-supplied\n+    // close cb\n+    process_close_common(id, data);\n+}\n \n-        #[test]\n-        fn ref() {\n-            let loop = loop_new();\n-            run(loop);\n-            loop_delete(loop);\n-        }\n+crust fn process_close_timer(\n+    id_buf: *u8,\n+    handle_ptr: *ctypes::void,\n+    data: *uv_loop_data)\n+    unsafe {\n+    let id = get_handle_id_from(id_buf);\n+    rustrt::rust_uv_close_timer(handle_ptr);\n+    process_close_common(id, data);\n+}\n \n-        #[test]\n-        fn idle_ref() {\n-            let loop = loop_new();\n-            let h = idle_new();\n-            idle_init(loop, ptr::addr_of(h));\n-            idle_start(ptr::addr_of(h), ptr::null());\n-            unref(loop);\n-            run(loop);\n-            loop_delete(loop);\n-        }\n \n-        #[test]\n-        fn async_ref() {\n-            /*\n-            let loop = loop_new();\n-            let h = async_new();\n-            async_init(loop, ptr::addr_of(h), ptr::null());\n-            unref(loop);\n-            run(loop);\n-            loop_delete(loop);\n-            */\n-        }\n-    }\n+#[test]\n+fn test_uv_new_loop_no_handles() {\n+    let test_loop = uv::loop_new();\n+    run(test_loop); // this should return immediately\n+                    // since there aren't any handles..\n }\n+\n+#[test]\n+fn test_uv_simple_async() {\n+    let test_loop = loop_new();\n+    let exit_port = comm::port::<bool>();\n+    let exit_chan = comm::chan::<bool>(exit_port);\n+    async_init(test_loop, {|new_async|\n+        close(new_async) {||\n+            comm::send(exit_chan, true);\n+        };\n+    }, {|new_async|\n+        async_send(new_async);\n+    });\n+    run(test_loop);\n+    assert comm::recv(exit_port);\n+}\n+\n+#[test]\n+fn test_uv_timer() {\n+    let test_loop = loop_new();\n+    let exit_port = comm::port::<bool>();\n+    let exit_chan = comm::chan::<bool>(exit_port);\n+    timer_init(test_loop) {|new_timer|\n+        timer_start(new_timer, 1u32, 0u32) {|started_timer|\n+            timer_stop(started_timer) {|stopped_timer|\n+                close(stopped_timer) {||\n+                    comm::send(exit_chan, true);\n+                };\n+            };\n+        };\n+    };\n+    run(test_loop);\n+    assert comm::recv(exit_port);\n+}\n\\ No newline at end of file"}, {"sha": "b64de837b095b14dc81512593690f7bb33382fe7", "filename": "src/libstd/uvtmp.rs", "status": "removed", "additions": 0, "deletions": 730, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/cf08ed64584cd13eb3fb98ca07d3e3b987103c16/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf08ed64584cd13eb3fb98ca07d3e3b987103c16/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=cf08ed64584cd13eb3fb98ca07d3e3b987103c16", "patch": "@@ -1,730 +0,0 @@\n-// Some temporary libuv hacks for servo\n-\n-// UV2\n-\n-// these are processed solely in the\n-// process_operation() crust fn below\n-enum uv_operation {\n-    op_async_init([u8]),\n-    op_close(uv_handle, *ctypes::void),\n-    op_timer_init([u8]),\n-    op_timer_start([u8], *ctypes::void, u32, u32),\n-    op_timer_stop([u8], *ctypes::void, fn~(uv_handle))\n-}\n-\n-enum uv_handle {\n-    uv_async([u8], uv_loop),\n-    uv_timer([u8], uv_loop)\n-}\n-\n-enum uv_msg {\n-    // requests from library users\n-    msg_run(comm::chan<bool>),\n-    msg_run_in_bg(),\n-    msg_async_init(fn~(uv_handle), fn~(uv_handle)),\n-    msg_async_send([u8]),\n-    msg_close(uv_handle, fn~()),\n-    msg_timer_init(fn~(uv_handle)),\n-    msg_timer_start([u8], u32, u32, fn~(uv_handle)),\n-    msg_timer_stop([u8], fn~(uv_handle)),\n-\n-    // dispatches from libuv\n-    uv_async_init([u8], *ctypes::void),\n-    uv_async_send([u8]),\n-    uv_close([u8]),\n-    uv_timer_init([u8], *ctypes::void),\n-    uv_timer_call([u8]),\n-    uv_timer_stop([u8], fn~(uv_handle)),\n-    uv_end()\n-}\n-\n-type uv_loop_data = {\n-    operation_port: comm::port<uv_operation>,\n-    rust_loop_chan: comm::chan<uv_msg>\n-};\n-\n-type uv_loop = comm::chan<uv_msg>;\n-\n-#[nolink]\n-native mod rustrt {\n-    fn rust_uvtmp_create_thread() -> thread;\n-    fn rust_uvtmp_start_thread(thread: thread);\n-    fn rust_uvtmp_join_thread(thread: thread);\n-    fn rust_uvtmp_delete_thread(thread: thread);\n-    fn rust_uvtmp_connect(\n-        thread: thread,\n-        req_id: u32,\n-        ip: str::sbuf,\n-        chan: comm::chan<iomsg>) -> connect_data;\n-    fn rust_uvtmp_close_connection(thread: thread, req_id: u32);\n-    fn rust_uvtmp_write(\n-        thread: thread,\n-        req_id: u32,\n-        buf: *u8,\n-        len: ctypes::size_t,\n-        chan: comm::chan<iomsg>);\n-    fn rust_uvtmp_read_start(\n-        thread: thread,\n-        req_id: u32,\n-        chan: comm::chan<iomsg>);\n-    fn rust_uvtmp_timer(\n-        thread: thread,\n-        timeout: u32,\n-        req_id: u32,\n-        chan: comm::chan<iomsg>);\n-    fn rust_uvtmp_delete_buf(buf: *u8);\n-    fn rust_uvtmp_get_req_id(cd: connect_data) -> u32;\n-\n-    fn rust_uvtmp_uv_loop_new() -> *ctypes::void;\n-    fn rust_uvtmp_uv_loop_set_data(\n-        loop: *ctypes::void,\n-        data: *uv_loop_data);\n-    fn rust_uvtmp_uv_bind_op_cb(loop: *ctypes::void, cb: *u8)\n-        -> *ctypes::void;\n-    fn rust_uvtmp_uv_stop_op_cb(handle: *ctypes::void);\n-    fn rust_uvtmp_uv_run(loop_handle: *ctypes::void);\n-    fn rust_uvtmp_uv_close(handle: *ctypes::void, cb: *u8);\n-    fn rust_uvtmp_uv_close_async(handle: *ctypes::void);\n-    fn rust_uvtmp_uv_close_timer(handle: *ctypes::void);\n-    fn rust_uvtmp_uv_async_send(handle: *ctypes::void);\n-    fn rust_uvtmp_uv_async_init(\n-        loop_handle: *ctypes::void,\n-        cb: *u8,\n-        id: *u8) -> *ctypes::void;\n-    fn rust_uvtmp_uv_timer_init(\n-        loop_handle: *ctypes::void,\n-        cb: *u8,\n-        id: *u8) -> *ctypes::void;\n-    fn rust_uvtmp_uv_timer_start(\n-        timer_handle: *ctypes::void,\n-        timeout: ctypes::c_uint,\n-        repeat: ctypes::c_uint);\n-    fn rust_uvtmp_uv_timer_stop(handle: *ctypes::void);\n-}\n-\n-mod uv {\n-    export loop_new, run, close, run_in_bg, async_init, async_send,\n-           timer_init, timer_start, timer_stop;\n-\n-    // public functions\n-    fn loop_new() -> uv_loop unsafe {\n-        let ret_recv_port: comm::port<uv_loop> =\n-            comm::port();\n-        let ret_recv_chan: comm::chan<uv_loop> =\n-            comm::chan(ret_recv_port);\n-\n-        task::spawn_sched(task::manual_threads(4u)) {||\n-            // our beloved uv_loop_t ptr\n-            let loop_handle = rustrt::\n-                rust_uvtmp_uv_loop_new();\n-\n-            // this port/chan pair are used to send messages to\n-            // libuv. libuv processes any pending messages on the\n-            // port (via crust) after receiving an async \"wakeup\"\n-            // on a special uv_async_t handle created below\n-            let operation_port = comm::port::<uv_operation>();\n-            let operation_chan = comm::chan::<uv_operation>(\n-                operation_port);\n-\n-            // this port/chan pair as used in the while() loop\n-            // below. It takes dispatches, originating from libuv\n-            // callbacks, to invoke handles registered by the\n-            // user\n-            let rust_loop_port = comm::port::<uv_msg>();\n-            let rust_loop_chan =\n-                comm::chan::<uv_msg>(rust_loop_port);\n-            // let the task-spawner return\n-            comm::send(ret_recv_chan, copy(rust_loop_chan));\n-\n-            // create our \"special\" async handle that will\n-            // allow all operations against libuv to be\n-            // \"buffered\" in the operation_port, for processing\n-            // from the thread that libuv runs on\n-            let loop_data: uv_loop_data = {\n-                operation_port: operation_port,\n-                rust_loop_chan: rust_loop_chan\n-            };\n-            rustrt::rust_uvtmp_uv_loop_set_data(\n-                loop_handle,\n-                ptr::addr_of(loop_data)); // pass an opaque C-ptr\n-                                          // to libuv, this will be\n-                                          // in the process_operation\n-                                          // crust fn\n-            let op_handle = rustrt::rust_uvtmp_uv_bind_op_cb(\n-                loop_handle,\n-                process_operation);\n-\n-            // all state goes here\n-            let handles: map::map<[u8], *ctypes::void> =\n-                map::new_bytes_hash();\n-            let id_to_handle: map::map<[u8], uv_handle> =\n-                map::new_bytes_hash();\n-            let after_cbs: map::map<[u8], fn~(uv_handle)> =\n-                map::new_bytes_hash();\n-            let close_callbacks: map::map<[u8], fn~()> =\n-                map::new_bytes_hash();\n-            let async_cbs: map::map<[u8], fn~(uv_handle)> =\n-                map::new_bytes_hash();\n-            let timer_cbs: map::map<[u8], fn~(uv_handle)> =\n-                map::new_bytes_hash();\n-\n-            // the main loop that this task blocks on.\n-            // should have the same lifetime as the C libuv\n-            // event loop.\n-            let keep_going = true;\n-            while (keep_going) {\n-                alt comm::recv(rust_loop_port) {\n-                  msg_run(end_chan) {\n-                    // start the libuv event loop\n-                    // we'll also do a uv_async_send with\n-                    // the operation handle to have the\n-                    // loop process any pending operations\n-                    // once its up and running\n-                    task::spawn_sched(task::manual_threads(1u)) {||\n-                        // this call blocks\n-                        rustrt::rust_uvtmp_uv_run(loop_handle);\n-                        // when we're done, msg the\n-                        // end chan\n-                        rustrt::rust_uvtmp_uv_stop_op_cb(op_handle);\n-                        comm::send(end_chan, true);\n-                        comm::send(rust_loop_chan, uv_end);\n-                    };\n-                  }\n-\n-                  msg_run_in_bg {\n-                    task::spawn_sched(task::manual_threads(1u)) {||\n-                        // this call blocks\n-                        rustrt::rust_uvtmp_uv_run(loop_handle);\n-                    };\n-                  }\n-\n-                  msg_close(handle, cb) {\n-                    let id = get_id_from_handle(handle);\n-                    close_callbacks.insert(id, cb);\n-                    let handle_ptr = handles.get(id);\n-                    let op = op_close(handle, handle_ptr);\n-\n-                    pass_to_libuv(op_handle, operation_chan, op);\n-                  }\n-                  uv_close(id) {\n-                    handles.remove(id);\n-                    let handle = id_to_handle.get(id);\n-                    id_to_handle.remove(id);\n-                    alt handle {\n-                      uv_async(id, _) {\n-                        async_cbs.remove(id);\n-                      }\n-                      uv_timer(id, _) {\n-                        timer_cbs.remove(id);\n-                      }\n-                      _ {\n-                        fail \"unknown form of uv_handle encountered \"\n-                            + \"in uv_close handler\";\n-                      }\n-                    }\n-                    let cb = close_callbacks.get(id);\n-                    close_callbacks.remove(id);\n-                    task::spawn {||\n-                        cb();\n-                    };\n-                  }\n-\n-                  msg_async_init(callback, after_cb) {\n-                    // create a new async handle\n-                    // with the id as the handle's\n-                    // data and save the callback for\n-                    // invocation on msg_async_send\n-                    let id = gen_handle_id();\n-                    async_cbs.insert(id, callback);\n-                    after_cbs.insert(id, after_cb);\n-                    let op = op_async_init(id);\n-                    pass_to_libuv(op_handle, operation_chan, op);\n-                  }\n-                  uv_async_init(id, async_handle) {\n-                    // libuv created a handle, which is\n-                    // passed back to us. save it and\n-                    // then invoke the supplied callback\n-                    // for after completion\n-                    handles.insert(id, async_handle);\n-                    let after_cb = after_cbs.get(id);\n-                    after_cbs.remove(id);\n-                    let async = uv_async(id, rust_loop_chan);\n-                    id_to_handle.insert(id, copy(async));\n-                    task::spawn {||\n-                        after_cb(async);\n-                    };\n-                  }\n-\n-                  msg_async_send(id) {\n-                    let async_handle = handles.get(id);\n-                    do_send(async_handle);\n-                  }\n-                  uv_async_send(id) {\n-                    let async_cb = async_cbs.get(id);\n-                    task::spawn {||\n-                        async_cb(uv_async(id, rust_loop_chan));\n-                    };\n-                  }\n-\n-                  msg_timer_init(after_cb) {\n-                    let id = gen_handle_id();\n-                    after_cbs.insert(id, after_cb);\n-                    let op = op_timer_init(id);\n-                    pass_to_libuv(op_handle, operation_chan, op);\n-                  }\n-                  uv_timer_init(id, handle) {\n-                    handles.insert(id, handle);\n-                    let after_cb = after_cbs.get(id);\n-                    after_cbs.remove(id);\n-                    let new_timer = uv_timer(id, rust_loop_chan);\n-                    id_to_handle.insert(id, copy(new_timer));\n-                    task::spawn {||\n-                        after_cb(new_timer);\n-                    };\n-                  }\n-\n-                  uv_timer_call(id) {\n-                    let cb = timer_cbs.get(id);\n-                    let the_timer = id_to_handle.get(id);\n-                    task::spawn {||\n-                        cb(the_timer);\n-                    };\n-                  }\n-\n-                  msg_timer_start(id, timeout, repeat, timer_call_cb) {\n-                    timer_cbs.insert(id, timer_call_cb);\n-                    let handle = handles.get(id);\n-                    let op = op_timer_start(id, handle, timeout,\n-                                            repeat);\n-                    pass_to_libuv(op_handle, operation_chan, op);\n-                  }\n-\n-                  msg_timer_stop(id, after_cb) {\n-                    let handle = handles.get(id);\n-                    let op = op_timer_stop(id, handle, after_cb);\n-                    pass_to_libuv(op_handle, operation_chan, op);\n-                  }\n-                  uv_timer_stop(id, after_cb) {\n-                    let the_timer = id_to_handle.get(id);\n-                    after_cb(the_timer);\n-                  }\n-\n-                  uv_end() {\n-                    keep_going = false;\n-                  }\n-\n-                  _ { fail \"unknown form of uv_msg received\"; }\n-                }\n-            }\n-        };\n-        ret comm::recv(ret_recv_port);\n-    }\n-\n-    fn run(loop: uv_loop) {\n-        let end_port = comm::port::<bool>();\n-        let end_chan = comm::chan::<bool>(end_port);\n-        comm::send(loop, msg_run(end_chan));\n-        comm::recv(end_port);\n-    }\n-\n-    fn run_in_bg(loop: uv_loop) {\n-        comm::send(loop, msg_run_in_bg);\n-    }\n-\n-    fn async_init (\n-        loop: uv_loop,\n-        async_cb: fn~(uv_handle),\n-        after_cb: fn~(uv_handle)) {\n-        let msg = msg_async_init(async_cb, after_cb);\n-        comm::send(loop, msg);\n-    }\n-\n-    fn async_send(async: uv_handle) {\n-        alt async {\n-          uv_async(id, loop) {\n-            comm::send(loop, msg_async_send(id));\n-          }\n-          _ {\n-            fail \"attempting to call async_send() with a\" +\n-                \" uv_async uv_handle\";\n-          }\n-        }\n-    }\n-\n-    fn close(h: uv_handle, cb: fn~()) {\n-        let loop_chan = get_loop_chan_from_handle(h);\n-        comm::send(loop_chan, msg_close(h, cb));\n-    }\n-\n-    fn timer_init(loop: uv_loop, after_cb: fn~(uv_handle)) {\n-        let msg = msg_timer_init(after_cb);\n-        comm::send(loop, msg);\n-    }\n-\n-    fn timer_start(the_timer: uv_handle, timeout: u32, repeat:u32,\n-                   timer_cb: fn~(uv_handle)) {\n-        alt the_timer {\n-          uv_timer(id, loop_chan) {\n-            let msg = msg_timer_start(id, timeout, repeat, timer_cb);\n-            comm::send(loop_chan, msg);\n-          }\n-          _ {\n-            fail \"can only pass a uv_timer form of uv_handle to \"+\n-                 \" uv::timer_start()\";\n-          }\n-        }\n-    }\n-\n-    fn timer_stop(the_timer: uv_handle, after_cb: fn~(uv_handle)) {\n-        alt the_timer {\n-          uv_timer(id, loop_chan) {\n-            let msg = msg_timer_stop(id, after_cb);\n-            comm::send(loop_chan, msg);\n-          }\n-          _ {\n-            fail \"only uv_timer form is allowed in calls to \"+\n-                 \" uv::timer_stop()\";\n-          }\n-        }\n-    }\n-\n-    // internal functions\n-    fn pass_to_libuv(\n-            op_handle: *ctypes::void,\n-            operation_chan: comm::chan<uv_operation>,\n-            op: uv_operation) unsafe {\n-        comm::send(operation_chan, copy(op));\n-        do_send(op_handle);\n-    }\n-    fn do_send(h: *ctypes::void) {\n-        rustrt::rust_uvtmp_uv_async_send(h);\n-    }\n-    fn gen_handle_id() -> [u8] {\n-        ret rand::mk_rng().gen_bytes(16u);\n-    }\n-    fn get_handle_id_from(buf: *u8) -> [u8] unsafe {\n-        ret vec::unsafe::from_buf(buf, 16u);\n-    }\n-\n-    fn get_loop_chan_from_data(data: *uv_loop_data)\n-            -> uv_loop unsafe {\n-        ret (*data).rust_loop_chan;\n-    }\n-\n-    fn get_loop_chan_from_handle(handle: uv_handle)\n-        -> uv_loop {\n-        alt handle {\n-          uv_async(id,loop) | uv_timer(id,loop) {\n-            ret loop;\n-          }\n-          _ {\n-            fail \"unknown form of uv_handle for get_loop_chan_from \"\n-                 + \" handle\";\n-          }\n-        }\n-    }\n-\n-    fn get_id_from_handle(handle: uv_handle) -> [u8] {\n-        alt handle {\n-          uv_async(id,loop) | uv_timer(id,loop) {\n-            ret id;\n-          }\n-          _ {\n-            fail \"unknown form of uv_handle for get_id_from handle\";\n-          }\n-        }\n-    }\n-\n-    // crust\n-    crust fn process_operation(\n-            loop: *ctypes::void,\n-            data: *uv_loop_data) unsafe {\n-        let op_port = (*data).operation_port;\n-        let loop_chan = get_loop_chan_from_data(data);\n-        let op_pending = comm::peek(op_port);\n-        while(op_pending) {\n-            alt comm::recv(op_port) {\n-              op_async_init(id) {\n-                let id_ptr = vec::unsafe::to_ptr(id);\n-                let async_handle = rustrt::rust_uvtmp_uv_async_init(\n-                    loop,\n-                    process_async_send,\n-                    id_ptr);\n-                comm::send(loop_chan, uv_async_init(\n-                    id,\n-                    async_handle));\n-              }\n-              op_close(handle, handle_ptr) {\n-                handle_op_close(handle, handle_ptr);\n-              }\n-              op_timer_init(id) {\n-                let id_ptr = vec::unsafe::to_ptr(id);\n-                let timer_handle = rustrt::rust_uvtmp_uv_timer_init(\n-                    loop,\n-                    process_timer_call,\n-                    id_ptr);\n-                comm::send(loop_chan, uv_timer_init(\n-                    id,\n-                    timer_handle));\n-              }\n-              op_timer_start(id, handle, timeout, repeat) {\n-                rustrt::rust_uvtmp_uv_timer_start(handle, timeout,\n-                                                  repeat);\n-              }\n-              op_timer_stop(id, handle, after_cb) {\n-                rustrt::rust_uvtmp_uv_timer_stop(handle);\n-                comm::send(loop_chan, uv_timer_stop(id, after_cb));\n-              }\n-              _ { fail \"unknown form of uv_operation received\"; }\n-            }\n-            op_pending = comm::peek(op_port);\n-        }\n-    }\n-\n-    fn handle_op_close(handle: uv_handle, handle_ptr: *ctypes::void) {\n-        // it's just like im doing C\n-        alt handle {\n-          uv_async(id, loop) {\n-            let cb = process_close_async;\n-            rustrt::rust_uvtmp_uv_close(\n-                handle_ptr, cb);\n-          }\n-          uv_timer(id, loop) {\n-            let cb = process_close_timer;\n-            rustrt::rust_uvtmp_uv_close(\n-                handle_ptr, cb);\n-          }\n-          _ {\n-            fail \"unknown form of uv_handle encountered \" +\n-                \"in process_operation/op_close\";\n-          }\n-        }\n-    }\n-\n-    crust fn process_async_send(id_buf: *u8, data: *uv_loop_data)\n-        unsafe {\n-        let handle_id = get_handle_id_from(id_buf);\n-        let loop_chan = get_loop_chan_from_data(data);\n-        comm::send(loop_chan, uv_async_send(handle_id));\n-    }\n-\n-    crust fn process_timer_call(id_buf: *u8, data: *uv_loop_data)\n-        unsafe {\n-        let handle_id = get_handle_id_from(id_buf);\n-        let loop_chan = get_loop_chan_from_data(data);\n-        comm::send(loop_chan, uv_timer_call(handle_id));\n-    }\n-\n-    fn process_close_common(id: [u8], data: *uv_loop_data)\n-        unsafe {\n-        // notify the rust loop that their handle is closed, then\n-        // the caller will invoke a per-handle-type c++ func to\n-        // free allocated memory\n-        let loop_chan = get_loop_chan_from_data(data);\n-        comm::send(loop_chan, uv_close(id));\n-    }\n-\n-    crust fn process_close_async(\n-        id_buf: *u8,\n-        handle_ptr: *ctypes::void,\n-        data: *uv_loop_data)\n-        unsafe {\n-        let id = get_handle_id_from(id_buf);\n-        rustrt::rust_uvtmp_uv_close_async(handle_ptr);\n-        // at this point, the handle and its data has been\n-        // released. notify the rust loop to remove the\n-        // handle and its data and call the user-supplied\n-        // close cb\n-        process_close_common(id, data);\n-    }\n-\n-    crust fn process_close_timer(\n-        id_buf: *u8,\n-        handle_ptr: *ctypes::void,\n-        data: *uv_loop_data)\n-        unsafe {\n-        let id = get_handle_id_from(id_buf);\n-        rustrt::rust_uvtmp_uv_close_timer(handle_ptr);\n-        process_close_common(id, data);\n-    }\n-\n-}\n-\n-#[test]\n-fn test_uvtmp_uv_new_loop_no_handles() {\n-    let test_loop = uv::loop_new();\n-    uv::run(test_loop); // this should return immediately\n-                        // since there aren't any handles..\n-}\n-\n-#[test]\n-fn test_uvtmp_uv_simple_async() {\n-    let test_loop = uv::loop_new();\n-    let exit_port = comm::port::<bool>();\n-    let exit_chan = comm::chan::<bool>(exit_port);\n-    uv::async_init(test_loop, {|new_async|\n-        uv::close(new_async) {||\n-            comm::send(exit_chan, true);\n-        };\n-    }, {|new_async|\n-        uv::async_send(new_async);\n-    });\n-    uv::run(test_loop);\n-    assert comm::recv(exit_port);\n-}\n-\n-#[test]\n-fn test_uvtmp_uv_timer() {\n-    let test_loop = uv::loop_new();\n-    let exit_port = comm::port::<bool>();\n-    let exit_chan = comm::chan::<bool>(exit_port);\n-    uv::timer_init(test_loop) {|new_timer|\n-        uv::timer_start(new_timer, 1u32, 0u32) {|started_timer|\n-            uv::timer_stop(started_timer) {|stopped_timer|\n-                uv::close(stopped_timer) {||\n-                    comm::send(exit_chan, true);\n-                };\n-            };\n-        };\n-    };\n-    uv::run(test_loop);\n-    assert comm::recv(exit_port);\n-}\n-\n-// END OF UV2\n-\n-type thread = *ctypes::void;\n-\n-type connect_data = *ctypes::void;\n-\n-enum iomsg {\n-    whatever,\n-    connected(connect_data),\n-    wrote(connect_data),\n-    read(connect_data, *u8, ctypes::ssize_t),\n-    timer(u32),\n-    exit\n-}\n-\n-fn create_thread() -> thread {\n-    rustrt::rust_uvtmp_create_thread()\n-}\n-\n-fn start_thread(thread: thread) {\n-    rustrt::rust_uvtmp_start_thread(thread)\n-}\n-\n-fn join_thread(thread: thread) {\n-    rustrt::rust_uvtmp_join_thread(thread)\n-}\n-\n-fn delete_thread(thread: thread) {\n-    rustrt::rust_uvtmp_delete_thread(thread)\n-}\n-\n-fn connect(thread: thread, req_id: u32,\n-           ip: str, ch: comm::chan<iomsg>) -> connect_data {\n-    str::as_buf(ip) {|ipbuf|\n-        rustrt::rust_uvtmp_connect(thread, req_id, ipbuf, ch)\n-    }\n-}\n-\n-fn close_connection(thread: thread, req_id: u32) {\n-    rustrt::rust_uvtmp_close_connection(thread, req_id);\n-}\n-\n-fn write(thread: thread, req_id: u32, bytes: [u8],\n-         chan: comm::chan<iomsg>) unsafe {\n-    rustrt::rust_uvtmp_write(\n-        thread, req_id, vec::to_ptr(bytes), vec::len(bytes), chan);\n-}\n-\n-fn read_start(thread: thread, req_id: u32,\n-              chan: comm::chan<iomsg>) {\n-    rustrt::rust_uvtmp_read_start(thread, req_id, chan);\n-}\n-\n-fn timer_start(thread: thread, timeout: u32, req_id: u32,\n-              chan: comm::chan<iomsg>) {\n-    rustrt::rust_uvtmp_timer(thread, timeout, req_id, chan);\n-}\n-\n-fn delete_buf(buf: *u8) {\n-    rustrt::rust_uvtmp_delete_buf(buf);\n-}\n-\n-fn get_req_id(cd: connect_data) -> u32 {\n-    ret rustrt::rust_uvtmp_get_req_id(cd);\n-}\n-\n-#[test]\n-fn test_start_stop() {\n-    let thread = create_thread();\n-    start_thread(thread);\n-    join_thread(thread);\n-    delete_thread(thread);\n-}\n-\n-#[test]\n-#[ignore]\n-fn test_connect() {\n-    let thread = create_thread();\n-    start_thread(thread);\n-    let port = comm::port();\n-    let chan = comm::chan(port);\n-    connect(thread, 0u32, \"74.125.224.146\", chan);\n-    alt comm::recv(port) {\n-      connected(cd) {\n-        close_connection(thread, 0u32);\n-      }\n-      _ { fail \"test_connect: port isn't connected\"; }\n-    }\n-    join_thread(thread);\n-    delete_thread(thread);\n-}\n-\n-#[test]\n-#[ignore]\n-fn test_http() {\n-    let thread = create_thread();\n-    start_thread(thread);\n-    let port = comm::port();\n-    let chan = comm::chan(port);\n-    connect(thread, 0u32, \"74.125.224.146\", chan);\n-    alt comm::recv(port) {\n-      connected(cd) {\n-        write(thread, 0u32, str::bytes(\"GET / HTTP/1.0\\n\\n\"), chan);\n-        alt comm::recv(port) {\n-          wrote(cd) {\n-            read_start(thread, 0u32, chan);\n-            let keep_going = true;\n-            while keep_going {\n-                alt comm::recv(port) {\n-                  read(_, buf, -1) {\n-                    keep_going = false;\n-                    delete_buf(buf);\n-                  }\n-                  read(_, buf, len) {\n-                    unsafe {\n-                        log(error, len);\n-                        let buf = vec::unsafe::from_buf(buf,\n-                                                        len as uint);\n-                        let str = str::from_bytes(buf);\n-                        #error(\"read something\");\n-                        io::println(str);\n-                    }\n-                    delete_buf(buf);\n-                  }\n-                  _ { fail \"test_http: protocol error\"; }\n-                }\n-            }\n-            close_connection(thread, 0u32);\n-          }\n-          _ { fail \"test_http: expected `wrote`\"; }\n-        }\n-      }\n-      _ { fail \"test_http: port not connected\"; }\n-    }\n-    join_thread(thread);\n-    delete_thread(thread);\n-}"}, {"sha": "03cd75d4805c285953ba1c5cf0d049b1611c7d7c", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 159, "deletions": 27, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/bb5960aa57a04920614fce021c6792ad8a9a0305/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bb5960aa57a04920614fce021c6792ad8a9a0305/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=bb5960aa57a04920614fce021c6792ad8a9a0305", "patch": "@@ -1,51 +1,183 @@\n #include \"rust_internal.h\"\n #include \"uv.h\"\n \n-/*\n-  Wrappers of uv_* functions. These can be eliminated by figuring\n-  out how to build static uv with externs, or by just using dynamic libuv\n- */\n+// crust fn pointers\n+typedef void (*crust_async_op_cb)(uv_loop_t* loop, void* data);\n+typedef void (*crust_simple_cb)(uint8_t* id_buf, void* loop_data);\n+typedef void (*crust_close_cb)(uint8_t* id_buf, void* handle,\n+\t\t\t\t\t\t\t  void* data);\n \n-extern \"C\" CDECL uv_loop_t*\n-rust_uv_default_loop() {\n-  return uv_default_loop();\n+// data types\n+#define RUST_UV_HANDLE_LEN 16\n+\n+struct handle_data {\n+\tuint8_t id_buf[RUST_UV_HANDLE_LEN];\n+\tcrust_simple_cb cb;\n+\tcrust_close_cb close_cb;\n+};\n+\n+// helpers\n+static void*\n+current_kernel_malloc(size_t size, const char* tag) {\n+  void* ptr = rust_task_thread::get_task()->kernel->malloc(size, tag);\n+  return ptr;\n+}\n+\n+static void\n+current_kernel_free(void* ptr) {\n+  rust_task_thread::get_task()->kernel->free(ptr);\n+}\n+\n+static handle_data*\n+new_handle_data_from(uint8_t* buf, crust_simple_cb cb) {\n+\thandle_data* data = (handle_data*)current_kernel_malloc(\n+\t\tsizeof(handle_data),\n+\t\t\"handle_data\");\n+\tmemcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n+\tdata->cb = cb;\n+\treturn data;\n+}\n+\n+// libuv callback impls\n+static void\n+native_crust_async_op_cb(uv_async_t* handle, int status) {\n+    crust_async_op_cb cb = (crust_async_op_cb)handle->data;\n+\tvoid* loop_data = handle->loop->data;\n+\tcb(handle->loop, loop_data);\n+}\n+\n+static void\n+native_async_cb(uv_async_t* handle, int status) {\n+\thandle_data* handle_d = (handle_data*)handle->data;\n+\tvoid* loop_data = handle->loop->data;\n+\thandle_d->cb(handle_d->id_buf, loop_data);\n+}\n+\n+static void\n+native_timer_cb(uv_timer_t* handle, int status) {\n+\thandle_data* handle_d = (handle_data*)handle->data;\n+\tvoid* loop_data = handle->loop->data;\n+\thandle_d->cb(handle_d->id_buf, loop_data);\n+}\n+\n+static void\n+native_close_cb(uv_handle_t* handle) {\n+\thandle_data* data = (handle_data*)handle->data;\n+\tdata->close_cb(data->id_buf, handle, handle->loop->data);\n }\n \n-extern \"C\" CDECL uv_loop_t*\n+static void\n+native_close_op_cb(uv_handle_t* op_handle) {\n+  uv_loop_t* loop = op_handle->loop;\n+  current_kernel_free(op_handle);\n+  loop->data = 0; // a ptr to some stack-allocated rust mem\n+  uv_loop_delete(loop);\n+}\n+\n+// native fns bound in rust\n+extern \"C\" void*\n rust_uv_loop_new() {\n-  return uv_loop_new();\n+    return (void*)uv_loop_new();\n+}\n+\n+extern \"C\" void\n+rust_uv_loop_set_data(uv_loop_t* loop, void* data) {\n+    loop->data = data;\n }\n \n-extern \"C\" CDECL void\n-rust_uv_loop_delete(uv_loop_t *loop) {\n-  return uv_loop_delete(loop);\n+extern \"C\" void*\n+rust_uv_bind_op_cb(uv_loop_t* loop, crust_async_op_cb cb) {\n+\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+\t\tsizeof(uv_async_t),\n+\t\t\"uv_async_t\");\n+\tuv_async_init(loop, async, native_crust_async_op_cb);\n+\tasync->data = (void*)cb;\n+\t// decrement the ref count, so that our async bind\n+\t// doesn't count towards keeping the loop alive\n+\tuv_unref(loop);\n+\treturn async;\n }\n \n-extern \"C\" CDECL int\n-rust_uv_run(uv_loop_t *loop) {\n-  return uv_run(loop);\n+extern \"C\" void\n+rust_uv_stop_op_cb(uv_handle_t* op_handle) {\n+  /*  // this is a hack to get libuv to cleanup a\n+  // handle that was made to not prevent the loop\n+  // from exiting via uv_unref().\n+  uv_ref(op_handle->loop);\n+  uv_close(op_handle, native_close_op_cb);\n+  uv_run(op_handle->loop); // this should process the handle's\n+                           // close event and then return\n+\t\t\t\t\t\t   */\n+  // the above code is supposed to work to cleanly close\n+  // a handler that was uv_unref()'d. but it causes much spew\n+  // instead. this is the ugly/quick way to deal w/ it for now.\n+  uv_close(op_handle, native_close_op_cb);\n+  native_close_op_cb(op_handle);\n }\n \n-extern \"C\" CDECL void\n-rust_uv_unref(uv_loop_t *loop) {\n-  return uv_unref(loop);\n+extern \"C\" void\n+rust_uv_run(uv_loop_t* loop) {\n+\tuv_run(loop);\n }\n \n-extern \"C\" CDECL int\n-rust_uv_idle_init(uv_loop_t* loop, uv_idle_t* idle) {\n-  return uv_idle_init(loop, idle);\n+extern \"C\" void\n+rust_uv_close(uv_handle_t* handle, crust_close_cb cb) {\n+\thandle_data* data = (handle_data*)handle->data;\n+\tdata->close_cb = cb;\n+\tuv_close(handle, native_close_cb);\n }\n \n-extern \"C\" CDECL int\n-rust_uv_idle_start(uv_idle_t* idle, uv_idle_cb cb) {\n-  return uv_idle_start(idle, cb);\n+extern \"C\" void\n+rust_uv_close_async(uv_async_t* handle) {\n+  current_kernel_free(handle->data);\n+  current_kernel_free(handle);\n }\n \n+extern \"C\" void\n+rust_uv_close_timer(uv_async_t* handle) {\n+  current_kernel_free(handle->data);\n+  current_kernel_free(handle);\n+}\n+\n+extern \"C\" void\n+rust_uv_async_send(uv_async_t* handle) {\n+    uv_async_send(handle);\n+}\n \n+extern \"C\" void*\n+rust_uv_async_init(uv_loop_t* loop, crust_simple_cb cb,\n+\t\t\t\t\t\t uint8_t* buf) {\n+\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+\t\tsizeof(uv_async_t),\n+\t\t\"uv_async_t\");\n+\tuv_async_init(loop, async, native_async_cb);\n+\thandle_data* data = new_handle_data_from(buf, cb);\n+\tasync->data = data;\n \n+\treturn async;\n+}\n+\n+extern \"C\" void*\n+rust_uv_timer_init(uv_loop_t* loop, crust_simple_cb cb,\n+\t\t\t\t\t\t uint8_t* buf) {\n+\tuv_timer_t* new_timer = (uv_timer_t*)current_kernel_malloc(\n+\t\tsizeof(uv_timer_t),\n+\t\t\"uv_timer_t\");\n+\tuv_timer_init(loop, new_timer);\n+\thandle_data* data = new_handle_data_from(buf, cb);\n+\tnew_timer->data = data;\n+\n+\treturn new_timer;\n+}\n+\n+extern \"C\" void\n+rust_uv_timer_start(uv_timer_t* the_timer, uint32_t timeout,\n+\t\t\t\t\t\t  uint32_t repeat) {\n+\tuv_timer_start(the_timer, native_timer_cb, timeout, repeat);\n+}\n \n-extern \"C\" CDECL size_t\n-rust_uv_size_of_idle_t() {\n-  return sizeof(uv_idle_t);\n+extern \"C\" void\n+rust_uv_timer_stop(uv_timer_t* the_timer) {\n+  uv_timer_stop(the_timer); \n }\n "}, {"sha": "697231dff1b56c8dbb1b83312efff738f9ee7688", "filename": "src/rt/rust_uvtmp.cpp", "status": "removed", "additions": 0, "deletions": 612, "changes": 612, "blob_url": "https://github.com/rust-lang/rust/blob/cf08ed64584cd13eb3fb98ca07d3e3b987103c16/src%2Frt%2Frust_uvtmp.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cf08ed64584cd13eb3fb98ca07d3e3b987103c16/src%2Frt%2Frust_uvtmp.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uvtmp.cpp?ref=cf08ed64584cd13eb3fb98ca07d3e3b987103c16", "patch": "@@ -1,612 +0,0 @@\n-#include <utility>\n-#include <queue>\n-#include <string>\n-#include \"rust_internal.h\"\n-#include \"uv.h\"\n-\n-class rust_uvtmp_thread;\n-\n-struct connect_data {\n-    uint32_t req_id;\n-    rust_uvtmp_thread *thread;\n-    char * ip_addr;\n-    uv_connect_t connect;\n-    uv_tcp_t tcp;\n-    chan_handle chan;\n-};\n-\n-const intptr_t whatever_tag = 0;\n-const intptr_t connected_tag = 1;\n-const intptr_t wrote_tag = 2;\n-const intptr_t read_tag = 3;\n-const intptr_t timer_tag = 4;\n-const intptr_t exit_tag = 5;\n-\n-struct iomsg {\n-    intptr_t tag;\n-    union {\n-\tconnect_data *connected_val;\n-\tconnect_data *wrote_val;\n-\tstruct {\n-\t    connect_data *cd;\n-\t    uint8_t *buf;\n-\t    ssize_t nread;\n-\t} read_val;\n-        uint32_t timer_req_id;\n-    } val;\n-};\n-\n-struct write_data {\n-    connect_data *cd;\n-    uint8_t *buf;\n-    size_t len;\n-    chan_handle chan;\n-};\n-\n-struct read_start_data {\n-    connect_data *cd;\n-    chan_handle chan;\n-};\n-\n-struct timer_start_data {\n-    rust_uvtmp_thread *thread;\n-    uint32_t timeout;\n-    uint32_t req_id;\n-    chan_handle chan;\n-};\n-\n-// UVTMP REWORK\n-\n-// crust fn pointers\n-typedef void (*crust_async_op_cb)(uv_loop_t* loop, void* data);\n-typedef void (*crust_simple_cb)(uint8_t* id_buf, void* loop_data);\n-typedef void (*crust_close_cb)(uint8_t* id_buf, void* handle,\n-\t\t\t\t\t\t\t  void* data);\n-\n-// data types\n-#define RUST_UV_HANDLE_LEN 16\n-\n-struct handle_data {\n-\tuint8_t id_buf[RUST_UV_HANDLE_LEN];\n-\tcrust_simple_cb cb;\n-\tcrust_close_cb close_cb;\n-};\n-\n-// helpers\n-static void*\n-current_kernel_malloc(size_t size, const char* tag) {\n-  void* ptr = rust_task_thread::get_task()->kernel->malloc(size, tag);\n-  return ptr;\n-}\n-\n-static void\n-current_kernel_free(void* ptr) {\n-  rust_task_thread::get_task()->kernel->free(ptr);\n-}\n-\n-static handle_data*\n-new_handle_data_from(uint8_t* buf, crust_simple_cb cb) {\n-\thandle_data* data = (handle_data*)current_kernel_malloc(\n-\t\tsizeof(handle_data),\n-\t\t\"handle_data\");\n-\tmemcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n-\tdata->cb = cb;\n-\treturn data;\n-}\n-\n-// libuv callback impls\n-static void\n-native_crust_async_op_cb(uv_async_t* handle, int status) {\n-    crust_async_op_cb cb = (crust_async_op_cb)handle->data;\n-\tvoid* loop_data = handle->loop->data;\n-\tcb(handle->loop, loop_data);\n-}\n-\n-static void\n-native_async_cb(uv_async_t* handle, int status) {\n-\thandle_data* handle_d = (handle_data*)handle->data;\n-\tvoid* loop_data = handle->loop->data;\n-\thandle_d->cb(handle_d->id_buf, loop_data);\n-}\n-\n-static void\n-native_timer_cb(uv_timer_t* handle, int status) {\n-\thandle_data* handle_d = (handle_data*)handle->data;\n-\tvoid* loop_data = handle->loop->data;\n-\thandle_d->cb(handle_d->id_buf, loop_data);\n-}\n-\n-static void\n-native_close_cb(uv_handle_t* handle) {\n-\thandle_data* data = (handle_data*)handle->data;\n-\tdata->close_cb(data->id_buf, handle, handle->loop->data);\n-}\n-\n-static void\n-native_close_op_cb(uv_handle_t* op_handle) {\n-  uv_loop_t* loop = op_handle->loop;\n-  current_kernel_free(op_handle);\n-  loop->data = 0; // a ptr to some stack-allocated rust mem\n-  uv_loop_delete(loop);\n-}\n-\n-// native fns bound in rust\n-extern \"C\" void*\n-rust_uvtmp_uv_loop_new() {\n-    return (void*)uv_loop_new();\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_uv_loop_set_data(uv_loop_t* loop, void* data) {\n-    loop->data = data;\n-}\n-\n-extern \"C\" void*\n-rust_uvtmp_uv_bind_op_cb(uv_loop_t* loop, crust_async_op_cb cb) {\n-\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n-\t\tsizeof(uv_async_t),\n-\t\t\"uv_async_t\");\n-\tuv_async_init(loop, async, native_crust_async_op_cb);\n-\tasync->data = (void*)cb;\n-\t// decrement the ref count, so that our async bind\n-\t// doesn't count towards keeping the loop alive\n-\tuv_unref(loop);\n-\treturn async;\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_uv_stop_op_cb(uv_handle_t* op_handle) {\n-  /*  // this is a hack to get libuv to cleanup a\n-  // handle that was made to not prevent the loop\n-  // from exiting via uv_unref().\n-  uv_ref(op_handle->loop);\n-  uv_close(op_handle, native_close_op_cb);\n-  uv_run(op_handle->loop); // this should process the handle's\n-                           // close event and then return\n-\t\t\t\t\t\t   */\n-  // the above code is supposed to work to cleanly close\n-  // a handler that was uv_unref()'d. but it causes much spew\n-  // instead. this is the ugly/quick way to deal w/ it for now.\n-  uv_close(op_handle, native_close_op_cb);\n-  native_close_op_cb(op_handle);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_uv_run(uv_loop_t* loop) {\n-\tuv_run(loop);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_uv_close(uv_handle_t* handle, crust_close_cb cb) {\n-\thandle_data* data = (handle_data*)handle->data;\n-\tdata->close_cb = cb;\n-\tuv_close(handle, native_close_cb);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_uv_close_async(uv_async_t* handle) {\n-  current_kernel_free(handle->data);\n-  current_kernel_free(handle);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_uv_close_timer(uv_async_t* handle) {\n-  current_kernel_free(handle->data);\n-  current_kernel_free(handle);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_uv_async_send(uv_async_t* handle) {\n-    uv_async_send(handle);\n-}\n-\n-extern \"C\" void*\n-rust_uvtmp_uv_async_init(uv_loop_t* loop, crust_simple_cb cb,\n-\t\t\t\t\t\t uint8_t* buf) {\n-\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n-\t\tsizeof(uv_async_t),\n-\t\t\"uv_async_t\");\n-\tuv_async_init(loop, async, native_async_cb);\n-\thandle_data* data = new_handle_data_from(buf, cb);\n-\tasync->data = data;\n-\n-\treturn async;\n-}\n-\n-extern \"C\" void*\n-rust_uvtmp_uv_timer_init(uv_loop_t* loop, crust_simple_cb cb,\n-\t\t\t\t\t\t uint8_t* buf) {\n-\tuv_timer_t* new_timer = (uv_timer_t*)current_kernel_malloc(\n-\t\tsizeof(uv_timer_t),\n-\t\t\"uv_timer_t\");\n-\tuv_timer_init(loop, new_timer);\n-\thandle_data* data = new_handle_data_from(buf, cb);\n-\tnew_timer->data = data;\n-\n-\treturn new_timer;\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_uv_timer_start(uv_timer_t* the_timer, uint32_t timeout,\n-\t\t\t\t\t\t  uint32_t repeat) {\n-\tuv_timer_start(the_timer, native_timer_cb, timeout, repeat);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_uv_timer_stop(uv_timer_t* the_timer) {\n-  uv_timer_stop(the_timer); \n-}\n-\n-// UVTMP REWORK\n-\n-// FIXME: Copied from rust_builtins.cpp. Could bitrot easily\n-static void\n-send(rust_task *task, chan_handle chan, void *data) {\n-    rust_task *target_task = task->kernel->get_task_by_id(chan.task);\n-    if(target_task) {\n-        rust_port *port = target_task->get_port_by_id(chan.port);\n-        if(port) {\n-            port->send(data);\n-            scoped_lock with(target_task->lock);\n-            port->deref();\n-        }\n-        target_task->deref();\n-    }\n-}\n-\n-class rust_uvtmp_thread : public rust_thread {\n-\n-private:\n-    std::map<int, connect_data *> req_map;\n-    rust_task *task;\n-    uv_loop_t *loop;\n-    uv_idle_t idle;\n-    lock_and_signal lock;\n-    bool stop_flag;\n-    std::queue<std::pair<connect_data *, chan_handle> > connect_queue;\n-    std::queue<connect_data*> close_connection_queue;\n-    std::queue<write_data*> write_queue;\n-    std::queue<read_start_data*> read_start_queue;\n-    std::queue<timer_start_data*> timer_start_queue;\n-public:\n-\n-    rust_uvtmp_thread() {\n-\ttask = rust_task_thread::get_task();\n-\tstop_flag = false;\n-\tloop = uv_loop_new();\n-\tuv_idle_init(loop, &idle);\n-\tidle.data = this;\n-\tuv_idle_start(&idle, idle_cb);\n-    }\n-\n-    ~rust_uvtmp_thread() {\n-\tuv_loop_delete(loop);\n-    }\n-\n-    void stop() {\n-\tscoped_lock with(lock);\n-\tstop_flag = true;\n-    }\n-\n-    connect_data *connect(uint32_t req_id, char *ip, chan_handle chan) {\n-\tscoped_lock with(lock);\n-        if (req_map.count(req_id)) return NULL;\n-        connect_data *cd = new connect_data();\n-        req_map[req_id] = cd;\n-        cd->req_id = req_id;\n-        cd->ip_addr = ip;\n-\tconnect_queue.push(\n-            std::pair<connect_data *, chan_handle>(cd, chan));\n-        return cd;\n-    }\n-\n-    void\n-    close_connection(uint32_t req_id) {\n-        scoped_lock with(lock);\n-        connect_data *cd = req_map[req_id];\n-        close_connection_queue.push(cd);\n-        req_map.erase(req_id);\n-    }\n-\n-    void\n-    write(uint32_t req_id, uint8_t *buf, size_t len, chan_handle chan) {\n-        scoped_lock with(lock);\n-        connect_data *cd = req_map[req_id];\n-        write_data *wd = new write_data();\n-        wd->cd = cd;\n-        wd->buf = new uint8_t[len];\n-        wd->len = len;\n-        wd->chan = chan;\n-\n-        memcpy(wd->buf, buf, len);\n-\n-        write_queue.push(wd);\n-    }\n-\n-    void\n-    read_start(uint32_t req_id, chan_handle chan) {\n-        scoped_lock with(lock);\n-        connect_data *cd = req_map[req_id];\n-        read_start_data *rd = new read_start_data();\n-        rd->cd = cd;\n-        rd->chan = chan;\n-\n-        read_start_queue.push(rd);\n-    }\n-\n-    void\n-    timer(uint32_t timeout, uint32_t req_id, chan_handle chan) {\n-        scoped_lock with(lock);\n-\n-        timer_start_data *td = new timer_start_data();\n-        td->timeout = timeout;\n-        td->req_id = req_id;\n-        td->chan = chan;\n-        timer_start_queue.push(td);\n-    }\n-\n-private:\n-\n-    virtual void\n-    run() {\n-\tuv_run(loop);\n-    }\n-\n-    static void\n-    idle_cb(uv_idle_t* handle, int status) {\n-\trust_uvtmp_thread *self = (rust_uvtmp_thread*) handle->data;\n-\tself->on_idle();\n-    }\n-\n-    void\n-    on_idle() {\n-\tscoped_lock with(lock);\n-\tmake_new_connections();\n-\tclose_connections();\n-\twrite_buffers();\n-\tstart_reads();\n-        start_timers();\n-\tclose_idle_if_stop();\n-    }\n-\n-    void\n-    make_new_connections() {\n-\tassert(lock.lock_held_by_current_thread());\n-\twhile (!connect_queue.empty()) {\n-\t    std::pair<connect_data *, chan_handle> pair = connect_queue.front();\n-\t    connect_queue.pop();\n-            connect_data *cd = pair.first;\n-\t    struct sockaddr_in client_addr = uv_ip4_addr(\"0.0.0.0\", 0);\n-\t    struct sockaddr_in server_addr = uv_ip4_addr(cd->ip_addr, 80);\n-\n-\t    cd->thread = this;\n-\t    cd->chan = pair.second;\n-\t    cd->connect.data = cd;\n-\n-\t    uv_tcp_init(loop, &cd->tcp);\n-\t    uv_tcp_bind(&cd->tcp, client_addr);\n-\n-\t    uv_tcp_connect(&cd->connect, &cd->tcp, server_addr, connect_cb);\n-\t}\n-    }\n-\n-    static void\n-    connect_cb(uv_connect_t *handle, int status) {\n-\tconnect_data *cd = (connect_data*)handle->data;\n-\tcd->thread->on_connect(cd);\n-    }\n-\n-    void\n-    on_connect(connect_data *cd) {\n-\tiomsg msg;\n-\tmsg.tag = connected_tag;\n-\tmsg.val.connected_val = cd;\n-\n-\tsend(task, cd->chan, &msg);\n-    }\n-\n-    void\n-    close_connections() {\n-\tassert(lock.lock_held_by_current_thread());\n-\twhile (!close_connection_queue.empty()) {\n-\t    connect_data *cd = close_connection_queue.front();\n-\t    close_connection_queue.pop();\n-\t    \n-\t    cd->tcp.data = cd;\n-\t    \n-\t    uv_close((uv_handle_t*)&cd->tcp, tcp_close_cb);\n-\t}\n-    }\n-\n-    static void\n-    tcp_close_cb(uv_handle_t *handle) {\n-\tconnect_data *cd = (connect_data*)handle->data;\n-\tdelete cd;\n-    }\n-\n-    void\n-    write_buffers() {\n-\tassert(lock.lock_held_by_current_thread());\n-\twhile (!write_queue.empty()) {\n-\t    write_data *wd = write_queue.front();\n-\t    write_queue.pop();\n-\n-\t    uv_write_t *write = new uv_write_t();\n-\n-\t    write->data = wd;\n-\n-\t    uv_buf_t buf;\n-\t    buf.base = (char*)wd->buf;\n-\t    buf.len = wd->len;\n-\n-\t    uv_write(write, (uv_stream_t*)&wd->cd->tcp, &buf, 1, write_cb);\n-\t}\n-    }\n-\n-    static void\n-    write_cb(uv_write_t *handle, int status) {\n-\twrite_data *wd = (write_data*)handle->data;\n-\trust_uvtmp_thread *self = wd->cd->thread;\n-\tself->on_write(handle, wd);\n-    }\n-\n-    void\n-    on_write(uv_write_t *handle, write_data *wd) {\n-\tiomsg msg;\n-\tmsg.tag = timer_tag;\n-\tmsg.val.wrote_val = wd->cd;\n-\n-\tsend(task, wd->chan, &msg);\n-\n-\tdelete [] wd->buf;\n-\tdelete wd;\n-\tdelete handle;\n-    }\n-\n-    void\n-    start_reads() {\n-\tassert (lock.lock_held_by_current_thread());\n-\twhile (!read_start_queue.empty()) {\n-\t    read_start_data *rd = read_start_queue.front();\n-\t    read_start_queue.pop();\n-\n-\t    connect_data *cd = rd->cd;\n-\t    cd->tcp.data = rd;\n-\n-\t    uv_read_start((uv_stream_t*)&cd->tcp, alloc_cb, read_cb);\n-\t}\n-    }\n-\n-    static uv_buf_t\n-    alloc_cb(uv_handle_t* handle, size_t size) {\n-\tuv_buf_t buf;\n-\tbuf.base = new char[size];\n-\tbuf.len = size;\n-\treturn buf;\n-    }\n-\n-    static void\n-    read_cb(uv_stream_t *handle, ssize_t nread, uv_buf_t buf) {\n-\tread_start_data *rd = (read_start_data*)handle->data;\n-\trust_uvtmp_thread *self = rd->cd->thread;\n-\tself->on_read(rd, nread, buf);\n-    }\n-\n-    void\n-    on_read(read_start_data *rd, ssize_t nread, uv_buf_t buf) {\n-\tiomsg msg;\n-\tmsg.tag = read_tag;\n-\tmsg.val.read_val.cd = rd->cd;\n-\tmsg.val.read_val.buf = (uint8_t*)buf.base;\n-\tmsg.val.read_val.nread = nread;\n-\n-\tsend(task, rd->chan, &msg);\n-\tif (nread == -1) {\n-\t    delete rd;\n-\t}\n-    }\n-\n-    void\n-    start_timers() {\n-\tassert (lock.lock_held_by_current_thread());\n-\twhile (!timer_start_queue.empty()) {\n-\t    timer_start_data *td = timer_start_queue.front();\n-\t    timer_start_queue.pop();\n-\n-            td->thread = this;\n-\n-            uv_timer_t *timer = (uv_timer_t *)malloc(sizeof(uv_timer_t));\n-            timer->data = td;\n-            uv_timer_init(loop, timer);\n-            uv_timer_start(timer, timer_cb, td->timeout, 0);\n-\t}\n-    }\n-\n-    static void\n-    timer_cb(uv_timer_t *handle, int what) {\n-\ttimer_start_data *td = (timer_start_data*)handle->data;\n-\trust_uvtmp_thread *self = td->thread;\n-\tself->on_timer(td);\n-        free(handle);\n-    }\n-\n-    void\n-    on_timer(timer_start_data *rd) {\n-\tiomsg msg;\n-\tmsg.tag = timer_tag;\n-        msg.val.timer_req_id = rd->req_id;\n-\n-\tsend(task, rd->chan, &msg);\n-        delete rd;\n-    }\n-\n-    void\n-    close_idle_if_stop() {\n-\tassert(lock.lock_held_by_current_thread());\n-\tif (stop_flag) {\n-\t    uv_close((uv_handle_t*)&idle, NULL);\n-\t}\n-    }\n-\n-};\n-\n-extern \"C\" rust_uvtmp_thread *\n-rust_uvtmp_create_thread() {\n-    rust_uvtmp_thread *thread = new rust_uvtmp_thread();\n-    return thread;\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_start_thread(rust_uvtmp_thread *thread) {\n-    thread->start();    \n-}\n-\n-extern \"C\" void\n-rust_uvtmp_join_thread(rust_uvtmp_thread *thread) {\n-    thread->stop();\n-    thread->join();\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_delete_thread(rust_uvtmp_thread *thread) {\n-    delete thread;\n-}\n-\n-extern \"C\" connect_data *\n-rust_uvtmp_connect(rust_uvtmp_thread *thread, uint32_t req_id, char *ip, chan_handle *chan) {\n-    return thread->connect(req_id, ip, *chan);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_close_connection(rust_uvtmp_thread *thread, uint32_t req_id) {\n-  thread->close_connection(req_id);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_write(rust_uvtmp_thread *thread, uint32_t req_id,\n-\t\t uint8_t *buf, size_t len, chan_handle *chan) {\n-    thread->write(req_id, buf, len, *chan);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_read_start(rust_uvtmp_thread *thread, uint32_t req_id,\n-\t\t      chan_handle *chan) {\n-    thread->read_start(req_id, *chan);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_timer(rust_uvtmp_thread *thread, uint32_t timeout, uint32_t req_id, chan_handle *chan) {\n-    thread->timer(timeout, req_id, *chan);\n-}\n-\n-extern \"C\" void\n-rust_uvtmp_delete_buf(uint8_t *buf) {\n-    delete [] buf;\n-}\n-\n-extern \"C\" uint32_t\n-rust_uvtmp_get_req_id(connect_data *cd) {\n-    return cd->req_id;\n-}\n-\n-"}, {"sha": "12bb69377482841f87448f90691f4bdb2a3f5075", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bb5960aa57a04920614fce021c6792ad8a9a0305/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/bb5960aa57a04920614fce021c6792ad8a9a0305/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=bb5960aa57a04920614fce021c6792ad8a9a0305", "patch": "@@ -80,38 +80,19 @@ upcall_call_shim_on_rust_stack\n upcall_new_stack\n upcall_del_stack\n upcall_reset_stack_limit\n-rust_uv_default_loop\n rust_uv_loop_new\n-rust_uv_loop_delete\n+rust_uv_loop_set_data\n+rust_uv_bind_op_cb\n+rust_uv_stop_op_cb\n rust_uv_run\n-rust_uv_unref\n-rust_uv_idle_init\n-rust_uv_idle_start\n-rust_uv_size_of_idle_t\n-rust_uvtmp_create_thread\n-rust_uvtmp_start_thread\n-rust_uvtmp_join_thread\n-rust_uvtmp_delete_thread\n-rust_uvtmp_connect\n-rust_uvtmp_close_connection\n-rust_uvtmp_write\n-rust_uvtmp_read_start\n-rust_uvtmp_timer\n-rust_uvtmp_delete_buf\n-rust_uvtmp_get_req_id\n-rust_uvtmp_uv_loop_new\n-rust_uvtmp_uv_loop_set_data\n-rust_uvtmp_uv_bind_op_cb\n-rust_uvtmp_uv_stop_op_cb\n-rust_uvtmp_uv_run\n-rust_uvtmp_uv_close\n-rust_uvtmp_uv_close_async\n-rust_uvtmp_uv_close_timer\n-rust_uvtmp_uv_async_send\n-rust_uvtmp_uv_async_init\n-rust_uvtmp_uv_timer_init\n-rust_uvtmp_uv_timer_start\n-rust_uvtmp_uv_timer_stop\n+rust_uv_close\n+rust_uv_close_async\n+rust_uv_close_timer\n+rust_uv_async_send\n+rust_uv_async_init\n+rust_uv_timer_init\n+rust_uv_timer_start\n+rust_uv_timer_stop\n rust_dbg_lock_create\n rust_dbg_lock_destroy\n rust_dbg_lock_lock"}]}