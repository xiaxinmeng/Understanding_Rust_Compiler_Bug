{"sha": "bd8c177d49c95d94f163e9bb3c3397f38ab72640", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkOGMxNzdkNDljOTVkOTRmMTYzZTliYjNjMzM5N2YzOGFiNzI2NDA=", "commit": {"author": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-04-20T01:24:53Z"}, "committer": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-04-25T02:39:07Z"}, "message": "Switch box_free to take the destructured contents of Box\n\nAs of now, Box only contains a Unique pointer, so this is the sole\nargument to box_free. Consequently, we remove the code supporting\nthe previous box_free signature. We however keep the old definition\nfor bootstrapping purpose.", "tree": {"sha": "e38da85ae2387fb6fb9b3b3928438d93ce206adf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e38da85ae2387fb6fb9b3b3928438d93ce206adf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd8c177d49c95d94f163e9bb3c3397f38ab72640", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd8c177d49c95d94f163e9bb3c3397f38ab72640", "html_url": "https://github.com/rust-lang/rust/commit/bd8c177d49c95d94f163e9bb3c3397f38ab72640", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd8c177d49c95d94f163e9bb3c3397f38ab72640/comments", "author": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64f5233c445406cc576b9ce371af3211c05a26e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/64f5233c445406cc576b9ce371af3211c05a26e4", "html_url": "https://github.com/rust-lang/rust/commit/64f5233c445406cc576b9ce371af3211c05a26e4"}], "stats": {"total": 85, "additions": 29, "deletions": 56}, "files": [{"sha": "ed8606787653bcc7ff452cdba25c4dfeedb2c2dd", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd8c177d49c95d94f163e9bb3c3397f38ab72640/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8c177d49c95d94f163e9bb3c3397f38ab72640/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=bd8c177d49c95d94f163e9bb3c3397f38ab72640", "patch": "@@ -16,7 +16,7 @@\n             issue = \"32838\")]\n \n use core::intrinsics::{min_align_of_val, size_of_val};\n-use core::ptr::NonNull;\n+use core::ptr::{NonNull, Unique};\n use core::usize;\n \n #[doc(inline)]\n@@ -170,9 +170,17 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     }\n }\n \n-#[cfg_attr(not(test), lang = \"box_free\")]\n+#[cfg(stage0)]\n+#[lang = \"box_free\"]\n+#[inline]\n+unsafe fn old_box_free<T: ?Sized>(ptr: *mut T) {\n+    box_free(Unique::new_unchecked(ptr))\n+}\n+\n+#[cfg_attr(not(any(test, stage0)), lang = \"box_free\")]\n #[inline]\n-pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n+    let ptr = ptr.as_ptr();\n     let size = size_of_val(&*ptr);\n     let align = min_align_of_val(&*ptr);\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary."}, {"sha": "a1ec5cd2208d4ba36a6888ef7c6d44ab07b8f400", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8c177d49c95d94f163e9bb3c3397f38ab72640/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8c177d49c95d94f163e9bb3c3397f38ab72640/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=bd8c177d49c95d94f163e9bb3c3397f38ab72640", "patch": "@@ -566,7 +566,8 @@ impl<T: ?Sized> Arc<T> {\n \n     fn from_box(v: Box<T>) -> Arc<T> {\n         unsafe {\n-            let bptr = Box::into_raw(v);\n+            let box_unique = Box::into_unique(v);\n+            let bptr = box_unique.as_ptr();\n \n             let value_size = size_of_val(&*bptr);\n             let ptr = Self::allocate_for_ptr(bptr);\n@@ -578,7 +579,7 @@ impl<T: ?Sized> Arc<T> {\n                 value_size);\n \n             // Free the allocation without dropping its contents\n-            box_free(bptr);\n+            box_free(box_unique);\n \n             Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }"}, {"sha": "c495d300805e7e66b22ba9d7b041fc21b50f0cd2", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8c177d49c95d94f163e9bb3c3397f38ab72640/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8c177d49c95d94f163e9bb3c3397f38ab72640/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bd8c177d49c95d94f163e9bb3c3397f38ab72640", "patch": "@@ -681,7 +681,8 @@ impl<T: ?Sized> Rc<T> {\n \n     fn from_box(v: Box<T>) -> Rc<T> {\n         unsafe {\n-            let bptr = Box::into_raw(v);\n+            let box_unique = Box::into_unique(v);\n+            let bptr = box_unique.as_ptr();\n \n             let value_size = size_of_val(&*bptr);\n             let ptr = Self::allocate_for_ptr(bptr);\n@@ -693,7 +694,7 @@ impl<T: ?Sized> Rc<T> {\n                 value_size);\n \n             // Free the allocation without dropping its contents\n-            box_free(bptr);\n+            box_free(box_unique);\n \n             Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }"}, {"sha": "02020c3b7a49ae07c766dd920dd321eb6576ed07", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 12, "deletions": 49, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bd8c177d49c95d94f163e9bb3c3397f38ab72640/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8c177d49c95d94f163e9bb3c3397f38ab72640/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=bd8c177d49c95d94f163e9bb3c3397f38ab72640", "patch": "@@ -879,56 +879,19 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let tcx = self.tcx();\n         let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n-        let free_sig = tcx.fn_sig(free_func).skip_binder().clone();\n-        let free_inputs = free_sig.inputs();\n-        // If the box_free function takes a *mut T, transform the Box into\n-        // such a pointer before calling box_free. Otherwise, pass it all\n-        // the fields in the Box as individual arguments.\n-        let (stmts, args) = if free_inputs.len() == 1 && free_inputs[0].is_mutable_pointer() {\n-            let ty = substs.type_at(0);\n-            let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n-                ty: ty,\n-                mutbl: hir::Mutability::MutMutable\n-            });\n-            let ptr_ty = tcx.mk_mut_ptr(ty);\n-            let ref_tmp = Place::Local(self.new_temp(ref_ty));\n-            let ptr_tmp = Place::Local(self.new_temp(ptr_ty));\n-            let stmts = vec![\n-                self.assign(&ref_tmp, Rvalue::Ref(\n-                    tcx.types.re_erased,\n-                    BorrowKind::Mut { allow_two_phase_borrow: false },\n-                    self.place.clone().deref()\n-                )),\n-                self.assign(&ptr_tmp, Rvalue::Cast(\n-                    CastKind::Misc,\n-                    Operand::Move(ref_tmp),\n-                    ptr_ty,\n-                )),\n-            ];\n-            (stmts, vec![Operand::Move(ptr_tmp)])\n-        } else {\n-            let args = adt.variants[0].fields.iter().enumerate().map(|(i, f)| {\n-                let field = Field::new(i);\n-                let field_ty = f.ty(self.tcx(), substs);\n-                Operand::Move(self.place.clone().field(field, field_ty))\n-            }).collect();\n-            (vec![], args)\n-        };\n+        let args = adt.variants[0].fields.iter().enumerate().map(|(i, f)| {\n+            let field = Field::new(i);\n+            let field_ty = f.ty(self.tcx(), substs);\n+            Operand::Move(self.place.clone().field(field, field_ty))\n+        }).collect();\n \n-        let free_block = BasicBlockData {\n-            statements: stmts,\n-            terminator: Some(Terminator {\n-                kind: TerminatorKind::Call {\n-                    func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n-                    args: args,\n-                    destination: Some((unit_temp, target)),\n-                    cleanup: None\n-                }, // FIXME(#43234)\n-                source_info: self.source_info,\n-            }),\n-            is_cleanup: unwind.is_cleanup()\n-        };\n-        let free_block = self.elaborator.patch().new_block(free_block);\n+        let call = TerminatorKind::Call {\n+            func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n+            args: args,\n+            destination: Some((unit_temp, target)),\n+            cleanup: None\n+        }; // FIXME(#43234)\n+        let free_block = self.new_block(unwind, call);\n \n         let block_start = Location { block: free_block, statement_index: 0 };\n         self.elaborator.clear_drop_flag(block_start, self.path, DropFlagMode::Shallow);"}]}