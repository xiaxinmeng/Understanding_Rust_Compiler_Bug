{"sha": "ec6aba37d74e2ca8acfb961806726373909a7ac8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNmFiYTM3ZDc0ZTJjYThhY2ZiOTYxODA2NzI2MzczOTA5YTdhYzg=", "commit": {"author": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-01-13T16:31:57Z"}, "committer": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-01-17T04:27:47Z"}, "message": "rustc::metadata: Remove trait FileSearch", "tree": {"sha": "4f7748a757e4a676c797aa0444d2014702ae5f51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f7748a757e4a676c797aa0444d2014702ae5f51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec6aba37d74e2ca8acfb961806726373909a7ac8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec6aba37d74e2ca8acfb961806726373909a7ac8", "html_url": "https://github.com/rust-lang/rust/commit/ec6aba37d74e2ca8acfb961806726373909a7ac8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec6aba37d74e2ca8acfb961806726373909a7ac8/comments", "author": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f30a9b3d5bb8c6173507e338b4635491383de10d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f30a9b3d5bb8c6173507e338b4635491383de10d", "html_url": "https://github.com/rust-lang/rust/commit/f30a9b3d5bb8c6173507e338b4635491383de10d"}], "stats": {"total": 212, "additions": 98, "deletions": 114}, "files": [{"sha": "43ecbccfd79dcf09fee86a83b3190b3b42c633e0", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec6aba37d74e2ca8acfb961806726373909a7ac8/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6aba37d74e2ca8acfb961806726373909a7ac8/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=ec6aba37d74e2ca8acfb961806726373909a7ac8", "patch": "@@ -39,7 +39,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> ~[~str] {\n \n     debug!(\"preparing the RPATH!\");\n \n-    let sysroot = sess.filesearch.sysroot();\n+    let sysroot = sess.filesearch.sysroot;\n     let output = out_filename;\n     let libs = sess.cstore.get_used_crates(cstore::RequireDynamic);\n     let libs = libs.move_iter().filter_map(|(_, l)| l.map(|p| p.clone())).collect();\n@@ -55,7 +55,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> ~[~str] {\n \n fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n     let r = filesearch::relative_target_lib_path(sess.opts.target_triple);\n-    let mut p = sess.filesearch.sysroot().join(&r);\n+    let mut p = sess.filesearch.sysroot.join(&r);\n     p.push(os::dll_filename(\"rustrt\"));\n     p\n }"}, {"sha": "b5dbf0e0c35c658bd7a5a820778f403a181d7cb7", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec6aba37d74e2ca8acfb961806726373909a7ac8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6aba37d74e2ca8acfb961806726373909a7ac8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=ec6aba37d74e2ca8acfb961806726373909a7ac8", "patch": "@@ -914,7 +914,7 @@ pub fn build_session_(sopts: @session::Options,\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n                                                     cm);\n     let cstore = @CStore::new(token::get_ident_interner());\n-    let filesearch = filesearch::mk_filesearch(\n+    let filesearch = @filesearch::FileSearch::new(\n         &sopts.maybe_sysroot,\n         sopts.target_triple,\n         sopts.addl_lib_search_paths);"}, {"sha": "f8e7a28d27708117066d7c43f7c2c26dd99ff7a2", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 94, "deletions": 109, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/ec6aba37d74e2ca8acfb961806726373909a7ac8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6aba37d74e2ca8acfb961806726373909a7ac8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=ec6aba37d74e2ca8acfb961806726373909a7ac8", "patch": "@@ -25,132 +25,117 @@ pub enum FileMatch { FileMatches, FileDoesntMatch }\n /// a file found in that directory.\n pub type pick<'a> = 'a |path: &Path| -> FileMatch;\n \n-pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n-    if path.filename() == Some(file.as_vec()) {\n-        Some(path.clone())\n-    } else {\n-        None\n-    }\n-}\n-\n-pub trait FileSearch {\n-    fn sysroot(&self) -> @Path;\n-    fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch);\n-    fn get_target_lib_path(&self) -> Path;\n-    fn get_target_lib_file_path(&self, file: &Path) -> Path;\n+pub struct FileSearch {\n+    sysroot: @Path,\n+    addl_lib_search_paths: @RefCell<HashSet<Path>>,\n+    target_triple: ~str\n }\n \n-pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n-                     target_triple: &str,\n-                     addl_lib_search_paths: @RefCell<HashSet<Path>>)\n-                  -> @FileSearch {\n-    struct FileSearchImpl {\n-        sysroot: @Path,\n-        addl_lib_search_paths: @RefCell<HashSet<Path>>,\n-        target_triple: ~str\n-    }\n-    impl FileSearch for FileSearchImpl {\n-        fn sysroot(&self) -> @Path { self.sysroot }\n-\n-        fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch) {\n-            let mut visited_dirs = HashSet::new();\n-            let mut found = false;\n-\n-            let addl_lib_search_paths = self.addl_lib_search_paths.borrow();\n-            debug!(\"filesearch: searching additional lib search paths [{:?}]\",\n-                   addl_lib_search_paths.get().len());\n-            for path in addl_lib_search_paths.get().iter() {\n-                match f(path) {\n-                    FileMatches => found = true,\n-                    FileDoesntMatch => ()\n-                }\n-                visited_dirs.insert(path.as_vec().to_owned());\n+impl FileSearch {\n+    pub fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch) {\n+        let mut visited_dirs = HashSet::new();\n+        let mut found = false;\n+\n+        let addl_lib_search_paths = self.addl_lib_search_paths.borrow();\n+        debug!(\"filesearch: searching additional lib search paths [{:?}]\",\n+               addl_lib_search_paths.get().len());\n+        for path in addl_lib_search_paths.get().iter() {\n+            match f(path) {\n+                FileMatches => found = true,\n+                FileDoesntMatch => ()\n             }\n+            visited_dirs.insert(path.as_vec().to_owned());\n+        }\n \n-            debug!(\"filesearch: searching target lib path\");\n-            let tlib_path = make_target_lib_path(self.sysroot,\n-                                        self.target_triple);\n-            if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n-                match f(&tlib_path) {\n-                    FileMatches => found = true,\n-                    FileDoesntMatch => ()\n-                }\n+        debug!(\"filesearch: searching target lib path\");\n+        let tlib_path = make_target_lib_path(self.sysroot,\n+                                    self.target_triple);\n+        if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n+            match f(&tlib_path) {\n+                FileMatches => found = true,\n+                FileDoesntMatch => ()\n             }\n-            visited_dirs.insert(tlib_path.as_vec().to_owned());\n-            // Try RUST_PATH\n-            if !found {\n-                let rustpath = rust_path();\n-                for path in rustpath.iter() {\n-                    let tlib_path = make_rustpkg_target_lib_path(path, self.target_triple);\n-                    debug!(\"is {} in visited_dirs? {:?}\", tlib_path.display(),\n-                            visited_dirs.contains_equiv(&tlib_path.as_vec().to_owned()));\n-\n-                    if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n-                        visited_dirs.insert(tlib_path.as_vec().to_owned());\n-                        // Don't keep searching the RUST_PATH if one match turns up --\n-                        // if we did, we'd get a \"multiple matching crates\" error\n-                        match f(&tlib_path) {\n-                           FileMatches => {\n-                               break;\n-                           }\n-                           FileDoesntMatch => ()\n-                        }\n+        }\n+        visited_dirs.insert(tlib_path.as_vec().to_owned());\n+        // Try RUST_PATH\n+        if !found {\n+            let rustpath = rust_path();\n+            for path in rustpath.iter() {\n+                let tlib_path = make_rustpkg_target_lib_path(path, self.target_triple);\n+                debug!(\"is {} in visited_dirs? {:?}\", tlib_path.display(),\n+                        visited_dirs.contains_equiv(&tlib_path.as_vec().to_owned()));\n+\n+                if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n+                    visited_dirs.insert(tlib_path.as_vec().to_owned());\n+                    // Don't keep searching the RUST_PATH if one match turns up --\n+                    // if we did, we'd get a \"multiple matching crates\" error\n+                    match f(&tlib_path) {\n+                       FileMatches => {\n+                           break;\n+                       }\n+                       FileDoesntMatch => ()\n                     }\n                 }\n             }\n         }\n-        fn get_target_lib_path(&self) -> Path {\n-            make_target_lib_path(self.sysroot, self.target_triple)\n-        }\n-        fn get_target_lib_file_path(&self, file: &Path) -> Path {\n-            let mut p = self.get_target_lib_path();\n-            p.push(file);\n-            p\n-        }\n     }\n \n-    let sysroot = get_sysroot(maybe_sysroot);\n-    debug!(\"using sysroot = {}\", sysroot.display());\n-    @FileSearchImpl {\n-        sysroot: sysroot,\n-        addl_lib_search_paths: addl_lib_search_paths,\n-        target_triple: target_triple.to_owned()\n-    } as @FileSearch\n-}\n+    pub fn get_target_lib_path(&self) -> Path {\n+        make_target_lib_path(self.sysroot, self.target_triple)\n+    }\n \n-pub fn search(filesearch: @FileSearch, pick: pick) {\n-    filesearch.for_each_lib_search_path(|lib_search_path| {\n-        debug!(\"searching {}\", lib_search_path.display());\n-        match io::result(|| fs::readdir(lib_search_path)) {\n-            Ok(files) => {\n-                let mut rslt = FileDoesntMatch;\n-                let is_rlib = |p: & &Path| {\n-                    p.extension_str() == Some(\"rlib\")\n-                };\n-                // Reading metadata out of rlibs is faster, and if we find both\n-                // an rlib and a dylib we only read one of the files of\n-                // metadata, so in the name of speed, bring all rlib files to\n-                // the front of the search list.\n-                let files1 = files.iter().filter(|p| is_rlib(p));\n-                let files2 = files.iter().filter(|p| !is_rlib(p));\n-                for path in files1.chain(files2) {\n-                    debug!(\"testing {}\", path.display());\n-                    let maybe_picked = pick(path);\n-                    match maybe_picked {\n-                        FileMatches => {\n-                            debug!(\"picked {}\", path.display());\n-                            rslt = FileMatches;\n-                        }\n-                        FileDoesntMatch => {\n-                            debug!(\"rejected {}\", path.display());\n+    pub fn get_target_lib_file_path(&self, file: &Path) -> Path {\n+        let mut p = self.get_target_lib_path();\n+        p.push(file);\n+        p\n+    }\n+\n+    pub fn search(&self, pick: pick) {\n+        self.for_each_lib_search_path(|lib_search_path| {\n+            debug!(\"searching {}\", lib_search_path.display());\n+            match io::result(|| fs::readdir(lib_search_path)) {\n+                Ok(files) => {\n+                    let mut rslt = FileDoesntMatch;\n+                    let is_rlib = |p: & &Path| {\n+                        p.extension_str() == Some(\"rlib\")\n+                    };\n+                    // Reading metadata out of rlibs is faster, and if we find both\n+                    // an rlib and a dylib we only read one of the files of\n+                    // metadata, so in the name of speed, bring all rlib files to\n+                    // the front of the search list.\n+                    let files1 = files.iter().filter(|p| is_rlib(p));\n+                    let files2 = files.iter().filter(|p| !is_rlib(p));\n+                    for path in files1.chain(files2) {\n+                        debug!(\"testing {}\", path.display());\n+                        let maybe_picked = pick(path);\n+                        match maybe_picked {\n+                            FileMatches => {\n+                                debug!(\"picked {}\", path.display());\n+                                rslt = FileMatches;\n+                            }\n+                            FileDoesntMatch => {\n+                                debug!(\"rejected {}\", path.display());\n+                            }\n                         }\n                     }\n+                    rslt\n                 }\n-                rslt\n+                Err(..) => FileDoesntMatch,\n             }\n-            Err(..) => FileDoesntMatch,\n+        });\n+    }\n+\n+    pub fn new(maybe_sysroot: &Option<@Path>,\n+               target_triple: &str,\n+               addl_lib_search_paths: @RefCell<HashSet<Path>>) -> FileSearch {\n+        let sysroot = get_sysroot(maybe_sysroot);\n+        debug!(\"using sysroot = {}\", sysroot.display());\n+        FileSearch{\n+            sysroot: sysroot,\n+            addl_lib_search_paths: addl_lib_search_paths,\n+            target_triple: target_triple.to_owned()\n         }\n-    });\n+    }\n }\n \n pub fn relative_target_lib_path(target_triple: &str) -> Path {"}, {"sha": "72f2e1baddd7bdd7adb4a2d742382c8b49404358", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec6aba37d74e2ca8acfb961806726373909a7ac8/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6aba37d74e2ca8acfb961806726373909a7ac8/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=ec6aba37d74e2ca8acfb961806726373909a7ac8", "patch": "@@ -17,7 +17,6 @@ use metadata::cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n use metadata::decoder;\n use metadata::encoder;\n use metadata::filesearch::{FileMatches, FileDoesntMatch};\n-use metadata::filesearch;\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::IdentInterner;\n@@ -89,7 +88,7 @@ impl Context {\n         let rlib_prefix = format!(\"lib{}-\", crate_name);\n \n         let mut matches = ~[];\n-        filesearch::search(filesearch, |path| {\n+        filesearch.search(|path| {\n             match path.filename_str() {\n                 None => FileDoesntMatch,\n                 Some(file) => {"}]}