{"sha": "d94262272bbdc700689a012a2e8a34adbe2a0f18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NDI2MjI3MmJiZGM3MDA2ODlhMDEyYTJlOGEzNGFkYmUyYTBmMTg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2019-09-27T12:04:36Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2019-09-30T11:31:56Z"}, "message": "Self-Profiling: Make names of existing events more consistent and use new API.", "tree": {"sha": "4e5820ff332bf14b9b4d7708626352fc023a9de3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e5820ff332bf14b9b4d7708626352fc023a9de3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d94262272bbdc700689a012a2e8a34adbe2a0f18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d94262272bbdc700689a012a2e8a34adbe2a0f18", "html_url": "https://github.com/rust-lang/rust/commit/d94262272bbdc700689a012a2e8a34adbe2a0f18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d94262272bbdc700689a012a2e8a34adbe2a0f18/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0b073cdb07ccd392747fcaf1f1e949fe8921c1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b", "html_url": "https://github.com/rust-lang/rust/commit/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b"}], "stats": {"total": 280, "additions": 122, "deletions": 158}, "files": [{"sha": "955f1447c55b67c3d61aeec068a2860accd35b65", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             let mut lock = cache.get_shard_by_value(key).lock();\n             if let Some(value) = lock.results.get(key) {\n                 profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                tcx.sess.profiler(|p| p.record_query_hit(Q::NAME));\n+                tcx.prof.query_cache_hit(Q::NAME);\n                 let result = (value.value.clone(), value.index);\n                 #[cfg(debug_assertions)]\n                 {\n@@ -128,7 +128,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                             // in another thread has completed. Record how long we wait in the\n                             // self-profiler.\n                             #[cfg(parallel_compiler)]\n-                            tcx.sess.profiler(|p| p.query_blocked_start(Q::NAME));\n+                            tcx.prof.query_blocked_start(Q::NAME);\n \n                             job.clone()\n                         },\n@@ -170,7 +170,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             #[cfg(parallel_compiler)]\n             {\n                 let result = job.r#await(tcx, span);\n-                tcx.sess.profiler(|p| p.query_blocked_end(Q::NAME));\n+                tcx.prof.query_blocked_end(Q::NAME);\n \n                 if let Err(cycle) = result {\n                     return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n@@ -382,8 +382,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n         if Q::ANON {\n+\n             profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n-            self.sess.profiler(|p| p.start_query(Q::NAME));\n+            let prof_timer = self.prof.query_provider(Q::NAME);\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n                 self.start_query(job.job.clone(), diagnostics, |tcx| {\n@@ -393,7 +394,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 })\n             });\n \n-            self.sess.profiler(|p| p.end_query(Q::NAME));\n+            drop(prof_timer);\n             profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n             self.dep_graph.read_index(dep_node_index);\n@@ -451,9 +452,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         // First we try to load the result from the on-disk cache.\n         let result = if Q::cache_on_disk(self, key.clone(), None) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n-            self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n+            let _prof_timer = self.prof.incr_cache_loading(Q::NAME);\n             let result = Q::try_load_from_disk(self, prev_dep_node_index);\n-            self.sess.profiler(|p| p.incremental_load_result_end(Q::NAME));\n \n             // We always expect to find a cached result for things that\n             // can be forced from `DepNode`.\n@@ -469,21 +469,17 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let result = if let Some(result) = result {\n             profq_msg!(self, ProfileQueriesMsg::CacheHit);\n-            self.sess.profiler(|p| p.record_query_hit(Q::NAME));\n-\n             result\n         } else {\n             // We could not load a result from the on-disk cache, so\n             // recompute.\n-\n-            self.sess.profiler(|p| p.start_query(Q::NAME));\n+            let _prof_timer = self.prof.query_provider(Q::NAME);\n \n             // The dep-graph for this computation is already in-place.\n             let result = self.dep_graph.with_ignore(|| {\n                 Q::compute(self, key)\n             });\n \n-            self.sess.profiler(|p| p.end_query(Q::NAME));\n             result\n         };\n \n@@ -551,7 +547,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 key, dep_node);\n \n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n-        self.sess.profiler(|p| p.start_query(Q::NAME));\n+        let prof_timer = self.prof.query_provider(Q::NAME);\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n             self.start_query(job.job.clone(), diagnostics, |tcx| {\n@@ -571,7 +567,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             })\n         });\n \n-        self.sess.profiler(|p| p.end_query(Q::NAME));\n+        drop(prof_timer);\n         profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n         if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n@@ -619,7 +615,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n         } else {\n             profq_msg!(self, ProfileQueriesMsg::CacheHit);\n-            self.sess.profiler(|p| p.record_query_hit(Q::NAME));\n+            self.prof.query_cache_hit(Q::NAME);\n         }\n     }\n "}, {"sha": "c4368d2cb8b45df859f68b601512e617ae352702", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -62,11 +62,13 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     };\n     let exported_symbols = cgcx.exported_symbols\n         .as_ref().expect(\"needs exported symbols for LTO\");\n-    let mut symbol_white_list = exported_symbols[&LOCAL_CRATE]\n-        .iter()\n-        .filter_map(symbol_filter)\n-        .collect::<Vec<CString>>();\n-    let _timer = cgcx.profile_activity(\"generate_symbol_white_list_for_thinlto\");\n+    let mut symbol_white_list = {\n+        let _timer = cgcx.prof.generic_activity(\"LLVM_lto_generate_symbol_white_list\");\n+        exported_symbols[&LOCAL_CRATE]\n+            .iter()\n+            .filter_map(symbol_filter)\n+            .collect::<Vec<CString>>()\n+    };\n     info!(\"{} symbols to preserve in this crate\", symbol_white_list.len());\n \n     // If we're performing LTO for the entire crate graph, then for each of our\n@@ -95,14 +97,17 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         }\n \n         for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n-            let _timer = cgcx.profile_activity(format!(\"load: {}\", path.display()));\n             let exported_symbols = cgcx.exported_symbols\n                 .as_ref().expect(\"needs exported symbols for LTO\");\n-            symbol_white_list.extend(\n-                exported_symbols[&cnum]\n-                    .iter()\n-                    .filter_map(symbol_filter));\n+            {\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_lto_generate_symbol_white_list\");\n+                symbol_white_list.extend(\n+                    exported_symbols[&cnum]\n+                        .iter()\n+                        .filter_map(symbol_filter));\n+            }\n \n+            let _timer = cgcx.prof.generic_activity(\"LLVM_lto_load_upstream_bitcode\");\n             let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n             let bytecodes = archive.iter().filter_map(|child| {\n                 child.ok().and_then(|c| c.name().map(|name| (name, c)))\n@@ -189,6 +194,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            symbol_white_list: &[*const libc::c_char])\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n+    let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_build_monolithic_module\");\n     info!(\"going for a fat lto\");\n \n     // Sort out all our lists of incoming modules into two lists.\n@@ -287,6 +293,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // save and persist everything with the original module.\n         let mut linker = Linker::new(llmod);\n         for (bc_decoded, name) in serialized_modules {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_link_module\");\n             info!(\"linking {:?}\", name);\n             time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n                 let data = bc_decoded.data();\n@@ -388,6 +395,7 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             symbol_white_list: &[*const libc::c_char])\n     -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n {\n+    let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_global_analysis\");\n     unsafe {\n         info!(\"going for that thin, thin LTO\");\n \n@@ -601,16 +609,6 @@ impl ModuleBuffer {\n             llvm::LLVMRustModuleBufferCreate(m)\n         })\n     }\n-\n-    pub fn parse<'a>(\n-        &self,\n-        name: &str,\n-        cx: &'a llvm::Context,\n-        handler: &Handler,\n-    ) -> Result<&'a llvm::Module, FatalError> {\n-        let name = CString::new(name).unwrap();\n-        parse_module(cx, &name, self.data(), handler)\n-    }\n }\n \n impl ModuleBufferMethods for ModuleBuffer {\n@@ -723,7 +721,7 @@ pub unsafe fn optimize_thin_module(\n         // Like with \"fat\" LTO, get some better optimizations if landing pads\n         // are disabled by removing all landing pads.\n         if cgcx.no_landing_pads {\n-            let _timer = cgcx.profile_activity(\"LLVM_remove_landing_pads\");\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_remove_landing_pads\");\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n             save_temp_bitcode(&cgcx, &module, \"thin-lto-after-nounwind\");\n         }\n@@ -736,26 +734,41 @@ pub unsafe fn optimize_thin_module(\n         //\n         // You can find some more comments about these functions in the LLVM\n         // bindings we've got (currently `PassWrapper.cpp`)\n-        if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\";\n-            return Err(write::llvm_err(&diag_handler, msg))\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_rename\");\n+            if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\";\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-rename\");\n         }\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-rename\");\n-        if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\";\n-            return Err(write::llvm_err(&diag_handler, msg))\n+\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_resolve_weak\");\n+            if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\";\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-resolve\");\n         }\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-resolve\");\n-        if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\";\n-            return Err(write::llvm_err(&diag_handler, msg))\n+\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_internalize\");\n+            if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\";\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-internalize\");\n         }\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-internalize\");\n-        if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\";\n-            return Err(write::llvm_err(&diag_handler, msg))\n+\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_import\");\n+            if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\";\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-import\");\n         }\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-import\");\n \n         // Ok now this is a bit unfortunate. This is also something you won't\n         // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n@@ -786,18 +799,24 @@ pub unsafe fn optimize_thin_module(\n         // not too much) but for now at least gets LLVM to emit valid DWARF (or\n         // so it appears). Hopefully we can remove this once upstream bugs are\n         // fixed in LLVM.\n-        llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-patch\");\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_patch_debuginfo\");\n+            llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-patch\");\n+        }\n \n         // Alright now that we've done everything related to the ThinLTO\n         // analysis it's time to run some optimizations! Here we use the same\n         // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n         // populate a thin-specific pass manager, which presumably LLVM treats a\n         // little differently.\n-        info!(\"running thin lto passes over {}\", module.name);\n-        let config = cgcx.config(module.kind);\n-        run_pass_manager(cgcx, &module, config, true);\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-pm\");\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_optimize\");\n+            info!(\"running thin lto passes over {}\", module.name);\n+            let config = cgcx.config(module.kind);\n+            run_pass_manager(cgcx, &module, config, true);\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-pm\");\n+        }\n     }\n     Ok(module)\n }"}, {"sha": "78db90b57b53d4ed968ccd1f5e21d96a775be45c", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -306,6 +306,8 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                    config: &ModuleConfig)\n     -> Result<(), FatalError>\n {\n+    let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize\");\n+\n     let llmod = module.module_llvm.llmod();\n     let llcx = &*module.module_llvm.llcx;\n     let tm = &*module.module_llvm.tm;\n@@ -423,7 +425,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n         // Finally, run the actual optimization passes\n         {\n-            let _timer = cgcx.profile_activity(\"LLVM_function_passes\");\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n             time_ext(config.time_passes,\n                         None,\n                         &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n@@ -432,7 +434,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             });\n         }\n         {\n-            let _timer = cgcx.profile_activity(\"LLVM_module_passes\");\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n             time_ext(config.time_passes,\n                     None,\n                     &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n@@ -454,7 +456,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                   config: &ModuleConfig)\n     -> Result<CompiledModule, FatalError>\n {\n-    let _timer = cgcx.profile_activity(\"codegen\");\n+    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen\");\n     {\n         let llmod = module.module_llvm.llmod();\n         let llcx = &*module.module_llvm.llcx;\n@@ -505,25 +507,26 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n \n         if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n-            let _timer = cgcx.profile_activity(\"LLVM_make_bitcode\");\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_make_bitcode\");\n             let thin = ThinBuffer::new(llmod);\n             let data = thin.data();\n \n             if write_bc {\n-                let _timer = cgcx.profile_activity(\"LLVM_emit_bitcode\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_bitcode\");\n                 if let Err(e) = fs::write(&bc_out, data) {\n                     let msg = format!(\"failed to write bytecode to {}: {}\", bc_out.display(), e);\n                     diag_handler.err(&msg);\n                 }\n             }\n \n             if config.embed_bitcode {\n-                let _timer = cgcx.profile_activity(\"LLVM_embed_bitcode\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_embed_bitcode\");\n                 embed_bitcode(cgcx, llcx, llmod, Some(data));\n             }\n \n             if config.emit_bc_compressed {\n-                let _timer = cgcx.profile_activity(\"LLVM_compress_bitcode\");\n+                let _timer =\n+                    cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_compressed_bitcode\");\n                 let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n                 let data = bytecode::encode(&module.name, data);\n                 if let Err(e) = fs::write(&dst, data) {\n@@ -538,7 +541,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n             || -> Result<(), FatalError> {\n             if config.emit_ir {\n-                let _timer = cgcx.profile_activity(\"LLVM_emit_ir\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");\n                 let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n                 let out_c = path_to_c_string(&out);\n \n@@ -585,7 +588,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             }\n \n             if config.emit_asm || asm_to_obj {\n-                let _timer = cgcx.profile_activity(\"LLVM_emit_asm\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_asm\");\n                 let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n                 // We can't use the same module for asm and binary output, because that triggers\n@@ -603,13 +606,13 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             }\n \n             if write_obj {\n-                let _timer = cgcx.profile_activity(\"LLVM_emit_obj\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_obj\");\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                       llvm::FileType::ObjectFile)\n                 })?;\n             } else if asm_to_obj {\n-                let _timer = cgcx.profile_activity(\"LLVM_asm_to_obj\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_asm_to_obj\");\n                 let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n                 run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n "}, {"sha": "bd7d0d4017dce471ca700efef316014b1e5aace6", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -108,6 +108,7 @@ pub fn compile_codegen_unit(\n     cgu_name: InternedString,\n     tx_to_llvm_workers: &std::sync::mpsc::Sender<Box<dyn std::any::Any + Send>>,\n ) {\n+    let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n@@ -119,6 +120,7 @@ pub fn compile_codegen_unit(\n         dep_graph::hash_result,\n     );\n     let time_to_codegen = start_time.elapsed();\n+    drop(prof_timer);\n \n     // We assume that the cost to run LLVM on a CGU is proportional to\n     // the time we needed for codegenning it."}, {"sha": "9bacd8a5f56ba9191cd6d00f58b120060bf6deb6", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -323,8 +323,9 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        sess.profiler(|p| p.start_activity(\"link_crate\"));\n         time(sess, \"linking\", || {\n+            let _prof_timer = sess.prof.generic_activity(\"link_crate\");\n+\n             use rustc_codegen_ssa::back::link::link_binary;\n             use crate::back::archive::LlvmArchiveBuilder;\n \n@@ -337,7 +338,6 @@ impl CodegenBackend for LlvmCodegenBackend {\n                 target_cpu,\n             );\n         });\n-        sess.profiler(|p| p.end_activity(\"link_crate\"));\n \n         // Now that we won't touch anything in the incremental compilation directory\n         // any more, we can finalize it (which involves renaming it)"}, {"sha": "f1cfac270332223d80d3a766bd22889208a934f2", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 11, "deletions": 67, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -19,7 +19,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n use rustc::util::common::{time_depth, set_time_depth, print_time_passes_entry};\n-use rustc::util::profiling::SelfProfiler;\n+use rustc::util::profiling::SelfProfilerRef;\n use rustc_fs_util::link_or_copy;\n use rustc_data_structures::svh::Svh;\n use rustc_errors::{Handler, Level, FatalError, DiagnosticId};\n@@ -31,7 +31,6 @@ use syntax_pos::symbol::{Symbol, sym};\n use jobserver::{Client, Acquired};\n \n use std::any::Any;\n-use std::borrow::Cow;\n use std::fs;\n use std::io;\n use std::mem;\n@@ -196,42 +195,13 @@ impl<B: WriteBackendMethods> Clone for TargetMachineFactory<B> {\n     }\n }\n \n-pub struct ProfileGenericActivityTimer {\n-    profiler: Option<Arc<SelfProfiler>>,\n-    label: Cow<'static, str>,\n-}\n-\n-impl ProfileGenericActivityTimer {\n-    pub fn start(\n-        profiler: Option<Arc<SelfProfiler>>,\n-        label: Cow<'static, str>,\n-    ) -> ProfileGenericActivityTimer {\n-        if let Some(profiler) = &profiler {\n-            profiler.start_activity(label.clone());\n-        }\n-\n-        ProfileGenericActivityTimer {\n-            profiler,\n-            label,\n-        }\n-    }\n-}\n-\n-impl Drop for ProfileGenericActivityTimer {\n-    fn drop(&mut self) {\n-        if let Some(profiler) = &self.profiler {\n-            profiler.end_activity(self.label.clone());\n-        }\n-    }\n-}\n-\n /// Additional resources used by optimize_and_codegen (not module specific)\n #[derive(Clone)]\n pub struct CodegenContext<B: WriteBackendMethods> {\n     // Resources needed when running LTO\n     pub backend: B,\n     pub time_passes: bool,\n-    pub profiler: Option<Arc<SelfProfiler>>,\n+    pub prof: SelfProfilerRef,\n     pub lto: Lto,\n     pub no_landing_pads: bool,\n     pub save_temps: bool,\n@@ -283,31 +253,6 @@ impl<B: WriteBackendMethods> CodegenContext<B> {\n             ModuleKind::Allocator => &self.allocator_module_config,\n         }\n     }\n-\n-    #[inline(never)]\n-    #[cold]\n-    fn profiler_active<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n-        match &self.profiler {\n-            None => bug!(\"profiler_active() called but there was no profiler active\"),\n-            Some(profiler) => {\n-                f(&*profiler);\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub fn profile<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n-        if unlikely!(self.profiler.is_some()) {\n-            self.profiler_active(f)\n-        }\n-    }\n-\n-    pub fn profile_activity(\n-        &self,\n-        label: impl Into<Cow<'static, str>>,\n-    ) -> ProfileGenericActivityTimer {\n-        ProfileGenericActivityTimer::start(self.profiler.clone(), label.into())\n-    }\n }\n \n fn generate_lto_work<B: ExtraBackendMethods>(\n@@ -316,7 +261,7 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n     needs_thin_lto: Vec<(String, B::ThinBuffer)>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n-    cgcx.profile(|p| p.start_activity(\"codegen_run_lto\"));\n+    let _prof_timer = cgcx.prof.generic_activity(\"codegen_run_lto\");\n \n     let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n         assert!(needs_thin_lto.is_empty());\n@@ -343,8 +288,6 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n         }), 0)\n     })).collect();\n \n-    cgcx.profile(|p| p.end_activity(\"codegen_run_lto\"));\n-\n     result\n }\n \n@@ -380,6 +323,9 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n ) -> OngoingCodegen<B> {\n     let (coordinator_send, coordinator_receive) = channel();\n     let sess = tcx.sess;\n+\n+    sess.prof.generic_activity_start(\"codegen_and_optimize_crate\");\n+\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, sym::no_builtins);\n@@ -1088,7 +1034,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         save_temps: sess.opts.cg.save_temps,\n         opts: Arc::new(sess.opts.clone()),\n         time_passes: sess.time_extended(),\n-        profiler: sess.self_profiling.clone(),\n+        prof: sess.prof.clone(),\n         exported_symbols,\n         plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n         remark: sess.opts.cg.remark.clone(),\n@@ -1645,12 +1591,8 @@ fn spawn_work<B: ExtraBackendMethods>(\n         // as a diagnostic was already sent off to the main thread - just\n         // surface that there was an error in this worker.\n         bomb.result = {\n-            let label = work.name();\n-            cgcx.profile(|p| p.start_activity(label.clone()));\n-            let result = execute_work_item(&cgcx, work).ok();\n-            cgcx.profile(|p| p.end_activity(label));\n-\n-            result\n+            let _prof_timer = cgcx.prof.generic_activity(&work.name());\n+            execute_work_item(&cgcx, work).ok()\n         };\n     });\n }\n@@ -1835,6 +1777,8 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n             self.backend.print_pass_timings()\n         }\n \n+        sess.prof.generic_activity_end(\"codegen_and_optimize_crate\");\n+\n         (CodegenResults {\n             crate_name: self.crate_name,\n             crate_hash: self.crate_hash,"}, {"sha": "250916d6279c42f8c707b3dbd1f54dde75f751b1", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -559,7 +559,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     if need_metadata_module {\n         // Codegen the encoded metadata.\n-        tcx.sess.profiler(|p| p.start_activity(\"codegen crate metadata\"));\n+        let _prof_timer = tcx.prof.generic_activity(\"codegen_crate_metadata\");\n \n         let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n                                                                 &[\"crate\"],\n@@ -570,7 +570,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             backend.write_compressed_metadata(tcx, &ongoing_codegen.metadata,\n                                               &mut metadata_llvm_module);\n         });\n-        tcx.sess.profiler(|p| p.end_activity(\"codegen crate metadata\"));\n \n         let metadata_module = ModuleCodegen {\n             name: metadata_cgu_name,\n@@ -599,11 +598,9 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                tcx.sess.profiler(|p| p.start_activity(format!(\"codegen {}\", cgu.name())));\n                 let start_time = Instant::now();\n                 backend.compile_codegen_unit(tcx, *cgu.name(), &ongoing_codegen.coordinator_send);\n                 total_codegen_time += start_time.elapsed();\n-                tcx.sess.profiler(|p| p.end_activity(format!(\"codegen {}\", cgu.name())));\n                 false\n             }\n             CguReuse::PreLto => {"}, {"sha": "5017a60ca699a2cd83303bc2ac92dec92e85a6f4", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -21,7 +21,6 @@\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_data_structures;\n #[macro_use] extern crate syntax;\n \n use std::path::PathBuf;"}, {"sha": "6af065513ee0dccf9f6f00343ea1a491bb335bb5", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -28,6 +28,8 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n \n         join(move || {\n             if tcx.sess.opts.debugging_opts.incremental_queries {\n+                let _timer = tcx.prof.generic_activity(\"incr_comp_persist_result_cache\");\n+\n                 time(sess, \"persist query result cache\", || {\n                     save_in(sess,\n                             query_cache_path,\n@@ -36,6 +38,8 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n             }\n         }, || {\n             time(sess, \"persist dep-graph\", || {\n+                let _timer = tcx.prof.generic_activity(\"incr_comp_persist_dep_graph\");\n+\n                 save_in(sess,\n                         dep_graph_path,\n                         |e| {\n@@ -135,6 +139,7 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n \n     // Encode the graph data.\n     let serialized_graph = time(tcx.sess, \"getting serialized graph\", || {\n+        let _timer = tcx.prof.generic_activity(\"incr_comp_serialize_dep_graph\");\n         tcx.dep_graph.serialize()\n     });\n \n@@ -214,6 +219,7 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n     }\n \n     time(tcx.sess, \"encoding serialized graph\", || {\n+        let _timer = tcx.prof.generic_activity(\"incr_comp_encode_serialized_dep_graph\");\n         serialized_graph.encode(encoder).unwrap();\n     });\n }"}, {"sha": "13e95b0f72db7b8b947e5bbc5a2cac4703df86e3", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -59,15 +59,17 @@ use std::rc::Rc;\n pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     sess.diagnostic()\n         .set_continue_after_error(sess.opts.debugging_opts.continue_parse_after_error);\n-    sess.profiler(|p| p.start_activity(\"parsing\"));\n-    let krate = time(sess, \"parsing\", || match *input {\n-        Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n-        Input::Str {\n-            ref input,\n-            ref name,\n-        } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n+    let krate = time(sess, \"parsing\", || {\n+        let _prof_timer = sess.prof.generic_activity(\"parse_crate\");\n+\n+        match *input {\n+            Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n+            Input::Str {\n+                ref input,\n+                ref name,\n+            } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n+        }\n     })?;\n-    sess.profiler(|p| p.end_activity(\"parsing\"));\n \n     sess.diagnostic().set_continue_after_error(true);\n \n@@ -355,8 +357,8 @@ fn configure_and_expand_inner<'a>(\n     );\n \n     // Expand all macros\n-    sess.profiler(|p| p.start_activity(\"macro expansion\"));\n     krate = time(sess, \"expansion\", || {\n+        let _prof_timer = sess.prof.generic_activity(\"macro_expand_crate\");\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n         // dependent dlls. Note that this uses cfg!(windows) as opposed to\n@@ -430,7 +432,6 @@ fn configure_and_expand_inner<'a>(\n         }\n         krate\n     });\n-    sess.profiler(|p| p.end_activity(\"macro expansion\"));\n \n     time(sess, \"maybe building test harness\", || {\n         syntax_ext::test_harness::inject(\n@@ -1071,11 +1072,10 @@ pub fn start_codegen<'tcx>(\n         encode_and_write_metadata(tcx, outputs)\n     });\n \n-    tcx.sess.profiler(|p| p.start_activity(\"codegen crate\"));\n     let codegen = time(tcx.sess, \"codegen\", move || {\n+        let _prof_timer = tcx.prof.generic_activity(\"codegen_crate\");\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n     });\n-    tcx.sess.profiler(|p| p.end_activity(\"codegen crate\"));\n \n     if log_enabled!(::log::Level::Info) {\n         println!(\"Post-codegen\");"}, {"sha": "26a8f79b8d8315df83321766d6f8b72b3cadc161", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94262272bbdc700689a012a2e8a34adbe2a0f18/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d94262272bbdc700689a012a2e8a34adbe2a0f18", "patch": "@@ -295,7 +295,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n-    tcx.sess.profiler(|p| p.start_activity(\"type-check crate\"));\n+    let _prof_timer = tcx.prof.generic_activity(\"type_check_crate\");\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n@@ -347,8 +347,6 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);\n \n-    tcx.sess.profiler(|p| p.end_activity(\"type-check crate\"));\n-\n     if tcx.sess.err_count() == 0 {\n         Ok(())\n     } else {"}]}