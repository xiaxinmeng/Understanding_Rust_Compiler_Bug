{"sha": "876b26645913f7e600f5919db166ec5db0219aaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NmIyNjY0NTkxM2Y3ZTYwMGY1OTE5ZGIxNjZlYzVkYjAyMTlhYWY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-20T22:18:35Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-20T22:18:35Z"}, "message": "Make multiline errors work with codes", "tree": {"sha": "b4fa92a7dd69b02c19bdfa632b0e96eeedd4641f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4fa92a7dd69b02c19bdfa632b0e96eeedd4641f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/876b26645913f7e600f5919db166ec5db0219aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/876b26645913f7e600f5919db166ec5db0219aaf", "html_url": "https://github.com/rust-lang/rust/commit/876b26645913f7e600f5919db166ec5db0219aaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/876b26645913f7e600f5919db166ec5db0219aaf/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a4401fe828f2f29c359bc3c83f6f3b7eed27d83", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4401fe828f2f29c359bc3c83f6f3b7eed27d83", "html_url": "https://github.com/rust-lang/rust/commit/9a4401fe828f2f29c359bc3c83f6f3b7eed27d83"}], "stats": {"total": 115, "additions": 63, "deletions": 52}, "files": [{"sha": "4150335abc3d3080ddbc4a7dc3c2c239c1acd787", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 63, "deletions": 52, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/876b26645913f7e600f5919db166ec5db0219aaf/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/876b26645913f7e600f5919db166ec5db0219aaf/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=876b26645913f7e600f5919db166ec5db0219aaf", "patch": "@@ -76,61 +76,16 @@ impl Session {\n         self.diagnostic().handler().fatal(msg)\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        // Conditions for enabling multi-line errors:\n-        if !msg.contains(\"mismatched types\") &&\n-           !msg.contains(\"type mismatch resolving\") &&\n-           !msg.contains(\"if and else have incompatible types\") &&\n-           !msg.contains(\"if may be missing an else clause\") &&\n-           !msg.contains(\"match arms have incompatible types\") &&\n-           !msg.contains(\"structure constructor specifies a structure of type\") {\n-            return self.diagnostic().span_err(sp, msg);\n+        match split_msg_into_multilines(msg) {\n+            Some(msg) => self.diagnostic().span_err(sp, &msg[]),\n+            None => self.diagnostic().span_err(sp, msg)\n         }\n-\n-        let first  = Regex::new(r\"[( ]expected\").unwrap();\n-        let second = Regex::new(r\" found\").unwrap();\n-        let third  = Regex::new(\n-                     r\"\\((values differ|lifetime|cyclic type of infinite size)\").unwrap();\n-\n-        let mut new_msg = String::new();\n-        let mut head = 0u;\n-\n-        // Insert `\\n` before expected and found.\n-        for (pos1, pos2) in first.find_iter(msg).zip(\n-                            second.find_iter(msg)) {\n-            new_msg = new_msg +\n-            // A `(` may be preceded by a space and it should be trimmed\n-                      msg[head..pos1.0].trim_right() + // prefix\n-                      \"\\n\" +                           // insert before first\n-                      &msg[pos1.0..pos1.1] +           // insert what first matched\n-                      &msg[pos1.1..pos2.0] +           // between matches\n-                      \"\\n   \" +                        // insert before second\n-            //           123\n-            // `expected` is 3 char longer than `found`. To align the types, `found` gets\n-            // 3 spaces prepended.\n-                      &msg[pos2.0..pos2.1];            // insert what second matched\n-\n-            head = pos2.1;\n-        }\n-\n-        let mut tail = &msg[head..];\n-        // Insert `\\n` before any remaining messages which match.\n-        for pos in third.find_iter(tail).take(1) {\n-            // The end of the message may just be wrapped in `()` without `expected`/`found`.\n-            // Push this also to a new line and add the final tail after.\n-            new_msg = new_msg +\n-            // `(` is usually preceded by a space and should be trimmed.\n-                      tail[..pos.0].trim_right() + // prefix\n-                      \"\\n\" +                       // insert before paren\n-                      &tail[pos.0..];              // append the tail\n-\n-            tail = \"\";\n-        }\n-\n-        new_msg.push_str(tail);\n-        self.diagnostic().span_err(sp, &new_msg[])\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.diagnostic().span_err_with_code(sp, msg, code)\n+        match split_msg_into_multilines(msg) {\n+            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[], code),\n+            None => self.diagnostic().span_err_with_code(sp, msg, code)\n+        }\n     }\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().handler().err(msg)\n@@ -288,6 +243,62 @@ impl Session {\n     }\n }\n \n+fn split_msg_into_multilines(msg: &str) -> Option<String> {\n+    // Conditions for enabling multi-line errors:\n+    if !msg.contains(\"mismatched types\") &&\n+        !msg.contains(\"type mismatch resolving\") &&\n+        !msg.contains(\"if and else have incompatible types\") &&\n+        !msg.contains(\"if may be missing an else clause\") &&\n+        !msg.contains(\"match arms have incompatible types\") &&\n+        !msg.contains(\"structure constructor specifies a structure of type\") {\n+            return None\n+    }\n+\n+    let first  = Regex::new(r\"[( ]expected\").unwrap();\n+    let second = Regex::new(r\" found\").unwrap();\n+    let third  = Regex::new(\n+        r\"\\((values differ|lifetime|cyclic type of infinite size)\").unwrap();\n+\n+    let mut new_msg = String::new();\n+    let mut head = 0u;\n+\n+    // Insert `\\n` before expected and found.\n+    for (pos1, pos2) in first.find_iter(msg).zip(\n+        second.find_iter(msg)) {\n+        new_msg = new_msg +\n+            // A `(` may be preceded by a space and it should be trimmed\n+            msg[head..pos1.0].trim_right() + // prefix\n+            \"\\n\" +                           // insert before first\n+            &msg[pos1.0..pos1.1] +           // insert what first matched\n+            &msg[pos1.1..pos2.0] +           // between matches\n+            \"\\n   \" +                        // insert before second\n+            //           123\n+            // `expected` is 3 char longer than `found`. To align the types, `found` gets\n+            // 3 spaces prepended.\n+            &msg[pos2.0..pos2.1];            // insert what second matched\n+\n+        head = pos2.1;\n+    }\n+\n+    let mut tail = &msg[head..];\n+    // Insert `\\n` before any remaining messages which match.\n+    for pos in third.find_iter(tail).take(1) {\n+        // The end of the message may just be wrapped in `()` without `expected`/`found`.\n+        // Push this also to a new line and add the final tail after.\n+        new_msg = new_msg +\n+            // `(` is usually preceded by a space and should be trimmed.\n+            tail[..pos.0].trim_right() + // prefix\n+            \"\\n\" +                       // insert before paren\n+            &tail[pos.0..];              // append the tail\n+\n+        tail = \"\";\n+    }\n+\n+    new_msg.push_str(tail);\n+\n+    return Some(new_msg)\n+}\n+\n pub fn build_session(sopts: config::Options,\n                      local_crate_source_file: Option<Path>,\n                      registry: diagnostics::registry::Registry)"}]}