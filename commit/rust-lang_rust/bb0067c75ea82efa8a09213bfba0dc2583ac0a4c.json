{"sha": "bb0067c75ea82efa8a09213bfba0dc2583ac0a4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMDA2N2M3NWVhODJlZmE4YTA5MjEzYmZiYTBkYzI1ODNhYzBhNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-14T18:04:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-14T18:04:18Z"}, "message": "Auto merge of #76278 - jethrogb:jb/sgx-rwlock-init-test, r=Mark-Simulacrum\n\nImprove SGX RWLock initializer test\n\nr? `@eddyb`\n\nThis addresses https://github.com/pnkfelix/rust/pull/1#discussion_r374239895\n\nFixes https://github.com/fortanix/rust-sgx/issues/213", "tree": {"sha": "748acbeb26cf201c4f85b23e2a266bd9f85bbb92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748acbeb26cf201c4f85b23e2a266bd9f85bbb92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb0067c75ea82efa8a09213bfba0dc2583ac0a4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb0067c75ea82efa8a09213bfba0dc2583ac0a4c", "html_url": "https://github.com/rust-lang/rust/commit/bb0067c75ea82efa8a09213bfba0dc2583ac0a4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb0067c75ea82efa8a09213bfba0dc2583ac0a4c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57c5f40cf4d7685538f6e3a405612f939e0a5e47", "url": "https://api.github.com/repos/rust-lang/rust/commits/57c5f40cf4d7685538f6e3a405612f939e0a5e47", "html_url": "https://github.com/rust-lang/rust/commit/57c5f40cf4d7685538f6e3a405612f939e0a5e47"}, {"sha": "0b5e681f5af0d3989b49121969f09cf29f029263", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5e681f5af0d3989b49121969f09cf29f029263", "html_url": "https://github.com/rust-lang/rust/commit/0b5e681f5af0d3989b49121969f09cf29f029263"}], "stats": {"total": 34, "additions": 11, "deletions": 23}, "files": [{"sha": "17c9e72ee39fa2ed2b2e690f01d80dcd855a28e2", "filename": "library/std/src/sys/sgx/rwlock/tests.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb0067c75ea82efa8a09213bfba0dc2583ac0a4c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb0067c75ea82efa8a09213bfba0dc2583ac0a4c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs?ref=bb0067c75ea82efa8a09213bfba0dc2583ac0a4c", "patch": "@@ -1,14 +1,12 @@\n use super::*;\n-use crate::mem::{self, MaybeUninit};\n-use core::array::FixedSizeArray;\n \n-// Verify that the bytes of initialized RWLock are the same as in\n-// libunwind. If they change, `src/UnwindRustSgx.h` in libunwind needs to\n-// be changed too.\n+// Verify that the byte pattern libunwind uses to initialize an RWLock is\n+// equivalent to the value of RWLock::new(). If the value changes,\n+// `src/UnwindRustSgx.h` in libunwind needs to be changed too.\n #[test]\n fn test_c_rwlock_initializer() {\n     #[rustfmt::skip]\n-    const RWLOCK_INIT: &[u8] = &[\n+    const C_RWLOCK_INIT: &[u8] = &[\n         /* 0x00 */ 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n         /* 0x10 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n         /* 0x20 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n@@ -20,24 +18,14 @@ fn test_c_rwlock_initializer() {\n         /* 0x80 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n     ];\n \n-    #[inline(never)]\n-    fn zero_stack() {\n-        test::black_box(MaybeUninit::<[RWLock; 16]>::zeroed());\n-    }\n-\n-    #[inline(never)]\n-    unsafe fn rwlock_new(init: &mut MaybeUninit<RWLock>) {\n-        init.write(RWLock::new());\n-    }\n+    // For the test to work, we need the padding/unused bytes in RWLock to be\n+    // initialized as 0. In practice, this is the case with statics.\n+    static RUST_RWLOCK_INIT: RWLock = RWLock::new();\n \n     unsafe {\n-        // try hard to make sure that the padding/unused bytes in RWLock\n-        // get initialized as 0. If the assertion below fails, that might\n-        // just be an issue with the test code and not with the value of\n-        // RWLOCK_INIT.\n-        zero_stack();\n-        let mut init = MaybeUninit::<RWLock>::zeroed();\n-        rwlock_new(&mut init);\n-        assert_eq!(mem::transmute::<_, [u8; 144]>(init.assume_init()).as_slice(), RWLOCK_INIT)\n+        // If the assertion fails, that not necessarily an issue with the value\n+        // of C_RWLOCK_INIT. It might just be an issue with the way padding\n+        // bytes are initialized in the test code.\n+        assert_eq!(&crate::mem::transmute_copy::<_, [u8; 144]>(&RUST_RWLOCK_INIT), C_RWLOCK_INIT);\n     };\n }"}]}