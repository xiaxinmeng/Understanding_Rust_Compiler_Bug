{"sha": "c913b48928107710d6ec87a455b1ae6891297c2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MTNiNDg5MjgxMDc3MTBkNmVjODdhNDU1YjFhZTY4OTEyOTdjMmI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-30T07:16:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-30T07:16:23Z"}, "message": "Merge #1936\n\n1936: cleanup editor r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b0272446dd887cbfab9168e2a0379de1c6f10a6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0272446dd887cbfab9168e2a0379de1c6f10a6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c913b48928107710d6ec87a455b1ae6891297c2b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdkavHCRBK7hj4Ov3rIwAAdHIIAGDPbEy4XVwHjX/4o6GNv93E\nOvjPuxzFd67lK36+UrId2BPOoSdsLsXBm2f8C4/Du1D9vIONvjW9hNeUNBzgOFxM\nfFJHAO7vvEIQucywaMmy2753FKoL3GFLiASVWmsqcfGbYsEFiWTGriFgJam/PsAd\n4YaDXKuWOImj0ktYzf3gLKvFn2cckl3l7y70CNrGh2nuZ9VvS3P4cFuIFUE3spOn\nwEUljiSUYtpaTlxAw5zLuYAD0zLRMvM7YTtOkQcw0K/YxxCzaWWiy4xvV8mJWJ2J\n+vp3SwOuy1KfOm4qledAfzqaHKxrMEl+IsWQ3/sxm/LXaTYeTBMwUWdCMC+/aE0=\n=5Aw6\n-----END PGP SIGNATURE-----\n", "payload": "tree b0272446dd887cbfab9168e2a0379de1c6f10a6d\nparent dbdf0e24d51ce425c0066a76a0efc723e41e5071\nparent 4acadbdca61e77368061a0c53125e164912ab5d5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1569827783 +0000\ncommitter GitHub <noreply@github.com> 1569827783 +0000\n\nMerge #1936\n\n1936: cleanup editor r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c913b48928107710d6ec87a455b1ae6891297c2b", "html_url": "https://github.com/rust-lang/rust/commit/c913b48928107710d6ec87a455b1ae6891297c2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c913b48928107710d6ec87a455b1ae6891297c2b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbdf0e24d51ce425c0066a76a0efc723e41e5071", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbdf0e24d51ce425c0066a76a0efc723e41e5071", "html_url": "https://github.com/rust-lang/rust/commit/dbdf0e24d51ce425c0066a76a0efc723e41e5071"}, {"sha": "4acadbdca61e77368061a0c53125e164912ab5d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4acadbdca61e77368061a0c53125e164912ab5d5", "html_url": "https://github.com/rust-lang/rust/commit/4acadbdca61e77368061a0c53125e164912ab5d5"}], "stats": {"total": 566, "additions": 280, "deletions": 286}, "files": [{"sha": "5f564be0b24e9f3fb2309f73b552ef139e1c175d", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=c913b48928107710d6ec87a455b1ae6891297c2b", "patch": "@@ -2,7 +2,7 @@ use hir::db::HirDatabase;\n use ra_db::FileRange;\n use ra_fmt::{leading_indent, reindent};\n use ra_syntax::{\n-    algo::{find_covering_element, find_node_at_offset},\n+    algo::{self, find_covering_element, find_node_at_offset},\n     AstNode, SourceFile, SyntaxElement, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n     TokenAtOffset,\n };\n@@ -177,6 +177,10 @@ impl AssistBuilder {\n         &mut self.edit\n     }\n \n+    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n+        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n+    }\n+\n     fn build(self) -> AssistAction {\n         AssistAction {\n             edit: self.edit.finish(),"}, {"sha": "6fd1c37530eba41a5a3fb268f85ca7de48bb5d56", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=c913b48928107710d6ec87a455b1ae6891297c2b", "patch": "@@ -1,10 +1,10 @@\n use hir::{db::HirDatabase, HasSource};\n use ra_syntax::{\n-    ast::{self, make, AstNode, NameOwner},\n+    ast::{self, edit, make, AstNode, NameOwner},\n     SmolStr,\n };\n \n-use crate::{ast_editor::AstEditor, Assist, AssistCtx, AssistId};\n+use crate::{Assist, AssistCtx, AssistId};\n \n #[derive(PartialEq)]\n enum AddMissingImplMembersMode {\n@@ -75,30 +75,26 @@ fn add_missing_impl_members_inner(\n \n     ctx.add_action(AssistId(assist_id), label, |edit| {\n         let n_existing_items = impl_item_list.impl_items().count();\n-        let items = missing_items.into_iter().map(|it| match it {\n-            ast::ImplItem::FnDef(def) => strip_docstring(add_body(def).into()),\n-            _ => strip_docstring(it),\n-        });\n-        let mut ast_editor = AstEditor::new(impl_item_list);\n-\n-        ast_editor.append_items(items);\n-\n-        let first_new_item = ast_editor.ast().impl_items().nth(n_existing_items).unwrap();\n-        let cursor_position = first_new_item.syntax().text_range().start();\n-        ast_editor.into_text_edit(edit.text_edit_builder());\n-\n+        let items = missing_items\n+            .into_iter()\n+            .map(|it| match it {\n+                ast::ImplItem::FnDef(def) => ast::ImplItem::FnDef(add_body(def)),\n+                _ => it,\n+            })\n+            .map(|it| edit::strip_attrs_and_docs(&it));\n+        let new_impl_item_list = impl_item_list.append_items(items);\n+        let cursor_position = {\n+            let first_new_item = new_impl_item_list.impl_items().nth(n_existing_items).unwrap();\n+            first_new_item.syntax().text_range().start()\n+        };\n+\n+        edit.replace_ast(impl_item_list, new_impl_item_list);\n         edit.set_cursor(cursor_position);\n     });\n \n     ctx.build()\n }\n \n-fn strip_docstring(item: ast::ImplItem) -> ast::ImplItem {\n-    let mut ast_editor = AstEditor::new(item);\n-    ast_editor.strip_attrs_and_docs();\n-    ast_editor.ast().to_owned()\n-}\n-\n fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n     if fn_def.body().is_none() {\n         fn_def.with_body(make::block_from_expr(make::expr_unimplemented()))"}, {"sha": "39ff512335bc8114590ab6610d7a89ac54a57d9a", "filename": "crates/ra_assists/src/assists/move_bounds.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs?ref=c913b48928107710d6ec87a455b1ae6891297c2b", "patch": "@@ -1,11 +1,11 @@\n use hir::db::HirDatabase;\n use ra_syntax::{\n-    ast::{self, make, AstNode, NameOwner, TypeBoundsOwner},\n+    ast::{self, edit, make, AstNode, NameOwner, TypeBoundsOwner},\n     SyntaxElement,\n     SyntaxKind::*,\n };\n \n-use crate::{ast_editor::AstEditor, Assist, AssistCtx, AssistId};\n+use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let type_param_list = ctx.node_at_offset::<ast::TypeParamList>()?;\n@@ -39,14 +39,12 @@ pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>)\n                 .type_params()\n                 .filter(|it| it.type_bound_list().is_some())\n                 .map(|type_param| {\n-                    let without_bounds =\n-                        AstEditor::new(type_param.clone()).remove_bounds().ast().clone();\n+                    let without_bounds = type_param.remove_bounds();\n                     (type_param, without_bounds)\n                 });\n \n-            let mut ast_editor = AstEditor::new(type_param_list.clone());\n-            ast_editor.replace_descendants(new_params);\n-            ast_editor.into_text_edit(edit.text_edit_builder());\n+            let new_type_param_list = edit::replace_descendants(&type_param_list, new_params);\n+            edit.replace_ast(type_param_list.clone(), new_type_param_list);\n \n             let where_clause = {\n                 let predicates = type_param_list.type_params().filter_map(build_predicate);"}, {"sha": "72c8c478a743d0dc3d1836220aafaad59fd6c2f8", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "removed", "additions": 0, "deletions": 245, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/dbdf0e24d51ce425c0066a76a0efc723e41e5071/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbdf0e24d51ce425c0066a76a0efc723e41e5071/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=dbdf0e24d51ce425c0066a76a0efc723e41e5071", "patch": "@@ -1,245 +0,0 @@\n-use std::{iter, ops::RangeInclusive};\n-\n-use arrayvec::ArrayVec;\n-use rustc_hash::FxHashMap;\n-\n-use ra_fmt::leading_indent;\n-use ra_syntax::{\n-    algo,\n-    ast::{self, make::tokens, TypeBoundsOwner},\n-    AstNode, Direction, InsertPosition, SyntaxElement,\n-    SyntaxKind::*,\n-    T,\n-};\n-use ra_text_edit::TextEditBuilder;\n-\n-pub struct AstEditor<N: AstNode> {\n-    original_ast: N,\n-    ast: N,\n-}\n-\n-impl<N: AstNode> AstEditor<N> {\n-    pub fn new(node: N) -> AstEditor<N>\n-    where\n-        N: Clone,\n-    {\n-        AstEditor { original_ast: node.clone(), ast: node }\n-    }\n-\n-    pub fn into_text_edit(self, builder: &mut TextEditBuilder) {\n-        for (from, to) in algo::diff(&self.original_ast.syntax(), self.ast().syntax()) {\n-            builder.replace(from.text_range(), to.to_string())\n-        }\n-    }\n-\n-    pub fn ast(&self) -> &N {\n-        &self.ast\n-    }\n-\n-    pub fn replace_descendants<T: AstNode>(\n-        &mut self,\n-        replacement_map: impl Iterator<Item = (T, T)>,\n-    ) -> &mut Self {\n-        let map = replacement_map\n-            .map(|(from, to)| (from.syntax().clone().into(), to.syntax().clone().into()))\n-            .collect::<FxHashMap<_, _>>();\n-        let new_syntax = algo::replace_descendants(self.ast.syntax(), &map);\n-        self.ast = N::cast(new_syntax).unwrap();\n-        self\n-    }\n-\n-    #[must_use]\n-    fn insert_children(\n-        &self,\n-        position: InsertPosition<SyntaxElement>,\n-        mut to_insert: impl Iterator<Item = SyntaxElement>,\n-    ) -> N {\n-        let new_syntax = algo::insert_children(self.ast().syntax(), position, &mut to_insert);\n-        N::cast(new_syntax).unwrap()\n-    }\n-\n-    #[must_use]\n-    fn replace_children(\n-        &self,\n-        to_delete: RangeInclusive<SyntaxElement>,\n-        mut to_insert: impl Iterator<Item = SyntaxElement>,\n-    ) -> N {\n-        let new_syntax = algo::replace_children(self.ast().syntax(), to_delete, &mut to_insert);\n-        N::cast(new_syntax).unwrap()\n-    }\n-\n-    fn do_make_multiline(&mut self) {\n-        let l_curly =\n-            match self.ast().syntax().children_with_tokens().find(|it| it.kind() == T!['{']) {\n-                Some(it) => it,\n-                None => return,\n-            };\n-        let sibling = match l_curly.next_sibling_or_token() {\n-            Some(it) => it,\n-            None => return,\n-        };\n-        let existing_ws = match sibling.as_token() {\n-            None => None,\n-            Some(tok) if tok.kind() != WHITESPACE => None,\n-            Some(ws) => {\n-                if ws.text().contains('\\n') {\n-                    return;\n-                }\n-                Some(ws.clone())\n-            }\n-        };\n-\n-        let indent = leading_indent(self.ast().syntax()).unwrap_or(\"\".into());\n-        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n-        let to_insert = iter::once(ws.ws().into());\n-        self.ast = match existing_ws {\n-            None => self.insert_children(InsertPosition::After(l_curly), to_insert),\n-            Some(ws) => {\n-                self.replace_children(RangeInclusive::new(ws.clone().into(), ws.into()), to_insert)\n-            }\n-        };\n-    }\n-}\n-\n-impl AstEditor<ast::RecordFieldList> {\n-    pub fn append_field(&mut self, field: &ast::RecordField) {\n-        self.insert_field(InsertPosition::Last, field)\n-    }\n-\n-    pub fn insert_field(\n-        &mut self,\n-        position: InsertPosition<&'_ ast::RecordField>,\n-        field: &ast::RecordField,\n-    ) {\n-        let is_multiline = self.ast().syntax().text().contains_char('\\n');\n-        let ws;\n-        let space = if is_multiline {\n-            ws = tokens::WsBuilder::new(&format!(\n-                \"\\n{}    \",\n-                leading_indent(self.ast().syntax()).unwrap_or(\"\".into())\n-            ));\n-            ws.ws()\n-        } else {\n-            tokens::single_space()\n-        };\n-\n-        let mut to_insert: ArrayVec<[SyntaxElement; 4]> = ArrayVec::new();\n-        to_insert.push(space.into());\n-        to_insert.push(field.syntax().clone().into());\n-        to_insert.push(tokens::comma().into());\n-\n-        macro_rules! after_l_curly {\n-            () => {{\n-                let anchor = match self.l_curly() {\n-                    Some(it) => it,\n-                    None => return,\n-                };\n-                InsertPosition::After(anchor)\n-            }};\n-        }\n-\n-        macro_rules! after_field {\n-            ($anchor:expr) => {\n-                if let Some(comma) = $anchor\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    InsertPosition::After(comma)\n-                } else {\n-                    to_insert.insert(0, tokens::comma().into());\n-                    InsertPosition::After($anchor.syntax().clone().into())\n-                }\n-            };\n-        };\n-\n-        let position = match position {\n-            InsertPosition::First => after_l_curly!(),\n-            InsertPosition::Last => {\n-                if !is_multiline {\n-                    // don't insert comma before curly\n-                    to_insert.pop();\n-                }\n-                match self.ast().fields().last() {\n-                    Some(it) => after_field!(it),\n-                    None => after_l_curly!(),\n-                }\n-            }\n-            InsertPosition::Before(anchor) => {\n-                InsertPosition::Before(anchor.syntax().clone().into())\n-            }\n-            InsertPosition::After(anchor) => after_field!(anchor),\n-        };\n-\n-        self.ast = self.insert_children(position, to_insert.iter().cloned());\n-    }\n-\n-    fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.ast().syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n-    }\n-}\n-\n-impl AstEditor<ast::ItemList> {\n-    pub fn append_items(&mut self, items: impl Iterator<Item = ast::ImplItem>) {\n-        if !self.ast().syntax().text().contains_char('\\n') {\n-            self.do_make_multiline();\n-        }\n-        items.for_each(|it| self.append_item(it));\n-    }\n-\n-    pub fn append_item(&mut self, item: ast::ImplItem) {\n-        let (indent, position) = match self.ast().impl_items().last() {\n-            Some(it) => (\n-                leading_indent(it.syntax()).unwrap_or_default().to_string(),\n-                InsertPosition::After(it.syntax().clone().into()),\n-            ),\n-            None => match self.l_curly() {\n-                Some(it) => (\n-                    \"    \".to_string() + &leading_indent(self.ast().syntax()).unwrap_or_default(),\n-                    InsertPosition::After(it),\n-                ),\n-                None => return,\n-            },\n-        };\n-        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n-        let to_insert: ArrayVec<[SyntaxElement; 2]> =\n-            [ws.ws().into(), item.syntax().clone().into()].into();\n-        self.ast = self.insert_children(position, to_insert.into_iter());\n-    }\n-\n-    fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.ast().syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n-    }\n-}\n-\n-impl AstEditor<ast::ImplItem> {\n-    pub fn strip_attrs_and_docs(&mut self) {\n-        while let Some(start) = self\n-            .ast()\n-            .syntax()\n-            .children_with_tokens()\n-            .find(|it| it.kind() == ATTR || it.kind() == COMMENT)\n-        {\n-            let end = match &start.next_sibling_or_token() {\n-                Some(el) if el.kind() == WHITESPACE => el.clone(),\n-                Some(_) | None => start.clone(),\n-            };\n-            self.ast = self.replace_children(RangeInclusive::new(start, end), iter::empty());\n-        }\n-    }\n-}\n-\n-impl AstEditor<ast::TypeParam> {\n-    pub fn remove_bounds(&mut self) -> &mut Self {\n-        let colon = match self.ast.colon_token() {\n-            Some(it) => it,\n-            None => return self,\n-        };\n-        let end = match self.ast.type_bound_list() {\n-            Some(it) => it.syntax().clone().into(),\n-            None => colon.clone().into(),\n-        };\n-        self.ast = self.replace_children(RangeInclusive::new(colon.into(), end), iter::empty());\n-        self\n-    }\n-}"}, {"sha": "91b2a1dcefb870815040e7becbc313b62b0390ba", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=c913b48928107710d6ec87a455b1ae6891297c2b", "patch": "@@ -7,7 +7,6 @@\n \n mod assist_ctx;\n mod marks;\n-pub mod ast_editor;\n \n use hir::db::HirDatabase;\n use itertools::Itertools;"}, {"sha": "4fa07e3dc12311d4f27ca6c14a88bb649487d11d", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=c913b48928107710d6ec87a455b1ae6891297c2b", "patch": "@@ -2,10 +2,10 @@ use std::cell::RefCell;\n \n use hir::diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSink};\n use itertools::Itertools;\n-use ra_assists::ast_editor::AstEditor;\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n+    algo,\n     ast::{self, make, AstNode},\n     Location, SyntaxNode, TextRange, T,\n };\n@@ -56,15 +56,15 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         })\n     })\n     .on::<hir::diagnostics::MissingFields, _>(|d| {\n-        let node = d.ast(db);\n-        let mut ast_editor = AstEditor::new(node);\n+        let mut field_list = d.ast(db);\n         for f in d.missed_fields.iter() {\n             let field = make::record_field(make::name_ref(&f.to_string()), Some(make::expr_unit()));\n-            ast_editor.append_field(&field);\n+            field_list = field_list.append_field(&field);\n         }\n \n         let mut builder = TextEditBuilder::default();\n-        ast_editor.into_text_edit(&mut builder);\n+        algo::diff(&d.ast(db).syntax(), &field_list.syntax()).into_text_edit(&mut builder);\n+\n         let fix =\n             SourceChange::source_file_edit_from(\"fill struct fields\", file_id, builder.finish());\n         res.borrow_mut().push(Diagnostic {"}, {"sha": "f33d2ad4e36e8dc3d4d67534b9697bc92c2de872", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=c913b48928107710d6ec87a455b1ae6891297c2b", "patch": "@@ -3,6 +3,7 @@ pub mod visit;\n use std::ops::RangeInclusive;\n \n use itertools::Itertools;\n+use ra_text_edit::TextEditBuilder;\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -63,19 +64,31 @@ pub enum InsertPosition<T> {\n     After(T),\n }\n \n+pub struct TreeDiff {\n+    replacements: FxHashMap<SyntaxElement, SyntaxElement>,\n+}\n+\n+impl TreeDiff {\n+    pub fn into_text_edit(&self, builder: &mut TextEditBuilder) {\n+        for (from, to) in self.replacements.iter() {\n+            builder.replace(from.text_range(), to.to_string())\n+        }\n+    }\n+}\n+\n /// Finds minimal the diff, which, applied to `from`, will result in `to`.\n ///\n /// Specifically, returns a map whose keys are descendants of `from` and values\n /// are descendants of `to`, such that  `replace_descendants(from, map) == to`.\n ///\n /// A trivial solution is a singletom map `{ from: to }`, but this function\n /// tries to find a more fine-grained diff.\n-pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> FxHashMap<SyntaxElement, SyntaxElement> {\n+pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n     let mut buf = FxHashMap::default();\n     // FIXME: this is both horrible inefficient and gives larger than\n     // necessary diff. I bet there's a cool algorithm to diff trees properly.\n     go(&mut buf, from.clone().into(), to.clone().into());\n-    return buf;\n+    return TreeDiff { replacements: buf };\n \n     fn go(\n         buf: &mut FxHashMap<SyntaxElement, SyntaxElement>,"}, {"sha": "1b2ce921a51c8d128066b11b06305954095d2966", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=c913b48928107710d6ec87a455b1ae6891297c2b", "patch": "@@ -5,7 +5,7 @@ mod traits;\n mod tokens;\n mod extensions;\n mod expr_extensions;\n-mod edit;\n+pub mod edit;\n pub mod make;\n \n use std::marker::PhantomData;"}, {"sha": "03f3b5fbb00045768f440669c5eb65b7f48ce728", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 222, "deletions": 3, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=c913b48928107710d6ec87a455b1ae6891297c2b", "patch": "@@ -1,14 +1,21 @@\n //! This module contains functions for editing syntax trees. As the trees are\n //! immutable, all function here return a fresh copy of the tree, instead of\n //! doing an in-place modification.\n+use std::{iter, ops::RangeInclusive};\n \n use arrayvec::ArrayVec;\n-use std::ops::RangeInclusive;\n+use rustc_hash::FxHashMap;\n \n use crate::{\n     algo,\n-    ast::{self, make, AstNode},\n-    InsertPosition, SyntaxElement,\n+    ast::{\n+        self,\n+        make::{self, tokens},\n+        AstNode, TypeBoundsOwner,\n+    },\n+    AstToken, Direction, InsertPosition, SmolStr, SyntaxElement,\n+    SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n+    SyntaxNode, T,\n };\n \n impl ast::FnDef {\n@@ -31,6 +38,218 @@ impl ast::FnDef {\n     }\n }\n \n+impl ast::ItemList {\n+    #[must_use]\n+    pub fn append_items(&self, items: impl Iterator<Item = ast::ImplItem>) -> ast::ItemList {\n+        let mut res = self.clone();\n+        if !self.syntax().text().contains_char('\\n') {\n+            res = res.make_multiline();\n+        }\n+        items.for_each(|it| res = res.append_item(it));\n+        res\n+    }\n+\n+    #[must_use]\n+    pub fn append_item(&self, item: ast::ImplItem) -> ast::ItemList {\n+        let (indent, position) = match self.impl_items().last() {\n+            Some(it) => (\n+                leading_indent(it.syntax()).unwrap_or_default().to_string(),\n+                InsertPosition::After(it.syntax().clone().into()),\n+            ),\n+            None => match self.l_curly() {\n+                Some(it) => (\n+                    \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default(),\n+                    InsertPosition::After(it),\n+                ),\n+                None => return self.clone(),\n+            },\n+        };\n+        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+        let to_insert: ArrayVec<[SyntaxElement; 2]> =\n+            [ws.ws().into(), item.syntax().clone().into()].into();\n+        insert_children(self, position, to_insert.into_iter())\n+    }\n+\n+    fn l_curly(&self) -> Option<SyntaxElement> {\n+        self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n+    }\n+\n+    fn make_multiline(&self) -> ast::ItemList {\n+        let l_curly = match self.syntax().children_with_tokens().find(|it| it.kind() == T!['{']) {\n+            Some(it) => it,\n+            None => return self.clone(),\n+        };\n+        let sibling = match l_curly.next_sibling_or_token() {\n+            Some(it) => it,\n+            None => return self.clone(),\n+        };\n+        let existing_ws = match sibling.as_token() {\n+            None => None,\n+            Some(tok) if tok.kind() != WHITESPACE => None,\n+            Some(ws) => {\n+                if ws.text().contains('\\n') {\n+                    return self.clone();\n+                }\n+                Some(ws.clone())\n+            }\n+        };\n+\n+        let indent = leading_indent(self.syntax()).unwrap_or(\"\".into());\n+        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+        let to_insert = iter::once(ws.ws().into());\n+        match existing_ws {\n+            None => insert_children(self, InsertPosition::After(l_curly), to_insert),\n+            Some(ws) => {\n+                replace_children(self, RangeInclusive::new(ws.clone().into(), ws.into()), to_insert)\n+            }\n+        }\n+    }\n+}\n+\n+impl ast::RecordFieldList {\n+    #[must_use]\n+    pub fn append_field(&self, field: &ast::RecordField) -> ast::RecordFieldList {\n+        self.insert_field(InsertPosition::Last, field)\n+    }\n+\n+    #[must_use]\n+    pub fn insert_field(\n+        &self,\n+        position: InsertPosition<&'_ ast::RecordField>,\n+        field: &ast::RecordField,\n+    ) -> ast::RecordFieldList {\n+        let is_multiline = self.syntax().text().contains_char('\\n');\n+        let ws;\n+        let space = if is_multiline {\n+            ws = tokens::WsBuilder::new(&format!(\n+                \"\\n{}    \",\n+                leading_indent(self.syntax()).unwrap_or(\"\".into())\n+            ));\n+            ws.ws()\n+        } else {\n+            tokens::single_space()\n+        };\n+\n+        let mut to_insert: ArrayVec<[SyntaxElement; 4]> = ArrayVec::new();\n+        to_insert.push(space.into());\n+        to_insert.push(field.syntax().clone().into());\n+        to_insert.push(tokens::comma().into());\n+\n+        macro_rules! after_l_curly {\n+            () => {{\n+                let anchor = match self.l_curly() {\n+                    Some(it) => it,\n+                    None => return self.clone(),\n+                };\n+                InsertPosition::After(anchor)\n+            }};\n+        }\n+\n+        macro_rules! after_field {\n+            ($anchor:expr) => {\n+                if let Some(comma) = $anchor\n+                    .syntax()\n+                    .siblings_with_tokens(Direction::Next)\n+                    .find(|it| it.kind() == T![,])\n+                {\n+                    InsertPosition::After(comma)\n+                } else {\n+                    to_insert.insert(0, tokens::comma().into());\n+                    InsertPosition::After($anchor.syntax().clone().into())\n+                }\n+            };\n+        };\n+\n+        let position = match position {\n+            InsertPosition::First => after_l_curly!(),\n+            InsertPosition::Last => {\n+                if !is_multiline {\n+                    // don't insert comma before curly\n+                    to_insert.pop();\n+                }\n+                match self.fields().last() {\n+                    Some(it) => after_field!(it),\n+                    None => after_l_curly!(),\n+                }\n+            }\n+            InsertPosition::Before(anchor) => {\n+                InsertPosition::Before(anchor.syntax().clone().into())\n+            }\n+            InsertPosition::After(anchor) => after_field!(anchor),\n+        };\n+\n+        insert_children(self, position, to_insert.iter().cloned())\n+    }\n+\n+    fn l_curly(&self) -> Option<SyntaxElement> {\n+        self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n+    }\n+}\n+\n+impl ast::TypeParam {\n+    #[must_use]\n+    pub fn remove_bounds(&self) -> ast::TypeParam {\n+        let colon = match self.colon_token() {\n+            Some(it) => it,\n+            None => return self.clone(),\n+        };\n+        let end = match self.type_bound_list() {\n+            Some(it) => it.syntax().clone().into(),\n+            None => colon.clone().into(),\n+        };\n+        replace_children(self, RangeInclusive::new(colon.into(), end), iter::empty())\n+    }\n+}\n+\n+#[must_use]\n+pub fn strip_attrs_and_docs<N: ast::AttrsOwner>(node: &N) -> N {\n+    N::cast(strip_attrs_and_docs_inner(node.syntax().clone())).unwrap()\n+}\n+\n+fn strip_attrs_and_docs_inner(mut node: SyntaxNode) -> SyntaxNode {\n+    while let Some(start) =\n+        node.children_with_tokens().find(|it| it.kind() == ATTR || it.kind() == COMMENT)\n+    {\n+        let end = match &start.next_sibling_or_token() {\n+            Some(el) if el.kind() == WHITESPACE => el.clone(),\n+            Some(_) | None => start.clone(),\n+        };\n+        node = algo::replace_children(&node, RangeInclusive::new(start, end), &mut iter::empty());\n+    }\n+    node\n+}\n+\n+#[must_use]\n+pub fn replace_descendants<N: AstNode, D: AstNode>(\n+    parent: &N,\n+    replacement_map: impl Iterator<Item = (D, D)>,\n+) -> N {\n+    let map = replacement_map\n+        .map(|(from, to)| (from.syntax().clone().into(), to.syntax().clone().into()))\n+        .collect::<FxHashMap<_, _>>();\n+    let new_syntax = algo::replace_descendants(parent.syntax(), &map);\n+    N::cast(new_syntax).unwrap()\n+}\n+\n+// Note this is copy-pasted from fmt. It seems like fmt should be a separate\n+// crate, but basic tree building should be this crate. However, tree building\n+// might want to call into fmt...\n+fn leading_indent(node: &SyntaxNode) -> Option<SmolStr> {\n+    let prev_tokens = std::iter::successors(node.first_token(), |token| token.prev_token());\n+    for token in prev_tokens {\n+        if let Some(ws) = ast::Whitespace::cast(token.clone()) {\n+            let ws_text = ws.text();\n+            if let Some(pos) = ws_text.rfind('\\n') {\n+                return Some(ws_text[pos + 1..].into());\n+            }\n+        }\n+        if token.text().contains('\\n') {\n+            break;\n+        }\n+    }\n+    None\n+}\n+\n #[must_use]\n fn insert_children<N: AstNode>(\n     parent: &N,"}, {"sha": "8c5ece65d2bb1bd3cc4cc9bc14cd1d5d2ecc711f", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c913b48928107710d6ec87a455b1ae6891297c2b/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=c913b48928107710d6ec87a455b1ae6891297c2b", "patch": "@@ -4,7 +4,7 @@\n use itertools::Itertools;\n \n use crate::{\n-    ast::{self, child_opt, children, AstNode, SyntaxNode},\n+    ast::{self, child_opt, children, AstChildren, AstNode, SyntaxNode},\n     SmolStr, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxToken, T,\n@@ -203,6 +203,16 @@ impl ast::ImplBlock {\n     }\n }\n \n+impl ast::AttrsOwner for ast::ImplItem {\n+    fn attrs(&self) -> AstChildren<ast::Attr> {\n+        match self {\n+            ast::ImplItem::FnDef(it) => it.attrs(),\n+            ast::ImplItem::TypeAliasDef(it) => it.attrs(),\n+            ast::ImplItem::ConstDef(it) => it.attrs(),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum StructKind {\n     Tuple(ast::TupleFieldDefList),"}]}