{"sha": "1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "node_id": "C_kwDOAAsO6NoAKDFlOWY4ZGY2YmI1Mzg2OWQ1ZGZhNTMwNTczNzI1YmIwZWYzZWZmMDI", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-06-19T04:20:27Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-06-19T04:20:27Z"}, "message": "Move RegionKind to rustc_type_ir", "tree": {"sha": "cb9220ff111e1e98ec47c00add3156528e8ab24f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb9220ff111e1e98ec47c00add3156528e8ab24f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "html_url": "https://github.com/rust-lang/rust/commit/1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e430bfa9a6a9d81b25bddf6325069d217dc6f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e430bfa9a6a9d81b25bddf6325069d217dc6f3f", "html_url": "https://github.com/rust-lang/rust/commit/8e430bfa9a6a9d81b25bddf6325069d217dc6f3f"}], "stats": {"total": 941, "additions": 597, "deletions": 344}, "files": [{"sha": "fcb0978111ecb0cd379edb994640904fa7ffa9a3", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -500,7 +500,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Returns an iterator over all the region indices.\n-    pub fn regions(&self) -> impl Iterator<Item = RegionVid> + '_ {\n+    pub fn regions(&self) -> impl Iterator<Item = RegionVid> + 'tcx {\n         self.definitions.indices()\n     }\n "}, {"sha": "c9589a7048870338b4ceb4ad60c9014d57ef27e7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -114,6 +114,12 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type DelaySpanBugEmitted = DelaySpanBugEmitted;\n     type PredicateKind = ty::PredicateKind<'tcx>;\n     type AllocId = crate::mir::interpret::AllocId;\n+\n+    type EarlyBoundRegion = ty::EarlyBoundRegion;\n+    type BoundRegion = ty::BoundRegion;\n+    type FreeRegion = ty::FreeRegion;\n+    type RegionVid = ty::RegionVid;\n+    type PlaceholderRegion = ty::PlaceholderRegion;\n }\n \n /// A type that is not publicly constructable. This prevents people from making [`TyKind::Error`]s\n@@ -136,7 +142,7 @@ pub struct CtxtInterners<'tcx> {\n     type_: InternedSet<'tcx, WithStableHash<TyS<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n-    region: InternedSet<'tcx, RegionKind>,\n+    region: InternedSet<'tcx, RegionKind<'tcx>>,\n     poly_existential_predicates:\n         InternedSet<'tcx, List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>>,\n     predicate: InternedSet<'tcx, PredicateS<'tcx>>,\n@@ -2175,7 +2181,7 @@ macro_rules! direct_interners {\n }\n \n direct_interners! {\n-    region: mk_region(RegionKind): Region -> Region<'tcx>,\n+    region: mk_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n     const_: mk_const(ConstS<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n     layout: intern_layout(LayoutS<'tcx>): Layout -> Layout<'tcx>,\n@@ -2274,7 +2280,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Same a `self.mk_region(kind)`, but avoids accessing the interners if\n     /// `*r == kind`.\n     #[inline]\n-    pub fn reuse_or_mk_region(self, r: Region<'tcx>, kind: RegionKind) -> Region<'tcx> {\n+    pub fn reuse_or_mk_region(self, r: Region<'tcx>, kind: RegionKind<'tcx>) -> Region<'tcx> {\n         if *r == kind { r } else { self.mk_region(kind) }\n     }\n "}, {"sha": "88397a2bb56ba73fa5d49978bf462a9ab4b78460", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -11,7 +11,6 @@ use rustc_data_structures::stable_hasher::HashingControls;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_query_system::ich::StableHashingContext;\n use std::cell::RefCell;\n-use std::mem;\n \n impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for &'tcx ty::List<T>\n where\n@@ -102,43 +101,12 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArgKin\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::EarlyBoundRegion {\n+    #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::ReErased | ty::ReStatic => {\n-                // No variant fields to hash for these ...\n-            }\n-            ty::ReEmpty(universe) => {\n-                universe.hash_stable(hcx, hasher);\n-            }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrAnon(i), .. }) => {\n-                db.hash_stable(hcx, hasher);\n-                i.hash_stable(hcx, hasher);\n-            }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrNamed(def_id, name), .. }) => {\n-                db.hash_stable(hcx, hasher);\n-                def_id.hash_stable(hcx, hasher);\n-                name.hash_stable(hcx, hasher);\n-            }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrEnv, .. }) => {\n-                db.hash_stable(hcx, hasher);\n-            }\n-            ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }) => {\n-                def_id.hash_stable(hcx, hasher);\n-                index.hash_stable(hcx, hasher);\n-                name.hash_stable(hcx, hasher);\n-            }\n-            ty::ReFree(ref free_region) => {\n-                free_region.hash_stable(hcx, hasher);\n-            }\n-            ty::RePlaceholder(p) => {\n-                p.hash_stable(hcx, hasher);\n-            }\n-            ty::ReVar(reg) => {\n-                reg.hash_stable(hcx, hasher);\n-            }\n-        }\n+        self.def_id.hash_stable(hcx, hasher);\n+        self.index.hash_stable(hcx, hasher);\n+        self.name.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "77722085f2d32479b88cb52910d103212b302880", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 78, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -55,6 +55,7 @@ use std::{fmt, str};\n \n pub use crate::ty::diagnostics::*;\n pub use rustc_type_ir::InferTy::*;\n+pub use rustc_type_ir::RegionKind::*;\n pub use rustc_type_ir::TyKind::*;\n pub use rustc_type_ir::*;\n \n@@ -80,7 +81,6 @@ pub use self::list::List;\n pub use self::parameterized::ParameterizedOverTcx;\n pub use self::rvalue_scopes::RvalueScopes;\n pub use self::sty::BoundRegionKind::*;\n-pub use self::sty::RegionKind::*;\n pub use self::sty::{\n     Article, Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar,\n     BoundVariableKind, CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid,\n@@ -1161,83 +1161,6 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n     }\n }\n \n-rustc_index::newtype_index! {\n-    /// \"Universes\" are used during type- and trait-checking in the\n-    /// presence of `for<..>` binders to control what sets of names are\n-    /// visible. Universes are arranged into a tree: the root universe\n-    /// contains names that are always visible. Each child then adds a new\n-    /// set of names that are visible, in addition to those of its parent.\n-    /// We say that the child universe \"extends\" the parent universe with\n-    /// new names.\n-    ///\n-    /// To make this more concrete, consider this program:\n-    ///\n-    /// ```ignore (illustrative)\n-    /// struct Foo { }\n-    /// fn bar<T>(x: T) {\n-    ///   let y: for<'a> fn(&'a u8, Foo) = ...;\n-    /// }\n-    /// ```\n-    ///\n-    /// The struct name `Foo` is in the root universe U0. But the type\n-    /// parameter `T`, introduced on `bar`, is in an extended universe U1\n-    /// -- i.e., within `bar`, we can name both `T` and `Foo`, but outside\n-    /// of `bar`, we cannot name `T`. Then, within the type of `y`, the\n-    /// region `'a` is in a universe U2 that extends U1, because we can\n-    /// name it inside the fn type but not outside.\n-    ///\n-    /// Universes are used to do type- and trait-checking around these\n-    /// \"forall\" binders (also called **universal quantification**). The\n-    /// idea is that when, in the body of `bar`, we refer to `T` as a\n-    /// type, we aren't referring to any type in particular, but rather a\n-    /// kind of \"fresh\" type that is distinct from all other types we have\n-    /// actually declared. This is called a **placeholder** type, and we\n-    /// use universes to talk about this. In other words, a type name in\n-    /// universe 0 always corresponds to some \"ground\" type that the user\n-    /// declared, but a type name in a non-zero universe is a placeholder\n-    /// type -- an idealized representative of \"types in general\" that we\n-    /// use for checking generic functions.\n-    pub struct UniverseIndex {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"U{}\",\n-    }\n-}\n-\n-impl UniverseIndex {\n-    pub const ROOT: UniverseIndex = UniverseIndex::from_u32(0);\n-\n-    /// Returns the \"next\" universe index in order -- this new index\n-    /// is considered to extend all previous universes. This\n-    /// corresponds to entering a `forall` quantifier. So, for\n-    /// example, suppose we have this type in universe `U`:\n-    ///\n-    /// ```ignore (illustrative)\n-    /// for<'a> fn(&'a u32)\n-    /// ```\n-    ///\n-    /// Once we \"enter\" into this `for<'a>` quantifier, we are in a\n-    /// new universe that extends `U` -- in this new universe, we can\n-    /// name the region `'a`, but that region was not nameable from\n-    /// `U` because it was not in scope there.\n-    pub fn next_universe(self) -> UniverseIndex {\n-        UniverseIndex::from_u32(self.private.checked_add(1).unwrap())\n-    }\n-\n-    /// Returns `true` if `self` can name a name from `other` -- in other words,\n-    /// if the set of names in `self` is a superset of those in\n-    /// `other` (`self >= other`).\n-    pub fn can_name(self, other: UniverseIndex) -> bool {\n-        self.private >= other.private\n-    }\n-\n-    /// Returns `true` if `self` cannot name some names from `other` -- in other\n-    /// words, if the set of names in `self` is a strict subset of\n-    /// those in `other` (`self < other`).\n-    pub fn cannot_name(self, other: UniverseIndex) -> bool {\n-        self.private < other.private\n-    }\n-}\n-\n /// The \"placeholder index\" fully defines a placeholder region, type, or const. Placeholders are\n /// identified by both a universe, as well as a name residing within that universe. Distinct bound\n /// regions/types/consts within the same universe simply have an unknown relationship to one"}, {"sha": "d57cf8f014911d7d83131af22a2299279e42bfc7", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -57,7 +57,7 @@ pub trait Printer<'tcx>: Sized {\n         self.default_print_impl_path(impl_def_id, substs, self_ty, trait_ref)\n     }\n \n-    fn print_region(self, region: ty::Region<'_>) -> Result<Self::Region, Self::Error>;\n+    fn print_region(self, region: ty::Region<'tcx>) -> Result<Self::Region, Self::Error>;\n \n     fn print_type(self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error>;\n \n@@ -291,7 +291,7 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n     characteristic_def_id_of_type_cached(ty, &mut SsoHashSet::new())\n }\n \n-impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::Region<'_> {\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::Region<'tcx> {\n     type Output = P::Region;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {"}, {"sha": "97e5a4983fcd1c5b10655ca4212662c7abedd3b7", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -182,7 +182,7 @@ impl<'tcx> RegionHighlightMode<'tcx> {\n     }\n \n     /// Returns `Some(n)` with the number to use for the given region, if any.\n-    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n+    fn region_highlighted(&self, region: ty::Region<'tcx>) -> Option<usize> {\n         self.highlight_regions.iter().find_map(|h| match h {\n             Some((r, n)) if *r == region => Some(*n),\n             _ => None,\n@@ -276,7 +276,7 @@ pub trait PrettyPrinter<'tcx>:\n     /// Returns `true` if the region should be printed in\n     /// optional positions, e.g., `&'a T` or `dyn Tr + 'b`.\n     /// This is typically the case for all non-`'_` regions.\n-    fn should_print_region(&self, region: ty::Region<'_>) -> bool;\n+    fn should_print_region(&self, region: ty::Region<'tcx>) -> bool;\n \n     // Defaults (should not be overridden):\n \n@@ -1706,7 +1706,7 @@ impl<'tcx> Printer<'tcx> for FmtPrinter<'_, 'tcx> {\n         self.default_print_def_path(def_id, substs)\n     }\n \n-    fn print_region(self, region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n+    fn print_region(self, region: ty::Region<'tcx>) -> Result<Self::Region, Self::Error> {\n         self.pretty_print_region(region)\n     }\n \n@@ -1911,7 +1911,7 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n         Ok(inner)\n     }\n \n-    fn should_print_region(&self, region: ty::Region<'_>) -> bool {\n+    fn should_print_region(&self, region: ty::Region<'tcx>) -> bool {\n         let highlight = self.region_highlight_mode;\n         if highlight.region_highlighted(region).is_some() {\n             return true;\n@@ -1978,8 +1978,8 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n }\n \n // HACK(eddyb) limited to `FmtPrinter` because of `region_highlight_mode`.\n-impl FmtPrinter<'_, '_> {\n-    pub fn pretty_print_region(mut self, region: ty::Region<'_>) -> Result<Self, fmt::Error> {\n+impl<'tcx> FmtPrinter<'_, 'tcx> {\n+    pub fn pretty_print_region(mut self, region: ty::Region<'tcx>) -> Result<Self, fmt::Error> {\n         define_scoped_cx!(self);\n \n         // Watch out for region highlights.\n@@ -2383,15 +2383,6 @@ macro_rules! define_print_and_forward_display {\n     };\n }\n \n-// HACK(eddyb) this is separate because `ty::RegionKind` doesn't need lifting.\n-impl<'tcx> fmt::Display for ty::Region<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            f.write_str(&self.print(FmtPrinter::new(tcx, Namespace::TypeNS))?.into_buffer())\n-        })\n-    }\n-}\n-\n /// Wrapper type for `ty::TraitRef` which opts-in to pretty printing only\n /// the trait path. That is, it will print `Trait<U>` instead of\n /// `<T as Trait<U>>`.\n@@ -2456,6 +2447,7 @@ impl<'tcx> ty::PolyTraitPredicate<'tcx> {\n }\n \n forward_display_to_print! {\n+    ty::Region<'tcx>,\n     Ty<'tcx>,\n     &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ty::Const<'tcx>,"}, {"sha": "8ba5b882fdd57c97835c607e082e74efae0acbc4", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -81,30 +81,6 @@ impl fmt::Debug for ty::BoundRegionKind {\n     }\n }\n \n-impl fmt::Debug for ty::RegionKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::ReEarlyBound(ref data) => write!(f, \"ReEarlyBound({}, {})\", data.index, data.name),\n-\n-            ty::ReLateBound(binder_id, ref bound_region) => {\n-                write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n-            }\n-\n-            ty::ReFree(ref fr) => fr.fmt(f),\n-\n-            ty::ReStatic => write!(f, \"ReStatic\"),\n-\n-            ty::ReVar(ref vid) => vid.fmt(f),\n-\n-            ty::RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n-\n-            ty::ReEmpty(ui) => write!(f, \"ReEmpty({:?})\", ui),\n-\n-            ty::ReErased => write!(f, \"ReErased\"),\n-        }\n-    }\n-}\n-\n impl fmt::Debug for ty::FreeRegion {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)"}, {"sha": "296442e24360796582bebbab32ed28d8ae7102e6", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 149, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -29,11 +29,13 @@ use std::ops::{ControlFlow, Deref, Range};\n use ty::util::IntTypeExt;\n \n use rustc_type_ir::sty::TyKind::*;\n+use rustc_type_ir::RegionKind as IrRegionKind;\n use rustc_type_ir::TyKind as IrTyKind;\n \n // Re-export the `TyKind` from `rustc_type_ir` here for convenience\n #[rustc_diagnostic_item = \"TyKind\"]\n pub type TyKind<'tcx> = IrTyKind<TyCtxt<'tcx>>;\n+pub type RegionKind<'tcx> = IrRegionKind<TyCtxt<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n@@ -1308,12 +1310,12 @@ impl ParamConst {\n /// Use this rather than `RegionKind`, whenever possible.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n #[rustc_pass_by_value]\n-pub struct Region<'tcx>(pub Interned<'tcx, RegionKind>);\n+pub struct Region<'tcx>(pub Interned<'tcx, RegionKind<'tcx>>);\n \n impl<'tcx> Deref for Region<'tcx> {\n-    type Target = RegionKind;\n+    type Target = RegionKind<'tcx>;\n \n-    fn deref(&self) -> &RegionKind {\n+    fn deref(&self) -> &RegionKind<'tcx> {\n         &self.0.0\n     }\n }\n@@ -1324,157 +1326,19 @@ impl<'tcx> fmt::Debug for Region<'tcx> {\n     }\n }\n \n-/// Representation of regions. Note that the NLL checker uses a distinct\n-/// representation of regions. For this reason, it internally replaces all the\n-/// regions with inference variables -- the index of the variable is then used\n-/// to index into internal NLL data structures. See `rustc_const_eval::borrow_check`\n-/// module for more information.\n-///\n-/// Note: operations are on the wrapper `Region` type, which is interned,\n-/// rather than this type.\n-///\n-/// ## The Region lattice within a given function\n-///\n-/// In general, the region lattice looks like\n-///\n-/// ```text\n-/// static ----------+-----...------+       (greatest)\n-/// |                |              |\n-/// early-bound and  |              |\n-/// free regions     |              |\n-/// |                |              |\n-/// |                |              |\n-/// empty(root)   placeholder(U1)   |\n-/// |            /                  |\n-/// |           /         placeholder(Un)\n-/// empty(U1) --         /\n-/// |                   /\n-/// ...                /\n-/// |                 /\n-/// empty(Un) --------                      (smallest)\n-/// ```\n-///\n-/// Early-bound/free regions are the named lifetimes in scope from the\n-/// function declaration. They have relationships to one another\n-/// determined based on the declared relationships from the\n-/// function.\n-///\n-/// Note that inference variables and bound regions are not included\n-/// in this diagram. In the case of inference variables, they should\n-/// be inferred to some other region from the diagram.  In the case of\n-/// bound regions, they are excluded because they don't make sense to\n-/// include -- the diagram indicates the relationship between free\n-/// regions.\n-///\n-/// ## Inference variables\n-///\n-/// During region inference, we sometimes create inference variables,\n-/// represented as `ReVar`. These will be inferred by the code in\n-/// `infer::lexical_region_resolve` to some free region from the\n-/// lattice above (the minimal region that meets the\n-/// constraints).\n-///\n-/// During NLL checking, where regions are defined differently, we\n-/// also use `ReVar` -- in that case, the index is used to index into\n-/// the NLL region checker's data structures. The variable may in fact\n-/// represent either a free region or an inference variable, in that\n-/// case.\n-///\n-/// ## Bound Regions\n-///\n-/// These are regions that are stored behind a binder and must be substituted\n-/// with some concrete region before being used. There are two kind of\n-/// bound regions: early-bound, which are bound in an item's `Generics`,\n-/// and are substituted by an `InternalSubsts`, and late-bound, which are part of\n-/// higher-ranked types (e.g., `for<'a> fn(&'a ())`), and are substituted by\n-/// the likes of `liberate_late_bound_regions`. The distinction exists\n-/// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n-///\n-/// Unlike `Param`s, bound regions are not supposed to exist \"in the wild\"\n-/// outside their binder, e.g., in types passed to type inference, and\n-/// should first be substituted (by placeholder regions, free regions,\n-/// or region variables).\n-///\n-/// ## Placeholder and Free Regions\n-///\n-/// One often wants to work with bound regions without knowing their precise\n-/// identity. For example, when checking a function, the lifetime of a borrow\n-/// can end up being assigned to some region parameter. In these cases,\n-/// it must be ensured that bounds on the region can't be accidentally\n-/// assumed without being checked.\n-///\n-/// To do this, we replace the bound regions with placeholder markers,\n-/// which don't satisfy any relation not explicitly provided.\n-///\n-/// There are two kinds of placeholder regions in rustc: `ReFree` and\n-/// `RePlaceholder`. When checking an item's body, `ReFree` is supposed\n-/// to be used. These also support explicit bounds: both the internally-stored\n-/// *scope*, which the region is assumed to outlive, as well as other\n-/// relations stored in the `FreeRegionMap`. Note that these relations\n-/// aren't checked when you `make_subregion` (or `eq_types`), only by\n-/// `resolve_regions_and_report_errors`.\n-///\n-/// When working with higher-ranked types, some region relations aren't\n-/// yet known, so you can't just call `resolve_regions_and_report_errors`.\n-/// `RePlaceholder` is designed for this purpose. In these contexts,\n-/// there's also the risk that some inference variable laying around will\n-/// get unified with your placeholder region: if you want to check whether\n-/// `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a`\n-/// with a placeholder region `'%a`, the variable `'_` would just be\n-/// instantiated to the placeholder region `'%a`, which is wrong because\n-/// the inference variable is supposed to satisfy the relation\n-/// *for every value of the placeholder region*. To ensure that doesn't\n-/// happen, you can use `leak_check`. This is more clearly explained\n-/// by the [rustc dev guide].\n-///\n-/// [1]: https://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n-/// [2]: https://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n-/// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-#[derive(Clone, PartialEq, Eq, Hash, Copy, TyEncodable, TyDecodable, PartialOrd, Ord)]\n-pub enum RegionKind {\n-    /// Region bound in a type or fn declaration which will be\n-    /// substituted 'early' -- that is, at the same time when type\n-    /// parameters are substituted.\n-    ReEarlyBound(EarlyBoundRegion),\n-\n-    /// Region bound in a function scope, which will be substituted when the\n-    /// function is called.\n-    ReLateBound(ty::DebruijnIndex, BoundRegion),\n-\n-    /// When checking a function body, the types of all arguments and so forth\n-    /// that refer to bound region parameters are modified to refer to free\n-    /// region parameters.\n-    ReFree(FreeRegion),\n-\n-    /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n-    ReStatic,\n-\n-    /// A region variable. Should not exist outside of type inference.\n-    ReVar(RegionVid),\n-\n-    /// A placeholder region -- basically, the higher-ranked version of `ReFree`.\n-    /// Should not exist outside of type inference.\n-    RePlaceholder(ty::PlaceholderRegion),\n-\n-    /// Empty lifetime is for data that is never accessed.  We tag the\n-    /// empty lifetime with a universe -- the idea is that we don't\n-    /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n-    /// Therefore, the `'empty` in a universe `U` is less than all\n-    /// regions visible from `U`, but not less than regions not visible\n-    /// from `U`.\n-    ReEmpty(ty::UniverseIndex),\n-\n-    /// Erased region, used by trait selection, in MIR and during codegen.\n-    ReErased,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, PartialOrd, Ord)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, PartialOrd, Ord)]\n pub struct EarlyBoundRegion {\n     pub def_id: DefId,\n     pub index: u32,\n     pub name: Symbol,\n }\n \n+impl fmt::Debug for EarlyBoundRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}, {}\", self.index, self.name)\n+    }\n+}\n+\n /// A **`const`** **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct ConstVid<'tcx> {\n@@ -1590,7 +1454,7 @@ impl<'tcx> PolyExistentialProjection<'tcx> {\n \n /// Region utilities\n impl<'tcx> Region<'tcx> {\n-    pub fn kind(self) -> RegionKind {\n+    pub fn kind(self) -> RegionKind<'tcx> {\n         *self.0.0\n     }\n "}, {"sha": "ad2898ccd67bab19c14374286a8daaee0a487865", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -82,7 +82,7 @@ impl<'tcx> GenericArgKind<'tcx> {\n             GenericArgKind::Lifetime(lt) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(&*lt.0.0) & TAG_MASK, 0);\n-                (REGION_TAG, lt.0.0 as *const ty::RegionKind as usize)\n+                (REGION_TAG, lt.0.0 as *const ty::RegionKind<'tcx> as usize)\n             }\n             GenericArgKind::Type(ty) => {\n                 // Ensure we can use the tag bits.\n@@ -153,7 +153,7 @@ impl<'tcx> GenericArg<'tcx> {\n         unsafe {\n             match ptr & TAG_MASK {\n                 REGION_TAG => GenericArgKind::Lifetime(ty::Region(Interned::new_unchecked(\n-                    &*((ptr & !TAG_MASK) as *const ty::RegionKind),\n+                    &*((ptr & !TAG_MASK) as *const ty::RegionKind<'tcx>),\n                 ))),\n                 TYPE_TAG => GenericArgKind::Type(Ty(Interned::new_unchecked(\n                     &*((ptr & !TAG_MASK) as *const WithStableHash<ty::TyS<'tcx>>),"}, {"sha": "6c9f5a225ba07b22cb0f3b249f3309909d5e7416", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -574,7 +574,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n-        env_region: ty::RegionKind,\n+        env_region: ty::RegionKind<'tcx>,\n     ) -> Option<Ty<'tcx>> {\n         let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n         let closure_kind_ty = closure_substs.as_closure().kind_ty();"}, {"sha": "cb1602816ae5e85249d6ab1a54ea8f61b081d29c", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -42,6 +42,12 @@ pub trait Interner {\n     type DelaySpanBugEmitted: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type PredicateKind: Clone + Debug + Hash + PartialEq + Eq;\n     type AllocId: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+\n+    type EarlyBoundRegion: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type BoundRegion: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type FreeRegion: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type RegionVid: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type PlaceholderRegion: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n }\n \n pub trait InternAs<T: ?Sized, R> {\n@@ -767,3 +773,85 @@ impl fmt::Display for InferTy {\n         }\n     }\n }\n+\n+rustc_index::newtype_index! {\n+    /// \"Universes\" are used during type- and trait-checking in the\n+    /// presence of `for<..>` binders to control what sets of names are\n+    /// visible. Universes are arranged into a tree: the root universe\n+    /// contains names that are always visible. Each child then adds a new\n+    /// set of names that are visible, in addition to those of its parent.\n+    /// We say that the child universe \"extends\" the parent universe with\n+    /// new names.\n+    ///\n+    /// To make this more concrete, consider this program:\n+    ///\n+    /// ```ignore (illustrative)\n+    /// struct Foo { }\n+    /// fn bar<T>(x: T) {\n+    ///   let y: for<'a> fn(&'a u8, Foo) = ...;\n+    /// }\n+    /// ```\n+    ///\n+    /// The struct name `Foo` is in the root universe U0. But the type\n+    /// parameter `T`, introduced on `bar`, is in an extended universe U1\n+    /// -- i.e., within `bar`, we can name both `T` and `Foo`, but outside\n+    /// of `bar`, we cannot name `T`. Then, within the type of `y`, the\n+    /// region `'a` is in a universe U2 that extends U1, because we can\n+    /// name it inside the fn type but not outside.\n+    ///\n+    /// Universes are used to do type- and trait-checking around these\n+    /// \"forall\" binders (also called **universal quantification**). The\n+    /// idea is that when, in the body of `bar`, we refer to `T` as a\n+    /// type, we aren't referring to any type in particular, but rather a\n+    /// kind of \"fresh\" type that is distinct from all other types we have\n+    /// actually declared. This is called a **placeholder** type, and we\n+    /// use universes to talk about this. In other words, a type name in\n+    /// universe 0 always corresponds to some \"ground\" type that the user\n+    /// declared, but a type name in a non-zero universe is a placeholder\n+    /// type -- an idealized representative of \"types in general\" that we\n+    /// use for checking generic functions.\n+    pub struct UniverseIndex {\n+        DEBUG_FORMAT = \"U{}\",\n+    }\n+}\n+\n+impl UniverseIndex {\n+    pub const ROOT: UniverseIndex = UniverseIndex::from_u32(0);\n+\n+    /// Returns the \"next\" universe index in order -- this new index\n+    /// is considered to extend all previous universes. This\n+    /// corresponds to entering a `forall` quantifier. So, for\n+    /// example, suppose we have this type in universe `U`:\n+    ///\n+    /// ```ignore (illustrative)\n+    /// for<'a> fn(&'a u32)\n+    /// ```\n+    ///\n+    /// Once we \"enter\" into this `for<'a>` quantifier, we are in a\n+    /// new universe that extends `U` -- in this new universe, we can\n+    /// name the region `'a`, but that region was not nameable from\n+    /// `U` because it was not in scope there.\n+    pub fn next_universe(self) -> UniverseIndex {\n+        UniverseIndex::from_u32(self.private.checked_add(1).unwrap())\n+    }\n+\n+    /// Returns `true` if `self` can name a name from `other` -- in other words,\n+    /// if the set of names in `self` is a superset of those in\n+    /// `other` (`self >= other`).\n+    pub fn can_name(self, other: UniverseIndex) -> bool {\n+        self.private >= other.private\n+    }\n+\n+    /// Returns `true` if `self` cannot name some names from `other` -- in other\n+    /// words, if the set of names in `self` is a strict subset of\n+    /// those in `other` (`self < other`).\n+    pub fn cannot_name(self, other: UniverseIndex) -> bool {\n+        self.private < other.private\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for UniverseIndex {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        self.private.hash_stable(ctx, hasher);\n+    }\n+}"}, {"sha": "5cd2901324a2ead5e3bcf52c3e8e4d099a1fbc3e", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 468, "deletions": 32, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9f8df6bb53869d5dfa530573725bb0ef3eff02/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=1e9f8df6bb53869d5dfa530573725bb0ef3eff02", "patch": "@@ -10,7 +10,9 @@ use crate::Interner;\n use crate::TyDecoder;\n use crate::TyEncoder;\n use crate::UintTy;\n+use crate::UniverseIndex;\n \n+use self::RegionKind::*;\n use self::TyKind::*;\n \n use rustc_data_structures::stable_hasher::HashStable;\n@@ -20,8 +22,6 @@ use rustc_serialize::{Decodable, Decoder, Encodable};\n ///\n /// Types written by the user start out as `hir::TyKind` and get\n /// converted to this representation using `AstConv::ast_ty_to_ty`.\n-///\n-/// The `HashStable` implementation for this type is defined in `rustc_query_system::ich`.\n #[rustc_diagnostic_item = \"IrTyKind\"]\n pub enum TyKind<I: Interner> {\n     /// The primitive boolean type. Written as `bool`.\n@@ -202,7 +202,7 @@ impl<I: Interner> TyKind<I> {\n // This is manually implemented for `TyKind` because `std::mem::discriminant`\n // returns an opaque value that is `PartialEq` but not `PartialOrd`\n #[inline]\n-const fn discriminant<I: Interner>(value: &TyKind<I>) -> usize {\n+const fn tykind_discriminant<I: Interner>(value: &TyKind<I>) -> usize {\n     match value {\n         Bool => 0,\n         Char => 1,\n@@ -273,8 +273,8 @@ impl<I: Interner> Clone for TyKind<I> {\n impl<I: Interner> PartialEq for TyKind<I> {\n     #[inline]\n     fn eq(&self, other: &TyKind<I>) -> bool {\n-        let __self_vi = discriminant(self);\n-        let __arg_1_vi = discriminant(other);\n+        let __self_vi = tykind_discriminant(self);\n+        let __arg_1_vi = tykind_discriminant(other);\n         if __self_vi == __arg_1_vi {\n             match (&*self, &*other) {\n                 (&Int(ref __self_0), &Int(ref __arg_1_0)) => __self_0 == __arg_1_0,\n@@ -345,8 +345,8 @@ impl<I: Interner> PartialOrd for TyKind<I> {\n impl<I: Interner> Ord for TyKind<I> {\n     #[inline]\n     fn cmp(&self, other: &TyKind<I>) -> Ordering {\n-        let __self_vi = discriminant(self);\n-        let __arg_1_vi = discriminant(other);\n+        let __self_vi = tykind_discriminant(self);\n+        let __arg_1_vi = tykind_discriminant(other);\n         if __self_vi == __arg_1_vi {\n             match (&*self, &*other) {\n                 (&Int(ref __self_0), &Int(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n@@ -444,109 +444,109 @@ impl<I: Interner> hash::Hash for TyKind<I> {\n     fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n         match (&*self,) {\n             (&Int(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Uint(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Float(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Adt(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state);\n                 hash::Hash::hash(__self_1, state)\n             }\n             (&Foreign(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Array(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state);\n                 hash::Hash::hash(__self_1, state)\n             }\n             (&Slice(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&RawPtr(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Ref(ref __self_0, ref __self_1, ref __self_2),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state);\n                 hash::Hash::hash(__self_1, state);\n                 hash::Hash::hash(__self_2, state)\n             }\n             (&FnDef(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state);\n                 hash::Hash::hash(__self_1, state)\n             }\n             (&FnPtr(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Dynamic(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state);\n                 hash::Hash::hash(__self_1, state)\n             }\n             (&Closure(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state);\n                 hash::Hash::hash(__self_1, state)\n             }\n             (&Generator(ref __self_0, ref __self_1, ref __self_2),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state);\n                 hash::Hash::hash(__self_1, state);\n                 hash::Hash::hash(__self_2, state)\n             }\n             (&GeneratorWitness(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Tuple(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Projection(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Opaque(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state);\n                 hash::Hash::hash(__self_1, state)\n             }\n             (&Param(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Bound(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state);\n                 hash::Hash::hash(__self_1, state)\n             }\n             (&Placeholder(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Infer(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n             (&Error(ref __self_0),) => {\n-                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(&tykind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n-            _ => hash::Hash::hash(&discriminant(self), state),\n+            _ => hash::Hash::hash(&tykind_discriminant(self), state),\n         }\n     }\n }\n@@ -716,7 +716,7 @@ where\n     I::AllocId: Encodable<E>,\n {\n     fn encode(&self, e: &mut E) {\n-        let disc = discriminant(self);\n+        let disc = tykind_discriminant(self);\n         match self {\n             Bool => e.emit_enum_variant(disc, |_| {}),\n             Char => e.emit_enum_variant(disc, |_| {}),\n@@ -991,3 +991,439 @@ where\n         }\n     }\n }\n+\n+/// Representation of regions. Note that the NLL checker uses a distinct\n+/// representation of regions. For this reason, it internally replaces all the\n+/// regions with inference variables -- the index of the variable is then used\n+/// to index into internal NLL data structures. See `rustc_const_eval::borrow_check`\n+/// module for more information.\n+///\n+/// Note: operations are on the wrapper `Region` type, which is interned,\n+/// rather than this type.\n+///\n+/// ## The Region lattice within a given function\n+///\n+/// In general, the region lattice looks like\n+///\n+/// ```text\n+/// static ----------+-----...------+       (greatest)\n+/// |                |              |\n+/// early-bound and  |              |\n+/// free regions     |              |\n+/// |                |              |\n+/// |                |              |\n+/// empty(root)   placeholder(U1)   |\n+/// |            /                  |\n+/// |           /         placeholder(Un)\n+/// empty(U1) --         /\n+/// |                   /\n+/// ...                /\n+/// |                 /\n+/// empty(Un) --------                      (smallest)\n+/// ```\n+///\n+/// Early-bound/free regions are the named lifetimes in scope from the\n+/// function declaration. They have relationships to one another\n+/// determined based on the declared relationships from the\n+/// function.\n+///\n+/// Note that inference variables and bound regions are not included\n+/// in this diagram. In the case of inference variables, they should\n+/// be inferred to some other region from the diagram.  In the case of\n+/// bound regions, they are excluded because they don't make sense to\n+/// include -- the diagram indicates the relationship between free\n+/// regions.\n+///\n+/// ## Inference variables\n+///\n+/// During region inference, we sometimes create inference variables,\n+/// represented as `ReVar`. These will be inferred by the code in\n+/// `infer::lexical_region_resolve` to some free region from the\n+/// lattice above (the minimal region that meets the\n+/// constraints).\n+///\n+/// During NLL checking, where regions are defined differently, we\n+/// also use `ReVar` -- in that case, the index is used to index into\n+/// the NLL region checker's data structures. The variable may in fact\n+/// represent either a free region or an inference variable, in that\n+/// case.\n+///\n+/// ## Bound Regions\n+///\n+/// These are regions that are stored behind a binder and must be substituted\n+/// with some concrete region before being used. There are two kind of\n+/// bound regions: early-bound, which are bound in an item's `Generics`,\n+/// and are substituted by an `InternalSubsts`, and late-bound, which are part of\n+/// higher-ranked types (e.g., `for<'a> fn(&'a ())`), and are substituted by\n+/// the likes of `liberate_late_bound_regions`. The distinction exists\n+/// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n+///\n+/// Unlike `Param`s, bound regions are not supposed to exist \"in the wild\"\n+/// outside their binder, e.g., in types passed to type inference, and\n+/// should first be substituted (by placeholder regions, free regions,\n+/// or region variables).\n+///\n+/// ## Placeholder and Free Regions\n+///\n+/// One often wants to work with bound regions without knowing their precise\n+/// identity. For example, when checking a function, the lifetime of a borrow\n+/// can end up being assigned to some region parameter. In these cases,\n+/// it must be ensured that bounds on the region can't be accidentally\n+/// assumed without being checked.\n+///\n+/// To do this, we replace the bound regions with placeholder markers,\n+/// which don't satisfy any relation not explicitly provided.\n+///\n+/// There are two kinds of placeholder regions in rustc: `ReFree` and\n+/// `RePlaceholder`. When checking an item's body, `ReFree` is supposed\n+/// to be used. These also support explicit bounds: both the internally-stored\n+/// *scope*, which the region is assumed to outlive, as well as other\n+/// relations stored in the `FreeRegionMap`. Note that these relations\n+/// aren't checked when you `make_subregion` (or `eq_types`), only by\n+/// `resolve_regions_and_report_errors`.\n+///\n+/// When working with higher-ranked types, some region relations aren't\n+/// yet known, so you can't just call `resolve_regions_and_report_errors`.\n+/// `RePlaceholder` is designed for this purpose. In these contexts,\n+/// there's also the risk that some inference variable laying around will\n+/// get unified with your placeholder region: if you want to check whether\n+/// `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a`\n+/// with a placeholder region `'%a`, the variable `'_` would just be\n+/// instantiated to the placeholder region `'%a`, which is wrong because\n+/// the inference variable is supposed to satisfy the relation\n+/// *for every value of the placeholder region*. To ensure that doesn't\n+/// happen, you can use `leak_check`. This is more clearly explained\n+/// by the [rustc dev guide].\n+///\n+/// [1]: https://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n+/// [2]: https://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n+/// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n+pub enum RegionKind<I: Interner> {\n+    /// Region bound in a type or fn declaration which will be\n+    /// substituted 'early' -- that is, at the same time when type\n+    /// parameters are substituted.\n+    ReEarlyBound(I::EarlyBoundRegion),\n+\n+    /// Region bound in a function scope, which will be substituted when the\n+    /// function is called.\n+    ReLateBound(DebruijnIndex, I::BoundRegion),\n+\n+    /// When checking a function body, the types of all arguments and so forth\n+    /// that refer to bound region parameters are modified to refer to free\n+    /// region parameters.\n+    ReFree(I::FreeRegion),\n+\n+    /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n+    ReStatic,\n+\n+    /// A region variable. Should not exist outside of type inference.\n+    ReVar(I::RegionVid),\n+\n+    /// A placeholder region -- basically, the higher-ranked version of `ReFree`.\n+    /// Should not exist outside of type inference.\n+    RePlaceholder(I::PlaceholderRegion),\n+\n+    /// Empty lifetime is for data that is never accessed.  We tag the\n+    /// empty lifetime with a universe -- the idea is that we don't\n+    /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n+    /// Therefore, the `'empty` in a universe `U` is less than all\n+    /// regions visible from `U`, but not less than regions not visible\n+    /// from `U`.\n+    ReEmpty(UniverseIndex),\n+\n+    /// Erased region, used by trait selection, in MIR and during codegen.\n+    ReErased,\n+}\n+\n+// This is manually implemented for `RegionKind` because `std::mem::discriminant`\n+// returns an opaque value that is `PartialEq` but not `PartialOrd`\n+#[inline]\n+const fn regionkind_discriminant<I: Interner>(value: &RegionKind<I>) -> usize {\n+    match value {\n+        ReEarlyBound(_) => 0,\n+        ReLateBound(_, _) => 1,\n+        ReFree(_) => 2,\n+        ReStatic => 3,\n+        ReVar(_) => 4,\n+        RePlaceholder(_) => 5,\n+        ReEmpty(_) => 6,\n+        ReErased => 7,\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Copy`\n+impl<I: Interner> Copy for RegionKind<I>\n+where\n+    I::EarlyBoundRegion: Copy,\n+    I::BoundRegion: Copy,\n+    I::FreeRegion: Copy,\n+    I::RegionVid: Copy,\n+    I::PlaceholderRegion: Copy,\n+{\n+}\n+\n+// This is manually implemented because a derive would require `I: Clone`\n+impl<I: Interner> Clone for RegionKind<I> {\n+    fn clone(&self) -> Self {\n+        match self {\n+            ReEarlyBound(a) => ReEarlyBound(a.clone()),\n+            ReLateBound(a, b) => ReLateBound(a.clone(), b.clone()),\n+            ReFree(a) => ReFree(a.clone()),\n+            ReStatic => ReStatic,\n+            ReVar(a) => ReVar(a.clone()),\n+            RePlaceholder(a) => RePlaceholder(a.clone()),\n+            ReEmpty(a) => ReEmpty(a.clone()),\n+            ReErased => ReErased,\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: PartialEq`\n+impl<I: Interner> PartialEq for RegionKind<I> {\n+    #[inline]\n+    fn eq(&self, other: &RegionKind<I>) -> bool {\n+        let __self_vi = regionkind_discriminant(self);\n+        let __arg_1_vi = regionkind_discriminant(other);\n+        if __self_vi == __arg_1_vi {\n+            match (&*self, &*other) {\n+                (&ReEarlyBound(ref __self_0), &ReEarlyBound(ref __arg_1_0)) => {\n+                    __self_0 == __arg_1_0\n+                }\n+                (\n+                    &ReLateBound(ref __self_0, ref __self_1),\n+                    &ReLateBound(ref __arg_1_0, ref __arg_1_1),\n+                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1,\n+                (&ReFree(ref __self_0), &ReFree(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&ReStatic, &ReStatic) => true,\n+                (&ReVar(ref __self_0), &ReVar(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n+                    __self_0 == __arg_1_0\n+                }\n+                (&ReEmpty(ref __self_0), &ReEmpty(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&ReErased, &ReErased) => true,\n+                _ => true,\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Eq`\n+impl<I: Interner> Eq for RegionKind<I> {}\n+\n+// This is manually implemented because a derive would require `I: PartialOrd`\n+impl<I: Interner> PartialOrd for RegionKind<I> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &RegionKind<I>) -> Option<Ordering> {\n+        Some(Ord::cmp(self, other))\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Ord`\n+impl<I: Interner> Ord for RegionKind<I> {\n+    #[inline]\n+    fn cmp(&self, other: &RegionKind<I>) -> Ordering {\n+        let __self_vi = regionkind_discriminant(self);\n+        let __arg_1_vi = regionkind_discriminant(other);\n+        if __self_vi == __arg_1_vi {\n+            match (&*self, &*other) {\n+                (&ReEarlyBound(ref __self_0), &ReEarlyBound(ref __arg_1_0)) => {\n+                    Ord::cmp(__self_0, __arg_1_0)\n+                }\n+                (\n+                    &ReLateBound(ref __self_0, ref __self_1),\n+                    &ReLateBound(ref __arg_1_0, ref __arg_1_1),\n+                ) => match Ord::cmp(__self_0, __arg_1_0) {\n+                    Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                    cmp => cmp,\n+                },\n+                (&ReFree(ref __self_0), &ReFree(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&ReStatic, &ReStatic) => Ordering::Equal,\n+                (&ReVar(ref __self_0), &ReVar(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n+                    Ord::cmp(__self_0, __arg_1_0)\n+                }\n+                (&ReEmpty(ref __self_0), &ReEmpty(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&ReErased, &ReErased) => Ordering::Equal,\n+                _ => Ordering::Equal,\n+            }\n+        } else {\n+            Ord::cmp(&__self_vi, &__arg_1_vi)\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Hash`\n+impl<I: Interner> hash::Hash for RegionKind<I> {\n+    fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n+        match (&*self,) {\n+            (&ReEarlyBound(ref __self_0),) => {\n+                hash::Hash::hash(&regionkind_discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&ReLateBound(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&regionkind_discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&ReFree(ref __self_0),) => {\n+                hash::Hash::hash(&regionkind_discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&ReStatic,) => {\n+                hash::Hash::hash(&regionkind_discriminant(self), state);\n+            }\n+            (&ReVar(ref __self_0),) => {\n+                hash::Hash::hash(&regionkind_discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&RePlaceholder(ref __self_0),) => {\n+                hash::Hash::hash(&regionkind_discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&ReEmpty(ref __self_0),) => {\n+                hash::Hash::hash(&regionkind_discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&ReErased,) => {\n+                hash::Hash::hash(&regionkind_discriminant(self), state);\n+            }\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Debug`\n+impl<I: Interner> fmt::Debug for RegionKind<I> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ReEarlyBound(ref data) => write!(f, \"ReEarlyBound({:?})\", data),\n+\n+            ReLateBound(binder_id, ref bound_region) => {\n+                write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n+            }\n+\n+            ReFree(ref fr) => fr.fmt(f),\n+\n+            ReStatic => write!(f, \"ReStatic\"),\n+\n+            ReVar(ref vid) => vid.fmt(f),\n+\n+            RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n+\n+            ReEmpty(ui) => write!(f, \"ReEmpty({:?})\", ui),\n+\n+            ReErased => write!(f, \"ReErased\"),\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Encodable`\n+impl<I: Interner, E: TyEncoder> Encodable<E> for RegionKind<I>\n+where\n+    I::EarlyBoundRegion: Encodable<E>,\n+    I::BoundRegion: Encodable<E>,\n+    I::FreeRegion: Encodable<E>,\n+    I::RegionVid: Encodable<E>,\n+    I::PlaceholderRegion: Encodable<E>,\n+{\n+    fn encode(&self, e: &mut E) {\n+        let disc = regionkind_discriminant(self);\n+        match self {\n+            ReEarlyBound(a) => e.emit_enum_variant(disc, |e| {\n+                a.encode(e);\n+            }),\n+            ReLateBound(a, b) => e.emit_enum_variant(disc, |e| {\n+                a.encode(e);\n+                b.encode(e);\n+            }),\n+            ReFree(a) => e.emit_enum_variant(disc, |e| {\n+                a.encode(e);\n+            }),\n+            ReStatic => e.emit_enum_variant(disc, |_| {}),\n+            ReVar(a) => e.emit_enum_variant(disc, |e| {\n+                a.encode(e);\n+            }),\n+            RePlaceholder(a) => e.emit_enum_variant(disc, |e| {\n+                a.encode(e);\n+            }),\n+            ReEmpty(a) => e.emit_enum_variant(disc, |e| {\n+                a.encode(e);\n+            }),\n+            ReErased => e.emit_enum_variant(disc, |_| {}),\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Decodable`\n+impl<I: Interner, D: TyDecoder<I = I>> Decodable<D> for RegionKind<I>\n+where\n+    I::EarlyBoundRegion: Decodable<D>,\n+    I::BoundRegion: Decodable<D>,\n+    I::FreeRegion: Decodable<D>,\n+    I::RegionVid: Decodable<D>,\n+    I::PlaceholderRegion: Decodable<D>,\n+{\n+    fn decode(d: &mut D) -> Self {\n+        match Decoder::read_usize(d) {\n+            0 => ReEarlyBound(Decodable::decode(d)),\n+            1 => ReLateBound(Decodable::decode(d), Decodable::decode(d)),\n+            2 => ReFree(Decodable::decode(d)),\n+            3 => ReStatic,\n+            4 => ReVar(Decodable::decode(d)),\n+            5 => RePlaceholder(Decodable::decode(d)),\n+            6 => ReEmpty(Decodable::decode(d)),\n+            7 => ReErased,\n+            _ => panic!(\n+                \"{}\",\n+                format!(\n+                    \"invalid enum variant tag while decoding `{}`, expected 0..{}\",\n+                    \"RegionKind\", 8,\n+                )\n+            ),\n+        }\n+    }\n+}\n+\n+// This is not a derived impl because a derive would require `I: HashStable`\n+impl<CTX, I: Interner> HashStable<CTX> for RegionKind<I>\n+where\n+    I::EarlyBoundRegion: HashStable<CTX>,\n+    I::BoundRegion: HashStable<CTX>,\n+    I::FreeRegion: HashStable<CTX>,\n+    I::RegionVid: HashStable<CTX>,\n+    I::PlaceholderRegion: HashStable<CTX>,\n+{\n+    #[inline]\n+    fn hash_stable(\n+        &self,\n+        hcx: &mut CTX,\n+        hasher: &mut rustc_data_structures::stable_hasher::StableHasher,\n+    ) {\n+        std::mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            ReErased | ReStatic => {\n+                // No variant fields to hash for these ...\n+            }\n+            ReEmpty(universe) => {\n+                universe.hash_stable(hcx, hasher);\n+            }\n+            ReLateBound(db, br) => {\n+                db.hash_stable(hcx, hasher);\n+                br.hash_stable(hcx, hasher);\n+            }\n+            ReEarlyBound(eb) => {\n+                eb.hash_stable(hcx, hasher);\n+            }\n+            ReFree(ref free_region) => {\n+                free_region.hash_stable(hcx, hasher);\n+            }\n+            RePlaceholder(p) => {\n+                p.hash_stable(hcx, hasher);\n+            }\n+            ReVar(reg) => {\n+                reg.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}"}]}