{"sha": "777baeb2986aebf32866358c31e4321b594b0742", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3N2JhZWIyOTg2YWViZjMyODY2MzU4YzMxZTQzMjFiNTk0YjA3NDI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-03T21:35:14Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-04T23:48:56Z"}, "message": "Remove code that was waiting for a snapshot\n\nextfmt is now demoded", "tree": {"sha": "714a650050550f484efddd06f91d0c4c25a4148d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/714a650050550f484efddd06f91d0c4c25a4148d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/777baeb2986aebf32866358c31e4321b594b0742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/777baeb2986aebf32866358c31e4321b594b0742", "html_url": "https://github.com/rust-lang/rust/commit/777baeb2986aebf32866358c31e4321b594b0742", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/777baeb2986aebf32866358c31e4321b594b0742/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c37c243e95df30d22f0dc495312771557e9b2bcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c37c243e95df30d22f0dc495312771557e9b2bcc", "html_url": "https://github.com/rust-lang/rust/commit/c37c243e95df30d22f0dc495312771557e9b2bcc"}], "stats": {"total": 199, "additions": 3, "deletions": 196}, "files": [{"sha": "de2e91b2e3268fefdd74bc1c5c58d35c14c2687f", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 3, "deletions": 196, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/777baeb2986aebf32866358c31e4321b594b0742/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777baeb2986aebf32866358c31e4321b594b0742/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=777baeb2986aebf32866358c31e4321b594b0742", "patch": "@@ -1,4 +1,7 @@\n #[doc(hidden)];\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n /*\n Syntax Extension: fmt\n@@ -463,202 +466,6 @@ pub mod rt {\n     }\n }\n \n-// Remove after snapshot\n-\n-// Functions used by the fmt extension at runtime. For now there are a lot of\n-// decisions made a runtime. If it proves worthwhile then some of these\n-// conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it 0this way, I think.\n-pub mod rt2 {\n-\n-    pub const flag_none : u32 = 0u32;\n-    pub const flag_left_justify   : u32 = 0b00000000000001u32;\n-    pub const flag_left_zero_pad  : u32 = 0b00000000000010u32;\n-    pub const flag_space_for_sign : u32 = 0b00000000000100u32;\n-    pub const flag_sign_always    : u32 = 0b00000000001000u32;\n-    pub const flag_alternate      : u32 = 0b00000000010000u32;\n-\n-    pub enum Count { CountIs(int), CountImplied, }\n-    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n-\n-    pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n-\n-    pub pure fn conv_int(cv: Conv, i: int) -> ~str {\n-        let radix = 10;\n-        let prec = get_int_precision(cv);\n-        let mut s : ~str = int_to_str_prec(i, radix, prec);\n-        if 0 <= i {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                unsafe { str::unshift_char(&mut s, '+') };\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                unsafe { str::unshift_char(&mut s, ' ') };\n-            }\n-        }\n-        return unsafe { pad(cv, s, PadSigned) };\n-    }\n-    pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n-        let prec = get_int_precision(cv);\n-        let mut rs =\n-            match cv.ty {\n-              TyDefault => uint_to_str_prec(u, 10u, prec),\n-              TyHexLower => uint_to_str_prec(u, 16u, prec),\n-              TyHexUpper => str::to_upper(uint_to_str_prec(u, 16u, prec)),\n-              TyBits => uint_to_str_prec(u, 2u, prec),\n-              TyOctal => uint_to_str_prec(u, 8u, prec)\n-            };\n-        return unsafe { pad(cv, rs, PadUnsigned) };\n-    }\n-    pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n-        let s = if b { ~\"true\" } else { ~\"false\" };\n-        // run the boolean conversion through the string conversion logic,\n-        // giving it the same rules for precision, etc.\n-        return conv_str(cv, s);\n-    }\n-    pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n-        let mut s = str::from_char(c);\n-        return unsafe { pad(cv, s, PadNozero) };\n-    }\n-    pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n-        // For strings, precision is the maximum characters\n-        // displayed\n-        let mut unpadded = match cv.precision {\n-          CountImplied => s.to_unique(),\n-          CountIs(max) => if max as uint < str::char_len(s) {\n-            str::substr(s, 0u, max as uint)\n-          } else {\n-            s.to_unique()\n-          }\n-        };\n-        return unsafe { pad(cv, unpadded, PadNozero) };\n-    }\n-    pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n-        let (to_str, digits) = match cv.precision {\n-              CountIs(c) => (float::to_str_exact, c as uint),\n-              CountImplied => (float::to_str, 6u)\n-        };\n-        let mut s = unsafe { to_str(f, digits) };\n-        if 0.0 <= f {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                s = ~\"+\" + s;\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = ~\" \" + s;\n-            }\n-        }\n-        return unsafe { pad(cv, s, PadFloat) };\n-    }\n-    pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n-        let s = sys::log_str(v);\n-        return conv_str(cv, s);\n-    }\n-\n-    // Convert an int to string with minimum number of digits. If precision is\n-    // 0 and num is 0 then the result is the empty string.\n-    pub pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n-        return if num < 0 {\n-                ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n-            } else { uint_to_str_prec(num as uint, radix, prec) };\n-    }\n-\n-    // Convert a uint to string with a minimum number of digits.  If precision\n-    // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to uint: but it doesn't seem all that useful.\n-    pub pure fn uint_to_str_prec(num: uint, radix: uint,\n-                                 prec: uint) -> ~str {\n-        return if prec == 0u && num == 0u {\n-                ~\"\"\n-            } else {\n-                let s = uint::to_str(num, radix);\n-                let len = str::char_len(s);\n-                if len < prec {\n-                    let diff = prec - len;\n-                    let pad = str::from_chars(vec::from_elem(diff, '0'));\n-                    pad + s\n-                } else { move s }\n-            };\n-    }\n-    pub pure fn get_int_precision(cv: Conv) -> uint {\n-        return match cv.precision {\n-              CountIs(c) => c as uint,\n-              CountImplied => 1u\n-            };\n-    }\n-\n-    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n-\n-    pub impl PadMode : Eq {\n-        pure fn eq(other: &PadMode) -> bool {\n-            match (self, (*other)) {\n-                (PadSigned, PadSigned) => true,\n-                (PadUnsigned, PadUnsigned) => true,\n-                (PadNozero, PadNozero) => true,\n-                (PadFloat, PadFloat) => true,\n-                (PadSigned, _) => false,\n-                (PadUnsigned, _) => false,\n-                (PadNozero, _) => false,\n-                (PadFloat, _) => false\n-            }\n-        }\n-        pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n-    }\n-\n-    pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n-        let mut s = move s; // sadtimes\n-        let uwidth : uint = match cv.width {\n-          CountImplied => return s,\n-          CountIs(width) => {\n-              // FIXME: width should probably be uint (see Issue #1996)\n-              width as uint\n-          }\n-        };\n-        let strlen = str::char_len(s);\n-        if uwidth <= strlen { return s; }\n-        let mut padchar = ' ';\n-        let diff = uwidth - strlen;\n-        if have_flag(cv.flags, flag_left_justify) {\n-            let padstr = str::from_chars(vec::from_elem(diff, padchar));\n-            return s + padstr;\n-        }\n-        let {might_zero_pad, signed} = match mode {\n-          PadNozero => {might_zero_pad:false, signed:false},\n-          PadSigned => {might_zero_pad:true,  signed:true },\n-          PadFloat => {might_zero_pad:true,  signed:true},\n-          PadUnsigned => {might_zero_pad:true,  signed:false}\n-        };\n-        pure fn have_precision(cv: Conv) -> bool {\n-            return match cv.precision { CountImplied => false, _ => true };\n-        }\n-        let zero_padding = {\n-            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-                (!have_precision(cv) || mode == PadFloat) {\n-                padchar = '0';\n-                true\n-            } else {\n-                false\n-            }\n-        };\n-        let padstr = str::from_chars(vec::from_elem(diff, padchar));\n-        // This is completely heinous. If we have a signed value then\n-        // potentially rip apart the intermediate result and insert some\n-        // zeros. It may make sense to convert zero padding to a precision\n-        // instead.\n-\n-        if signed && zero_padding && s.len() > 0 {\n-            let head = str::shift_char(&mut s);\n-            if head == '+' || head == '-' || head == ' ' {\n-                let headstr = str::from_chars(vec::from_elem(1u, head));\n-                return headstr + padstr + s;\n-            }\n-            else {\n-                str::unshift_char(&mut s, head);\n-            }\n-        }\n-        return padstr + s;\n-    }\n-    pub pure fn have_flag(flags: u32, f: u32) -> bool {\n-        flags & f != 0\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     #[test]"}]}