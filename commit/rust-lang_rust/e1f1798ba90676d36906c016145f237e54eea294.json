{"sha": "e1f1798ba90676d36906c016145f237e54eea294", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZjE3OThiYTkwNjc2ZDM2OTA2YzAxNjE0NWYyMzdlNTRlZWEyOTQ=", "commit": {"author": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2017-08-08T15:13:12Z"}, "committer": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2017-08-14T13:07:21Z"}, "message": "Handle unwinding, use a loop for arrays", "tree": {"sha": "ebfdb622c1815c321cc022dcdea9303303fc0777", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebfdb622c1815c321cc022dcdea9303303fc0777"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1f1798ba90676d36906c016145f237e54eea294", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1f1798ba90676d36906c016145f237e54eea294", "html_url": "https://github.com/rust-lang/rust/commit/e1f1798ba90676d36906c016145f237e54eea294", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1f1798ba90676d36906c016145f237e54eea294/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df7be435d3a1ad05ba8b71b2966b4ec9b2a1229e", "url": "https://api.github.com/repos/rust-lang/rust/commits/df7be435d3a1ad05ba8b71b2966b4ec9b2a1229e", "html_url": "https://github.com/rust-lang/rust/commit/df7be435d3a1ad05ba8b71b2966b4ec9b2a1229e"}], "stats": {"total": 364, "additions": 308, "deletions": 56}, "files": [{"sha": "d2a42650e3df97f69cbb09c526945195c9d239bc", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 242, "deletions": 55, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/e1f1798ba90676d36906c016145f237e54eea294/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f1798ba90676d36906c016145f237e54eea294/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=e1f1798ba90676d36906c016145f237e54eea294", "patch": "@@ -286,18 +286,26 @@ fn build_clone_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     let mut local_decls = local_decls_for_sig(&sig, span);\n     let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n \n+    let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+\n     let mut blocks = IndexVec::new();\n-    let block = |blocks: &mut IndexVec<_, _>, statement, kind| {\n+    let block = |blocks: &mut IndexVec<_, _>, statements, kind, is_cleanup| {\n         blocks.push(BasicBlockData {\n-            statements: vec![statement],\n+            statements,\n             terminator: Some(Terminator { source_info, kind }),\n-            is_cleanup: false\n+            is_cleanup,\n         })\n     };\n \n-    let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+    let make_lvalue = |mutability, ty, local_decls: &mut IndexVec<_, _>| {\n+        Lvalue::Local(\n+            local_decls.push(temp_decl(mutability, ty, span))\n+        )\n+    };\n \n-    let call_clone = |i, ty, rcvr_field, blocks: &mut _, local_decls: &mut IndexVec<_, _>| {\n+    let call_clone = |ty, rcvr_field, next, cleanup,\n+                      blocks: &mut _, local_decls: &mut IndexVec<_, _>|\n+    {\n         // `func == Clone::clone(&ty) -> ty`\n         let substs = Substs::for_item(tcx, def_id, |_, _| tcx.types.re_erased, |_, _| ty);\n         let func = Operand::Constant(box Constant {\n@@ -308,102 +316,281 @@ fn build_clone_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             },\n         });\n \n-        let ref_loc = Lvalue::Local(\n-            local_decls.push(temp_decl(\n-                Mutability::Not,\n-                tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n-                    ty,\n-                    mutbl: hir::Mutability::MutImmutable,\n-                }),\n-                span\n-            ))\n-        );\n-\n-        let loc = Lvalue::Local(\n-            local_decls.push(temp_decl(\n-                Mutability::Not,\n+        let ref_loc = make_lvalue(\n+            Mutability::Not,\n+            tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n                 ty,\n-                span\n-            ))\n+                mutbl: hir::Mutability::MutImmutable,\n+            }),\n+            local_decls\n         );\n \n+        let loc = make_lvalue(Mutability::Not, ty, local_decls);\n+\n         // `let ref_loc: &ty = &rcvr_field;`\n         let statement = Statement {\n-            source_info: source_info,\n+            source_info,\n             kind: StatementKind::Assign(\n                 ref_loc.clone(),\n                 Rvalue::Ref(tcx.types.re_erased, BorrowKind::Shared, rcvr_field)\n             )\n         };\n \n         // `let loc = Clone::clone(ref_loc);`\n-        block(blocks, statement, TerminatorKind::Call {\n+        block(blocks, vec![statement], TerminatorKind::Call {\n             func,\n             args: vec![Operand::Consume(ref_loc)],\n-            destination: Some((loc.clone(), BasicBlock::new(i + 1))),\n-            cleanup: None,\n-        });\n+            destination: Some((loc.clone(), next)),\n+            cleanup: Some(cleanup),\n+        }, false);\n \n         loc\n     };\n \n     let is_copy = !self_ty.moves_by_default(tcx, tcx.param_env(def_id), span);\n-\n     match self_ty.sty {\n         _ if is_copy => {\n             // `return *self;`\n-            let statement = Statement {\n-                source_info: source_info,\n+            let ret_statement = Statement {\n+                source_info,\n                 kind: StatementKind::Assign(\n                     Lvalue::Local(RETURN_POINTER),\n                     Rvalue::Use(Operand::Consume(rcvr))\n                 )\n             };\n-            block(&mut blocks, statement, TerminatorKind::Return);\n+            block(&mut blocks, vec![ret_statement], TerminatorKind::Return, false);\n         }\n         ty::TyArray(ty, len) => {\n-            let mut returns = Vec::new();\n-            for i in 0..len {\n-                let index = ConstUsize::new(i as u64, tcx.sess.target.uint_type).unwrap();\n-                let rcvr_field = rcvr.clone().index(\n-                    Operand::Constant(box Constant {\n-                        span,\n-                        ty: tcx.types.usize,\n-                        literal: Literal::Value {\n-                            value: ConstVal::Integral(ConstInt::Usize(index))\n-                        }\n-                    })\n+            let make_loop = |beg, end, loop_body, loop_end,\n+                             blocks: &mut _, local_decls: &mut _, is_cleanup|\n+            {\n+                let cond = make_lvalue(Mutability::Mut, tcx.types.bool, local_decls);\n+                let compute_cond = Statement {\n+                    source_info,\n+                    kind: StatementKind::Assign(\n+                        cond.clone(),\n+                        Rvalue::BinaryOp(BinOp::Ne, Operand::Consume(end), Operand::Consume(beg))\n+                    )\n+                };\n+\n+                // `if end != beg { goto loop_body; } else { goto loop_end; }`\n+                block(\n+                    blocks,\n+                    vec![compute_cond],\n+                    TerminatorKind::if_(tcx, Operand::Consume(cond), loop_body, loop_end),\n+                    is_cleanup\n                 );\n+            };\n \n-                // `returns[i] = Clone::clone(&rcvr[i]);`\n-                returns.push(call_clone(i, ty, rcvr_field, &mut blocks, &mut local_decls));\n-            }\n+            let make_usize = |value| {\n+                let value = ConstUsize::new(value as u64, tcx.sess.target.uint_type).unwrap();\n+                box Constant {\n+                    span,\n+                    ty: tcx.types.usize,\n+                    literal: Literal::Value {\n+                        value: ConstVal::Integral(ConstInt::Usize(value))\n+                    }\n+                }\n+            };\n \n-            // `return [returns[0], returns[1], ..., returns[len - 1]];`\n-            let statement = Statement {\n+            let beg = make_lvalue(Mutability::Mut, tcx.types.usize, &mut local_decls);\n+            let end = make_lvalue(Mutability::Not, tcx.types.usize, &mut local_decls);\n+            let ret = make_lvalue(Mutability::Mut, tcx.mk_array(ty, len), &mut local_decls);\n+\n+            // BB #0\n+            // `let mut beg = 0;`\n+            // `let end = len;`\n+            // `goto #1;`\n+            let inits = vec![\n+                Statement {\n+                    source_info,\n+                    kind: StatementKind::Assign(\n+                        beg.clone(),\n+                        Rvalue::Use(Operand::Constant(make_usize(0)))\n+                    )\n+                },\n+                Statement {\n+                    source_info,\n+                    kind: StatementKind::Assign(\n+                        end.clone(),\n+                        Rvalue::Use(Operand::Constant(make_usize(len)))\n+                    )\n+                }\n+            ];\n+            block(&mut blocks, inits, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);\n+\n+            // BB #1: loop {\n+            //     BB #2;\n+            //     BB #3;\n+            // }\n+            // BB #4;\n+            make_loop(\n+                beg.clone(),\n+                end,\n+                BasicBlock::new(2),\n+                BasicBlock::new(4),\n+                &mut blocks,\n+                &mut local_decls,\n+                false\n+            );\n+\n+            // BB #2\n+            // `let cloned = Clone::clone(rcvr[beg])`;\n+            // Goto #3 if ok, #5 if unwinding happens.\n+            let rcvr_field = rcvr.clone().index(Operand::Consume(beg.clone()));\n+            let cloned = call_clone(\n+                ty,\n+                rcvr_field,\n+                BasicBlock::new(3),\n+                BasicBlock::new(5),\n+                &mut blocks,\n+                &mut local_decls\n+            );\n+\n+            // BB #3\n+            // `ret[beg] = cloned;`\n+            // `beg = beg + 1;`\n+            // `goto #1`;\n+            let ret_field = ret.clone().index(Operand::Consume(beg.clone()));\n+            let statements = vec![\n+                Statement {\n+                    source_info,\n+                    kind: StatementKind::Assign(\n+                        ret_field,\n+                        Rvalue::Use(Operand::Consume(cloned))\n+                    )\n+                },\n+                Statement {\n+                    source_info,\n+                    kind: StatementKind::Assign(\n+                        beg.clone(),\n+                        Rvalue::BinaryOp(\n+                            BinOp::Add,\n+                            Operand::Consume(beg.clone()),\n+                            Operand::Constant(make_usize(1))\n+                        )\n+                    )\n+                }\n+            ];\n+            block(\n+                &mut blocks,\n+                statements,\n+                TerminatorKind::Goto { target: BasicBlock::new(1) },\n+                false\n+            );\n+\n+            // BB #4\n+            // `return ret;`\n+            let ret_statement = Statement {\n                 source_info: source_info,\n                 kind: StatementKind::Assign(\n                     Lvalue::Local(RETURN_POINTER),\n-                    Rvalue::Aggregate(\n-                        box AggregateKind::Array(ty),\n-                        returns.into_iter().map(Operand::Consume).collect()\n+                    Rvalue::Use(Operand::Consume(ret.clone())),\n+                )\n+            };\n+            block(&mut blocks, vec![ret_statement], TerminatorKind::Return, false);\n+\n+            // BB #5 (cleanup)\n+            // `let end = beg;`\n+            // `let mut beg = 0;`\n+            // goto #6;\n+            let end = beg;\n+            let beg = make_lvalue(Mutability::Mut, tcx.types.usize, &mut local_decls);\n+            let init = Statement {\n+                source_info,\n+                kind: StatementKind::Assign(\n+                    beg.clone(),\n+                    Rvalue::Use(Operand::Constant(make_usize(0)))\n+                )\n+            };\n+            block(\n+                &mut blocks,\n+                vec![init],\n+                TerminatorKind::Goto { target: BasicBlock::new(6) },\n+                true\n+            );\n+\n+            // BB #6 (cleanup): loop {\n+            //     BB #7;\n+            //     BB #8;\n+            // }\n+            // BB #9;\n+            make_loop(\n+                beg.clone(),\n+                end,\n+                BasicBlock::new(7),\n+                BasicBlock::new(9),\n+                &mut blocks,\n+                &mut local_decls,\n+                true\n+            );\n+\n+            // BB #7 (cleanup)\n+            // `drop(ret[beg])`;\n+            block(&mut blocks, vec![], TerminatorKind::Drop {\n+                location: ret.index(Operand::Consume(beg.clone())),\n+                target: BasicBlock::new(8),\n+                unwind: None,\n+            }, true);\n+\n+            // BB #8 (cleanup)\n+            // `beg = beg + 1;`\n+            // `goto #6;`\n+            let statement = Statement {\n+                source_info,\n+                kind: StatementKind::Assign(\n+                    beg.clone(),\n+                    Rvalue::BinaryOp(\n+                        BinOp::Add,\n+                        Operand::Consume(beg.clone()),\n+                        Operand::Constant(make_usize(1))\n                     )\n                 )\n             };\n-            block(&mut blocks, statement, TerminatorKind::Return);\n+            block(\n+                &mut blocks,\n+                vec![statement],\n+                TerminatorKind::Goto { target: BasicBlock::new(6) },\n+                true\n+            );\n+\n+            // BB #9 (resume)\n+            block(&mut blocks, vec![], TerminatorKind::Resume, true);\n         }\n         ty::TyTuple(tys, _) => {\n             let mut returns = Vec::new();\n             for (i, ity) in tys.iter().enumerate() {\n                 let rcvr_field = rcvr.clone().field(Field::new(i), *ity);\n \n+                // BB #(2i)\n                 // `returns[i] = Clone::clone(&rcvr.i);`\n-                returns.push(call_clone(i, *ity, rcvr_field, &mut blocks, &mut local_decls));\n+                // Goto #(2i + 2) if ok, #(2i + 1) if unwinding happens.\n+                returns.push(call_clone(\n+                    *ity,\n+                    rcvr_field,\n+                    BasicBlock::new(2 * i + 2),\n+                    BasicBlock::new(2 * i + 1),\n+                    &mut blocks,\n+                    &mut local_decls\n+                ));\n+\n+                // BB #(2i + 1) (cleanup)\n+                if i == 0 {\n+                    // Nothing to drop, just resume.\n+                    block(&mut blocks, vec![], TerminatorKind::Resume, true);\n+                } else {\n+                    // Drop previous field and goto previous cleanup block.\n+                    block(&mut blocks, vec![], TerminatorKind::Drop {\n+                        location: returns[i - 1].clone(),\n+                        target: BasicBlock::new(2 * i - 1),\n+                        unwind: None,\n+                    }, true);\n+                }\n             }\n \n             // `return (returns[0], returns[1], ..., returns[tys.len() - 1]);`\n-            let statement = Statement {\n-                source_info: source_info,\n+            let ret_statement = Statement {\n+                source_info,\n                 kind: StatementKind::Assign(\n                     Lvalue::Local(RETURN_POINTER),\n                     Rvalue::Aggregate(\n@@ -412,10 +599,10 @@ fn build_clone_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                     )\n                 )\n             };\n-            block(&mut blocks, statement, TerminatorKind::Return);\n+            block(&mut blocks, vec![ret_statement], TerminatorKind::Return, false);\n         }\n         _ => {\n-            bug!(\"builtin shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty);\n+            bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty);\n         }\n     };\n "}, {"sha": "2829f79812c59dfaa9c7a48ef229d01eeb247a21", "filename": "src/test/run-pass/builtin-clone-unwind.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e1f1798ba90676d36906c016145f237e54eea294/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f1798ba90676d36906c016145f237e54eea294/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs?ref=e1f1798ba90676d36906c016145f237e54eea294", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that builtin implementations of `Clone` cleanup everything\n+// in case of unwinding.\n+\n+use std::thread;\n+use std::sync::Arc;\n+\n+struct S(Arc<()>);\n+\n+impl Clone for S {\n+    fn clone(&self) -> Self {\n+        if Arc::strong_count(&self.0) == 7 {\n+            panic!(\"oops\");\n+        }\n+\n+        S(self.0.clone())\n+    }\n+}\n+\n+fn main() {\n+    let counter = Arc::new(());\n+\n+    // Unwinding with tuples...\n+    let ccounter = counter.clone();\n+    let child = thread::spawn(move || {\n+        let _ = (\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter)\n+        ).clone();\n+    });\n+\n+    assert!(child.join().is_err());\n+    assert_eq!(\n+        1,\n+        Arc::strong_count(&counter)\n+    );\n+\n+    // ... and with arrays.\n+    let ccounter = counter.clone();\n+    let child = thread::spawn(move || {\n+        let _ = [\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter)\n+        ].clone();\n+    });\n+\n+    assert!(child.join().is_err());\n+    assert_eq!(\n+        1,\n+        Arc::strong_count(&counter)\n+    );\n+}"}, {"sha": "95903610931b2e9f7ec6d2a1482afc342038047a", "filename": "src/test/run-pass/builtin-clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1f1798ba90676d36906c016145f237e54eea294/src%2Ftest%2Frun-pass%2Fbuiltin-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f1798ba90676d36906c016145f237e54eea294/src%2Ftest%2Frun-pass%2Fbuiltin-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-clone.rs?ref=e1f1798ba90676d36906c016145f237e54eea294", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //"}]}