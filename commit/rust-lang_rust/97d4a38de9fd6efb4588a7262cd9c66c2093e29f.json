{"sha": "97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "node_id": "C_kwDOAAsO6NoAKDk3ZDRhMzhkZTlmZDZlZmI0NTg4YTcyNjJjZDljNjZjMjA5M2UyOWY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-28T23:56:37Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-30T07:48:49Z"}, "message": "Remove `-Zcgu-partitioning-strategy`.\n\nThis option was introduced three years ago, but it's never been\nmeaningfully used, and `default` is the only acceptable value.\n\nAlso, I think the `Partition` trait presents an interface that is too\nclosely tied to the existing strategy and would probably be wrong for\nother strategies. (My rule of thumb is to not make something generic\nuntil there are at least two instances of it, to avoid this kind of\nproblem.)\n\nAlso, I don't think providing multiple partitioning strategies to the\nuser is a good idea, because the compiler already has enough obscure\nknobs.\n\nThis commit removes the option, along with the `Partition` trait, and\nthe `Partitioner` and `DefaultPartitioning` types. I left the existing\ncode in `compiler/rustc_monomorphize/src/partitioning/default.rs`,\nthough I could be persuaded that moving it into\n`compiler/rustc_monomorphize/src/partitioning/mod.rs` is better.", "tree": {"sha": "8abd4ad711d5041c1bc85d77629e2f48514ebdac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8abd4ad711d5041c1bc85d77629e2f48514ebdac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "html_url": "https://github.com/rust-lang/rust/commit/97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97d4a38de9fd6efb4588a7262cd9c66c2093e29f/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c53407e8c7cc922d718bde61ca34f47b6d2120f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c53407e8c7cc922d718bde61ca34f47b6d2120f", "html_url": "https://github.com/rust-lang/rust/commit/1c53407e8c7cc922d718bde61ca34f47b6d2120f"}], "stats": {"total": 672, "additions": 276, "deletions": 396}, "files": [{"sha": "71cbee3b166953a4385b96cb48c144d344404fe3", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 271, "deletions": 278, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/97d4a38de9fd6efb4588a7262cd9c66c2093e29f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d4a38de9fd6efb4588a7262cd9c66c2093e29f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "patch": "@@ -15,326 +15,319 @@ use rustc_span::symbol::Symbol;\n \n use super::PartitioningCx;\n use crate::collector::InliningMap;\n-use crate::partitioning::{MonoItemPlacement, Partition, PlacedRootMonoItems};\n-\n-pub struct DefaultPartitioning;\n-\n-impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>,\n-    {\n-        let mut roots = FxHashSet::default();\n-        let mut codegen_units = FxHashMap::default();\n-        let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n-        let mut internalization_candidates = FxHashSet::default();\n-\n-        // Determine if monomorphizations instantiated in this crate will be made\n-        // available to downstream crates. This depends on whether we are in\n-        // share-generics mode and whether the current crate can even have\n-        // downstream crates.\n-        let export_generics =\n-            cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n-\n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-        let cgu_name_cache = &mut FxHashMap::default();\n-\n-        for mono_item in mono_items {\n-            match mono_item.instantiation_mode(cx.tcx) {\n-                InstantiationMode::GloballyShared { .. } => {}\n-                InstantiationMode::LocalCopy => continue,\n-            }\n+use crate::partitioning::{MonoItemPlacement, PlacedRootMonoItems};\n+\n+// This modules implements the default (and only) partitioning strategy.\n+\n+pub(super) fn place_root_mono_items<'tcx, I>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    mono_items: &mut I,\n+) -> PlacedRootMonoItems<'tcx>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n+{\n+    let mut roots = FxHashSet::default();\n+    let mut codegen_units = FxHashMap::default();\n+    let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n+    let mut internalization_candidates = FxHashSet::default();\n+\n+    // Determine if monomorphizations instantiated in this crate will be made\n+    // available to downstream crates. This depends on whether we are in\n+    // share-generics mode and whether the current crate can even have\n+    // downstream crates.\n+    let export_generics =\n+        cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n \n-            let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n-            let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n-\n-            let codegen_unit_name = match characteristic_def_id {\n-                Some(def_id) => compute_codegen_unit_name(\n-                    cx.tcx,\n-                    cgu_name_builder,\n-                    def_id,\n-                    is_volatile,\n-                    cgu_name_cache,\n-                ),\n-                None => fallback_cgu_name(cgu_name_builder),\n-            };\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+    let cgu_name_cache = &mut FxHashMap::default();\n+\n+    for mono_item in mono_items {\n+        match mono_item.instantiation_mode(cx.tcx) {\n+            InstantiationMode::GloballyShared { .. } => {}\n+            InstantiationMode::LocalCopy => continue,\n+        }\n \n-            let codegen_unit = codegen_units\n-                .entry(codegen_unit_name)\n-                .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n+        let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n+        let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n \n-            let mut can_be_internalized = true;\n-            let (linkage, visibility) = mono_item_linkage_and_visibility(\n+        let codegen_unit_name = match characteristic_def_id {\n+            Some(def_id) => compute_codegen_unit_name(\n                 cx.tcx,\n-                &mono_item,\n-                &mut can_be_internalized,\n-                export_generics,\n-            );\n-            if visibility == Visibility::Hidden && can_be_internalized {\n-                internalization_candidates.insert(mono_item);\n-            }\n-\n-            codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n-            roots.insert(mono_item);\n-        }\n+                cgu_name_builder,\n+                def_id,\n+                is_volatile,\n+                cgu_name_cache,\n+            ),\n+            None => fallback_cgu_name(cgu_name_builder),\n+        };\n \n-        // Always ensure we have at least one CGU; otherwise, if we have a\n-        // crate with just types (for example), we could wind up with no CGU.\n-        if codegen_units.is_empty() {\n-            let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n-            codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n+        let codegen_unit = codegen_units\n+            .entry(codegen_unit_name)\n+            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n+\n+        let mut can_be_internalized = true;\n+        let (linkage, visibility) = mono_item_linkage_and_visibility(\n+            cx.tcx,\n+            &mono_item,\n+            &mut can_be_internalized,\n+            export_generics,\n+        );\n+        if visibility == Visibility::Hidden && can_be_internalized {\n+            internalization_candidates.insert(mono_item);\n         }\n \n-        let codegen_units = codegen_units.into_values().collect();\n-        PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n+        codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n+        roots.insert(mono_item);\n     }\n \n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    ) {\n-        assert!(cx.target_cgu_count >= 1);\n+    // Always ensure we have at least one CGU; otherwise, if we have a\n+    // crate with just types (for example), we could wind up with no CGU.\n+    if codegen_units.is_empty() {\n+        let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n+        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n+    }\n \n-        // Note that at this point in time the `codegen_units` here may not be\n-        // in a deterministic order (but we know they're deterministically the\n-        // same set). We want this merging to produce a deterministic ordering\n-        // of codegen units from the input.\n-        //\n-        // Due to basically how we've implemented the merging below (merge the\n-        // two smallest into each other) we're sure to start off with a\n-        // deterministic order (sorted by name). This'll mean that if two cgus\n-        // have the same size the stable sort below will keep everything nice\n-        // and deterministic.\n-        codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-        // This map keeps track of what got merged into what.\n-        let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n-            codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n-\n-        // Merge the two smallest codegen units until the target size is\n-        // reached.\n-        while codegen_units.len() > cx.target_cgu_count {\n-            // Sort small cgus to the back\n-            codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-            let mut smallest = codegen_units.pop().unwrap();\n-            let second_smallest = codegen_units.last_mut().unwrap();\n-\n-            // Move the mono-items from `smallest` to `second_smallest`\n-            second_smallest.modify_size_estimate(smallest.size_estimate());\n-            for (k, v) in smallest.items_mut().drain() {\n-                second_smallest.items_mut().insert(k, v);\n-            }\n+    let codegen_units = codegen_units.into_values().collect();\n+    PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n+}\n \n-            // Record that `second_smallest` now contains all the stuff that was\n-            // in `smallest` before.\n-            let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-            cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n+pub(super) fn merge_codegen_units<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n+) {\n+    assert!(cx.target_cgu_count >= 1);\n \n-            debug!(\n-                \"CodegenUnit {} merged into CodegenUnit {}\",\n-                smallest.name(),\n-                second_smallest.name()\n-            );\n+    // Note that at this point in time the `codegen_units` here may not be\n+    // in a deterministic order (but we know they're deterministically the\n+    // same set). We want this merging to produce a deterministic ordering\n+    // of codegen units from the input.\n+    //\n+    // Due to basically how we've implemented the merging below (merge the\n+    // two smallest into each other) we're sure to start off with a\n+    // deterministic order (sorted by name). This'll mean that if two cgus\n+    // have the same size the stable sort below will keep everything nice\n+    // and deterministic.\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+    // This map keeps track of what got merged into what.\n+    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n+        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n+\n+    // Merge the two smallest codegen units until the target size is\n+    // reached.\n+    while codegen_units.len() > cx.target_cgu_count {\n+        // Sort small cgus to the back\n+        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+        let mut smallest = codegen_units.pop().unwrap();\n+        let second_smallest = codegen_units.last_mut().unwrap();\n+\n+        // Move the mono-items from `smallest` to `second_smallest`\n+        second_smallest.modify_size_estimate(smallest.size_estimate());\n+        for (k, v) in smallest.items_mut().drain() {\n+            second_smallest.items_mut().insert(k, v);\n         }\n \n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-\n-        if cx.tcx.sess.opts.incremental.is_some() {\n-            // If we are doing incremental compilation, we want CGU names to\n-            // reflect the path of the source level module they correspond to.\n-            // For CGUs that contain the code of multiple modules because of the\n-            // merging done above, we use a concatenation of the names of all\n-            // contained CGUs.\n-            let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-                .into_iter()\n-                // This `filter` makes sure we only update the name of CGUs that\n-                // were actually modified by merging.\n-                .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-                .map(|(current_cgu_name, cgu_contents)| {\n-                    let mut cgu_contents: Vec<&str> =\n-                        cgu_contents.iter().map(|s| s.as_str()).collect();\n-\n-                    // Sort the names, so things are deterministic and easy to\n-                    // predict. We are sorting primitive `&str`s here so we can\n-                    // use unstable sort.\n-                    cgu_contents.sort_unstable();\n-\n-                    (current_cgu_name, cgu_contents.join(\"--\"))\n-                })\n-                .collect();\n-\n-            for cgu in codegen_units.iter_mut() {\n-                if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                    if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n-                        cgu.set_name(Symbol::intern(&new_cgu_name));\n-                    } else {\n-                        // If we don't require CGU names to be human-readable,\n-                        // we use a fixed length hash of the composite CGU name\n-                        // instead.\n-                        let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                        cgu.set_name(Symbol::intern(&new_cgu_name));\n-                    }\n+        // Record that `second_smallest` now contains all the stuff that was\n+        // in `smallest` before.\n+        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+        cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n+\n+        debug!(\n+            \"CodegenUnit {} merged into CodegenUnit {}\",\n+            smallest.name(),\n+            second_smallest.name()\n+        );\n+    }\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+\n+    if cx.tcx.sess.opts.incremental.is_some() {\n+        // If we are doing incremental compilation, we want CGU names to\n+        // reflect the path of the source level module they correspond to.\n+        // For CGUs that contain the code of multiple modules because of the\n+        // merging done above, we use a concatenation of the names of all\n+        // contained CGUs.\n+        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+            .into_iter()\n+            // This `filter` makes sure we only update the name of CGUs that\n+            // were actually modified by merging.\n+            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+            .map(|(current_cgu_name, cgu_contents)| {\n+                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n+\n+                // Sort the names, so things are deterministic and easy to\n+                // predict. We are sorting primitive `&str`s here so we can\n+                // use unstable sort.\n+                cgu_contents.sort_unstable();\n+\n+                (current_cgu_name, cgu_contents.join(\"--\"))\n+            })\n+            .collect();\n+\n+        for cgu in codegen_units.iter_mut() {\n+            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                } else {\n+                    // If we don't require CGU names to be human-readable,\n+                    // we use a fixed length hash of the composite CGU name\n+                    // instead.\n+                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n                 }\n             }\n-        } else {\n-            // If we are compiling non-incrementally we just generate simple CGU\n-            // names containing an index.\n-            for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-                let numbered_codegen_unit_name =\n-                    cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n-                cgu.set_name(numbered_codegen_unit_name);\n-            }\n+        }\n+    } else {\n+        // If we are compiling non-incrementally we just generate simple CGU\n+        // names containing an index.\n+        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+            let numbered_codegen_unit_name =\n+                cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n+            cgu.set_name(numbered_codegen_unit_name);\n         }\n     }\n+}\n \n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n-        let mut mono_item_placements = FxHashMap::default();\n-\n-        let single_codegen_unit = codegen_units.len() == 1;\n-\n-        for old_codegen_unit in codegen_units.iter_mut() {\n-            // Collect all items that need to be available in this codegen unit.\n-            let mut reachable = FxHashSet::default();\n-            for root in old_codegen_unit.items().keys() {\n-                follow_inlining(*root, cx.inlining_map, &mut reachable);\n-            }\n+pub(super) fn place_inlined_mono_items<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n+    let mut mono_item_placements = FxHashMap::default();\n \n-            let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n+    let single_codegen_unit = codegen_units.len() == 1;\n \n-            // Add all monomorphizations that are not already there.\n-            for mono_item in reachable {\n-                if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                    // This is a root, just copy it over.\n-                    new_codegen_unit.items_mut().insert(mono_item, *linkage);\n-                } else {\n-                    if roots.contains(&mono_item) {\n-                        bug!(\n-                            \"GloballyShared mono-item inlined into other CGU: \\\n-                              {:?}\",\n-                            mono_item\n-                        );\n-                    }\n+    for old_codegen_unit in codegen_units.iter_mut() {\n+        // Collect all items that need to be available in this codegen unit.\n+        let mut reachable = FxHashSet::default();\n+        for root in old_codegen_unit.items().keys() {\n+            follow_inlining(*root, cx.inlining_map, &mut reachable);\n+        }\n+\n+        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n \n-                    // This is a CGU-private copy.\n-                    new_codegen_unit\n-                        .items_mut()\n-                        .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+        // Add all monomorphizations that are not already there.\n+        for mono_item in reachable {\n+            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n+                // This is a root, just copy it over.\n+                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n+            } else {\n+                if roots.contains(&mono_item) {\n+                    bug!(\n+                        \"GloballyShared mono-item inlined into other CGU: \\\n+                          {:?}\",\n+                        mono_item\n+                    );\n                 }\n \n-                if !single_codegen_unit {\n-                    // If there is more than one codegen unit, we need to keep track\n-                    // in which codegen units each monomorphization is placed.\n-                    match mono_item_placements.entry(mono_item) {\n-                        Entry::Occupied(e) => {\n-                            let placement = e.into_mut();\n-                            debug_assert!(match *placement {\n-                                MonoItemPlacement::SingleCgu { cgu_name } => {\n-                                    cgu_name != new_codegen_unit.name()\n-                                }\n-                                MonoItemPlacement::MultipleCgus => true,\n-                            });\n-                            *placement = MonoItemPlacement::MultipleCgus;\n-                        }\n-                        Entry::Vacant(e) => {\n-                            e.insert(MonoItemPlacement::SingleCgu {\n-                                cgu_name: new_codegen_unit.name(),\n-                            });\n-                        }\n+                // This is a CGU-private copy.\n+                new_codegen_unit\n+                    .items_mut()\n+                    .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+            }\n+\n+            if !single_codegen_unit {\n+                // If there is more than one codegen unit, we need to keep track\n+                // in which codegen units each monomorphization is placed.\n+                match mono_item_placements.entry(mono_item) {\n+                    Entry::Occupied(e) => {\n+                        let placement = e.into_mut();\n+                        debug_assert!(match *placement {\n+                            MonoItemPlacement::SingleCgu { cgu_name } => {\n+                                cgu_name != new_codegen_unit.name()\n+                            }\n+                            MonoItemPlacement::MultipleCgus => true,\n+                        });\n+                        *placement = MonoItemPlacement::MultipleCgus;\n+                    }\n+                    Entry::Vacant(e) => {\n+                        e.insert(MonoItemPlacement::SingleCgu {\n+                            cgu_name: new_codegen_unit.name(),\n+                        });\n                     }\n                 }\n             }\n-\n-            *old_codegen_unit = new_codegen_unit;\n         }\n \n-        return mono_item_placements;\n-\n-        fn follow_inlining<'tcx>(\n-            mono_item: MonoItem<'tcx>,\n-            inlining_map: &InliningMap<'tcx>,\n-            visited: &mut FxHashSet<MonoItem<'tcx>>,\n-        ) {\n-            if !visited.insert(mono_item) {\n-                return;\n-            }\n-\n-            inlining_map.with_inlining_candidates(mono_item, |target| {\n-                follow_inlining(target, inlining_map, visited);\n-            });\n-        }\n+        *old_codegen_unit = new_codegen_unit;\n     }\n \n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        if codegen_units.len() == 1 {\n-            // Fast path for when there is only one codegen unit. In this case we\n-            // can internalize all candidates, since there is nowhere else they\n-            // could be accessed from.\n-            for cgu in codegen_units {\n-                for candidate in &internalization_candidates {\n-                    cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n-                }\n-            }\n+    return mono_item_placements;\n \n+    fn follow_inlining<'tcx>(\n+        mono_item: MonoItem<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+        visited: &mut FxHashSet<MonoItem<'tcx>>,\n+    ) {\n+        if !visited.insert(mono_item) {\n             return;\n         }\n \n-        // Build a map from every monomorphization to all the monomorphizations that\n-        // reference it.\n-        let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-        cx.inlining_map.iter_accesses(|accessor, accessees| {\n-            for accessee in accessees {\n-                accessor_map.entry(*accessee).or_default().push(accessor);\n-            }\n+        inlining_map.with_inlining_candidates(mono_item, |target| {\n+            follow_inlining(target, inlining_map, visited);\n         });\n+    }\n+}\n \n-        // For each internalization candidates in each codegen unit, check if it is\n-        // accessed from outside its defining codegen unit.\n+pub(super) fn internalize_symbols<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+) {\n+    if codegen_units.len() == 1 {\n+        // Fast path for when there is only one codegen unit. In this case we\n+        // can internalize all candidates, since there is nowhere else they\n+        // could be accessed from.\n         for cgu in codegen_units {\n-            let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n+            for candidate in &internalization_candidates {\n+                cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    // Build a map from every monomorphization to all the monomorphizations that\n+    // reference it.\n+    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n+    cx.inlining_map.iter_accesses(|accessor, accessees| {\n+        for accessee in accessees {\n+            accessor_map.entry(*accessee).or_default().push(accessor);\n+        }\n+    });\n \n-            for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-                if !internalization_candidates.contains(accessee) {\n-                    // This item is no candidate for internalizing, so skip it.\n+    // For each internalization candidates in each codegen unit, check if it is\n+    // accessed from outside its defining codegen unit.\n+    for cgu in codegen_units {\n+        let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n+\n+        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n+            if !internalization_candidates.contains(accessee) {\n+                // This item is no candidate for internalizing, so skip it.\n+                continue;\n+            }\n+            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n+\n+            if let Some(accessors) = accessor_map.get(accessee) {\n+                if accessors\n+                    .iter()\n+                    .filter_map(|accessor| {\n+                        // Some accessors might not have been\n+                        // instantiated. We can safely ignore those.\n+                        mono_item_placements.get(accessor)\n+                    })\n+                    .any(|placement| *placement != home_cgu)\n+                {\n+                    // Found an accessor from another CGU, so skip to the next\n+                    // item without marking this one as internal.\n                     continue;\n                 }\n-                debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n-\n-                if let Some(accessors) = accessor_map.get(accessee) {\n-                    if accessors\n-                        .iter()\n-                        .filter_map(|accessor| {\n-                            // Some accessors might not have been\n-                            // instantiated. We can safely ignore those.\n-                            mono_item_placements.get(accessor)\n-                        })\n-                        .any(|placement| *placement != home_cgu)\n-                    {\n-                        // Found an accessor from another CGU, so skip to the next\n-                        // item without marking this one as internal.\n-                        continue;\n-                    }\n-                }\n-\n-                // If we got here, we did not find any accesses from other CGUs,\n-                // so it's fine to make this monomorphization internal.\n-                *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n             }\n+\n+            // If we got here, we did not find any accesses from other CGUs,\n+            // so it's fine to make this monomorphization internal.\n+            *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n         }\n     }\n }"}, {"sha": "2843c361e0ac351f29ad25a66623e121d411a8e4", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 5, "deletions": 116, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/97d4a38de9fd6efb4588a7262cd9c66c2093e29f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d4a38de9fd6efb4588a7262cd9c66c2093e29f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "patch": "@@ -113,74 +113,7 @@ use rustc_span::symbol::Symbol;\n \n use crate::collector::InliningMap;\n use crate::collector::{self, MonoItemCollectionMode};\n-use crate::errors::{\n-    CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode, UnknownPartitionStrategy,\n-};\n-\n-enum Partitioner {\n-    Default(default::DefaultPartitioning),\n-    // Other partitioning strategies can go here.\n-    Unknown,\n-}\n-\n-impl<'tcx> Partition<'tcx> for Partitioner {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>,\n-    {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.place_root_mono_items(cx, mono_items),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    ) {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.merge_codegen_units(cx, codegen_units),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n-        match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.place_inlined_mono_items(cx, codegen_units, roots)\n-            }\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.internalize_symbols(\n-                cx,\n-                codegen_units,\n-                mono_item_placements,\n-                internalization_candidates,\n-            ),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-}\n+use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode};\n \n struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -194,49 +127,6 @@ pub struct PlacedRootMonoItems<'tcx> {\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-trait Partition<'tcx> {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>;\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    );\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement>;\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    );\n-}\n-\n-fn get_partitioner(tcx: TyCtxt<'_>) -> Partitioner {\n-    let strategy = match &tcx.sess.opts.unstable_opts.cgu_partitioning_strategy {\n-        None => \"default\",\n-        Some(s) => &s[..],\n-    };\n-\n-    match strategy {\n-        \"default\" => Partitioner::Default(default::DefaultPartitioning),\n-        _ => Partitioner::Unknown,\n-    }\n-}\n-\n fn partition<'tcx, I>(\n     tcx: TyCtxt<'tcx>,\n     mono_items: &mut I,\n@@ -248,14 +138,13 @@ where\n {\n     let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n \n-    let mut partitioner = get_partitioner(tcx);\n     let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n     let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        partitioner.place_root_mono_items(cx, mono_items)\n+        default::place_root_mono_items(cx, mono_items)\n     };\n \n     for cgu in &mut codegen_units {\n@@ -269,7 +158,7 @@ where\n     // estimates.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(cx, &mut codegen_units);\n+        default::merge_codegen_units(cx, &mut codegen_units);\n         debug_dump(tcx, \"POST MERGING\", &codegen_units);\n     }\n \n@@ -279,7 +168,7 @@ where\n     // local functions the definition of which is marked with `#[inline]`.\n     let mono_item_placements = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(cx, &mut codegen_units, roots)\n+        default::place_inlined_mono_items(cx, &mut codegen_units, roots)\n     };\n \n     for cgu in &mut codegen_units {\n@@ -292,7 +181,7 @@ where\n     // more freedom to optimize.\n     if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(\n+        default::internalize_symbols(\n             cx,\n             &mut codegen_units,\n             mono_item_placements,"}, {"sha": "7cc2b2c880c60bd75931ec04e2a596622619d366", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97d4a38de9fd6efb4588a7262cd9c66c2093e29f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d4a38de9fd6efb4588a7262cd9c66c2093e29f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "patch": "@@ -1372,8 +1372,6 @@ options! {\n         \"set options for branch target identification and pointer authentication on AArch64\"),\n     cf_protection: CFProtection = (CFProtection::None, parse_cfprotection, [TRACKED],\n         \"instrument control-flow architecture protection\"),\n-    cgu_partitioning_strategy: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"the codegen unit partitioning strategy to use\"),\n     codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"the backend to use\"),\n     combine_cgu: bool = (false, parse_bool, [TRACKED],"}]}