{"sha": "a3ed564c130ec3f19e933a9ea31faca5a717ce91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZWQ1NjRjMTMwZWMzZjE5ZTkzM2E5ZWEzMWZhY2E1YTcxN2NlOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-02T12:02:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-02T12:02:36Z"}, "message": "Auto merge of #81660 - jonas-schievink:rollup-fz2lh78, r=jonas-schievink\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #80629 (Add lint for 2229 migrations)\n - #81022 (Add Frames Iterator for Backtrace)\n - #81481 (move some tests)\n - #81485 (Add some tests for associated-type-bounds issues)\n - #81492 (rustdoc: Note why `rustdoc::html::markdown` is public)\n - #81577 (const_evaluatable: consider sub-expressions to be evaluatable)\n - #81599 (Implement `TrustedLen` for `Fuse<I: TrustedLen>`)\n - #81608 (Improve handling of spans around macro result parse errors)\n - #81609 (Remove the remains of query categories)\n - #81630 (Fix overflowing text on mobile when sidebar is displayed)\n - #81631 (Remove unneeded `mut` variable)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e5f20eba8577b1117e208b06ab7872ed3e8dcfca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5f20eba8577b1117e208b06ab7872ed3e8dcfca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3ed564c130ec3f19e933a9ea31faca5a717ce91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ed564c130ec3f19e933a9ea31faca5a717ce91", "html_url": "https://github.com/rust-lang/rust/commit/a3ed564c130ec3f19e933a9ea31faca5a717ce91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3ed564c130ec3f19e933a9ea31faca5a717ce91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6cb45ad01a4518f615926f39801996622f46179", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6cb45ad01a4518f615926f39801996622f46179", "html_url": "https://github.com/rust-lang/rust/commit/f6cb45ad01a4518f615926f39801996622f46179"}, {"sha": "73f859e912bb9ab60cef84e2d79ad2353691b9f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/73f859e912bb9ab60cef84e2d79ad2353691b9f0", "html_url": "https://github.com/rust-lang/rust/commit/73f859e912bb9ab60cef84e2d79ad2353691b9f0"}], "stats": {"total": 4113, "additions": 2480, "deletions": 1633}, "files": [{"sha": "5fdb7fc591594b861b3552c183489fd7b5bbab2e", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -896,7 +896,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 fragment\n             }\n             Err(mut err) => {\n-                err.set_span(span);\n+                if err.span.is_dummy() {\n+                    err.set_span(span);\n+                }\n                 annotate_err_with_kind(&mut err, kind, span);\n                 err.emit();\n                 self.cx.trace_macros_diag();"}, {"sha": "199be00990761484b84f5b9566f29e8f7a49beb5", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -2968,6 +2968,7 @@ declare_lint_pass! {\n         UNSUPPORTED_NAKED_FUNCTIONS,\n         MISSING_ABI,\n         SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n+        DISJOINT_CAPTURE_DROP_REORDER,\n     ]\n }\n \n@@ -2994,6 +2995,51 @@ declare_lint! {\n     \"detects doc comments that aren't used by rustdoc\"\n }\n \n+declare_lint! {\n+    /// The `disjoint_capture_drop_reorder` lint detects variables that aren't completely\n+    /// captured when the feature `capture_disjoint_fields` is enabled and it affects the Drop\n+    /// order of at least one path starting at this variable.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// # #![deny(disjoint_capture_drop_reorder)]\n+    /// # #![allow(unused)]\n+    /// struct FancyInteger(i32);\n+    ///\n+    /// impl Drop for FancyInteger {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"Just dropped {}\", self.0);\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Point { x: FancyInteger, y: FancyInteger }\n+    ///\n+    /// fn main() {\n+    ///   let p = Point { x: FancyInteger(10), y: FancyInteger(20) };\n+    ///\n+    ///   let c = || {\n+    ///      let x = p.x;\n+    ///   };\n+    ///\n+    ///   c();\n+    ///\n+    ///   // ... More code ...\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In the above example `p.y` will be dropped at the end of `f` instead of with `c` if\n+    /// the feature `capture_disjoint_fields` is enabled.\n+    pub DISJOINT_CAPTURE_DROP_REORDER,\n+    Allow,\n+    \"Drop reorder because of `capture_disjoint_fields`\"\n+\n+}\n+\n declare_lint_pass!(UnusedDocComment => [UNUSED_DOC_COMMENTS]);\n \n declare_lint! {"}, {"sha": "cff8e9833189bbf7535b208e2169ff5272323f1e", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 52, "deletions": 73, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -189,25 +189,6 @@ impl<T: Parse> Parse for List<T> {\n     }\n }\n \n-/// A named group containing queries.\n-///\n-/// For now, the name is not used any more, but the capability remains interesting for future\n-/// developments of the query system.\n-struct Group {\n-    #[allow(unused)]\n-    name: Ident,\n-    queries: List<Query>,\n-}\n-\n-impl Parse for Group {\n-    fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let name: Ident = input.parse()?;\n-        let content;\n-        braced!(content in input);\n-        Ok(Group { name, queries: content.parse()? })\n-    }\n-}\n-\n struct QueryModifiers {\n     /// The description of the query.\n     desc: (Option<Ident>, Punctuated<Expr, Token![,]>),\n@@ -450,72 +431,70 @@ fn add_query_description_impl(\n }\n \n pub fn rustc_queries(input: TokenStream) -> TokenStream {\n-    let groups = parse_macro_input!(input as List<Group>);\n+    let queries = parse_macro_input!(input as List<Query>);\n \n     let mut query_stream = quote! {};\n     let mut query_description_stream = quote! {};\n     let mut dep_node_def_stream = quote! {};\n     let mut cached_queries = quote! {};\n \n-    for group in groups.0 {\n-        for mut query in group.queries.0 {\n-            let modifiers = process_modifiers(&mut query);\n-            let name = &query.name;\n-            let arg = &query.arg;\n-            let result_full = &query.result;\n-            let result = match query.result {\n-                ReturnType::Default => quote! { -> () },\n-                _ => quote! { #result_full },\n-            };\n+    for mut query in queries.0 {\n+        let modifiers = process_modifiers(&mut query);\n+        let name = &query.name;\n+        let arg = &query.arg;\n+        let result_full = &query.result;\n+        let result = match query.result {\n+            ReturnType::Default => quote! { -> () },\n+            _ => quote! { #result_full },\n+        };\n \n-            if modifiers.cache.is_some() {\n-                cached_queries.extend(quote! {\n-                    #name,\n-                });\n-            }\n+        if modifiers.cache.is_some() {\n+            cached_queries.extend(quote! {\n+                #name,\n+            });\n+        }\n \n-            let mut attributes = Vec::new();\n+        let mut attributes = Vec::new();\n \n-            // Pass on the fatal_cycle modifier\n-            if modifiers.fatal_cycle {\n-                attributes.push(quote! { fatal_cycle });\n-            };\n-            // Pass on the storage modifier\n-            if let Some(ref ty) = modifiers.storage {\n-                attributes.push(quote! { storage(#ty) });\n-            };\n-            // Pass on the cycle_delay_bug modifier\n-            if modifiers.cycle_delay_bug {\n-                attributes.push(quote! { cycle_delay_bug });\n-            };\n-            // Pass on the no_hash modifier\n-            if modifiers.no_hash {\n-                attributes.push(quote! { no_hash });\n-            };\n-            // Pass on the anon modifier\n-            if modifiers.anon {\n-                attributes.push(quote! { anon });\n-            };\n-            // Pass on the eval_always modifier\n-            if modifiers.eval_always {\n-                attributes.push(quote! { eval_always });\n-            };\n+        // Pass on the fatal_cycle modifier\n+        if modifiers.fatal_cycle {\n+            attributes.push(quote! { fatal_cycle });\n+        };\n+        // Pass on the storage modifier\n+        if let Some(ref ty) = modifiers.storage {\n+            attributes.push(quote! { storage(#ty) });\n+        };\n+        // Pass on the cycle_delay_bug modifier\n+        if modifiers.cycle_delay_bug {\n+            attributes.push(quote! { cycle_delay_bug });\n+        };\n+        // Pass on the no_hash modifier\n+        if modifiers.no_hash {\n+            attributes.push(quote! { no_hash });\n+        };\n+        // Pass on the anon modifier\n+        if modifiers.anon {\n+            attributes.push(quote! { anon });\n+        };\n+        // Pass on the eval_always modifier\n+        if modifiers.eval_always {\n+            attributes.push(quote! { eval_always });\n+        };\n \n-            let attribute_stream = quote! {#(#attributes),*};\n-            let doc_comments = query.doc_comments.iter();\n-            // Add the query to the group\n-            query_stream.extend(quote! {\n-                #(#doc_comments)*\n-                [#attribute_stream] fn #name(#arg) #result,\n-            });\n+        let attribute_stream = quote! {#(#attributes),*};\n+        let doc_comments = query.doc_comments.iter();\n+        // Add the query to the group\n+        query_stream.extend(quote! {\n+            #(#doc_comments)*\n+            [#attribute_stream] fn #name(#arg) #result,\n+        });\n \n-            // Create a dep node for the query\n-            dep_node_def_stream.extend(quote! {\n-                [#attribute_stream] #name(#arg),\n-            });\n+        // Create a dep node for the query\n+        dep_node_def_stream.extend(quote! {\n+            [#attribute_stream] #name(#arg),\n+        });\n \n-            add_query_description_impl(&query, modifiers, &mut query_description_stream);\n-        }\n+        add_query_description_impl(&query, modifiers, &mut query_description_stream);\n     }\n \n     TokenStream::from(quote! {"}, {"sha": "ca528b2f0914bbff8df1fc6f912c1bf04bcbcbf2", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1340, "deletions": 1433, "changes": 2773, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91"}, {"sha": "5512e849c451d014783f2ed47531bfd9cdb95505", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -1104,7 +1104,7 @@ impl<'a> Parser<'a> {\n         let (prev_sp, sp) = match (&self.token.kind, self.subparser_name) {\n             // Point at the end of the macro call when reaching end of macro arguments.\n             (token::Eof, Some(_)) => {\n-                let sp = self.sess.source_map().next_point(self.token.span);\n+                let sp = self.sess.source_map().next_point(self.prev_token.span);\n                 (sp, sp)\n             }\n             // We don't want to point at the following span after DUMMY_SP.\n@@ -1721,7 +1721,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn expected_expression_found(&self) -> DiagnosticBuilder<'a> {\n         let (span, msg) = match (&self.token.kind, self.subparser_name) {\n             (&token::Eof, Some(origin)) => {\n-                let sp = self.sess.source_map().next_point(self.token.span);\n+                let sp = self.sess.source_map().next_point(self.prev_token.span);\n                 (sp, format!(\"expected expression, found end of {}\", origin))\n             }\n             _ => ("}, {"sha": "631dcb60594f1823aa925a6ae532aad5960b0c62", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -132,7 +132,7 @@ where\n         tcx: TyCtxt<'tcx>,\n         ct: AbstractConst<'tcx>,\n     ) -> ControlFlow<V::BreakTy> {\n-        const_evaluatable::walk_abstract_const(tcx, ct, |node| match node {\n+        const_evaluatable::walk_abstract_const(tcx, ct, |node| match node.root() {\n             ACNode::Leaf(leaf) => {\n                 let leaf = leaf.subst(tcx, ct.substs);\n                 self.visit_const(leaf)"}, {"sha": "004c06029ffba51baafa7750880f33980ed895c3", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -2083,18 +2083,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         output: Option<&'tcx hir::Ty<'tcx>>,\n     ) {\n         debug!(\"visit_fn_like_elision: enter\");\n-        let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n-        let arg_scope = Scope::Elision { elide: arg_elide.clone(), s: self.scope };\n+        let arg_scope = Scope::Elision { elide: Elide::FreshLateAnon(Cell::new(0)), s: self.scope };\n         self.with(arg_scope, |_, this| {\n             for input in inputs {\n                 this.visit_ty(input);\n             }\n-            match *this.scope {\n-                Scope::Elision { ref elide, .. } => {\n-                    arg_elide = elide.clone();\n-                }\n-                _ => bug!(),\n-            }\n         });\n \n         let output = match output {"}, {"sha": "2b429372dcffb2d2dd07a800bf4392b408739512", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -799,6 +799,9 @@ impl SourceMap {\n \n     /// Returns a new span representing the next character after the end-point of this span.\n     pub fn next_point(&self, sp: Span) -> Span {\n+        if sp.is_dummy() {\n+            return sp;\n+        }\n         let start_of_next_point = sp.hi().0;\n \n         let width = self.find_width_of_character_at_span(sp.shrink_to_hi(), true);"}, {"sha": "3facdd5f84c29112a2a768259ddebfefd6752627", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -50,11 +50,24 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                             if b_def == def && b_substs == substs {\n                                 debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n                                 return Ok(());\n-                            } else if AbstractConst::new(tcx, b_def, b_substs)?\n-                                .map_or(false, |b_ct| try_unify(tcx, ct, b_ct))\n-                            {\n-                                debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n-                                return Ok(());\n+                            }\n+\n+                            if let Some(b_ct) = AbstractConst::new(tcx, b_def, b_substs)? {\n+                                // Try to unify with each subtree in the AbstractConst to allow for\n+                                // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n+                                // predicate for `(N + 1) * 2`\n+                                let result =\n+                                    walk_abstract_const(tcx, b_ct, |b_ct| {\n+                                        match try_unify(tcx, ct, b_ct) {\n+                                            true => ControlFlow::BREAK,\n+                                            false => ControlFlow::CONTINUE,\n+                                        }\n+                                    });\n+\n+                                if let ControlFlow::Break(()) = result {\n+                                    debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                                    return Ok(());\n+                                }\n                             }\n                         }\n                         _ => {} // don't care\n@@ -78,7 +91,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                     Concrete,\n                 }\n                 let mut failure_kind = FailureKind::Concrete;\n-                walk_abstract_const::<!, _>(tcx, ct, |node| match node {\n+                walk_abstract_const::<!, _>(tcx, ct, |node| match node.root() {\n                     Node::Leaf(leaf) => {\n                         let leaf = leaf.subst(tcx, ct.substs);\n                         if leaf.has_infer_types_or_consts() {\n@@ -580,15 +593,15 @@ pub fn walk_abstract_const<'tcx, R, F>(\n     mut f: F,\n ) -> ControlFlow<R>\n where\n-    F: FnMut(Node<'tcx>) -> ControlFlow<R>,\n+    F: FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n {\n     fn recurse<'tcx, R>(\n         tcx: TyCtxt<'tcx>,\n         ct: AbstractConst<'tcx>,\n-        f: &mut dyn FnMut(Node<'tcx>) -> ControlFlow<R>,\n+        f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n     ) -> ControlFlow<R> {\n+        f(ct)?;\n         let root = ct.root();\n-        f(root)?;\n         match root {\n             Node::Leaf(_) => ControlFlow::CONTINUE,\n             Node::Binop(_, l, r) => {"}, {"sha": "3852005ee3f35f0c79a05e1c3b1300def69eab50", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -828,7 +828,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n             // constants which are not considered const evaluatable.\n             use rustc_middle::mir::abstract_const::Node;\n             if let Ok(Some(ct)) = AbstractConst::from_const(self.tcx, ct) {\n-                const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node {\n+                const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node.root() {\n                     Node::Leaf(leaf) => {\n                         let leaf = leaf.subst(self.tcx, ct.substs);\n                         self.visit_const(leaf)\n@@ -849,7 +849,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                 // take a `ty::Const` instead.\n                 use rustc_middle::mir::abstract_const::Node;\n                 if let Ok(Some(ct)) = AbstractConst::new(self.tcx, def, substs) {\n-                    const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node {\n+                    const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node.root() {\n                         Node::Leaf(leaf) => {\n                             let leaf = leaf.subst(self.tcx, ct.substs);\n                             self.visit_const(leaf)"}, {"sha": "04a9e65e6647d9dda6b9346e823e5a081c40d447", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 198, "deletions": 44, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -30,6 +30,7 @@\n //! then mean that all later passes would have to check for these figments\n //! and report an error, and it just seems like more mess in the end.)\n \n+use super::writeback::Resolver;\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n@@ -40,7 +41,9 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n-use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n+use rustc_session::lint;\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n \n@@ -55,6 +58,11 @@ enum PlaceAncestryRelation {\n     Divergent,\n }\n \n+/// Intermediate format to store a captured `Place` and associated `ty::CaptureInfo`\n+/// during capture analysis. Information in this map feeds into the minimum capture\n+/// analysis pass.\n+type InferredCaptureInformation<'tcx> = FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n         InferBorrowKindVisitor { fcx: self }.visit_body(body);\n@@ -92,7 +100,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         closure_hir_id: hir::HirId,\n         span: Span,\n-        body: &hir::Body<'_>,\n+        body: &'tcx hir::Body<'tcx>,\n         capture_clause: hir::CaptureBy,\n     ) {\n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_hir_id, body.id());\n@@ -124,28 +132,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let local_def_id = closure_def_id.expect_local();\n \n-        let mut capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>> =\n-            Default::default();\n-        if !self.tcx.features().capture_disjoint_fields {\n-            if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n-                for (&var_hir_id, _) in upvars.iter() {\n-                    let place = self.place_for_root_variable(local_def_id, var_hir_id);\n-\n-                    debug!(\"seed place {:?}\", place);\n-\n-                    let upvar_id = ty::UpvarId::new(var_hir_id, local_def_id);\n-                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n-                    let info = ty::CaptureInfo {\n-                        capture_kind_expr_id: None,\n-                        path_expr_id: None,\n-                        capture_kind,\n-                    };\n-\n-                    capture_information.insert(place, info);\n-                }\n-            }\n-        }\n-\n         let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n         assert_eq!(body_owner_def_id.to_def_id(), closure_def_id);\n         let mut delegate = InferBorrowKind {\n@@ -155,7 +141,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             capture_clause,\n             current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n             current_origin: None,\n-            capture_information,\n+            capture_information: Default::default(),\n         };\n         euv::ExprUseVisitor::new(\n             &mut delegate,\n@@ -172,6 +158,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         self.log_capture_analysis_first_pass(closure_def_id, &delegate.capture_information, span);\n \n+        self.compute_min_captures(closure_def_id, delegate.capture_information);\n+\n+        let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        if should_do_migration_analysis(self.tcx, closure_hir_id) {\n+            self.perform_2229_migration_anaysis(closure_def_id, capture_clause, span, body);\n+        }\n+\n+        // We now fake capture information for all variables that are mentioned within the closure\n+        // We do this after handling migrations so that min_captures computes before\n+        if !self.tcx.features().capture_disjoint_fields {\n+            let mut capture_information: InferredCaptureInformation<'tcx> = Default::default();\n+\n+            if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+                for var_hir_id in upvars.keys() {\n+                    let place = self.place_for_root_variable(local_def_id, *var_hir_id);\n+\n+                    debug!(\"seed place {:?}\", place);\n+\n+                    let upvar_id = ty::UpvarId::new(*var_hir_id, local_def_id);\n+                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n+                    let fake_info = ty::CaptureInfo {\n+                        capture_kind_expr_id: None,\n+                        path_expr_id: None,\n+                        capture_kind,\n+                    };\n+\n+                    capture_information.insert(place, fake_info);\n+                }\n+            }\n+\n+            // This will update the min captures based on this new fake information.\n+            self.compute_min_captures(closure_def_id, capture_information);\n+        }\n+\n         if let Some(closure_substs) = infer_kind {\n             // Unify the (as yet unbound) type variable in the closure\n             // substs with the kind we inferred.\n@@ -197,7 +217,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.compute_min_captures(closure_def_id, delegate);\n         self.log_closure_min_capture_info(closure_def_id, span);\n \n         self.min_captures_to_closure_captures_bridge(closure_def_id);\n@@ -344,6 +363,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Places (and corresponding capture kind) that we need to keep track of to support all\n     /// the required captured paths.\n     ///\n+    ///\n+    /// Note: If this function is called multiple times for the same closure, it will update\n+    ///       the existing min_capture map that is stored in TypeckResults.\n+    ///\n     /// Eg:\n     /// ```rust,no_run\n     /// struct Point { x: i32, y: i32 }\n@@ -408,11 +431,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn compute_min_captures(\n         &self,\n         closure_def_id: DefId,\n-        inferred_info: InferBorrowKind<'_, 'tcx>,\n+        capture_information: InferredCaptureInformation<'tcx>,\n     ) {\n-        let mut root_var_min_capture_list: ty::RootVariableMinCaptureList<'_> = Default::default();\n+        if capture_information.is_empty() {\n+            return;\n+        }\n+\n+        let mut typeck_results = self.typeck_results.borrow_mut();\n \n-        for (place, capture_info) in inferred_info.capture_information.into_iter() {\n+        let mut root_var_min_capture_list =\n+            typeck_results.closure_min_captures.remove(&closure_def_id).unwrap_or_default();\n+\n+        for (place, capture_info) in capture_information.into_iter() {\n             let var_hir_id = match place.base {\n                 PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n@@ -422,7 +452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n-                    let mutability = self.determine_capture_mutability(&place);\n+                    let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                     let min_cap_list =\n                         vec![ty::CapturedPlace { place, info: capture_info, mutability }];\n                     root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n@@ -487,21 +517,129 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Only need to insert when we don't have an ancestor in the existing min capture list\n             if !ancestor_found {\n-                let mutability = self.determine_capture_mutability(&place);\n+                let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                 let captured_place =\n                     ty::CapturedPlace { place, info: updated_capture_info, mutability };\n                 min_cap_list.push(captured_place);\n             }\n         }\n \n         debug!(\"For closure={:?}, min_captures={:#?}\", closure_def_id, root_var_min_capture_list);\n+        typeck_results.closure_min_captures.insert(closure_def_id, root_var_min_capture_list);\n+    }\n \n-        if !root_var_min_capture_list.is_empty() {\n-            self.typeck_results\n-                .borrow_mut()\n-                .closure_min_captures\n-                .insert(closure_def_id, root_var_min_capture_list);\n+    /// Perform the migration analysis for RFC 2229, and emit lint\n+    /// `disjoint_capture_drop_reorder` if needed.\n+    fn perform_2229_migration_anaysis(\n+        &self,\n+        closure_def_id: DefId,\n+        capture_clause: hir::CaptureBy,\n+        span: Span,\n+        body: &'tcx hir::Body<'tcx>,\n+    ) {\n+        let need_migrations = self.compute_2229_migrations_first_pass(\n+            closure_def_id,\n+            span,\n+            capture_clause,\n+            body,\n+            self.typeck_results.borrow().closure_min_captures.get(&closure_def_id),\n+        );\n+\n+        if !need_migrations.is_empty() {\n+            let need_migrations_hir_id = need_migrations.iter().map(|m| m.0).collect::<Vec<_>>();\n+\n+            let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations_hir_id);\n+\n+            let local_def_id = closure_def_id.expect_local();\n+            let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+            self.tcx.struct_span_lint_hir(\n+                lint::builtin::DISJOINT_CAPTURE_DROP_REORDER,\n+                closure_hir_id,\n+                span,\n+                |lint| {\n+                    let mut diagnostics_builder = lint.build(\n+                        \"drop order affected for closure because of `capture_disjoint_fields`\",\n+                    );\n+                    diagnostics_builder.note(&migrations_text);\n+                    diagnostics_builder.emit();\n+                },\n+            );\n+        }\n+    }\n+\n+    /// Figures out the list of root variables (and their types) that aren't completely\n+    /// captured by the closure when `capture_disjoint_fields` is enabled and drop order of\n+    /// some path starting at that root variable **might** be affected.\n+    ///\n+    /// The output list would include a root variable if:\n+    /// - It would have been moved into the closure when `capture_disjoint_fields` wasn't\n+    ///   enabled, **and**\n+    /// - It wasn't completely captured by the closure, **and**\n+    /// - The type of the root variable needs Drop.\n+    fn compute_2229_migrations_first_pass(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_span: Span,\n+        closure_clause: hir::CaptureBy,\n+        body: &'tcx hir::Body<'tcx>,\n+        min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n+    ) -> Vec<(hir::HirId, Ty<'tcx>)> {\n+        fn resolve_ty<T: TypeFoldable<'tcx>>(\n+            fcx: &FnCtxt<'_, 'tcx>,\n+            span: Span,\n+            body: &'tcx hir::Body<'tcx>,\n+            ty: T,\n+        ) -> T {\n+            let mut resolver = Resolver::new(fcx, &span, body);\n+            ty.fold_with(&mut resolver)\n+        }\n+\n+        let upvars = if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+            upvars\n+        } else {\n+            return vec![];\n+        };\n+\n+        let mut need_migrations = Vec::new();\n+\n+        for (&var_hir_id, _) in upvars.iter() {\n+            let ty = resolve_ty(self, closure_span, body, self.node_ty(var_hir_id));\n+\n+            if !ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n+                continue;\n+            }\n+\n+            let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n+                min_captures.and_then(|m| m.get(&var_hir_id))\n+            {\n+                root_var_min_capture_list\n+            } else {\n+                // The upvar is mentioned within the closure but no path starting from it is\n+                // used.\n+\n+                match closure_clause {\n+                    // Only migrate if closure is a move closure\n+                    hir::CaptureBy::Value => need_migrations.push((var_hir_id, ty)),\n+\n+                    hir::CaptureBy::Ref => {}\n+                }\n+\n+                continue;\n+            };\n+\n+            let is_moved = root_var_min_capture_list\n+                .iter()\n+                .any(|capture| matches!(capture.info.capture_kind, ty::UpvarCapture::ByValue(_)));\n+\n+            let is_not_completely_captured =\n+                root_var_min_capture_list.iter().any(|capture| capture.place.projections.len() > 0);\n+\n+            if is_moved && is_not_completely_captured {\n+                need_migrations.push((var_hir_id, ty));\n+            }\n         }\n+\n+        need_migrations\n     }\n \n     fn init_capture_kind(\n@@ -613,18 +751,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// A captured place is mutable if\n     /// 1. Projections don't include a Deref of an immut-borrow, **and**\n     /// 2. PlaceBase is mut or projections include a Deref of a mut-borrow.\n-    fn determine_capture_mutability(&self, place: &Place<'tcx>) -> hir::Mutability {\n+    fn determine_capture_mutability(\n+        &self,\n+        typeck_results: &'a TypeckResults<'tcx>,\n+        place: &Place<'tcx>,\n+    ) -> hir::Mutability {\n         let var_hir_id = match place.base {\n             PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n             _ => unreachable!(),\n         };\n \n-        let bm = *self\n-            .typeck_results\n-            .borrow()\n-            .pat_binding_modes()\n-            .get(var_hir_id)\n-            .expect(\"missing binding mode\");\n+        let bm = *typeck_results.pat_binding_modes().get(var_hir_id).expect(\"missing binding mode\");\n \n         let mut is_mutbl = match bm {\n             ty::BindByValue(mutability) => mutability,\n@@ -698,9 +835,11 @@ struct InferBorrowKind<'a, 'tcx> {\n     ///\n     /// For closure `fix_s`, (at a high level) the map contains\n     ///\n+    /// ```\n     /// Place { V1, [ProjectionKind::Field(Index=0, Variant=0)] } : CaptureKind { E1, ImmutableBorrow }\n     /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n-    capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>,\n+    /// ```\n+    capture_information: InferredCaptureInformation<'tcx>,\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n@@ -1119,6 +1258,21 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n \n+fn should_do_migration_analysis(tcx: TyCtxt<'_>, closure_id: hir::HirId) -> bool {\n+    let (level, _) =\n+        tcx.lint_level_at_node(lint::builtin::DISJOINT_CAPTURE_DROP_REORDER, closure_id);\n+\n+    !matches!(level, lint::Level::Allow)\n+}\n+\n+fn migration_suggestion_for_2229(tcx: TyCtxt<'_>, need_migrations: &Vec<hir::HirId>) -> String {\n+    let need_migrations_strings =\n+        need_migrations.iter().map(|v| format!(\"{}\", var_name(tcx, *v))).collect::<Vec<_>>();\n+    let migrations_list_concat = need_migrations_strings.join(\", \");\n+\n+    format!(\"drop(&({}));\", migrations_list_concat)\n+}\n+\n /// Helper function to determine if we need to escalate CaptureKind from\n /// CaptureInfo A to B and returns the escalated CaptureInfo.\n /// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)"}, {"sha": "4d18b2cb3fc49656d2f558761ffea967ce8fdd19", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -650,7 +650,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n }\n \n-trait Locatable {\n+crate trait Locatable {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span;\n }\n \n@@ -668,7 +668,7 @@ impl Locatable for hir::HirId {\n \n /// The Resolver. This is the type folding engine that detects\n /// unresolved types and so forth.\n-struct Resolver<'cx, 'tcx> {\n+crate struct Resolver<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     span: &'cx dyn Locatable,\n@@ -679,7 +679,7 @@ struct Resolver<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n-    fn new(\n+    crate fn new(\n         fcx: &'cx FnCtxt<'cx, 'tcx>,\n         span: &'cx dyn Locatable,\n         body: &'tcx hir::Body<'tcx>,"}, {"sha": "7a852c2cb9da55dc9d8bbb5c85c4987a22ae64a3", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -1,6 +1,8 @@\n use crate::intrinsics;\n use crate::iter::adapters::{zip::try_get_unchecked, InPlaceIterable, SourceIter};\n-use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedRandomAccess};\n+use crate::iter::{\n+    DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen, TrustedRandomAccess,\n+};\n use crate::ops::Try;\n \n /// An iterator that yields `None` forever after the underlying iterator\n@@ -182,8 +184,19 @@ where\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+// SAFETY: `TrustedLen` requires that an accurate length is reported via `size_hint()`. As `Fuse`\n+// is just forwarding this to the wrapped iterator `I` this property is preserved and it is safe to\n+// implement `TrustedLen` here.\n+unsafe impl<I> TrustedLen for Fuse<I> where I: TrustedLen {}\n+\n #[doc(hidden)]\n #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+// SAFETY: `TrustedRandomAccess` requires that `size_hint()` must be exact and cheap to call, and\n+// `Iterator::__iterator_get_unchecked()` must be implemented accordingly.\n+//\n+// This is safe to implement as `Fuse` is just forwarding these to the wrapped iterator `I`, which\n+// preserves these properties.\n unsafe impl<I> TrustedRandomAccess for Fuse<I>\n where\n     I: TrustedRandomAccess,"}, {"sha": "0aae4674b29423c763025113ecf236b8591f4dd4", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -147,11 +147,14 @@ fn _assert_send_sync() {\n     _assert::<Backtrace>();\n }\n \n-struct BacktraceFrame {\n+/// A single frame of a backtrace.\n+#[unstable(feature = \"backtrace_frames\", issue = \"79676\")]\n+pub struct BacktraceFrame {\n     frame: RawFrame,\n     symbols: Vec<BacktraceSymbol>,\n }\n \n+#[derive(Debug)]\n enum RawFrame {\n     Actual(backtrace_rs::Frame),\n     #[cfg(test)]\n@@ -196,6 +199,14 @@ impl fmt::Debug for Backtrace {\n     }\n }\n \n+impl fmt::Debug for BacktraceFrame {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut dbg = fmt.debug_list();\n+        dbg.entries(&self.symbols);\n+        dbg.finish()\n+    }\n+}\n+\n impl fmt::Debug for BacktraceSymbol {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME: improve formatting: https://github.com/rust-lang/rust/issues/65280\n@@ -353,6 +364,14 @@ impl Backtrace {\n     }\n }\n \n+impl<'a> Backtrace {\n+    /// Returns an iterator over the backtrace frames.\n+    #[unstable(feature = \"backtrace_frames\", issue = \"79676\")]\n+    pub fn frames(&'a self) -> &'a [BacktraceFrame] {\n+        if let Inner::Captured(c) = &self.inner { &c.force().frames } else { &[] }\n+    }\n+}\n+\n impl fmt::Display for Backtrace {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let capture = match &self.inner {"}, {"sha": "f5da93f93fd932b0e7ed6134e1893c18b6d02d2a", "filename": "library/std/src/backtrace/tests.rs", "status": "modified", "additions": 72, "deletions": 37, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -1,48 +1,52 @@\n use super::*;\n \n+fn generate_fake_frames() -> Vec<BacktraceFrame> {\n+    vec![\n+        BacktraceFrame {\n+            frame: RawFrame::Fake,\n+            symbols: vec![BacktraceSymbol {\n+                name: Some(b\"std::backtrace::Backtrace::create\".to_vec()),\n+                filename: Some(BytesOrWide::Bytes(b\"rust/backtrace.rs\".to_vec())),\n+                lineno: Some(100),\n+                colno: None,\n+            }],\n+        },\n+        BacktraceFrame {\n+            frame: RawFrame::Fake,\n+            symbols: vec![BacktraceSymbol {\n+                name: Some(b\"__rust_maybe_catch_panic\".to_vec()),\n+                filename: None,\n+                lineno: None,\n+                colno: None,\n+            }],\n+        },\n+        BacktraceFrame {\n+            frame: RawFrame::Fake,\n+            symbols: vec![\n+                BacktraceSymbol {\n+                    name: Some(b\"std::rt::lang_start_internal\".to_vec()),\n+                    filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n+                    lineno: Some(300),\n+                    colno: Some(5),\n+                },\n+                BacktraceSymbol {\n+                    name: Some(b\"std::rt::lang_start\".to_vec()),\n+                    filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n+                    lineno: Some(400),\n+                    colno: None,\n+                },\n+            ],\n+        },\n+    ]\n+}\n+\n #[test]\n fn test_debug() {\n     let backtrace = Backtrace {\n         inner: Inner::Captured(LazilyResolvedCapture::new(Capture {\n             actual_start: 1,\n             resolved: true,\n-            frames: vec![\n-                BacktraceFrame {\n-                    frame: RawFrame::Fake,\n-                    symbols: vec![BacktraceSymbol {\n-                        name: Some(b\"std::backtrace::Backtrace::create\".to_vec()),\n-                        filename: Some(BytesOrWide::Bytes(b\"rust/backtrace.rs\".to_vec())),\n-                        lineno: Some(100),\n-                        colno: None,\n-                    }],\n-                },\n-                BacktraceFrame {\n-                    frame: RawFrame::Fake,\n-                    symbols: vec![BacktraceSymbol {\n-                        name: Some(b\"__rust_maybe_catch_panic\".to_vec()),\n-                        filename: None,\n-                        lineno: None,\n-                        colno: None,\n-                    }],\n-                },\n-                BacktraceFrame {\n-                    frame: RawFrame::Fake,\n-                    symbols: vec![\n-                        BacktraceSymbol {\n-                            name: Some(b\"std::rt::lang_start_internal\".to_vec()),\n-                            filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n-                            lineno: Some(300),\n-                            colno: Some(5),\n-                        },\n-                        BacktraceSymbol {\n-                            name: Some(b\"std::rt::lang_start\".to_vec()),\n-                            filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n-                            lineno: Some(400),\n-                            colno: None,\n-                        },\n-                    ],\n-                },\n-            ],\n+            frames: generate_fake_frames(),\n         })),\n     };\n \n@@ -58,3 +62,34 @@ fn test_debug() {\n     // Format the backtrace a second time, just to make sure lazily resolved state is stable\n     assert_eq!(format!(\"{:#?}\", backtrace), expected);\n }\n+\n+#[test]\n+fn test_frames() {\n+    let backtrace = Backtrace {\n+        inner: Inner::Captured(LazilyResolvedCapture::new(Capture {\n+            actual_start: 1,\n+            resolved: true,\n+            frames: generate_fake_frames(),\n+        })),\n+    };\n+\n+    let frames = backtrace.frames();\n+\n+    #[rustfmt::skip]\n+    let expected = vec![\n+        \"[\n+    { fn: \\\"std::backtrace::Backtrace::create\\\", file: \\\"rust/backtrace.rs\\\", line: 100 },\n+]\",\n+        \"[\n+    { fn: \\\"__rust_maybe_catch_panic\\\" },\n+]\",\n+        \"[\n+    { fn: \\\"std::rt::lang_start_internal\\\", file: \\\"rust/rt.rs\\\", line: 300 },\n+    { fn: \\\"std::rt::lang_start\\\", file: \\\"rust/rt.rs\\\", line: 400 },\n+]\"\n+    ];\n+\n+    let mut iter = frames.iter().zip(expected.iter());\n+\n+    assert!(iter.all(|(f, e)| format!(\"{:#?}\", f) == *e));\n+}"}, {"sha": "4318be898ceb49c60ca0211e20811e080e411b9f", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -2,6 +2,7 @@ crate mod escape;\n crate mod format;\n crate mod highlight;\n crate mod layout;\n+// used by the error-index generator, so it needs to be public\n pub mod markdown;\n crate mod render;\n crate mod sources;"}, {"sha": "422c57bcd3bd20238e51d2cc9504d977057dceb0", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -1490,6 +1490,14 @@ h4 > .notable-traits {\n \t\tbackground-color: rgba(0,0,0,0);\n \t\theight: 100%;\n \t}\n+\t/*\n+\tThis allows to prevent the version text to overflow the sidebar title on mobile mode when the\n+\tsidebar is displayed (after clicking on the \"hamburger\" button).\n+\t*/\n+\t.sidebar.mobile > div.version {\n+\t\toverflow: hidden;\n+\t\tmax-height: 33px;\n+\t}\n \t.sidebar {\n \t\twidth: calc(100% + 30px);\n \t}"}, {"sha": "87a6098e4922b7f7ccf7afcd72342660ee791f7f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -83,7 +83,8 @@ mod doctree;\n mod error;\n mod doctest;\n mod fold;\n-crate mod formats;\n+mod formats;\n+// used by the error-index generator, so it needs to be public\n pub mod html;\n mod json;\n mod markdown;"}, {"sha": "7e898851aa83ab30bbfcb2d4ed55bd2d84d5011f", "filename": "src/test/ui/associated-types/issue-38917.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fassociated-types%2Fissue-38917.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fassociated-types%2Fissue-38917.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-38917.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+\n+use std::borrow::Borrow;\n+\n+trait TNode: Sized {\n+    type ConcreteElement: TElement<ConcreteNode = Self>;\n+}\n+\n+trait TElement: Sized {\n+    type ConcreteNode: TNode<ConcreteElement = Self>;\n+}\n+\n+trait DomTraversal<N: TNode> {\n+    type BorrowElement: Borrow<N::ConcreteElement>;\n+}\n+\n+#[allow(dead_code)]\n+fn recalc_style_at<E, D>()\n+where\n+    E: TElement,\n+    D: DomTraversal<E::ConcreteNode>,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "fd325ae1008610367c2a803857fab14cefab2b71", "filename": "src/test/ui/associated-types/issue-40093.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fassociated-types%2Fissue-40093.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fassociated-types%2Fissue-40093.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-40093.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+pub trait Test {\n+    type Item;\n+    type Bundle: From<Self::Item>;\n+}\n+\n+fn fails<T>()\n+where\n+    T: Test<Item = String>,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "5f177333c93d5addc3868d925b90f305d743cb8a", "filename": "src/test/ui/associated-types/issue-43475.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fassociated-types%2Fissue-43475.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fassociated-types%2Fissue-43475.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-43475.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+trait Foo { type FooT: Foo; }\n+impl Foo for () { type FooT = (); }\n+trait Bar<T: Foo> { type BarT: Bar<T::FooT>; }\n+impl Bar<()> for () { type BarT = (); }\n+\n+#[allow(dead_code)]\n+fn test<C: Bar<()>>() { }\n+fn main() { }"}, {"sha": "4d2e39f4da60c788e9e625a3a62584b5daf508ac", "filename": "src/test/ui/associated-types/issue-63591.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fassociated-types%2Fissue-63591.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fassociated-types%2Fissue-63591.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-63591.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+trait Bar { type Assoc; }\n+\n+trait Thing {\n+    type Out;\n+    fn func() -> Self::Out;\n+}\n+\n+struct AssocIsCopy;\n+impl Bar for AssocIsCopy { type Assoc = u8; }\n+\n+impl Thing for AssocIsCopy {\n+    type Out = impl Bar<Assoc: Copy>;\n+\n+    fn func() -> Self::Out {\n+        AssocIsCopy\n+    }\n+}"}, {"sha": "5f5e621d762dfc67c703a04d75de1a4ece607f82", "filename": "src/test/ui/cast/fat-ptr-cast-rpass.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Ffat-ptr-cast-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Ffat-ptr-cast-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Ffat-ptr-cast-rpass.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "previous_filename": "src/test/ui/fat-ptr-cast-rpass.rs"}, {"sha": "a0fad583a1645a069f3fbbf0be75dd329ac0a648", "filename": "src/test/ui/cast/fat-ptr-cast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Ffat-ptr-cast.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "previous_filename": "src/test/ui/fat-ptr-cast.rs"}, {"sha": "0b0c288fe3b6169acbb88b0c191bcc0a75cf01b5", "filename": "src/test/ui/cast/fat-ptr-cast.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Ffat-ptr-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Ffat-ptr-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Ffat-ptr-cast.stderr?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "previous_filename": "src/test/ui/fat-ptr-cast.stderr"}, {"sha": "906b443c9fab86602fe0bceae29033b0e0b77d5b", "filename": "src/test/ui/cast/issue-17444.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Fissue-17444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Fissue-17444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fissue-17444.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "previous_filename": "src/test/ui/issues/issue-17444.rs"}, {"sha": "1097079dfc1d1c3a13dfa858265fe0bc889644d7", "filename": "src/test/ui/cast/issue-17444.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Fissue-17444.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Fissue-17444.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fissue-17444.stderr?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "previous_filename": "src/test/ui/issues/issue-17444.stderr"}, {"sha": "1384ecc6ef251027e708e116e022c9c90f1af9f2", "filename": "src/test/ui/cast/unsupported-cast.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Funsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Funsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Funsupported-cast.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,5 @@\n+struct A;\n+\n+fn main() {\n+  println!(\"{:?}\", 1.0 as *const A); //~ERROR  casting `f64` as `*const A` is invalid\n+}"}, {"sha": "56a375a1d942a0ce33ac0cafcd305ee5e77f6eab", "filename": "src/test/ui/cast/unsupported-cast.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Funsupported-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fcast%2Funsupported-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Funsupported-cast.stderr?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -1,7 +1,7 @@\n error[E0606]: casting `f64` as `*const A` is invalid\n-  --> $DIR/unsupported-cast.rs:6:20\n+  --> $DIR/unsupported-cast.rs:4:20\n    |\n-LL |   println!(\"{:?}\", 1.0 as *const A); // Can't cast float to foreign.\n+LL |   println!(\"{:?}\", 1.0 as *const A);\n    |                    ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error", "previous_filename": "src/test/ui/unsupported-cast.stderr"}, {"sha": "02b373620966e239c17fbae278a91d3f2aff9101", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,130 @@\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a insignificant drop (stlib defined)\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t, t1, t2));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t, t1));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        println!(\"{}\", t1.1);\n+    };\n+\n+    c();\n+}\n+\n+// Copy types get copied into the closure instead of move. Therefore we don't need to\n+// migrate then as their drop order isn't tied to the closure.\n+fn test4_only_non_copy_types_need_migration() {\n+    let t = (String::new(), String::new());\n+\n+    // `t1` is Copy because all of its elements are Copy\n+    let t1 = (0i32, 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+    };\n+\n+    c();\n+}\n+\n+fn test5_only_drop_types_need_migration() {\n+    struct S(i32, i32);\n+\n+    let t = (String::new(), String::new());\n+\n+    // `s` doesn't implement Drop or any elements within it, and doesn't need migration\n+    let s = S(0i32, 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        let _s = s.0;\n+    };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test6_move_closures_non_copy_types_might_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = move || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t1, t));\n+        println!(\"{} {}\", t1.1, t.1);\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test7_drop_non_drop_aggregate_need_migration() {\n+    let t = (String::new(), String::new(), 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_only_non_copy_types_need_migration();\n+    test5_only_drop_types_need_migration();\n+    test6_move_closures_non_copy_types_might_need_migration();\n+    test7_drop_non_drop_aggregate_need_migration();\n+}"}, {"sha": "656c132c12deeaf7630723734c8910c5539f90ac", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.stderr", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,105 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:13:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/insignificant_drop.rs:1:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: drop(&(t, t1, t2));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:31:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t, t1));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:47:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         println!(\"{}\", t1.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:65:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:83:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _s = s.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:98:13\n+   |\n+LL |       let c = move || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         println!(\"{} {}\", t1.1, t.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t1, t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/insignificant_drop.rs:113:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "73592ce04c28f9cfebdbb727369675d319db2939", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/no_migrations.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,84 @@\n+// run-pass\n+\n+// Set of test cases that don't need migrations\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+\n+\n+// Copy types as copied by the closure instead of being moved into the closure\n+// Therefore their drop order isn't tied to the closure and won't be requiring any\n+// migrations.\n+fn test1_only_copy_types() {\n+    let t = (0i32, 0i32);\n+\n+    let c = || {\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Same as test1 but using a move closure\n+fn test2_only_copy_types_move_closure() {\n+    let t = (0i32, 0i32);\n+\n+    let c = move || {\n+        println!(\"{}\", t.0);\n+    };\n+\n+    c();\n+}\n+\n+// Don't need to migrate if captured by ref\n+fn test3_only_copy_types_move_closure() {\n+    let t = (String::new(), String::new());\n+\n+    let c = || {\n+        println!(\"{}\", t.0);\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Insignificant Drop + Non Drop aggregates.\n+// Note in this test the closure captures a non Drop type and therefore the variable\n+// is only captured by ref.\n+fn test4_insignificant_drop_non_drop_aggregate() {\n+    let t = (String::new(), 0i32);\n+\n+    let c = || {\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+// Test migration analysis in case of Significant Drop + Non Drop aggregates.\n+// Note in this test the closure captures a non Drop type and therefore the variable\n+// is only captured by ref.\n+fn test5_significant_drop_non_drop_aggregate() {\n+    let t = (Foo(0), 0i32);\n+\n+    let c = || {\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_only_copy_types();\n+    test2_only_copy_types_move_closure();\n+    test3_only_copy_types_move_closure();\n+    test4_insignificant_drop_non_drop_aggregate();\n+    test5_significant_drop_non_drop_aggregate();\n+\n+}"}, {"sha": "ed5e4ea8be01182e7af538000f9dae4e34869858", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,137 @@\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a significant drop (user defined)\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ConstainsDropField(Foo, Foo);\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t, t1, t2));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t, t1));\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        println!(\"{:?}\", t1.1);\n+    };\n+\n+    c();\n+}\n+\n+// The root variable might not implement drop themselves but some path starting\n+// at the root variable might implement Drop.\n+//\n+// If this path isn't captured we need to migrate for the root variable.\n+fn test4_type_contains_drop_need_migration() {\n+    let t = ConstainsDropField(Foo(0), Foo(0));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test5_drop_non_drop_aggregate_need_migration() {\n+    let t = (Foo(0), Foo(0), 0i32);\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Significant and Insignificant Drop aggregates.\n+fn test6_significant_insignificant_drop_aggregate_need_migration() {\n+    struct S(i32, i32);\n+\n+    let t = (Foo(0), String::new());\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test7_move_closures_non_copy_types_might_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0), Foo(0));\n+\n+    let c = move || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t1, t));\n+        println!(\"{:?} {:?}\", t1.1, t.1);\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_type_contains_drop_need_migration();\n+    test5_drop_non_drop_aggregate_need_migration();\n+    test6_significant_insignificant_drop_aggregate_need_migration();\n+    test7_move_closures_non_copy_types_might_need_migration();\n+}"}, {"sha": "6c21b27b493ba579f3bf69fa9ac31dde94dda3e2", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.stderr", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,103 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:24:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/significant_drop.rs:1:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: drop(&(t, t1, t2));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:42:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t1 = t1.0;\n+LL | |         let _t2 = t2;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t, t1));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:58:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         println!(\"{:?}\", t1.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:75:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:90:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:105:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.1;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/significant_drop.rs:120:13\n+   |\n+LL |       let c = move || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?} {:?}\", t1.1, t.1);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t1, t));\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "4d0b87efc77c3549428b09087bbd428a5fb01dd8", "filename": "src/test/ui/const-generics/const_evaluatable_checked/nested_uneval_unification-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested_uneval_unification-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested_uneval_unification-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested_uneval_unification-1.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -21,7 +21,6 @@ where\n \n fn substs3<const L: usize>() -> Substs1<{ (L - 1) * 2 }>\n where\n-    [(); (L - 1)]: ,\n     [(); (L - 1) * 2 + 1]: ,\n {\n     substs2::<{ L - 1 }>()"}, {"sha": "11c0760cdfe055765ea382b41ba03aad4ad25903", "filename": "src/test/ui/const-generics/const_evaluatable_checked/subexprs_are_const_evalutable.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsubexprs_are_const_evalutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsubexprs_are_const_evalutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsubexprs_are_const_evalutable.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn make_array<const M: usize>() -> [(); M + 1] {\n+    [(); M + 1]\n+}\n+\n+fn foo<const N: usize>() -> [(); (N * 2) + 1] {\n+    make_array::<{ N * 2 }>()\n+}\n+\n+fn main() {\n+    assert_eq!(foo::<10>(), [(); 10 * 2 + 1])\n+}\n+\n+// Tests that N * 2 is considered const_evalutable by appearing as part of the (N * 2) + 1 const"}, {"sha": "e1b446fc61f612215a85f95d1702a450a7356d00", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -7,10 +7,10 @@ LL |             let mut closure1 = || p = &y;\n    = note: defining type: test::{closure#0}::{closure#0} with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n+               (&'_#1r mut &'_#2r i32, &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#1r: '_#3r\n+   = note: where '_#3r: '_#2r\n \n note: external requirements\n   --> $DIR/escape-upvar-nested.rs:20:27\n@@ -25,10 +25,10 @@ LL | |         };\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n+               (&'_#1r mut &'_#2r i32, &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#1r: '_#3r\n+   = note: where '_#3r: '_#2r\n \n note: no external requirements\n   --> $DIR/escape-upvar-nested.rs:13:1"}, {"sha": "0ea1076c32ef4dd215be4056d3e9cefef645d3b5", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -7,10 +7,10 @@ LL |         let mut closure = || p = &y;\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n+               (&'_#1r mut &'_#2r i32, &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#1r: '_#3r\n+   = note: where '_#3r: '_#2r\n \n note: no external requirements\n   --> $DIR/escape-upvar-ref.rs:17:1"}, {"sha": "027389556fe24fd83ed4a0cecc9554cbec5c8b13", "filename": "src/test/ui/proc-macro/issue-81543-item-parse-err.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81543-item-parse-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81543-item-parse-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81543-item-parse-err.rs?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,14 @@\n+// aux-build:test-macros.rs\n+\n+// Regression test for issue #81543\n+// Tests that we emit a properly spanned error\n+// when the output of a proc-macro cannot be parsed\n+// as the expected AST node kind\n+\n+extern crate test_macros;\n+\n+test_macros::identity! {\n+    fn 32() {} //~ ERROR expected identifier\n+}\n+\n+fn main() {}"}, {"sha": "ca524176035b84d79a78a746e851cc43a723f8f3", "filename": "src/test/ui/proc-macro/issue-81543-item-parse-err.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81543-item-parse-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81543-item-parse-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81543-item-parse-err.stderr?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -0,0 +1,8 @@\n+error: expected identifier, found `32`\n+  --> $DIR/issue-81543-item-parse-err.rs:11:8\n+   |\n+LL |     fn 32() {}\n+   |        ^^ expected identifier\n+\n+error: aborting due to previous error\n+"}, {"sha": "58f6165388ca167c3db93524d8c5b1de41f81621", "filename": "src/test/ui/proc-macro/lifetimes.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ed564c130ec3f19e933a9ea31faca5a717ce91/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.stderr?ref=a3ed564c130ec3f19e933a9ea31faca5a717ce91", "patch": "@@ -2,7 +2,12 @@ error: expected type, found `'`\n   --> $DIR/lifetimes.rs:7:10\n    |\n LL | type A = single_quote_alone!();\n-   |          ^^^^^^^^^^^^^^^^^^^^^ this macro call doesn't expand to a type\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+   |          |\n+   |          expected type\n+   |          this macro call doesn't expand to a type\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "cb6a57a4d39d58590a776e45ab09cd982e576dc1", "filename": "src/test/ui/unsupported-cast.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6cb45ad01a4518f615926f39801996622f46179/src%2Ftest%2Fui%2Funsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cb45ad01a4518f615926f39801996622f46179/src%2Ftest%2Fui%2Funsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsupported-cast.rs?ref=f6cb45ad01a4518f615926f39801996622f46179", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:casting\n-\n-struct A;\n-\n-fn main() {\n-  println!(\"{:?}\", 1.0 as *const A); // Can't cast float to foreign.\n-}"}]}