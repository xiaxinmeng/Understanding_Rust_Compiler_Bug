{"sha": "e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3M2ZiYzY5Y2Q4NWNjZDdlNDQ0OTI5YjdiN2FhMGFlNzRlZTYxOTg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-08T16:25:52Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-11T20:09:46Z"}, "message": "rustc_typeck: unify expected return types with formal return types to propagate coercions through calls of generic functions.", "tree": {"sha": "c2342320ca949eaada24e199ff13abc85d7f3834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2342320ca949eaada24e199ff13abc85d7f3834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198", "html_url": "https://github.com/rust-lang/rust/commit/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4", "html_url": "https://github.com/rust-lang/rust/commit/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4"}], "stats": {"total": 203, "additions": 180, "deletions": 23}, "files": [{"sha": "8fd44f144e1ea577fc30a832bef7d1b9addb4282", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198", "patch": "@@ -613,6 +613,39 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.commit_unconditionally(move || self.try(move |_| f()))\n     }\n \n+    /// Execute `f` and commit only the region bindings if successful.\n+    /// The function f must be very careful not to leak any non-region\n+    /// variables that get created.\n+    pub fn commit_regions_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n+        F: FnOnce() -> Result<T, E>\n+    {\n+        debug!(\"commit_regions_if_ok()\");\n+        let CombinedSnapshot { type_snapshot,\n+                               int_snapshot,\n+                               float_snapshot,\n+                               region_vars_snapshot } = self.start_snapshot();\n+\n+        let r = self.try(move |_| f());\n+\n+        // Roll back any non-region bindings - they should be resolved\n+        // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n+        self.type_variables\n+            .borrow_mut()\n+            .rollback_to(type_snapshot);\n+        self.int_unification_table\n+            .borrow_mut()\n+            .rollback_to(int_snapshot);\n+        self.float_unification_table\n+            .borrow_mut()\n+            .rollback_to(float_snapshot);\n+\n+        // Commit region vars that may escape through resolved types.\n+        self.region_vars\n+            .commit(region_vars_snapshot);\n+\n+        r\n+    }\n+\n     /// Execute `f`, unroll bindings on panic\n     pub fn try<T, E, F>(&self, f: F) -> Result<T, E> where\n         F: FnOnce(&CombinedSnapshot) -> Result<T, E>"}, {"sha": "d851206f384e316ab116e1ad7a208a12220939e9", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198", "patch": "@@ -14,6 +14,8 @@ use super::check_argument_types;\n use super::check_expr;\n use super::check_method_argument_types;\n use super::err_args;\n+use super::Expectation;\n+use super::expected_types_for_fn_args;\n use super::FnCtxt;\n use super::LvaluePreference;\n use super::method;\n@@ -65,7 +67,8 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             call_expr: &ast::Expr,\n                             callee_expr: &ast::Expr,\n-                            arg_exprs: &[P<ast::Expr>])\n+                            arg_exprs: &[P<ast::Expr>],\n+                            expected: Expectation<'tcx>)\n {\n     check_expr(fcx, callee_expr);\n     let original_callee_ty = fcx.expr_ty(callee_expr);\n@@ -84,15 +87,15 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match result {\n         None => {\n             // this will report an error since original_callee_ty is not a fn\n-            confirm_builtin_call(fcx, call_expr, original_callee_ty, arg_exprs);\n+            confirm_builtin_call(fcx, call_expr, original_callee_ty, arg_exprs, expected);\n         }\n \n         Some(CallStep::Builtin) => {\n-            confirm_builtin_call(fcx, call_expr, callee_ty, arg_exprs);\n+            confirm_builtin_call(fcx, call_expr, callee_ty, arg_exprs, expected);\n         }\n \n         Some(CallStep::Overloaded(method_callee)) => {\n-            confirm_overloaded_call(fcx, call_expr, arg_exprs, method_callee);\n+            confirm_overloaded_call(fcx, call_expr, arg_exprs, method_callee, expected);\n         }\n     }\n }\n@@ -153,7 +156,8 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                  call_expr: &ast::Expr,\n                                  callee_ty: Ty<'tcx>,\n-                                 arg_exprs: &[P<ast::Expr>])\n+                                 arg_exprs: &[P<ast::Expr>],\n+                                 expected: Expectation<'tcx>)\n {\n     let error_fn_sig;\n \n@@ -192,9 +196,15 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         fcx.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n     // Call the generic checker.\n+    let expected_arg_tys = expected_types_for_fn_args(fcx,\n+                                                      call_expr.span,\n+                                                      expected,\n+                                                      fn_sig.output,\n+                                                      fn_sig.inputs.as_slice());\n     check_argument_types(fcx,\n                          call_expr.span,\n                          fn_sig.inputs.as_slice(),\n+                         &expected_arg_tys[],\n                          arg_exprs,\n                          AutorefArgs::No,\n                          fn_sig.variadic,\n@@ -206,15 +216,17 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n fn confirm_overloaded_call<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     call_expr: &ast::Expr,\n                                     arg_exprs: &[P<ast::Expr>],\n-                                    method_callee: ty::MethodCallee<'tcx>)\n+                                    method_callee: ty::MethodCallee<'tcx>,\n+                                    expected: Expectation<'tcx>)\n {\n     let output_type = check_method_argument_types(fcx,\n                                                   call_expr.span,\n                                                   method_callee.ty,\n                                                   call_expr,\n                                                   arg_exprs,\n                                                   AutorefArgs::No,\n-                                                  TupleArgumentsFlag::TupleArguments);\n+                                                  TupleArgumentsFlag::TupleArguments,\n+                                                  expected);\n     let method_call = ty::MethodCall::expr(call_expr.id);\n     fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n     write_call(fcx, call_expr, output_type);"}, {"sha": "5a62bf3f3a8448ffac6dcee149de48e98b3d4520", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 99, "deletions": 16, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198", "patch": "@@ -2559,7 +2559,8 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   iterator_expr,\n                                                   &[],\n                                                   AutorefArgs::No,\n-                                                  DontTupleArguments);\n+                                                  DontTupleArguments,\n+                                                  NoExpectation);\n \n     match method {\n         Some(method) => {\n@@ -2601,7 +2602,8 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          callee_expr: &ast::Expr,\n                                          args_no_rcvr: &[P<ast::Expr>],\n                                          autoref_args: AutorefArgs,\n-                                         tuple_arguments: TupleArgumentsFlag)\n+                                         tuple_arguments: TupleArgumentsFlag,\n+                                         expected: Expectation<'tcx>)\n                                          -> ty::FnOutput<'tcx> {\n     if ty::type_is_error(method_fn_ty) {\n         let err_inputs = err_args(fcx.tcx(), args_no_rcvr.len());\n@@ -2614,6 +2616,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         check_argument_types(fcx,\n                              sp,\n                              &err_inputs[],\n+                             &[],\n                              args_no_rcvr,\n                              autoref_args,\n                              false,\n@@ -2623,9 +2626,15 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         match method_fn_ty.sty {\n             ty::ty_bare_fn(_, ref fty) => {\n                 // HACK(eddyb) ignore self in the definition (see above).\n+                let expected_arg_tys = expected_types_for_fn_args(fcx,\n+                                                                  sp,\n+                                                                  expected,\n+                                                                  fty.sig.0.output,\n+                                                                  &fty.sig.0.inputs[1..]);\n                 check_argument_types(fcx,\n                                      sp,\n                                      &fty.sig.0.inputs[1..],\n+                                     &expected_arg_tys[],\n                                      args_no_rcvr,\n                                      autoref_args,\n                                      fty.sig.0.variadic,\n@@ -2645,6 +2654,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   sp: Span,\n                                   fn_inputs: &[Ty<'tcx>],\n+                                  expected_arg_tys: &[Ty<'tcx>],\n                                   args: &[P<ast::Expr>],\n                                   autoref_args: AutorefArgs,\n                                   variadic: bool,\n@@ -2659,6 +2669,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         1\n     };\n \n+    let mut expected_arg_tys = expected_arg_tys;\n     let expected_arg_count = fn_inputs.len();\n     let formal_tys = if tuple_arguments == TupleArguments {\n         let tuple_type = structurally_resolved_type(fcx, sp, fn_inputs[0]);\n@@ -2671,23 +2682,32 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         if arg_types.len() == 1 {\"\"} else {\"s\"},\n                         args.len(),\n                         if args.len() == 1 {\" was\"} else {\"s were\"});\n+                    expected_arg_tys = &[][];\n                     err_args(fcx.tcx(), args.len())\n                 } else {\n+                    expected_arg_tys = match expected_arg_tys.get(0) {\n+                        Some(&ty) => match ty.sty {\n+                            ty::ty_tup(ref tys) => &**tys,\n+                            _ => &[]\n+                        },\n+                        None => &[]\n+                    };\n                     (*arg_types).clone()\n                 }\n             }\n             _ => {\n                 span_err!(tcx.sess, sp, E0059,\n                     \"cannot use call notation; the first type parameter \\\n                      for the function trait is neither a tuple nor unit\");\n+                expected_arg_tys = &[][];\n                 err_args(fcx.tcx(), args.len())\n             }\n         }\n     } else if expected_arg_count == supplied_arg_count {\n-        fn_inputs.iter().map(|a| *a).collect()\n+        fn_inputs.to_vec()\n     } else if variadic {\n         if supplied_arg_count >= expected_arg_count {\n-            fn_inputs.iter().map(|a| *a).collect()\n+            fn_inputs.to_vec()\n         } else {\n             span_err!(tcx.sess, sp, E0060,\n                 \"this function takes at least {} parameter{} \\\n@@ -2696,6 +2716,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if expected_arg_count == 1 {\"\"} else {\"s\"},\n                 supplied_arg_count,\n                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n+            expected_arg_tys = &[][];\n             err_args(fcx.tcx(), supplied_arg_count)\n         }\n     } else {\n@@ -2705,6 +2726,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if expected_arg_count == 1 {\"\"} else {\"s\"},\n             supplied_arg_count,\n             if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n+        expected_arg_tys = &[][];\n         err_args(fcx.tcx(), supplied_arg_count)\n     };\n \n@@ -2768,7 +2790,25 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     AutorefArgs::No => {}\n                 }\n \n-                check_expr_coercable_to_type(fcx, &**arg, formal_ty);\n+                // The special-cased logic below has three functions:\n+                // 1. Provide as good of an expected type as possible.\n+                let expected = expected_arg_tys.get(i).map(|&ty| {\n+                    Expectation::rvalue_hint(ty)\n+                });\n+\n+                check_expr_with_unifier(fcx, &**arg,\n+                                        expected.unwrap_or(ExpectHasType(formal_ty)),\n+                                        NoPreference, || {\n+                    // 2. Coerce to the most detailed type that could be coerced\n+                    //    to, which is `expected_ty` if `rvalue_hint` returns an\n+                    //    `ExprHasType(expected_ty)`, or the `formal_ty` otherwise.\n+                    let coerce_ty = expected.and_then(|e| e.only_has_type(fcx));\n+                    demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &**arg);\n+\n+                    // 3. Relate the expected type and the formal one,\n+                    //    if the expected type was used for the coercion.\n+                    coerce_ty.map(|ty| demand::suptype(fcx, arg.span, formal_ty, ty));\n+                });\n             }\n         }\n     }\n@@ -3008,6 +3048,45 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n+/// Unifies the return type with the expected type early, for more coercions\n+/// and forward type information on the argument expressions.\n+fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        call_span: Span,\n+                                        expected_ret: Expectation<'tcx>,\n+                                        formal_ret: ty::FnOutput<'tcx>,\n+                                        formal_args: &[Ty<'tcx>])\n+                                        -> Vec<Ty<'tcx>> {\n+    let expected_args = expected_ret.only_has_type(fcx).and_then(|ret_ty| {\n+        if let ty::FnConverging(formal_ret_ty) = formal_ret {\n+            fcx.infcx().commit_regions_if_ok(|| {\n+                // Attempt to apply a subtyping relationship between the formal\n+                // return type (likely containing type variables if the function\n+                // is polymorphic) and the expected return type.\n+                // No argument expectations are produced if unification fails.\n+                let origin = infer::Misc(call_span);\n+                let ures = fcx.infcx().sub_types(false, origin, formal_ret_ty, ret_ty);\n+                // FIXME(#15760) can't use try! here, FromError doesn't default\n+                // to identity so the resulting type is not constrained.\n+                if let Err(e) = ures {\n+                    return Err(e);\n+                }\n+\n+                // Record all the argument types, with the substitutions\n+                // produced from the above subtyping unification.\n+                Ok(formal_args.iter().map(|ty| {\n+                    fcx.infcx().resolve_type_vars_if_possible(ty)\n+                }).collect())\n+            }).ok()\n+        } else {\n+            None\n+        }\n+    }).unwrap_or(vec![]);\n+    debug!(\"expected_types_for_fn_args(formal={} -> {}, expected={} -> {})\",\n+           formal_args.repr(fcx.tcx()), formal_ret.repr(fcx.tcx()),\n+           expected_args.repr(fcx.tcx()), expected_ret.repr(fcx.tcx()));\n+    expected_args\n+}\n+\n /// Invariant:\n /// If an expression has any sub-expressions that result in a type error,\n /// inspecting that expression's type with `ty::type_is_error` will return\n@@ -3029,12 +3108,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n            expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n \n     // Checks a method call.\n-    fn check_method_call(fcx: &FnCtxt,\n-                         expr: &ast::Expr,\n-                         method_name: ast::SpannedIdent,\n-                         args: &[P<ast::Expr>],\n-                         tps: &[P<ast::Ty>],\n-                         lvalue_pref: LvaluePreference) {\n+    fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                   expr: &ast::Expr,\n+                                   method_name: ast::SpannedIdent,\n+                                   args: &[P<ast::Expr>],\n+                                   tps: &[P<ast::Ty>],\n+                                   expected: Expectation<'tcx>,\n+                                   lvalue_pref: LvaluePreference) {\n         let rcvr = &*args[0];\n         check_expr_with_lvalue_pref(fcx, &*rcvr, lvalue_pref);\n \n@@ -3071,7 +3151,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  expr,\n                                                  &args[1..],\n                                                  AutorefArgs::No,\n-                                                 DontTupleArguments);\n+                                                 DontTupleArguments,\n+                                                 expected);\n \n         write_call(fcx, expr, ret_ty);\n     }\n@@ -3182,7 +3263,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   op_ex,\n                                                   args,\n                                                   autoref_args,\n-                                                  DontTupleArguments) {\n+                                                  DontTupleArguments,\n+                                                  NoExpectation) {\n                     ty::FnConverging(result_type) => result_type,\n                     ty::FnDiverging => fcx.tcx().types.err\n                 }\n@@ -3198,7 +3280,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             op_ex,\n                                             args,\n                                             autoref_args,\n-                                            DontTupleArguments);\n+                                            DontTupleArguments,\n+                                            NoExpectation);\n                 fcx.tcx().types.err\n             }\n         }\n@@ -4045,10 +4128,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       ast::ExprCall(ref callee, ref args) => {\n-          callee::check_call(fcx, expr, &**callee, &args[]);\n+          callee::check_call(fcx, expr, &**callee, &args[], expected);\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, &args[], &tps[], lvalue_pref);\n+        check_method_call(fcx, expr, ident, &args[], &tps[], expected, lvalue_pref);\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {"}, {"sha": "f590e6e07283cc208f26e2e63e8aacc22754104d", "filename": "src/test/run-pass/coerce-expect-unsized.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized.rs?ref=e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198", "patch": "@@ -30,4 +30,7 @@ pub fn main() {\n     let _: &Fn(int) -> _ = &{ |x| (x as u8) };\n     let _: &Show = &if true { false } else { true };\n     let _: &Show = &match true { true => 'a', false => 'b' };\n+\n+    let _: Box<[int]> = Box::new([1, 2, 3]);\n+    let _: Box<Fn(int) -> _> = Box::new(|x| (x as u8));\n }"}, {"sha": "eeba9042f7c3fcfbb140ba359eef73364ce06f5b", "filename": "src/test/run-pass/coerce-unify-return.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Ftest%2Frun-pass%2Fcoerce-unify-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198/src%2Ftest%2Frun-pass%2Fcoerce-unify-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-unify-return.rs?ref=e73fbc69cd85ccd7e444929b7b7aa0ae74ee6198", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that coercions unify the expected return type of a polymorphic\n+// function call, instead of leaving the type variables as they were.\n+\n+struct Foo;\n+impl Foo {\n+    fn foo<T>(self, x: T) -> Option<T> { Some(x) }\n+}\n+\n+pub fn main() {\n+    let _: Option<fn()> = Some(main);\n+    let _: Option<fn()> = Foo.foo(main);\n+\n+    // The same two cases, with implicit type variables made explicit.\n+    let _: Option<fn()> = Some::<_>(main);\n+    let _: Option<fn()> = Foo.foo::<_>(main);\n+}"}]}