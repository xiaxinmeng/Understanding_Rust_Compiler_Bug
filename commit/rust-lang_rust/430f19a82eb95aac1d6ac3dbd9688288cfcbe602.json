{"sha": "430f19a82eb95aac1d6ac3dbd9688288cfcbe602", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMGYxOWE4MmViOTVhYWMxZDZhYzNkYmQ5Njg4Mjg4Y2ZjYmU2MDI=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-08-02T18:03:48Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-08-02T18:03:48Z"}, "message": "Document unsafety in library/core/src/slice/mod.rs", "tree": {"sha": "0442b1331a62e45f741f596f1f5eaa6439a9d53e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0442b1331a62e45f741f596f1f5eaa6439a9d53e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/430f19a82eb95aac1d6ac3dbd9688288cfcbe602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/430f19a82eb95aac1d6ac3dbd9688288cfcbe602", "html_url": "https://github.com/rust-lang/rust/commit/430f19a82eb95aac1d6ac3dbd9688288cfcbe602", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/430f19a82eb95aac1d6ac3dbd9688288cfcbe602/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8876ae2c11f341565059b900eeae1254a9accf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8876ae2c11f341565059b900eeae1254a9accf1", "html_url": "https://github.com/rust-lang/rust/commit/e8876ae2c11f341565059b900eeae1254a9accf1"}], "stats": {"total": 129, "additions": 119, "deletions": 10}, "files": [{"sha": "3af8a3e46c91c55aef14814522c319459bad5896", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 119, "deletions": 10, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/430f19a82eb95aac1d6ac3dbd9688288cfcbe602/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430f19a82eb95aac1d6ac3dbd9688288cfcbe602/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=430f19a82eb95aac1d6ac3dbd9688288cfcbe602", "patch": "@@ -1,5 +1,4 @@\n // ignore-tidy-filelength\n-// ignore-tidy-undocumented-unsafe\n \n //! Slice management and manipulation.\n //!\n@@ -70,6 +69,8 @@ impl<T> [T] {\n     #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn len(&self) -> usize {\n+        // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n+        // Only `std` can make this guarantee.\n         unsafe { crate::ptr::Repr { rust: self }.raw.len }\n     }\n \n@@ -443,7 +444,8 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n     #[inline]\n     pub fn as_ptr_range(&self) -> Range<*const T> {\n-        // The `add` here is safe, because:\n+        let start = self.as_ptr();\n+        // SAFETY: The `add` here is safe, because:\n         //\n         //   - Both pointers are part of the same object, as pointing directly\n         //     past the object also counts.\n@@ -460,7 +462,6 @@ impl<T> [T] {\n         //     the end of the address space.\n         //\n         // See the documentation of pointer::add.\n-        let start = self.as_ptr();\n         let end = unsafe { start.add(self.len()) };\n         start..end\n     }\n@@ -484,8 +485,8 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n     #[inline]\n     pub fn as_mut_ptr_range(&mut self) -> Range<*mut T> {\n-        // See as_ptr_range() above for why `add` here is safe.\n         let start = self.as_mut_ptr();\n+        // SAFETY: See as_ptr_range() above for why `add` here is safe.\n         let end = unsafe { start.add(self.len()) };\n         start..end\n     }\n@@ -511,6 +512,10 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn swap(&mut self, a: usize, b: usize) {\n+        // SAFETY: `pa` and `pb` have been created from safe mutable references and refer\n+        // to elements in the slice and therefore are guaranteed to be valid and aligned.\n+        // Note that accessing the elements behind `a` and `b` is checked and will\n+        // panic when out of bounds.\n         unsafe {\n             // Can't take two mutable loans from one vector, so instead just cast\n             // them to their raw pointers to do the swap\n@@ -554,6 +559,17 @@ impl<T> [T] {\n             // Use the llvm.bswap intrinsic to reverse u8s in a usize\n             let chunk = mem::size_of::<usize>();\n             while i + chunk - 1 < ln / 2 {\n+                // SAFETY: An unaligned u32 can be read from `i` if `i + 1 < ln`\n+                // (and obviously `i < ln`), because each element is 2 bytes and\n+                // we're reading 4.\n+                // `i + chunk - 1 < ln / 2` # while condition\n+                // `i + 2 - 1 < ln / 2`\n+                // `i + 1 < ln / 2`\n+                // Since it's less than the length divided by 2, then it must be\n+                // in bounds.\n+                //\n+                // Note: when updating this comment, update the others in the\n+                // function too.\n                 unsafe {\n                     let pa: *mut T = self.get_unchecked_mut(i);\n                     let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n@@ -570,6 +586,17 @@ impl<T> [T] {\n             // Use rotate-by-16 to reverse u16s in a u32\n             let chunk = mem::size_of::<u32>() / 2;\n             while i + chunk - 1 < ln / 2 {\n+                // SAFETY: An unaligned u32 can be read from `i` if `i + 1 < ln`\n+                // (and obviously `i < ln`), because each element is 2 bytes and\n+                // we're reading 4.\n+                // `i + chunk - 1 < ln / 2` # while condition\n+                // `i + 2 - 1 < ln / 2`\n+                // `i + 1 < ln / 2`\n+                // Since it's less than the length divided by 2, then it must be\n+                // in bounds.\n+                //\n+                // Note: when updating this comment, update the others in the\n+                // function too.\n                 unsafe {\n                     let pa: *mut T = self.get_unchecked_mut(i);\n                     let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n@@ -583,8 +610,13 @@ impl<T> [T] {\n         }\n \n         while i < ln / 2 {\n-            // Unsafe swap to avoid the bounds check in safe swap.\n+            // SAFETY: `i` is inferior to half the length of the slice so\n+            // accessing `i` and `ln - i - 1` is safe (`i` starts at 0 and\n+            // will not go further than `ln / 2 - 1`).\n+            // The resulting pointers `pa` and `pb` are therefore valid and\n+            // aligned, and can be read from and written to.\n             unsafe {\n+                // Unsafe swap to avoid the bounds check in safe swap.\n                 let pa: *mut T = self.get_unchecked_mut(i);\n                 let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n                 ptr::swap(pa, pb);\n@@ -609,6 +641,9 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter(&self) -> Iter<'_, T> {\n+        // SAFETY: adding `self.len()` to the starting pointer gives a pointer\n+        // at the end of `self`, which fulfills the expectations of `ptr.add()`\n+        // and `NonNull::new_unchecked()`.\n         unsafe {\n             let ptr = self.as_ptr();\n             assume(!ptr.is_null());\n@@ -637,6 +672,9 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n+        // SAFETY: adding `self.len()` to the starting pointer gives a pointer\n+        // at the end of `self`, which fulfills the expectations of `ptr.add()`\n+        // and `NonNull::new_unchecked()`.\n         unsafe {\n             let ptr = self.as_mut_ptr();\n             assume(!ptr.is_null());\n@@ -1107,6 +1145,8 @@ impl<T> [T] {\n         let len = self.len();\n         let ptr = self.as_mut_ptr();\n \n+        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n+        // fulfills the requirements of `from_raw_parts_mut`.\n         unsafe {\n             assert!(mid <= len);\n \n@@ -1655,14 +1695,14 @@ impl<T> [T] {\n         while size > 1 {\n             let half = size / 2;\n             let mid = base + half;\n-            // mid is always in [0, size), that means mid is >= 0 and < size.\n+            // SAFETY:\n             // mid >= 0: by definition\n             // mid < size: mid = size / 2 + size / 4 + size / 8 ...\n             let cmp = f(unsafe { s.get_unchecked(mid) });\n             base = if cmp == Greater { base } else { mid };\n             size -= half;\n         }\n-        // base is always in [0, size) because base <= mid.\n+        // SAFETY: base is always in [0, size) because base <= mid.\n         let cmp = f(unsafe { s.get_unchecked(base) });\n         if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }\n     }\n@@ -2120,6 +2160,16 @@ impl<T> [T] {\n         let mut next_read: usize = 1;\n         let mut next_write: usize = 1;\n \n+        // SAFETY: the `while` condition guarantees `next_read` and `next_write`\n+        // are less than `len`, thus are inside `self`. `prev_ptr_write` points to\n+        // one element before `ptr_write`, but `next_write` starts at 1, so\n+        // `prev_ptr_write` is never less than 0 and is inside the slice.\n+        // This fulfils the requirements for dereferencing `ptr_read`, `prev_ptr_write`\n+        // and `ptr_write`, and for using `ptr.add(next_read)`, `ptr.add(next_write - 1)`\n+        // and `prev_ptr_write.offset(1)`.\n+        //\n+        // `next_write` is also incremented at most once per loop at most meaning\n+        // no element is skipped when it may need to be swapped.\n         unsafe {\n             // Avoid bounds checks by using raw pointers.\n             while next_read < len {\n@@ -2204,6 +2254,8 @@ impl<T> [T] {\n         assert!(mid <= self.len());\n         let k = self.len() - mid;\n \n+        // SAFETY: `[mid - mid;mid+k]` corresponds to the entire\n+        // `self` slice, thus is valid for reads and writes.\n         unsafe {\n             let p = self.as_mut_ptr();\n             rotate::ptr_rotate(mid, p.add(mid), k);\n@@ -2245,6 +2297,8 @@ impl<T> [T] {\n         assert!(k <= self.len());\n         let mid = self.len() - k;\n \n+        // SAFETY: `[mid - mid;mid+k]` corresponds to the entire\n+        // `self` slice, thus is valid for reads and writes.\n         unsafe {\n             let p = self.as_mut_ptr();\n             rotate::ptr_rotate(mid, p.add(mid), k);\n@@ -2407,6 +2461,9 @@ impl<T> [T] {\n         T: Copy,\n     {\n         assert_eq!(self.len(), src.len(), \"destination and source slices have different lengths\");\n+        // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n+        // checked to have the same length. The slices cannot overlap because\n+        // mutable references are exclusive.\n         unsafe {\n             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());\n         }\n@@ -2460,6 +2517,7 @@ impl<T> [T] {\n         assert!(src_end <= self.len(), \"src is out of bounds\");\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n+        // SAFETY: the conditions for `ptr::copy` have all been checked above.\n         unsafe {\n             ptr::copy(self.as_ptr().add(src_start), self.as_mut_ptr().add(dest), count);\n         }\n@@ -2515,6 +2573,9 @@ impl<T> [T] {\n     #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n     pub fn swap_with_slice(&mut self, other: &mut [T]) {\n         assert!(self.len() == other.len(), \"destination and source slices have different lengths\");\n+        // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n+        // checked to have the same length. The slices cannot overlap because\n+        // mutable references are exclusive.\n         unsafe {\n             ptr::swap_nonoverlapping(self.as_mut_ptr(), other.as_mut_ptr(), self.len());\n         }\n@@ -2546,6 +2607,8 @@ impl<T> [T] {\n             // iterative stein\u2019s algorithm\n             // We should still make this `const fn` (and revert to recursive algorithm if we do)\n             // because relying on llvm to consteval all this is\u2026 well, it makes me uncomfortable.\n+\n+            // SAFETY: `a` and `b` are checked to be non-zero values.\n             let (ctz_a, mut ctz_b) = unsafe {\n                 if a == 0 {\n                     return b;\n@@ -2565,6 +2628,7 @@ impl<T> [T] {\n                     mem::swap(&mut a, &mut b);\n                 }\n                 b = b - a;\n+                // SAFETY: `b` is checked to be non-zero.\n                 unsafe {\n                     if b == 0 {\n                         break;\n@@ -3126,11 +3190,13 @@ unsafe impl<T> SliceIndex<[T]> for usize {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&T> {\n+        // SAFETY: `self` is checked to be in bounds.\n         if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n+        // SAFETY: `self` is checked to be in bounds.\n         if self < slice.len() { unsafe { Some(&mut *self.get_unchecked_mut(slice)) } } else { None }\n     }\n \n@@ -3171,6 +3237,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n             unsafe { Some(&*self.get_unchecked(slice)) }\n         }\n     }\n@@ -3180,6 +3247,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n             unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n         }\n     }\n@@ -3208,6 +3276,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_end_index_len_fail(self.end, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &*self.get_unchecked(slice) }\n     }\n \n@@ -3218,6 +3287,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_end_index_len_fail(self.end, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &mut *self.get_unchecked_mut(slice) }\n     }\n }\n@@ -3290,6 +3360,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n         if self.start > slice.len() {\n             slice_start_index_len_fail(self.start, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &*self.get_unchecked(slice) }\n     }\n \n@@ -3298,6 +3369,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n         if self.start > slice.len() {\n             slice_start_index_len_fail(self.start, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &mut *self.get_unchecked_mut(slice) }\n     }\n }\n@@ -3543,6 +3615,9 @@ macro_rules! iterator {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n             fn make_slice(&self) -> &'a [T] {\n+                // SAFETY: the iterator was created from a slice with pointer\n+                // `self.ptr` and length `len!(self)`. This guarantees that all\n+                // the prerequisites for `from_raw_parts` are fulfilled.\n                 unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n             }\n \n@@ -3601,6 +3676,11 @@ macro_rules! iterator {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n+\n+                // SAFETY: `assume` calls are safe since a slice's start pointer\n+                // must be non-null, and slices over non-ZSTs must also have a\n+                // non-null end pointer. The call to `next_unchecked!` is safe\n+                // since we check if the iterator is empty first.\n                 unsafe {\n                     assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n@@ -3634,14 +3714,14 @@ macro_rules! iterator {\n                         // could be (due to wrapping).\n                         self.end = self.ptr.as_ptr();\n                     } else {\n+                        // SAFETY: end can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n                         unsafe {\n-                            // End can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n                             self.ptr = NonNull::new_unchecked(self.end as *mut T);\n                         }\n                     }\n                     return None;\n                 }\n-                // We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n+                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                 unsafe {\n                     self.post_inc_start(n as isize);\n                     Some(next_unchecked!(self))\n@@ -3748,6 +3828,8 @@ macro_rules! iterator {\n                 let mut i = 0;\n                 while let Some(x) = self.next() {\n                     if predicate(x) {\n+                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n+                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                         unsafe { assume(i < n) };\n                         return Some(i);\n                     }\n@@ -3769,6 +3851,8 @@ macro_rules! iterator {\n                 while let Some(x) = self.next_back() {\n                     i -= 1;\n                     if predicate(x) {\n+                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n+                        // and is only decreasing.\n                         unsafe { assume(i < n) };\n                         return Some(i);\n                     }\n@@ -3784,6 +3868,11 @@ macro_rules! iterator {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n+\n+                // SAFETY: `assume` calls are safe since a slice's start pointer must be non-null,\n+                // and slices over non-ZSTs must also have a non-null end pointer.\n+                // The call to `next_back_unchecked!` is safe since we check if the iterator is\n+                // empty first.\n                 unsafe {\n                     assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n@@ -3804,7 +3893,7 @@ macro_rules! iterator {\n                     self.end = self.ptr.as_ptr();\n                     return None;\n                 }\n-                // We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n+                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                 unsafe {\n                     self.pre_dec_end(n as isize);\n                     Some(next_back_unchecked!(self))\n@@ -3999,6 +4088,9 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n+        // SAFETY: the iterator was created from a mutable slice with pointer\n+        // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites\n+        // for `from_raw_parts_mut` are fulfilled.\n         unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }\n     }\n \n@@ -6288,12 +6380,20 @@ pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T]\n /// Converts a reference to T into a slice of length 1 (without copying).\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n pub fn from_ref<T>(s: &T) -> &[T] {\n+    // SAFETY: a reference is guaranteed to be valid for reads. The returned\n+    // reference cannot be mutated as it is an immutable reference.\n+    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n+    // Thus the call to `from_raw_parts` is safe.\n     unsafe { from_raw_parts(s, 1) }\n }\n \n /// Converts a reference to T into a slice of length 1 (without copying).\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n pub fn from_mut<T>(s: &mut T) -> &mut [T] {\n+    // SAFETY: a mutable reference is guaranteed to be valid for writes.\n+    // The reference cannot be accessed by another pointer as it is an mutable reference.\n+    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n+    // Thus the call to `from_raw_parts_mut` is safe.\n     unsafe { from_raw_parts_mut(s, 1) }\n }\n \n@@ -6414,6 +6514,8 @@ where\n         if self.as_ptr().guaranteed_eq(other.as_ptr()) {\n             return true;\n         }\n+        // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.\n+        // The two slices have been checked to have the same size above.\n         unsafe {\n             let size = mem::size_of_val(self);\n             memcmp(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0\n@@ -6516,6 +6618,9 @@ impl SliceOrd for u8 {\n     #[inline]\n     fn compare(left: &[Self], right: &[Self]) -> Ordering {\n         let order =\n+            // SAFETY: `left` and `right` are references and are thus guaranteed to be valid.\n+            // We use the minimum of both lengths which guarantees that both regions are\n+            // valid for reads in that interval.\n             unsafe { memcmp(left.as_ptr(), right.as_ptr(), cmp::min(left.len(), right.len())) };\n         if order == 0 {\n             left.len().cmp(&right.len())\n@@ -6590,6 +6695,10 @@ impl SliceContains for u8 {\n impl SliceContains for i8 {\n     fn slice_contains(&self, x: &[Self]) -> bool {\n         let byte = *self as u8;\n+        // SAFETY: `i8` and `u8` have the same memory layout, thus casting `x.as_ptr()`\n+        // as `*const u8` is safe. The `x.as_ptr()` comes from a reference and is thus guaranteed\n+        // to be valid for reads for the length of the slice `x.len()`, which cannot be larger\n+        // than `isize::MAX`. The returned slice is never mutated.\n         let bytes: &[u8] = unsafe { from_raw_parts(x.as_ptr() as *const u8, x.len()) };\n         memchr::memchr(byte, bytes).is_some()\n     }"}]}