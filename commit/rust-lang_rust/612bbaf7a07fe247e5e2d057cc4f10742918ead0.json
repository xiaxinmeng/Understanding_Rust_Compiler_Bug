{"sha": "612bbaf7a07fe247e5e2d057cc4f10742918ead0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMmJiYWY3YTA3ZmUyNDdlNWUyZDA1N2NjNGYxMDc0MjkxOGVhZDA=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2014-06-17T15:58:13Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2014-06-17T21:49:53Z"}, "message": "Refactor backslash-escape parsing to share similar code.\n\nMove into a new syntax::parse::lexer::StringReader method the code\nthat was almost duplicated for parsing backslash-escapes in\nbyte, byte string, char, and string literals.", "tree": {"sha": "c2f82b241b7bde0f88039c7d116335a9c17c9969", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2f82b241b7bde0f88039c7d116335a9c17c9969"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/612bbaf7a07fe247e5e2d057cc4f10742918ead0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/612bbaf7a07fe247e5e2d057cc4f10742918ead0", "html_url": "https://github.com/rust-lang/rust/commit/612bbaf7a07fe247e5e2d057cc4f10742918ead0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/612bbaf7a07fe247e5e2d057cc4f10742918ead0/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a52a8a8b8079de795dabdd35985f9f663aa0b5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a52a8a8b8079de795dabdd35985f9f663aa0b5d", "html_url": "https://github.com/rust-lang/rust/commit/3a52a8a8b8079de795dabdd35985f9f663aa0b5d"}], "stats": {"total": 220, "additions": 69, "deletions": 151}, "files": [{"sha": "f67b77d64dda5d841ae52599dc0056591fd17d30", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 69, "deletions": 151, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/612bbaf7a07fe247e5e2d057cc4f10742918ead0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612bbaf7a07fe247e5e2d057cc4f10742918ead0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=612bbaf7a07fe247e5e2d057cc4f10742918ead0", "patch": "@@ -636,6 +636,67 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n+    /// Scan for a single (possibly escaped) byte or char\n+    /// in a byte, (non-raw) byte string, char, or (non-raw) string literal.\n+    /// `start` is the position of `first_source_char`, which is already consumed.\n+    fn scan_char_or_byte(&mut self, start: BytePos, first_source_char: char,\n+                         ascii_only: bool, delim: char) -> Option<char> {\n+        match first_source_char {\n+            '\\\\' => {\n+                // '\\X' for some X must be a character constant:\n+                let escaped = self.curr;\n+                let escaped_pos = self.last_pos;\n+                self.bump();\n+                match escaped {\n+                    None => {},  // EOF here is an error that will be checked later.\n+                    Some(e) => {\n+                        return Some(match e {\n+                            'n' => '\\n',\n+                            'r' => '\\r',\n+                            't' => '\\t',\n+                            '\\\\' => '\\\\',\n+                            '\\'' => '\\'',\n+                            '\"' => '\"',\n+                            '0' => '\\x00',\n+                            'x' => self.scan_numeric_escape(2u, delim),\n+                            'u' if !ascii_only => self.scan_numeric_escape(4u, delim),\n+                            'U' if !ascii_only => self.scan_numeric_escape(8u, delim),\n+                            '\\n' if delim == '\"' => {\n+                                self.consume_whitespace();\n+                                return None\n+                            },\n+                            c => {\n+                                let last_pos = self.last_pos;\n+                                self.err_span_char(\n+                                    escaped_pos, last_pos,\n+                                    if ascii_only { \"unknown byte escape\" }\n+                                    else { \"unknown character escape\" },\n+                                    c);\n+                                c\n+                            }\n+                        })\n+                    }\n+                }\n+            }\n+            '\\t' | '\\n' | '\\r' | '\\'' if delim == '\\'' => {\n+                let last_pos = self.last_pos;\n+                self.err_span_char(\n+                    start, last_pos,\n+                    if ascii_only { \"byte constant must be escaped\" }\n+                    else { \"character constant must be escaped\" },\n+                    first_source_char);\n+            }\n+            _ => if ascii_only && first_source_char > '\\x7F' {\n+                let last_pos = self.last_pos;\n+                self.err_span_char(\n+                    start, last_pos,\n+                    \"byte constant must be ASCII. \\\n+                     Use a \\\\xHH escape for a non-ASCII byte\", first_source_char);\n+            }\n+        }\n+        Some(first_source_char)\n+    }\n+\n     fn binop(&mut self, op: token::BinOp) -> token::Token {\n         self.bump();\n         if self.curr_is('=') {\n@@ -810,43 +871,7 @@ impl<'a> StringReader<'a> {\n             }\n \n             // Otherwise it is a character constant:\n-            match c2 {\n-                '\\\\' => {\n-                    // '\\X' for some X must be a character constant:\n-                    let escaped = self.curr;\n-                    let escaped_pos = self.last_pos;\n-                    self.bump();\n-                    match escaped {\n-                        None => {}\n-                        Some(e) => {\n-                            c2 = match e {\n-                                'n' => '\\n',\n-                                'r' => '\\r',\n-                                't' => '\\t',\n-                                '\\\\' => '\\\\',\n-                                '\\'' => '\\'',\n-                                '\"' => '\"',\n-                                '0' => '\\x00',\n-                                'x' => self.scan_numeric_escape(2u, '\\''),\n-                                'u' => self.scan_numeric_escape(4u, '\\''),\n-                                'U' => self.scan_numeric_escape(8u, '\\''),\n-                                c2 => {\n-                                    let last_bpos = self.last_pos;\n-                                    self.err_span_char(escaped_pos, last_bpos,\n-                                                         \"unknown character escape\", c2);\n-                                    c2\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                '\\t' | '\\n' | '\\r' | '\\'' => {\n-                    let last_bpos = self.last_pos;\n-                    self.err_span_char( start, last_bpos,\n-                        \"character constant must be escaped\", c2);\n-                }\n-                _ => {}\n-            }\n+            c2 = self.scan_char_or_byte(start, c2, /* ascii_only = */ false, '\\'').unwrap();\n             if !self.curr_is('\\'') {\n                 let last_bpos = self.last_pos;\n                 self.fatal_span_verbose(\n@@ -876,44 +901,7 @@ impl<'a> StringReader<'a> {\n                 let mut c2 = self_.curr.unwrap_or('\\x00');\n                 self_.bump();\n \n-                match c2 {\n-                    '\\\\' => {\n-                        // '\\X' for some X must be a character constant:\n-                        let escaped = self_.curr;\n-                        let escaped_pos = self_.last_pos;\n-                        self_.bump();\n-                        match escaped {\n-                            None => {}\n-                            Some(e) => {\n-                                c2 = match e {\n-                                    'n' => '\\n',\n-                                    'r' => '\\r',\n-                                    't' => '\\t',\n-                                    '\\\\' => '\\\\',\n-                                    '\\'' => '\\'',\n-                                    '\"' => '\"',\n-                                    '0' => '\\x00',\n-                                    'x' => self_.scan_numeric_escape(2u, '\\''),\n-                                    c2 => {\n-                                        self_.err_span_char(\n-                                            escaped_pos, self_.last_pos,\n-                                            \"unknown byte escape\", c2);\n-                                        c2\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                    '\\t' | '\\n' | '\\r' | '\\'' => {\n-                        self_.err_span_char( start, self_.last_pos,\n-                            \"byte constant must be escaped\", c2);\n-                    }\n-                    _ => if c2 > '\\x7F' {\n-                        self_.err_span_char( start, self_.last_pos,\n-                            \"byte constant must be ASCII. \\\n-                             Use a \\\\xHH escape for a non-ASCII byte\", c2);\n-                    }\n-                }\n+                c2 = self_.scan_char_or_byte(start, c2, /* ascii_only = */ true, '\\'').unwrap();\n                 if !self_.curr_is('\\'') {\n                     // Byte offsetting here is okay because the\n                     // character before position `start` are an\n@@ -936,46 +924,11 @@ impl<'a> StringReader<'a> {\n                                          \"unterminated double quote byte string\");\n                     }\n \n+                    let ch_start = self_.last_pos;\n                     let ch = self_.curr.unwrap();\n                     self_.bump();\n-                    match ch {\n-                      '\\\\' => {\n-                        if self_.is_eof() {\n-                            self_.fatal_span(start, self_.last_pos,\n-                                             \"unterminated double quote byte string\");\n-                        }\n-\n-                        let escaped = self_.curr.unwrap();\n-                        let escaped_pos = self_.last_pos;\n-                        self_.bump();\n-                        match escaped {\n-                          'n' => value.push('\\n' as u8),\n-                          'r' => value.push('\\r' as u8),\n-                          't' => value.push('\\t' as u8),\n-                          '\\\\' => value.push('\\\\' as u8),\n-                          '\\'' => value.push('\\'' as u8),\n-                          '\"' => value.push('\"' as u8),\n-                          '\\n' => self_.consume_whitespace(),\n-                          '0' => value.push(0),\n-                          'x' => {\n-                            value.push(self_.scan_numeric_escape(2u, '\"') as u8);\n-                          }\n-                          c2 => {\n-                            self_.err_span_char(escaped_pos, self_.last_pos,\n-                                                \"unknown byte string escape\", c2);\n-                          }\n-                        }\n-                      }\n-                      _ => {\n-                        if ch <= '\\x7F' {\n-                            value.push(ch as u8)\n-                        } else {\n-                            self_.err_span_char(self_.last_pos, self_.last_pos,\n-                                \"byte string must be ASCII. \\\n-                                 Use a \\\\xHH escape for a non-ASCII byte\", ch);\n-                        }\n-                      }\n-                    }\n+                    self_.scan_char_or_byte(ch_start, ch, /* ascii_only = */ true, '\"')\n+                        .map(|ch| value.push(ch as u8));\n                 }\n                 self_.bump();\n                 return token::LIT_BINARY(Rc::new(value));\n@@ -1039,46 +992,11 @@ impl<'a> StringReader<'a> {\n                     self.fatal_span(start_bpos, last_bpos, \"unterminated double quote string\");\n                 }\n \n+                let ch_start = self.last_pos;\n                 let ch = self.curr.unwrap();\n                 self.bump();\n-                match ch {\n-                  '\\\\' => {\n-                    if self.is_eof() {\n-                        let last_bpos = self.last_pos;\n-                        self.fatal_span(start_bpos, last_bpos,\n-                               \"unterminated double quote string\");\n-                    }\n-\n-                    let escaped = self.curr.unwrap();\n-                    let escaped_pos = self.last_pos;\n-                    self.bump();\n-                    match escaped {\n-                      'n' => accum_str.push_char('\\n'),\n-                      'r' => accum_str.push_char('\\r'),\n-                      't' => accum_str.push_char('\\t'),\n-                      '\\\\' => accum_str.push_char('\\\\'),\n-                      '\\'' => accum_str.push_char('\\''),\n-                      '\"' => accum_str.push_char('\"'),\n-                      '\\n' => self.consume_whitespace(),\n-                      '0' => accum_str.push_char('\\x00'),\n-                      'x' => {\n-                        accum_str.push_char(self.scan_numeric_escape(2u, '\"'));\n-                      }\n-                      'u' => {\n-                        accum_str.push_char(self.scan_numeric_escape(4u, '\"'));\n-                      }\n-                      'U' => {\n-                        accum_str.push_char(self.scan_numeric_escape(8u, '\"'));\n-                      }\n-                      c2 => {\n-                        let last_bpos = self.last_pos;\n-                        self.err_span_char(escaped_pos, last_bpos,\n-                                        \"unknown string escape\", c2);\n-                      }\n-                    }\n-                  }\n-                  _ => accum_str.push_char(ch)\n-                }\n+                self.scan_char_or_byte(ch_start, ch, /* ascii_only = */ false, '\"')\n+                    .map(|ch| accum_str.push_char(ch));\n             }\n             self.bump();\n             return token::LIT_STR(str_to_ident(accum_str.as_slice()));"}]}