{"sha": "7614ea42fc2df3a9df53251ae0a586a692ccafba", "node_id": "C_kwDOAAsO6NoAKDc2MTRlYTQyZmMyZGYzYTlkZjUzMjUxYWUwYTU4NmE2OTJjY2FmYmE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-12T15:04:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-12T15:04:33Z"}, "message": "Rollup merge of #110210 - nnethercote:DescriptionCtx-cleanups, r=davidtwco\n\n`DescriptionCtx` cleanups\n\nBest reviewed one commit at a time.\n\nr? `@davidtwco`", "tree": {"sha": "3e316aa9e3eba8514461b193df749141f6b054db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e316aa9e3eba8514461b193df749141f6b054db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7614ea42fc2df3a9df53251ae0a586a692ccafba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkNsiBCRBK7hj4Ov3rIwAA6zQIAEO7sryEPnr5nsWPrwR5r5op\nGI+ccxyDO7Y66Ecsmj2GBLA9HUXNB1QtyL0MkNTTk/TxjqzVLCZK9BQbXeD6xISI\nmBajCoyv5RvAGGJHzTlmll+gOte8Zk0Wh0gCIAmfhsYrAgEMNMQ9dnK8SGLN9+XN\nKlxhLuAZSZwQvU7vDlnMMrTL9ytXDkIwBJMqToCCZ1bP5x0JrOfecMMqP6TxwnY1\n0EWaxhzf6LnGDZhSc1QDlxTZPjRRcIU90+l4dlkLaACP08bAp89PPbPtzcDvHCq1\na5LZB1R/zPR+HH/HRB1obxCVgjYZZ9XiYF5JxVnnp1ySiHmQdE97c7gTMJhU9/8=\n=rred\n-----END PGP SIGNATURE-----\n", "payload": "tree 3e316aa9e3eba8514461b193df749141f6b054db\nparent 49769260a36f99af9933a2b8f1ea11e071ffac4b\nparent 76d0c6f5186826d57d80bb5f2435454837c8a449\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1681311873 +0200\ncommitter GitHub <noreply@github.com> 1681311873 +0200\n\nRollup merge of #110210 - nnethercote:DescriptionCtx-cleanups, r=davidtwco\n\n`DescriptionCtx` cleanups\n\nBest reviewed one commit at a time.\n\nr? `@davidtwco`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7614ea42fc2df3a9df53251ae0a586a692ccafba", "html_url": "https://github.com/rust-lang/rust/commit/7614ea42fc2df3a9df53251ae0a586a692ccafba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7614ea42fc2df3a9df53251ae0a586a692ccafba/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49769260a36f99af9933a2b8f1ea11e071ffac4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/49769260a36f99af9933a2b8f1ea11e071ffac4b", "html_url": "https://github.com/rust-lang/rust/commit/49769260a36f99af9933a2b8f1ea11e071ffac4b"}, {"sha": "76d0c6f5186826d57d80bb5f2435454837c8a449", "url": "https://api.github.com/repos/rust-lang/rust/commits/76d0c6f5186826d57d80bb5f2435454837c8a449", "html_url": "https://github.com/rust-lang/rust/commit/76d0c6f5186826d57d80bb5f2435454837c8a449"}], "stats": {"total": 198, "additions": 79, "deletions": 119}, "files": [{"sha": "1ae53182046f31fc2bf2224260c652498148cd13", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7614ea42fc2df3a9df53251ae0a586a692ccafba/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7614ea42fc2df3a9df53251ae0a586a692ccafba/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=7614ea42fc2df3a9df53251ae0a586a692ccafba", "patch": "@@ -163,7 +163,6 @@ infer_region_explanation = {$pref_kind ->\n     [as_defined] the lifetime `{$desc_arg}` as defined here\n     [as_defined_anon] the anonymous lifetime as defined here\n     [defined_here] the anonymous lifetime defined here\n-    [anon_num_here] the anonymous lifetime #{$desc_num_arg} defined here\n     [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n }{$suff_kind ->\n     *[should_not_happen] [{$suff_kind}]"}, {"sha": "7328241dfbcaf3a48cdd2f05dd637cee16537c50", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 47, "deletions": 76, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/7614ea42fc2df3a9df53251ae0a586a692ccafba/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7614ea42fc2df3a9df53251ae0a586a692ccafba/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=7614ea42fc2df3a9df53251ae0a586a692ccafba", "patch": "@@ -4,12 +4,10 @@ use rustc_errors::{self, AddToDiagnostic, Diagnostic, IntoDiagnosticArg, Subdiag\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{symbol::kw, Span};\n \n-#[derive(Default)]\n struct DescriptionCtx<'a> {\n     span: Option<Span>,\n     kind: &'a str,\n     arg: String,\n-    num_arg: u32,\n }\n \n impl<'a> DescriptionCtx<'a> {\n@@ -18,102 +16,74 @@ impl<'a> DescriptionCtx<'a> {\n         region: ty::Region<'tcx>,\n         alt_span: Option<Span>,\n     ) -> Option<Self> {\n-        let mut me = DescriptionCtx::default();\n-        me.span = alt_span;\n-        match *region {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                return Self::from_early_bound_and_free_regions(tcx, region);\n-            }\n-            ty::ReStatic => {\n-                me.kind = \"restatic\";\n-            }\n-\n-            ty::RePlaceholder(_) => return None,\n-\n-            ty::ReError(_) => return None,\n-\n-            // FIXME(#13998) RePlaceholder should probably print like\n-            // ReFree rather than dumping Debug output on the user.\n-            //\n-            // We shouldn't really be having unification failures with ReVar\n-            // and ReLateBound though.\n-            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n-                me.kind = \"revar\";\n-                me.arg = format!(\"{:?}\", region);\n-            }\n-        };\n-        Some(me)\n-    }\n-\n-    fn from_early_bound_and_free_regions<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) -> Option<Self> {\n-        let mut me = DescriptionCtx::default();\n-        let scope = region.free_region_binding_scope(tcx).expect_local();\n-        match *region {\n+        let (span, kind, arg) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = tcx.def_span(scope);\n-                if let Some(param) =\n+                let scope = region.free_region_binding_scope(tcx).expect_local();\n+                let span = if let Some(param) =\n                     tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n                 {\n-                    sp = param.span;\n-                }\n-                if br.has_name() {\n-                    me.kind = \"as_defined\";\n-                    me.arg = br.name.to_string();\n+                    param.span\n                 } else {\n-                    me.kind = \"as_defined_anon\";\n+                    tcx.def_span(scope)\n                 };\n-                me.span = Some(sp)\n+                if br.has_name() {\n+                    (Some(span), \"as_defined\", br.name.to_string())\n+                } else {\n+                    (Some(span), \"as_defined_anon\", String::new())\n+                }\n             }\n             ty::ReFree(ref fr) => {\n                 if !fr.bound_region.is_named()\n                     && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n                 {\n-                    me.kind = \"defined_here\";\n-                    me.span = Some(ty.span);\n+                    (Some(ty.span), \"defined_here\", String::new())\n                 } else {\n+                    let scope = region.free_region_binding_scope(tcx).expect_local();\n                     match fr.bound_region {\n                         ty::BoundRegionKind::BrNamed(_, name) => {\n-                            let mut sp = tcx.def_span(scope);\n-                            if let Some(param) =\n-                                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                            let span = if let Some(param) = tcx\n+                                .hir()\n+                                .get_generics(scope)\n+                                .and_then(|generics| generics.get_named(name))\n                             {\n-                                sp = param.span;\n-                            }\n-                            if name == kw::UnderscoreLifetime {\n-                                me.kind = \"as_defined_anon\";\n+                                param.span\n                             } else {\n-                                me.kind = \"as_defined\";\n-                                me.arg = name.to_string();\n+                                tcx.def_span(scope)\n                             };\n-                            me.span = Some(sp);\n+                            if name == kw::UnderscoreLifetime {\n+                                (Some(span), \"as_defined_anon\", String::new())\n+                            } else {\n+                                (Some(span), \"as_defined\", name.to_string())\n+                            }\n                         }\n                         ty::BrAnon(span) => {\n-                            me.kind = \"defined_here\";\n-                            me.span = match span {\n+                            let span = match span {\n                                 Some(_) => span,\n                                 None => Some(tcx.def_span(scope)),\n-                            }\n-                        },\n+                            };\n+                            (span, \"defined_here\", String::new())\n+                        }\n                         _ => {\n-                            me.kind = \"defined_here_reg\";\n-                            me.arg = region.to_string();\n-                            me.span = Some(tcx.def_span(scope));\n-                        },\n+                            (Some(tcx.def_span(scope)), \"defined_here_reg\", region.to_string())\n+                        }\n                     }\n                 }\n             }\n-            _ => bug!(),\n-        }\n-        Some(me)\n-    }\n \n-    fn add_to(self, diag: &mut rustc_errors::Diagnostic) {\n-        diag.set_arg(\"desc_kind\", self.kind);\n-        diag.set_arg(\"desc_arg\", self.arg);\n-        diag.set_arg(\"desc_num_arg\", self.num_arg);\n+            ty::ReStatic => (alt_span, \"restatic\", String::new()),\n+\n+            ty::RePlaceholder(_) | ty::ReError(_) => return None,\n+\n+            // FIXME(#13998) RePlaceholder should probably print like\n+            // ReFree rather than dumping Debug output on the user.\n+            //\n+            // We shouldn't really be having unification failures with ReVar\n+            // and ReLateBound though.\n+            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+                (alt_span, \"revar\", format!(\"{:?}\", region))\n+            }\n+        };\n+        Some(DescriptionCtx { span, kind, arg })\n     }\n }\n \n@@ -198,10 +168,11 @@ impl AddToDiagnostic for RegionExplanation<'_> {\n     {\n         diag.set_arg(\"pref_kind\", self.prefix);\n         diag.set_arg(\"suff_kind\", self.suffix);\n-        let desc_span = self.desc.span;\n-        self.desc.add_to(diag);\n+        diag.set_arg(\"desc_kind\", self.desc.kind);\n+        diag.set_arg(\"desc_arg\", self.desc.arg);\n+\n         let msg = f(diag, fluent::infer_region_explanation.into());\n-        if let Some(span) = desc_span {\n+        if let Some(span) = self.desc.span {\n             diag.span_note(span, msg);\n         } else {\n             diag.note(msg);"}, {"sha": "b68ffaed69dab8f7325a85ae2e725bd372773f1f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 32, "deletions": 42, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7614ea42fc2df3a9df53251ae0a586a692ccafba/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7614ea42fc2df3a9df53251ae0a586a692ccafba/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7614ea42fc2df3a9df53251ae0a586a692ccafba", "patch": "@@ -184,84 +184,74 @@ fn msg_span_from_named_region<'tcx>(\n     region: ty::Region<'tcx>,\n     alt_span: Option<Span>,\n ) -> (String, Option<Span>) {\n-    match *region {\n-        ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-            let (msg, span) = msg_span_from_early_bound_and_free_regions(tcx, region);\n-            (msg, Some(span))\n-        }\n-        ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n-        ty::RePlaceholder(ty::PlaceholderRegion {\n-            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrNamed(def_id, name), .. },\n-            ..\n-        }) => (format!(\"the lifetime `{name}` as defined here\"), Some(tcx.def_span(def_id))),\n-        ty::RePlaceholder(ty::PlaceholderRegion {\n-            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(Some(span)), .. },\n-            ..\n-        }) => (format!(\"the anonymous lifetime defined here\"), Some(span)),\n-        ty::RePlaceholder(ty::PlaceholderRegion {\n-            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(None), .. },\n-            ..\n-        }) => (format!(\"an anonymous lifetime\"), None),\n-        _ => bug!(\"{:?}\", region),\n-    }\n-}\n-\n-fn msg_span_from_early_bound_and_free_regions<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    region: ty::Region<'tcx>,\n-) -> (String, Span) {\n-    let scope = region.free_region_binding_scope(tcx).expect_local();\n     match *region {\n         ty::ReEarlyBound(ref br) => {\n-            let mut sp = tcx.def_span(scope);\n-            if let Some(param) =\n+            let scope = region.free_region_binding_scope(tcx).expect_local();\n+            let span = if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n             {\n-                sp = param.span;\n-            }\n+                param.span\n+            } else {\n+                tcx.def_span(scope)\n+            };\n             let text = if br.has_name() {\n                 format!(\"the lifetime `{}` as defined here\", br.name)\n             } else {\n                 \"the anonymous lifetime as defined here\".to_string()\n             };\n-            (text, sp)\n+            (text, Some(span))\n         }\n         ty::ReFree(ref fr) => {\n             if !fr.bound_region.is_named()\n                 && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n             {\n-                (\"the anonymous lifetime defined here\".to_string(), ty.span)\n+                (\"the anonymous lifetime defined here\".to_string(), Some(ty.span))\n             } else {\n+                let scope = region.free_region_binding_scope(tcx).expect_local();\n                 match fr.bound_region {\n                     ty::BoundRegionKind::BrNamed(_, name) => {\n-                        let mut sp = tcx.def_span(scope);\n-                        if let Some(param) =\n+                        let span = if let Some(param) =\n                             tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n                         {\n-                            sp = param.span;\n-                        }\n+                            param.span\n+                        } else {\n+                            tcx.def_span(scope)\n+                        };\n                         let text = if name == kw::UnderscoreLifetime {\n                             \"the anonymous lifetime as defined here\".to_string()\n                         } else {\n                             format!(\"the lifetime `{}` as defined here\", name)\n                         };\n-                        (text, sp)\n+                        (text, Some(span))\n                     }\n                     ty::BrAnon(span) => (\n                         \"the anonymous lifetime as defined here\".to_string(),\n-                        match span {\n+                        Some(match span {\n                             Some(span) => span,\n                             None => tcx.def_span(scope)\n-                        }\n+                        })\n                     ),\n                     _ => (\n                         format!(\"the lifetime `{}` as defined here\", region),\n-                        tcx.def_span(scope),\n+                        Some(tcx.def_span(scope)),\n                     ),\n                 }\n             }\n         }\n-        _ => bug!(),\n+        ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrNamed(def_id, name), .. },\n+            ..\n+        }) => (format!(\"the lifetime `{name}` as defined here\"), Some(tcx.def_span(def_id))),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(Some(span)), .. },\n+            ..\n+        }) => (format!(\"the anonymous lifetime defined here\"), Some(span)),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(None), .. },\n+            ..\n+        }) => (format!(\"an anonymous lifetime\"), None),\n+        _ => bug!(\"{:?}\", region),\n     }\n }\n "}]}