{"sha": "a15ac301627b33f87ca6f166b7cdbcc453543ee3", "node_id": "C_kwDOAAsO6NoAKGExNWFjMzAxNjI3YjMzZjg3Y2E2ZjE2NmI3Y2RiY2M0NTM1NDNlZTM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-11T18:00:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-11T18:00:41Z"}, "message": "Rollup merge of #95801 - m-ou-se:futex-rwlock, r=Amanieu\n\nReplace RwLock by a futex based one on Linux\n\nThis replaces the pthread-based RwLock on Linux by a futex based one.\n\nThis implementation is similar to [the algorithm](https://gist.github.com/kprotty/3042436aa55620d8ebcddf2bf25668bc) suggested by `@kprotty,` but modified to prefer writers and spin before sleeping. It uses two futexes: One for the readers to wait on, and one for the writers to wait on. The readers futex contains the state of the RwLock: The number of readers, a bit indicating whether writers are waiting, and a bit indicating whether readers are waiting. The writers futex is used as a simple condition variable and its contents are meaningless; it just needs to be changed on every notification.\n\nUsing two futexes rather than one has the obvious advantage of allowing a separate queue for readers and writers, but it also means we avoid the problem a single-futex RwLock would have of making it hard for a writer to go to sleep while the number of readers is rapidly changing up and down, as the writers futex is only changed when we actually want to wake up a writer.\n\nIt always prefers writers, as we decided [here](https://github.com/rust-lang/rust/issues/93740#issuecomment-1070696128).\n\nTo be able to prefer writers, it relies on futex_wake to return the number of awoken threads to be able to handle write-unlocking while both the readers-waiting and writers-waiting bits are set. Instead of waking both and letting them race, it first wakes writers and only continues to wake the readers too if futex_wake reported there were no writers to wake up.\n\nr? `@Amanieu`", "tree": {"sha": "4cdc27dae2502c9a72a77f7d5213b0769dad5f78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cdc27dae2502c9a72a77f7d5213b0769dad5f78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a15ac301627b33f87ca6f166b7cdbcc453543ee3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiVGzJCRBK7hj4Ov3rIwAAUp0IAEQUQibHkTSi5wPkTiqoypfV\nxDltZsw2b4QqOAKTFfC6AFckH8DxHklOAWk9EABOPrK+8SQZvk7CK0XBICLADdql\nv4SlhHrYusWjZNKvzZ02ma2SzUuESi1j/NTVWPdUO8ItQ3VSU7bs6asQ/tlwEW7j\nHR8l5wxHaFziKeGpSFyoBdNdnGqPE5E99mLZIiotHqGfl+1i5/7NmEV3Y7GM+uNz\nmeDbSJaz3GDcqOjIyzT4pq2e5M8INpCGmkM9UV4AoU4zdjnPsqOMD1mxzRvrTIT+\nFwZlqMCgV2O2rXk92zPV70b/Idb9JSo25NCkwfIvErhnUAFsxaTyTA1mxwm4IN0=\n=O02n\n-----END PGP SIGNATURE-----\n", "payload": "tree 4cdc27dae2502c9a72a77f7d5213b0769dad5f78\nparent 2ad701e45036fb2ccab8d4b4e23f9a3325e12817\nparent 83393817419e197d696fb724560bc55b18346a01\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649700041 +0200\ncommitter GitHub <noreply@github.com> 1649700041 +0200\n\nRollup merge of #95801 - m-ou-se:futex-rwlock, r=Amanieu\n\nReplace RwLock by a futex based one on Linux\n\nThis replaces the pthread-based RwLock on Linux by a futex based one.\n\nThis implementation is similar to [the algorithm](https://gist.github.com/kprotty/3042436aa55620d8ebcddf2bf25668bc) suggested by `@kprotty,` but modified to prefer writers and spin before sleeping. It uses two futexes: One for the readers to wait on, and one for the writers to wait on. The readers futex contains the state of the RwLock: The number of readers, a bit indicating whether writers are waiting, and a bit indicating whether readers are waiting. The writers futex is used as a simple condition variable and its contents are meaningless; it just needs to be changed on every notification.\n\nUsing two futexes rather than one has the obvious advantage of allowing a separate queue for readers and writers, but it also means we avoid the problem a single-futex RwLock would have of making it hard for a writer to go to sleep while the number of readers is rapidly changing up and down, as the writers futex is only changed when we actually want to wake up a writer.\n\nIt always prefers writers, as we decided [here](https://github.com/rust-lang/rust/issues/93740#issuecomment-1070696128).\n\nTo be able to prefer writers, it relies on futex_wake to return the number of awoken threads to be able to handle write-unlocking while both the readers-waiting and writers-waiting bits are set. Instead of waking both and letting them race, it first wakes writers and only continues to wake the readers too if futex_wake reported there were no writers to wake up.\n\nr? `@Amanieu`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a15ac301627b33f87ca6f166b7cdbcc453543ee3", "html_url": "https://github.com/rust-lang/rust/commit/a15ac301627b33f87ca6f166b7cdbcc453543ee3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a15ac301627b33f87ca6f166b7cdbcc453543ee3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ad701e45036fb2ccab8d4b4e23f9a3325e12817", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad701e45036fb2ccab8d4b4e23f9a3325e12817", "html_url": "https://github.com/rust-lang/rust/commit/2ad701e45036fb2ccab8d4b4e23f9a3325e12817"}, {"sha": "83393817419e197d696fb724560bc55b18346a01", "url": "https://api.github.com/repos/rust-lang/rust/commits/83393817419e197d696fb724560bc55b18346a01", "html_url": "https://github.com/rust-lang/rust/commit/83393817419e197d696fb724560bc55b18346a01"}], "stats": {"total": 337, "additions": 329, "deletions": 8}, "files": [{"sha": "b45d1c0149cb462cc4c8f867f1a6d282f52a5cfc", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a15ac301627b33f87ca6f166b7cdbcc453543ee3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15ac301627b33f87ca6f166b7cdbcc453543ee3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=a15ac301627b33f87ca6f166b7cdbcc453543ee3", "patch": "@@ -7,6 +7,11 @@\n use crate::sync::atomic::AtomicI32;\n use crate::time::Duration;\n \n+/// Wait for a futex_wake operation to wake us.\n+///\n+/// Returns directly if the futex doesn't hold the expected value.\n+///\n+/// Returns false on timeout, and true in all other cases.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) -> bool {\n     use super::time::Timespec;\n@@ -68,18 +73,23 @@ pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n     }\n }\n \n+/// Wake up one thread that's blocked on futex_wait on this futex.\n+///\n+/// Returns true if this actually woke up such a thread,\n+/// or false if no thread was waiting on this futex.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn futex_wake(futex: &AtomicI32) {\n+pub fn futex_wake(futex: &AtomicI32) -> bool {\n     unsafe {\n         libc::syscall(\n             libc::SYS_futex,\n             futex as *const AtomicI32,\n             libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n             1,\n-        );\n+        ) > 0\n     }\n }\n \n+/// Wake up all threads that are waiting on futex_wait on this futex.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn futex_wake_all(futex: &AtomicI32) {\n     unsafe {\n@@ -93,12 +103,10 @@ pub fn futex_wake_all(futex: &AtomicI32) {\n }\n \n #[cfg(target_os = \"emscripten\")]\n-pub fn futex_wake(futex: &AtomicI32) {\n+pub fn futex_wake(futex: &AtomicI32) -> bool {\n     extern \"C\" {\n         fn emscripten_futex_wake(addr: *const AtomicI32, count: libc::c_int) -> libc::c_int;\n     }\n \n-    unsafe {\n-        emscripten_futex_wake(futex as *const AtomicI32, 1);\n-    }\n+    unsafe { emscripten_futex_wake(futex as *const AtomicI32, 1) > 0 }\n }"}, {"sha": "aa16da97e4c19c4937ef31675be81df80294990c", "filename": "library/std/src/sys/unix/locks/futex_rwlock.rs", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/a15ac301627b33f87ca6f166b7cdbcc453543ee3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15ac301627b33f87ca6f166b7cdbcc453543ee3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs?ref=a15ac301627b33f87ca6f166b7cdbcc453543ee3", "patch": "@@ -0,0 +1,313 @@\n+use crate::sync::atomic::{\n+    AtomicI32,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n+\n+pub type MovableRwLock = RwLock;\n+\n+pub struct RwLock {\n+    // The state consists of a 30-bit reader counter, a 'readers waiting' flag, and a 'writers waiting' flag.\n+    // Bits 0..30:\n+    //   0: Unlocked\n+    //   1..=0x3FFF_FFFE: Locked by N readers\n+    //   0x3FFF_FFFF: Write locked\n+    // Bit 30: Readers are waiting on this futex.\n+    // Bit 31: Writers are waiting on the writer_notify futex.\n+    state: AtomicI32,\n+    // The 'condition variable' to notify writers through.\n+    // Incremented on every signal.\n+    writer_notify: AtomicI32,\n+}\n+\n+const READ_LOCKED: i32 = 1;\n+const MASK: i32 = (1 << 30) - 1;\n+const WRITE_LOCKED: i32 = MASK;\n+const MAX_READERS: i32 = MASK - 1;\n+const READERS_WAITING: i32 = 1 << 30;\n+const WRITERS_WAITING: i32 = 1 << 31;\n+\n+fn is_unlocked(state: i32) -> bool {\n+    state & MASK == 0\n+}\n+\n+fn is_write_locked(state: i32) -> bool {\n+    state & MASK == WRITE_LOCKED\n+}\n+\n+fn has_readers_waiting(state: i32) -> bool {\n+    state & READERS_WAITING != 0\n+}\n+\n+fn has_writers_waiting(state: i32) -> bool {\n+    state & WRITERS_WAITING != 0\n+}\n+\n+fn is_read_lockable(state: i32) -> bool {\n+    // This also returns false if the counter could overflow if we tried to read lock it.\n+    //\n+    // We don't allow read-locking if there's readers waiting, even if the lock is unlocked\n+    // and there's no writers waiting. The only situation when this happens is after unlocking,\n+    // at which point the unlocking thread might be waking up writers, which have priority over readers.\n+    // The unlocking thread will clear the readers waiting bit and wake up readers, if necssary.\n+    state & MASK < MAX_READERS && !has_readers_waiting(state) && !has_writers_waiting(state)\n+}\n+\n+fn has_reached_max_readers(state: i32) -> bool {\n+    state & MASK == MAX_READERS\n+}\n+\n+impl RwLock {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self { state: AtomicI32::new(0), writer_notify: AtomicI32::new(0) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {}\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        self.state\n+            .fetch_update(Acquire, Relaxed, |s| is_read_lockable(s).then(|| s + READ_LOCKED))\n+            .is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        let state = self.state.load(Relaxed);\n+        if !is_read_lockable(state)\n+            || self\n+                .state\n+                .compare_exchange_weak(state, state + READ_LOCKED, Acquire, Relaxed)\n+                .is_err()\n+        {\n+            self.read_contended();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        let state = self.state.fetch_sub(READ_LOCKED, Release) - READ_LOCKED;\n+\n+        // It's impossible for a reader to be waiting on a read-locked RwLock,\n+        // except if there is also a writer waiting.\n+        debug_assert!(!has_readers_waiting(state) || has_writers_waiting(state));\n+\n+        // Wake up a writer if we were the last reader and there's a writer waiting.\n+        if is_unlocked(state) && has_writers_waiting(state) {\n+            self.wake_writer_or_readers(state);\n+        }\n+    }\n+\n+    #[cold]\n+    fn read_contended(&self) {\n+        let mut state = self.spin_read();\n+\n+        loop {\n+            // If we can lock it, lock it.\n+            if is_read_lockable(state) {\n+                match self.state.compare_exchange_weak(state, state + READ_LOCKED, Acquire, Relaxed)\n+                {\n+                    Ok(_) => return, // Locked!\n+                    Err(s) => {\n+                        state = s;\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            // Check for overflow.\n+            if has_reached_max_readers(state) {\n+                panic!(\"too many active read locks on RwLock\");\n+            }\n+\n+            // Make sure the readers waiting bit is set before we go to sleep.\n+            if !has_readers_waiting(state) {\n+                if let Err(s) =\n+                    self.state.compare_exchange(state, state | READERS_WAITING, Relaxed, Relaxed)\n+                {\n+                    state = s;\n+                    continue;\n+                }\n+            }\n+\n+            // Wait for the state to change.\n+            futex_wait(&self.state, state | READERS_WAITING, None);\n+\n+            // Spin again after waking up.\n+            state = self.spin_read();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        self.state\n+            .fetch_update(Acquire, Relaxed, |s| is_unlocked(s).then(|| s + WRITE_LOCKED))\n+            .is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        if self.state.compare_exchange_weak(0, WRITE_LOCKED, Acquire, Relaxed).is_err() {\n+            self.write_contended();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        let state = self.state.fetch_sub(WRITE_LOCKED, Release) - WRITE_LOCKED;\n+\n+        debug_assert!(is_unlocked(state));\n+\n+        if has_writers_waiting(state) || has_readers_waiting(state) {\n+            self.wake_writer_or_readers(state);\n+        }\n+    }\n+\n+    #[cold]\n+    fn write_contended(&self) {\n+        let mut state = self.spin_write();\n+\n+        let mut other_writers_waiting = 0;\n+\n+        loop {\n+            // If it's unlocked, we try to lock it.\n+            if is_unlocked(state) {\n+                match self.state.compare_exchange_weak(\n+                    state,\n+                    state | WRITE_LOCKED | other_writers_waiting,\n+                    Acquire,\n+                    Relaxed,\n+                ) {\n+                    Ok(_) => return, // Locked!\n+                    Err(s) => {\n+                        state = s;\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            // Set the waiting bit indicating that we're waiting on it.\n+            if !has_writers_waiting(state) {\n+                if let Err(s) =\n+                    self.state.compare_exchange(state, state | WRITERS_WAITING, Relaxed, Relaxed)\n+                {\n+                    state = s;\n+                    continue;\n+                }\n+            }\n+\n+            // Other writers might be waiting now too, so we should make sure\n+            // we keep that bit on once we manage lock it.\n+            other_writers_waiting = WRITERS_WAITING;\n+\n+            // Examine the notification counter before we check if `state` has changed,\n+            // to make sure we don't miss any notifications.\n+            let seq = self.writer_notify.load(Acquire);\n+\n+            // Don't go to sleep if the lock has become available,\n+            // or if the writers waiting bit is no longer set.\n+            let s = self.state.load(Relaxed);\n+            if is_unlocked(state) || !has_writers_waiting(s) {\n+                state = s;\n+                continue;\n+            }\n+\n+            // Wait for the state to change.\n+            futex_wait(&self.writer_notify, seq, None);\n+\n+            // Spin again after waking up.\n+            state = self.spin_write();\n+        }\n+    }\n+\n+    /// Wake up waiting threads after unlocking.\n+    ///\n+    /// If both are waiting, this will wake up only one writer, but will fall\n+    /// back to waking up readers if there was no writer to wake up.\n+    #[cold]\n+    fn wake_writer_or_readers(&self, mut state: i32) {\n+        assert!(is_unlocked(state));\n+\n+        // The readers waiting bit might be turned on at any point now,\n+        // since readers will block when there's anything waiting.\n+        // Writers will just lock the lock though, regardless of the waiting bits,\n+        // so we don't have to worry about the writer waiting bit.\n+        //\n+        // If the lock gets locked in the meantime, we don't have to do\n+        // anything, because then the thread that locked the lock will take\n+        // care of waking up waiters when it unlocks.\n+\n+        // If only writers are waiting, wake one of them up.\n+        if state == WRITERS_WAITING {\n+            match self.state.compare_exchange(state, 0, Relaxed, Relaxed) {\n+                Ok(_) => {\n+                    self.wake_writer();\n+                    return;\n+                }\n+                Err(s) => {\n+                    // Maybe some readers are now waiting too. So, continue to the next `if`.\n+                    state = s;\n+                }\n+            }\n+        }\n+\n+        // If both writers and readers are waiting, leave the readers waiting\n+        // and only wake up one writer.\n+        if state == READERS_WAITING + WRITERS_WAITING {\n+            if self.state.compare_exchange(state, READERS_WAITING, Relaxed, Relaxed).is_err() {\n+                // The lock got locked. Not our problem anymore.\n+                return;\n+            }\n+            if self.wake_writer() {\n+                return;\n+            }\n+            // No writers were actually blocked on futex_wait, so we continue\n+            // to wake up readers instead, since we can't be sure if we notified a writer.\n+            state = READERS_WAITING;\n+        }\n+\n+        // If readers are waiting, wake them all up.\n+        if state == READERS_WAITING {\n+            if self.state.compare_exchange(state, 0, Relaxed, Relaxed).is_ok() {\n+                futex_wake_all(&self.state);\n+            }\n+        }\n+    }\n+\n+    /// This wakes one writer and returns true if we woke up a writer that was\n+    /// blocked on futex_wait.\n+    ///\n+    /// If this returns false, it might still be the case that we notified a\n+    /// writer that was about to go to sleep.\n+    fn wake_writer(&self) -> bool {\n+        self.writer_notify.fetch_add(1, Release);\n+        futex_wake(&self.writer_notify)\n+    }\n+\n+    /// Spin for a while, but stop directly at the given condition.\n+    fn spin_until(&self, f: impl Fn(i32) -> bool) -> i32 {\n+        let mut spin = 100; // Chosen by fair dice roll.\n+        loop {\n+            let state = self.state.load(Relaxed);\n+            if f(state) || spin == 0 {\n+                return state;\n+            }\n+            crate::hint::spin_loop();\n+            spin -= 1;\n+        }\n+    }\n+\n+    fn spin_write(&self) -> i32 {\n+        // Stop spinning when it's unlocked or when there's waiting writers, to keep things somewhat fair.\n+        self.spin_until(|state| is_unlocked(state) || has_writers_waiting(state))\n+    }\n+\n+    fn spin_read(&self) -> i32 {\n+        // Stop spinning when it's unlocked or read locked, or when there's waiting threads.\n+        self.spin_until(|state| {\n+            !is_write_locked(state) || has_readers_waiting(state) || has_writers_waiting(state)\n+        })\n+    }\n+}"}, {"sha": "85afc939d2e897e7c9f0ecf1e1f8269f852d6591", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15ac301627b33f87ca6f166b7cdbcc453543ee3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15ac301627b33f87ca6f166b7cdbcc453543ee3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=a15ac301627b33f87ca6f166b7cdbcc453543ee3", "patch": "@@ -4,13 +4,13 @@ cfg_if::cfg_if! {\n         target_os = \"android\",\n     ))] {\n         mod futex;\n+        mod futex_rwlock;\n         #[allow(dead_code)]\n         mod pthread_mutex; // Only used for PthreadMutexAttr, needed by pthread_remutex.\n         mod pthread_remutex; // FIXME: Implement this using a futex\n-        mod pthread_rwlock; // FIXME: Implement this using a futex\n         pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar};\n         pub use pthread_remutex::ReentrantMutex;\n-        pub use pthread_rwlock::{RwLock, MovableRwLock};\n+        pub use futex_rwlock::{RwLock, MovableRwLock};\n     } else {\n         mod pthread_mutex;\n         mod pthread_remutex;"}]}