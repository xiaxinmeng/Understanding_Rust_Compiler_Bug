{"sha": "77f34841489767804ffe3d0f20d5469ecc5cf417", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZjM0ODQxNDg5NzY3ODA0ZmZlM2QwZjIwZDU0NjllY2M1Y2Y0MTc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-25T23:10:40Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:51Z"}, "message": "trans: Apply all attributes through FnType.", "tree": {"sha": "6afe306918b78493301741c465ba994cfcece4fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6afe306918b78493301741c465ba994cfcece4fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77f34841489767804ffe3d0f20d5469ecc5cf417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77f34841489767804ffe3d0f20d5469ecc5cf417", "html_url": "https://github.com/rust-lang/rust/commit/77f34841489767804ffe3d0f20d5469ecc5cf417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77f34841489767804ffe3d0f20d5469ecc5cf417/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de5f8244f20e434d2e0d351c7f4b55e604b4f3b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/de5f8244f20e434d2e0d351c7f4b55e604b4f3b3", "html_url": "https://github.com/rust-lang/rust/commit/de5f8244f20e434d2e0d351c7f4b55e604b4f3b3"}], "stats": {"total": 628, "additions": 240, "deletions": 388}, "files": [{"sha": "a1dca796d9a42db6a7be6e768c0f33aeb9842a48", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -212,21 +212,21 @@ impl Attributes {\n         self\n     }\n \n-    pub fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n+    pub fn apply_llfn(&self, idx: usize, llfn: ValueRef) {\n         unsafe {\n-            LLVMAddFunctionAttribute(llfn, idx, self.regular.bits());\n+            LLVMAddFunctionAttribute(llfn, idx as c_uint, self.regular.bits());\n             if self.dereferenceable_bytes != 0 {\n-                LLVMAddDereferenceableAttr(llfn, idx,\n+                LLVMAddDereferenceableAttr(llfn, idx as c_uint,\n                                            self.dereferenceable_bytes);\n             }\n         }\n     }\n \n-    pub fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n+    pub fn apply_callsite(&self, idx: usize, callsite: ValueRef) {\n         unsafe {\n-            LLVMAddCallSiteAttribute(callsite, idx, self.regular.bits());\n+            LLVMAddCallSiteAttribute(callsite, idx as c_uint, self.regular.bits());\n             if self.dereferenceable_bytes != 0 {\n-                LLVMAddDereferenceableCallSiteAttr(callsite, idx,\n+                LLVMAddDereferenceableCallSiteAttr(callsite, idx as c_uint,\n                                                    self.dereferenceable_bytes);\n             }\n         }\n@@ -240,49 +240,6 @@ pub enum AttributeSet {\n     FunctionIndex = !0\n }\n \n-pub struct AttrBuilder {\n-    attrs: Vec<(usize, Attributes)>\n-}\n-\n-impl AttrBuilder {\n-    pub fn new() -> AttrBuilder {\n-        AttrBuilder {\n-            attrs: Vec::new()\n-        }\n-    }\n-\n-    pub fn arg(&mut self, idx: usize) -> &mut Attributes {\n-        let mut found = None;\n-        for (i, &(idx2, _)) in self.attrs.iter().enumerate() {\n-            if idx == idx2 {\n-                found = Some(i);\n-                break;\n-            }\n-        }\n-        let i = found.unwrap_or_else(|| {\n-            self.attrs.push((idx, Attributes::default()));\n-            self.attrs.len() - 1\n-        });\n-        &mut self.attrs[i].1\n-    }\n-\n-    pub fn ret(&mut self) -> &mut Attributes {\n-        self.arg(ReturnIndex as usize)\n-    }\n-\n-    pub fn apply_llfn(&self, llfn: ValueRef) {\n-        for &(idx, ref attr) in &self.attrs {\n-            attr.apply_llfn(idx as c_uint, llfn);\n-        }\n-    }\n-\n-    pub fn apply_callsite(&self, callsite: ValueRef) {\n-        for &(idx, ref attr) in &self.attrs {\n-            attr.apply_callsite(idx as c_uint, callsite);\n-        }\n-    }\n-}\n-\n // enum for the LLVM IntPredicate type\n #[derive(Copy, Clone)]\n pub enum IntPredicate {"}, {"sha": "440d5a8d816ab2fe44fd2afcb5d6c7b3f1b409e6", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 104, "deletions": 12, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm;\n+use llvm::{self, ValueRef};\n use trans::common::{return_type_is_void, type_is_fat_ptr};\n use trans::context::CrateContext;\n use trans::cabi_x86;\n@@ -24,6 +24,7 @@ use trans::machine::{llsize_of_alloc, llsize_of_real};\n use trans::type_::Type;\n use trans::type_of;\n \n+use rustc_front::hir;\n use middle::ty::{self, Ty};\n \n pub use syntax::abi::Abi;\n@@ -204,22 +205,102 @@ impl FnType {\n             }\n         };\n \n-        let ret = match sig.output {\n+        let mut ret = match sig.output {\n             ty::FnConverging(ret_ty) if !return_type_is_void(ccx, ret_ty) => {\n                 arg_of(ret_ty)\n             }\n             _ => ArgType::new(Type::void(ccx), Type::void(ccx))\n         };\n \n+        if let ty::FnConverging(ret_ty) = sig.output {\n+            if !type_is_fat_ptr(ccx.tcx(), ret_ty) {\n+                // The `noalias` attribute on the return value is useful to a\n+                // function ptr caller.\n+                if let ty::TyBox(_) = ret_ty.sty {\n+                    // `Box` pointer return values never alias because ownership\n+                    // is transferred\n+                    ret.attrs.set(llvm::Attribute::NoAlias);\n+                }\n+\n+                // We can also mark the return value as `dereferenceable` in certain cases\n+                match ret_ty.sty {\n+                    // These are not really pointers but pairs, (pointer, len)\n+                    ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+                    ty::TyBox(ty) => {\n+                        let llty = type_of::sizing_type_of(ccx, ty);\n+                        let llsz = llsize_of_real(ccx, llty);\n+                        ret.attrs.set_dereferenceable(llsz);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+\n         let mut args = Vec::with_capacity(inputs.len() + extra_args.len());\n+\n+        // Handle safe Rust thin and fat pointers.\n+        let rust_ptr_attrs = |ty: Ty<'tcx>, arg: &mut ArgType| match ty.sty {\n+            // `Box` pointer parameters never alias because ownership is transferred\n+            ty::TyBox(inner) => {\n+                arg.attrs.set(llvm::Attribute::NoAlias);\n+                Some(inner)\n+            }\n+\n+            ty::TyRef(b, mt) => {\n+                use middle::ty::{BrAnon, ReLateBound};\n+\n+                // `&mut` pointer parameters never alias other parameters, or mutable global data\n+                //\n+                // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n+                // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n+                // on memory dependencies rather than pointer equality\n+                let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n+\n+                if mt.mutbl != hir::MutMutable && !interior_unsafe {\n+                    arg.attrs.set(llvm::Attribute::NoAlias);\n+                }\n+\n+                if mt.mutbl == hir::MutImmutable && !interior_unsafe {\n+                    arg.attrs.set(llvm::Attribute::ReadOnly);\n+                }\n+\n+                // When a reference in an argument has no named lifetime, it's\n+                // impossible for that reference to escape this function\n+                // (returned or stored beyond the call by a closure).\n+                if let ReLateBound(_, BrAnon(_)) = *b {\n+                    arg.attrs.set(llvm::Attribute::NoCapture);\n+                }\n+\n+                Some(mt.ty)\n+            }\n+            _ => None\n+        };\n+\n         for ty in inputs.iter().chain(extra_args.iter()) {\n-            let arg = arg_of(ty);\n+            let mut arg = arg_of(ty);\n+\n             if type_is_fat_ptr(ccx.tcx(), ty) {\n-                let original = arg.original_ty.field_types();\n-                let sizing = arg.ty.field_types();\n-                args.extend(original.into_iter().zip(sizing)\n-                                    .map(|(o, s)| ArgType::new(o, s)));\n+                let original_tys = arg.original_ty.field_types();\n+                let sizing_tys = arg.ty.field_types();\n+                assert_eq!((original_tys.len(), sizing_tys.len()), (2, 2));\n+\n+                let mut data = ArgType::new(original_tys[0], sizing_tys[0]);\n+                let mut info = ArgType::new(original_tys[1], sizing_tys[1]);\n+\n+                if let Some(inner) = rust_ptr_attrs(ty, &mut data) {\n+                    data.attrs.set(llvm::Attribute::NonNull);\n+                    if ccx.tcx().struct_tail(inner).is_trait() {\n+                        info.attrs.set(llvm::Attribute::NonNull);\n+                    }\n+                }\n+                args.push(data);\n+                args.push(info);\n             } else {\n+                if let Some(inner) = rust_ptr_attrs(ty, &mut arg) {\n+                    let llty = type_of::sizing_type_of(ccx, inner);\n+                    let llsz = llsize_of_real(ccx, llty);\n+                    arg.attrs.set_dereferenceable(llsz);\n+                }\n                 args.push(arg);\n             }\n         }\n@@ -327,18 +408,29 @@ impl FnType {\n         }\n     }\n \n-    pub fn llvm_attrs(&self) -> llvm::AttrBuilder {\n-        let mut attrs = llvm::AttrBuilder::new();\n+    pub fn apply_attrs_llfn(&self, llfn: ValueRef) {\n+        let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n+        self.ret.attrs.apply_llfn(i, llfn);\n+        i += 1;\n+        for arg in &self.args {\n+            if !arg.is_ignore() {\n+                if arg.pad.is_some() { i += 1; }\n+                arg.attrs.apply_llfn(i, llfn);\n+                i += 1;\n+            }\n+        }\n+    }\n+\n+    pub fn apply_attrs_callsite(&self, callsite: ValueRef) {\n         let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n-        *attrs.arg(i) = self.ret.attrs;\n+        self.ret.attrs.apply_callsite(i, callsite);\n         i += 1;\n         for arg in &self.args {\n             if !arg.is_ignore() {\n                 if arg.pad.is_some() { i += 1; }\n-                *attrs.arg(i) = arg.attrs;\n+                arg.attrs.apply_callsite(i, callsite);\n                 i += 1;\n             }\n         }\n-        attrs\n     }\n }"}, {"sha": "99dc3ade823fa7794e24c6edf9891c054521f198", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 2, "deletions": 171, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -11,17 +11,10 @@\n \n use libc::{c_uint, c_ulonglong};\n use llvm::{self, ValueRef};\n-use middle::ty;\n-use middle::infer;\n use session::config::NoDebugInfo;\n pub use syntax::attr::InlineAttr;\n use syntax::ast;\n-use rustc_front::hir;\n-use trans::abi::Abi;\n-use trans::common;\n use trans::context::CrateContext;\n-use trans::machine;\n-use trans::type_of;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n@@ -111,174 +104,12 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n     for attr in attrs {\n         if attr.check_name(\"cold\") {\n             llvm::Attributes::default().set(llvm::Attribute::Cold)\n-                .apply_llfn(llvm::FunctionIndex as c_uint, llfn)\n+                .apply_llfn(llvm::FunctionIndex as usize, llfn)\n         } else if attr.check_name(\"allocator\") {\n             llvm::Attributes::default().set(llvm::Attribute::NoAlias)\n-                .apply_llfn(llvm::ReturnIndex as c_uint, llfn)\n+                .apply_llfn(llvm::ReturnIndex as usize, llfn)\n         } else if attr.check_name(\"unwind\") {\n             unwind(llfn, true);\n         }\n     }\n }\n-\n-/// Composite function which converts function type into LLVM attributes for the function.\n-pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx>)\n-                              -> llvm::AttrBuilder {\n-    use middle::ty::{BrAnon, ReLateBound};\n-\n-    let f = match fn_type.sty {\n-        ty::TyFnDef(_, _, f) | ty::TyFnPtr(f) => f,\n-        _ => unreachable!(\"expected fn type, found {:?}\", fn_type)\n-    };\n-\n-    let fn_sig = ccx.tcx().erase_late_bound_regions(&f.sig);\n-    let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n-\n-    let mut attrs = llvm::AttrBuilder::new();\n-    let ret_ty = fn_sig.output;\n-\n-    // These have an odd calling convention, so we need to manually\n-    // unpack the input ty's\n-    let input_tys = match fn_type.sty {\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) if f.abi == Abi::RustCall => {\n-            let first = Some(fn_sig.inputs[0]).into_iter();\n-\n-            match fn_sig.inputs[1].sty {\n-                ty::TyTuple(ref t_in) => {\n-                    first.chain(t_in.iter().cloned())\n-                }\n-                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n-            }\n-        }\n-        _ => None.into_iter().chain(fn_sig.inputs.iter().cloned())\n-    };\n-\n-    // Index 0 is the return value of the llvm func, so we start at 1\n-    let mut idx = 1;\n-    if let ty::FnConverging(ret_ty) = ret_ty {\n-        // A function pointer is called without the declaration\n-        // available, so we have to apply any attributes with ABI\n-        // implications directly to the call instruction. Right now,\n-        // the only attribute we need to worry about is `sret`.\n-        if type_of::return_uses_outptr(ccx, ret_ty) {\n-            let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n-\n-            // The outptr can be noalias and nocapture because it's entirely\n-            // invisible to the program. We also know it's nonnull as well\n-            // as how many bytes we can dereference\n-            attrs.arg(1).set(llvm::Attribute::StructRet)\n-                        .set(llvm::Attribute::NoAlias)\n-                        .set(llvm::Attribute::NoCapture)\n-                        .set_dereferenceable(llret_sz);\n-\n-            // Add one more since there's an outptr\n-            idx += 1;\n-        } else {\n-            // The `noalias` attribute on the return value is useful to a\n-            // function ptr caller.\n-            match ret_ty.sty {\n-                // `Box` pointer return values never alias because ownership\n-                // is transferred\n-                ty::TyBox(it) if common::type_is_sized(ccx.tcx(), it) => {\n-                    attrs.ret().set(llvm::Attribute::NoAlias);\n-                }\n-                _ => {}\n-            }\n-\n-            // We can also mark the return value as `dereferenceable` in certain cases\n-            match ret_ty.sty {\n-                // These are not really pointers but pairs, (pointer, len)\n-                ty::TyRef(_, ty::TypeAndMut { ty: inner, .. })\n-                | ty::TyBox(inner) if common::type_is_sized(ccx.tcx(), inner) => {\n-                    let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-                    attrs.ret().set_dereferenceable(llret_sz);\n-                }\n-                _ => {}\n-            }\n-\n-            if let ty::TyBool = ret_ty.sty {\n-                attrs.ret().set(llvm::Attribute::ZExt);\n-            }\n-        }\n-    }\n-\n-    for t in input_tys {\n-        match t.sty {\n-            _ if type_of::arg_is_indirect(ccx, t) => {\n-                let llarg_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, t));\n-\n-                // For non-immediate arguments the callee gets its own copy of\n-                // the value on the stack, so there are no aliases. It's also\n-                // program-invisible so can't possibly capture\n-                attrs.arg(idx).set(llvm::Attribute::NoAlias)\n-                              .set(llvm::Attribute::NoCapture)\n-                              .set_dereferenceable(llarg_sz);\n-            }\n-\n-            ty::TyBool => {\n-                attrs.arg(idx).set(llvm::Attribute::ZExt);\n-            }\n-\n-            // `Box` pointer parameters never alias because ownership is transferred\n-            ty::TyBox(inner) => {\n-                attrs.arg(idx).set(llvm::Attribute::NoAlias);\n-\n-                if common::type_is_sized(ccx.tcx(), inner) {\n-                    let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-                    attrs.arg(idx).set_dereferenceable(llsz);\n-                } else {\n-                    attrs.arg(idx).set(llvm::Attribute::NonNull);\n-                    if inner.is_trait() {\n-                        attrs.arg(idx + 1).set(llvm::Attribute::NonNull);\n-                    }\n-                }\n-            }\n-\n-            ty::TyRef(b, mt) => {\n-                // `&mut` pointer parameters never alias other parameters, or mutable global data\n-                //\n-                // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n-                // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n-                // on memory dependencies rather than pointer equality\n-                let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n-\n-                if mt.mutbl != hir::MutMutable && !interior_unsafe {\n-                    attrs.arg(idx).set(llvm::Attribute::NoAlias);\n-                }\n-\n-                if mt.mutbl == hir::MutImmutable && !interior_unsafe {\n-                    attrs.arg(idx).set(llvm::Attribute::ReadOnly);\n-                }\n-\n-                // & pointer parameters are also never null and for sized types we also know\n-                // exactly how many bytes we can dereference\n-                if common::type_is_sized(ccx.tcx(), mt.ty) {\n-                    let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                    attrs.arg(idx).set_dereferenceable(llsz);\n-                } else {\n-                    attrs.arg(idx).set(llvm::Attribute::NonNull);\n-                    if mt.ty.is_trait() {\n-                        attrs.arg(idx + 1).set(llvm::Attribute::NonNull);\n-                    }\n-                }\n-\n-                // When a reference in an argument has no named lifetime, it's\n-                // impossible for that reference to escape this function\n-                // (returned or stored beyond the call by a closure).\n-                if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx).set(llvm::Attribute::NoCapture);\n-                }\n-            }\n-\n-            _ => ()\n-        }\n-\n-        if common::type_is_fat_ptr(ccx.tcx(), t) {\n-            idx += 2;\n-        } else {\n-            idx += 1;\n-        }\n-    }\n-\n-    attrs\n-}"}, {"sha": "4b268ba57ca7e8b638013f77881b0f602baea535", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -836,16 +836,13 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: &[ValueRef],\n-                          fn_ty: Ty<'tcx>,\n                           debug_loc: DebugLoc)\n                           -> (ValueRef, Block<'blk, 'tcx>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n-    let attributes = attributes::from_fn_type(bcx.ccx(), fn_ty);\n-\n     match bcx.opt_node_id {\n         None => {\n             debug!(\"invoke at ???\");\n@@ -868,7 +865,6 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               &llargs[..],\n                               normal_bcx.llbb,\n                               landing_pad,\n-                              Some(attributes),\n                               debug_loc);\n         return (llresult, normal_bcx);\n     } else {\n@@ -877,7 +873,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             debug!(\"arg: {:?}\", Value(llarg));\n         }\n \n-        let llresult = Call(bcx, llfn, &llargs[..], Some(attributes), debug_loc);\n+        let llresult = Call(bcx, llfn, &llargs[..], debug_loc);\n         return (llresult, bcx);\n     }\n }\n@@ -1105,7 +1101,6 @@ pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n         Call(cx,\n              lifetime_start,\n              &[C_u64(ccx, size), ptr],\n-             None,\n              DebugLoc::None);\n     })\n }\n@@ -1116,7 +1111,6 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n         Call(cx,\n              lifetime_end,\n              &[C_u64(ccx, size), ptr],\n-             None,\n              DebugLoc::None);\n     })\n }\n@@ -1147,7 +1141,6 @@ pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     Call(cx,\n          memcpy,\n          &[dst_ptr, src_ptr, size, align, volatile],\n-         None,\n          DebugLoc::None);\n }\n \n@@ -1217,7 +1210,7 @@ pub fn call_memset<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let volatile = C_bool(ccx, volatile);\n-    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None, None);\n+    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n }\n \n \n@@ -1292,7 +1285,7 @@ pub fn alloca_dropped<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>, name: &st\n     // Block, which we do not have for `alloca_insert_pt`).\n     core_lifetime_emit(cx.ccx(), p, Lifetime::Start, |ccx, size, lifetime_start| {\n         let ptr = b.pointercast(p, Type::i8p(ccx));\n-        b.call(lifetime_start, &[C_u64(ccx, size), ptr], None, None);\n+        b.call(lifetime_start, &[C_u64(ccx, size), ptr], None);\n     });\n     memfill(&b, p, ty, adt::DTOR_DONE);\n     p"}, {"sha": "ac7e3e48fb53433e9e1526a7751f9767910ca206", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -12,7 +12,7 @@\n #![allow(non_snake_case)]\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect, AttrBuilder};\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use trans::common::*;\n@@ -139,7 +139,6 @@ pub fn Invoke(cx: Block,\n               args: &[ValueRef],\n               then: BasicBlockRef,\n               catch: BasicBlockRef,\n-              attributes: Option<AttrBuilder>,\n               debug_loc: DebugLoc)\n               -> ValueRef {\n     if cx.unreachable.get() {\n@@ -154,7 +153,7 @@ pub fn Invoke(cx: Block,\n            }).collect::<Vec<String>>().join(\", \"));\n     debug_loc.apply(cx.fcx);\n     let bundle = cx.lpad().and_then(|b| b.bundle());\n-    B(cx).invoke(fn_, args, then, catch, bundle, attributes)\n+    B(cx).invoke(fn_, args, then, catch, bundle)\n }\n \n pub fn Unreachable(cx: Block) {\n@@ -911,30 +910,28 @@ pub fn InlineAsmCall(cx: Block, asm: *const c_char, cons: *const c_char,\n pub fn Call(cx: Block,\n             fn_: ValueRef,\n             args: &[ValueRef],\n-            attributes: Option<AttrBuilder>,\n             debug_loc: DebugLoc)\n             -> ValueRef {\n     if cx.unreachable.get() {\n         return _UndefReturn(cx, fn_);\n     }\n     debug_loc.apply(cx.fcx);\n     let bundle = cx.lpad.get().and_then(|b| b.bundle());\n-    B(cx).call(fn_, args, bundle, attributes)\n+    B(cx).call(fn_, args, bundle)\n }\n \n pub fn CallWithConv(cx: Block,\n                     fn_: ValueRef,\n                     args: &[ValueRef],\n                     conv: CallConv,\n-                    attributes: Option<AttrBuilder>,\n                     debug_loc: DebugLoc)\n                     -> ValueRef {\n     if cx.unreachable.get() {\n         return _UndefReturn(cx, fn_);\n     }\n     debug_loc.apply(cx.fcx);\n     let bundle = cx.lpad.get().and_then(|b| b.bundle());\n-    B(cx).call_with_conv(fn_, args, conv, bundle, attributes)\n+    B(cx).call_with_conv(fn_, args, conv, bundle)\n }\n \n pub fn AtomicFence(cx: Block, order: AtomicOrdering, scope: SynchronizationScope) {"}, {"sha": "da5042b0caf3d53156ffd7d90d4fd407daece4e9", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)] // FFI wrappers\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect, AttrBuilder};\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use trans::base;\n@@ -165,8 +165,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                   args: &[ValueRef],\n                   then: BasicBlockRef,\n                   catch: BasicBlockRef,\n-                  bundle: Option<&OperandBundleDef>,\n-                  attributes: Option<AttrBuilder>)\n+                  bundle: Option<&OperandBundleDef>)\n                   -> ValueRef {\n         self.count_insn(\"invoke\");\n \n@@ -180,18 +179,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n \n         unsafe {\n-            let v = llvm::LLVMRustBuildInvoke(self.llbuilder,\n-                                              llfn,\n-                                              args.as_ptr(),\n-                                              args.len() as c_uint,\n-                                              then,\n-                                              catch,\n-                                              bundle,\n-                                              noname());\n-            if let Some(a) = attributes {\n-                a.apply_callsite(v);\n-            }\n-            v\n+            llvm::LLVMRustBuildInvoke(self.llbuilder,\n+                                      llfn,\n+                                      args.as_ptr(),\n+                                      args.len() as c_uint,\n+                                      then,\n+                                      catch,\n+                                      bundle,\n+                                      noname())\n         }\n     }\n \n@@ -775,7 +770,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                          comment_text.as_ptr(), noname(), False,\n                                          False)\n             };\n-            self.call(asm, &[], None, None);\n+            self.call(asm, &[], None);\n         }\n     }\n \n@@ -800,13 +795,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n-            self.call(v, inputs, None, None)\n+            self.call(v, inputs, None)\n         }\n     }\n \n     pub fn call(&self, llfn: ValueRef, args: &[ValueRef],\n-                bundle: Option<&OperandBundleDef>,\n-                attributes: Option<AttrBuilder>) -> ValueRef {\n+                bundle: Option<&OperandBundleDef>) -> ValueRef {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {:?} with args ({})\",\n@@ -844,22 +838,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n \n         unsafe {\n-            let v = llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n-                                            args.len() as c_uint, bundle,\n-                                            noname());\n-            if let Some(a) = attributes {\n-                a.apply_callsite(v);\n-            }\n-            v\n+            llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n+                                    args.len() as c_uint, bundle, noname())\n         }\n     }\n \n     pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n                           conv: CallConv,\n-                          bundle: Option<&OperandBundleDef>,\n-                          attributes: Option<AttrBuilder>) -> ValueRef {\n+                          bundle: Option<&OperandBundleDef>) -> ValueRef {\n         self.count_insn(\"callwithconv\");\n-        let v = self.call(llfn, args, bundle, attributes);\n+        let v = self.call(llfn, args, bundle);\n         llvm::SetInstructionCallConv(v, conv);\n         v\n     }"}, {"sha": "9236d29ca72af74e0d12ed8c15e5a3a3e9e275d3", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -27,7 +27,7 @@ use middle::subst;\n use middle::subst::{Substs};\n use middle::traits;\n use rustc::front::map as hir_map;\n-use trans::abi::Abi;\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n use trans::attributes;\n use trans::base;\n@@ -700,25 +700,31 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         };\n \n         // Invoke the actual rust fn and update bcx/llresult.\n-        let (llret, b) = base::invoke(bcx,\n-                                      datum.val,\n-                                      &llargs[..],\n-                                      datum.ty,\n-                                      debug_loc);\n+        let (llret, b) = base::invoke(bcx, datum.val, &llargs, debug_loc);\n+\n+        let fn_ty = match datum.ty.sty {\n+            ty::TyFnDef(_, _, f) | ty::TyFnPtr(f) => {\n+                let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n+                let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n+                FnType::new(bcx.ccx(), f.abi, &sig, &[])\n+            }\n+            _ => unreachable!(\"expected fn type\")\n+        };\n+\n+        if !bcx.unreachable.get() {\n+            fn_ty.apply_attrs_callsite(llret);\n+        }\n+\n         bcx = b;\n         llresult = llret;\n \n         // If the Rust convention for this type is return via\n         // the return value, copy it into llretslot.\n-        match (opt_llretslot, ret_ty) {\n-            (Some(llretslot), ty::FnConverging(ret_ty)) => {\n-                if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n-                    !common::type_is_zero_size(bcx.ccx(), ret_ty)\n-                {\n-                    store_ty(bcx, llret, llretslot, ret_ty)\n-                }\n+        if let Some(llretslot) = opt_llretslot {\n+            let llty = fn_ty.ret.original_ty;\n+            if !fn_ty.ret.is_indirect() && llty != Type::void(bcx.ccx()) {\n+                store_ty(bcx, llret, llretslot, ret_ty.unwrap())\n             }\n-            (_, _) => {}\n         }\n     } else {\n         // Lang items are the only case where dest is None, and"}, {"sha": "307c511b2a8c32853d159f26e2312549278e4cce", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -109,14 +109,11 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n         llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n     }\n \n-    let attrs = if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-        attributes::from_fn_type(ccx, fn_type)\n-    } else {\n+    if f.abi != Abi::Rust && f.abi != Abi::RustCall {\n         attributes::unwind(llfn, false);\n-        fty.llvm_attrs()\n-    };\n+    }\n \n-    attrs.apply_llfn(llfn);\n+    fty.apply_attrs_llfn(llfn);\n \n     llfn\n }"}, {"sha": "d03f4a3013c3eb9eb082efeaa0eb18e023592037", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -864,7 +864,6 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let expected = Call(bcx,\n                                 expect,\n                                 &[bounds_check, C_bool(ccx, false)],\n-                                None,\n                                 index_expr_debug_loc);\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n@@ -1681,10 +1680,10 @@ fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 if lhs_t == tcx.types.f32 {\n                     let lhs = FPExt(bcx, lhs, f64t);\n                     let rhs = FPExt(bcx, rhs, f64t);\n-                    let res = Call(bcx, llfn, &[lhs, rhs], None, binop_debug_loc);\n+                    let res = Call(bcx, llfn, &[lhs, rhs], binop_debug_loc);\n                     FPTrunc(bcx, res, Type::f32(bcx.ccx()))\n                 } else {\n-                    Call(bcx, llfn, &[lhs, rhs], None, binop_debug_loc)\n+                    Call(bcx, llfn, &[lhs, rhs], binop_debug_loc)\n                 }\n             } else {\n                 FRem(bcx, lhs, rhs, binop_debug_loc)\n@@ -2255,7 +2254,7 @@ impl OverflowOpViaIntrinsic {\n                                         -> (Block<'blk, 'tcx>, ValueRef) {\n         let llfn = self.to_intrinsic(bcx, lhs_t);\n \n-        let val = Call(bcx, llfn, &[lhs, rhs], None, binop_debug_loc);\n+        let val = Call(bcx, llfn, &[lhs, rhs], binop_debug_loc);\n         let result = ExtractValue(bcx, val, 0); // iN operation result\n         let overflow = ExtractValue(bcx, val, 1); // i1 \"did it overflow?\"\n \n@@ -2264,7 +2263,7 @@ impl OverflowOpViaIntrinsic {\n \n         let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n         Call(bcx, expect, &[cond, C_integral(Type::i1(bcx.ccx()), 0, false)],\n-             None, binop_debug_loc);\n+             binop_debug_loc);\n \n         let bcx =\n             base::with_cond(bcx, cond, |bcx|"}, {"sha": "50b11515effd31ebd21daa07f3bff272272ddd44", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -253,8 +253,10 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         llfn,\n                                         &llargs_foreign[..],\n                                         fn_type.cconv,\n-                                        Some(fn_type.llvm_attrs()),\n                                         call_debug_loc);\n+    if !bcx.unreachable.get() {\n+        fn_type.apply_attrs_callsite(llforeign_retval);\n+    }\n \n     // If the function we just called does not use an outpointer,\n     // store the result into the rust outpointer. Cast the outpointer\n@@ -347,20 +349,31 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let fnty = ccx.tcx().node_id_to_type(id);\n     let mty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fnty);\n-    let (fn_abi, fn_sig) = match mty.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n+    let f = match mty.sty {\n+        ty::TyFnDef(_, _, f) => f,\n         _ => ccx.sess().bug(\"trans_rust_fn_with_foreign_abi called on non-function type\")\n     };\n-    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n+    assert!(f.abi != Abi::Rust);\n+    assert!(f.abi != Abi::RustIntrinsic);\n+    assert!(f.abi != Abi::PlatformIntrinsic);\n+\n+    let fn_sig = ccx.tcx().erase_late_bound_regions(&f.sig);\n     let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n-    let fn_ty = FnType::new(ccx, fn_abi, &fn_sig, &[]);\n+    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ty::BareFnTy {\n+        unsafety: f.unsafety,\n+        abi: Abi::Rust,\n+        sig: ty::Binder(fn_sig.clone())\n+    });\n+    let fty = FnType::new(ccx, f.abi, &fn_sig, &[]);\n+    let rust_fty = FnType::new(ccx, Abi::Rust, &fn_sig, &[]);\n \n     unsafe { // unsafe because we call LLVM operations\n         // Build up the Rust function (`foo0` above).\n-        let llrustfn = build_rust_fn(ccx, decl, body, param_substs, attrs, id, hash);\n+        let llrustfn = build_rust_fn(ccx, decl, body, param_substs,\n+                                     attrs, id, rust_fn_ty, hash);\n \n         // Build up the foreign wrapper (`foo` above).\n-        return build_wrap_fn(ccx, llrustfn, llwrapfn, &fn_sig, &fn_ty, mty);\n+        return build_wrap_fn(ccx, llrustfn, llwrapfn, &fn_sig, &fty, &rust_fty);\n     }\n \n     fn build_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -369,13 +382,12 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                param_substs: &'tcx Substs<'tcx>,\n                                attrs: &[ast::Attribute],\n                                id: ast::NodeId,\n+                               rust_fn_ty: Ty<'tcx>,\n                                hash: Option<&str>)\n                                -> ValueRef\n     {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let tcx = ccx.tcx();\n-        let t = tcx.node_id_to_type(id);\n-        let t = monomorphize::apply_param_substs(tcx, param_substs, &t);\n \n         let path =\n             tcx.map.def_path(tcx.map.local_def_id(id))\n@@ -384,25 +396,6 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                    .chain(once(special_idents::clownshoe_abi.name.as_str()));\n         let ps = link::mangle(path, hash);\n \n-        // Compute the type that the function would have if it were just a\n-        // normal Rust function. This will be the type of the wrappee fn.\n-        let rust_fn_ty = match t.sty {\n-            ty::TyFnDef(_, _, ref f) => {\n-                assert!(f.abi != Abi::Rust);\n-                assert!(f.abi != Abi::RustIntrinsic);\n-                assert!(f.abi != Abi::PlatformIntrinsic);\n-                tcx.mk_fn_ptr(ty::BareFnTy {\n-                    unsafety: f.unsafety,\n-                    abi: Abi::Rust,\n-                    sig: f.sig.clone()\n-                })\n-            }\n-            _ => {\n-                unreachable!(\"build_rust_fn: extern fn {} has ty {:?}, \\\n-                              expected a fn item type\",\n-                              tcx.map.path_to_string(id), t);\n-            }\n-        };\n \n         debug!(\"build_rust_fn: path={} id={} ty={:?}\",\n                ccx.tcx().map.path_to_string(id),\n@@ -419,14 +412,13 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                       llwrapfn: ValueRef,\n                                       fn_sig: &ty::FnSig<'tcx>,\n                                       fn_ty: &FnType,\n-                                      t: Ty<'tcx>) {\n+                                      rust_fty: &FnType) {\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n \n-        debug!(\"build_wrap_fn(llrustfn={:?}, llwrapfn={:?}, t={:?})\",\n+        debug!(\"build_wrap_fn(llrustfn={:?}, llwrapfn={:?})\",\n                Value(llrustfn),\n-               Value(llwrapfn),\n-               t);\n+               Value(llwrapfn));\n \n         // Avoid all the Rust generation stuff and just generate raw\n         // LLVM here.\n@@ -615,11 +607,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         // Perform the call itself\n-        debug!(\"calling llrustfn = {:?}, t = {:?}\",\n-               Value(llrustfn), t);\n-        let attributes = attributes::from_fn_type(ccx, t);\n-        let llrust_ret_val = builder.call(llrustfn, &llrust_args,\n-                                          None, Some(attributes));\n+        debug!(\"calling llrustfn = {:?}\", Value(llrustfn));\n+        let llrust_ret_val = builder.call(llrustfn, &llrust_args, None);\n+        rust_fty.apply_attrs_callsite(llrust_ret_val);\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = fn_ty.ret.cast.unwrap_or(fn_ty.ret.original_ty);"}, {"sha": "6e31e7c571ab541a92a2aa1f334ac2d5bc292ea6", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -170,13 +170,13 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let may_need_drop =\n                     ICmp(bcx, llvm::IntNE, hint_val, moved_val, DebugLoc::None);\n                 bcx = with_cond(bcx, may_need_drop, |cx| {\n-                    Call(cx, glue, &[ptr], None, debug_loc);\n+                    Call(cx, glue, &[ptr], debug_loc);\n                     cx\n                 })\n             }\n             None => {\n                 // No drop-hint ==> call standard drop glue\n-                Call(bcx, glue, &[ptr], None, debug_loc);\n+                Call(bcx, glue, &[ptr], debug_loc);\n             }\n         }\n     }\n@@ -313,7 +313,7 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             And(bcx, not_init, not_done, DebugLoc::None);\n         with_cond(bcx, drop_flag_neither_initialized_nor_cleared, |cx| {\n             let llfn = cx.ccx().get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(cx, llfn, &[], None, DebugLoc::None);\n+            Call(cx, llfn, &[], DebugLoc::None);\n             cx\n         })\n     };\n@@ -583,7 +583,6 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n             Call(bcx,\n                  dtor,\n                  &[PointerCast(bcx, Load(bcx, data_ptr), Type::i8p(bcx.ccx()))],\n-                 None,\n                  DebugLoc::None);\n             bcx\n         }"}, {"sha": "171a1fe977d115b827e8146fb67717f2d9ac785f", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -407,7 +407,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // These are the only intrinsic functions that diverge.\n     if name == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n-        Call(bcx, llfn, &[], None, call_debug_location);\n+        Call(bcx, llfn, &[], call_debug_location);\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n@@ -442,11 +442,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let simple = get_simple_intrinsic(ccx, &name);\n     let llval = match (simple, &name[..]) {\n         (Some(llfn), _) => {\n-            Call(bcx, llfn, &llargs, None, call_debug_location)\n+            Call(bcx, llfn, &llargs, call_debug_location)\n         }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(bcx, llfn, &[], None, call_debug_location)\n+            Call(bcx, llfn, &[], call_debug_location)\n         }\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -636,13 +636,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         \"cttz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.cttz.i{}\", width),\n                                                         llargs[0], call_debug_location),\n                         \"ctpop\" => Call(bcx, ccx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n-                                        &llargs, None, call_debug_location),\n+                                        &llargs, call_debug_location),\n                         \"bswap\" => {\n                             if width == 8 {\n                                 llargs[0] // byte swap a u8/i8 is just a no-op\n                             } else {\n                                 Call(bcx, ccx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n-                                        &llargs, None, call_debug_location)\n+                                        &llargs, call_debug_location)\n                             }\n                         }\n                         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n@@ -951,7 +951,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let f = declare::declare_cfn(ccx,\n                                                  name,\n                                                  Type::func(&inputs, &outputs));\n-                    Call(bcx, f, &llargs, None, call_debug_location)\n+                    Call(bcx, f, &llargs, call_debug_location)\n                 }\n             };\n \n@@ -1024,7 +1024,6 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            Mul(bcx, size, count, DebugLoc::None),\n            align,\n            C_bool(ccx, volatile)],\n-         None,\n          call_debug_location)\n }\n \n@@ -1054,7 +1053,6 @@ fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            Mul(bcx, size, count, DebugLoc::None),\n            align,\n            C_bool(ccx, volatile)],\n-         None,\n          call_debug_location)\n }\n \n@@ -1065,7 +1063,7 @@ fn count_zeros_intrinsic(bcx: Block,\n                          -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n-    Call(bcx, llfn, &[val, y], None, call_debug_location)\n+    Call(bcx, llfn, &[val, y], call_debug_location)\n }\n \n fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -1078,7 +1076,7 @@ fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let llfn = bcx.ccx().get_intrinsic(&name);\n \n     // Convert `i1` to a `bool`, and write it to the out parameter\n-    let val = Call(bcx, llfn, &[a, b], None, call_debug_location);\n+    let val = Call(bcx, llfn, &[a, b], call_debug_location);\n     let result = ExtractValue(bcx, val, 0);\n     let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n     Store(bcx, result, StructGEP(bcx, out, 0));\n@@ -1094,7 +1092,7 @@ fn try_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              dest: ValueRef,\n                              dloc: DebugLoc) -> Block<'blk, 'tcx> {\n     if bcx.sess().no_landing_pads() {\n-        Call(bcx, func, &[data], None, dloc);\n+        Call(bcx, func, &[data], dloc);\n         Store(bcx, C_null(Type::i8p(bcx.ccx())), dest);\n         bcx\n     } else if wants_msvc_seh(bcx.sess()) {\n@@ -1165,9 +1163,9 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // More information can be found in libstd's seh.rs implementation.\n         let slot = Alloca(bcx, Type::i8p(ccx), \"slot\");\n         let localescape = ccx.get_intrinsic(&\"llvm.localescape\");\n-        Call(bcx, localescape, &[slot], None, dloc);\n+        Call(bcx, localescape, &[slot], dloc);\n         Store(bcx, local_ptr, slot);\n-        Invoke(bcx, func, &[data], normal.llbb, catchswitch.llbb, None, dloc);\n+        Invoke(bcx, func, &[data], normal.llbb, catchswitch.llbb, dloc);\n \n         Ret(normal, C_i32(ccx, 0), dloc);\n \n@@ -1184,7 +1182,7 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = Call(bcx, llfn, &[func, data, local_ptr], None, dloc);\n+    let ret = Call(bcx, llfn, &[func, data, local_ptr], dloc);\n     Store(bcx, ret, dest);\n     return bcx\n }\n@@ -1242,7 +1240,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let func = llvm::get_param(bcx.fcx.llfn, 0);\n         let data = llvm::get_param(bcx.fcx.llfn, 1);\n         let local_ptr = llvm::get_param(bcx.fcx.llfn, 2);\n-        Invoke(bcx, func, &[data], then.llbb, catch.llbb, None, dloc);\n+        Invoke(bcx, func, &[data], then.llbb, catch.llbb, dloc);\n         Ret(then, C_i32(ccx, 0), dloc);\n \n         // Type indicator for the exception being thrown.\n@@ -1262,7 +1260,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = Call(bcx, llfn, &[func, data, local_ptr], None, dloc);\n+    let ret = Call(bcx, llfn, &[func, data, local_ptr], dloc);\n     Store(bcx, ret, dest);\n     return bcx;\n }\n@@ -1376,11 +1374,10 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     // For more info, see seh.rs in the standard library.\n     let do_trans = |bcx: Block, ehptrs, base_pointer| {\n         let rust_try_fn = BitCast(bcx, rust_try_fn, Type::i8p(ccx));\n-        let parentfp = Call(bcx, recoverfp, &[rust_try_fn, base_pointer],\n-                            None, dloc);\n+        let parentfp = Call(bcx, recoverfp, &[rust_try_fn, base_pointer], dloc);\n         let arg = Call(bcx, localrecover,\n-                       &[rust_try_fn, parentfp, C_i32(ccx, 0)], None, dloc);\n-        let ret = Call(bcx, rust_try_filter, &[ehptrs, arg], None, dloc);\n+                       &[rust_try_fn, parentfp, C_i32(ccx, 0)], dloc);\n+        let ret = Call(bcx, rust_try_filter, &[ehptrs, arg], dloc);\n         Ret(bcx, ret, dloc);\n     };\n \n@@ -1402,7 +1399,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n             }),\n         });\n         gen_fn(fcx, \"__rustc_try_filter\", filter_fn_ty, output, &mut |bcx| {\n-            let ebp = Call(bcx, frameaddress, &[C_i32(ccx, 1)], None, dloc);\n+            let ebp = Call(bcx, frameaddress, &[C_i32(ccx, 1)], dloc);\n             let exn = InBoundsGEP(bcx, ebp, &[C_i32(ccx, -20)]);\n             let exn = Load(bcx, BitCast(bcx, exn, Type::i8p(ccx).ptr_to()));\n             do_trans(bcx, exn, ebp);"}, {"sha": "a91b2dfcf9253a9c5c85f532eb1cb51a39506130", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use llvm::{BasicBlockRef, ValueRef, OperandBundleDef};\n-use rustc::middle::ty;\n+use rustc::middle::{infer, ty};\n use rustc::mir::repr as mir;\n-use trans::abi::Abi;\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n-use trans::attributes;\n use trans::base;\n use trans::build;\n use trans::callee::{Callee, Fn, Virtual};\n@@ -141,11 +140,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                &[llvalue],\n                                self.llblock(target),\n                                unwind.llbb(),\n-                               cleanup_bundle.as_ref(),\n-                               None);\n+                               cleanup_bundle.as_ref());\n                     self.bcx(target).at_start(|bcx| drop::drop_fill(bcx, lvalue.llval, ty));\n                 } else {\n-                    bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref(), None);\n+                    bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref());\n                     drop::drop_fill(&bcx, lvalue.llval, ty);\n                     funclet_br(bcx, self.llblock(target));\n                 }\n@@ -244,7 +242,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                     datum\n                 };\n-                let attrs = attributes::from_fn_type(bcx.ccx(), datum.ty);\n+\n+                let fn_ty = match datum.ty.sty {\n+                    ty::TyFnDef(_, _, f) | ty::TyFnPtr(f) => {\n+                        let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n+                        let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n+                        FnType::new(bcx.ccx(), f.abi, &sig, &[])\n+                    }\n+                    _ => unreachable!(\"expected fn type\")\n+                };\n \n                 // Many different ways to call a function handled here\n                 match (is_foreign, cleanup, destination) {\n@@ -253,12 +259,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let unreachable_blk = self.unreachable_block();\n-                        bcx.invoke(datum.val,\n-                                   &llargs[..],\n-                                   unreachable_blk.llbb,\n-                                   landingpad.llbb(),\n-                                   cleanup_bundle.as_ref(),\n-                                   Some(attrs));\n+                        let cs = bcx.invoke(datum.val,\n+                                            &llargs[..],\n+                                            unreachable_blk.llbb,\n+                                            landingpad.llbb(),\n+                                            cleanup_bundle.as_ref());\n+                        fn_ty.apply_attrs_callsite(cs);\n                         landingpad.at_start(|bcx| for op in args {\n                             self.set_operand_dropped(bcx, op);\n                         });\n@@ -270,8 +276,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                    &llargs[..],\n                                                    self.llblock(success),\n                                                    landingpad.llbb(),\n-                                                   cleanup_bundle.as_ref(),\n-                                                   Some(attrs));\n+                                                   cleanup_bundle.as_ref());\n+                        fn_ty.apply_attrs_callsite(invokeret);\n                         if must_copy_dest {\n                             let (ret_dest, ret_ty) = ret_dest_ty\n                                 .expect(\"return destination and type not set\");\n@@ -289,18 +295,18 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         });\n                     },\n                     (false, _, &None) => {\n-                        bcx.call(datum.val,\n-                                 &llargs[..],\n-                                 cleanup_bundle.as_ref(),\n-                                 Some(attrs));\n+                        let cs = bcx.call(datum.val,\n+                                          &llargs[..],\n+                                          cleanup_bundle.as_ref());\n+                        fn_ty.apply_attrs_callsite(cs);\n                         // no need to drop args, because the call never returns\n                         bcx.unreachable();\n                     }\n                     (false, _, &Some((_, target))) => {\n                         let llret = bcx.call(datum.val,\n                                              &llargs[..],\n-                                             cleanup_bundle.as_ref(),\n-                                             Some(attrs));\n+                                             cleanup_bundle.as_ref());\n+                        fn_ty.apply_attrs_callsite(llret);\n                         if must_copy_dest {\n                             let (ret_dest, ret_ty) = ret_dest_ty\n                                 .expect(\"return destination and type not set\");"}, {"sha": "cf4c2dfd99b2727d3386e010a447830d3721f911", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f34841489767804ffe3d0f20d5469ecc5cf417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=77f34841489767804ffe3d0f20d5469ecc5cf417", "patch": "@@ -515,10 +515,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if input_ty == tcx.types.f32 {\n                         let lllhs = bcx.fpext(lhs, f64t);\n                         let llrhs = bcx.fpext(rhs, f64t);\n-                        let llres = bcx.call(llfn, &[lllhs, llrhs], None, None);\n+                        let llres = bcx.call(llfn, &[lllhs, llrhs], None);\n                         bcx.fptrunc(llres, Type::f32(bcx.ccx()))\n                     } else {\n-                        bcx.call(llfn, &[lhs, rhs], None, None)\n+                        bcx.call(llfn, &[lhs, rhs], None)\n                     }\n                 } else {\n                     bcx.frem(lhs, rhs)"}]}