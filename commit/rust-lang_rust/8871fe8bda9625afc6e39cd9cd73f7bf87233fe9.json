{"sha": "8871fe8bda9625afc6e39cd9cd73f7bf87233fe9", "node_id": "C_kwDOAAsO6NoAKDg4NzFmZThiZGE5NjI1YWZjNmUzOWNkOWNkNzNmN2JmODcyMzNmZTk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-10-26T17:32:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-26T17:32:44Z"}, "message": "Rollup merge of #90296 - CAD97:rip-lerp, r=Mark-Simulacrum\n\nRemove fNN::lerp\n\nLerp is [surprisingly complex with multiple tradeoffs depending on what guarantees you want to provide](https://github.com/rust-lang/rust/issues/86269#issuecomment-869108301) (and what you're willing to drop for raw speed), so we don't have consensus on what implementation to use, let alone what signature - `t.lerp(a, b)` nicely puts `a, b` together, but makes dispatch to lerp custom types with the same signature basically impossible, and major ecosystem crates (e.g. nalgebra, glium) use `a.lerp(b, t)`, which is easily confusable. It was suggested to maybe provide a `Lerp<T>` trait and `t.lerp([a, b])`, which _could_ be implemented by downstream math libraries for their types, but also significantly raises the bar from a simple fNN method to a full trait, and does nothing to solve the implementation question. (It also raises the question of whether we'd support higher-order bezier interpolation.)\n\nThe only consensus we have is the lack of consensus, and the [general temperature](https://github.com/rust-lang/rust/issues/86269#issuecomment-951347135) is that we should just remove this method (giving the method space back to 3rd party libs) and revisit this if (and likely only if) IEEE adds lerp to their specification.\n\nIf people want a lerp, they're _probably_ already using (or writing) a math support library, which provides a lerp function for its custom math types and can provide the same lerp implementation for the primitive types via an extension trait.\n\nSee also [previous Zulip discussion](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/lerp.20API.20design)\n\ncc ``@clarfonthey`` (original PR author), ``@m-ou-se`` (original r+), ``@scottmcm`` (last voice in tracking issue, prompted me to post this)\n\nCloses #86269 (removed)", "tree": {"sha": "608fec5b677bdf9e3a124afc9341c09674b7cd4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/608fec5b677bdf9e3a124afc9341c09674b7cd4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJheDu8CRBK7hj4Ov3rIwAABX4IAKVCpI/bp+GujBOx9pAa25cc\nhlBEnsBXMJakeqOM1zs8lMacqyVJzG6GwbhP03U8FEEDtAev8eL2f47kFFYP0O9o\nt5NtaneTdsn3wbn0GSSvVP1GY/ExMynz1YvR46w0fT0069p8hnLtayHcFwZDiqAQ\nxGNhz/OTVrJqxrQqH6EJWvwD0cc7RQWd4OXG2hdeid/rH15VEjptUogM1iYnaEHD\nk+aQYrLF/S1FVyBVTstGU7ED/f2AqsMO1kiE4Ex/fkfOL7sscO7c7DrWP9qHc39b\nTxv6QgBJguLFX6rcfY3VfegIDNVKvOQ9mfzHICmueWX/LsbYa10hFjku0hOM6KU=\n=bSp2\n-----END PGP SIGNATURE-----\n", "payload": "tree 608fec5b677bdf9e3a124afc9341c09674b7cd4b\nparent 3c8f001d454b1b495f7472d8430ef8fdf10aac11\nparent 6b449b49bb52b6eb92dd7fc1611f5e0e2564f323\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1635269564 +0200\ncommitter GitHub <noreply@github.com> 1635269564 +0200\n\nRollup merge of #90296 - CAD97:rip-lerp, r=Mark-Simulacrum\n\nRemove fNN::lerp\n\nLerp is [surprisingly complex with multiple tradeoffs depending on what guarantees you want to provide](https://github.com/rust-lang/rust/issues/86269#issuecomment-869108301) (and what you're willing to drop for raw speed), so we don't have consensus on what implementation to use, let alone what signature - `t.lerp(a, b)` nicely puts `a, b` together, but makes dispatch to lerp custom types with the same signature basically impossible, and major ecosystem crates (e.g. nalgebra, glium) use `a.lerp(b, t)`, which is easily confusable. It was suggested to maybe provide a `Lerp<T>` trait and `t.lerp([a, b])`, which _could_ be implemented by downstream math libraries for their types, but also significantly raises the bar from a simple fNN method to a full trait, and does nothing to solve the implementation question. (It also raises the question of whether we'd support higher-order bezier interpolation.)\n\nThe only consensus we have is the lack of consensus, and the [general temperature](https://github.com/rust-lang/rust/issues/86269#issuecomment-951347135) is that we should just remove this method (giving the method space back to 3rd party libs) and revisit this if (and likely only if) IEEE adds lerp to their specification.\n\nIf people want a lerp, they're _probably_ already using (or writing) a math support library, which provides a lerp function for its custom math types and can provide the same lerp implementation for the primitive types via an extension trait.\n\nSee also [previous Zulip discussion](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/lerp.20API.20design)\n\ncc ``@clarfonthey`` (original PR author), ``@m-ou-se`` (original r+), ``@scottmcm`` (last voice in tracking issue, prompted me to post this)\n\nCloses #86269 (removed)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9", "html_url": "https://github.com/rust-lang/rust/commit/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c8f001d454b1b495f7472d8430ef8fdf10aac11", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c8f001d454b1b495f7472d8430ef8fdf10aac11", "html_url": "https://github.com/rust-lang/rust/commit/3c8f001d454b1b495f7472d8430ef8fdf10aac11"}, {"sha": "6b449b49bb52b6eb92dd7fc1611f5e0e2564f323", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b449b49bb52b6eb92dd7fc1611f5e0e2564f323", "html_url": "https://github.com/rust-lang/rust/commit/6b449b49bb52b6eb92dd7fc1611f5e0e2564f323"}], "stats": {"total": 191, "additions": 0, "deletions": 191}, "files": [{"sha": "d23f5244d88d4e4f9999509c23900fcec7515bc5", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=8871fe8bda9625afc6e39cd9cd73f7bf87233fe9", "patch": "@@ -878,40 +878,4 @@ impl f32 {\n     pub fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n-\n-    /// Linear interpolation between `start` and `end`.\n-    ///\n-    /// This enables linear interpolation between `start` and `end`, where start is represented by\n-    /// `self == 0.0` and `end` is represented by `self == 1.0`. This is the basis of all\n-    /// \"transition\", \"easing\", or \"step\" functions; if you change `self` from 0.0 to 1.0\n-    /// at a given rate, the result will change from `start` to `end` at a similar rate.\n-    ///\n-    /// Values below 0.0 or above 1.0 are allowed, allowing you to extrapolate values outside the\n-    /// range from `start` to `end`. This also is useful for transition functions which might\n-    /// move slightly past the end or start for a desired effect. Mathematically, the values\n-    /// returned are equivalent to `start + self * (end - start)`, although we make a few specific\n-    /// guarantees that are useful specifically to linear interpolation.\n-    ///\n-    /// These guarantees are:\n-    ///\n-    /// * If `start` and `end` are [finite], the value at 0.0 is always `start` and the\n-    ///   value at 1.0 is always `end`. (exactness)\n-    /// * If `start` and `end` are [finite], the values will always move in the direction from\n-    ///   `start` to `end` (monotonicity)\n-    /// * If `self` is [finite] and `start == end`, the value at any point will always be\n-    ///   `start == end`. (consistency)\n-    ///\n-    /// [finite]: #method.is_finite\n-    #[must_use = \"method returns a new number and does not mutate the original value\"]\n-    #[unstable(feature = \"float_interpolation\", issue = \"86269\")]\n-    pub fn lerp(self, start: f32, end: f32) -> f32 {\n-        // consistent\n-        if start == end {\n-            start\n-\n-        // exact/monotonic\n-        } else {\n-            self.mul_add(end, (-self).mul_add(start, start))\n-        }\n-    }\n }"}, {"sha": "0d4b865f3392a66304e13e47e9fa652099428534", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=8871fe8bda9625afc6e39cd9cd73f7bf87233fe9", "patch": "@@ -757,66 +757,3 @@ fn test_total_cmp() {\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::INFINITY));\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n }\n-\n-#[test]\n-fn test_lerp_exact() {\n-    // simple values\n-    assert_eq!(f32::lerp(0.0, 2.0, 4.0), 2.0);\n-    assert_eq!(f32::lerp(1.0, 2.0, 4.0), 4.0);\n-\n-    // boundary values\n-    assert_eq!(f32::lerp(0.0, f32::MIN, f32::MAX), f32::MIN);\n-    assert_eq!(f32::lerp(1.0, f32::MIN, f32::MAX), f32::MAX);\n-}\n-\n-#[test]\n-fn test_lerp_consistent() {\n-    assert_eq!(f32::lerp(f32::MAX, f32::MIN, f32::MIN), f32::MIN);\n-    assert_eq!(f32::lerp(f32::MIN, f32::MAX, f32::MAX), f32::MAX);\n-\n-    // as long as t is finite, a/b can be infinite\n-    assert_eq!(f32::lerp(f32::MAX, f32::NEG_INFINITY, f32::NEG_INFINITY), f32::NEG_INFINITY);\n-    assert_eq!(f32::lerp(f32::MIN, f32::INFINITY, f32::INFINITY), f32::INFINITY);\n-}\n-\n-#[test]\n-fn test_lerp_nan_infinite() {\n-    // non-finite t is not NaN if a/b different\n-    assert!(!f32::lerp(f32::INFINITY, f32::MIN, f32::MAX).is_nan());\n-    assert!(!f32::lerp(f32::NEG_INFINITY, f32::MIN, f32::MAX).is_nan());\n-}\n-\n-#[test]\n-fn test_lerp_values() {\n-    // just a few basic values\n-    assert_eq!(f32::lerp(0.25, 1.0, 2.0), 1.25);\n-    assert_eq!(f32::lerp(0.50, 1.0, 2.0), 1.50);\n-    assert_eq!(f32::lerp(0.75, 1.0, 2.0), 1.75);\n-}\n-\n-#[test]\n-fn test_lerp_monotonic() {\n-    // near 0\n-    let below_zero = f32::lerp(-f32::EPSILON, f32::MIN, f32::MAX);\n-    let zero = f32::lerp(0.0, f32::MIN, f32::MAX);\n-    let above_zero = f32::lerp(f32::EPSILON, f32::MIN, f32::MAX);\n-    assert!(below_zero <= zero);\n-    assert!(zero <= above_zero);\n-    assert!(below_zero <= above_zero);\n-\n-    // near 0.5\n-    let below_half = f32::lerp(0.5 - f32::EPSILON, f32::MIN, f32::MAX);\n-    let half = f32::lerp(0.5, f32::MIN, f32::MAX);\n-    let above_half = f32::lerp(0.5 + f32::EPSILON, f32::MIN, f32::MAX);\n-    assert!(below_half <= half);\n-    assert!(half <= above_half);\n-    assert!(below_half <= above_half);\n-\n-    // near 1\n-    let below_one = f32::lerp(1.0 - f32::EPSILON, f32::MIN, f32::MAX);\n-    let one = f32::lerp(1.0, f32::MIN, f32::MAX);\n-    let above_one = f32::lerp(1.0 + f32::EPSILON, f32::MIN, f32::MAX);\n-    assert!(below_one <= one);\n-    assert!(one <= above_one);\n-    assert!(below_one <= above_one);\n-}"}, {"sha": "55e17b471905d29dd293be5e2db9a494e9a55d5c", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=8871fe8bda9625afc6e39cd9cd73f7bf87233fe9", "patch": "@@ -881,42 +881,6 @@ impl f64 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n \n-    /// Linear interpolation between `start` and `end`.\n-    ///\n-    /// This enables linear interpolation between `start` and `end`, where start is represented by\n-    /// `self == 0.0` and `end` is represented by `self == 1.0`. This is the basis of all\n-    /// \"transition\", \"easing\", or \"step\" functions; if you change `self` from 0.0 to 1.0\n-    /// at a given rate, the result will change from `start` to `end` at a similar rate.\n-    ///\n-    /// Values below 0.0 or above 1.0 are allowed, allowing you to extrapolate values outside the\n-    /// range from `start` to `end`. This also is useful for transition functions which might\n-    /// move slightly past the end or start for a desired effect. Mathematically, the values\n-    /// returned are equivalent to `start + self * (end - start)`, although we make a few specific\n-    /// guarantees that are useful specifically to linear interpolation.\n-    ///\n-    /// These guarantees are:\n-    ///\n-    /// * If `start` and `end` are [finite], the value at 0.0 is always `start` and the\n-    ///   value at 1.0 is always `end`. (exactness)\n-    /// * If `start` and `end` are [finite], the values will always move in the direction from\n-    ///   `start` to `end` (monotonicity)\n-    /// * If `self` is [finite] and `start == end`, the value at any point will always be\n-    ///   `start == end`. (consistency)\n-    ///\n-    /// [finite]: #method.is_finite\n-    #[must_use = \"method returns a new number and does not mutate the original value\"]\n-    #[unstable(feature = \"float_interpolation\", issue = \"86269\")]\n-    pub fn lerp(self, start: f64, end: f64) -> f64 {\n-        // consistent\n-        if start == end {\n-            start\n-\n-        // exact/monotonic\n-        } else {\n-            self.mul_add(end, (-self).mul_add(start, start))\n-        }\n-    }\n-\n     // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n     // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n     // of expected NaN)."}, {"sha": "5c163cfe90e0b2eff9030bc80dd0cfeb4c71532c", "filename": "library/std/src/f64/tests.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs?ref=8871fe8bda9625afc6e39cd9cd73f7bf87233fe9", "patch": "@@ -753,58 +753,3 @@ fn test_total_cmp() {\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::INFINITY));\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n }\n-\n-#[test]\n-fn test_lerp_exact() {\n-    // simple values\n-    assert_eq!(f64::lerp(0.0, 2.0, 4.0), 2.0);\n-    assert_eq!(f64::lerp(1.0, 2.0, 4.0), 4.0);\n-\n-    // boundary values\n-    assert_eq!(f64::lerp(0.0, f64::MIN, f64::MAX), f64::MIN);\n-    assert_eq!(f64::lerp(1.0, f64::MIN, f64::MAX), f64::MAX);\n-}\n-\n-#[test]\n-fn test_lerp_consistent() {\n-    assert_eq!(f64::lerp(f64::MAX, f64::MIN, f64::MIN), f64::MIN);\n-    assert_eq!(f64::lerp(f64::MIN, f64::MAX, f64::MAX), f64::MAX);\n-\n-    // as long as t is finite, a/b can be infinite\n-    assert_eq!(f64::lerp(f64::MAX, f64::NEG_INFINITY, f64::NEG_INFINITY), f64::NEG_INFINITY);\n-    assert_eq!(f64::lerp(f64::MIN, f64::INFINITY, f64::INFINITY), f64::INFINITY);\n-}\n-\n-#[test]\n-fn test_lerp_nan_infinite() {\n-    // non-finite t is not NaN if a/b different\n-    assert!(!f64::lerp(f64::INFINITY, f64::MIN, f64::MAX).is_nan());\n-    assert!(!f64::lerp(f64::NEG_INFINITY, f64::MIN, f64::MAX).is_nan());\n-}\n-\n-#[test]\n-fn test_lerp_values() {\n-    // just a few basic values\n-    assert_eq!(f64::lerp(0.25, 1.0, 2.0), 1.25);\n-    assert_eq!(f64::lerp(0.50, 1.0, 2.0), 1.50);\n-    assert_eq!(f64::lerp(0.75, 1.0, 2.0), 1.75);\n-}\n-\n-#[test]\n-fn test_lerp_monotonic() {\n-    // near 0\n-    let below_zero = f64::lerp(-f64::EPSILON, f64::MIN, f64::MAX);\n-    let zero = f64::lerp(0.0, f64::MIN, f64::MAX);\n-    let above_zero = f64::lerp(f64::EPSILON, f64::MIN, f64::MAX);\n-    assert!(below_zero <= zero);\n-    assert!(zero <= above_zero);\n-    assert!(below_zero <= above_zero);\n-\n-    // near 1\n-    let below_one = f64::lerp(1.0 - f64::EPSILON, f64::MIN, f64::MAX);\n-    let one = f64::lerp(1.0, f64::MIN, f64::MAX);\n-    let above_one = f64::lerp(1.0 + f64::EPSILON, f64::MIN, f64::MAX);\n-    assert!(below_one <= one);\n-    assert!(one <= above_one);\n-    assert!(below_one <= above_one);\n-}"}, {"sha": "d7c0ffd476a59f8454020868b8cf0ab35014399c", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871fe8bda9625afc6e39cd9cd73f7bf87233fe9/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=8871fe8bda9625afc6e39cd9cd73f7bf87233fe9", "patch": "@@ -284,7 +284,6 @@\n #![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]\n-#![feature(float_interpolation)]\n #![feature(fn_traits)]\n #![feature(format_args_nl)]\n #![feature(gen_future)]"}]}