{"sha": "07a3ede5f2ee2db963b73453f43126a71f5092bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YTNlZGU1ZjJlZTJkYjk2M2I3MzQ1M2Y0MzEyNmE3MWY1MDkyYmQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-26T22:43:00Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "Return DiagnosticBuilder to add help suggestions", "tree": {"sha": "e356a617086291c1492ed79adc08eaeb859dfb10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e356a617086291c1492ed79adc08eaeb859dfb10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07a3ede5f2ee2db963b73453f43126a71f5092bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07a3ede5f2ee2db963b73453f43126a71f5092bd", "html_url": "https://github.com/rust-lang/rust/commit/07a3ede5f2ee2db963b73453f43126a71f5092bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07a3ede5f2ee2db963b73453f43126a71f5092bd/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "021d97d1c5e053176961970ccbcad9f2802e9c91", "url": "https://api.github.com/repos/rust-lang/rust/commits/021d97d1c5e053176961970ccbcad9f2802e9c91", "html_url": "https://github.com/rust-lang/rust/commit/021d97d1c5e053176961970ccbcad9f2802e9c91"}], "stats": {"total": 233, "additions": 50, "deletions": 183}, "files": [{"sha": "a67af1d5dcc3c206b7eac9b370330ee9ab79f50a", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=07a3ede5f2ee2db963b73453f43126a71f5092bd", "patch": "@@ -90,7 +90,6 @@ use ty::error::TypeError;\n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n-//use std::rc::Rc;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n@@ -234,22 +233,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/*struct MethodInfo<'tcx> {\n-    ast: Option<ast::Attribute>,\n-    id: DefId,\n-    item: Rc<ImplOrTraitItem<'tcx>>,\n-}\n-\n-impl<'tcx> MethodInfo<'tcx> {\n-    fn new(ast: Option<ast::Attribute>, id: DefId, item: Rc<ImplOrTraitItem<'tcx>>) -> MethodInfo {\n-        MethodInfo {\n-            ast: ast,\n-            id: id,\n-            item: item,\n-        }\n-    }\n-}*/\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_region_errors(&self,\n                                 errors: &Vec<RegionResolutionError<'tcx>>) {\n@@ -599,54 +582,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     diag.note_expected_found(&\"type\", &expected, &found);\n                 }\n             }\n-\n-            //if let Some((found, (expected_ty, expected))) = self.get_ids(values) {\n-                // look for expected with found id\n-                /*self.tcx.populate_inherent_implementations_for_type_if_necessary(found);\n-                if let Some(impl_infos) = self.tcx.inherent_impls.borrow().get(&found) {\n-                    let mut methods: Vec<MethodInfo> = Vec::new();\n-                    for impl_ in impl_infos {\n-                        methods.append(&mut self.tcx\n-                                                .impl_or_trait_items(*impl_)\n-                                                .iter()\n-                                                .map(|&did| MethodInfo::new(None, did, Rc::new(self.tcx.impl_or_trait_item(did))))\n-                                                .filter(|ref x| {\n-                                                    self.matches_return_type(&*x.item, &expected_ty)\n-                                                })\n-                                                .collect());\n-                    }\n-                    for did in self.tcx.sess.cstore.implementations_of_trait(None) {\n-                        if did == found {\n-                            methods.append(\n-                                self.tcx.sess.cstore.impl_or_trait_items(did)\n-                                                    .iter()\n-                                                    .map(|&did| MethodInfo::new(None, did, Rc::new(self.tcx.impl_or_trait_item(did))))\n-                                                    .filter(|ref x| {\n-                                                        self.matches_return_type(&*x.item, &expected_ty)\n-                                                    })\n-                                                    .collect());\n-                            ;\n-                        }\n-                    }\n-                    let safe_suggestions: Vec<_> =\n-                        methods.iter()\n-                               .map(|ref x| MethodInfo::new(self.find_attr(x.id, \"safe_suggestion\"), x.id, x.item.clone()))\n-                               .filter(|ref x| x.ast.is_some())\n-                               .collect();\n-                    if safe_suggestions.len() > 0 {\n-                        println!(\"safe\");\n-                        self.get_best_match(&safe_suggestions);\n-                    } else {\n-                        println!(\"not safe\");\n-                        self.get_best_match(&methods);\n-                    }*/\n-                    /*let mode = probe::Mode::MethodCall;\n-                    if let Ok(ret) = self.probe_return(DUMMY_SP, mode, expected, found,                               DUMMY_NODE_ID) {\n-                        println!(\"got it\");\n-                    } else {\n-                        println!(\"sad...\");\n-                    }*/\n-            //}\n         }\n \n         diag.span_label(span, &terr);\n@@ -659,32 +594,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.note_and_explain_type_err(diag, terr, span);\n     }\n \n-    /*fn get_best_match(&self, methods: &[MethodInfo<'tcx>]) -> String {\n-        let no_argument_methods: Vec<&MethodInfo> =\n-            methods.iter()\n-                   .filter(|ref x| self.has_not_input_arg(&*x.item))\n-                   .collect();\n-        if no_argument_methods.len() > 0 {\n-            for ref method in no_argument_methods {\n-                println!(\"best match ==> {:?}\", method.item.name());\n-            }\n-        } else {\n-            for ref method in methods.iter() {\n-                println!(\"not best ==> {:?}\", method.item.name());\n-            }\n-        }\n-        String::new()\n-    }\n-\n-    fn find_attr(&self, def_id: DefId, attr_name: &str) -> Option<ast::Attribute> {\n-        for item in self.tcx.get_attrs(def_id).iter() {\n-            if item.check_name(attr_name) {\n-                return Some(item.clone());\n-            }\n-        }\n-        None\n-    }*/\n-\n     pub fn report_and_explain_type_error(&self,\n                                          trace: TypeTrace<'tcx>,\n                                          terr: &TypeError<'tcx>)\n@@ -713,69 +622,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /*fn has_not_input_arg(&self, method: &ImplOrTraitItem<'tcx>) -> bool {\n-        match *method {\n-            ImplOrTraitItem::MethodTraitItem(ref x) => {\n-                x.fty.sig.skip_binder().inputs.len() == 1\n-            }\n-            _ => false,\n-        }\n-    }\n-\n-    fn matches_return_type(&self, method: &ImplOrTraitItem<'tcx>, expected: &ty::Ty<'tcx>) -> bool {\n-        match *method {\n-            ImplOrTraitItem::MethodTraitItem(ref x) => {\n-                self.can_sub_types(x.fty.sig.skip_binder().output, expected).is_ok()\n-            }\n-            _ => false,\n-        }\n-    }\n-\n-    fn get_id(&self, ty: Ty<'tcx>) -> Option<DefId> {\n-        match ty.sty {\n-            ty::TyTrait(box ref data) => Some(data.principal.def_id()),\n-            ty::TyAdt(def, _) => Some(def.did),\n-            ty::TyBox(ref ty) => self.get_id(*ty), // since we don't want box's methods by type's\n-            ty::TyChar => self.tcx.lang_items.char_impl(),\n-            ty::TyStr => self.tcx.lang_items.str_impl(),\n-            ty::TySlice(_) => self.tcx.lang_items.slice_impl(),\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                self.tcx.lang_items.const_ptr_impl()\n-            }\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                self.tcx.lang_items.mut_ptr_impl()\n-            }\n-            ty::TyInt(ast::IntTy::I8) => self.tcx.lang_items.i8_impl(),\n-            ty::TyInt(ast::IntTy::I16) => self.tcx.lang_items.i16_impl(),\n-            ty::TyInt(ast::IntTy::I32) => self.tcx.lang_items.i32_impl(),\n-            ty::TyInt(ast::IntTy::I64) => self.tcx.lang_items.i64_impl(),\n-            ty::TyInt(ast::IntTy::Is) => self.tcx.lang_items.isize_impl(),\n-            ty::TyUint(ast::UintTy::U8) => self.tcx.lang_items.u8_impl(),\n-            ty::TyUint(ast::UintTy::U16) => self.tcx.lang_items.u16_impl(),\n-            ty::TyUint(ast::UintTy::U32) => self.tcx.lang_items.u32_impl(),\n-            ty::TyUint(ast::UintTy::U64) => self.tcx.lang_items.u64_impl(),\n-            ty::TyUint(ast::UintTy::Us) => self.tcx.lang_items.usize_impl(),\n-            ty::TyFloat(ast::FloatTy::F32) => self.tcx.lang_items.f32_impl(),\n-            ty::TyFloat(ast::FloatTy::F64) => self.tcx.lang_items.f64_impl(),\n-            _ => None,\n-        }\n-    }\n-\n-    // Yep, returned value super ugly. it'll certainly become `Option<(DefId, ty::Ty<'tcx>)>`\n-    // in a close future. Or maybe a struct?\n-    fn get_ids(&self, values: Option<ValuePairs<'tcx>>) -> Option<(DefId, (ty::Ty<'tcx>, DefId))> {\n-        match values {\n-            // for now, only handling non trait types\n-            Some(infer::Types(ref exp_found)) => {\n-                match (self.get_id(exp_found.found), self.get_id(exp_found.expected)) {\n-                    (Some(found), Some(expected)) => Some((found, (exp_found.expected, expected))),\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-    }*/\n-\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)"}, {"sha": "6bbe40950b75f20780d584235c239bbffabc1a45", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=07a3ede5f2ee2db963b73453f43126a71f5092bd", "patch": "@@ -1367,9 +1367,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                    cause: &ObligationCause<'tcx>,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: TypeError<'tcx>) {\n+                                   err: TypeError<'tcx>) -> DiagnosticBuilder<'tcx> {\n         let trace = TypeTrace::types(cause, true, expected, actual);\n-        self.report_and_explain_type_error(trace, &err).emit();\n+        self.report_and_explain_type_error(trace, &err)\n     }\n \n     pub fn report_conflicting_default_types(&self,"}, {"sha": "ff50ee11b390e674a703b9cdd9837a22676da5af", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=07a3ede5f2ee2db963b73453f43126a71f5092bd", "patch": "@@ -481,7 +481,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         (result_ty, arm_ty)\n                     };\n-                    self.report_mismatched_types(&cause, expected, found, e);\n+                    self.report_mismatched_types(&cause, expected, found, e).emit();\n                     self.tcx.types.err\n                 }\n             };"}, {"sha": "01a961949bc337655421710354be8ff2c9c97387", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=07a3ede5f2ee2db963b73453f43126a71f5092bd", "patch": "@@ -51,7 +51,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.register_predicates(obligations);\n             },\n             Err(e) => {\n+<<<<<<< HEAD\n                 self.report_mismatched_types(&cause, expected, actual, e);\n+=======\n+                self.report_mismatched_types(origin, expected, actual, e).emit();\n+>>>>>>> Return DiagnosticBuilder to add help suggestions\n             }\n         }\n     }\n@@ -70,7 +74,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.register_predicates(obligations);\n             },\n             Err(e) => {\n-                self.report_mismatched_types(cause, expected, actual, e);\n+                self.report_mismatched_types(cause, expected, actual, e).emit();\n             }\n         }\n     }\n@@ -82,7 +86,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n             let mode = probe::Mode::MethodCall;\n-            if let Ok(methods) = self.probe_return(syntax_pos::DUMMY_SP, mode, expected,\n+            let suggestions = \n+                if let Ok(methods) = self.probe_return(syntax_pos::DUMMY_SP, mode, expected,\n                                                    checked_ty, ast::DUMMY_NODE_ID) {\n                 let suggestions: Vec<_> =\n                     methods.iter()\n@@ -93,43 +98,59 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 None\n                             }})\n                            .collect();\n-                let safe_suggestions: Vec<_> =\n-                    suggestions.iter()\n-                               .map(|ref x| MethodInfo::new(\n-                                                self.find_attr(x.id, \"safe_suggestion\"),\n-                                                               x.id,\n-                                                               x.item.clone()))\n-                               .filter(|ref x| x.ast.is_some())\n-                               .collect();\n-                if safe_suggestions.len() > 0 {\n-                    self.get_best_match(&safe_suggestions);\n+                if suggestions.len() > 0 {\n+                    let safe_suggestions: Vec<_> =\n+                        suggestions.iter()\n+                                   .map(|ref x| MethodInfo::new(\n+                                                    self.find_attr(x.id, \"safe_suggestion\"),\n+                                                                   x.id,\n+                                                                   x.item.clone()))\n+                                   .filter(|ref x| x.ast.is_some())\n+                                   .collect();\n+                    Some(if safe_suggestions.len() > 0 {\n+                        self.get_best_match(&safe_suggestions)\n+                    } else {\n+                        format!(\"no safe suggestion found, here are functions which match your \\\n+                                 needs but be careful:\\n - {}\",\n+                                self.get_best_match(&suggestions))\n+                    })\n                 } else {\n-                    self.get_best_match(&suggestions);\n+                    None\n                 }\n+            } else {\n+                None\n+            };\n+            let mut err = self.report_mismatched_types(origin, expected, expr_ty, e);\n+            if let Some(suggestions) = suggestions {\n+                err.help(&suggestions);\n             }\n+<<<<<<< HEAD\n             self.report_mismatched_types(&cause, expected, expr_ty, e);\n+=======\n+            err.emit();\n+>>>>>>> Return DiagnosticBuilder to add help suggestions\n         }\n     }\n \n     fn get_best_match(&self, methods: &[MethodInfo<'tcx>]) -> String {\n         if methods.len() == 1 {\n-            println!(\"unique match ==> {:?}\", methods[0].item.name());\n-            return String::new();\n+            return format!(\" - {}\", methods[0].item.name());\n         }\n         let no_argument_methods: Vec<&MethodInfo> =\n             methods.iter()\n                    .filter(|ref x| self.has_not_input_arg(&*x.item))\n                    .collect();\n         if no_argument_methods.len() > 0 {\n-            for ref method in no_argument_methods {\n-                println!(\"best match ==> {:?}\", method.item.name());\n-            }\n+            no_argument_methods.iter()\n+                               .map(|method| format!(\"{}\", method.item.name()))\n+                               .collect::<Vec<String>>()\n+                               .join(\"\\n - \")\n         } else {\n-            for ref method in methods.iter() {\n-                println!(\"not best ==> {:?}\", method.item.name());\n-            }\n+            methods.iter()\n+                   .map(|method| format!(\"{}\", method.item.name()))\n+                   .collect::<Vec<String>>()\n+                   .join(\"\\n - \")\n         }\n-        String::new()\n     }\n \n     fn get_impl_id(&self, impl_: &ImplOrTraitItem<'tcx>) -> Option<DefId> {"}, {"sha": "92d96b407192bdac5bbcf2fc3c202298f022964d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=07a3ede5f2ee2db963b73453f43126a71f5092bd", "patch": "@@ -2986,7 +2986,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             Err(e) => {\n-                self.report_mismatched_types(&cause, expected_ty, found_ty, e);\n+                self.report_mismatched_types(&cause, expected_ty, found_ty, e).emit();\n                 self.tcx.types.err\n             }\n         }\n@@ -3880,7 +3880,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 match result {\n                     Ok(ty) => unified = ty,\n                     Err(e) => {\n-                        self.report_mismatched_types(&cause, unified, e_ty, e);\n+                        self.report_mismatched_types(&cause, unified, e_ty, e).emit();\n                     }\n                 }\n             }"}, {"sha": "0e5a16987c12e408e9315cadd82ca3848872ae16", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=07a3ede5f2ee2db963b73453f43126a71f5092bd", "patch": "@@ -356,7 +356,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         infcx.report_mismatched_types(&cause,\n                                                       mk_ptr(mt_b.ty),\n                                                       target,\n-                                                      ty::error::TypeError::Mutability);\n+                                                      ty::error::TypeError::Mutability).emit();\n                     }\n                     (mt_a.ty, mt_b.ty, unsize_trait, None)\n                 };"}, {"sha": "ec17813ed2a521fb479a0e012d1546890c31af33", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a3ede5f2ee2db963b73453f43126a71f5092bd/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=07a3ede5f2ee2db963b73453f43126a71f5092bd", "patch": "@@ -185,7 +185,7 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 true\n             }\n             Err(err) => {\n-                infcx.report_mismatched_types(cause, expected, actual, err);\n+                infcx.report_mismatched_types(cause, expected, actual, err).emit();\n                 false\n             }\n         }"}]}