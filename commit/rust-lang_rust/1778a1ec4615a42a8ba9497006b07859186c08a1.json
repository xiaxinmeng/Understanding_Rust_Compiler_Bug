{"sha": "1778a1ec4615a42a8ba9497006b07859186c08a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NzhhMWVjNDYxNWE0MmE4YmE5NDk3MDA2YjA3ODU5MTg2YzA4YTE=", "commit": {"author": {"name": "Takayuki Nakata", "email": "f.seasons017@gmail.com", "date": "2020-09-07T13:17:31Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-09-10T16:05:01Z"}, "message": "Restrict `same_item_push` to suppress false positives\n\nIt emits a lint when the pushed item is a literal, a constant and an immutable binding that are initialized with those.", "tree": {"sha": "1b0e0d6d9f05a210f4a04923b0a9b2d0ffecf7d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b0e0d6d9f05a210f4a04923b0a9b2d0ffecf7d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1778a1ec4615a42a8ba9497006b07859186c08a1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl9aTrAACgkQaTCGhp1Q\nZjcB0Q/+Pm35zyPU1Hrtkn0BismswZwrgExQZKrZgeJjsBqvHFZRETmkh0dE1mOa\nPZjHRC5G4o2RhAo5Gu9cp2n/D/ezAb5QY00C8yiJbcvW+HJcMj+8a24E6kIkQN0Y\nFdkD5J2Yilsx9zpxsfZD7E2+ygM53/xO5FPx4uqFyALisnbTXa9lVbF35MBLvOvU\nv6HaILhkLuQUeUqXZAPqZeWqqieQoCTWHnVIQAUpfJuWyWUWtJzFBOiuO20NnSKD\nq8LmP2TyxqzErwbpa10Iyk8is89o6+1eD94JGxuO1mvPbFQUhOTdYRRV8x1pyZi4\nYU+ZS9dCMZ+cKKHqpaHxIuDEbdodnmACRpsoW6kBTBccoTsSyjduP3vQGkQ/gcyN\nji22akPWsOFFY1m4fUWNla1NLf/aRaXrGv7u/rTsPzWhRFNivXru8WtPsQf9mh6o\nty5pgS33bIZYHYwj90UPMOeplCw1yFAZs9YKx3l/MioL6GFhRN7p9Tz95qWjkSXW\nhmuACNgcdDM18Vi/nGoY3qsxdBWktwwZKoWQJsB09KqVVnhVnnpvl7ssvFi7zZhH\nmWsE8gGXfVDn5v/XzfAsGPvx3OczoIXTB5G9R9kXZvuf6RMRp5XKX2pw//Sby2yn\nAA+NH70D2LubHCvoxiGvlrK4KBwiVbXxBbT6IT7JyOIBUtif7ZA=\n=NFi3\n-----END PGP SIGNATURE-----", "payload": "tree 1b0e0d6d9f05a210f4a04923b0a9b2d0ffecf7d4\nparent 09bd400243ed6f7059fedc0c1623aae3792521d6\nauthor Takayuki Nakata <f.seasons017@gmail.com> 1599484651 +0900\ncommitter flip1995 <hello@philkrones.com> 1599753901 +0200\n\nRestrict `same_item_push` to suppress false positives\n\nIt emits a lint when the pushed item is a literal, a constant and an immutable binding that are initialized with those.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1778a1ec4615a42a8ba9497006b07859186c08a1", "html_url": "https://github.com/rust-lang/rust/commit/1778a1ec4615a42a8ba9497006b07859186c08a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1778a1ec4615a42a8ba9497006b07859186c08a1/comments", "author": {"login": "giraffate", "id": 17407489, "node_id": "MDQ6VXNlcjE3NDA3NDg5", "avatar_url": "https://avatars.githubusercontent.com/u/17407489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/giraffate", "html_url": "https://github.com/giraffate", "followers_url": "https://api.github.com/users/giraffate/followers", "following_url": "https://api.github.com/users/giraffate/following{/other_user}", "gists_url": "https://api.github.com/users/giraffate/gists{/gist_id}", "starred_url": "https://api.github.com/users/giraffate/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/giraffate/subscriptions", "organizations_url": "https://api.github.com/users/giraffate/orgs", "repos_url": "https://api.github.com/users/giraffate/repos", "events_url": "https://api.github.com/users/giraffate/events{/privacy}", "received_events_url": "https://api.github.com/users/giraffate/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09bd400243ed6f7059fedc0c1623aae3792521d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/09bd400243ed6f7059fedc0c1623aae3792521d6", "html_url": "https://github.com/rust-lang/rust/commit/09bd400243ed6f7059fedc0c1623aae3792521d6"}], "stats": {"total": 190, "additions": 154, "deletions": 36}, "files": [{"sha": "f417e3a0caf9519cce8dad106c002cc0aea50ed3", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 95, "deletions": 23, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/1778a1ec4615a42a8ba9497006b07859186c08a1/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1778a1ec4615a42a8ba9497006b07859186c08a1/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=1778a1ec4615a42a8ba9497006b07859186c08a1", "patch": "@@ -826,7 +826,7 @@ struct FixedOffsetVar<'hir> {\n }\n \n fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n-    let is_slice = match ty.kind {\n+    let is_slice = match ty.kind() {\n         ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n         ty::Slice(..) | ty::Array(..) => true,\n         _ => false,\n@@ -1003,7 +1003,7 @@ fn detect_manual_memcpy<'tcx>(\n         start: Some(start),\n         end: Some(end),\n         limits,\n-    }) = higher::range(cx, arg)\n+    }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n@@ -1140,23 +1140,95 @@ fn detect_same_item_push<'tcx>(\n     walk_expr(&mut same_item_push_visitor, body);\n     if same_item_push_visitor.should_lint {\n         if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n-            // Make sure that the push does not involve possibly mutating values\n-            if mutated_variables(pushed_item, cx).map_or(false, |mutvars| mutvars.is_empty()) {\n+            let vec_ty = cx.typeck_results().expr_ty(vec);\n+            let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n+            if cx\n+                .tcx\n+                .lang_items()\n+                .clone_trait()\n+                .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+            {\n+                // Make sure that the push does not involve possibly mutating values\n                 if let PatKind::Wild = pat.kind {\n                     let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n                     let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n-\n-                    span_lint_and_help(\n-                        cx,\n-                        SAME_ITEM_PUSH,\n-                        vec.span,\n-                        \"it looks like the same item is being pushed into this Vec\",\n-                        None,\n-                        &format!(\n-                            \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n-                            item_str, vec_str, item_str\n-                        ),\n-                    )\n+                    if let ExprKind::Path(ref qpath) = pushed_item.kind {\n+                        match qpath_res(cx, qpath, pushed_item.hir_id) {\n+                            // immutable bindings that are initialized with literal or constant\n+                            Res::Local(hir_id) => {\n+                                if_chain! {\n+                                    let node = cx.tcx.hir().get(hir_id);\n+                                    if let Node::Binding(pat) = node;\n+                                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n+                                    if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                                    let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n+                                    if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n+                                    if let rustc_hir::Local { init: Some(init), .. } = parent_let_expr;\n+                                    then {\n+                                        match init.kind {\n+                                            // immutable bindings that are initialized with literal\n+                                            ExprKind::Lit(..) => {\n+                                                span_lint_and_help(\n+                                                    cx,\n+                                                    SAME_ITEM_PUSH,\n+                                                    vec.span,\n+                                                    \"it looks like the same item is being pushed into this Vec\",\n+                                                    None,\n+                                                    &format!(\n+                                                        \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                                                        item_str, vec_str, item_str\n+                                                    ),\n+                                                )\n+                                            },\n+                                            // immutable bindings that are initialized with constant\n+                                            ExprKind::Path(ref path) => {\n+                                                if let Res::Def(DefKind::Const, ..) = qpath_res(cx, path, init.hir_id) {\n+                                                    span_lint_and_help(\n+                                                        cx,\n+                                                        SAME_ITEM_PUSH,\n+                                                        vec.span,\n+                                                        \"it looks like the same item is being pushed into this Vec\",\n+                                                        None,\n+                                                        &format!(\n+                                                            \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                                                            item_str, vec_str, item_str\n+                                                        ),\n+                                                    )\n+                                                }\n+                                            }\n+                                            _ => {},\n+                                        }\n+                                    }\n+                                }\n+                            },\n+                            // constant\n+                            Res::Def(DefKind::Const, ..) => span_lint_and_help(\n+                                cx,\n+                                SAME_ITEM_PUSH,\n+                                vec.span,\n+                                \"it looks like the same item is being pushed into this Vec\",\n+                                None,\n+                                &format!(\n+                                    \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                                    item_str, vec_str, item_str\n+                                ),\n+                            ),\n+                            _ => {},\n+                        }\n+                    } else if let ExprKind::Lit(..) = pushed_item.kind {\n+                        // literal\n+                        span_lint_and_help(\n+                            cx,\n+                            SAME_ITEM_PUSH,\n+                            vec.span,\n+                            \"it looks like the same item is being pushed into this Vec\",\n+                            None,\n+                            &format!(\n+                                \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                                item_str, vec_str, item_str\n+                            ),\n+                        )\n+                    }\n                 }\n             }\n         }\n@@ -1177,7 +1249,7 @@ fn check_for_loop_range<'tcx>(\n         start: Some(start),\n         ref end,\n         limits,\n-    }) = higher::range(cx, arg)\n+    }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n@@ -1355,7 +1427,7 @@ fn is_end_eq_array_len<'tcx>(\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = end.kind;\n         if let ast::LitKind::Int(end_int, _) = lit.node;\n-        if let ty::Array(_, arr_len_const) = indexed_ty.kind;\n+        if let ty::Array(_, arr_len_const) = indexed_ty.kind();\n         if let Some(arr_len) = arr_len_const.try_eval_usize(cx.tcx, cx.param_env);\n         then {\n             return match limits {\n@@ -1592,7 +1664,7 @@ fn check_for_loop_over_map_kv<'tcx>(\n     if let PatKind::Tuple(ref pat, _) = pat.kind {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n-            let (new_pat_span, kind, ty, mutbl) = match cx.typeck_results().expr_ty(arg).kind {\n+            let (new_pat_span, kind, ty, mutbl) = match *cx.typeck_results().expr_ty(arg).kind() {\n                 ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n                     (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n                     (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n@@ -1679,7 +1751,7 @@ fn check_for_mut_range_bound(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'\n         start: Some(start),\n         end: Some(end),\n         ..\n-    }) = higher::range(cx, arg)\n+    }) = higher::range(arg)\n     {\n         let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n         if mut_ids[0].is_some() || mut_ids[1].is_some() {\n@@ -1920,7 +1992,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 for expr in args {\n                     let ty = self.cx.typeck_results().expr_ty_adjusted(expr);\n                     self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = ty.kind {\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {\n                             self.prefer_mutable = true;\n                         }\n@@ -1932,7 +2004,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = ty.kind {\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {\n                             self.prefer_mutable = true;\n                         }\n@@ -2030,7 +2102,7 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n \n fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Array(_, n) => n\n             .try_eval_usize(cx.tcx, cx.param_env)\n             .map_or(false, |val| (0..=32).contains(&val)),"}, {"sha": "bd4792c4a76be858aa1ce827670d7b79eca2767e", "filename": "tests/ui/same_item_push.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1778a1ec4615a42a8ba9497006b07859186c08a1/tests%2Fui%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1778a1ec4615a42a8ba9497006b07859186c08a1/tests%2Fui%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.rs?ref=1778a1ec4615a42a8ba9497006b07859186c08a1", "patch": "@@ -1,5 +1,7 @@\n #![warn(clippy::same_item_push)]\n \n+const VALUE: u8 = 7;\n+\n fn mutate_increment(x: &mut u8) -> u8 {\n     *x += 1;\n     *x\n@@ -86,4 +88,40 @@ fn main() {\n     for a in vec_a {\n         vec12.push(2u8.pow(a.kind));\n     }\n+\n+    // Fix #5902\n+    let mut vec13: Vec<u8> = Vec::new();\n+    let mut item = 0;\n+    for _ in 0..10 {\n+        vec13.push(item);\n+        item += 10;\n+    }\n+\n+    // Fix #5979\n+    let mut vec14: Vec<std::fs::File> = Vec::new();\n+    for _ in 0..10 {\n+        vec14.push(std::fs::File::open(\"foobar\").unwrap());\n+    }\n+    // Fix #5979\n+    #[derive(Clone)]\n+    struct S {}\n+\n+    trait T {}\n+    impl T for S {}\n+\n+    let mut vec15: Vec<Box<dyn T>> = Vec::new();\n+    for _ in 0..10 {\n+        vec15.push(Box::new(S {}));\n+    }\n+\n+    let mut vec16 = Vec::new();\n+    for _ in 0..20 {\n+        vec16.push(VALUE);\n+    }\n+\n+    let mut vec17 = Vec::new();\n+    let item = VALUE;\n+    for _ in 0..20 {\n+        vec17.push(item);\n+    }\n }"}, {"sha": "4896479791af4e9de4cd0ba420ec9dc09ffd94a6", "filename": "tests/ui/same_item_push.stderr", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1778a1ec4615a42a8ba9497006b07859186c08a1/tests%2Fui%2Fsame_item_push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1778a1ec4615a42a8ba9497006b07859186c08a1/tests%2Fui%2Fsame_item_push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.stderr?ref=1778a1ec4615a42a8ba9497006b07859186c08a1", "patch": "@@ -1,35 +1,43 @@\n error: it looks like the same item is being pushed into this Vec\n-  --> $DIR/same_item_push.rs:16:9\n-   |\n-LL |         spaces.push(vec![b' ']);\n-   |         ^^^^^^\n-   |\n-   = note: `-D clippy::same-item-push` implied by `-D warnings`\n-   = help: try using vec![vec![b' '];SIZE] or spaces.resize(NEW_SIZE, vec![b' '])\n-\n-error: it looks like the same item is being pushed into this Vec\n-  --> $DIR/same_item_push.rs:22:9\n+  --> $DIR/same_item_push.rs:24:9\n    |\n LL |         vec2.push(item);\n    |         ^^^^\n    |\n+   = note: `-D clippy::same-item-push` implied by `-D warnings`\n    = help: try using vec![item;SIZE] or vec2.resize(NEW_SIZE, item)\n \n error: it looks like the same item is being pushed into this Vec\n-  --> $DIR/same_item_push.rs:28:9\n+  --> $DIR/same_item_push.rs:30:9\n    |\n LL |         vec3.push(item);\n    |         ^^^^\n    |\n    = help: try using vec![item;SIZE] or vec3.resize(NEW_SIZE, item)\n \n error: it looks like the same item is being pushed into this Vec\n-  --> $DIR/same_item_push.rs:33:9\n+  --> $DIR/same_item_push.rs:35:9\n    |\n LL |         vec4.push(13);\n    |         ^^^^\n    |\n    = help: try using vec![13;SIZE] or vec4.resize(NEW_SIZE, 13)\n \n-error: aborting due to 4 previous errors\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:119:9\n+   |\n+LL |         vec16.push(VALUE);\n+   |         ^^^^^\n+   |\n+   = help: try using vec![VALUE;SIZE] or vec16.resize(NEW_SIZE, VALUE)\n+\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:125:9\n+   |\n+LL |         vec17.push(item);\n+   |         ^^^^^\n+   |\n+   = help: try using vec![item;SIZE] or vec17.resize(NEW_SIZE, item)\n+\n+error: aborting due to 5 previous errors\n "}]}