{"sha": "c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMjVjYjBhNDJjMmIyYzBiMTJlZWIxZWJmNGNjMjJiY2EwZmU5OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-21T05:10:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-21T05:10:28Z"}, "message": "auto merge of #7912 : graydon/rust/extra-new-benchmarks-1, r=catamorphism\n\nThis adds new #[bench] benchmarks for extra::smallintmap, treemap, sha1, sha256 and 512, and base64. Also fixes a bunch of warnings in bitv.", "tree": {"sha": "88765fe5523317fd04d636ed9e8d1bca1eb6133b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88765fe5523317fd04d636ed9e8d1bca1eb6133b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "html_url": "https://github.com/rust-lang/rust/commit/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d029ebfc5f69f830fe24b4c8a979970d9a7d297d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d029ebfc5f69f830fe24b4c8a979970d9a7d297d", "html_url": "https://github.com/rust-lang/rust/commit/d029ebfc5f69f830fe24b4c8a979970d9a7d297d"}, {"sha": "0ba6a51f3269796e4b1e8fe4141ec6798fb8e5a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba6a51f3269796e4b1e8fe4141ec6798fb8e5a3", "html_url": "https://github.com/rust-lang/rust/commit/0ba6a51f3269796e4b1e8fe4141ec6798fb8e5a3"}], "stats": {"total": 477, "additions": 409, "deletions": 68}, "files": [{"sha": "3c549d4291710d48fddf7010261bda886fe9a545", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 95, "deletions": 67, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "patch": "@@ -284,81 +284,109 @@ impl<'self> FromBase64 for &'self str {\n     }\n }\n \n-#[test]\n-fn test_to_base64_basic() {\n-    assert_eq!(\"\".to_base64(STANDARD), ~\"\");\n-    assert_eq!(\"f\".to_base64(STANDARD), ~\"Zg==\");\n-    assert_eq!(\"fo\".to_base64(STANDARD), ~\"Zm8=\");\n-    assert_eq!(\"foo\".to_base64(STANDARD), ~\"Zm9v\");\n-    assert_eq!(\"foob\".to_base64(STANDARD), ~\"Zm9vYg==\");\n-    assert_eq!(\"fooba\".to_base64(STANDARD), ~\"Zm9vYmE=\");\n-    assert_eq!(\"foobar\".to_base64(STANDARD), ~\"Zm9vYmFy\");\n-}\n+#[cfg(test)]\n+mod test {\n+    use test::BenchHarness;\n+    use base64::*;\n+\n+    #[test]\n+    fn test_to_base64_basic() {\n+        assert_eq!(\"\".to_base64(STANDARD), ~\"\");\n+        assert_eq!(\"f\".to_base64(STANDARD), ~\"Zg==\");\n+        assert_eq!(\"fo\".to_base64(STANDARD), ~\"Zm8=\");\n+        assert_eq!(\"foo\".to_base64(STANDARD), ~\"Zm9v\");\n+        assert_eq!(\"foob\".to_base64(STANDARD), ~\"Zm9vYg==\");\n+        assert_eq!(\"fooba\".to_base64(STANDARD), ~\"Zm9vYmE=\");\n+        assert_eq!(\"foobar\".to_base64(STANDARD), ~\"Zm9vYmFy\");\n+    }\n \n-#[test]\n-fn test_to_base64_line_break() {\n-    assert!(![0u8, 1000].to_base64(Config {line_length: None, ..STANDARD})\n-        .contains(\"\\r\\n\"));\n-    assert_eq!(\"foobar\".to_base64(Config {line_length: Some(4), ..STANDARD}),\n-        ~\"Zm9v\\r\\nYmFy\");\n-}\n+    #[test]\n+    fn test_to_base64_line_break() {\n+        assert!(![0u8, 1000].to_base64(Config {line_length: None, ..STANDARD})\n+                .contains(\"\\r\\n\"));\n+        assert_eq!(\"foobar\".to_base64(Config {line_length: Some(4), ..STANDARD}),\n+                   ~\"Zm9v\\r\\nYmFy\");\n+    }\n \n-#[test]\n-fn test_to_base64_padding() {\n-    assert_eq!(\"f\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n-    assert_eq!(\"fo\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n-}\n+    #[test]\n+    fn test_to_base64_padding() {\n+        assert_eq!(\"f\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n+        assert_eq!(\"fo\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n+    }\n \n-#[test]\n-fn test_to_base64_url_safe() {\n-    assert_eq!([251, 255].to_base64(URL_SAFE), ~\"-_8\");\n-    assert_eq!([251, 255].to_base64(STANDARD), ~\"+/8=\");\n-}\n+    #[test]\n+    fn test_to_base64_url_safe() {\n+        assert_eq!([251, 255].to_base64(URL_SAFE), ~\"-_8\");\n+        assert_eq!([251, 255].to_base64(STANDARD), ~\"+/8=\");\n+    }\n \n-#[test]\n-fn test_from_base64_basic() {\n-    assert_eq!(\"\".from_base64().get(), \"\".as_bytes().to_owned());\n-    assert_eq!(\"Zg==\".from_base64().get(), \"f\".as_bytes().to_owned());\n-    assert_eq!(\"Zm8=\".from_base64().get(), \"fo\".as_bytes().to_owned());\n-    assert_eq!(\"Zm9v\".from_base64().get(), \"foo\".as_bytes().to_owned());\n-    assert_eq!(\"Zm9vYg==\".from_base64().get(), \"foob\".as_bytes().to_owned());\n-    assert_eq!(\"Zm9vYmE=\".from_base64().get(), \"fooba\".as_bytes().to_owned());\n-    assert_eq!(\"Zm9vYmFy\".from_base64().get(), \"foobar\".as_bytes().to_owned());\n-}\n+    #[test]\n+    fn test_from_base64_basic() {\n+        assert_eq!(\"\".from_base64().get(), \"\".as_bytes().to_owned());\n+        assert_eq!(\"Zg==\".from_base64().get(), \"f\".as_bytes().to_owned());\n+        assert_eq!(\"Zm8=\".from_base64().get(), \"fo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9v\".from_base64().get(), \"foo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYg==\".from_base64().get(), \"foob\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmE=\".from_base64().get(), \"fooba\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmFy\".from_base64().get(), \"foobar\".as_bytes().to_owned());\n+    }\n \n-#[test]\n-fn test_from_base64_newlines() {\n-    assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().get(),\n-        \"foobar\".as_bytes().to_owned());\n-}\n+    #[test]\n+    fn test_from_base64_newlines() {\n+        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().get(),\n+                   \"foobar\".as_bytes().to_owned());\n+    }\n \n-#[test]\n-fn test_from_base64_urlsafe() {\n-    assert_eq!(\"-_8\".from_base64().get(), \"+/8=\".from_base64().get());\n-}\n+    #[test]\n+    fn test_from_base64_urlsafe() {\n+        assert_eq!(\"-_8\".from_base64().get(), \"+/8=\".from_base64().get());\n+    }\n \n-#[test]\n-fn test_from_base64_invalid_char() {\n-    assert!(\"Zm$=\".from_base64().is_err())\n-    assert!(\"Zg==$\".from_base64().is_err());\n-}\n+    #[test]\n+    fn test_from_base64_invalid_char() {\n+        assert!(\"Zm$=\".from_base64().is_err())\n+            assert!(\"Zg==$\".from_base64().is_err());\n+    }\n \n-#[test]\n-fn test_from_base64_invalid_padding() {\n-    assert!(\"Z===\".from_base64().is_err());\n-}\n+    #[test]\n+    fn test_from_base64_invalid_padding() {\n+        assert!(\"Z===\".from_base64().is_err());\n+    }\n \n-#[test]\n-fn test_base64_random() {\n-    use std::rand::{task_rng, random, RngUtil};\n-    use std::vec;\n+    #[test]\n+    fn test_base64_random() {\n+        use std::rand::{task_rng, random, RngUtil};\n+        use std::vec;\n \n-    for 1000.times {\n-        let v: ~[u8] = do vec::build |push| {\n-            for task_rng().gen_uint_range(1, 100).times {\n-                push(random());\n-            }\n-        };\n-        assert_eq!(v.to_base64(STANDARD).from_base64().get(), v);\n+        for 1000.times {\n+            let v: ~[u8] = do vec::build |push| {\n+                for task_rng().gen_uint_range(1, 100).times {\n+                    push(random());\n+                }\n+            };\n+            assert_eq!(v.to_base64(STANDARD).from_base64().get(), v);\n+        }\n     }\n-}\n+\n+    #[bench]\n+    pub fn to_base64(bh: & mut BenchHarness) {\n+        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+        do bh.iter {\n+            s.to_base64(STANDARD);\n+        }\n+        bh.bytes = s.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn from_base64(bh: & mut BenchHarness) {\n+        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+        let b = s.to_base64(STANDARD);\n+        do bh.iter {\n+            b.from_base64();\n+        }\n+        bh.bytes = b.len() as u64;\n+    }\n+\n+}\n\\ No newline at end of file"}, {"sha": "7b072b7cd467d1a4eff249c95d148847c35f512f", "filename": "src/libextra/container.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcontainer.rs?ref=c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "patch": "@@ -38,3 +38,86 @@ pub trait Deque<T> : Mutable {\n     /// Remove the first element and return it, or None if the sequence is empty\n     fn pop_front(&mut self) -> Option<T>;\n }\n+\n+#[cfg(test)]\n+mod bench {\n+\n+    use std::container::MutableMap;\n+    use std::{vec,rand,uint};\n+    use std::rand::RngUtil;\n+    use test::BenchHarness;\n+\n+    pub fn insert_rand_n<M:MutableMap<uint,uint>>(n: uint,\n+                                                  map: &mut M,\n+                                                  bh: &mut BenchHarness) {\n+        // setup\n+        let mut rng = rand::XorShiftRng::new();\n+\n+        map.clear();\n+        for uint::range(0,n) |_i| {\n+            map.insert(rng.gen::<uint>() % n, 1);\n+        }\n+\n+        // measure\n+        do bh.iter {\n+            let k = rng.gen::<uint>() % n;\n+            map.insert(k, 1);\n+            map.remove(&k);\n+        }\n+    }\n+\n+    pub fn insert_seq_n<M:MutableMap<uint,uint>>(n: uint,\n+                                                 map: &mut M,\n+                                                 bh: &mut BenchHarness) {\n+        // setup\n+        map.clear();\n+        for uint::range(0, n) |i| {\n+            map.insert(i*2, 1);\n+        }\n+\n+        // measure\n+        let mut i = 1;\n+        do bh.iter {\n+            map.insert(i, 1);\n+            map.remove(&i);\n+            i = (i + 2) % n;\n+        }\n+    }\n+\n+    pub fn find_rand_n<M:MutableMap<uint,uint>>(n: uint,\n+                                                map: &mut M,\n+                                                bh: &mut BenchHarness) {\n+        // setup\n+        let mut rng = rand::XorShiftRng::new();\n+        let mut keys = vec::from_fn(n, |_| rng.gen::<uint>() % n);\n+\n+        for keys.iter().advance() |k| {\n+            map.insert(*k, 1);\n+        }\n+\n+        rng.shuffle_mut(keys);\n+\n+        // measure\n+        let mut i = 0;\n+        do bh.iter {\n+            map.find(&(keys[i]));\n+            i = (i + 1) % n;\n+        }\n+    }\n+\n+    pub fn find_seq_n<M:MutableMap<uint,uint>>(n: uint,\n+                                               map: &mut M,\n+                                               bh: &mut BenchHarness) {\n+        // setup\n+        for uint::range(0, n) |i| {\n+            map.insert(i, 1);\n+        }\n+\n+        // measure\n+        let mut i = 0;\n+        do bh.iter {\n+            map.find(&i);\n+            i = (i + 1) % n;\n+        }\n+     }\n+}\n\\ No newline at end of file"}, {"sha": "dbc65754266dc272b45b13b88639f31bf4c645b9", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "patch": "@@ -367,3 +367,41 @@ mod tests {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod bench {\n+\n+    use sha1::Sha1;\n+    use test::BenchHarness;\n+\n+    #[bench]\n+    pub fn sha1_10(bh: & mut BenchHarness) {\n+        let mut sh = Sha1::new();\n+        let bytes = [1u8, ..10];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha1_1k(bh: & mut BenchHarness) {\n+        let mut sh = Sha1::new();\n+        let bytes = [1u8, ..1024];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha1_64k(bh: & mut BenchHarness) {\n+        let mut sh = Sha1::new();\n+        let bytes = [1u8, ..65536];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+}"}, {"sha": "f21722e8d7af0e7f151777e0d83af022ad84da99", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "patch": "@@ -1121,3 +1121,75 @@ mod tests {\n         test_hash(sh, tests);\n     }\n }\n+\n+\n+\n+#[cfg(test)]\n+mod bench {\n+\n+    use sha2::{Sha256,Sha512};\n+    use test::BenchHarness;\n+\n+    #[bench]\n+    pub fn sha256_10(bh: & mut BenchHarness) {\n+        let mut sh = Sha256::new();\n+        let bytes = [1u8, ..10];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha256_1k(bh: & mut BenchHarness) {\n+        let mut sh = Sha256::new();\n+        let bytes = [1u8, ..1024];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha256_64k(bh: & mut BenchHarness) {\n+        let mut sh = Sha256::new();\n+        let bytes = [1u8, ..65536];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+\n+\n+    #[bench]\n+    pub fn sha512_10(bh: & mut BenchHarness) {\n+        let mut sh = Sha512::new();\n+        let bytes = [1u8, ..10];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha512_1k(bh: & mut BenchHarness) {\n+        let mut sh = Sha512::new();\n+        let bytes = [1u8, ..1024];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha512_64k(bh: & mut BenchHarness) {\n+        let mut sh = Sha512::new();\n+        let bytes = [1u8, ..65536];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+}"}, {"sha": "23b3364eb7caae0fed62cfe867f5d1bbfc4643c0", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "patch": "@@ -657,6 +657,66 @@ mod tests {\n     }\n }\n \n+#[cfg(test)]\n+mod bench {\n+\n+    use super::*;\n+    use test::BenchHarness;\n+    use container::bench::*;\n+\n+    // Find seq\n+    #[bench]\n+    pub fn insert_rand_100(bh: &mut BenchHarness) {\n+        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        insert_rand_n(100, &mut m, bh);\n+    }\n+\n+    #[bench]\n+    pub fn insert_rand_10_000(bh: &mut BenchHarness) {\n+        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        insert_rand_n(10_000, &mut m, bh);\n+    }\n+\n+    // Insert seq\n+    #[bench]\n+    pub fn insert_seq_100(bh: &mut BenchHarness) {\n+        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        insert_seq_n(100, &mut m, bh);\n+    }\n+\n+    #[bench]\n+    pub fn insert_seq_10_000(bh: &mut BenchHarness) {\n+        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        insert_seq_n(10_000, &mut m, bh);\n+    }\n+\n+    // Find rand\n+    #[bench]\n+    pub fn find_rand_100(bh: &mut BenchHarness) {\n+        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        find_rand_n(100, &mut m, bh);\n+    }\n+\n+    #[bench]\n+    pub fn find_rand_10_000(bh: &mut BenchHarness) {\n+        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        find_rand_n(10_000, &mut m, bh);\n+    }\n+\n+    // Find seq\n+    #[bench]\n+    pub fn find_seq_100(bh: &mut BenchHarness) {\n+        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        find_seq_n(100, &mut m, bh);\n+    }\n+\n+    #[bench]\n+    pub fn find_seq_10_000(bh: &mut BenchHarness) {\n+        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        find_seq_n(10_000, &mut m, bh);\n+    }\n+}\n+\n #[cfg(test)]\n mod test_set {\n \n@@ -851,5 +911,4 @@ mod test_set {\n             i + v2 == 4\n         });\n     }\n-\n }"}, {"sha": "f9b2c8429cff7a2f4f811c6851bfdedf8bcdf2d6", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "patch": "@@ -1055,6 +1055,67 @@ mod test_treemap {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n+\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+\n+    use super::*;\n+    use test::BenchHarness;\n+    use container::bench::*;\n+\n+    // Find seq\n+    #[bench]\n+    pub fn insert_rand_100(bh: &mut BenchHarness) {\n+        let mut m : TreeMap<uint,uint> = TreeMap::new();\n+        insert_rand_n(100, &mut m, bh);\n+    }\n+\n+    #[bench]\n+    pub fn insert_rand_10_000(bh: &mut BenchHarness) {\n+        let mut m : TreeMap<uint,uint> = TreeMap::new();\n+        insert_rand_n(10_000, &mut m, bh);\n+    }\n+\n+    // Insert seq\n+    #[bench]\n+    pub fn insert_seq_100(bh: &mut BenchHarness) {\n+        let mut m : TreeMap<uint,uint> = TreeMap::new();\n+        insert_seq_n(100, &mut m, bh);\n+    }\n+\n+    #[bench]\n+    pub fn insert_seq_10_000(bh: &mut BenchHarness) {\n+        let mut m : TreeMap<uint,uint> = TreeMap::new();\n+        insert_seq_n(10_000, &mut m, bh);\n+    }\n+\n+    // Find rand\n+    #[bench]\n+    pub fn find_rand_100(bh: &mut BenchHarness) {\n+        let mut m : TreeMap<uint,uint> = TreeMap::new();\n+        find_rand_n(100, &mut m, bh);\n+    }\n+\n+    #[bench]\n+    pub fn find_rand_10_000(bh: &mut BenchHarness) {\n+        let mut m : TreeMap<uint,uint> = TreeMap::new();\n+        find_rand_n(10_000, &mut m, bh);\n+    }\n+\n+    // Find seq\n+    #[bench]\n+    pub fn find_seq_100(bh: &mut BenchHarness) {\n+        let mut m : TreeMap<uint,uint> = TreeMap::new();\n+        find_seq_n(100, &mut m, bh);\n+    }\n+\n+    #[bench]\n+    pub fn find_seq_10_000(bh: &mut BenchHarness) {\n+        let mut m : TreeMap<uint,uint> = TreeMap::new();\n+        find_seq_n(10_000, &mut m, bh);\n+    }\n }\n \n #[cfg(test)]"}]}