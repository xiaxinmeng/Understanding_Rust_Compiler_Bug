{"sha": "31df6807893bd9c66cba57ff0f4de89ab9d8460e", "node_id": "C_kwDOAAsO6NoAKDMxZGY2ODA3ODkzYmQ5YzY2Y2JhNTdmZjBmNGRlODlhYjlkODQ2MGU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-19T05:20:07Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-22T20:13:31Z"}, "message": "Eliminate `TokenTreeOrTokenTreeSlice`.\n\nAs its name suggests, `TokenTreeOrTokenTreeSlice` is either a single\n`TokenTree` or a slice of them. It has methods `len` and `get_tt` that\nlet it be treated much like an ordinary slice. The reason it isn't an\nordinary slice is that for `TokenTree::Delimited` the open and close\ndelimiters are represented implicitly, and when they are needed they are\nconstructed on the fly with `Delimited::{open,close}_tt`, rather than\nbeing present in memory.\n\nThis commit changes `Delimited` so the open and close delimiters are\nrepresented explicitly. As a result, `TokenTreeOrTokenTreeSlice` is no\nlonger needed and `MatcherPos` and `MatcherTtFrame` can just use an\nordinary slice. `TokenTree::{len,get_tt}` are also removed, because they\nwere only needed to support `TokenTreeOrTokenTreeSlice`.\n\nThe change makes the code shorter and a little bit faster on benchmarks\nthat use macro expansion heavily, partly because `MatcherPos` is a lot\nsmaller (less data to `memcpy`) and partly because ordinary slice\noperations are faster than `TokenTreeOrTokenTreeSlice::{len,get_tt}`.", "tree": {"sha": "121e04e98fc7e52ab7087a3f7b05041eab4521e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/121e04e98fc7e52ab7087a3f7b05041eab4521e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31df6807893bd9c66cba57ff0f4de89ab9d8460e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31df6807893bd9c66cba57ff0f4de89ab9d8460e", "html_url": "https://github.com/rust-lang/rust/commit/31df6807893bd9c66cba57ff0f4de89ab9d8460e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31df6807893bd9c66cba57ff0f4de89ab9d8460e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "754dc8e66f77da219a077d147009816e8275eed3", "url": "https://api.github.com/repos/rust-lang/rust/commits/754dc8e66f77da219a077d147009816e8275eed3", "html_url": "https://github.com/rust-lang/rust/commit/754dc8e66f77da219a077d147009816e8275eed3"}], "stats": {"total": 319, "additions": 146, "deletions": 173}, "files": [{"sha": "0f7a8a9ed75506b05491927798da8f06d34d9fe2", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=31df6807893bd9c66cba57ff0f4de89ab9d8460e", "patch": "@@ -17,23 +17,48 @@ use rustc_data_structures::sync::Lrc;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-/// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n-/// that the delimiter itself might be `NoDelim`.\n+/// Contains the sub-token-trees of a \"delimited\" token tree such as `(a b c)`. The delimiter itself\n+/// might be `NoDelim`.\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n struct Delimited {\n     delim: token::DelimToken,\n-    tts: Vec<TokenTree>,\n+    /// Note: This contains the opening and closing delimiters tokens (e.g. `(` and `)`). Note that\n+    /// these could be `NoDelim`. These token kinds must match `delim`, and the methods below\n+    /// debug_assert this.\n+    all_tts: Vec<TokenTree>,\n }\n \n impl Delimited {\n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n-    fn open_tt(&self, span: DelimSpan) -> TokenTree {\n-        TokenTree::token(token::OpenDelim(self.delim), span.open)\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter. Panics if\n+    /// the delimiter is `NoDelim`.\n+    fn open_tt(&self) -> &TokenTree {\n+        let tt = self.all_tts.first().unwrap();\n+        debug_assert!(matches!(\n+            tt,\n+            &TokenTree::Token(token::Token { kind: token::OpenDelim(d), .. }) if d == self.delim\n+        ));\n+        tt\n+    }\n+\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter. Panics if\n+    /// the delimeter is `NoDelim`.\n+    fn close_tt(&self) -> &TokenTree {\n+        let tt = self.all_tts.last().unwrap();\n+        debug_assert!(matches!(\n+            tt,\n+            &TokenTree::Token(token::Token { kind: token::CloseDelim(d), .. }) if d == self.delim\n+        ));\n+        tt\n     }\n \n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n-    fn close_tt(&self, span: DelimSpan) -> TokenTree {\n-        TokenTree::token(token::CloseDelim(self.delim), span.close)\n+    /// Returns the tts excluding the outer delimiters.\n+    ///\n+    /// FIXME: #67062 has details about why this is sub-optimal.\n+    fn inner_tts(&self) -> &[TokenTree] {\n+        // These functions are called for the assertions within them.\n+        let _open_tt = self.open_tt();\n+        let _close_tt = self.close_tt();\n+        &self.all_tts[1..self.all_tts.len() - 1]\n     }\n }\n \n@@ -73,35 +98,24 @@ enum KleeneOp {\n     ZeroOrOne,\n }\n \n-/// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, `$(...)`,\n-/// and `${...}` are \"first-class\" token trees. Useful for parsing macros.\n+/// Similar to `tokenstream::TokenTree`, except that `Sequence`, `MetaVar`, `MetaVarDecl`, and\n+/// `MetaVarExpr` are \"first-class\" token trees. Useful for parsing macros.\n #[derive(Debug, Clone, PartialEq, Encodable, Decodable)]\n enum TokenTree {\n     Token(Token),\n+    /// A delimited sequence, e.g. `($e:expr)` (RHS) or `{ $e }` (LHS).\n     Delimited(DelimSpan, Lrc<Delimited>),\n-    /// A kleene-style repetition sequence\n+    /// A kleene-style repetition sequence, e.g. `$($e:expr)*` (RHS) or `$($e),*` (LHS).\n     Sequence(DelimSpan, Lrc<SequenceRepetition>),\n-    /// e.g., `$var`\n+    /// e.g., `$var`.\n     MetaVar(Span, Ident),\n-    /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n+    /// e.g., `$var:expr`. Only appears on the LHS.\n     MetaVarDecl(Span, Ident /* name to bind */, Option<NonterminalKind>),\n-    /// A meta-variable expression inside `${...}`\n+    /// A meta-variable expression inside `${...}`.\n     MetaVarExpr(DelimSpan, MetaVarExpr),\n }\n \n impl TokenTree {\n-    /// Return the number of tokens in the tree.\n-    fn len(&self) -> usize {\n-        match *self {\n-            TokenTree::Delimited(_, ref delimed) => match delimed.delim {\n-                token::NoDelim => delimed.tts.len(),\n-                _ => delimed.tts.len() + 2,\n-            },\n-            TokenTree::Sequence(_, ref seq) => seq.tts.len(),\n-            _ => 0,\n-        }\n-    }\n-\n     /// Returns `true` if the given token tree is delimited.\n     fn is_delimited(&self) -> bool {\n         matches!(*self, TokenTree::Delimited(..))\n@@ -115,26 +129,6 @@ impl TokenTree {\n         }\n     }\n \n-    /// Gets the `index`-th sub-token-tree. This only makes sense for delimited trees and sequences.\n-    fn get_tt(&self, index: usize) -> TokenTree {\n-        match (self, index) {\n-            (&TokenTree::Delimited(_, ref delimed), _) if delimed.delim == token::NoDelim => {\n-                delimed.tts[index].clone()\n-            }\n-            (&TokenTree::Delimited(span, ref delimed), _) => {\n-                if index == 0 {\n-                    return delimed.open_tt(span);\n-                }\n-                if index == delimed.tts.len() + 1 {\n-                    return delimed.close_tt(span);\n-                }\n-                delimed.tts[index - 1].clone()\n-            }\n-            (&TokenTree::Sequence(_, ref seq), _) => seq.tts[index].clone(),\n-            _ => panic!(\"Cannot expand a token tree\"),\n-        }\n-    }\n-\n     /// Retrieves the `TokenTree`'s span.\n     fn span(&self) -> Span {\n         match *self {"}, {"sha": "b55a40c5b2c4b6ad09965e90cb69fb905c58414e", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=31df6807893bd9c66cba57ff0f4de89ab9d8460e", "patch": "@@ -281,7 +281,7 @@ fn check_binders(\n         // `MetaVarExpr` can not appear in the LHS of a macro arm\n         TokenTree::MetaVarExpr(..) => {}\n         TokenTree::Delimited(_, ref del) => {\n-            for tt in &del.tts {\n+            for tt in del.inner_tts() {\n                 check_binders(sess, node_id, tt, macros, binders, ops, valid);\n             }\n         }\n@@ -344,7 +344,7 @@ fn check_occurrences(\n             check_ops_is_prefix(sess, node_id, macros, binders, ops, dl.entire(), name);\n         }\n         TokenTree::Delimited(_, ref del) => {\n-            check_nested_occurrences(sess, node_id, &del.tts, macros, binders, ops, valid);\n+            check_nested_occurrences(sess, node_id, del.inner_tts(), macros, binders, ops, valid);\n         }\n         TokenTree::Sequence(_, ref seq) => {\n             let ops = ops.push(seq.kleene);\n@@ -431,14 +431,20 @@ fn check_nested_occurrences(\n             {\n                 let macro_rules = state == NestedMacroState::MacroRulesNotName;\n                 state = NestedMacroState::Empty;\n-                let rest =\n-                    check_nested_macro(sess, node_id, macro_rules, &del.tts, &nested_macros, valid);\n+                let rest = check_nested_macro(\n+                    sess,\n+                    node_id,\n+                    macro_rules,\n+                    del.inner_tts(),\n+                    &nested_macros,\n+                    valid,\n+                );\n                 // If we did not check the whole macro definition, then check the rest as if outside\n                 // the macro definition.\n                 check_nested_occurrences(\n                     sess,\n                     node_id,\n-                    &del.tts[rest..],\n+                    &del.inner_tts()[rest..],\n                     macros,\n                     binders,\n                     ops,"}, {"sha": "d8071bf159a743cf7a173dfb654b031845487817", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 25, "deletions": 57, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=31df6807893bd9c66cba57ff0f4de89ab9d8460e", "patch": "@@ -72,9 +72,8 @@\n \n crate use NamedMatch::*;\n crate use ParseResult::*;\n-use TokenTreeOrTokenTreeSlice::*;\n \n-use crate::mbe::{self, DelimSpan, SequenceRepetition, TokenTree};\n+use crate::mbe::{self, SequenceRepetition, TokenTree};\n \n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n use rustc_parse::parser::Parser;\n@@ -90,43 +89,14 @@ use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n \n-// To avoid costly uniqueness checks, we require that `MatchSeq` always has a nonempty body.\n-\n-/// Either a slice of token trees or a single one. This is used as the representation of the\n-/// token trees that make up a matcher.\n-#[derive(Clone)]\n-enum TokenTreeOrTokenTreeSlice<'tt> {\n-    Tt(TokenTree),\n-    TtSlice(&'tt [TokenTree]),\n-}\n-\n-impl<'tt> TokenTreeOrTokenTreeSlice<'tt> {\n-    /// Returns the number of constituent top-level token trees of `self` (top-level in that it\n-    /// will not recursively descend into subtrees).\n-    fn len(&self) -> usize {\n-        match *self {\n-            TtSlice(ref v) => v.len(),\n-            Tt(ref tt) => tt.len(),\n-        }\n-    }\n-\n-    /// The `index`-th token tree of `self`.\n-    fn get_tt(&self, index: usize) -> TokenTree {\n-        match *self {\n-            TtSlice(ref v) => v[index].clone(),\n-            Tt(ref tt) => tt.get_tt(index),\n-        }\n-    }\n-}\n-\n /// An unzipping of `TokenTree`s... see the `stack` field of `MatcherPos`.\n ///\n /// This is used by `parse_tt_inner` to keep track of delimited submatchers that we have\n /// descended into.\n #[derive(Clone)]\n struct MatcherTtFrame<'tt> {\n     /// The \"parent\" matcher that we are descending into.\n-    elts: TokenTreeOrTokenTreeSlice<'tt>,\n+    elts: &'tt [TokenTree],\n     /// The position of the \"dot\" in `elts` at the time we descended.\n     idx: usize,\n }\n@@ -138,7 +108,7 @@ type NamedMatchVec = SmallVec<[NamedMatch; 4]>;\n #[derive(Clone)]\n struct MatcherPos<'tt> {\n     /// The token or slice of tokens that make up the matcher. `elts` is short for \"elements\".\n-    top_elts: TokenTreeOrTokenTreeSlice<'tt>,\n+    top_elts: &'tt [TokenTree],\n \n     /// The position of the \"dot\" in this matcher\n     idx: usize,\n@@ -183,7 +153,7 @@ struct MatcherPos<'tt> {\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MatcherPos<'_>, 232);\n+rustc_data_structures::static_assert_size!(MatcherPos<'_>, 136);\n \n impl<'tt> MatcherPos<'tt> {\n     /// `len` `Vec`s (initially shared and empty) that will store matches of metavars.\n@@ -203,7 +173,7 @@ impl<'tt> MatcherPos<'tt> {\n         let match_idx_hi = count_names(ms);\n         MatcherPos {\n             // Start with the top level matcher given to us.\n-            top_elts: TtSlice(ms),\n+            top_elts: ms,\n \n             // The \"dot\" is before the first token of the matcher.\n             idx: 0,\n@@ -224,9 +194,9 @@ impl<'tt> MatcherPos<'tt> {\n         }\n     }\n \n-    fn repetition(up: Box<MatcherPos<'tt>>, sp: DelimSpan, seq: Lrc<SequenceRepetition>) -> Self {\n+    fn repetition(up: Box<MatcherPos<'tt>>, seq: &'tt SequenceRepetition) -> Self {\n         MatcherPos {\n-            stack: smallvec![],\n+            top_elts: &seq.tts,\n             idx: 0,\n             matches: Self::create_matches(up.matches.len()),\n             match_lo: up.match_cur,\n@@ -237,7 +207,7 @@ impl<'tt> MatcherPos<'tt> {\n                 sep: seq.separator.clone(),\n                 seq_op: seq.kleene.op,\n             }),\n-            top_elts: Tt(TokenTree::Sequence(sp, seq)),\n+            stack: smallvec![],\n         }\n     }\n \n@@ -288,8 +258,8 @@ crate type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, N\n pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n     ms.iter().fold(0, |count, elt| {\n         count\n-            + match *elt {\n-                TokenTree::Delimited(_, ref delim) => count_names(&delim.tts),\n+            + match elt {\n+                TokenTree::Delimited(_, delim) => count_names(delim.inner_tts()),\n                 TokenTree::MetaVar(..) => 0,\n                 TokenTree::MetaVarDecl(..) => 1,\n                 // Panicking here would abort execution because `parse_tree` makes use of this\n@@ -298,7 +268,7 @@ pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n                 // `0` is still returned to inform that no meta-variable was found. `Meta-variables\n                 // != Meta-variable expressions`\n                 TokenTree::MetaVarExpr(..) => 0,\n-                TokenTree::Sequence(_, ref seq) => seq.num_captures,\n+                TokenTree::Sequence(_, seq) => seq.num_captures,\n                 TokenTree::Token(..) => 0,\n             }\n     })\n@@ -382,7 +352,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                 }\n             }\n             TokenTree::Delimited(_, ref delim) => {\n-                for next_m in &delim.tts {\n+                for next_m in delim.inner_tts() {\n                     n_rec(sess, next_m, res.by_ref(), ret_val)?;\n                 }\n             }\n@@ -446,8 +416,8 @@ pub struct TtParser<'tt> {\n }\n \n impl<'tt> TtParser<'tt> {\n-    pub(super) fn new(macro_name: Ident) -> Self {\n-        Self { macro_name, cur_items: vec![], next_items: vec![], bb_items: vec![] }\n+    pub(super) fn new(macro_name: Ident) -> TtParser<'tt> {\n+        TtParser { macro_name, cur_items: vec![], next_items: vec![], bb_items: vec![] }\n     }\n \n     /// Process the matcher positions of `cur_items` until it is empty. In the process, this will\n@@ -492,8 +462,8 @@ impl<'tt> TtParser<'tt> {\n             if idx < len {\n                 // We are in the middle of a matcher. Compare the matcher's current tt against\n                 // `token`.\n-                match item.top_elts.get_tt(idx) {\n-                    TokenTree::Sequence(sp, seq) => {\n+                match &item.top_elts[idx] {\n+                    TokenTree::Sequence(_sp, seq) => {\n                         let op = seq.kleene.op;\n                         if op == mbe::KleeneOp::ZeroOrMore || op == mbe::KleeneOp::ZeroOrOne {\n                             // Allow for the possibility of zero matches of this sequence.\n@@ -507,17 +477,17 @@ impl<'tt> TtParser<'tt> {\n                         }\n \n                         // Allow for the possibility of one or more matches of this sequence.\n-                        self.cur_items.push(box MatcherPos::repetition(item, sp, seq));\n+                        self.cur_items.push(box MatcherPos::repetition(item, &seq));\n                     }\n \n-                    TokenTree::MetaVarDecl(span, _, None) => {\n+                    &TokenTree::MetaVarDecl(span, _, None) => {\n                         // E.g. `$e` instead of `$e:expr`.\n                         if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                             return Some(Error(span, \"missing fragment specifier\".to_string()));\n                         }\n                     }\n \n-                    TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n+                    &TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n                         // Built-in nonterminals never start with these tokens, so we can eliminate\n                         // them from consideration.\n                         //\n@@ -528,13 +498,14 @@ impl<'tt> TtParser<'tt> {\n                         }\n                     }\n \n-                    seq @ TokenTree::Delimited(..) => {\n+                    TokenTree::Delimited(_, delimited) => {\n                         // To descend into a delimited submatcher, we push the current matcher onto\n                         // a stack and push a new item containing the submatcher onto `cur_items`.\n                         //\n                         // At the beginning of the loop, if we reach the end of the delimited\n-                        // submatcher, we pop the stack to backtrack out of the descent.\n-                        let lower_elts = mem::replace(&mut item.top_elts, Tt(seq));\n+                        // submatcher, we pop the stack to backtrack out of the descent. Note that\n+                        // we use `all_tts` to include the open and close delimiter tokens.\n+                        let lower_elts = mem::replace(&mut item.top_elts, &delimited.all_tts);\n                         let idx = item.idx;\n                         item.stack.push(MatcherTtFrame { elts: lower_elts, idx });\n                         item.idx = 0;\n@@ -560,7 +531,6 @@ impl<'tt> TtParser<'tt> {\n             } else if let Some(repetition) = &item.repetition {\n                 // We are past the end of a repetition.\n                 debug_assert!(idx <= len + 1);\n-                debug_assert!(matches!(item.top_elts, Tt(TokenTree::Sequence(..))));\n \n                 if idx == len {\n                     // Add all matches from the sequence to `up`, and move the \"dot\" past the\n@@ -678,9 +648,7 @@ impl<'tt> TtParser<'tt> {\n                 (0, 1) => {\n                     // We need to call the black-box parser to get some nonterminal.\n                     let mut item = self.bb_items.pop().unwrap();\n-                    if let TokenTree::MetaVarDecl(span, _, Some(kind)) =\n-                        item.top_elts.get_tt(item.idx)\n-                    {\n+                    if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts[item.idx] {\n                         let match_cur = item.match_cur;\n                         // We use the span of the metavariable declaration to determine any\n                         // edition-specific matching behavior for non-terminals.\n@@ -720,7 +688,7 @@ impl<'tt> TtParser<'tt> {\n         let nts = self\n             .bb_items\n             .iter()\n-            .map(|item| match item.top_elts.get_tt(item.idx) {\n+            .map(|item| match item.top_elts[item.idx] {\n                 TokenTree::MetaVarDecl(_, bind, Some(kind)) => {\n                     format!(\"{} ('{}')\", kind, bind)\n                 }"}, {"sha": "f13b97251d21035a71b340f81ee72814f3b47cb3", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=31df6807893bd9c66cba57ff0f4de89ab9d8460e", "patch": "@@ -203,15 +203,15 @@ fn trace_macros_note(cx_expansions: &mut FxHashMap<Span, Vec<String>>, sp: Span,\n }\n \n /// Given `lhses` and `rhses`, this is the new macro we create\n-fn generic_extension<'cx>(\n+fn generic_extension<'cx, 'tt>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n     def_span: Span,\n     name: Ident,\n     transparency: Transparency,\n     arg: TokenStream,\n-    lhses: &[mbe::TokenTree],\n-    rhses: &[mbe::TokenTree],\n+    lhses: &'tt [mbe::TokenTree],\n+    rhses: &'tt [mbe::TokenTree],\n     is_local: bool,\n ) -> Box<dyn MacResult + 'cx> {\n     let sess = &cx.sess.parse_sess;\n@@ -245,31 +245,30 @@ fn generic_extension<'cx>(\n     // this situation.)\n     let parser = parser_from_cx(sess, arg.clone());\n \n-    let mut tt_parser = TtParser::new(name);\n-    for (i, lhs) in lhses.iter().enumerate() {\n-        // try each arm's matchers\n-        let lhs_tt = match *lhs {\n-            mbe::TokenTree::Delimited(_, ref delim) => &delim.tts,\n+    // A matcher is always delimited, but the delimiters are ignored.\n+    let delimited_inner_tts = |tt: &'tt mbe::TokenTree| -> &'tt [mbe::TokenTree] {\n+        match tt {\n+            mbe::TokenTree::Delimited(_, delimited) => delimited.inner_tts(),\n             _ => cx.span_bug(sp, \"malformed macro lhs\"),\n-        };\n+        }\n+    };\n \n+    // Try each arm's matchers.\n+    let mut tt_parser = TtParser::new(name);\n+    for (i, lhs) in lhses.iter().enumerate() {\n         // Take a snapshot of the state of pre-expansion gating at this point.\n         // This is used so that if a matcher is not `Success(..)`ful,\n         // then the spans which became gated when parsing the unsuccessful matcher\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n-        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n+        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), delimited_inner_tts(lhs)) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n                 sess.gated_spans.merge(gated_spans_snapshot);\n \n-                let rhs = match rhses[i] {\n-                    // ignore delimiters\n-                    mbe::TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n-                    _ => cx.span_bug(sp, \"malformed macro rhs\"),\n-                };\n+                let rhs = delimited_inner_tts(&rhses[i]).to_vec().clone();\n                 let arm_span = rhses[i].span();\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n@@ -347,14 +346,10 @@ fn generic_extension<'cx>(\n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n     if let Some((arg, comma_span)) = arg.add_comma() {\n         for lhs in lhses {\n-            // try each arm's matchers\n-            let lhs_tt = match *lhs {\n-                mbe::TokenTree::Delimited(_, ref delim) => &delim.tts,\n-                _ => continue,\n-            };\n-            if let Success(_) =\n-                tt_parser.parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt)\n-            {\n+            if let Success(_) = tt_parser.parse_tt(\n+                &mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())),\n+                delimited_inner_tts(lhs),\n+            ) {\n                 if comma_span.is_dummy() {\n                     err.note(\"you might be missing a comma\");\n                 } else {\n@@ -477,16 +472,17 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = mbe::quoted::parse(\n+                        let mut tts = vec![];\n+                        mbe::quoted::parse(\n                             tt.clone().into(),\n                             true,\n                             &sess.parse_sess,\n                             def.id,\n                             features,\n                             edition,\n-                        )\n-                        .pop()\n-                        .unwrap();\n+                            &mut tts,\n+                        );\n+                        let tt = tts.pop().unwrap();\n                         valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def, &tt);\n                         return tt;\n                     }\n@@ -503,16 +499,17 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return mbe::quoted::parse(\n+                        let mut tts = vec![];\n+                        mbe::quoted::parse(\n                             tt.clone().into(),\n                             false,\n                             &sess.parse_sess,\n                             def.id,\n                             features,\n                             edition,\n-                        )\n-                        .pop()\n-                        .unwrap();\n+                            &mut tts,\n+                        );\n+                        return tts.pop().unwrap();\n                     }\n                 }\n                 sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n@@ -564,8 +561,8 @@ fn check_lhs_nt_follows(\n ) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n-    if let mbe::TokenTree::Delimited(_, ref tts) = *lhs {\n-        check_matcher(sess, features, def, &tts.tts)\n+    if let mbe::TokenTree::Delimited(_, delimited) = lhs {\n+        check_matcher(sess, features, def, delimited.inner_tts())\n     } else {\n         let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n         sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -586,7 +583,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n             | TokenTree::MetaVarDecl(..)\n             | TokenTree::MetaVarExpr(..) => (),\n             TokenTree::Delimited(_, ref del) => {\n-                if !check_lhs_no_empty_seq(sess, &del.tts) {\n+                if !check_lhs_no_empty_seq(sess, del.inner_tts()) {\n                     return false;\n                 }\n             }\n@@ -681,9 +678,9 @@ impl FirstSets {\n                     | TokenTree::MetaVarExpr(..) => {\n                         first.replace_with(tt.clone());\n                     }\n-                    TokenTree::Delimited(span, ref delimited) => {\n-                        build_recur(sets, &delimited.tts);\n-                        first.replace_with(delimited.open_tt(span));\n+                    TokenTree::Delimited(_span, ref delimited) => {\n+                        build_recur(sets, delimited.inner_tts());\n+                        first.replace_with(delimited.open_tt().clone());\n                     }\n                     TokenTree::Sequence(sp, ref seq_rep) => {\n                         let subfirst = build_recur(sets, &seq_rep.tts);\n@@ -747,8 +744,8 @@ impl FirstSets {\n                     first.add_one(tt.clone());\n                     return first;\n                 }\n-                TokenTree::Delimited(span, ref delimited) => {\n-                    first.add_one(delimited.open_tt(span));\n+                TokenTree::Delimited(_span, ref delimited) => {\n+                    first.add_one(delimited.open_tt().clone());\n                     return first;\n                 }\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n@@ -934,9 +931,9 @@ fn check_matcher_core(\n                     suffix_first = build_suffix_first();\n                 }\n             }\n-            TokenTree::Delimited(span, ref d) => {\n-                let my_suffix = TokenSet::singleton(d.close_tt(span));\n-                check_matcher_core(sess, features, def, first_sets, &d.tts, &my_suffix);\n+            TokenTree::Delimited(_span, ref d) => {\n+                let my_suffix = TokenSet::singleton(d.close_tt().clone());\n+                check_matcher_core(sess, features, def, first_sets, d.inner_tts(), &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n "}, {"sha": "b3ed6b8e4db2423c7b446d0d05675be776a8199b", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=31df6807893bd9c66cba57ff0f4de89ab9d8460e", "patch": "@@ -45,10 +45,8 @@ pub(super) fn parse(\n     node_id: NodeId,\n     features: &Features,\n     edition: Edition,\n-) -> Vec<TokenTree> {\n-    // Will contain the final collection of `self::TokenTree`\n-    let mut result = Vec::new();\n-\n+    result: &mut Vec<TokenTree>,\n+) {\n     // For each token tree in `input`, parse the token into a `self::TokenTree`, consuming\n     // additional trees if need be.\n     let mut trees = input.trees();\n@@ -115,7 +113,6 @@ pub(super) fn parse(\n             _ => result.push(tree),\n         }\n     }\n-    result\n }\n \n /// Asks for the `macro_metavar_expr` feature if it is not already declared\n@@ -208,7 +205,8 @@ fn parse_tree(\n                     // If we didn't find a metavar expression above, then we must have a\n                     // repetition sequence in the macro (e.g. `$(pat)*`).  Parse the\n                     // contents of the sequence itself\n-                    let sequence = parse(tts, parsing_patterns, sess, node_id, features, edition);\n+                    let mut sequence = vec![];\n+                    parse(tts, parsing_patterns, sess, node_id, features, edition, &mut sequence);\n                     // Get the Kleene operator and optional separator\n                     let (separator, kleene) =\n                         parse_sep_and_kleene_op(&mut trees, delim_span.entire(), sess);\n@@ -225,8 +223,8 @@ fn parse_tree(\n                     )\n                 }\n \n-                // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate` special\n-                // metavariable that names the crate of the invocation.\n+                // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate`\n+                // special metavariable that names the crate of the invocation.\n                 Some(tokenstream::TokenTree::Token(token)) if token.is_ident() => {\n                     let (ident, is_raw) = token.ident().unwrap();\n                     let span = ident.span.with_lo(span.lo());\n@@ -270,13 +268,15 @@ fn parse_tree(\n \n         // `tree` is the beginning of a delimited set of tokens (e.g., `(` or `{`). We need to\n         // descend into the delimited set and further parse it.\n-        tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n-            span,\n-            Lrc::new(Delimited {\n-                delim,\n-                tts: parse(tts, parsing_patterns, sess, node_id, features, edition),\n-            }),\n-        ),\n+        tokenstream::TokenTree::Delimited(span, delim, tts) => {\n+            let mut all_tts = vec![];\n+            // Add the explicit open and close delimiters, which\n+            // `tokenstream::TokenTree::Delimited` lacks.\n+            all_tts.push(TokenTree::token(token::OpenDelim(delim), span.open));\n+            parse(tts, parsing_patterns, sess, node_id, features, edition, &mut all_tts);\n+            all_tts.push(TokenTree::token(token::CloseDelim(delim), span.close));\n+            TokenTree::Delimited(span, Lrc::new(Delimited { delim, all_tts }))\n+        }\n     }\n }\n "}, {"sha": "6566338d44febb6ecaddd6524e1d9554093f518b", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31df6807893bd9c66cba57ff0f4de89ab9d8460e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=31df6807893bd9c66cba57ff0f4de89ab9d8460e", "patch": "@@ -10,7 +10,7 @@ use rustc_errors::{pluralize, PResult};\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_span::hygiene::{LocalExpnId, Transparency};\n use rustc_span::symbol::{sym, Ident, MacroRulesNormalizedIdent};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n \n use smallvec::{smallvec, SmallVec};\n use std::mem;\n@@ -34,8 +34,14 @@ enum Frame {\n \n impl Frame {\n     /// Construct a new frame around the delimited set of tokens.\n-    fn new(tts: Vec<mbe::TokenTree>) -> Frame {\n-        let forest = Lrc::new(mbe::Delimited { delim: token::NoDelim, tts });\n+    fn new(mut tts: Vec<mbe::TokenTree>) -> Frame {\n+        // Need to add empty delimeters.\n+        let open_tt = mbe::TokenTree::token(token::OpenDelim(token::NoDelim), DUMMY_SP);\n+        let close_tt = mbe::TokenTree::token(token::CloseDelim(token::NoDelim), DUMMY_SP);\n+        tts.insert(0, open_tt);\n+        tts.push(close_tt);\n+\n+        let forest = Lrc::new(mbe::Delimited { delim: token::NoDelim, all_tts: tts });\n         Frame::Delimited { forest, idx: 0, span: DelimSpan::dummy() }\n     }\n }\n@@ -46,12 +52,14 @@ impl Iterator for Frame {\n     fn next(&mut self) -> Option<mbe::TokenTree> {\n         match *self {\n             Frame::Delimited { ref forest, ref mut idx, .. } => {\n+                let res = forest.inner_tts().get(*idx).cloned();\n                 *idx += 1;\n-                forest.tts.get(*idx - 1).cloned()\n+                res\n             }\n             Frame::Sequence { ref forest, ref mut idx, .. } => {\n+                let res = forest.tts.get(*idx).cloned();\n                 *idx += 1;\n-                forest.tts.get(*idx - 1).cloned()\n+                res\n             }\n         }\n     }\n@@ -376,8 +384,8 @@ fn lockstep_iter_size(\n ) -> LockstepIterSize {\n     use mbe::TokenTree;\n     match *tree {\n-        TokenTree::Delimited(_, ref delimed) => {\n-            delimed.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n+        TokenTree::Delimited(_, ref delimited) => {\n+            delimited.inner_tts().iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }"}]}