{"sha": "db5b51ae634830ac07b199a0842ef839d3809d8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNWI1MWFlNjM0ODMwYWMwN2IxOTlhMDg0MmVmODM5ZDM4MDlkOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-28T02:32:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-28T02:32:30Z"}, "message": "auto merge of #10687 : alexcrichton/rust/issue-10686, r=thestinger\n\nTurns out android doesn't support LLVM's thread_local attribute and accompanying\r\nimplementation.\r\n\r\nCloses #10686", "tree": {"sha": "e4eb360d2e453b709e5cac57e6d8a1152adc967a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4eb360d2e453b709e5cac57e6d8a1152adc967a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db5b51ae634830ac07b199a0842ef839d3809d8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db5b51ae634830ac07b199a0842ef839d3809d8e", "html_url": "https://github.com/rust-lang/rust/commit/db5b51ae634830ac07b199a0842ef839d3809d8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db5b51ae634830ac07b199a0842ef839d3809d8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "503e5df3f273dd7cb24f63098665d6c2c5268ebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/503e5df3f273dd7cb24f63098665d6c2c5268ebf", "html_url": "https://github.com/rust-lang/rust/commit/503e5df3f273dd7cb24f63098665d6c2c5268ebf"}, {"sha": "1686bfabf5dce46c74c04c28efecf4488d674536", "url": "https://api.github.com/repos/rust-lang/rust/commits/1686bfabf5dce46c74c04c28efecf4488d674536", "html_url": "https://github.com/rust-lang/rust/commit/1686bfabf5dce46c74c04c28efecf4488d674536"}], "stats": {"total": 475, "additions": 227, "deletions": 248}, "files": [{"sha": "2375ce55766806969d633145e7449406a4505f80", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db5b51ae634830ac07b199a0842ef839d3809d8e/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5b51ae634830ac07b199a0842ef839d3809d8e/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=db5b51ae634830ac07b199a0842ef839d3809d8e", "patch": "@@ -132,7 +132,7 @@ mod test {\n     #[test]\n     fn thread_local_task_smoke_test() {\n         do run_in_bare_thread {\n-            local_ptr::init_tls_key();\n+            local_ptr::init();\n             let mut sched = ~new_test_uv_sched();\n             let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n@@ -144,7 +144,7 @@ mod test {\n     #[test]\n     fn thread_local_task_two_instances() {\n         do run_in_bare_thread {\n-            local_ptr::init_tls_key();\n+            local_ptr::init();\n             let mut sched = ~new_test_uv_sched();\n             let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n@@ -161,7 +161,7 @@ mod test {\n     #[test]\n     fn borrow_smoke_test() {\n         do run_in_bare_thread {\n-            local_ptr::init_tls_key();\n+            local_ptr::init();\n             let mut sched = ~new_test_uv_sched();\n             let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n@@ -177,7 +177,7 @@ mod test {\n     #[test]\n     fn borrow_with_return() {\n         do run_in_bare_thread {\n-            local_ptr::init_tls_key();\n+            local_ptr::init();\n             let mut sched = ~new_test_uv_sched();\n             let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);"}, {"sha": "c50a9778d33cf11dfd4448d390eb5784959955a6", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 219, "deletions": 238, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/db5b51ae634830ac07b199a0842ef839d3809d8e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5b51ae634830ac07b199a0842ef839d3809d8e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=db5b51ae634830ac07b199a0842ef839d3809d8e", "patch": "@@ -15,286 +15,267 @@\n //! XXX: Add runtime checks for usage of inconsistent pointer types.\n //! and for overwriting an existing pointer.\n \n-use libc::c_void;\n use cast;\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-use ptr;\n use cell::Cell;\n-use option::{Option, Some, None};\n use unstable::finally::Finally;\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-use unstable::mutex::{Mutex, MUTEX_INIT};\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-use tls = rt::thread_local_storage;\n \n-#[cfg(not(stage0), not(windows), test)]\n-#[thread_local]\n-pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;\n+#[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n+#[cfg(target_os = \"android\")] // see #10686\n+#[cfg(stage0)] // only remove this attribute after the next snapshot\n+pub use self::native::*;\n \n-#[cfg(not(stage0), not(windows), not(test))]\n-#[thread_local]\n-pub static mut RT_TLS_PTR: *mut c_void = 0 as *mut c_void;\n+#[cfg(not(stage0), not(windows), not(target_os = \"android\"))]\n+pub use self::compiled::*;\n \n-#[cfg(stage0)]\n-#[cfg(windows)]\n-static mut RT_TLS_KEY: tls::Key = -1;\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-static mut tls_lock: Mutex = MUTEX_INIT;\n-static mut tls_initialized: bool = false;\n+/// Borrow the thread-local value from thread-local storage.\n+/// While the value is borrowed it is not available in TLS.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+pub unsafe fn borrow<T>(f: |&mut T|) {\n+    let mut value = take();\n \n-/// Initialize the TLS key. Other ops will fail if this isn't executed first.\n-#[inline(never)]\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-pub fn init_tls_key() {\n-    unsafe {\n-        tls_lock.lock();\n-        if !tls_initialized {\n-            tls::create(&mut RT_TLS_KEY);\n-            tls_initialized = true;\n-        }\n-        tls_lock.unlock();\n-    }\n-}\n+    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n+    let unsafe_ptr = cast::transmute_mut_region(&mut *value);\n+    let value_cell = Cell::new(value);\n \n-#[cfg(not(stage0), not(windows))]\n-pub fn init_tls_key() {\n-    unsafe {\n-        tls_initialized = true;\n-    }\n+    (|| f(unsafe_ptr)).finally(|| put(value_cell.take()));\n }\n \n-#[cfg(windows)]\n-pub unsafe fn cleanup() {\n-    // No real use to acquiring a lock around these operations. All we're\n-    // going to do is destroy the lock anyway which races locking itself. This\n-    // is why the whole function is labeled as 'unsafe'\n-    assert!(tls_initialized);\n-    tls::destroy(RT_TLS_KEY);\n-    tls_lock.destroy();\n-    tls_initialized = false;\n-}\n+/// Compiled implementation of accessing the runtime local pointer. This is\n+/// implemented using LLVM's thread_local attribute which isn't necessarily\n+/// working on all platforms. This implementation is faster, however, so we use\n+/// it wherever possible.\n+#[cfg(not(windows), not(target_os = \"android\"))]\n+pub mod compiled {\n+    use libc::c_void;\n+    use cast;\n+    use option::{Option, Some, None};\n \n-#[cfg(not(windows))]\n-pub unsafe fn cleanup() {\n-    assert!(tls_initialized);\n-    tls_initialized = false;\n-}\n+    #[cfg(test)]\n+    pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;\n \n-/// Give a pointer to thread-local storage.\n-///\n-/// # Safety note\n-///\n-/// Does not validate the pointer type.\n-#[inline]\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-pub unsafe fn put<T>(sched: ~T) {\n-    let key = tls_key();\n-    let void_ptr: *mut c_void = cast::transmute(sched);\n-    tls::set(key, void_ptr);\n-}\n+    #[cfg(not(test))]\n+    #[thread_local]\n+    pub static mut RT_TLS_PTR: *mut c_void = 0 as *mut c_void;\n \n-/// Give a pointer to thread-local storage.\n-///\n-/// # Safety note\n-///\n-/// Does not validate the pointer type.\n-#[inline]\n-#[cfg(not(stage0), not(windows))]\n-pub unsafe fn put<T>(sched: ~T) {\n-    RT_TLS_PTR = cast::transmute(sched)\n-}\n+    pub fn init() {}\n \n-/// Take ownership of a pointer from thread-local storage.\n-///\n-/// # Safety note\n-///\n-/// Does not validate the pointer type.\n-#[inline]\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-pub unsafe fn take<T>() -> ~T {\n-    let key = tls_key();\n-    let void_ptr: *mut c_void = tls::get(key);\n-    if void_ptr.is_null() {\n-        rtabort!(\"thread-local pointer is null. bogus!\");\n+    pub unsafe fn cleanup() {}\n+\n+    /// Give a pointer to thread-local storage.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// Does not validate the pointer type.\n+    #[inline]\n+    pub unsafe fn put<T>(sched: ~T) {\n+        RT_TLS_PTR = cast::transmute(sched)\n     }\n-    let ptr: ~T = cast::transmute(void_ptr);\n-    tls::set(key, ptr::mut_null());\n-    return ptr;\n-}\n \n-/// Take ownership of a pointer from thread-local storage.\n-///\n-/// # Safety note\n-///\n-/// Does not validate the pointer type.\n-#[inline]\n-#[cfg(not(stage0), not(windows))]\n-pub unsafe fn take<T>() -> ~T {\n-    let ptr: ~T = cast::transmute(RT_TLS_PTR);\n-    RT_TLS_PTR = cast::transmute(0); // can't use `as`, due to type not matching with `cfg(test)`\n-    ptr\n-}\n+    /// Take ownership of a pointer from thread-local storage.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// Does not validate the pointer type.\n+    #[inline]\n+    pub unsafe fn take<T>() -> ~T {\n+        let ptr: ~T = cast::transmute(RT_TLS_PTR);\n+        // can't use `as`, due to type not matching with `cfg(test)`\n+        RT_TLS_PTR = cast::transmute(0);\n+        ptr\n+    }\n \n-/// Take ownership of a pointer from thread-local storage.\n-///\n-/// # Safety note\n-///\n-/// Does not validate the pointer type.\n-/// Leaves the old pointer in TLS for speed.\n-#[inline]\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-pub unsafe fn unsafe_take<T>() -> ~T {\n-    let key = tls_key();\n-    let void_ptr: *mut c_void = tls::get(key);\n-    if void_ptr.is_null() {\n-        rtabort!(\"thread-local pointer is null. bogus!\");\n+    /// Take ownership of a pointer from thread-local storage.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// Does not validate the pointer type.\n+    /// Leaves the old pointer in TLS for speed.\n+    #[inline]\n+    pub unsafe fn unsafe_take<T>() -> ~T {\n+        cast::transmute(RT_TLS_PTR)\n     }\n-    let ptr: ~T = cast::transmute(void_ptr);\n-    return ptr;\n-}\n \n-/// Take ownership of a pointer from thread-local storage.\n-///\n-/// # Safety note\n-///\n-/// Does not validate the pointer type.\n-/// Leaves the old pointer in TLS for speed.\n-#[inline]\n-#[cfg(not(stage0), not(windows))]\n-pub unsafe fn unsafe_take<T>() -> ~T {\n-    cast::transmute(RT_TLS_PTR)\n-}\n+    /// Check whether there is a thread-local pointer installed.\n+    pub fn exists() -> bool {\n+        unsafe {\n+            RT_TLS_PTR.is_not_null()\n+        }\n+    }\n \n-/// Check whether there is a thread-local pointer installed.\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-pub fn exists() -> bool {\n-    unsafe {\n-        match maybe_tls_key() {\n-            Some(key) => tls::get(key).is_not_null(),\n-            None => false\n+    pub unsafe fn unsafe_borrow<T>() -> *mut T {\n+        if RT_TLS_PTR.is_null() {\n+            rtabort!(\"thread-local pointer is null. bogus!\");\n         }\n+        RT_TLS_PTR as *mut T\n     }\n-}\n \n-/// Check whether there is a thread-local pointer installed.\n-#[cfg(not(stage0), not(windows))]\n-pub fn exists() -> bool {\n-    unsafe {\n-        RT_TLS_PTR.is_not_null()\n+    pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n+        if RT_TLS_PTR.is_null() {\n+            None\n+        } else {\n+            Some(RT_TLS_PTR as *mut T)\n+        }\n     }\n }\n \n-/// Borrow the thread-local value from thread-local storage.\n-/// While the value is borrowed it is not available in TLS.\n-///\n-/// # Safety note\n-///\n-/// Does not validate the pointer type.\n-pub unsafe fn borrow<T>(f: |&mut T|) {\n-    let mut value = take();\n+/// Native implementation of having the runtime thread-local pointer. This\n+/// implementation uses the `thread_local_storage` module to provide a\n+/// thread-local value.\n+pub mod native {\n+    use cast;\n+    use libc::c_void;\n+    use option::{Option, Some, None};\n+    use ptr;\n+    use tls = rt::thread_local_storage;\n+    use unstable::mutex::{Mutex, MUTEX_INIT};\n \n-    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n-    let unsafe_ptr = cast::transmute_mut_region(&mut *value);\n-    let value_cell = Cell::new(value);\n+    static mut LOCK: Mutex = MUTEX_INIT;\n+    static mut INITIALIZED: bool = false;\n+    static mut RT_TLS_KEY: tls::Key = -1;\n \n-    (|| f(unsafe_ptr)).finally(|| put(value_cell.take()));\n-}\n+    /// Initialize the TLS key. Other ops will fail if this isn't executed\n+    /// first.\n+    pub fn init() {\n+        unsafe {\n+            LOCK.lock();\n+            if !INITIALIZED {\n+                tls::create(&mut RT_TLS_KEY);\n+                INITIALIZED = true;\n+            }\n+            LOCK.unlock();\n+        }\n+    }\n \n-/// Borrow a mutable reference to the thread-local value\n-///\n-/// # Safety Note\n-///\n-/// Because this leaves the value in thread-local storage it is possible\n-/// For the Scheduler pointer to be aliased\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-pub unsafe fn unsafe_borrow<T>() -> *mut T {\n-    let key = tls_key();\n-    let void_ptr = tls::get(key);\n-    if void_ptr.is_null() {\n-        rtabort!(\"thread-local pointer is null. bogus!\");\n+    pub unsafe fn cleanup() {\n+        assert!(INITIALIZED);\n+        tls::destroy(RT_TLS_KEY);\n+        LOCK.destroy();\n+        INITIALIZED = false;\n     }\n-    void_ptr as *mut T\n-}\n \n-#[cfg(not(stage0), not(windows))]\n-pub unsafe fn unsafe_borrow<T>() -> *mut T {\n-    if RT_TLS_PTR.is_null() {\n-        rtabort!(\"thread-local pointer is null. bogus!\");\n+    /// Give a pointer to thread-local storage.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// Does not validate the pointer type.\n+    #[inline]\n+    pub unsafe fn put<T>(sched: ~T) {\n+        let key = tls_key();\n+        let void_ptr: *mut c_void = cast::transmute(sched);\n+        tls::set(key, void_ptr);\n     }\n-    RT_TLS_PTR as *mut T\n-}\n \n-#[cfg(stage0)]\n-#[cfg(windows)]\n-pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n-    match maybe_tls_key() {\n-        Some(key) => {\n-            let void_ptr = tls::get(key);\n-            if void_ptr.is_null() {\n-                None\n-            } else {\n-                Some(void_ptr as *mut T)\n+    /// Take ownership of a pointer from thread-local storage.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// Does not validate the pointer type.\n+    #[inline]\n+    pub unsafe fn take<T>() -> ~T {\n+        let key = tls_key();\n+        let void_ptr: *mut c_void = tls::get(key);\n+        if void_ptr.is_null() {\n+            rtabort!(\"thread-local pointer is null. bogus!\");\n+        }\n+        let ptr: ~T = cast::transmute(void_ptr);\n+        tls::set(key, ptr::mut_null());\n+        return ptr;\n+    }\n+\n+    /// Take ownership of a pointer from thread-local storage.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// Does not validate the pointer type.\n+    /// Leaves the old pointer in TLS for speed.\n+    #[inline]\n+    pub unsafe fn unsafe_take<T>() -> ~T {\n+        let key = tls_key();\n+        let void_ptr: *mut c_void = tls::get(key);\n+        if void_ptr.is_null() {\n+            rtabort!(\"thread-local pointer is null. bogus!\");\n+        }\n+        let ptr: ~T = cast::transmute(void_ptr);\n+        return ptr;\n+    }\n+\n+    /// Check whether there is a thread-local pointer installed.\n+    pub fn exists() -> bool {\n+        unsafe {\n+            match maybe_tls_key() {\n+                Some(key) => tls::get(key).is_not_null(),\n+                None => false\n             }\n         }\n-        None => None\n     }\n-}\n \n-#[cfg(not(stage0), not(windows))]\n-pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n-    if RT_TLS_PTR.is_null() {\n-        None\n-    } else {\n-        Some(RT_TLS_PTR as *mut T)\n+    /// Borrow a mutable reference to the thread-local value\n+    ///\n+    /// # Safety Note\n+    ///\n+    /// Because this leaves the value in thread-local storage it is possible\n+    /// For the Scheduler pointer to be aliased\n+    pub unsafe fn unsafe_borrow<T>() -> *mut T {\n+        let key = tls_key();\n+        let void_ptr = tls::get(key);\n+        if void_ptr.is_null() {\n+            rtabort!(\"thread-local pointer is null. bogus!\");\n+        }\n+        void_ptr as *mut T\n     }\n-}\n \n-#[inline]\n-#[cfg(stage0)]\n-#[cfg(windows)]\n-fn tls_key() -> tls::Key {\n-    match maybe_tls_key() {\n-        Some(key) => key,\n-        None => rtabort!(\"runtime tls key not initialized\")\n+    pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n+        match maybe_tls_key() {\n+            Some(key) => {\n+                let void_ptr = tls::get(key);\n+                if void_ptr.is_null() {\n+                    None\n+                } else {\n+                    Some(void_ptr as *mut T)\n+                }\n+            }\n+            None => None\n+        }\n     }\n-}\n \n-#[inline]\n-#[cfg(not(test), stage0)]\n-#[cfg(not(test), windows)]\n-pub fn maybe_tls_key() -> Option<tls::Key> {\n-    unsafe {\n-        // NB: This is a little racy because, while the key is\n-        // initalized under a mutex and it's assumed to be initalized\n-        // in the Scheduler ctor by any thread that needs to use it,\n-        // we are not accessing the key under a mutex.  Threads that\n-        // are not using the new Scheduler but still *want to check*\n-        // whether they are running under a new Scheduler may see a 0\n-        // value here that is in the process of being initialized in\n-        // another thread. I think this is fine since the only action\n-        // they could take if it was initialized would be to check the\n-        // thread-local value and see that it's not set.\n-        if RT_TLS_KEY != -1 {\n-            return Some(RT_TLS_KEY);\n-        } else {\n-            return None;\n+    #[inline]\n+    fn tls_key() -> tls::Key {\n+        match maybe_tls_key() {\n+            Some(key) => key,\n+            None => rtabort!(\"runtime tls key not initialized\")\n+        }\n+    }\n+\n+    #[inline]\n+    #[cfg(not(test))]\n+    pub fn maybe_tls_key() -> Option<tls::Key> {\n+        unsafe {\n+            // NB: This is a little racy because, while the key is\n+            // initalized under a mutex and it's assumed to be initalized\n+            // in the Scheduler ctor by any thread that needs to use it,\n+            // we are not accessing the key under a mutex.  Threads that\n+            // are not using the new Scheduler but still *want to check*\n+            // whether they are running under a new Scheduler may see a 0\n+            // value here that is in the process of being initialized in\n+            // another thread. I think this is fine since the only action\n+            // they could take if it was initialized would be to check the\n+            // thread-local value and see that it's not set.\n+            if RT_TLS_KEY != -1 {\n+                return Some(RT_TLS_KEY);\n+            } else {\n+                return None;\n+            }\n         }\n     }\n-}\n \n-#[inline]\n-#[cfg(test, stage0)]\n-#[cfg(test, windows)]\n-pub fn maybe_tls_key() -> Option<tls::Key> {\n-    unsafe { ::cast::transmute(::realstd::rt::shouldnt_be_public::maybe_tls_key()) }\n+    #[inline] #[cfg(test)]\n+    pub fn maybe_tls_key() -> Option<tls::Key> {\n+        use realstd;\n+        unsafe {\n+            cast::transmute(realstd::rt::shouldnt_be_public::maybe_tls_key())\n+        }\n+    }\n }"}, {"sha": "0c69315b27dca919969ef7d90ed2f5c8f9493b72", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db5b51ae634830ac07b199a0842ef839d3809d8e/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5b51ae634830ac07b199a0842ef839d3809d8e/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=db5b51ae634830ac07b199a0842ef839d3809d8e", "patch": "@@ -95,11 +95,9 @@ pub use self::kill::BlockedTask;\n pub mod shouldnt_be_public {\n     pub use super::select::SelectInner;\n     pub use super::select::{SelectInner, SelectPortInner};\n-    #[cfg(stage0)]\n-    #[cfg(windows)]\n-    pub use super::local_ptr::maybe_tls_key;\n-    #[cfg(not(stage0), not(windows))]\n-    pub use super::local_ptr::RT_TLS_PTR;\n+    pub use super::local_ptr::native::maybe_tls_key;\n+    #[cfg(not(stage0), not(windows), not(target_os = \"android\"))]\n+    pub use super::local_ptr::compiled::RT_TLS_PTR;\n }\n \n // Internal macros used by the runtime."}, {"sha": "21753d9e4d99ec3d8211a2f32a8ffc34db9c6df9", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db5b51ae634830ac07b199a0842ef839d3809d8e/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5b51ae634830ac07b199a0842ef839d3809d8e/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=db5b51ae634830ac07b199a0842ef839d3809d8e", "patch": "@@ -172,7 +172,7 @@ impl Scheduler {\n         self.idle_callback = Some(self.event_loop.pausible_idle_callback(cb));\n \n         // Initialize the TLS key.\n-        local_ptr::init_tls_key();\n+        local_ptr::init();\n \n         // Create a task for the scheduler with an empty context.\n         let sched_task = ~Task::new_sched_task();"}]}