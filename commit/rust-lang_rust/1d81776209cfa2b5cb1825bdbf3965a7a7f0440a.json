{"sha": "1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkODE3NzYyMDljZmEyYjVjYjE4MjViZGJmMzk2NWE3YTdmMDQ0MGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-20T12:01:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-20T12:01:44Z"}, "message": "auto merge of #19113 : nikomatsakis/rust/unboxed-boxed-closure-unification, r=acrichto\n\nUse the expected type to infer the argument/return types of unboxed closures. Also, in `||` expressions, use the expected type to decide if the result should be a boxed or unboxed closure (and if an unboxed closure, what kind).\r\n\r\nThis supercedes PR #19089, which was already reviewed by @pcwalton.", "tree": {"sha": "43c3aa55ebfb5fd8b24173e1315a4212346bbd8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43c3aa55ebfb5fd8b24173e1315a4212346bbd8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "html_url": "https://github.com/rust-lang/rust/commit/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b825b3496aff1ed784f7a7ca935245208b95aabb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b825b3496aff1ed784f7a7ca935245208b95aabb", "html_url": "https://github.com/rust-lang/rust/commit/b825b3496aff1ed784f7a7ca935245208b95aabb"}, {"sha": "b9c5cd4dc420b90874784b253bcb8fd4ac72441a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c5cd4dc420b90874784b253bcb8fd4ac72441a", "html_url": "https://github.com/rust-lang/rust/commit/b9c5cd4dc420b90874784b253bcb8fd4ac72441a"}], "stats": {"total": 939, "additions": 595, "deletions": 344}, "files": [{"sha": "d421b3ebdf3d1d4bb79d36f988dfa8f4df63f983", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -288,9 +288,12 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n             ast::ExprProc(_, ref block) |\n-            ast::ExprFnBlock(_, _, ref block) |\n-            ast::ExprUnboxedFn(_, _, _, ref block) => { block.id }\n-            _ => panic!(\"encountered non-closure id: {}\", closure_id)\n+            ast::ExprClosure(_, _, _, ref block) => {\n+                block.id\n+            }\n+            _ => {\n+                panic!(\"encountered non-closure id: {}\", closure_id)\n+            }\n         },\n         _ => panic!(\"encountered non-expr id: {}\", closure_id)\n     }"}, {"sha": "04c8a4fe59412ad787db90bf7568f25f2d8065eb", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -496,9 +496,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprMac(..) |\n-            ast::ExprFnBlock(..) |\n+            ast::ExprClosure(..) |\n             ast::ExprProc(..) |\n-            ast::ExprUnboxedFn(..) |\n             ast::ExprLit(..) |\n             ast::ExprPath(..) => {\n                 self.straightline(expr, pred, None::<ast::Expr>.iter())"}, {"sha": "36742df98503190a0dd2e40570259ad0fe17f1d8", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -48,9 +48,8 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n                 self.visit_expr(&**e);\n                 self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n-            ast::ExprFnBlock(_, _, ref b) |\n-            ast::ExprProc(_, ref b) |\n-            ast::ExprUnboxedFn(_, _, _, ref b) => {\n+            ast::ExprClosure(_, _, _, ref b) |\n+            ast::ExprProc(_, ref b) => {\n                 self.with_context(Closure, |v| v.visit_block(&**b));\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", e.span),"}, {"sha": "08605f76e02495fcfe4b421e2e116dfbc1b11b7b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -496,8 +496,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 self.consume_expr(&**count);\n             }\n \n-            ast::ExprFnBlock(..) |\n-            ast::ExprUnboxedFn(..) |\n+            ast::ExprClosure(..) |\n             ast::ExprProc(..) => {\n                 self.walk_captures(expr)\n             }"}, {"sha": "7d13d2e5f9431733f5be8e900a6c3d3e7229c8a2", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -458,7 +458,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         }\n         visit::walk_expr(ir, expr);\n       }\n-      ast::ExprFnBlock(..) | ast::ExprProc(..) | ast::ExprUnboxedFn(..) => {\n+      ast::ExprClosure(..) | ast::ExprProc(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -975,10 +975,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ast::ExprFnBlock(_, _, ref blk) |\n-          ast::ExprProc(_, ref blk) |\n-          ast::ExprUnboxedFn(_, _, _, ref blk) => {\n-              debug!(\"{} is an ExprFnBlock, ExprProc, or ExprUnboxedFn\",\n+          ast::ExprClosure(_, _, _, ref blk) |\n+          ast::ExprProc(_, ref blk) => {\n+              debug!(\"{} is an ExprClosure or ExprProc\",\n                      expr_to_string(expr));\n \n               /*\n@@ -1495,7 +1494,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprBreak(..) | ast::ExprAgain(..) | ast::ExprLit(_) |\n       ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n       ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n-      ast::ExprFnBlock(..) | ast::ExprProc(..) | ast::ExprUnboxedFn(..) |\n+      ast::ExprClosure(..) | ast::ExprProc(..) |\n       ast::ExprPath(..) | ast::ExprBox(..) | ast::ExprSlice(..) => {\n         visit::walk_expr(this, expr);\n       }"}, {"sha": "3166f6b1495eb54a82aad1342cea4d7e28827927", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -520,8 +520,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n-          ast::ExprFnBlock(..) | ast::ExprProc(..) |\n-          ast::ExprUnboxedFn(..) | ast::ExprRet(..) |\n+          ast::ExprClosure(..) | ast::ExprProc(..) |\n+          ast::ExprRet(..) |\n           ast::ExprUnary(..) | ast::ExprSlice(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n@@ -693,9 +693,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 };\n \n                 match fn_expr.node {\n-                    ast::ExprFnBlock(_, _, ref body) |\n                     ast::ExprProc(_, ref body) |\n-                    ast::ExprUnboxedFn(_, _, _, ref body) => body.id,\n+                    ast::ExprClosure(_, _, _, ref body) => body.id,\n                     _ => unreachable!()\n                 }\n             };"}, {"sha": "901f602ff30a84d55136a7782deeced2f6fe0c97", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -50,8 +50,8 @@ use util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n-use syntax::ast::{ExprFnBlock, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n-use syntax::ast::{ExprPath, ExprProc, ExprStruct, ExprUnboxedFn, FnDecl};\n+use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n+use syntax::ast::{ExprPath, ExprProc, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n@@ -5848,24 +5848,19 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprFnBlock(capture_clause, ref fn_decl, ref block) => {\n+            ExprClosure(capture_clause, _, ref fn_decl, ref block) => {\n                 self.capture_mode_map.insert(expr.id, capture_clause);\n                 self.resolve_function(ClosureRibKind(expr.id, ast::DUMMY_NODE_ID),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n             }\n+\n             ExprProc(ref fn_decl, ref block) => {\n                 self.capture_mode_map.insert(expr.id, ast::CaptureByValue);\n                 self.resolve_function(ClosureRibKind(expr.id, block.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n             }\n-            ExprUnboxedFn(capture_clause, _, ref fn_decl, ref block) => {\n-                self.capture_mode_map.insert(expr.id, capture_clause);\n-                self.resolve_function(ClosureRibKind(expr.id, block.id),\n-                                      Some(&**fn_decl), NoTypeParameters,\n-                                      &**block);\n-            }\n \n             ExprStruct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to. We don't"}, {"sha": "62382ac386fcd8719411f6199cb9bd40698e981a", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -109,6 +109,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.select(&mut selcx, false)\n     }\n \n+    pub fn pending_trait_obligations(&self) -> &[Obligation<'tcx>] {\n+        self.trait_obligations[]\n+    }\n+\n     fn select<'a>(&mut self,\n                   selcx: &mut SelectionContext<'a, 'tcx>,\n                   only_new_obligations: bool)"}, {"sha": "6552a5b4351ac047e343fa38a6e81b66fdcc3cbd", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -3919,9 +3919,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprTup(..) |\n         ast::ExprIf(..) |\n         ast::ExprMatch(..) |\n-        ast::ExprFnBlock(..) |\n+        ast::ExprClosure(..) |\n         ast::ExprProc(..) |\n-        ast::ExprUnboxedFn(..) |\n         ast::ExprBlock(..) |\n         ast::ExprRepeat(..) |\n         ast::ExprVec(..) => {"}, {"sha": "5cd0a7add44992469c9e52fcb37d5b7331071d0f", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -995,7 +995,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             }\n             ast::TyInfer => {\n                 // TyInfer also appears as the type of arguments or return\n-                // values in a ExprFnBlock, ExprProc, or ExprUnboxedFn, or as\n+                // values in a ExprClosure or ExprProc, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n                 this.ty_infer(ast_ty.span)"}, {"sha": "51636f00c391ad2171fb9022e2f5d85e9ed05f53", "filename": "src/librustc/middle/typeck/check/closure.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fclosure.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -0,0 +1,346 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Code for type-checking closure expressions.\n+ */\n+\n+use super::check_fn;\n+use super::{Expectation, ExpectCastableToType, ExpectHasType, NoExpectation};\n+use super::FnCtxt;\n+\n+use middle::subst;\n+use middle::ty::{mod, Ty};\n+use middle::typeck::astconv;\n+use middle::typeck::infer;\n+use middle::typeck::rscope::RegionScope;\n+use syntax::abi;\n+use syntax::ast;\n+use syntax::ast_util;\n+use util::ppaux::Repr;\n+\n+pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                   expr: &ast::Expr,\n+                                   opt_kind: Option<ast::UnboxedClosureKind>,\n+                                   decl: &ast::FnDecl,\n+                                   body: &ast::Block,\n+                                   expected: Expectation<'tcx>) {\n+    debug!(\"check_expr_closure(expr={},expected={})\",\n+           expr.repr(fcx.tcx()),\n+           expected.repr(fcx.tcx()));\n+\n+    match opt_kind {\n+        None => {\n+            // If users didn't specify what sort of closure they want,\n+            // examine the expected type. For now, if we see explicit\n+            // evidence than an unboxed closure is desired, we'll use\n+            // that, otherwise we'll fall back to boxed closures.\n+            match deduce_unboxed_closure_expectations_from_expectation(fcx, expected) {\n+                None => { // doesn't look like an unboxed closure\n+                    let region = astconv::opt_ast_region_to_region(fcx,\n+                                                                   fcx.infcx(),\n+                                                                   expr.span,\n+                                                                   &None);\n+                    check_boxed_closure(fcx,\n+                                        expr,\n+                                        ty::RegionTraitStore(region, ast::MutMutable),\n+                                        decl,\n+                                        body,\n+                                        expected);\n+                }\n+                Some((sig, kind)) => {\n+                    check_unboxed_closure(fcx, expr, kind, decl, body, Some(sig));\n+                }\n+            }\n+        }\n+\n+        Some(kind) => {\n+            let kind = match kind {\n+                ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n+                ast::FnMutUnboxedClosureKind => ty::FnMutUnboxedClosureKind,\n+                ast::FnOnceUnboxedClosureKind => ty::FnOnceUnboxedClosureKind,\n+            };\n+\n+            let expected_sig =\n+                deduce_unboxed_closure_expectations_from_expectation(fcx, expected)\n+                .map(|t| t.0);\n+\n+            check_unboxed_closure(fcx, expr, kind, decl, body, expected_sig);\n+        }\n+    }\n+}\n+\n+fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                  expr: &ast::Expr,\n+                                  kind: ty::UnboxedClosureKind,\n+                                  decl: &ast::FnDecl,\n+                                  body: &ast::Block,\n+                                  expected_sig: Option<ty::FnSig<'tcx>>) {\n+    let expr_def_id = ast_util::local_def(expr.id);\n+\n+    debug!(\"check_unboxed_closure kind={} expected_sig={}\",\n+           kind,\n+           expected_sig.repr(fcx.tcx()));\n+\n+    let mut fn_ty = astconv::ty_of_closure(\n+        fcx,\n+        ast::NormalFn,\n+        ast::Many,\n+\n+        // The `RegionTraitStore` and region_existential_bounds\n+        // are lies, but we ignore them so it doesn't matter.\n+        //\n+        // FIXME(pcwalton): Refactor this API.\n+        ty::region_existential_bound(ty::ReStatic),\n+        ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n+\n+        decl,\n+        abi::RustCall,\n+        expected_sig);\n+\n+    let region = match fcx.infcx().anon_regions(expr.span, 1) {\n+        Err(_) => {\n+            fcx.ccx.tcx.sess.span_bug(expr.span,\n+                                      \"can't make anon regions here?!\")\n+        }\n+        Ok(regions) => regions[0],\n+    };\n+\n+    let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n+                                              expr_def_id,\n+                                              region,\n+                                              fcx.inh.param_env.free_substs.clone());\n+\n+    fcx.write_ty(expr.id, closure_type);\n+\n+    check_fn(fcx.ccx,\n+             ast::NormalFn,\n+             expr.id,\n+             &fn_ty.sig,\n+             decl,\n+             expr.id,\n+             &*body,\n+             fcx.inh);\n+\n+    // Tuple up the arguments and insert the resulting function type into\n+    // the `unboxed_closures` table.\n+    fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n+\n+    debug!(\"unboxed_closure for {} --> sig={} kind={}\",\n+           expr_def_id.repr(fcx.tcx()),\n+           fn_ty.sig.repr(fcx.tcx()),\n+           kind);\n+\n+    let unboxed_closure = ty::UnboxedClosure {\n+        closure_type: fn_ty,\n+        kind: kind,\n+    };\n+\n+    fcx.inh\n+        .unboxed_closures\n+        .borrow_mut()\n+        .insert(expr_def_id, unboxed_closure);\n+}\n+\n+fn deduce_unboxed_closure_expectations_from_expectation<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    expected: Expectation<'tcx>)\n+    -> Option<(ty::FnSig<'tcx>,ty::UnboxedClosureKind)>\n+{\n+    match expected.resolve(fcx) {\n+        NoExpectation => None,\n+        ExpectCastableToType(t) | ExpectHasType(t) => {\n+            deduce_unboxed_closure_expectations_from_expected_type(fcx, t)\n+        }\n+    }\n+}\n+\n+fn deduce_unboxed_closure_expectations_from_expected_type<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    expected_ty: Ty<'tcx>)\n+    -> Option<(ty::FnSig<'tcx>,ty::UnboxedClosureKind)>\n+{\n+    match expected_ty.sty {\n+        ty::ty_trait(ref object_type) => {\n+            deduce_unboxed_closure_expectations_from_trait_ref(fcx, &object_type.principal)\n+        }\n+        ty::ty_infer(ty::TyVar(vid)) => {\n+            deduce_unboxed_closure_expectations_from_obligations(fcx, vid)\n+        }\n+        _ => {\n+            None\n+        }\n+    }\n+}\n+\n+fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    trait_ref: &ty::TraitRef<'tcx>)\n+    -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n+{\n+    let tcx = fcx.tcx();\n+\n+    debug!(\"deduce_unboxed_closure_expectations_from_object_type({})\",\n+           trait_ref.repr(tcx));\n+\n+    let def_id_kinds = [\n+        (tcx.lang_items.fn_trait(), ty::FnUnboxedClosureKind),\n+        (tcx.lang_items.fn_mut_trait(), ty::FnMutUnboxedClosureKind),\n+        (tcx.lang_items.fn_once_trait(), ty::FnOnceUnboxedClosureKind),\n+    ];\n+\n+    for &(def_id, kind) in def_id_kinds.iter() {\n+        if Some(trait_ref.def_id) == def_id {\n+            debug!(\"found object type {}\", kind);\n+\n+            let arg_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n+            let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(arg_param_ty);\n+            debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n+\n+            let input_tys = match arg_param_ty.sty {\n+                ty::ty_tup(ref tys) => { (*tys).clone() }\n+                _ => { continue; }\n+            };\n+            debug!(\"input_tys {}\", input_tys.repr(tcx));\n+\n+            let ret_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 1);\n+            let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(ret_param_ty);\n+            debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n+\n+            let fn_sig = ty::FnSig {\n+                inputs: input_tys,\n+                output: ty::FnConverging(ret_param_ty),\n+                variadic: false\n+            };\n+            debug!(\"fn_sig {}\", fn_sig.repr(tcx));\n+\n+            return Some((fn_sig, kind));\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    expected_vid: ty::TyVid)\n+    -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n+{\n+    // Here `expected_ty` is known to be a type inference variable.\n+    for obligation in fcx.inh.fulfillment_cx.borrow().pending_trait_obligations().iter() {\n+        let obligation_self_ty = fcx.infcx().shallow_resolve(obligation.self_ty());\n+        match obligation_self_ty.sty {\n+            ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n+            _ => { continue; }\n+        }\n+\n+        match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &*obligation.trait_ref) {\n+            Some(e) => { return Some(e); }\n+            None => { }\n+        }\n+    }\n+\n+    None\n+}\n+\n+\n+pub fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                    expr: &ast::Expr,\n+                                    store: ty::TraitStore,\n+                                    decl: &ast::FnDecl,\n+                                    body: &ast::Block,\n+                                    expected: Expectation<'tcx>) {\n+    let tcx = fcx.ccx.tcx;\n+\n+    // Find the expected input/output types (if any). Substitute\n+    // fresh bound regions for any bound regions we find in the\n+    // expected types so as to avoid capture.\n+    let expected_sty = expected.map_to_option(fcx, |x| Some((*x).clone()));\n+    let (expected_sig,\n+         expected_onceness,\n+         expected_bounds) = {\n+        match expected_sty {\n+            Some(ty::ty_closure(ref cenv)) => {\n+                let (sig, _) =\n+                    ty::replace_late_bound_regions(\n+                        tcx,\n+                        &cenv.sig,\n+                        |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n+                let onceness = match (&store, &cenv.store) {\n+                    // As the closure type and onceness go, only three\n+                    // combinations are legit:\n+                    //      once closure\n+                    //      many closure\n+                    //      once proc\n+                    // If the actual and expected closure type disagree with\n+                    // each other, set expected onceness to be always Once or\n+                    // Many according to the actual type. Otherwise, it will\n+                    // yield either an illegal \"many proc\" or a less known\n+                    // \"once closure\" in the error message.\n+                    (&ty::UniqTraitStore, &ty::UniqTraitStore) |\n+                    (&ty::RegionTraitStore(..), &ty::RegionTraitStore(..)) =>\n+                        cenv.onceness,\n+                    (&ty::UniqTraitStore, _) => ast::Once,\n+                    (&ty::RegionTraitStore(..), _) => ast::Many,\n+                };\n+                (Some(sig), onceness, cenv.bounds)\n+            }\n+            _ => {\n+                // Not an error! Means we're inferring the closure type\n+                let (bounds, onceness) = match expr.node {\n+                    ast::ExprProc(..) => {\n+                        let mut bounds = ty::region_existential_bound(ty::ReStatic);\n+                        bounds.builtin_bounds.insert(ty::BoundSend); // FIXME\n+                        (bounds, ast::Once)\n+                    }\n+                    _ => {\n+                        let region = fcx.infcx().next_region_var(\n+                            infer::AddrOfRegion(expr.span));\n+                        (ty::region_existential_bound(region), ast::Many)\n+                    }\n+                };\n+                (None, onceness, bounds)\n+            }\n+        }\n+    };\n+\n+    // construct the function type\n+    let fn_ty = astconv::ty_of_closure(fcx,\n+                                       ast::NormalFn,\n+                                       expected_onceness,\n+                                       expected_bounds,\n+                                       store,\n+                                       decl,\n+                                       abi::Rust,\n+                                       expected_sig);\n+    let fty_sig = fn_ty.sig.clone();\n+    let fty = ty::mk_closure(tcx, fn_ty);\n+    debug!(\"check_expr_fn fty={}\", fcx.infcx().ty_to_string(fty));\n+\n+    fcx.write_ty(expr.id, fty);\n+\n+    // If the closure is a stack closure and hasn't had some non-standard\n+    // style inferred for it, then check it under its parent's style.\n+    // Otherwise, use its own\n+    let (inherited_style, inherited_style_id) = match store {\n+        ty::RegionTraitStore(..) => (fcx.ps.borrow().fn_style,\n+                                     fcx.ps.borrow().def),\n+        ty::UniqTraitStore => (ast::NormalFn, expr.id)\n+    };\n+\n+    check_fn(fcx.ccx,\n+             inherited_style,\n+             inherited_style_id,\n+             &fty_sig,\n+             &*decl,\n+             expr.id,\n+             &*body,\n+             fcx.inh);\n+}"}, {"sha": "1430bf87f4e11c569f53f66561738696eb3b9299", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 197, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -78,7 +78,7 @@ type parameter).\n \n pub use self::LvaluePreference::*;\n pub use self::DerefArgs::*;\n-use self::Expectation::*;\n+pub use self::Expectation::*;\n use self::IsBinopAssignment::*;\n use self::TupleArgumentsFlag::*;\n \n@@ -97,7 +97,7 @@ use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{mod, Ty};\n-use middle::ty::{replace_late_bound_regions, liberate_late_bound_regions};\n+use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n@@ -147,6 +147,7 @@ pub mod regionck;\n pub mod demand;\n pub mod method;\n pub mod wf;\n+mod closure;\n \n /// Fields that are part of a `FnCtxt` which are inherited by\n /// closures defined within the function.  For example:\n@@ -2833,9 +2834,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n         for (i, arg) in args.iter().take(t).enumerate() {\n             let is_block = match arg.node {\n-                ast::ExprFnBlock(..) |\n-                ast::ExprProc(..) |\n-                ast::ExprUnboxedFn(..) => true,\n+                ast::ExprClosure(..) | ast::ExprProc(..) => true,\n                 _ => false\n             };\n \n@@ -3530,174 +3529,6 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         })\n     }\n \n-    fn check_unboxed_closure(fcx: &FnCtxt,\n-                             expr: &ast::Expr,\n-                             kind: ast::UnboxedClosureKind,\n-                             decl: &ast::FnDecl,\n-                             body: &ast::Block) {\n-        let mut fn_ty = astconv::ty_of_closure(\n-            fcx,\n-            ast::NormalFn,\n-            ast::Many,\n-\n-            // The `RegionTraitStore` and region_existential_bounds\n-            // are lies, but we ignore them so it doesn't matter.\n-            //\n-            // FIXME(pcwalton): Refactor this API.\n-            ty::region_existential_bound(ty::ReStatic),\n-            ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n-\n-            decl,\n-            abi::RustCall,\n-            None);\n-\n-        let region = match fcx.infcx().anon_regions(expr.span, 1) {\n-            Err(_) => {\n-                fcx.ccx.tcx.sess.span_bug(expr.span,\n-                                          \"can't make anon regions here?!\")\n-            }\n-            Ok(regions) => regions[0],\n-        };\n-        let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n-                                                  local_def(expr.id),\n-                                                  region,\n-                                                  fcx.inh.param_env.free_substs.clone());\n-        fcx.write_ty(expr.id, closure_type);\n-\n-        check_fn(fcx.ccx,\n-                 ast::NormalFn,\n-                 expr.id,\n-                 &fn_ty.sig,\n-                 decl,\n-                 expr.id,\n-                 &*body,\n-                 fcx.inh);\n-\n-        // Tuple up the arguments and insert the resulting function type into\n-        // the `unboxed_closures` table.\n-        fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n-\n-        let kind = match kind {\n-            ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n-            ast::FnMutUnboxedClosureKind => ty::FnMutUnboxedClosureKind,\n-            ast::FnOnceUnboxedClosureKind => ty::FnOnceUnboxedClosureKind,\n-        };\n-\n-        debug!(\"unboxed_closure for {} --> sig={} kind={}\",\n-               local_def(expr.id).repr(fcx.tcx()),\n-               fn_ty.sig.repr(fcx.tcx()),\n-               kind);\n-\n-        let unboxed_closure = ty::UnboxedClosure {\n-            closure_type: fn_ty,\n-            kind: kind,\n-        };\n-\n-        fcx.inh\n-           .unboxed_closures\n-           .borrow_mut()\n-           .insert(local_def(expr.id), unboxed_closure);\n-    }\n-\n-    fn check_expr_fn<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                               expr: &ast::Expr,\n-                               store: ty::TraitStore,\n-                               decl: &ast::FnDecl,\n-                               body: &ast::Block,\n-                               expected: Expectation<'tcx>) {\n-        let tcx = fcx.ccx.tcx;\n-\n-        debug!(\"check_expr_fn(expr={}, expected={})\",\n-               expr.repr(tcx),\n-               expected.repr(tcx));\n-\n-        // Find the expected input/output types (if any). Substitute\n-        // fresh bound regions for any bound regions we find in the\n-        // expected types so as to avoid capture.\n-        let expected_sty = expected.map_to_option(fcx, |x| Some((*x).clone()));\n-        let (expected_sig,\n-             expected_onceness,\n-             expected_bounds) = {\n-            match expected_sty {\n-                Some(ty::ty_closure(ref cenv)) => {\n-                    let (sig, _) =\n-                        replace_late_bound_regions(\n-                            tcx,\n-                            &cenv.sig,\n-                            |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n-                    let onceness = match (&store, &cenv.store) {\n-                        // As the closure type and onceness go, only three\n-                        // combinations are legit:\n-                        //      once closure\n-                        //      many closure\n-                        //      once proc\n-                        // If the actual and expected closure type disagree with\n-                        // each other, set expected onceness to be always Once or\n-                        // Many according to the actual type. Otherwise, it will\n-                        // yield either an illegal \"many proc\" or a less known\n-                        // \"once closure\" in the error message.\n-                        (&ty::UniqTraitStore, &ty::UniqTraitStore) |\n-                        (&ty::RegionTraitStore(..), &ty::RegionTraitStore(..)) =>\n-                            cenv.onceness,\n-                        (&ty::UniqTraitStore, _) => ast::Once,\n-                        (&ty::RegionTraitStore(..), _) => ast::Many,\n-                    };\n-                    (Some(sig), onceness, cenv.bounds)\n-                }\n-                _ => {\n-                    // Not an error! Means we're inferring the closure type\n-                    let (bounds, onceness) = match expr.node {\n-                        ast::ExprProc(..) => {\n-                            let mut bounds = ty::region_existential_bound(ty::ReStatic);\n-                            bounds.builtin_bounds.insert(ty::BoundSend); // FIXME\n-                            (bounds, ast::Once)\n-                        }\n-                        _ => {\n-                            let region = fcx.infcx().next_region_var(\n-                                infer::AddrOfRegion(expr.span));\n-                            (ty::region_existential_bound(region), ast::Many)\n-                        }\n-                    };\n-                    (None, onceness, bounds)\n-                }\n-            }\n-        };\n-\n-        // construct the function type\n-        let fn_ty = astconv::ty_of_closure(fcx,\n-                                           ast::NormalFn,\n-                                           expected_onceness,\n-                                           expected_bounds,\n-                                           store,\n-                                           decl,\n-                                           abi::Rust,\n-                                           expected_sig);\n-        let fty_sig = fn_ty.sig.clone();\n-        let fty = ty::mk_closure(tcx, fn_ty);\n-        debug!(\"check_expr_fn fty={}\", fcx.infcx().ty_to_string(fty));\n-\n-        fcx.write_ty(expr.id, fty);\n-\n-        // If the closure is a stack closure and hasn't had some non-standard\n-        // style inferred for it, then check it under its parent's style.\n-        // Otherwise, use its own\n-        let (inherited_style, inherited_style_id) = match store {\n-            ty::RegionTraitStore(..) => (fcx.ps.borrow().fn_style,\n-                                         fcx.ps.borrow().def),\n-            ty::UniqTraitStore => (ast::NormalFn, expr.id)\n-        };\n-\n-        check_fn(fcx.ccx,\n-                 inherited_style,\n-                 inherited_style_id,\n-                 &fty_sig,\n-                 &*decl,\n-                 expr.id,\n-                 &*body,\n-                 fcx.inh);\n-    }\n-\n-\n     // Check field access expressions\n     fn check_field(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n@@ -4326,32 +4157,16 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprMatch(ref discrim, ref arms, _) => {\n         _match::check_match(fcx, expr, &**discrim, arms.as_slice());\n       }\n-      ast::ExprFnBlock(_, ref decl, ref body) => {\n-        let region = astconv::opt_ast_region_to_region(fcx,\n-                                                       fcx.infcx(),\n-                                                       expr.span,\n-                                                       &None);\n-        check_expr_fn(fcx,\n-                      expr,\n-                      ty::RegionTraitStore(region, ast::MutMutable),\n-                      &**decl,\n-                      &**body,\n-                      expected);\n-      }\n-      ast::ExprUnboxedFn(_, kind, ref decl, ref body) => {\n-        check_unboxed_closure(fcx,\n-                              expr,\n-                              kind,\n-                              &**decl,\n-                              &**body);\n+      ast::ExprClosure(_, opt_kind, ref decl, ref body) => {\n+          closure::check_expr_closure(fcx, expr, opt_kind, &**decl, &**body, expected);\n       }\n       ast::ExprProc(ref decl, ref body) => {\n-        check_expr_fn(fcx,\n-                      expr,\n-                      ty::UniqTraitStore,\n-                      &**decl,\n-                      &**body,\n-                      expected);\n+          closure::check_boxed_closure(fcx,\n+                                       expr,\n+                                       ty::UniqTraitStore,\n+                                       &**decl,\n+                                       &**body,\n+                                       expected);\n       }\n       ast::ExprBlock(ref b) => {\n         check_block_with_expected(fcx, &**b, expected);"}, {"sha": "0a5af8baeaca99a88834e56c28ecd5acf9ca2167", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -742,9 +742,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n-        ast::ExprFnBlock(_, _, ref body) |\n         ast::ExprProc(_, ref body) |\n-        ast::ExprUnboxedFn(_, _, _, ref body) => {\n+        ast::ExprClosure(_, _, _, ref body) => {\n             check_expr_fn_block(rcx, expr, &**body);\n         }\n "}, {"sha": "23af30b44d9356cc5c4ebe51027d26a772510ad4", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -122,9 +122,8 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n                                     MethodCall::expr(e.id));\n \n         match e.node {\n-            ast::ExprFnBlock(_, ref decl, _) |\n-            ast::ExprProc(ref decl, _) |\n-            ast::ExprUnboxedFn(_, _, ref decl, _) => {\n+            ast::ExprClosure(_, _, ref decl, _) |\n+            ast::ExprProc(ref decl, _) => {\n                 for input in decl.inputs.iter() {\n                     let _ = self.visit_node_id(ResolvingExpr(e.span),\n                                                input.id);"}, {"sha": "cda8a1b1b5f17b25dcba108d0f78e5880828b78e", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -241,8 +241,7 @@ mod svh_visitor {\n         SawExprIf,\n         SawExprWhile,\n         SawExprMatch,\n-        SawExprFnBlock,\n-        SawExprUnboxedFn,\n+        SawExprClosure,\n         SawExprProc,\n         SawExprBlock,\n         SawExprAssign,\n@@ -274,8 +273,7 @@ mod svh_visitor {\n             ExprWhile(..)            => SawExprWhile,\n             ExprLoop(_, id)          => SawExprLoop(id.map(content)),\n             ExprMatch(..)            => SawExprMatch,\n-            ExprFnBlock(..)          => SawExprFnBlock,\n-            ExprUnboxedFn(..)        => SawExprUnboxedFn,\n+            ExprClosure(..)          => SawExprClosure,\n             ExprProc(..)             => SawExprProc,\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,"}, {"sha": "67ed95f83fd37972acb4ef64cf8624da76d5317e", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -1345,7 +1345,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             \"Expected struct type, but not ty_struct\"),\n                 }\n             },\n-            ast::ExprFnBlock(_, ref decl, ref body) => {\n+            ast::ExprClosure(_, _, ref decl, ref body) => {\n                 if generated_code(body.span) {\n                     return\n                 }"}, {"sha": "c30ad781cc9cb6196876ad86a9d2f6842ce7c810", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -1385,9 +1385,8 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprFnBlock(_, _, ref blk) |\n-                ast::ExprProc(_, ref blk) |\n-                ast::ExprUnboxedFn(_, _, _, ref blk) => {\n+                ast::ExprClosure(_, _, _, ref blk) |\n+                ast::ExprProc(_, ref blk) => {\n                     let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                     let mut implicit = CheckForNestedReturnsVisitor::implicit();\n                     visit::walk_expr(&mut explicit, e);"}, {"sha": "075b6b0dd6e04081c52c5b51233e9577c0daa74f", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -1232,9 +1232,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n-                ast::ExprFnBlock(_, ref fn_decl, ref top_level_block) |\n                 ast::ExprProc(ref fn_decl, ref top_level_block) |\n-                ast::ExprUnboxedFn(_, _, ref fn_decl, ref top_level_block) => {\n+                ast::ExprClosure(_, _, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name.as_slice());\n                     (name, &**fn_decl,\n@@ -1310,7 +1309,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                       file_metadata,\n                                                       &mut function_name);\n \n-    // There is no ast_map::Path for ast::ExprFnBlock-type functions. For now,\n+    // There is no ast_map::Path for ast::ExprClosure-type functions. For now,\n     // just don't put them into a namespace. In the future this could be improved\n     // somehow (storing a path in the ast_map, or construct a path using the\n     // enclosing function).\n@@ -3578,9 +3577,8 @@ fn populate_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            ast::ExprFnBlock(_, ref decl, ref block) |\n             ast::ExprProc(ref decl, ref block) |\n-            ast::ExprUnboxedFn(_, _, ref decl, ref block) => {\n+            ast::ExprClosure(_, _, ref decl, ref block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,"}, {"sha": "670e893cc0e536e7997546ed3317c88b0c67a1af", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -77,6 +77,7 @@ use trans::machine::{llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n \n use syntax::ast;\n+use syntax::ast_util;\n use syntax::codemap;\n use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n@@ -1070,16 +1071,23 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             tvec::trans_fixed_vstore(bcx, expr, dest)\n         }\n-        ast::ExprFnBlock(_, ref decl, ref body) |\n+        ast::ExprClosure(_, _, ref decl, ref body) |\n         ast::ExprProc(ref decl, ref body) => {\n-            let expr_ty = expr_ty(bcx, expr);\n-            let store = ty::ty_closure_store(expr_ty);\n-            debug!(\"translating block function {} with type {}\",\n-                   expr_to_string(expr), expr_ty.repr(tcx));\n-            closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n-        }\n-        ast::ExprUnboxedFn(_, _, ref decl, ref body) => {\n-            closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n+            // Check the side-table to see whether this is an unboxed\n+            // closure or an older, legacy style closure. Store this\n+            // into a variable to ensure the the RefCell-lock is\n+            // released before we recurse.\n+            let is_unboxed_closure =\n+                bcx.tcx().unboxed_closures.borrow().contains_key(&ast_util::local_def(expr.id));\n+            if is_unboxed_closure {\n+                closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n+            } else {\n+                let expr_ty = expr_ty(bcx, expr);\n+                let store = ty::ty_closure_store(expr_ty);\n+                debug!(\"translating block function {} with type {}\",\n+                       expr_to_string(expr), expr_ty.repr(tcx));\n+                closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n+            }\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {"}, {"sha": "5d4fd2704a2e143fb9126500711008a4a5be2666", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -667,9 +667,8 @@ pub enum Expr_ {\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n-    ExprFnBlock(CaptureClause, P<FnDecl>, P<Block>),\n+    ExprClosure(CaptureClause, Option<UnboxedClosureKind>, P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n-    ExprUnboxedFn(CaptureClause, UnboxedClosureKind, P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(P<Expr>, P<Expr>),"}, {"sha": "8db12fbd8355ff8516d36a6bebeaa42a50e9b2af", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -37,7 +37,7 @@ use visit;\n ///\n /// More specifically, it is one of either:\n ///   - A function item,\n-///   - A closure expr (i.e. an ExprFnBlock or ExprProc), or\n+///   - A closure expr (i.e. an ExprClosure or ExprProc), or\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function.\n@@ -71,7 +71,7 @@ impl MaybeFnLike for ast::TraitItem {\n impl MaybeFnLike for ast::Expr {\n     fn is_fn_like(&self) -> bool {\n         match self.node {\n-            ast::ExprFnBlock(..) | ast::ExprProc(..) => true,\n+            ast::ExprClosure(..) | ast::ExprProc(..) => true,\n             _ => false,\n         }\n     }\n@@ -215,7 +215,7 @@ impl<'a> FnLikeNode<'a> {\n                 }\n             }\n             ast_map::NodeExpr(e) => match e.node {\n-                ast::ExprFnBlock(_, ref decl, ref block) =>\n+                ast::ExprClosure(_, _, ref decl, ref block) =>\n                     closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 ast::ExprProc(ref decl, ref block) =>\n                     closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),"}, {"sha": "b18a0c8411cb8aabc5878bc42de5305b0a3c689d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -864,14 +864,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprFnBlock(ast::CaptureByRef, fn_decl, blk))\n+        self.expr(span, ast::ExprClosure(ast::CaptureByRef, None, fn_decl, blk))\n     }\n     fn lambda(&self, span: Span, ids: Vec<ast::Ident>, blk: P<ast::Block>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n-        self.expr(span, ast::ExprFnBlock(ast::CaptureByRef, fn_decl, blk))\n+        self.expr(span, ast::ExprClosure(ast::CaptureByRef, None, fn_decl, blk))\n     }\n     fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)"}, {"sha": "04132679a03700ee6bfce91703d0973fb5ddd77d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -207,10 +207,11 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr(span, ast::ExprForLoop(pat, head, body, opt_ident))\n         }\n \n-        ast::ExprFnBlock(capture_clause, fn_decl, block) => {\n+        ast::ExprClosure(capture_clause, opt_kind, fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n-            let new_node = ast::ExprFnBlock(capture_clause,\n+            let new_node = ast::ExprClosure(capture_clause,\n+                                            opt_kind,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n             P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n@@ -1555,7 +1556,7 @@ mod test {\n             0)\n     }\n \n-    // closure arg hygiene (ExprFnBlock)\n+    // closure arg hygiene (ExprClosure)\n     // expands to fn f(){(|x_1 : int| {(x_2 + x_1)})(3);}\n     #[test] fn closure_arg_hygiene(){\n         run_renaming_test("}, {"sha": "9635f0175f075051f1ac97a6fd2bf1738c43d076", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -309,7 +309,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprUnboxedFn(..) => {\n+            ast::ExprClosure(_, Some(_), _, _) => {\n                 self.gate_feature(\"unboxed_closures\",\n                                   e.span,\n                                   \"unboxed closures are a work-in-progress \\"}, {"sha": "1bdf9ea73df2fff4c5183b6decbc21fd4db210e0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -1326,18 +1326,13 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                         arms.move_map(|x| folder.fold_arm(x)),\n                         source)\n             }\n-            ExprFnBlock(capture_clause, decl, body) => {\n-                ExprFnBlock(capture_clause,\n-                            folder.fold_fn_decl(decl),\n-                            folder.fold_block(body))\n-            }\n             ExprProc(decl, body) => {\n                 ExprProc(folder.fold_fn_decl(decl),\n                          folder.fold_block(body))\n             }\n-            ExprUnboxedFn(capture_clause, kind, decl, body) => {\n-                ExprUnboxedFn(capture_clause,\n-                            kind,\n+            ExprClosure(capture_clause, opt_kind, decl, body) => {\n+                ExprClosure(capture_clause,\n+                            opt_kind,\n                             folder.fold_fn_decl(decl),\n                             folder.fold_block(body))\n             }"}, {"sha": "ab0543d64b7feac2cb5412fcf803d2ab8d23f29b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -25,10 +25,10 @@ use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, Explicit\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n-use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIfLet, ExprIndex, ExprSlice};\n+use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex, ExprSlice};\n use ast::{ExprLit, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n-use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n+use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n use ast::{Once, Many};\n use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n@@ -2999,7 +2999,8 @@ impl<'a> Parser<'a> {\n \n     // `|args| expr`\n     pub fn parse_lambda_expr(&mut self, capture_clause: CaptureClause)\n-                             -> P<Expr> {\n+                             -> P<Expr>\n+    {\n         let lo = self.span.lo;\n         let (decl, optional_unboxed_closure_kind) =\n             self.parse_fn_block_decl();\n@@ -3013,21 +3014,10 @@ impl<'a> Parser<'a> {\n             rules: DefaultBlock,\n         });\n \n-        match optional_unboxed_closure_kind {\n-            Some(unboxed_closure_kind) => {\n-                self.mk_expr(lo,\n-                             fakeblock.span.hi,\n-                             ExprUnboxedFn(capture_clause,\n-                                           unboxed_closure_kind,\n-                                           decl,\n-                                           fakeblock))\n-            }\n-            None => {\n-                self.mk_expr(lo,\n-                             fakeblock.span.hi,\n-                             ExprFnBlock(capture_clause, decl, fakeblock))\n-            }\n-        }\n+        self.mk_expr(\n+            lo,\n+            fakeblock.span.hi,\n+            ExprClosure(capture_clause, optional_unboxed_closure_kind, decl, fakeblock))\n     }\n \n     pub fn parse_else_expr(&mut self) -> P<Expr> {"}, {"sha": "5652a9a9d3a632cba4a4f167dfad8d7135b4562a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 43, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -444,9 +444,8 @@ pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n fn needs_parentheses(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprAssign(..) | ast::ExprBinary(..) |\n-        ast::ExprFnBlock(..) | ast::ExprProc(..) |\n-        ast::ExprUnboxedFn(..) | ast::ExprAssignOp(..) |\n-        ast::ExprCast(..) => true,\n+        ast::ExprClosure(..) | ast::ExprProc(..) |\n+        ast::ExprAssignOp(..) | ast::ExprCast(..) => true,\n         _ => false,\n     }\n }\n@@ -1662,49 +1661,11 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose_(expr.span, indent_unit));\n             }\n-            ast::ExprFnBlock(capture_clause, ref decl, ref body) => {\n+            ast::ExprClosure(capture_clause, opt_kind, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n-                // in do/for blocks we don't want to show an empty\n-                // argument list, but at this point we don't know which\n-                // we are inside.\n-                //\n-                // if !decl.inputs.is_empty() {\n-                try!(self.print_fn_block_args(&**decl, None));\n+                try!(self.print_fn_block_args(&**decl, opt_kind));\n                 try!(space(&mut self.s));\n-                // }\n-\n-                if !body.stmts.is_empty() || !body.expr.is_some() {\n-                    try!(self.print_block_unclosed(&**body));\n-                } else {\n-                    // we extract the block, so as not to create another set of boxes\n-                    match body.expr.as_ref().unwrap().node {\n-                        ast::ExprBlock(ref blk) => {\n-                            try!(self.print_block_unclosed(&**blk));\n-                        }\n-                        _ => {\n-                            // this is a bare expression\n-                            try!(self.print_expr(&**body.expr.as_ref().unwrap()));\n-                            try!(self.end()); // need to close a box\n-                        }\n-                    }\n-                }\n-                // a box will be closed by print_expr, but we didn't want an overall\n-                // wrapper so we closed the corresponding opening. so create an\n-                // empty box to satisfy the close.\n-                try!(self.ibox(0));\n-            }\n-            ast::ExprUnboxedFn(capture_clause, kind, ref decl, ref body) => {\n-                try!(self.print_capture_clause(capture_clause));\n-\n-                // in do/for blocks we don't want to show an empty\n-                // argument list, but at this point we don't know which\n-                // we are inside.\n-                //\n-                // if !decl.inputs.is_empty() {\n-                try!(self.print_fn_block_args(&**decl, Some(kind)));\n-                try!(space(&mut self.s));\n-                // }\n \n                 if !body.stmts.is_empty() || !body.expr.is_some() {\n                     try!(self.print_block_unclosed(&**body));"}, {"sha": "a0bdd7391130836ddf3a65b1b63cf8e493c2384c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -815,14 +815,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 visitor.visit_arm(arm)\n             }\n         }\n-        ExprFnBlock(_, ref function_declaration, ref body) => {\n-            visitor.visit_fn(FkFnBlock,\n-                             &**function_declaration,\n-                             &**body,\n-                             expression.span,\n-                             expression.id)\n-        }\n-        ExprUnboxedFn(_, _, ref function_declaration, ref body) => {\n+        ExprClosure(_, _, ref function_declaration, ref body) => {\n             visitor.visit_fn(FkFnBlock,\n                              &**function_declaration,\n                              &**body,"}, {"sha": "70f0d61b5ee1fdfd896b4acdcf816f90be942dce", "filename": "src/test/compile-fail/regions-escape-unboxed-closure.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Fcompile-fail%2Fregions-escape-unboxed-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Fcompile-fail%2Fregions-escape-unboxed-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-unboxed-closure.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+fn with_int(f: &mut FnMut(&int)) {\n+}\n+\n+fn main() {\n+    let mut x: Option<&int> = None;\n+    with_int(&mut |&mut: y| x = Some(y));   //~ ERROR cannot infer\n+}"}, {"sha": "72109b22957e02ceb57891670ba37f8c6f175f8e", "filename": "src/test/compile-fail/unboxed-closures-infer-argument-types-two-region-pointers.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// That a closure whose expected argument types include two distinct\n+// bound regions.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::cell::Cell;\n+\n+fn doit<T,F>(val: T, f: &F)\n+    where F : Fn(&Cell<&T>, &T)\n+{\n+    let x = Cell::new(&val);\n+    f.call((&x,&val))\n+}\n+\n+pub fn main() {\n+    doit(0i, &|&: x, y| {\n+        x.set(y); //~ ERROR cannot infer\n+    });\n+}"}, {"sha": "465c324122a44d5171213b317de7f0c06215dade", "filename": "src/test/run-pass/unboxed-closures-infer-argument-types-from-expected-bound.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-bound.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer that the type of `x` is `int` based\n+// on the expected type from the object.\n+\n+#![feature(unboxed_closures)]\n+\n+fn doit<T,F>(val: T, f: &F)\n+    where F : Fn(T)\n+{\n+    f.call((val,))\n+}\n+\n+pub fn main() {\n+    doit(0i, &|&: x /*: int*/ | { x.to_int(); });\n+}"}, {"sha": "440292d202e486a2c011132288ed91e402db47d9", "filename": "src/test/run-pass/unboxed-closures-infer-argument-types-from-expected-object-type.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-object-type.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer that the type of `x` is `int` based\n+// on the expected type from the object.\n+\n+#![feature(unboxed_closures)]\n+\n+fn doit<T>(val: T, f: &Fn(T)) { f.call((val,)) }\n+\n+pub fn main() {\n+    doit(0i, &|&: x /*: int*/ | { x.to_int(); });\n+}"}, {"sha": "b279eb5fbba90284514ce96ae448a8d144586919", "filename": "src/test/run-pass/unboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer that the type of `x` is `int` based\n+// on the expected type from the object.\n+\n+#![feature(unboxed_closures)]\n+\n+fn doit<T,F>(val: T, f: &F)\n+    where F : Fn(&T)\n+{\n+    f.call((&val,))\n+}\n+\n+pub fn main() {\n+    doit(0i, &|&: x /*: int*/ | { x.to_int(); });\n+}"}, {"sha": "0cb719ecd7ff9ce4578ded24e363e161b09d8a41", "filename": "src/test/run-pass/unboxed-closures-infer-kind.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d81776209cfa2b5cb1825bdbf3965a7a7f0440a/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-kind.rs?ref=1d81776209cfa2b5cb1825bdbf3965a7a7f0440a", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can infer the \"kind\" of an unboxed closure based on\n+// the expected type.\n+\n+#![feature(unboxed_closures)]\n+\n+// Test by-ref capture of environment in unboxed closure types\n+\n+fn call_fn<F: Fn()>(f: F) {\n+    f()\n+}\n+\n+fn call_fn_mut<F: FnMut()>(mut f: F) {\n+    f()\n+}\n+\n+fn call_fn_once<F: FnOnce()>(f: F) {\n+    f()\n+}\n+\n+fn main() {\n+    let mut x = 0u;\n+    let y = 2u;\n+\n+    call_fn(|| assert_eq!(x, 0));\n+    call_fn_mut(|| x += y);\n+    call_fn_once(|| x += y);\n+    assert_eq!(x, y * 2);\n+}"}]}