{"sha": "1a8b00a03a45c19a47165ce037ae703e4e71f202", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhOGIwMGEwM2E0NWMxOWE0NzE2NWNlMDM3YWU3MDNlNGU3MWYyMDI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T03:35:33Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T03:35:33Z"}, "message": "Copyedit sections 5 and 6 of the tutorial", "tree": {"sha": "f1691eb9443dde088c55af0621a2c898e3998ea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1691eb9443dde088c55af0621a2c898e3998ea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a8b00a03a45c19a47165ce037ae703e4e71f202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a8b00a03a45c19a47165ce037ae703e4e71f202", "html_url": "https://github.com/rust-lang/rust/commit/1a8b00a03a45c19a47165ce037ae703e4e71f202", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a8b00a03a45c19a47165ce037ae703e4e71f202/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7b8512eae0f92e64b8a9eabe8584ac18bf9e061", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7b8512eae0f92e64b8a9eabe8584ac18bf9e061", "html_url": "https://github.com/rust-lang/rust/commit/d7b8512eae0f92e64b8a9eabe8584ac18bf9e061"}], "stats": {"total": 110, "additions": 65, "deletions": 45}, "files": [{"sha": "e784a08801fb98a193f9f13968ad4aaf13a7ee27", "filename": "doc/tutorial.md", "status": "modified", "additions": 65, "deletions": 45, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/1a8b00a03a45c19a47165ce037ae703e4e71f202/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/1a8b00a03a45c19a47165ce037ae703e4e71f202/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=1a8b00a03a45c19a47165ce037ae703e4e71f202", "patch": "@@ -702,11 +702,11 @@ collection, Rust uses [higher-order functions](#closures).\n Rust struct types must be declared before they are used using the `struct`\n syntax: `struct Name { field1: T1, field2: T2 [, ...] }`, where `T1`, `T2`,\n ... denote types. To construct a struct, use the same syntax, but leave off\n-the `struct`; for example: `Point { x: 1.0, y: 2.0 }`.\n+the `struct`: for example: `Point { x: 1.0, y: 2.0 }`.\n \n Structs are quite similar to C structs and are even laid out the same way in\n-memory (so you can read from a Rust struct in C, and vice-versa). The dot\n-operator is used to access struct fields (`mypoint.x`).\n+memory (so you can read from a Rust struct in C, and vice-versa). Use the dot\n+operator to access struct fields, as in `mypoint.x`.\n \n Fields that you want to mutate must be explicitly marked `mut`.\n \n@@ -720,7 +720,7 @@ struct Stack {\n With a value of such a type, you can do `mystack.head += 1`. If `mut` were\n omitted from the type, such an assignment would result in a type error.\n \n-Structs can be destructured in `match` patterns. The basic syntax is\n+`match` patterns destructure structs. The basic syntax is\n `Name {fieldname: pattern, ...}`:\n \n ~~~~\n@@ -747,9 +747,9 @@ match mypoint {\n }\n ~~~\n \n-Structs are the only type in Rust that may have user-defined destructors,\n-using `drop` blocks, inside of which the struct's value may be referred\n-to with the name `self`.\n+Structs are the only type in Rust that may have user-defined\n+destructors, defined with `drop` blocks. Inside a `drop`, the name\n+`self` refers to the struct's value.\n \n ~~~\n struct TimeBomb {\n@@ -783,16 +783,16 @@ A value of this type is either a `Circle`, in which case it contains a\n `Point` struct and a float, or a `Rectangle`, in which case it contains\n two `Point` structs. The run-time representation of such a value\n includes an identifier of the actual form that it holds, much like the\n-'tagged union' pattern in C, but with better ergonomics.\n+'tagged union' pattern in C, but with better static guarantees.\n \n-The above declaration will define a type `Shape` that can be used to\n-refer to such shapes, and two functions, `Circle` and `Rectangle`,\n-which can be used to construct values of the type (taking arguments of\n-the specified types). So `Circle(Point {x: 0f, y: 0f}, 10f)` is the way to\n+The above declaration will define a type `Shape` that can refer to\n+such shapes, and two functions, `Circle` and `Rectangle`, which can be\n+used to construct values of the type (taking arguments of the\n+specified types). So `Circle(Point {x: 0f, y: 0f}, 10f)` is the way to\n create a new circle.\n \n-Enum variants need not have type parameters. This, for example, is\n-equivalent to a C enum:\n+Enum variants need not have type parameters. This `enum` declaration,\n+for example, is equivalent to a C enum:\n \n ~~~~\n enum Direction {\n@@ -803,12 +803,12 @@ enum Direction {\n }\n ~~~~\n \n-This will define `North`, `East`, `South`, and `West` as constants,\n+This declaration defines `North`, `East`, `South`, and `West` as constants,\n all of which have type `Direction`.\n \n-When an enum is C-like, that is, when none of the variants have\n-parameters, it is possible to explicitly set the discriminator values\n-to an integer value:\n+When an enum is C-like (that is, when none of the variants have\n+parameters), it is possible to explicitly set the discriminator values\n+to a constant value:\n \n ~~~~\n enum Color {\n@@ -821,16 +821,19 @@ enum Color {\n If an explicit discriminator is not specified for a variant, the value\n defaults to the value of the previous variant plus one. If the first\n variant does not have a discriminator, it defaults to 0. For example,\n-the value of `North` is 0, `East` is 1, etc.\n+the value of `North` is 0, `East` is 1, `South` is 2, and `West` is 3.\n \n-When an enum is C-like the `as` cast operator can be used to get the\n-discriminator's value.\n+When an enum is C-like, you can apply the `as` cast operator to\n+convert it to its discriminator value as an int.\n \n <a name=\"single_variant_enum\"></a>\n \n-There is a special case for enums with a single variant. These are\n-used to define new types in such a way that the new name is not just a\n-synonym for an existing type, but its own distinct type. If you say:\n+There is a special case for enums with a single variant, which are\n+sometimes called \"newtype-style enums\" (after Haskell's \"newtype\"\n+feature). These are used to define new types in such a way that the\n+new name is not just a synonym for an existing type, but its own\n+distinct type: `type` creates a structural synonym, while this form of\n+`enum` creates a nominal synonym. If you say:\n \n ~~~~\n enum GizmoId = int;\n@@ -842,7 +845,7 @@ That is a shorthand for this:\n enum GizmoId { GizmoId(int) }\n ~~~~\n \n-Enum types like this can have their content extracted with the\n+You can extract the contents of such an enum type with the\n dereference (`*`) unary operator:\n \n ~~~~\n@@ -851,6 +854,17 @@ let my_gizmo_id: GizmoId = GizmoId(10);\n let id_int: int = *my_gizmo_id;\n ~~~~\n \n+Types like this can be useful to differentiate between data that have\n+the same type but must be used in different ways.\n+\n+~~~~\n+enum Inches = int;\n+enum Centimeters = int;\n+~~~~\n+\n+The above definitions allow for a simple way for programs to avoid\n+confusing numbers that correspond to different units.\n+\n For enum types with multiple variants, destructuring is the only way to\n get at their contents. All variant constructors can be used as\n patterns, as in this definition of `area`:\n@@ -866,9 +880,9 @@ fn area(sh: Shape) -> float {\n }\n ~~~~\n \n-Like other patterns, a lone underscore ignores individual fields.\n-Ignoring all fields of a variant can be written `Circle(*)`. As in\n-their introductory form, nullary enum patterns are written without\n+You can write a lone `_` to ignore an individual fields, and can\n+ignore all fields of a variant like: `Circle(*)`. As in their\n+introduction form, nullary enum patterns are written without\n parentheses.\n \n ~~~~\n@@ -887,9 +901,9 @@ fn point_from_direction(dir: Direction) -> Point {\n ## Tuples\n \n Tuples in Rust behave exactly like structs, except that their fields\n-do not have names (and can thus not be accessed with dot notation).\n+do not have names. Thus, you cannot access their fields with dot notation.\n Tuples can have any arity except for 0 or 1 (though you may consider\n-nil, `()`, as the empty tuple if you like).\n+unit, `()`, as the empty tuple if you like).\n \n ~~~~\n let mytup: (int, int, float) = (10, 20, 30.0);\n@@ -902,10 +916,11 @@ match mytup {\n \n We've already seen several function definitions. Like all other static\n declarations, such as `type`, functions can be declared both at the\n-top level and inside other functions (or modules, which we'll come\n-back to [later](#modules-and-crates)). They are introduced with the\n-`fn` keyword, the type of arguments are specified following colons and\n-the return type follows the arrow.\n+top level and inside other functions (or in modules, which we'll come\n+back to [later](#modules-and-crates)). The `fn` keyword introduces a\n+function. A function has an argument list, which is a parenthesized\n+list of `expr: type` pairs separated by commas. An arrow `->`\n+separates the argument list and the function's return type.\n \n ~~~~\n fn line(a: int, b: int, x: int) -> int {\n@@ -924,9 +939,12 @@ fn line(a: int, b: int, x: int) -> int {\n }\n ~~~~\n \n-Functions that do not return a value are said to return nil, `()`,\n-and both the return type and the return value may be omitted from\n-the definition. The following two functions are equivalent.\n+It's better Rust style to write a return value this way instead of\n+writing an explicit `return`. The utility of `return` comes in when\n+returning early from a function. Functions that do not return a value\n+are said to return nil, `()`, and both the return type and the return\n+value may be omitted from the definition. The following two functions\n+are equivalent.\n \n ~~~~\n fn do_nothing_the_hard_way() -> () { return (); }\n@@ -944,10 +962,12 @@ assert 8  == line(5, 3, 1);\n assert () == oops(5, 3, 1);\n ~~~~\n \n-Methods are like functions, except that they are defined for a specific\n-'self' type (like 'this' in C++). Calling a method is done with\n-dot notation, as in `my_vec.len()`. Methods may be defined on most\n-Rust types with the `impl` keyword. As an example, lets define a draw\n+Methods are like functions, except that they have an implicit argument\n+called `self`, which has the type that the method's receiver has. The\n+`self` argument is like 'this' in C++. An expression with dot\n+notation, as in `my_vec.len()`, denotes a method\n+call. Implementations, written with the `impl` keyword, can define\n+methods on most Rust types. As an example, let's define a `draw`\n method on our `Shape` enum.\n \n ~~~\n@@ -978,15 +998,15 @@ s.draw();\n \n This defines an _implementation_ for `Shape` containing a single\n method, `draw`. In most respects the `draw` method is defined\n-like any other function, with the exception of the name `self`. `self`\n-is a special value that is automatically defined in each method,\n+like any other function, except for the name `self`. `self`\n+is a special value that is automatically in scope inside each method,\n referring to the value being operated on. If we wanted we could add\n additional methods to the same impl, or multiple impls for the same\n type. We'll discuss methods more in the context of [traits and\n generics](#generics).\n \n-> ***Note:*** The method definition syntax will change to require\n-> declaring the self type explicitly, as the first argument.\n+> ***Note:*** In the future, the method definition syntax will change to\n+> require declaring the `self` type explicitly, as the first argument.\n \n # The Rust memory model\n "}]}