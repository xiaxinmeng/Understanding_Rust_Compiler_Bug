{"sha": "46292c7cecb0bd957aee48f72b5c1e931ce47b79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MjkyYzdjZWNiMGJkOTU3YWVlNDhmNzJiNWMxZTkzMWNlNDdiNzk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-31T13:02:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-31T13:02:12Z"}, "message": "Move assists documentation into the manual", "tree": {"sha": "51355c749f7931101f5e79ce42814217da354cad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51355c749f7931101f5e79ce42814217da354cad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46292c7cecb0bd957aee48f72b5c1e931ce47b79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46292c7cecb0bd957aee48f72b5c1e931ce47b79", "html_url": "https://github.com/rust-lang/rust/commit/46292c7cecb0bd957aee48f72b5c1e931ce47b79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46292c7cecb0bd957aee48f72b5c1e931ce47b79/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a2f4548e59981871fe4db2b9ee591b9bf39a46e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2f4548e59981871fe4db2b9ee591b9bf39a46e", "html_url": "https://github.com/rust-lang/rust/commit/5a2f4548e59981871fe4db2b9ee591b9bf39a46e"}], "stats": {"total": 555, "additions": 366, "deletions": 189}, "files": [{"sha": "b8cdfb1cdfe3d994fd83f8bad36907ea5988d510", "filename": "docs/user/generated_assists.adoc", "status": "renamed", "additions": 293, "deletions": 131, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/46292c7cecb0bd957aee48f72b5c1e931ce47b79/docs%2Fuser%2Fgenerated_assists.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/46292c7cecb0bd957aee48f72b5c1e931ce47b79/docs%2Fuser%2Fgenerated_assists.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_assists.adoc?ref=46292c7cecb0bd957aee48f72b5c1e931ce47b79", "patch": "@@ -1,18 +1,16 @@\n-# Assists\n-\n-Cursor position or selection is signified by `\u2503` character.\n-\n-\n-## `add_custom_impl`\n+[discrete]\n+=== `add_custom_impl`\n \n Adds impl block for derived trait.\n \n+.Before\n ```rust\n-// BEFORE\n #[derive(Deb\u2503ug, Display)]\n struct S;\n+```\n \n-// AFTER\n+.After\n+```rust\n #[derive(Display)]\n struct S;\n \n@@ -21,50 +19,62 @@ impl Debug for S {\n }\n ```\n \n-## `add_derive`\n+\n+[discrete]\n+=== `add_derive`\n \n Adds a new `#[derive()]` clause to a struct or enum.\n \n+.Before\n ```rust\n-// BEFORE\n struct Point {\n     x: u32,\n     y: u32,\u2503\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n #[derive($0)]\n struct Point {\n     x: u32,\n     y: u32,\n }\n ```\n \n-## `add_explicit_type`\n+\n+[discrete]\n+=== `add_explicit_type`\n \n Specify type for a let binding.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     let x\u2503 = 92;\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     let x: i32 = 92;\n }\n ```\n \n-## `add_from_impl_for_enum`\n+\n+[discrete]\n+=== `add_from_impl_for_enum`\n \n Adds a From impl for an enum variant with one tuple field.\n \n+.Before\n ```rust\n-// BEFORE\n enum A { \u2503One(u32) }\n+```\n \n-// AFTER\n+.After\n+```rust\n enum A { One(u32) }\n \n impl From<u32> for A {\n@@ -74,20 +84,24 @@ impl From<u32> for A {\n }\n ```\n \n-## `add_function`\n+\n+[discrete]\n+=== `add_function`\n \n Adds a stub function with a signature matching the function under the cursor.\n \n+.Before\n ```rust\n-// BEFORE\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n     bar\u2503(\"\", baz());\n }\n \n+```\n \n-// AFTER\n+.After\n+```rust\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n@@ -100,33 +114,41 @@ fn bar(arg: &str, baz: Baz) {\n \n ```\n \n-## `add_hash`\n+\n+[discrete]\n+=== `add_hash`\n \n Adds a hash to a raw string literal.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     r#\"Hello,\u2503 World!\"#;\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     r##\"Hello, World!\"##;\n }\n ```\n \n-## `add_impl`\n+\n+[discrete]\n+=== `add_impl`\n \n Adds a new inherent impl for a type.\n \n+.Before\n ```rust\n-// BEFORE\n struct Ctx<T: Clone> {\n     data: T,\u2503\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n struct Ctx<T: Clone> {\n     data: T,\n }\n@@ -136,12 +158,14 @@ impl<T: Clone> Ctx<T> {\n }\n ```\n \n-## `add_impl_default_members`\n+\n+[discrete]\n+=== `add_impl_default_members`\n \n Adds scaffold for overriding default impl members.\n \n+.Before\n ```rust\n-// BEFORE\n trait Trait {\n     Type X;\n     fn foo(&self);\n@@ -153,8 +177,10 @@ impl Trait for () {\n     fn foo(&self) {}\u2503\n \n }\n+```\n \n-// AFTER\n+.After\n+```rust\n trait Trait {\n     Type X;\n     fn foo(&self);\n@@ -169,12 +195,14 @@ impl Trait for () {\n }\n ```\n \n-## `add_impl_missing_members`\n+\n+[discrete]\n+=== `add_impl_missing_members`\n \n Adds scaffold for required impl members.\n \n+.Before\n ```rust\n-// BEFORE\n trait Trait<T> {\n     Type X;\n     fn foo(&self) -> T;\n@@ -184,8 +212,10 @@ trait Trait<T> {\n impl Trait<u32> for () {\u2503\n \n }\n+```\n \n-// AFTER\n+.After\n+```rust\n trait Trait<T> {\n     Type X;\n     fn foo(&self) -> T;\n@@ -200,17 +230,21 @@ impl Trait<u32> for () {\n }\n ```\n \n-## `add_new`\n+\n+[discrete]\n+=== `add_new`\n \n Adds a new inherent impl for a type.\n \n+.Before\n ```rust\n-// BEFORE\n struct Ctx<T: Clone> {\n      data: T,\u2503\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n struct Ctx<T: Clone> {\n      data: T,\n }\n@@ -221,77 +255,93 @@ impl<T: Clone> Ctx<T> {\n \n ```\n \n-## `add_turbo_fish`\n+\n+[discrete]\n+=== `add_turbo_fish`\n \n Adds `::<_>` to a call of a generic method or function.\n \n+.Before\n ```rust\n-// BEFORE\n fn make<T>() -> T { todo!() }\n fn main() {\n     let x = make\u2503();\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn make<T>() -> T { todo!() }\n fn main() {\n     let x = make::<${0:_}>();\n }\n ```\n \n-## `apply_demorgan`\n+\n+[discrete]\n+=== `apply_demorgan`\n \n Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).\n This transforms expressions of the form `!l || !r` into `!(l && r)`.\n This also works with `&&`. This assist can only be applied with the cursor\n on either `||` or `&&`, with both operands being a negation of some kind.\n This means something of the form `!x` or `x != y`.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     if x != 4 ||\u2503 !y {}\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     if !(x == 4 && y) {}\n }\n ```\n \n-## `auto_import`\n+\n+[discrete]\n+=== `auto_import`\n \n If the name is unresolved, provides all possible imports for it.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     let map = HashMap\u2503::new();\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n use std::collections::HashMap;\n \n fn main() {\n     let map = HashMap::new();\n }\n ```\n \n-## `change_lifetime_anon_to_named`\n+\n+[discrete]\n+=== `change_lifetime_anon_to_named`\n \n Change an anonymous lifetime to a named lifetime.\n \n+.Before\n ```rust\n-// BEFORE\n impl Cursor<'_\u2503> {\n     fn node(self) -> &SyntaxNode {\n         match self {\n             Cursor::Replace(node) | Cursor::Before(node) => node,\n         }\n     }\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n impl<'a> Cursor<'a> {\n     fn node(self) -> &SyntaxNode {\n         match self {\n@@ -301,44 +351,56 @@ impl<'a> Cursor<'a> {\n }\n ```\n \n-## `change_return_type_to_result`\n+\n+[discrete]\n+=== `change_return_type_to_result`\n \n Change the function's return type to Result.\n \n+.Before\n ```rust\n-// BEFORE\n fn foo() -> i32\u2503 { 42i32 }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n ```\n \n-## `change_visibility`\n+\n+[discrete]\n+=== `change_visibility`\n \n Adds or changes existing visibility specifier.\n \n+.Before\n ```rust\n-// BEFORE\n \u2503fn frobnicate() {}\n+```\n \n-// AFTER\n+.After\n+```rust\n pub(crate) fn frobnicate() {}\n ```\n \n-## `convert_to_guarded_return`\n+\n+[discrete]\n+=== `convert_to_guarded_return`\n \n Replace a large conditional with a guarded return.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     \u2503if cond {\n         foo();\n         bar();\n     }\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     if !cond {\n         return;\n@@ -348,21 +410,25 @@ fn main() {\n }\n ```\n \n-## `fill_match_arms`\n+\n+[discrete]\n+=== `fill_match_arms`\n \n Adds missing clauses to a `match` expression.\n \n+.Before\n ```rust\n-// BEFORE\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n     match action {\n         \u2503\n     }\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n@@ -373,20 +439,24 @@ fn handle(action: Action) {\n }\n ```\n \n-## `fix_visibility`\n+\n+[discrete]\n+=== `fix_visibility`\n \n Makes inaccessible item public.\n \n+.Before\n ```rust\n-// BEFORE\n mod m {\n     fn frobnicate() {}\n }\n fn main() {\n     m::frobnicate\u2503() {}\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n mod m {\n     $0pub(crate) fn frobnicate() {}\n }\n@@ -395,154 +465,192 @@ fn main() {\n }\n ```\n \n-## `flip_binexpr`\n+\n+[discrete]\n+=== `flip_binexpr`\n \n Flips operands of a binary expression.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     let _ = 90 +\u2503 2;\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     let _ = 2 + 90;\n }\n ```\n \n-## `flip_comma`\n+\n+[discrete]\n+=== `flip_comma`\n \n Flips two comma-separated items.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     ((1, 2),\u2503 (3, 4));\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     ((3, 4), (1, 2));\n }\n ```\n \n-## `flip_trait_bound`\n+\n+[discrete]\n+=== `flip_trait_bound`\n \n Flips two trait bounds.\n \n+.Before\n ```rust\n-// BEFORE\n fn foo<T: Clone +\u2503 Copy>() { }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn foo<T: Copy + Clone>() { }\n ```\n \n-## `inline_local_variable`\n+\n+[discrete]\n+=== `inline_local_variable`\n \n Inlines local variable.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     let x\u2503 = 1 + 2;\n     x * 4;\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     (1 + 2) * 4;\n }\n ```\n \n-## `introduce_variable`\n+\n+[discrete]\n+=== `introduce_variable`\n \n Extracts subexpression into a variable.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     \u2503(1 + 2)\u2503 * 4;\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     let $0var_name = (1 + 2);\n     var_name * 4;\n }\n ```\n \n-## `invert_if`\n+\n+[discrete]\n+=== `invert_if`\n \n Apply invert_if\n This transforms if expressions of the form `if !x {A} else {B}` into `if x {B} else {A}`\n This also works with `!=`. This assist can only be applied with the cursor\n on `if`.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     if\u2503 !y { A } else { B }\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     if y { B } else { A }\n }\n ```\n \n-## `make_raw_string`\n+\n+[discrete]\n+=== `make_raw_string`\n \n Adds `r#` to a plain string literal.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     \"Hello,\u2503 World!\";\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     r#\"Hello, World!\"#;\n }\n ```\n \n-## `make_usual_string`\n+\n+[discrete]\n+=== `make_usual_string`\n \n Turns a raw string into a plain string.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     r#\"Hello,\u2503 \"World!\"\"#;\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     \"Hello, \\\"World!\\\"\";\n }\n ```\n \n-## `merge_imports`\n+\n+[discrete]\n+=== `merge_imports`\n \n Merges two imports with a common prefix.\n \n+.Before\n ```rust\n-// BEFORE\n use std::\u2503fmt::Formatter;\n use std::io;\n+```\n \n-// AFTER\n+.After\n+```rust\n use std::{fmt::Formatter, io};\n ```\n \n-## `merge_match_arms`\n+\n+[discrete]\n+=== `merge_match_arms`\n \n Merges identical match arms.\n \n+.Before\n ```rust\n-// BEFORE\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n@@ -551,8 +659,10 @@ fn handle(action: Action) {\n         Action::Stop => foo(),\n     }\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n@@ -562,12 +672,14 @@ fn handle(action: Action) {\n }\n ```\n \n-## `move_arm_cond_to_match_guard`\n+\n+[discrete]\n+=== `move_arm_cond_to_match_guard`\n \n Moves if expression from match arm body into a guard.\n \n+.Before\n ```rust\n-// BEFORE\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n@@ -576,8 +688,10 @@ fn handle(action: Action) {\n         _ => (),\n     }\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n@@ -588,28 +702,34 @@ fn handle(action: Action) {\n }\n ```\n \n-## `move_bounds_to_where_clause`\n+\n+[discrete]\n+=== `move_bounds_to_where_clause`\n \n Moves inline type bounds to a where clause.\n \n+.Before\n ```rust\n-// BEFORE\n fn apply<T, U, \u2503F: FnOnce(T) -> U>(f: F, x: T) -> U {\n     f(x)\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n     f(x)\n }\n ```\n \n-## `move_guard_to_arm_body`\n+\n+[discrete]\n+=== `move_guard_to_arm_body`\n \n Moves match guard into match arm body.\n \n+.Before\n ```rust\n-// BEFORE\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n@@ -618,8 +738,10 @@ fn handle(action: Action) {\n         _ => (),\n     }\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n@@ -630,75 +752,93 @@ fn handle(action: Action) {\n }\n ```\n \n-## `remove_dbg`\n+\n+[discrete]\n+=== `remove_dbg`\n \n Removes `dbg!()` macro call.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     \u2503dbg!(92);\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     92;\n }\n ```\n \n-## `remove_hash`\n+\n+[discrete]\n+=== `remove_hash`\n \n Removes a hash from a raw string literal.\n \n+.Before\n ```rust\n-// BEFORE\n fn main() {\n     r#\"Hello,\u2503 World!\"#;\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn main() {\n     r\"Hello, World!\";\n }\n ```\n \n-## `remove_mut`\n+\n+[discrete]\n+=== `remove_mut`\n \n Removes the `mut` keyword.\n \n+.Before\n ```rust\n-// BEFORE\n impl Walrus {\n     fn feed(&mut\u2503 self, amount: u32) {}\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n impl Walrus {\n     fn feed(&self, amount: u32) {}\n }\n ```\n \n-## `reorder_fields`\n+\n+[discrete]\n+=== `reorder_fields`\n \n Reorder the fields of record literals and record patterns in the same order as in\n the definition.\n \n+.Before\n ```rust\n-// BEFORE\n struct Foo {foo: i32, bar: i32};\n const test: Foo = \u2503Foo {bar: 0, foo: 1}\n+```\n \n-// AFTER\n+.After\n+```rust\n struct Foo {foo: i32, bar: i32};\n const test: Foo = Foo {foo: 1, bar: 0}\n ```\n \n-## `replace_if_let_with_match`\n+\n+[discrete]\n+=== `replace_if_let_with_match`\n \n Replaces `if let` with an else branch with a `match` expression.\n \n+.Before\n ```rust\n-// BEFORE\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n@@ -708,8 +848,10 @@ fn handle(action: Action) {\n         bar()\n     }\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n@@ -720,20 +862,24 @@ fn handle(action: Action) {\n }\n ```\n \n-## `replace_let_with_if_let`\n+\n+[discrete]\n+=== `replace_let_with_if_let`\n \n Replaces `let` with an `if-let`.\n \n+.Before\n ```rust\n-// BEFORE\n \n fn main(action: Action) {\n     \u2503let x = compute();\n }\n \n fn compute() -> Option<i32> { None }\n+```\n \n-// AFTER\n+.After\n+```rust\n \n fn main(action: Action) {\n     if let Some(x) = compute() {\n@@ -743,33 +889,41 @@ fn main(action: Action) {\n fn compute() -> Option<i32> { None }\n ```\n \n-## `replace_qualified_name_with_use`\n+\n+[discrete]\n+=== `replace_qualified_name_with_use`\n \n Adds a use statement for a given fully-qualified name.\n \n+.Before\n ```rust\n-// BEFORE\n fn process(map: std::collections::\u2503HashMap<String, String>) {}\n+```\n \n-// AFTER\n+.After\n+```rust\n use std::collections::HashMap;\n \n fn process(map: HashMap<String, String>) {}\n ```\n \n-## `replace_unwrap_with_match`\n+\n+[discrete]\n+=== `replace_unwrap_with_match`\n \n Replaces `unwrap` a `match` expression. Works for Result and Option.\n \n+.Before\n ```rust\n-// BEFORE\n enum Result<T, E> { Ok(T), Err(E) }\n fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n     let y = x.\u2503unwrap();\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n enum Result<T, E> { Ok(T), Err(E) }\n fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n@@ -780,31 +934,39 @@ fn main() {\n }\n ```\n \n-## `split_import`\n+\n+[discrete]\n+=== `split_import`\n \n Wraps the tail of import into braces.\n \n+.Before\n ```rust\n-// BEFORE\n use std::\u2503collections::HashMap;\n+```\n \n-// AFTER\n+.After\n+```rust\n use std::{collections::HashMap};\n ```\n \n-## `unwrap_block`\n+\n+[discrete]\n+=== `unwrap_block`\n \n This assist removes if...else, for, while and loop control statements to just keep the body.\n \n+.Before\n ```rust\n-// BEFORE\n fn foo() {\n     if true {\u2503\n         println!(\"foo\");\n     }\n }\n+```\n \n-// AFTER\n+.After\n+```rust\n fn foo() {\n     println!(\"foo\");\n }", "previous_filename": "docs/user/assists.md"}, {"sha": "27b37921357107326b96085549d104332f3d9fd6", "filename": "docs/user/manual.adoc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46292c7cecb0bd957aee48f72b5c1e931ce47b79/docs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/46292c7cecb0bd957aee48f72b5c1e931ce47b79/docs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fmanual.adoc?ref=46292c7cecb0bd957aee48f72b5c1e931ce47b79", "patch": "@@ -278,5 +278,6 @@ include::./generated_features.adoc[]\n \n Assists, or code actions, are small local refactorings, available in a particular context.\n They are usually triggered by a shortcut or by clicking a light bulb icon in the editor.\n+Cursor position or selection is signified by `\u2503` character.\n \n-See [assists.md](./assists.md) for the list of available assists.\n+include::./generated_assists.adoc[]"}, {"sha": "f3917a244aa0fd495af8a071e4b1db39b02761d5", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/46292c7cecb0bd957aee48f72b5c1e931ce47b79/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46292c7cecb0bd957aee48f72b5c1e931ce47b79/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=46292c7cecb0bd957aee48f72b5c1e931ce47b79", "patch": "@@ -10,9 +10,12 @@ mod gen_parser_tests;\n mod gen_assists_docs;\n mod gen_feature_docs;\n \n-use std::{mem, path::Path};\n+use std::{\n+    fmt, mem,\n+    path::{Path, PathBuf},\n+};\n \n-use crate::{not_bash::fs2, Result};\n+use crate::{not_bash::fs2, project_root, Result};\n \n pub use self::{\n     gen_assists_docs::generate_assists_docs, gen_feature_docs::generate_feature_docs,\n@@ -29,7 +32,6 @@ const AST_TOKENS: &str = \"crates/ra_syntax/src/ast/generated/tokens.rs\";\n \n const ASSISTS_DIR: &str = \"crates/ra_assists/src/handlers\";\n const ASSISTS_TESTS: &str = \"crates/ra_assists/src/tests/generated.rs\";\n-const ASSISTS_DOCS: &str = \"docs/user/assists.md\";\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub enum Mode {\n@@ -107,3 +109,28 @@ fn do_extract_comment_blocks(text: &str, allow_blocks_with_empty_lines: bool) ->\n     }\n     res\n }\n+\n+#[derive(Debug)]\n+struct Location {\n+    file: PathBuf,\n+}\n+\n+impl Location {\n+    fn new(file: PathBuf) -> Self {\n+        Self { file }\n+    }\n+}\n+\n+impl fmt::Display for Location {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let path = self.file.strip_prefix(&project_root()).unwrap().display().to_string();\n+        let path = path.replace('\\\\', \"/\");\n+        let name = self.file.file_name().unwrap();\n+        write!(\n+            f,\n+            \"https://github.com/rust-analyzer/rust-analyzer/blob/master/{}[{}]\",\n+            path,\n+            name.to_str().unwrap()\n+        )\n+    }\n+}"}, {"sha": "15a02d317bbca0412282b0106aa7e7a9cb8f72d4", "filename": "xtask/src/codegen/gen_assists_docs.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/46292c7cecb0bd957aee48f72b5c1e931ce47b79/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46292c7cecb0bd957aee48f72b5c1e931ce47b79/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs?ref=46292c7cecb0bd957aee48f72b5c1e931ce47b79", "patch": "@@ -1,22 +1,28 @@\n //! Generates `assists.md` documentation.\n \n-use std::{fs, path::Path};\n+use std::{fmt, fs, path::Path};\n \n use crate::{\n-    codegen::{self, extract_comment_blocks_with_empty_lines, Mode},\n+    codegen::{self, extract_comment_blocks_with_empty_lines, Location, Mode},\n     project_root, rust_files, Result,\n };\n \n pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n     let assists = Assist::collect()?;\n     generate_tests(&assists, mode)?;\n-    generate_docs(&assists, mode)?;\n+\n+    let contents = assists.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n+    let contents = contents.trim().to_string() + \"\\n\";\n+    let dst = project_root().join(\"docs/user/generated_assists.adoc\");\n+    codegen::update(&dst, &contents, mode)?;\n+\n     Ok(())\n }\n \n #[derive(Debug)]\n struct Assist {\n     id: String,\n+    location: Location,\n     doc: String,\n     before: String,\n     after: String,\n@@ -58,7 +64,8 @@ impl Assist {\n                 assert_eq!(lines.next().unwrap().as_str(), \"->\");\n                 assert_eq!(lines.next().unwrap().as_str(), \"```\");\n                 let after = take_until(lines.by_ref(), \"```\");\n-                acc.push(Assist { id, doc, before, after })\n+                let location = Location::new(path.to_path_buf());\n+                acc.push(Assist { id, location, doc, before, after })\n             }\n \n             fn take_until<'a>(lines: impl Iterator<Item = &'a String>, marker: &str) -> String {\n@@ -76,6 +83,31 @@ impl Assist {\n     }\n }\n \n+impl fmt::Display for Assist {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let before = self.before.replace(\"<|>\", \"\u2503\"); // Unicode pseudo-graphics bar\n+        let after = self.after.replace(\"<|>\", \"\u2503\");\n+        writeln!(\n+            f,\n+            \"[discrete]\\n=== `{}`\n+\n+{}\n+\n+.Before\n+```rust\n+{}```\n+\n+.After\n+```rust\n+{}```\",\n+            self.id,\n+            self.doc,\n+            hide_hash_comments(&before),\n+            hide_hash_comments(&after)\n+        )\n+    }\n+}\n+\n fn generate_tests(assists: &[Assist], mode: Mode) -> Result<()> {\n     let mut buf = String::from(\"use super::check_doc_test;\\n\");\n \n@@ -103,37 +135,6 @@ r#####\"\n     codegen::update(&project_root().join(codegen::ASSISTS_TESTS), &buf, mode)\n }\n \n-fn generate_docs(assists: &[Assist], mode: Mode) -> Result<()> {\n-    let mut buf = String::from(\n-        \"# Assists\\n\\nCursor position or selection is signified by `\u2503` character.\\n\\n\",\n-    );\n-\n-    for assist in assists {\n-        let before = assist.before.replace(\"<|>\", \"\u2503\"); // Unicode pseudo-graphics bar\n-        let after = assist.after.replace(\"<|>\", \"\u2503\");\n-        let docs = format!(\n-            \"\n-## `{}`\n-\n-{}\n-\n-```rust\n-// BEFORE\n-{}\n-// AFTER\n-{}```\n-\",\n-            assist.id,\n-            assist.doc,\n-            hide_hash_comments(&before),\n-            hide_hash_comments(&after)\n-        );\n-        buf.push_str(&docs);\n-    }\n-\n-    codegen::update(&project_root().join(codegen::ASSISTS_DOCS), &buf, mode)\n-}\n-\n fn hide_hash_comments(text: &str) -> String {\n     text.split('\\n') // want final newline\n         .filter(|&it| !(it.starts_with(\"# \") || it == \"#\"))"}, {"sha": "731e7ecf256b014e66926d473e5bb86b2531f165", "filename": "xtask/src/codegen/gen_feature_docs.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/46292c7cecb0bd957aee48f72b5c1e931ce47b79/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46292c7cecb0bd957aee48f72b5c1e931ce47b79/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs?ref=46292c7cecb0bd957aee48f72b5c1e931ce47b79", "patch": "@@ -3,7 +3,7 @@\n use std::{fmt, fs, path::PathBuf};\n \n use crate::{\n-    codegen::{self, extract_comment_blocks_with_empty_lines, Mode},\n+    codegen::{self, extract_comment_blocks_with_empty_lines, Location, Mode},\n     project_root, rust_files, Result,\n };\n \n@@ -19,7 +19,7 @@ pub fn generate_feature_docs(mode: Mode) -> Result<()> {\n #[derive(Debug)]\n struct Feature {\n     id: String,\n-    path: PathBuf,\n+    location: Location,\n     doc: String,\n }\n \n@@ -40,7 +40,7 @@ impl Feature {\n                 let id = block.id;\n                 assert!(is_valid_feature_name(&id), \"invalid feature name: {:?}\", id);\n                 let doc = block.contents.join(\"\\n\");\n-                acc.push(Feature { id, path: path.clone(), doc })\n+                acc.push(Feature { id, location: Location::new(path.clone()), doc })\n             }\n \n             Ok(())\n@@ -69,20 +69,6 @@ fn is_valid_feature_name(feature: &str) -> bool {\n \n impl fmt::Display for Feature {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        writeln!(f, \"=== {}\", self.id)?;\n-        let path = self.path.strip_prefix(&project_root()).unwrap().display().to_string();\n-        let path = path.replace('\\\\', \"/\");\n-        let name = self.path.file_name().unwrap();\n-\n-        //FIXME: generate line number as well\n-        writeln!(\n-            f,\n-            \"**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/{}[{}]\",\n-            path,\n-            name.to_str().unwrap(),\n-        )?;\n-\n-        writeln!(f, \"{}\", self.doc)?;\n-        Ok(())\n+        writeln!(f, \"=== {}\\n**Source:** {}\\n{}\", self.id, self.location, self.doc)\n     }\n }"}, {"sha": "874957885e8408153ee8b2899f3171c07ce557a5", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46292c7cecb0bd957aee48f72b5c1e931ce47b79/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46292c7cecb0bd957aee48f72b5c1e931ce47b79/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=46292c7cecb0bd957aee48f72b5c1e931ce47b79", "patch": "@@ -191,7 +191,7 @@ Release: release:{}[]\n     let path = changelog_dir.join(format!(\"{}-changelog-{}.adoc\", today, changelog_n));\n     fs2::write(&path, &contents)?;\n \n-    for &adoc in [\"manual.adoc\", \"generated_features.adoc\"].iter() {\n+    for &adoc in [\"manual.adoc\", \"generated_features.adoc\", \"generated_assists.adoc\"].iter() {\n         let src = project_root().join(\"./docs/user/\").join(adoc);\n         let dst = website_root.join(adoc);\n         fs2::copy(src, dst)?;"}]}