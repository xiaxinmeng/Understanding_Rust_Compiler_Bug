{"sha": "f521e4185323699cd5d063b2704367a319583982", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MjFlNDE4NTMyMzY5OWNkNWQwNjNiMjcwNDM2N2EzMTk1ODM5ODI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-15T18:02:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-15T18:03:08Z"}, "message": "internal: introduce minicore -- a subset of libcore for testing", "tree": {"sha": "249c358780bebe049e01f0003caf8e15eb3c4a26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/249c358780bebe049e01f0003caf8e15eb3c4a26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f521e4185323699cd5d063b2704367a319583982", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f521e4185323699cd5d063b2704367a319583982", "html_url": "https://github.com/rust-lang/rust/commit/f521e4185323699cd5d063b2704367a319583982", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f521e4185323699cd5d063b2704367a319583982/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f5eead9e3b32f7e88562337c95f76ea75c82486", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f5eead9e3b32f7e88562337c95f76ea75c82486", "html_url": "https://github.com/rust-lang/rust/commit/3f5eead9e3b32f7e88562337c95f76ea75c82486"}], "stats": {"total": 313, "additions": 271, "deletions": 42}, "files": [{"sha": "d56b20b83d9d5bfd3a63d223b6e822e2142e9439", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f521e4185323699cd5d063b2704367a319583982/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f521e4185323699cd5d063b2704367a319583982/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=f521e4185323699cd5d063b2704367a319583982", "patch": "@@ -9,8 +9,8 @@ use test_utils::{\n use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n-    input::CrateName, Change, CrateGraph, CrateId, Edition, Env, FileId, FilePosition, FileRange,\n-    SourceDatabaseExt, SourceRoot, SourceRootId,\n+    input::CrateName, Change, CrateDisplayName, CrateGraph, CrateId, Edition, Env, FileId,\n+    FilePosition, FileRange, SourceDatabaseExt, SourceRoot, SourceRootId,\n };\n \n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n@@ -81,7 +81,7 @@ pub struct ChangeFixture {\n \n impl ChangeFixture {\n     pub fn parse(ra_fixture: &str) -> ChangeFixture {\n-        let fixture = Fixture::parse(ra_fixture);\n+        let (mini_core, fixture) = Fixture::parse(ra_fixture);\n         let mut change = Change::new();\n \n         let mut files = Vec::new();\n@@ -166,6 +166,31 @@ impl ChangeFixture {\n             }\n         }\n \n+        if let Some(mini_core) = mini_core {\n+            let core_file = file_id;\n+            file_id.0 += 1;\n+\n+            let mut fs = FileSet::default();\n+            fs.insert(core_file, VfsPath::new_virtual_path(\"/sysroot/core/lib.rs\".to_string()));\n+            roots.push(SourceRoot::new_library(fs));\n+\n+            change.change_file(core_file, Some(Arc::new(mini_core.source_code())));\n+\n+            let all_crates = crate_graph.crates_in_topological_order();\n+\n+            let core_crate = crate_graph.add_crate_root(\n+                core_file,\n+                Edition::Edition2021,\n+                Some(CrateDisplayName::from_canonical_name(\"core\".to_string())),\n+                CfgOptions::default(),\n+                Env::default(),\n+                Vec::new(),\n+            );\n+\n+            for krate in all_crates {\n+                crate_graph.add_dep(krate, CrateName::new(\"core\").unwrap(), core_crate).unwrap();\n+            }\n+        }\n         roots.push(SourceRoot::new_local(mem::take(&mut file_set)));\n         change.set_roots(roots);\n         change.set_crate_graph(crate_graph);"}, {"sha": "91236e97458f817172c69c582791ef2461661144", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f521e4185323699cd5d063b2704367a319583982/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f521e4185323699cd5d063b2704367a319583982/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=f521e4185323699cd5d063b2704367a319583982", "patch": "@@ -23,38 +23,29 @@ fn infer_block_expr_type_mismatch() {\n fn coerce_places() {\n     check_infer(\n         r#\"\n-        struct S<T> { a: T }\n+//- minicore: coerce_unsized\n+struct S<T> { a: T }\n \n-        fn f<T>(_: &[T]) -> T { loop {} }\n-        fn g<T>(_: S<&[T]>) -> T { loop {} }\n+fn f<T>(_: &[T]) -> T { loop {} }\n+fn g<T>(_: S<&[T]>) -> T { loop {} }\n \n-        fn gen<T>() -> *mut [T; 2] { loop {} }\n-        fn test1<U>() -> *mut [U] {\n-            gen()\n-        }\n-\n-        fn test2() {\n-            let arr: &[u8; 1] = &[1];\n+fn gen<T>() -> *mut [T; 2] { loop {} }\n+fn test1<U>() -> *mut [U] {\n+    gen()\n+}\n \n-            let a: &[_] = arr;\n-            let b = f(arr);\n-            let c: &[_] = { arr };\n-            let d = g(S { a: arr });\n-            let e: [&[_]; 1] = [arr];\n-            let f: [&[_]; 2] = [arr; 2];\n-            let g: (&[_], &[_]) = (arr, arr);\n-        }\n+fn test2() {\n+    let arr: &[u8; 1] = &[1];\n \n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n-        \"#,\n+    let a: &[_] = arr;\n+    let b = f(arr);\n+    let c: &[_] = { arr };\n+    let d = g(S { a: arr });\n+    let e: [&[_]; 1] = [arr];\n+    let f: [&[_]; 2] = [arr; 2];\n+    let g: (&[_], &[_]) = (arr, arr);\n+}\n+\"#,\n         expect![[r#\"\n             30..31 '_': &[T]\n             44..55 '{ loop {} }': T"}, {"sha": "260a504e7674cbffae1f2194661bdd74a25e13b7", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f521e4185323699cd5d063b2704367a319583982/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f521e4185323699cd5d063b2704367a319583982/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=f521e4185323699cd5d063b2704367a319583982", "patch": "@@ -75,7 +75,9 @@ impl<'a> Project<'a> {\n             profile::init_from(crate::PROFILE);\n         });\n \n-        for entry in Fixture::parse(self.fixture) {\n+        let (mini_core, fixtures) = Fixture::parse(self.fixture);\n+        assert!(mini_core.is_none());\n+        for entry in fixtures {\n             let path = tmp_dir.path().join(&entry.path['/'.len_utf8()..]);\n             fs::create_dir_all(path.parent().unwrap()).unwrap();\n             fs::write(path.as_path(), entry.text.as_bytes()).unwrap();"}, {"sha": "535892f3fcdc4f1e4aab34605aed2d13f76e2632", "filename": "crates/test_utils/src/fixture.rs", "status": "modified", "additions": 148, "deletions": 9, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/f521e4185323699cd5d063b2704367a319583982/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f521e4185323699cd5d063b2704367a319583982/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Ffixture.rs?ref=f521e4185323699cd5d063b2704367a319583982", "patch": "@@ -77,6 +77,11 @@ pub struct Fixture {\n     pub introduce_new_source_root: bool,\n }\n \n+pub struct MiniCore {\n+    activated_flags: Vec<String>,\n+    valid_flags: Vec<String>,\n+}\n+\n impl Fixture {\n     /// Parses text which looks like this:\n     ///\n@@ -86,12 +91,28 @@ impl Fixture {\n     ///  line 2\n     ///  //- other meta\n     ///  ```\n-    pub fn parse(ra_fixture: &str) -> Vec<Fixture> {\n+    ///\n+    /// Fixture can also start with a minicore declaration:\n+    ///\n+    /// ```\n+    /// //- minicore: sized\n+    /// ```\n+    ///\n+    /// That will include a subset of `libcore` into the fixture, see\n+    /// `minicore.rs` for what's available.\n+    pub fn parse(ra_fixture: &str) -> (Option<MiniCore>, Vec<Fixture>) {\n         let fixture = trim_indent(ra_fixture);\n-\n+        let mut fixture = fixture.as_str();\n+        let mut mini_core = None;\n         let mut res: Vec<Fixture> = Vec::new();\n \n-        let default = if ra_fixture.contains(\"//-\") { None } else { Some(\"//- /main.rs\") };\n+        if fixture.starts_with(\"//- minicore:\") {\n+            let first_line = fixture.split_inclusive('\\n').next().unwrap();\n+            mini_core = Some(MiniCore::parse(first_line));\n+            fixture = &fixture[first_line.len()..];\n+        }\n+\n+        let default = if fixture.contains(\"//-\") { None } else { Some(\"//- /main.rs\") };\n \n         for (ix, line) in default.into_iter().chain(fixture.split_inclusive('\\n')).enumerate() {\n             if line.contains(\"//-\") {\n@@ -113,7 +134,7 @@ impl Fixture {\n             }\n         }\n \n-        res\n+        (mini_core, res)\n     }\n \n     //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n@@ -172,6 +193,122 @@ impl Fixture {\n     }\n }\n \n+impl MiniCore {\n+    fn has_flag(&self, flag: &str) -> bool {\n+        self.activated_flags.iter().any(|it| it == flag)\n+    }\n+\n+    fn assert_valid_flag(&self, flag: &str) {\n+        if !self.valid_flags.iter().any(|it| it == flag) {\n+            panic!(\"invalid flag: {:?}, valid flags: {:?}\", flag, self.valid_flags);\n+        }\n+    }\n+\n+    fn parse(line: &str) -> MiniCore {\n+        let mut res = MiniCore { activated_flags: Vec::new(), valid_flags: Vec::new() };\n+\n+        let line = line.strip_prefix(\"//- minicore:\").unwrap().trim();\n+        for entry in line.split(\", \") {\n+            if res.has_flag(entry) {\n+                panic!(\"duplicate minicore flag: {:?}\", entry)\n+            }\n+            res.activated_flags.push(entry.to_string())\n+        }\n+\n+        res\n+    }\n+\n+    /// Strips parts of minicore.rs which are flagged by inactive flags.\n+    ///\n+    /// This is probably over-engineered to support flags dependencies.\n+    pub fn source_code(mut self) -> String {\n+        let mut buf = String::new();\n+        let raw_mini_core = include_str!(\"./minicore.rs\");\n+        let mut lines = raw_mini_core.split_inclusive('\\n');\n+\n+        let mut parsing_flags = false;\n+        let mut implications = Vec::new();\n+\n+        // Parse `//!` preamble and extract flags and dependencies.\n+        for line in lines.by_ref() {\n+            let line = match line.strip_prefix(\"//!\") {\n+                Some(it) => it,\n+                None => {\n+                    assert!(line.trim().is_empty());\n+                    break;\n+                }\n+            };\n+\n+            if parsing_flags {\n+                let (flag, deps) = line.split_once(':').unwrap();\n+                let flag = flag.trim();\n+                self.valid_flags.push(flag.to_string());\n+                for dep in deps.split(\", \") {\n+                    let dep = dep.trim();\n+                    if !dep.is_empty() {\n+                        self.assert_valid_flag(dep);\n+                        implications.push((flag, dep));\n+                    }\n+                }\n+            }\n+\n+            if line.contains(\"Available flags:\") {\n+                parsing_flags = true;\n+            }\n+        }\n+\n+        for flag in &self.activated_flags {\n+            self.assert_valid_flag(flag);\n+        }\n+\n+        // Fixed point loop to compute transitive closure of flags.\n+        loop {\n+            let mut changed = false;\n+            for &(u, v) in implications.iter() {\n+                if self.has_flag(u) && !self.has_flag(v) {\n+                    self.activated_flags.push(v.to_string());\n+                    changed = true;\n+                }\n+            }\n+            if !changed {\n+                break;\n+            }\n+        }\n+\n+        let mut curr_region = \"\";\n+        for line in lines {\n+            let trimmed = line.trim();\n+            if let Some(region) = trimmed.strip_prefix(\"// region:\") {\n+                assert_eq!(curr_region, \"\");\n+                curr_region = region;\n+                continue;\n+            }\n+            if let Some(region) = trimmed.strip_prefix(\"// endregion:\") {\n+                assert_eq!(curr_region, region);\n+                curr_region = \"\";\n+                continue;\n+            }\n+\n+            let mut flag = curr_region;\n+            if let Some(idx) = trimmed.find(\"// :\") {\n+                flag = &trimmed[idx + \"// :\".len()..];\n+            }\n+\n+            let skip = if flag == \"\" {\n+                false\n+            } else {\n+                self.assert_valid_flag(flag);\n+                !self.has_flag(flag)\n+            };\n+\n+            if !skip {\n+                buf.push_str(line)\n+            }\n+        }\n+        buf\n+    }\n+}\n+\n #[test]\n #[should_panic]\n fn parse_fixture_checks_further_indented_metadata() {\n@@ -189,12 +326,14 @@ fn parse_fixture_checks_further_indented_metadata() {\n \n #[test]\n fn parse_fixture_gets_full_meta() {\n-    let parsed = Fixture::parse(\n-        r\"\n-    //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n-    mod m;\n-    \",\n+    let (mini_core, parsed) = Fixture::parse(\n+        r#\"\n+//- minicore: coerce_unsized\n+//- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n+mod m;\n+\"#,\n     );\n+    assert_eq!(mini_core.unwrap().activated_flags, vec![\"coerce_unsized\".to_string()]);\n     assert_eq!(1, parsed.len());\n \n     let meta = &parsed[0];"}, {"sha": "d55bae62a1771dcd433f4012e3e78c9fcc28bb87", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f521e4185323699cd5d063b2704367a319583982/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f521e4185323699cd5d063b2704367a319583982/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=f521e4185323699cd5d063b2704367a319583982", "patch": "@@ -23,7 +23,10 @@ use text_size::{TextRange, TextSize};\n pub use dissimilar::diff as __diff;\n pub use rustc_hash::FxHashMap;\n \n-pub use crate::{assert_linear::AssertLinear, fixture::Fixture};\n+pub use crate::{\n+    assert_linear::AssertLinear,\n+    fixture::{Fixture, MiniCore},\n+};\n \n pub const CURSOR_MARKER: &str = \"$0\";\n pub const ESCAPED_CURSOR_MARKER: &str = \"\\\\$0\";"}, {"sha": "629c06ed0d4cfe3664a37adb8ea36e4f1e4305f0", "filename": "crates/test_utils/src/minicore.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f521e4185323699cd5d063b2704367a319583982/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f521e4185323699cd5d063b2704367a319583982/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=f521e4185323699cd5d063b2704367a319583982", "patch": "@@ -0,0 +1,69 @@\n+//! This is a fixture we use for tests that need lang items.\n+//!\n+//! We want to include the minimal subset of core for each test, so this file\n+//! supports \"conditional compilation\". Tests use the following syntax to include minicore:\n+//!\n+//!  //- minicore: flag1, flag2\n+//!\n+//! We then strip all the code marked with other flags.\n+//!\n+//! Available flags:\n+//!     sized:\n+//!     coerce_unsized: sized\n+\n+pub mod marker {\n+    // region:sized\n+    #[lang = \"sized\"]\n+    #[fundamental]\n+    #[rustc_specialization_trait]\n+    pub trait Sized {}\n+\n+    #[lang = \"unsize\"]\n+    pub trait Unsize<T: ?Sized> {}\n+    // endregion:sized\n+}\n+\n+pub mod ops {\n+    mod unsize {\n+        // region:coerce_unsized\n+        use crate::marker::Unsize;\n+\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T: ?Sized> {}\n+\n+        impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+        impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+        impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n+\n+        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+        impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n+\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+        // endregion:coerce_unsized\n+    }\n+}\n+\n+pub mod prelude {\n+    pub mod v1 {\n+        pub use crate::marker::Sized; // :sized\n+    }\n+\n+    pub mod rust_2015 {\n+        pub use super::v1::*;\n+    }\n+\n+    pub mod rust_2018 {\n+        pub use super::v1::*;\n+    }\n+\n+    pub mod rust_2021 {\n+        pub use super::v1::*;\n+    }\n+}\n+\n+#[prelude_import]\n+#[allow(unused)]\n+use prelude::v1::*;"}]}