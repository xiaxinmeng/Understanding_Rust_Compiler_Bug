{"sha": "14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "node_id": "C_kwDOAAsO6NoAKDE0ZTcyZTdmZmFlZjM4ODAyNzllOWYzZDJmZWY3ZGNmOGZjNWNiNWI", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-05-22T23:39:09Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-18T19:01:03Z"}, "message": "Improve information sharing across SB diagnostics\n\nPrevious Stacked Borrows diagnostics were missing a lot of information\nabout the state of the interpreter, and it was difficult to add\nadditional state because it was threaded through all the intervening\nfunction signatures.\n\nThis change factors a lot of the arguments which used to be passed\nindividually to many stacked borrows functions into a single\n`DiagnosticCx`, which is built in `Stacks::for_each`, and since it\nwraps a handle to `AllocHistory`, we can now handle more nuanced\nthings like heterogeneous borrow of `!Freeze` types.", "tree": {"sha": "f8b816743270ea69f1f4653ae6219d5f859b2f6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8b816743270ea69f1f4653ae6219d5f859b2f6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "html_url": "https://github.com/rust-lang/rust/commit/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46da7485023e2b09b76039071d4969334aabbe91", "url": "https://api.github.com/repos/rust-lang/rust/commits/46da7485023e2b09b76039071d4969334aabbe91", "html_url": "https://github.com/rust-lang/rust/commit/46da7485023e2b09b76039071d4969334aabbe91"}], "stats": {"total": 1397, "additions": 876, "deletions": 521}, "files": [{"sha": "eafe56955d1f4bf1506db57f68cc9cb80d0a090c", "filename": "src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -178,20 +178,15 @@ pub fn report_error<'tcx, 'mir>(\n                         (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\")),\n                         (None, format!(\"see {url} for further information\")),\n                     ];\n-                    match history {\n-                        Some(TagHistory::Tagged {tag, created: (created_range, created_span), invalidated, protected }) => {\n-                            let msg = format!(\"{tag:?} was created by a retag at offsets {created_range:?}\");\n-                            helps.push((Some(*created_span), msg));\n-                            if let Some((invalidated_range, invalidated_span)) = invalidated {\n-                                let msg = format!(\"{tag:?} was later invalidated at offsets {invalidated_range:?}\");\n-                                helps.push((Some(*invalidated_span), msg));\n-                            }\n-                            if let Some((protecting_tag, protecting_tag_span, protection_span)) = protected {\n-                                helps.push((Some(*protecting_tag_span), format!(\"{tag:?} was protected due to {protecting_tag:?} which was created here\")));\n-                                helps.push((Some(*protection_span), format!(\"this protector is live for this call\")));\n-                            }\n+                    if let Some(TagHistory {created, invalidated, protected}) = history.clone() {\n+                        helps.push((Some(created.1), created.0));\n+                        if let Some((msg, span)) = invalidated {\n+                            helps.push((Some(span), msg));\n+                        }\n+                        if let Some([(protector_msg, protector_span), (protection_msg, protection_span)]) = protected {\n+                            helps.push((Some(protector_span), protector_msg));\n+                            helps.push((Some(protection_span), protection_msg));\n                         }\n-                        None => {}\n                     }\n                     helps\n                 }"}, {"sha": "6f6cbcc38a7773f43f109a55f59430c2d3969b9e", "filename": "src/helpers.rs", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -876,8 +876,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n-    pub fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n-        CurrentSpan { span: None, machine: self }\n+    pub fn current_span(&self, tcx: TyCtxt<'tcx>) -> CurrentSpan<'_, 'mir, 'tcx> {\n+        CurrentSpan { span: None, machine: self, tcx }\n     }\n }\n \n@@ -888,27 +888,61 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n #[derive(Clone)]\n pub struct CurrentSpan<'a, 'mir, 'tcx> {\n     span: Option<Span>,\n+    tcx: TyCtxt<'tcx>,\n     machine: &'a Evaluator<'mir, 'tcx>,\n }\n \n-impl<'a, 'mir, 'tcx> CurrentSpan<'a, 'mir, 'tcx> {\n+impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n+    /// Get the current span, skipping non-local frames.\n+    /// This function is backed by a cache, and can be assumed to be very fast.\n     pub fn get(&mut self) -> Span {\n-        *self.span.get_or_insert_with(|| Self::current_span(self.machine))\n+        *self.span.get_or_insert_with(|| Self::current_span(self.tcx, self.machine))\n     }\n \n+    /// Similar to `CurrentSpan::get`, but retrieves the parent frame of the first non-local frame.\n+    /// This is useful when we are processing something which occurs on function-entry and we want\n+    /// to point at the call to the function, not the function definition generally.\n     #[inline(never)]\n-    fn current_span(machine: &Evaluator<'_, '_>) -> Span {\n+    pub fn get_parent(&mut self) -> Span {\n+        let idx = Self::current_span_index(self.tcx, self.machine);\n+        Self::nth_span(self.machine, idx.wrapping_sub(1))\n+    }\n+\n+    #[inline(never)]\n+    fn current_span(tcx: TyCtxt<'_>, machine: &Evaluator<'_, '_>) -> Span {\n+        let idx = Self::current_span_index(tcx, machine);\n+        Self::nth_span(machine, idx)\n+    }\n+\n+    fn nth_span(machine: &Evaluator<'_, '_>, idx: usize) -> Span {\n+        machine\n+            .threads\n+            .active_thread_stack()\n+            .get(idx)\n+            .map(Frame::current_span)\n+            .unwrap_or(rustc_span::DUMMY_SP)\n+    }\n+\n+    // Find the position of the inner-most frame which is part of the crate being\n+    // compiled/executed, part of the Cargo workspace, and is also not #[track_caller].\n+    fn current_span_index(tcx: TyCtxt<'_>, machine: &Evaluator<'_, '_>) -> usize {\n         machine\n             .threads\n             .active_thread_stack()\n             .iter()\n+            .enumerate()\n             .rev()\n-            .find(|frame| {\n+            .find_map(|(idx, frame)| {\n                 let def_id = frame.instance.def_id();\n-                def_id.is_local() || machine.local_crates.contains(&def_id.krate)\n+                if (def_id.is_local() || machine.local_crates.contains(&def_id.krate))\n+                    && !frame.instance.def.requires_caller_location(tcx)\n+                {\n+                    Some(idx)\n+                } else {\n+                    None\n+                }\n             })\n-            .map(|frame| frame.current_span())\n-            .unwrap_or(rustc_span::DUMMY_SP)\n+            .unwrap_or(0)\n     }\n }\n "}, {"sha": "7357731f3592cd20b13befee4288785ccb2241d5", "filename": "src/machine.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -137,7 +137,7 @@ pub enum Provenance {\n }\n \n /// The \"extra\" information a pointer has over a regular AllocId.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq)]\n pub enum ProvenanceExtra {\n     Concrete(SbTag),\n     Wildcard,\n@@ -706,15 +706,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n \n         let alloc = alloc.into_owned();\n-        let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n-            Stacks::new_allocation(\n-                id,\n-                alloc.size(),\n-                stacked_borrows,\n-                kind,\n-                ecx.machine.current_span(),\n-            )\n-        });\n+        let stacks =\n+            ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n+                Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind)\n+            });\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n             data_race::AllocExtra::new_allocation(\n                 data_race,\n@@ -808,7 +803,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn before_memory_read(\n-        _tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         machine: &Self,\n         alloc_extra: &AllocExtra,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n@@ -828,7 +823,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n+                machine.current_span(tcx),\n                 &machine.threads,\n             )?;\n         }\n@@ -840,7 +835,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn before_memory_write(\n-        _tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n@@ -860,7 +855,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n+                machine.current_span(tcx),\n                 &machine.threads,\n             )?;\n         }\n@@ -872,7 +867,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn before_memory_deallocation(\n-        _tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         (alloc_id, prove_extra): (AllocId, Self::ProvenanceExtra),\n@@ -895,6 +890,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 prove_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n+                machine.current_span(tcx),\n                 &machine.threads,\n             )\n         } else {"}, {"sha": "ac2783670cfffd006492d93c8b73cab09384264d", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 415, "deletions": 97, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,101 +1,343 @@\n use smallvec::SmallVec;\n+use std::fmt;\n \n-use rustc_middle::mir::interpret::{AllocId, AllocRange};\n+use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange};\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n use crate::helpers::CurrentSpan;\n-use crate::stacked_borrows::{err_sb_ub, AccessKind};\n+use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission};\n use crate::*;\n \n use rustc_middle::mir::interpret::InterpError;\n \n #[derive(Clone, Debug)]\n pub struct AllocHistory {\n-    // The time tags can be compressed down to one bit per event, by just storing a Vec<u8>\n-    // where each bit is set to indicate if the event was a creation or a retag\n-    current_time: usize,\n-    creations: smallvec::SmallVec<[Event; 2]>,\n-    invalidations: smallvec::SmallVec<[Event; 1]>,\n+    id: AllocId,\n+    creations: smallvec::SmallVec<[Creation; 1]>,\n+    invalidations: smallvec::SmallVec<[Invalidation; 1]>,\n     protectors: smallvec::SmallVec<[Protection; 1]>,\n }\n \n #[derive(Clone, Debug)]\n-struct Protection {\n-    orig_tag: SbTag,\n-    tag: SbTag,\n+struct Creation {\n+    retag: RetagOp,\n     span: Span,\n }\n \n+impl Creation {\n+    fn generate_diagnostic(&self) -> (String, SpanData) {\n+        let tag = self.retag.new_tag;\n+        if let Some(perm) = self.retag.permission {\n+            (\n+                format!(\n+                    \"{tag:?} was created by a {:?} retag at offsets {:?}\",\n+                    perm, self.retag.range,\n+                ),\n+                self.span.data(),\n+            )\n+        } else {\n+            assert!(self.retag.range.size == Size::ZERO);\n+            (\n+                format!(\n+                    \"{tag:?} would have been created here, but this is a zero-size retag ({:?}) so the tag in question does not exist anywhere\",\n+                    self.retag.range,\n+                ),\n+                self.span.data(),\n+            )\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n-struct Event {\n-    parent: Option<SbTag>,\n+struct Invalidation {\n     tag: SbTag,\n     range: AllocRange,\n     span: Span,\n+    cause: InvalidationCause,\n }\n \n-pub enum TagHistory {\n-    Tagged {\n-        tag: SbTag,\n-        created: (AllocRange, SpanData),\n-        invalidated: Option<(AllocRange, SpanData)>,\n-        protected: Option<(SbTag, SpanData, SpanData)>,\n-    },\n+#[derive(Clone, Debug)]\n+enum InvalidationCause {\n+    Access(AccessKind),\n+    Retag(Permission, RetagCause),\n+}\n+\n+impl Invalidation {\n+    fn generate_diagnostic(&self) -> (String, SpanData) {\n+        (\n+            format!(\n+                \"{:?} was later invalidated at offsets {:?} by a {}\",\n+                self.tag, self.range, self.cause\n+            ),\n+            self.span.data(),\n+        )\n+    }\n+}\n+\n+impl fmt::Display for InvalidationCause {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            InvalidationCause::Access(kind) => write!(f, \"{}\", kind),\n+            InvalidationCause::Retag(perm, kind) =>\n+                if *kind == RetagCause::FnEntry {\n+                    write!(f, \"{:?} FnEntry retag\", perm)\n+                } else {\n+                    write!(f, \"{:?} retag\", perm)\n+                },\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+struct Protection {\n+    orig_tag: ProvenanceExtra,\n+    tag: SbTag,\n+    span: Span,\n+}\n+\n+#[derive(Clone)]\n+pub struct TagHistory {\n+    pub created: (String, SpanData),\n+    pub invalidated: Option<(String, SpanData)>,\n+    pub protected: Option<([(String, SpanData); 2])>,\n+}\n+\n+pub struct DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n+    operation: Operation,\n+    current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+}\n+\n+pub struct DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n+    operation: Operation,\n+    current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    history: &'history mut AllocHistory,\n+    offset: Size,\n+}\n+\n+impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n+    pub fn build(\n+        self,\n+        history: &'history mut AllocHistory,\n+        offset: Size,\n+    ) -> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n+        DiagnosticCx {\n+            operation: self.operation,\n+            current_span: self.current_span,\n+            threads: self.threads,\n+            history,\n+            offset,\n+        }\n+    }\n+\n+    pub fn retag(\n+        current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        cause: RetagCause,\n+        new_tag: SbTag,\n+        orig_tag: ProvenanceExtra,\n+        range: AllocRange,\n+    ) -> Self {\n+        let operation =\n+            Operation::Retag(RetagOp { cause, new_tag, orig_tag, range, permission: None });\n+\n+        DiagnosticCxBuilder { current_span, threads, operation }\n+    }\n+\n+    pub fn read(\n+        current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        tag: ProvenanceExtra,\n+        range: AllocRange,\n+    ) -> Self {\n+        let operation = Operation::Access(AccessOp { kind: AccessKind::Read, tag, range });\n+        DiagnosticCxBuilder { current_span, threads, operation }\n+    }\n+\n+    pub fn write(\n+        current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        tag: ProvenanceExtra,\n+        range: AllocRange,\n+    ) -> Self {\n+        let operation = Operation::Access(AccessOp { kind: AccessKind::Write, tag, range });\n+        DiagnosticCxBuilder { current_span, threads, operation }\n+    }\n+\n+    pub fn dealloc(\n+        current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        tag: ProvenanceExtra,\n+    ) -> Self {\n+        let operation = Operation::Dealloc(DeallocOp { tag });\n+        DiagnosticCxBuilder { current_span, threads, operation }\n+    }\n+}\n+\n+impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n+    pub fn unbuild(self) -> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n+        DiagnosticCxBuilder {\n+            operation: self.operation,\n+            current_span: self.current_span,\n+            threads: self.threads,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+enum Operation {\n+    Retag(RetagOp),\n+    Access(AccessOp),\n+    Dealloc(DeallocOp),\n+}\n+\n+#[derive(Debug, Clone)]\n+struct RetagOp {\n+    cause: RetagCause,\n+    new_tag: SbTag,\n+    orig_tag: ProvenanceExtra,\n+    range: AllocRange,\n+    permission: Option<Permission>,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+pub enum RetagCause {\n+    Normal,\n+    FnReturn,\n+    FnEntry,\n+    TwoPhase,\n+}\n+\n+#[derive(Debug, Clone)]\n+struct AccessOp {\n+    kind: AccessKind,\n+    tag: ProvenanceExtra,\n+    range: AllocRange,\n+}\n+\n+#[derive(Debug, Clone)]\n+struct DeallocOp {\n+    tag: ProvenanceExtra,\n }\n \n impl AllocHistory {\n-    pub fn new() -> Self {\n+    pub fn new(id: AllocId) -> Self {\n         Self {\n-            current_time: 0,\n+            id,\n             creations: SmallVec::new(),\n             invalidations: SmallVec::new(),\n             protectors: SmallVec::new(),\n         }\n     }\n+}\n \n-    pub fn log_creation(\n-        &mut self,\n-        parent: Option<SbTag>,\n-        tag: SbTag,\n-        range: AllocRange,\n-        current_span: &mut CurrentSpan<'_, '_, '_>,\n-    ) {\n-        let span = current_span.get();\n-        self.creations.push(Event { parent, tag, range, span });\n-        self.current_time += 1;\n+impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n+    pub fn start_grant(&mut self, perm: Permission) {\n+        let Operation::Retag(op) = &mut self.operation else {\n+            unreachable!(\"start_grant must only be called during a retag, this is: {:?}\", self.operation)\n+        };\n+        op.permission = Some(perm);\n+\n+        let last_creation = &mut self.history.creations.last_mut().unwrap();\n+        match last_creation.retag.permission {\n+            None => {\n+                last_creation.retag.permission = Some(perm);\n+            }\n+            Some(previous) =>\n+                if previous != perm {\n+                    let previous_range = last_creation.retag.range;\n+                    last_creation.retag.range = alloc_range(previous_range.start, self.offset);\n+                    let mut new_event = last_creation.clone();\n+                    new_event.retag.range = alloc_range(self.offset, previous_range.end());\n+                    new_event.retag.permission = Some(perm);\n+                    self.history.creations.push(new_event);\n+                },\n+        }\n     }\n \n-    pub fn log_invalidation(\n-        &mut self,\n-        tag: SbTag,\n-        range: AllocRange,\n-        current_span: &mut CurrentSpan<'_, '_, '_>,\n-    ) {\n-        let span = current_span.get();\n-        self.invalidations.push(Event { parent: None, tag, range, span });\n-        self.current_time += 1;\n+    pub fn log_creation(&mut self) {\n+        let Operation::Retag(op) = &self.operation else {\n+            unreachable!(\"log_creation must only be called during a retag\")\n+        };\n+        self.history.creations.push(Creation { retag: op.clone(), span: self.current_span.get() });\n     }\n \n-    pub fn log_protector(\n-        &mut self,\n-        orig_tag: SbTag,\n-        tag: SbTag,\n-        current_span: &mut CurrentSpan<'_, '_, '_>,\n-    ) {\n-        let span = current_span.get();\n-        self.protectors.push(Protection { orig_tag, tag, span });\n-        self.current_time += 1;\n+    pub fn log_invalidation(&mut self, tag: SbTag) {\n+        let mut span = self.current_span.get();\n+        let (range, cause) = match &self.operation {\n+            Operation::Retag(RetagOp { cause, range, permission, .. }) => {\n+                if *cause == RetagCause::FnEntry {\n+                    span = self.current_span.get_parent();\n+                }\n+                (*range, InvalidationCause::Retag(permission.unwrap(), *cause))\n+            }\n+            Operation::Access(AccessOp { kind, range, .. }) =>\n+                (*range, InvalidationCause::Access(*kind)),\n+            _ => unreachable!(\"Tags can only be invalidated during a retag or access\"),\n+        };\n+        self.history.invalidations.push(Invalidation { tag, range, span, cause });\n+    }\n+\n+    pub fn log_protector(&mut self) {\n+        let Operation::Retag(op) = &self.operation else {\n+            unreachable!(\"Protectors can only be created during a retag\")\n+        };\n+        self.history.protectors.push(Protection {\n+            orig_tag: op.orig_tag,\n+            tag: op.new_tag,\n+            span: self.current_span.get(),\n+        });\n     }\n \n     pub fn get_logs_relevant_to(\n         &self,\n         tag: SbTag,\n         protector_tag: Option<SbTag>,\n     ) -> Option<TagHistory> {\n+        let Some(created) = self.history\n+            .creations\n+            .iter()\n+            .rev()\n+            .find_map(|event| {\n+                // First, look for a Creation event where the tag and the offset matches. This\n+                // ensrues that we pick the right Creation event when a retag isn't uniform due to\n+                // Freeze.\n+                let range = event.retag.range;\n+                if event.retag.new_tag == tag\n+                    && self.offset >= range.start\n+                    && self.offset < (range.start + range.size)\n+                {\n+                    Some(event.generate_diagnostic())\n+                } else {\n+                    None\n+                }\n+            })\n+            .or_else(|| {\n+                // If we didn't find anything with a matching offset, just return the event where\n+                // the tag was created. This branch is hit when we use a tag at an offset that\n+                // doesn't have the tag.\n+                self.history.creations.iter().rev().find_map(|event| {\n+                    if event.retag.new_tag == tag {\n+                        Some(event.generate_diagnostic())\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }) else {\n+                // But if we don't have a creation event, this is related to a wildcard, and there\n+                // is really nothing we can do to help.\n+                return None;\n+            };\n+\n+        let invalidated = self.history.invalidations.iter().rev().find_map(|event| {\n+            if event.tag == tag { Some(event.generate_diagnostic()) } else { None }\n+        });\n+\n         let protected = protector_tag\n             .and_then(|protector| {\n-                self.protectors.iter().find_map(|protection| {\n+                self.history.protectors.iter().find_map(|protection| {\n                     if protection.tag == protector {\n                         Some((protection.orig_tag, protection.span.data()))\n                     } else {\n@@ -104,77 +346,141 @@ impl AllocHistory {\n                 })\n             })\n             .and_then(|(tag, call_span)| {\n-                self.creations.iter().rev().find_map(|event| {\n-                    if event.tag == tag {\n-                        Some((event.parent?, event.span.data(), call_span))\n+                self.history.creations.iter().rev().find_map(|event| {\n+                    if ProvenanceExtra::Concrete(event.retag.new_tag) == tag {\n+                        Some((event.retag.orig_tag, event.span.data(), call_span))\n                     } else {\n                         None\n                     }\n                 })\n+            })\n+            .map(|(protecting_tag, protecting_tag_span, protection_span)| {\n+                [\n+                    (\n+                        format!(\n+                            \"{tag:?} was protected due to {protecting_tag:?} which was created here\"\n+                        ),\n+                        protecting_tag_span,\n+                    ),\n+                    (format!(\"this protector is live for this call\"), protection_span),\n+                ]\n             });\n \n-        let get_matching = |events: &[Event]| {\n-            events.iter().rev().find_map(|event| {\n-                if event.tag == tag { Some((event.range, event.span.data())) } else { None }\n-            })\n-        };\n-        Some(TagHistory::Tagged {\n-            tag,\n-            created: get_matching(&self.creations)?,\n-            invalidated: get_matching(&self.invalidations),\n-            protected,\n-        })\n+        Some(TagHistory { created, invalidated, protected })\n     }\n \n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n-    pub fn grant_error<'tcx>(\n-        &self,\n-        derived_from: ProvenanceExtra,\n-        new: Item,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-        error_offset: Size,\n-        stack: &Stack,\n-    ) -> InterpError<'tcx> {\n+    pub fn grant_error(&self, perm: Permission, stack: &Stack) -> InterpError<'tcx> {\n+        let Operation::Retag(op) = &self.operation else {\n+            unreachable!(\"grant_error should only be called during a retag\")\n+        };\n         let action = format!(\n-            \"trying to reborrow from {derived_from:?} for {new_perm:?} permission at {alloc_id:?}[{offset:#x}]\",\n-            new_perm = new.perm(),\n-            offset = error_offset.bytes(),\n+            \"trying to retag from {:?} for {:?} permission at {:?}[{:#x}]\",\n+            op.orig_tag,\n+            perm,\n+            self.history.id,\n+            self.offset.bytes(),\n         );\n         err_sb_ub(\n-            format!(\"{}{}\", action, error_cause(stack, derived_from)),\n-            Some(operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n-            derived_from.and_then(|derived_from| self.get_logs_relevant_to(derived_from, None)),\n+            format!(\"{}{}\", action, error_cause(stack, op.orig_tag)),\n+            Some(operation_summary(&op.cause.summary(), self.history.id, op.range)),\n+            op.orig_tag.and_then(|orig_tag| self.get_logs_relevant_to(orig_tag, None)),\n         )\n     }\n \n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n-    pub fn access_error<'tcx>(\n-        &self,\n-        access: AccessKind,\n-        tag: ProvenanceExtra,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-        error_offset: Size,\n-        stack: &Stack,\n-    ) -> InterpError<'tcx> {\n+    pub fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n+        let Operation::Access(op) = &self.operation  else {\n+            unreachable!(\"access_error should only be called during an access\")\n+        };\n         let action = format!(\n             \"attempting a {access} using {tag:?} at {alloc_id:?}[{offset:#x}]\",\n-            offset = error_offset.bytes(),\n+            access = op.kind,\n+            tag = op.tag,\n+            alloc_id = self.history.id,\n+            offset = self.offset.bytes(),\n         );\n         err_sb_ub(\n-            format!(\"{}{}\", action, error_cause(stack, tag)),\n-            Some(operation_summary(\"an access\", alloc_id, alloc_range)),\n-            tag.and_then(|tag| self.get_logs_relevant_to(tag, None)),\n+            format!(\"{}{}\", action, error_cause(stack, op.tag)),\n+            Some(operation_summary(\"an access\", self.history.id, op.range)),\n+            op.tag.and_then(|tag| self.get_logs_relevant_to(tag, None)),\n         )\n     }\n+\n+    pub fn protector_error(&self, item: &Item) -> InterpError<'tcx> {\n+        let call_id = self\n+            .threads\n+            .all_stacks()\n+            .flatten()\n+            .map(|frame| {\n+                frame.extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\")\n+            })\n+            .find(|frame| frame.protected_tags.contains(&item.tag()))\n+            .map(|frame| frame.call_id)\n+            .unwrap(); // FIXME: Surely we should find something, but a panic seems wrong here?\n+        match self.operation {\n+            Operation::Dealloc(_) =>\n+                err_sb_ub(\n+                    format!(\n+                        \"deallocating while item {:?} is protected by call {:?}\",\n+                        item, call_id\n+                    ),\n+                    None,\n+                    None,\n+                ),\n+            Operation::Retag(RetagOp { orig_tag: tag, .. })\n+            | Operation::Access(AccessOp { tag, .. }) =>\n+                err_sb_ub(\n+                    format!(\n+                        \"not granting access to tag {:?} because incompatible item {:?} is protected by call {:?}\",\n+                        tag, item, call_id\n+                    ),\n+                    None,\n+                    tag.and_then(|tag| self.get_logs_relevant_to(tag, Some(item.tag()))),\n+                ),\n+        }\n+    }\n+\n+    pub fn dealloc_error(&self) -> InterpError<'tcx> {\n+        let Operation::Dealloc(op) = &self.operation else {\n+            unreachable!(\"dealloc_error should only be called during a deallocation\")\n+        };\n+        err_sb_ub(\n+            format!(\n+                \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n+                op.tag, self.history.id,\n+            ),\n+            None,\n+            op.tag.and_then(|tag| self.get_logs_relevant_to(tag, None)),\n+        )\n+    }\n+\n+    #[inline(never)]\n+    pub fn check_tracked_tag_popped(&self, item: &Item, global: &GlobalStateInner) {\n+        if !global.tracked_pointer_tags.contains(&item.tag()) {\n+            return;\n+        }\n+        let summary = match self.operation {\n+            Operation::Dealloc(_) => None,\n+            Operation::Access(AccessOp { kind, tag, .. }) => Some((tag, kind)),\n+            Operation::Retag(RetagOp { orig_tag, permission, .. }) => {\n+                let kind = match permission\n+                    .expect(\"start_grant should set the current permission before popping a tag\")\n+                {\n+                    Permission::SharedReadOnly => AccessKind::Read,\n+                    Permission::Unique => AccessKind::Write,\n+                    Permission::SharedReadWrite | Permission::Disabled => {\n+                        panic!(\"Only SharedReadOnly and Unique retags can pop tags\");\n+                    }\n+                };\n+                Some((orig_tag, kind))\n+            }\n+        };\n+        register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n+    }\n }\n \n-fn operation_summary(\n-    operation: &'static str,\n-    alloc_id: AllocId,\n-    alloc_range: AllocRange,\n-) -> String {\n+fn operation_summary(operation: &str, alloc_id: AllocId, alloc_range: AllocRange) -> String {\n     format!(\"this error occurs as part of {operation} at {alloc_id:?}{alloc_range:?}\")\n }\n \n@@ -192,3 +498,15 @@ fn error_cause(stack: &Stack, prov_extra: ProvenanceExtra) -> &'static str {\n         \", but no exposed tags have suitable permission in the borrow stack for this location\"\n     }\n }\n+\n+impl RetagCause {\n+    fn summary(&self) -> String {\n+        match self {\n+            RetagCause::Normal => \"retag\",\n+            RetagCause::FnEntry => \"FnEntry retag\",\n+            RetagCause::FnReturn => \"FnReturn retag\",\n+            RetagCause::TwoPhase => \"two-phase retag\",\n+        }\n+        .to_string()\n+    }\n+}"}, {"sha": "6cb76e7b23aa540e64b9bd94d017ebc7a2eb3174", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 119, "deletions": 230, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -22,7 +22,7 @@ use smallvec::SmallVec;\n use crate::*;\n \n pub mod diagnostics;\n-use diagnostics::{AllocHistory, TagHistory};\n+use diagnostics::{AllocHistory, DiagnosticCx, DiagnosticCxBuilder, RetagCause, TagHistory};\n \n mod item;\n pub use item::{Item, Permission};\n@@ -142,11 +142,11 @@ pub enum RefKind {\n impl fmt::Display for RefKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            RefKind::Unique { two_phase: false } => write!(f, \"unique\"),\n-            RefKind::Unique { two_phase: true } => write!(f, \"unique (two-phase)\"),\n-            RefKind::Shared => write!(f, \"shared\"),\n-            RefKind::Raw { mutable: true } => write!(f, \"raw (mutable)\"),\n-            RefKind::Raw { mutable: false } => write!(f, \"raw (constant)\"),\n+            RefKind::Unique { two_phase: false } => write!(f, \"unique reference\"),\n+            RefKind::Unique { two_phase: true } => write!(f, \"unique reference (two-phase)\"),\n+            RefKind::Shared => write!(f, \"shared reference\"),\n+            RefKind::Raw { mutable: true } => write!(f, \"raw (mutable) pointer\"),\n+            RefKind::Raw { mutable: false } => write!(f, \"raw (constant) pointer\"),\n         }\n     }\n }\n@@ -285,94 +285,19 @@ impl<'tcx> Stack {\n     /// currently checking.\n     fn item_popped(\n         item: &Item,\n-        provoking_access: Option<(ProvenanceExtra, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n-        alloc_history: &mut AllocHistory,\n-        threads: &ThreadManager<'_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n     ) -> InterpResult<'tcx> {\n         if !global.tracked_pointer_tags.is_empty() {\n-            check_tracked(item, &provoking_access, global);\n-\n-            #[inline(never)] // cold path\n-            fn check_tracked(\n-                item: &Item,\n-                provoking_access: &Option<(ProvenanceExtra, AllocRange, Size, AccessKind)>,\n-                global: &GlobalStateInner,\n-            ) {\n-                if global.tracked_pointer_tags.contains(&item.tag()) {\n-                    register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n-                        *item,\n-                        provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n-                    ));\n-                }\n-            }\n+            dcx.check_tracked_tag_popped(item, global);\n         }\n \n         if !item.protected() {\n             return Ok(());\n         }\n \n-        // We store tags twice, once in global.protected_tags and once in each call frame.\n-        // We do this because consulting a single global set in this function is faster\n-        // than attempting to search all call frames in the program for the `FrameExtra`\n-        // (if any) which is protecting the popped tag.\n-        //\n-        // This duplication trades off making `end_call` slower to make this function faster. This\n-        // trade-off is profitable in practice for a combination of two reasons.\n-        // 1. A single protected tag can (and does in some programs) protect thousands of `Item`s.\n-        //    Therefore, adding overhead to in function call/return is profitable even if it only\n-        //    saves a little work in this function.\n-        // 2. Most frames protect only one or two tags. So this duplicative global turns a search\n-        //    which ends up about linear in the number of protected tags in the program into a\n-        //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n         if global.protected_tags.contains(&item.tag()) {\n-            return Err(protector_error(item, &provoking_access, alloc_history, threads));\n-\n-            #[inline(never)] // cold path\n-            fn protector_error<'tcx>(\n-                item: &Item,\n-                provoking_access: &Option<(ProvenanceExtra, AllocRange, Size, AccessKind)>,\n-                alloc_history: &mut AllocHistory,\n-                threads: &ThreadManager<'_, 'tcx>,\n-            ) -> InterpErrorInfo<'tcx> {\n-                // This path is cold because it is fatal to the program. So here it is fine to do the\n-                // more expensive search to figure out which call is responsible for protecting this\n-                // tag.\n-                let call_id = threads\n-                    .all_stacks()\n-                    .flatten()\n-                    .map(|frame| {\n-                        frame\n-                            .extra\n-                            .stacked_borrows\n-                            .as_ref()\n-                            .expect(\"we should have Stacked Borrows data\")\n-                    })\n-                    .find(|frame| frame.protected_tags.contains(&item.tag()))\n-                    .map(|frame| frame.call_id)\n-                    .unwrap(); // FIXME: Surely we should find something, but a panic seems wrong here?\n-                if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n-                    err_sb_ub(\n-                        format!(\n-                            \"not granting access to tag {:?} because incompatible item {:?} is protected by call {:?}\",\n-                            tag, item, call_id\n-                        ),\n-                        None,\n-                        tag.and_then(|tag| {\n-                            alloc_history.get_logs_relevant_to(tag, Some(item.tag()))\n-                        }),\n-                    )\n-                } else {\n-                    err_sb_ub(\n-                        format!(\n-                            \"deallocating while item {:?} is protected by call {:?}\",\n-                            item, call_id\n-                        ),\n-                        None,\n-                        None,\n-                    )\n-                }.into()\n-            }\n+            return Err(dcx.protector_error(item).into());\n         }\n         Ok(())\n     }\n@@ -385,19 +310,15 @@ impl<'tcx> Stack {\n         &mut self,\n         access: AccessKind,\n         tag: ProvenanceExtra,\n-        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n-        current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n-        alloc_history: &mut AllocHistory,\n+        dcx: &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n         exposed_tags: &FxHashSet<SbTag>,\n-        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, tag, exposed_tags).map_err(|_| {\n-            alloc_history.access_error(access, tag, alloc_id, alloc_range, offset, self)\n-        })?;\n+        let granting_idx =\n+            self.find_granting(access, tag, exposed_tags).map_err(|_| dcx.access_error(self))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -416,14 +337,8 @@ impl<'tcx> Stack {\n                 0\n             };\n             self.pop_items_after(first_incompatible_idx, |item| {\n-                Stack::item_popped(\n-                    &item,\n-                    Some((tag, alloc_range, offset, access)),\n-                    global,\n-                    alloc_history,\n-                    threads,\n-                )?;\n-                alloc_history.log_invalidation(item.tag(), alloc_range, current_span);\n+                Stack::item_popped(&item, global, dcx)?;\n+                dcx.log_invalidation(item.tag());\n                 Ok(())\n             })?;\n         } else {\n@@ -443,14 +358,8 @@ impl<'tcx> Stack {\n                 0\n             };\n             self.disable_uniques_starting_at(first_incompatible_idx, |item| {\n-                Stack::item_popped(\n-                    &item,\n-                    Some((tag, alloc_range, offset, access)),\n-                    global,\n-                    alloc_history,\n-                    threads,\n-                )?;\n-                alloc_history.log_invalidation(item.tag(), alloc_range, current_span);\n+                Stack::item_popped(&item, global, dcx)?;\n+                dcx.log_invalidation(item.tag());\n                 Ok(())\n             })?;\n         }\n@@ -487,27 +396,18 @@ impl<'tcx> Stack {\n     fn dealloc(\n         &mut self,\n         tag: ProvenanceExtra,\n-        (alloc_id, _alloc_range, _offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n-        alloc_history: &mut AllocHistory,\n+        dcx: &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n         exposed_tags: &FxHashSet<SbTag>,\n-        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make sure there is a granting item.\n-        self.find_granting(AccessKind::Write, tag, exposed_tags).map_err(|_| {\n-            err_sb_ub(format!(\n-                \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n-                tag, alloc_id,\n-                ),\n-                None,\n-                tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, None)),\n-            )\n-        })?;\n+        self.find_granting(AccessKind::Write, tag, exposed_tags)\n+            .map_err(|_| dcx.dealloc_error())?;\n \n         // Step 2: Consider all items removed. This checks for protectors.\n         for idx in (0..self.len()).rev() {\n             let item = self.get(idx).unwrap();\n-            Stack::item_popped(&item, None, global, alloc_history, threads)?;\n+            Stack::item_popped(&item, global, dcx)?;\n         }\n         Ok(())\n     }\n@@ -522,23 +422,21 @@ impl<'tcx> Stack {\n         &mut self,\n         derived_from: ProvenanceExtra,\n         new: Item,\n-        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n-        current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n-        alloc_history: &mut AllocHistory,\n+        dcx: &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n         exposed_tags: &FxHashSet<SbTag>,\n-        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n+        dcx.start_grant(new.perm());\n+\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm().grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n \n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let granting_idx =\n-            self.find_granting(access, derived_from, exposed_tags).map_err(|_| {\n-                alloc_history.grant_error(derived_from, new, alloc_id, alloc_range, offset, self)\n-            })?;\n+        let granting_idx = self\n+            .find_granting(access, derived_from, exposed_tags)\n+            .map_err(|_| dcx.grant_error(new.perm(), self))?;\n \n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n@@ -568,16 +466,7 @@ impl<'tcx> Stack {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access.\n             // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(\n-                access,\n-                derived_from,\n-                (alloc_id, alloc_range, offset),\n-                global,\n-                current_span,\n-                alloc_history,\n-                exposed_tags,\n-                threads,\n-            )?;\n+            self.access(access, derived_from, global, dcx, exposed_tags)?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n             // on top of `derived_from`, and we want the new item at the top so that we\n@@ -596,14 +485,15 @@ impl<'tcx> Stack {\n \n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n-    /// Creates new stack with initial tag.\n-    fn new(size: Size, perm: Permission, tag: SbTag) -> Self {\n+    /// Creates a new stack with an initial tag. For diagnostic purposes, we also need to know\n+    /// the [`AllocId`] of the allocation this is associated with.\n+    fn new(size: Size, perm: Permission, tag: SbTag, id: AllocId) -> Self {\n         let item = Item::new(tag, perm, false);\n         let stack = Stack::new(item);\n \n         Stacks {\n             stacks: RangeMap::new(size, stack),\n-            history: AllocHistory::new(),\n+            history: AllocHistory::new(id),\n             exposed_tags: FxHashSet::default(),\n         }\n     }\n@@ -612,15 +502,17 @@ impl<'tcx> Stacks {\n     fn for_each(\n         &mut self,\n         range: AllocRange,\n+        mut dcx_builder: DiagnosticCxBuilder<'_, '_, 'tcx>,\n         mut f: impl FnMut(\n-            Size,\n             &mut Stack,\n-            &mut AllocHistory,\n+            &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n             &mut FxHashSet<SbTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         for (offset, stack) in self.stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack, &mut self.history, &mut self.exposed_tags)?;\n+            let mut dcx = dcx_builder.build(&mut self.history, offset);\n+            f(stack, &mut dcx, &mut self.exposed_tags)?;\n+            dcx_builder = dcx.unbuild();\n         }\n         Ok(())\n     }\n@@ -633,7 +525,6 @@ impl Stacks {\n         size: Size,\n         state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n-        mut current_span: CurrentSpan<'_, '_, '_>,\n     ) -> Self {\n         let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n@@ -646,91 +537,70 @@ impl Stacks {\n             // Everything else is shared by default.\n             _ => (extra.base_ptr_tag(id), Permission::SharedReadWrite),\n         };\n-        let mut stacks = Stacks::new(size, perm, base_tag);\n-        stacks.history.log_creation(\n-            None,\n-            base_tag,\n-            alloc_range(Size::ZERO, size),\n-            &mut current_span,\n-        );\n-        stacks\n+        Stacks::new(size, perm, base_tag, id)\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_read<'tcx>(\n+    pub fn before_memory_read<'tcx, 'mir>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        mut current_span: CurrentSpan<'_, '_, 'tcx>,\n-        threads: &ThreadManager<'_, 'tcx>,\n+        current_span: CurrentSpan<'_, 'mir, 'tcx>,\n+        threads: &ThreadManager<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"read access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n+        let dcx = DiagnosticCxBuilder::read(current_span, threads, tag, range);\n         let mut state = state.borrow_mut();\n-        self.for_each(range, |offset, stack, history, exposed_tags| {\n-            stack.access(\n-                AccessKind::Read,\n-                tag,\n-                (alloc_id, range, offset),\n-                &mut state,\n-                &mut current_span,\n-                history,\n-                exposed_tags,\n-                threads,\n-            )\n+        self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n+            stack.access(AccessKind::Read, tag, &mut state, dcx, exposed_tags)\n         })\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_write<'tcx>(\n+    pub fn before_memory_write<'tcx, 'mir>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        mut current_span: CurrentSpan<'_, '_, 'tcx>,\n-        threads: &ThreadManager<'_, 'tcx>,\n+        current_span: CurrentSpan<'_, 'mir, 'tcx>,\n+        threads: &ThreadManager<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n+        let dcx = DiagnosticCxBuilder::write(current_span, threads, tag, range);\n         let mut state = state.borrow_mut();\n-        self.for_each(range, |offset, stack, history, exposed_tags| {\n-            stack.access(\n-                AccessKind::Write,\n-                tag,\n-                (alloc_id, range, offset),\n-                &mut state,\n-                &mut current_span,\n-                history,\n-                exposed_tags,\n-                threads,\n-            )\n+        self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n+            stack.access(AccessKind::Write, tag, &mut state, dcx, exposed_tags)\n         })\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_deallocation<'tcx>(\n+    pub fn before_memory_deallocation<'tcx, 'mir>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        threads: &ThreadManager<'_, 'tcx>,\n+        current_span: CurrentSpan<'_, 'mir, 'tcx>,\n+        threads: &ThreadManager<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n+        let dcx = DiagnosticCxBuilder::dealloc(current_span, threads, tag);\n         let state = state.borrow();\n-        self.for_each(range, |offset, stack, history, exposed_tags| {\n-            stack.dealloc(tag, (alloc_id, range, offset), &state, history, exposed_tags, threads)\n+        self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n+            stack.dealloc(tag, &state, dcx, exposed_tags)\n         })?;\n         Ok(())\n     }\n@@ -747,15 +617,15 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         place: &MPlaceTy<'tcx, Provenance>,\n         size: Size,\n         kind: RefKind,\n+        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n         new_tag: SbTag,\n         protect: bool,\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n-        let current_span = &mut this.machine.current_span();\n \n         // It is crucial that this gets called on all code paths, to ensure we track tag creation.\n         let log_creation = |this: &MiriEvalContext<'mir, 'tcx>,\n-                            current_span: &mut CurrentSpan<'_, 'mir, 'tcx>,\n+                            current_span: CurrentSpan<'_, 'mir, 'tcx>,\n                             loc: Option<(AllocId, Size, ProvenanceExtra)>| // alloc_id, base_offset, orig_tag\n          -> InterpResult<'tcx> {\n             let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n@@ -771,14 +641,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 return Ok(())\n             };\n \n-            // The SB history tracking needs a parent tag, so skip if we come from a wildcard.\n-            let ProvenanceExtra::Concrete(orig_tag) = orig_tag else {\n-                // FIXME: should we log this?\n-                return Ok(())\n-            };\n-\n-            let (_size, _align, kind) = this.get_alloc_info(alloc_id);\n-            match kind {\n+            let (_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n+            match alloc_kind {\n                 AllocKind::LiveData => {\n                     // This should have alloc_extra data, but `get_alloc_extra` can still fail\n                     // if converting this alloc_id from a global to a local one\n@@ -789,14 +653,18 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         .as_ref()\n                         .expect(\"we should have Stacked Borrows data\")\n                         .borrow_mut();\n-                    stacked_borrows.history.log_creation(\n-                        Some(orig_tag),\n+                    let  dcx = DiagnosticCxBuilder::retag(\n+                        current_span,\n+                        &this.machine.threads,\n+                        retag_cause,\n                         new_tag,\n+                        orig_tag,\n                         alloc_range(base_offset, size),\n-                        current_span,\n                     );\n+                    let mut dcx = dcx.build(&mut stacked_borrows.history, base_offset);\n+                    dcx.log_creation();\n                     if protect {\n-                        stacked_borrows.history.log_protector(orig_tag, new_tag, current_span);\n+                        dcx.log_protector();\n                     }\n                 }\n                 AllocKind::Function | AllocKind::VTable | AllocKind::Dead => {\n@@ -806,6 +674,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok(())\n         };\n \n+        let current_span = this.machine.current_span(*this.tcx);\n+\n         if size == Size::ZERO {\n             trace!(\n                 \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n@@ -829,6 +699,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             log_creation(this, current_span, None)?;\n             return Ok(None);\n         }\n+\n         let (alloc_id, base_offset, orig_tag) = this.ptr_get_alloc_id(place.ptr)?;\n         log_creation(this, current_span, Some((alloc_id, base_offset, orig_tag)))?;\n \n@@ -855,11 +726,22 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         );\n \n         if protect {\n+            // We store tags twice, once in global.protected_tags and once in each call frame.\n+            // We do this because consulting a single global set in this function is faster\n+            // than attempting to search all call frames in the program for the `FrameExtra`\n+            // (if any) which is protecting the popped tag.\n+            //\n+            // This duplication trades off making `end_call` slower to make this function faster. This\n+            // trade-off is profitable in practice for a combination of two reasons.\n+            // 1. A single protected tag can (and does in some programs) protect thousands of `Item`s.\n+            //    Therefore, adding overhead to in function call/return is profitable even if it only\n+            //    saves a little work in this function.\n+            // 2. Most frames protect only one or two tags. So this duplicative global turns a search\n+            //    which ends up about linear in the number of protected tags in the program into a\n+            //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n             this.frame_mut().extra.stacked_borrows.as_mut().unwrap().protected_tags.push(new_tag);\n             this.machine.stacked_borrows.as_mut().unwrap().get_mut().protected_tags.insert(new_tag);\n         }\n-        // FIXME: can't hold the current span handle across the borrows of self above\n-        let current_span = &mut this.machine.current_span();\n \n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n@@ -906,26 +788,26 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     };\n                     let item = Item::new(new_tag, perm, protected);\n                     let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n-                    let threads = &this.machine.threads;\n-                    stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n-                        stack.grant(\n-                            orig_tag,\n-                            item,\n-                            (alloc_id, range, offset),\n-                            &mut global,\n-                            current_span,\n-                            history,\n-                            exposed_tags,\n-                            threads,\n-                        )\n+                    let dcx = DiagnosticCxBuilder::retag(\n+                        this.machine.current_span(*this.tcx),\n+                        &this.machine.threads,\n+                        retag_cause,\n+                        new_tag,\n+                        orig_tag,\n+                        alloc_range(base_offset, size),\n+                    );\n+                    stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n+                        stack.grant(orig_tag, item, &mut global, dcx, exposed_tags)\n                     })\n                 })?;\n                 return Ok(Some(alloc_id));\n             }\n         };\n+\n         // Here we can avoid `borrow()` calls because we have mutable references.\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n+        let tcx = *this.tcx;\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n         let mut stacked_borrows = alloc_extra\n             .stacked_borrows\n@@ -935,19 +817,16 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let item = Item::new(new_tag, perm, protect);\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n-        let threads = &machine.threads;\n-        let current_span = &mut machine.current_span(); // `get_alloc_extra_mut` invalidated our old `current_span`\n-        stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n-            stack.grant(\n-                orig_tag,\n-                item,\n-                (alloc_id, range, offset),\n-                &mut global,\n-                current_span,\n-                history,\n-                exposed_tags,\n-                threads,\n-            )\n+        let dcx = DiagnosticCxBuilder::retag(\n+            machine.current_span(tcx),\n+            &machine.threads,\n+            retag_cause,\n+            new_tag,\n+            orig_tag,\n+            alloc_range(base_offset, size),\n+        );\n+        stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n+            stack.grant(orig_tag, item, &mut global, dcx, exposed_tags)\n         })?;\n \n         Ok(Some(alloc_id))\n@@ -959,6 +838,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         val: &ImmTy<'tcx, Provenance>,\n         kind: RefKind,\n+        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n         protect: bool,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n@@ -977,7 +857,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let new_tag = this.machine.stacked_borrows.as_mut().unwrap().get_mut().new_ptr();\n \n         // Reborrow.\n-        let alloc_id = this.reborrow(&place, size, kind, new_tag, protect)?;\n+        let alloc_id = this.reborrow(&place, size, kind, retag_cause, new_tag, protect)?;\n \n         // Adjust pointer.\n         let new_place = place.map_provenance(|p| {\n@@ -1007,7 +887,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let retag_fields = this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields;\n-        let mut visitor = RetagVisitor { ecx: this, kind, retag_fields };\n+        let retag_cause = match kind {\n+            RetagKind::TwoPhase { .. } => RetagCause::TwoPhase,\n+            RetagKind::FnEntry => RetagCause::FnEntry,\n+            RetagKind::Raw | RetagKind::Default => RetagCause::Normal,\n+        };\n+        let mut visitor = RetagVisitor { ecx: this, kind, retag_cause, retag_fields };\n         return visitor.visit_value(place);\n \n         // Determine mutability and whether to add a protector.\n@@ -1036,6 +921,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         struct RetagVisitor<'ecx, 'mir, 'tcx> {\n             ecx: &'ecx mut MiriEvalContext<'mir, 'tcx>,\n             kind: RetagKind,\n+            retag_cause: RetagCause,\n             retag_fields: bool,\n         }\n         impl<'ecx, 'mir, 'tcx> RetagVisitor<'ecx, 'mir, 'tcx> {\n@@ -1044,10 +930,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 &mut self,\n                 place: &PlaceTy<'tcx, Provenance>,\n                 ref_kind: RefKind,\n+                retag_cause: RetagCause,\n                 protector: bool,\n             ) -> InterpResult<'tcx> {\n                 let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n-                let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n+                let val = self.ecx.retag_reference(&val, ref_kind, retag_cause, protector)?;\n                 self.ecx.write_immediate(*val, place)?;\n                 Ok(())\n             }\n@@ -1068,13 +955,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 self.retag_place(\n                     place,\n                     RefKind::Unique { two_phase: false },\n+                    self.retag_cause,\n                     /*protector*/ false,\n                 )\n             }\n \n             fn visit_value(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n-                    self.retag_place(place, ref_kind, protector)?;\n+                    self.retag_place(place, ref_kind, self.retag_cause, protector)?;\n                 } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {\n                     // Wide raw pointers *do* have fields and their types are strange.\n                     // vtables have a type like `&[*const (); 3]` or so!\n@@ -1117,6 +1005,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let val = this.retag_reference(\n             &val,\n             RefKind::Unique { two_phase: false },\n+            RetagCause::FnReturn,\n             /*protector*/ true,\n         )?;\n         // And use reborrowed pointer for return place."}, {"sha": "1436afcd212be42906d5a7a2eeaeb8a74fc84905", "filename": "tests/fail/box-cell-alias.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fbox-cell-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fbox-cell-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbox-cell-alias.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/box-cell-alias.rs:LL:CC\n    |\n LL |     unsafe { (*ptr).set(20) };\n    |              ^^^^^^^^^^^^^^\n    |              |\n-   |              trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of a reborrow at ALLOC[0x0..0x1]\n+   |              trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |              this error occurs as part of retag at ALLOC[0x0..0x1]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x1]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x1]\n   --> $DIR/box-cell-alias.rs:LL:CC\n    |\n LL |     let ptr: *const Cell<u8> = &*val;\n    |                                ^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x1]\n+help: <TAG> was later invalidated at offsets [0x0..0x1] by a Unique retag\n   --> $DIR/box-cell-alias.rs:LL:CC\n    |\n LL |     let res = helper(val, ptr);"}, {"sha": "74d1e4ebbcb8482a9693c395493b644589f5a79d", "filename": "tests/fail/stacked_borrows/alias_through_mutation.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     let _val = *target_alias;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/alias_through_mutation.rs:LL:CC\n    |\n LL |         *x = &mut *(target as *mut _);\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/alias_through_mutation.rs:LL:CC\n    |\n LL |     *target = 13;"}, {"sha": "e3f05f3350a5c60842fe241edff11c2ce29cc42c", "filename": "tests/fail/stacked_borrows/aliasing_mut1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -6,7 +6,7 @@ LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/aliasing_mut1.rs:LL:CC\n    |\n LL |     let xraw: *mut i32 = unsafe { mem::transmute(&mut x) };"}, {"sha": "94c2ffa07f7159c06d01f623b062fdbaf8fc5809", "filename": "tests/fail/stacked_borrows/aliasing_mut2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -6,7 +6,7 @@ LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/aliasing_mut2.rs:LL:CC\n    |\n LL |     let xref = &mut x;"}, {"sha": "0fa31260323fbb067ea7f00c1a6f97ce271aca3e", "filename": "tests/fail/stacked_borrows/aliasing_mut3.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,24 +1,24 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &i32) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | |\n-   | trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   | this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+   | trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   | this error occurs as part of FnEntry retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n LL |     safe_raw(xraw, xshr);\n    |                    ^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique FnEntry retag\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n-LL | pub fn safe(_x: &mut i32, _y: &i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     safe_raw(xraw, xshr);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n    = note: backtrace:\n    = note: inside `safe` at $DIR/aliasing_mut3.rs:LL:CC\n note: inside `main` at $DIR/aliasing_mut3.rs:LL:CC"}, {"sha": "f48d39b2e49f0154657dfab36e3d0c398a414bf0", "filename": "tests/fail/stacked_borrows/aliasing_mut4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -6,7 +6,7 @@ LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/aliasing_mut4.rs:LL:CC\n    |\n LL |     let xref = &mut x;"}, {"sha": "dfe49d7f089267d0438dd949f87cde9ccb02b5f1", "filename": "tests/fail/stacked_borrows/box_exclusive_violation1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |         *LEAK = 7;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n LL |         LEAK = x as *const _ as *mut _;\n    |                ^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n LL |     *our = 5;"}, {"sha": "c0fc247cd4a20640000284daf83827b5b6cfb07f", "filename": "tests/fail/stacked_borrows/buggy_as_mut_slice.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     v1[1] = 5;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0xc]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0xc]\n   --> $DIR/buggy_as_mut_slice.rs:LL:CC\n    |\n LL |     let v1 = safe::as_mut_slice(&v);\n    |              ^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0xc]\n+help: <TAG> was later invalidated at offsets [0x0..0xc] by a Unique retag\n   --> $DIR/buggy_as_mut_slice.rs:LL:CC\n    |\n LL |         unsafe { from_raw_parts_mut(self_.as_ptr() as *mut T, self_.len()) }"}, {"sha": "8a1ea86d63385a423e44d922a347adcbdc832026", "filename": "tests/fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -19,7 +19,7 @@ mod safe {\n fn main() {\n     let mut array = [1, 2, 3, 4];\n     let (a, b) = safe::split_at_mut(&mut array, 0);\n-    //~^ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+    //~^ ERROR: /retag .* tag does not exist in the borrow stack/\n     a[1] = 5;\n     b[1] = 6;\n }"}, {"sha": "b4c5140882f32086dc910c26f9820c9f6ba97b09", "filename": "tests/fail/stacked_borrows/buggy_split_at_mut.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for Unique permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/buggy_split_at_mut.rs:LL:CC\n    |\n LL |     let (a, b) = safe::split_at_mut(&mut array, 0);\n    |          ^\n    |          |\n-   |          trying to reborrow from <TAG> for Unique permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |          this error occurs as part of a reborrow at ALLOC[0x0..0x10]\n+   |          trying to retag from <TAG> for Unique permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |          this error occurs as part of retag at ALLOC[0x0..0x10]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x10]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x10]\n   --> $DIR/buggy_split_at_mut.rs:LL:CC\n    |\n LL |                 from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x10]\n+help: <TAG> was later invalidated at offsets [0x0..0x10] by a Unique retag\n   --> $DIR/buggy_split_at_mut.rs:LL:CC\n    |\n LL |                 from_raw_parts_mut(ptr.offset(mid as isize), len - mid),"}, {"sha": "37214bebb82850f3bbd5a832073190aba793c68a", "filename": "tests/fail/stacked_borrows/fnentry_invalidation.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -0,0 +1,20 @@\n+// Test that spans displayed in diagnostics identify the function call, not the function\n+// definition, as the location of invalidation due to FnEntry retag. Technically the FnEntry retag\n+// occurs inside the function, but what the user wants to know is which call produced the\n+// invalidation.\n+fn main() {\n+    let mut x = 0i32;\n+    let z = &mut x as *mut i32;\n+    x.do_bad();\n+    unsafe {\n+        let _oof = *z; //~ ERROR: /read access .* tag does not exist in the borrow stack/\n+    }\n+}\n+\n+trait Bad {\n+    fn do_bad(&mut self) {\n+        // who knows\n+    }\n+}\n+\n+impl Bad for i32 {}"}, {"sha": "a66fd32003474f25a0304c4c0afceefe14cab77d", "filename": "tests/fail/stacked_borrows/fnentry_invalidation.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -0,0 +1,28 @@\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/fnentry_invalidation.rs:LL:CC\n+   |\n+LL |         let _oof = *z;\n+   |                    ^^\n+   |                    |\n+   |                    attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n+  --> $DIR/fnentry_invalidation.rs:LL:CC\n+   |\n+LL |     let z = &mut x as *mut i32;\n+   |             ^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique FnEntry retag\n+  --> $DIR/fnentry_invalidation.rs:LL:CC\n+   |\n+LL |     x.do_bad();\n+   |     ^^^^^^^^^^\n+   = note: backtrace:\n+   = note: inside `main` at $DIR/fnentry_invalidation.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "6e9d491137c85548d7d8467db4120213fc0c6f54", "filename": "tests/fail/stacked_borrows/illegal_read1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     let _val = *xref; // ...but any use of raw will invalidate our ref.\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read1.rs:LL:CC\n    |\n LL |     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still ok...\n    |                         ^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n   --> $DIR/illegal_read1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw };"}, {"sha": "fb1f9ec6a884f7ad2666c2d44b561b1416789090", "filename": "tests/fail/stacked_borrows/illegal_read2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read2.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     let _val = *xref; // ...but any use of raw will invalidate our ref.\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read2.rs:LL:CC\n    |\n LL |     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still ok...\n    |                         ^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadOnly retag\n   --> $DIR/illegal_read2.rs:LL:CC\n    |\n LL |     let shr = unsafe { &*xraw };"}, {"sha": "55ab8877999cad1d666e79eaa81348a7630374a9", "filename": "tests/fail/stacked_borrows/illegal_read3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read3.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     let _val = *xref2;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read3.rs:LL:CC\n    |\n LL |     let xref2 = &mut *xref1;\n    |                 ^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n   --> $DIR/illegal_read3.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xref1.r };"}, {"sha": "3bb064e2f4162f159329d08f672ff136d0637b1f", "filename": "tests/fail/stacked_borrows/illegal_read4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read4.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     let _illegal = *xref2;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read4.rs:LL:CC\n    |\n LL |     let xref2 = unsafe { &mut *xraw };\n    |                          ^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n   --> $DIR/illegal_read4.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // use the raw again, this invalidates xref2 *even* with the special read except for uniq refs"}, {"sha": "e060463cf1d3f75b74fa47af8af31e93472ca805", "filename": "tests/fail/stacked_borrows/illegal_read5.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read5.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     let _val = *xref; // the mutable one is dead and gone\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [$HEX..$HEX]\n+help: <TAG> was created by a Unique retag at offsets [$HEX..$HEX]\n   --> $DIR/illegal_read5.rs:LL:CC\n    |\n LL |     let xref: &mut i32 = &mut *refmut;\n    |                          ^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [$HEX..$HEX]\n+help: <TAG> was later invalidated at offsets [$HEX..$HEX] by a read access\n   --> $DIR/illegal_read5.rs:LL:CC\n    |\n LL |     mem::forget(unsafe { ptr::read(xshr) }); // but after reading through the shared ref"}, {"sha": "8ef720925646aceffd542b8f599bf7b9d76f0542", "filename": "tests/fail/stacked_borrows/illegal_read6.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |         let _val = *raw;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n LL |         let raw = x as *mut _;\n    |                   ^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n LL |         let x = &mut *x; // kill `raw`"}, {"sha": "1901e8e4e3480f9872536f1ad4b32e32573baa3d", "filename": "tests/fail/stacked_borrows/illegal_read7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -17,6 +17,6 @@ fn main() {\n         // without invalidating `x`.  That would be bad!  It would mean that creating `shr`\n         // leaked `x` to `raw`.\n         let _val = ptr::read(raw);\n-        let _val = *x.get_mut(); //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+        let _val = *x.get_mut(); //~ ERROR: /retag .* tag does not exist in the borrow stack/\n     }\n }"}, {"sha": "5c42b0a5863c14d490d01c9e2e44bdcd21645271", "filename": "tests/fail/stacked_borrows/illegal_read7.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/illegal_read7.rs:LL:CC\n    |\n LL |         let _val = *x.get_mut();\n    |                     ^^^^^^^^^^^\n    |                     |\n-   |                     trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |                     this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+   |                     trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                     this error occurs as part of two-phase retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read7.rs:LL:CC\n    |\n LL |         let x = &mut *raw;\n    |                 ^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n   --> $DIR/illegal_read7.rs:LL:CC\n    |\n LL |         let _val = ptr::read(raw);"}, {"sha": "c962d1c3e4032c15b01b66970e790c5cf98d7da0", "filename": "tests/fail/stacked_borrows/illegal_read8.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read8.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |         let _fail = *y1;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read8.rs:LL:CC\n    |\n LL |         let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n    |                        ^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/illegal_read8.rs:LL:CC\n    |\n LL |         *y2 += 1;"}, {"sha": "4607a9dbf675dc02c204efe83e3801ba497ce2a5", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed1.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,6 +9,16 @@ LL |         let _val = *root2;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n+  --> $DIR/illegal_read_despite_exposed1.rs:LL:CC\n+   |\n+LL |         let root2 = &mut *exposed_ptr;\n+   |                     ^^^^^^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n+  --> $DIR/illegal_read_despite_exposed1.rs:LL:CC\n+   |\n+LL |         *exposed_ptr = 0;\n+   |         ^^^^^^^^^^^^^^^^\n    = note: backtrace:\n    = note: inside `main` at $DIR/illegal_read_despite_exposed1.rs:LL:CC\n "}, {"sha": "4bf0df7d0625e609df5ffdbf76fb0c4896c92223", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed2.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,6 +9,16 @@ LL |         let _val = *root2;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n+  --> $DIR/illegal_read_despite_exposed2.rs:LL:CC\n+   |\n+LL |         let root2 = &mut *exposed_ptr;\n+   |                     ^^^^^^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n+  --> $DIR/illegal_read_despite_exposed2.rs:LL:CC\n+   |\n+LL |         let _val = *exposed_ptr;\n+   |                    ^^^^^^^^^^^^\n    = note: backtrace:\n    = note: inside `main` at $DIR/illegal_read_despite_exposed2.rs:LL:CC\n "}, {"sha": "55ba9aab9bf4e149fe450e7c611a1918cfe05b5e", "filename": "tests/fail/stacked_borrows/illegal_write1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,7 +9,7 @@ LL |         unsafe { *x = 42 };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write1.rs:LL:CC\n    |\n LL |         let x: *mut u32 = xref as *const _ as *mut _;"}, {"sha": "ceb4ce040b8962887120a5bbbf68f6162f2da9af", "filename": "tests/fail/stacked_borrows/illegal_write2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     unsafe { *target2 = 13 };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write2.rs:LL:CC\n    |\n LL |     let target2 = target as *mut _;\n    |                   ^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n   --> $DIR/illegal_write2.rs:LL:CC\n    |\n LL |     drop(&mut *target); // reborrow"}, {"sha": "e091e25190bbfd79bb5d816596d8c008622c1f1a", "filename": "tests/fail/stacked_borrows/illegal_write3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,7 +9,7 @@ LL |     unsafe { *ptr = 42 };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write3.rs:LL:CC\n    |\n LL |     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag"}, {"sha": "d66585ff7f14cd2b0b2b4d5694c24655a647b2b9", "filename": "tests/fail/stacked_borrows/illegal_write4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     let _val = *reference;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write4.rs:LL:CC\n    |\n LL |     let reference = unsafe { &*raw }; // freeze\n    |                              ^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n   --> $DIR/illegal_write4.rs:LL:CC\n    |\n LL |     let _mut_ref: &mut i32 = unsafe { mem::transmute(raw) }; // &mut, with raw tag"}, {"sha": "319c2d77062cb786cc048936454ecc692ccf8d81", "filename": "tests/fail/stacked_borrows/illegal_write5.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write5.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     let _val = *xref;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write5.rs:LL:CC\n    |\n LL |     let xref = unsafe { &mut *xraw };\n    |                         ^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/illegal_write5.rs:LL:CC\n    |\n LL |     unsafe { *xraw = 15 };"}, {"sha": "56576b1ff39b51488c6373f5fa646f9ac8211ca7", "filename": "tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -6,7 +6,7 @@ LL |     unsafe { *y = 2 };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     let p = x as *mut u32;"}, {"sha": "aa436b544126c0d86ac54b69479ad49a3fffdbb5", "filename": "tests/fail/stacked_borrows/illegal_write_despite_exposed1.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,6 +9,16 @@ LL |         let _val = *root2;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n+  --> $DIR/illegal_write_despite_exposed1.rs:LL:CC\n+   |\n+LL |         let root2 = &*exposed_ptr;\n+   |                     ^^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n+  --> $DIR/illegal_write_despite_exposed1.rs:LL:CC\n+   |\n+LL |         *exposed_ptr = 0;\n+   |         ^^^^^^^^^^^^^^^^\n    = note: backtrace:\n    = note: inside `main` at $DIR/illegal_write_despite_exposed1.rs:LL:CC\n "}, {"sha": "6911238fc53e9e4b81997b38c513b37a346fd5fa", "filename": "tests/fail/stacked_borrows/interior_mut1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -12,6 +12,6 @@ fn main() {\n         *c.get() = UnsafeCell::new(1); // invalidates inner_shr\n         // stack: [c: SharedReadWrite]\n \n-        let _val = *inner_shr.get(); //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+        let _val = *inner_shr.get(); //~ ERROR: /retag .* tag does not exist in the borrow stack/\n     }\n }"}, {"sha": "3aaca3892a54a852d5c27e0e11e80e7b4dbb8e4f", "filename": "tests/fail/stacked_borrows/interior_mut1.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/interior_mut1.rs:LL:CC\n    |\n LL |         let _val = *inner_shr.get();\n    |                     ^^^^^^^^^^^^^^^\n    |                     |\n-   |                     trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |                     this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+   |                     trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                     this error occurs as part of retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n   --> $DIR/interior_mut1.rs:LL:CC\n    |\n LL |         let inner_shr = &*inner_uniq; // adds a SharedReadWrite\n    |                         ^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/interior_mut1.rs:LL:CC\n    |\n LL |         *c.get() = UnsafeCell::new(1); // invalidates inner_shr"}, {"sha": "5e9d177cd038d3e69769c4cb8e4cce6bee9cdd23", "filename": "tests/fail/stacked_borrows/interior_mut2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finterior_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finterior_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finterior_mut2.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -25,6 +25,6 @@ fn main() {\n         // stack: [c: SharedReadWrite]\n \n         // now this does not work any more\n-        let _val = *inner_shr.get(); //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+        let _val = *inner_shr.get(); //~ ERROR: /retag .* tag does not exist in the borrow stack/\n     }\n }"}, {"sha": "b0141cc34fb65a3707cdd49c96042a8aff1284de", "filename": "tests/fail/stacked_borrows/interior_mut2.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finterior_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finterior_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finterior_mut2.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/interior_mut2.rs:LL:CC\n    |\n LL |         let _val = *inner_shr.get();\n    |                     ^^^^^^^^^^^^^^^\n    |                     |\n-   |                     trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |                     this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+   |                     trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                     this error occurs as part of retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n   --> $DIR/interior_mut2.rs:LL:CC\n    |\n LL |         let inner_shr = &*inner_uniq;\n    |                         ^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/interior_mut2.rs:LL:CC\n    |\n LL |         *c.get() = UnsafeCell::new(0); // now inner_shr gets invalidated"}, {"sha": "378f7b7d1ef56e173d811b71ca7de7650c89431c", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -6,7 +6,7 @@ LL |     let _val = unsafe { *x };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     let xraw = &mut x as *mut _;"}, {"sha": "0352b671823e6c865fdeba3296e1e7c8a8b32fb4", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -6,7 +6,7 @@ LL |     unsafe { *x = 0 };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     let xraw = &mut x as *mut _;"}, {"sha": "5c99c82da6d6af4c94ddeff4ebeab4ca4c9afd75", "filename": "tests/fail/stacked_borrows/load_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    let _val = *xref_in_mem; //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+    let _val = *xref_in_mem; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }"}, {"sha": "43b6ce8d895ea38850afaafaa69703f4e1099f9c", "filename": "tests/fail/stacked_borrows/load_invalid_mut.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_mut.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for Unique permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/load_invalid_mut.rs:LL:CC\n    |\n LL |     let _val = *xref_in_mem;\n    |                ^^^^^^^^^^^^\n    |                |\n-   |                trying to reborrow from <TAG> for Unique permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |                this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+   |                trying to retag from <TAG> for Unique permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                this error occurs as part of retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/load_invalid_mut.rs:LL:CC\n    |\n LL |     let xref_in_mem = Box::new(xref);\n    |                       ^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n   --> $DIR/load_invalid_mut.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref"}, {"sha": "8f94cc07a24f77bc42e8a61f63fe876892ff543c", "filename": "tests/fail/stacked_borrows/load_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_shr.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let xref = unsafe { &*xraw };\n     let xref_in_mem = Box::new(xref);\n     unsafe { *xraw = 42 }; // unfreeze\n-    let _val = *xref_in_mem; //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+    let _val = *xref_in_mem; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }"}, {"sha": "2177ebdd7021025c73b78ed52ee0eec0ece9191f", "filename": "tests/fail/stacked_borrows/load_invalid_shr.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_shr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_shr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fload_invalid_shr.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/load_invalid_shr.rs:LL:CC\n    |\n LL |     let _val = *xref_in_mem;\n    |                ^^^^^^^^^^^^\n    |                |\n-   |                trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |                this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+   |                trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                this error occurs as part of retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/load_invalid_shr.rs:LL:CC\n    |\n LL |     let xref_in_mem = Box::new(xref);\n    |                       ^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/load_invalid_shr.rs:LL:CC\n    |\n LL |     unsafe { *xraw = 42 }; // unfreeze"}, {"sha": "42f872eac62f6be0b3c975f73a9631abe843e942", "filename": "tests/fail/stacked_borrows/mut_exclusive_violation1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |         *LEAK = 7;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/mut_exclusive_violation1.rs:LL:CC\n    |\n LL |         LEAK = x as *const _ as *mut _;\n    |                ^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/mut_exclusive_violation1.rs:LL:CC\n    |\n LL |     *our = 5;"}, {"sha": "1952172d927b7f63823efdd2ff24d5932ef97da1", "filename": "tests/fail/stacked_borrows/mut_exclusive_violation2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation2.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |         let _val = *raw1;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/mut_exclusive_violation2.rs:LL:CC\n    |\n LL |         let raw1 = ptr1.as_mut();\n    |                    ^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n   --> $DIR/mut_exclusive_violation2.rs:LL:CC\n    |\n LL |         let _raw2 = ptr2.as_mut();"}, {"sha": "2d26787231dc68805f011d0b26c921e538b00d08", "filename": "tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -6,7 +6,7 @@ LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n   --> $DIR/newtype_retagging.rs:LL:CC\n    |\n LL |     let ptr = Box::into_raw(Box::new(0i32));"}, {"sha": "e111a8227b2aae4460b8bbceb70cad28e5914621", "filename": "tests/fail/stacked_borrows/outdated_local.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     assert_eq!(unsafe { *y }, 1);\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/outdated_local.rs:LL:CC\n    |\n LL |     let y: *const i32 = &x;\n    |                         ^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/outdated_local.rs:LL:CC\n    |\n LL |     x = 1; // this invalidates y by reactivating the lowermost uniq borrow for this local"}, {"sha": "8db2c149b17e0562e96580b9236e44e1419ab8ce", "filename": "tests/fail/stacked_borrows/pass_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let _val = unsafe { *xraw }; // invalidate xref\n-    foo(xref); //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+    foo(xref); //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }"}, {"sha": "5fd97780544587179033518a3a541b36fc14d119", "filename": "tests/fail/stacked_borrows/pass_invalid_mut.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_mut.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/pass_invalid_mut.rs:LL:CC\n    |\n LL |     foo(xref);\n    |         ^^^^\n    |         |\n-   |         trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |         this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+   |         trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         this error occurs as part of two-phase retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/pass_invalid_mut.rs:LL:CC\n    |\n LL |     let xref = unsafe { &mut *xraw };\n    |                         ^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n   --> $DIR/pass_invalid_mut.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref"}, {"sha": "903c2733107bbbb091e100b5efa9ef0939ca53c9", "filename": "tests/fail/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &*xraw };\n     unsafe { *xraw = 42 }; // unfreeze\n-    foo(xref); //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+    foo(xref); //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }"}, {"sha": "0f0df02babb51871b6f63694e070407444ed67b5", "filename": "tests/fail/stacked_borrows/pass_invalid_shr.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_shr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_shr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fpass_invalid_shr.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/pass_invalid_shr.rs:LL:CC\n    |\n LL |     foo(xref);\n    |         ^^^^\n    |         |\n-   |         trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |         this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+   |         trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         this error occurs as part of retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/pass_invalid_shr.rs:LL:CC\n    |\n LL |     let xref = unsafe { &*xraw };\n    |                         ^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n   --> $DIR/pass_invalid_shr.rs:LL:CC\n    |\n LL |     unsafe { *xraw = 42 }; // unfreeze"}, {"sha": "43d689a0f4bbb5ef64a2eeed7449bd1b30841882", "filename": "tests/fail/stacked_borrows/pointer_smuggling.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     let _x = unsafe { *PTR };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x1]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x1]\n   --> $DIR/pointer_smuggling.rs:LL:CC\n    |\n LL |         PTR = x;\n    |               ^\n-help: <TAG> was later invalidated at offsets [0x0..0x1]\n+help: <TAG> was later invalidated at offsets [0x0..0x1] by a write access\n   --> $DIR/pointer_smuggling.rs:LL:CC\n    |\n LL |     *val = 2; // this invalidates any raw ptrs `fun1` might have created."}, {"sha": "fc846f6d9f6a04b21da1321a4ab14c91ea3360f6", "filename": "tests/fail/stacked_borrows/raw_tracking.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fraw_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fraw_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fraw_tracking.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |     unsafe { *raw1 = 13 };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n   --> $DIR/raw_tracking.rs:LL:CC\n    |\n LL |     let raw1 = &mut l as *mut _;\n    |                ^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n   --> $DIR/raw_tracking.rs:LL:CC\n    |\n LL |     let raw2 = &mut l as *mut _; // invalidates raw1"}, {"sha": "7d9a6f11aff97af17c2ee9558121e6997bcfdbc1", "filename": "tests/fail/stacked_borrows/return_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {"}, {"sha": "c9194208e5dd5819116e843bd0f1c1bfafc6e827", "filename": "tests/fail/stacked_borrows/return_invalid_mut.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_mut.rs:LL:CC\n    |\n LL |     ret\n    |     ^^^\n    |     |\n-   |     trying to reborrow from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |     this error occurs as part of a reborrow at ALLOC[0x4..0x8]\n+   |     trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x4..0x8]\n+help: <TAG> was created by a Unique retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_mut.rs:LL:CC\n    |\n LL |     let ret = unsafe { &mut (*xraw).1 };\n    |                        ^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x8]\n+help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n   --> $DIR/return_invalid_mut.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref"}, {"sha": "7fa9cf77d44b2153bc97303ca886a15925de03e7", "filename": "tests/fail/stacked_borrows/return_invalid_mut_option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -10,7 +10,7 @@ fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n \n fn main() {\n     match foo(&mut (1, 2)) {\n-        Some(_x) => {} //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+        Some(_x) => {} //~ ERROR: /retag .* tag does not exist in the borrow stack/\n         None => {}\n     }\n }"}, {"sha": "789d0a3aa82936514f93883630b22cd1819862e4", "filename": "tests/fail/stacked_borrows/return_invalid_mut_option.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n LL |         Some(_x) => {}\n    |              ^^\n    |              |\n-   |              trying to reborrow from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of a reborrow at ALLOC[0x4..0x8]\n+   |              trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |              this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x4..0x8]\n+help: <TAG> was created by a Unique retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n LL |     let ret = Some(ret);\n    |                    ^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x8]\n+help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref"}, {"sha": "c94fef90542fdc1d0e9b37df4c6d776df825f17f", "filename": "tests/fail/stacked_borrows/return_invalid_mut_tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -8,5 +8,5 @@ fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n }\n \n fn main() {\n-    foo(&mut (1, 2)).0; //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+    foo(&mut (1, 2)).0; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }"}, {"sha": "f7fc75bfd098f2eedf8bbbbbfd6fb5dad135619f", "filename": "tests/fail/stacked_borrows/return_invalid_mut_tuple.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n LL |     foo(&mut (1, 2)).0;\n    |     ^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     trying to reborrow from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |     this error occurs as part of a reborrow at ALLOC[0x4..0x8]\n+   |     trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x4..0x8]\n+help: <TAG> was created by a Unique retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n LL |     let ret = (unsafe { &mut (*xraw).1 },);\n    |                         ^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x8]\n+help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref"}, {"sha": "45526498dadf5cfbd07b60dfa1975eaf4a53f43f", "filename": "tests/fail/stacked_borrows/return_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &(*xraw).1 };\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {"}, {"sha": "fef83c478fe912ffed853795af24e86332600769", "filename": "tests/fail/stacked_borrows/return_invalid_shr.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_shr.rs:LL:CC\n    |\n LL |     ret\n    |     ^^^\n    |     |\n-   |     trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |     this error occurs as part of a reborrow at ALLOC[0x4..0x8]\n+   |     trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x4..0x8]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_shr.rs:LL:CC\n    |\n LL |     let ret = unsafe { &(*xraw).1 };\n    |                        ^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x8]\n+help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n   --> $DIR/return_invalid_shr.rs:LL:CC\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze"}, {"sha": "3a028ceed86ae508d5b3b4a631460343d99f7201", "filename": "tests/fail/stacked_borrows/return_invalid_shr_option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,7 +9,7 @@ fn foo(x: &mut (i32, i32)) -> Option<&i32> {\n \n fn main() {\n     match foo(&mut (1, 2)) {\n-        Some(_x) => {} //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+        Some(_x) => {} //~ ERROR: /retag .* tag does not exist in the borrow stack/\n         None => {}\n     }\n }"}, {"sha": "cc316aaf44ece1fb4fa578f4fd66c68541865ea9", "filename": "tests/fail/stacked_borrows/return_invalid_shr_option.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n LL |         Some(_x) => {}\n    |              ^^\n    |              |\n-   |              trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of a reborrow at ALLOC[0x4..0x8]\n+   |              trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |              this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x4..0x8]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n LL |     let ret = Some(unsafe { &(*xraw).1 });\n    |                             ^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x8]\n+help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze"}, {"sha": "e4536626dbf2cc891673162c10877e9bc8a5a773", "filename": "tests/fail/stacked_borrows/return_invalid_shr_tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -8,5 +8,5 @@ fn foo(x: &mut (i32, i32)) -> (&i32,) {\n }\n \n fn main() {\n-    foo(&mut (1, 2)).0; //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+    foo(&mut (1, 2)).0; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }"}, {"sha": "f6be5d0e53a06ffcd4e47334a4c4b37413b1a9d5", "filename": "tests/fail/stacked_borrows/return_invalid_shr_tuple.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n LL |     foo(&mut (1, 2)).0;\n    |     ^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |     this error occurs as part of a reborrow at ALLOC[0x4..0x8]\n+   |     trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x4..0x8]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n LL |     let ret = (unsafe { &(*xraw).1 },);\n    |                         ^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x8]\n+help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze"}, {"sha": "2450ec4b4a1d0234b0bd87a2d3fe37040bdb511c", "filename": "tests/fail/stacked_borrows/shared_rw_borrows_are_weak1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -11,6 +11,6 @@ fn main() {\n         let y: &mut Cell<i32> = mem::transmute(&mut *x); // launder lifetime\n         let shr_rw = &*x; // thanks to interior mutability this will be a SharedReadWrite\n         shr_rw.set(1);\n-        y.get_mut(); //~ ERROR: /reborrow .* tag does not exist in the borrow stack/\n+        y.get_mut(); //~ ERROR: /retag .* tag does not exist in the borrow stack/\n     }\n }"}, {"sha": "3f5f2c66ae1fff4cc2336fb150561ece9ddfd6ba", "filename": "tests/fail/stacked_borrows/shared_rw_borrows_are_weak1.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/shared_rw_borrows_are_weak1.rs:LL:CC\n    |\n LL |         y.get_mut();\n    |         ^^^^^^^^^^^\n    |         |\n-   |         trying to reborrow from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |         this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+   |         trying to retag from <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         this error occurs as part of two-phase retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n   --> $DIR/shared_rw_borrows_are_weak1.rs:LL:CC\n    |\n LL |         let y: &mut Cell<i32> = mem::transmute(&mut *x); // launder lifetime\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n   --> $DIR/shared_rw_borrows_are_weak1.rs:LL:CC\n    |\n LL |         shr_rw.set(1);"}, {"sha": "0a551fe824b5e5f1c92071c971f899861ea015e5", "filename": "tests/fail/stacked_borrows/shared_rw_borrows_are_weak2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak2.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,12 +9,12 @@ LL |         let _val = *y;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [$HEX..$HEX]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [$HEX..$HEX]\n   --> $DIR/shared_rw_borrows_are_weak2.rs:LL:CC\n    |\n LL |         let y: &i32 = mem::transmute(&*x.borrow()); // launder lifetime\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [$HEX..$HEX]\n+help: <TAG> was later invalidated at offsets [$HEX..$HEX] by a Unique retag\n   --> $DIR/shared_rw_borrows_are_weak2.rs:LL:CC\n    |\n LL |         shr_rw.replace(1);"}, {"sha": "9ae8461e13ea2e735b9198f765fe67aeccebaaf4", "filename": "tests/fail/stacked_borrows/shr_frozen_violation1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,7 +9,7 @@ LL |         *(x as *const i32 as *mut i32) = 7;\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x4]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n   --> $DIR/shr_frozen_violation1.rs:LL:CC\n    |\n LL |         *(x as *const i32 as *mut i32) = 7;"}, {"sha": "3455eb4684ea228f78eadbffecc2ed7e0790c071", "filename": "tests/fail/stacked_borrows/track_caller.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ftrack_caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ftrack_caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Ftrack_caller.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -0,0 +1,17 @@\n+// This is a copy of illegal_read1.rs, but with #[track_caller] on the test.\n+// This test only checks that our diagnostics do not display the contents of callee.\n+\n+#[rustfmt::skip] // rustfmt bug: https://github.com/rust-lang/rustfmt/issues/5391\n+fn main() {\n+    let mut x = 15;\n+    let xraw = &mut x as *mut _;\n+    let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still ok...\n+    callee(xraw);\n+    let _val = *xref; // ...but any use of raw will invalidate our ref.\n+    //~^ ERROR: /read access .* tag does not exist in the borrow stack/\n+}\n+\n+#[track_caller]\n+fn callee(xraw: *mut i32) {\n+    let _val = unsafe { *xraw };\n+}"}, {"sha": "5ad22305910aaf2820b1b8ed368350edb1f701cb", "filename": "tests/fail/stacked_borrows/track_caller.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ftrack_caller.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ftrack_caller.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Ftrack_caller.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -0,0 +1,28 @@\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/track_caller.rs:LL:CC\n+   |\n+LL |     let _val = *xref; // ...but any use of raw will invalidate our ref.\n+   |                ^^^^^\n+   |                |\n+   |                attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n+  --> $DIR/track_caller.rs:LL:CC\n+   |\n+LL |     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still ok...\n+   |                         ^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n+  --> $DIR/track_caller.rs:LL:CC\n+   |\n+LL |     callee(xraw);\n+   |     ^^^^^^^^^^^^\n+   = note: backtrace:\n+   = note: inside `main` at $DIR/track_caller.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "eaac77034cce835c0ee7f9408a87bf8a51bd7b00", "filename": "tests/fail/stacked_borrows/transmute-is-no-escape.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,7 +9,7 @@ LL |     unsafe { *raw = 13 };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x4..0x8]\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x4..0x8]\n   --> $DIR/transmute-is-no-escape.rs:LL:CC\n    |\n LL |     let raw = (&mut x[1] as *mut i32).wrapping_offset(-1);"}, {"sha": "7b210ed9314e80e54e5f48533254a5a708363573", "filename": "tests/fail/stacked_borrows/unescaped_static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -9,7 +9,7 @@ LL |     let _val = unsafe { *ptr_to_first.add(1) };\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x1]\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x1]\n   --> $DIR/unescaped_static.rs:LL:CC\n    |\n LL |     let ptr_to_first = &ARRAY[0] as *const u8;"}, {"sha": "77daa9c9811aee828d923adcda36c6180b7716c6", "filename": "tests/fail/stacked_borrows/zst_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fzst_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fzst_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fzst_slice.rs?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,5 +1,5 @@\n //@compile-flags: -Zmiri-strict-provenance\n-//@error-pattern: /reborrow .* tag does not exist in the borrow stack/\n+//@error-pattern: /retag .* tag does not exist in the borrow stack/\n \n fn main() {\n     unsafe {"}, {"sha": "6d0e785cea765c55edd4e1cc28b8ff9d0467cc4d", "filename": "tests/fail/stacked_borrows/zst_slice.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fzst_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b/tests%2Ffail%2Fstacked_borrows%2Fzst_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fzst_slice.stderr?ref=14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "patch": "@@ -1,15 +1,15 @@\n-error: Undefined Behavior: trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> RUSTLIB/core/src/slice/mod.rs:LL:CC\n    |\n LL |         unsafe { &*index.get_unchecked(self) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  trying to reborrow from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |                  this error occurs as part of a reborrow at ALLOC[0x4..0x8]\n+   |                  trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |                  this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a retag at offsets [0x0..0x0]\n+help: <TAG> would have been created here, but this is a zero-size retag ([0x0..0x0]) so the tag in question does not exist anywhere\n   --> $DIR/zst_slice.rs:LL:CC\n    |\n LL |         assert_eq!(*s.get_unchecked(1), 2);"}]}