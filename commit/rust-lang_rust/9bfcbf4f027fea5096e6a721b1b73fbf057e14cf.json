{"sha": "9bfcbf4f027fea5096e6a721b1b73fbf057e14cf", "node_id": "C_kwDOAAsO6NoAKDliZmNiZjRmMDI3ZmVhNTA5NmU2YTcyMWIxYjczZmJmMDU3ZTE0Y2Y", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-17T15:48:24Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-17T15:48:24Z"}, "message": "Remove some redundant checks in various matches lints", "tree": {"sha": "cca3252db35445dfd8783a14baecd61aeb269a03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cca3252db35445dfd8783a14baecd61aeb269a03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf", "html_url": "https://github.com/rust-lang/rust/commit/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4cf91b9c8b393a83dc9690d2721346a1fe0569d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4cf91b9c8b393a83dc9690d2721346a1fe0569d", "html_url": "https://github.com/rust-lang/rust/commit/a4cf91b9c8b393a83dc9690d2721346a1fe0569d"}], "stats": {"total": 257, "additions": 128, "deletions": 129}, "files": [{"sha": "2e1f7646eb400b3924ff813738c90091205e139f", "filename": "clippy_lints/src/matches/match_like_matches.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=9bfcbf4f027fea5096e6a721b1b73fbf057e14cf", "patch": "@@ -3,49 +3,52 @@ use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{higher, is_wild};\n use rustc_ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Guard, MatchSource, Pat};\n+use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Guard, Pat};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Spanned;\n \n use super::MATCH_LIKE_MATCHES_MACRO;\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     if let Some(higher::IfLet {\n         let_pat,\n         let_expr,\n         if_then,\n         if_else: Some(if_else),\n     }) = higher::IfLet::hir(cx, expr)\n     {\n-        return find_matches_sugg(\n+        find_matches_sugg(\n             cx,\n             let_expr,\n             IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n             expr,\n             true,\n         );\n     }\n+}\n \n-    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n-        return find_matches_sugg(\n-            cx,\n-            scrut,\n-            arms.iter().map(|arm| {\n-                (\n-                    cx.tcx.hir().attrs(arm.hir_id),\n-                    Some(arm.pat),\n-                    arm.body,\n-                    arm.guard.as_ref(),\n-                )\n-            }),\n-            expr,\n-            false,\n-        );\n-    }\n-\n-    false\n+pub(super) fn check_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'tcx>],\n+) -> bool {\n+    find_matches_sugg(\n+        cx,\n+        scrutinee,\n+        arms.iter().map(|arm| {\n+            (\n+                cx.tcx.hir().attrs(arm.hir_id),\n+                Some(arm.pat),\n+                arm.body,\n+                arm.guard.as_ref(),\n+            )\n+        }),\n+        e,\n+        false,\n+    )\n }\n \n /// Lint a `match` or `if let` for replacement by `matches!`"}, {"sha": "d11dda57e6fd94c2676a4ef1a0fc2d95bc4d8feb", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=9bfcbf4f027fea5096e6a721b1b73fbf057e14cf", "patch": "@@ -1,96 +1,94 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n-use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, MatchSource, Pat, PatKind};\n+use rustc_hir::{Arm, Expr, HirId, HirIdMap, HirIdSet, Pat, PatKind};\n use rustc_lint::LateContext;\n use std::collections::hash_map::Entry;\n \n use super::MATCH_SAME_ARMS;\n \n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(arm.body);\n-            h.finish()\n-        };\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n+    let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_expr(arm.body);\n+        h.finish()\n+    };\n \n-        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n-            let min_index = usize::min(lindex, rindex);\n-            let max_index = usize::max(lindex, rindex);\n+    let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+        let min_index = usize::min(lindex, rindex);\n+        let max_index = usize::max(lindex, rindex);\n \n-            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n-            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-                if_chain! {\n-                    if let Some(a_id) = path_to_local(a);\n-                    if let Some(b_id) = path_to_local(b);\n-                    let entry = match local_map.entry(a_id) {\n-                        Entry::Vacant(entry) => entry,\n-                        // check if using the same bindings as before\n-                        Entry::Occupied(entry) => return *entry.get() == b_id,\n-                    };\n-                    // the names technically don't have to match; this makes the lint more conservative\n-                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n-                    if cx.typeck_results().expr_ty(a) == cx.typeck_results().expr_ty(b);\n-                    if pat_contains_local(lhs.pat, a_id);\n-                    if pat_contains_local(rhs.pat, b_id);\n-                    then {\n-                        entry.insert(b_id);\n-                        true\n-                    } else {\n-                        false\n-                    }\n+        let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n+        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+            if_chain! {\n+                if let Some(a_id) = path_to_local(a);\n+                if let Some(b_id) = path_to_local(b);\n+                let entry = match local_map.entry(a_id) {\n+                    Entry::Vacant(entry) => entry,\n+                    // check if using the same bindings as before\n+                    Entry::Occupied(entry) => return *entry.get() == b_id,\n+                };\n+                // the names technically don't have to match; this makes the lint more conservative\n+                if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                if cx.typeck_results().expr_ty(a) == cx.typeck_results().expr_ty(b);\n+                if pat_contains_local(lhs.pat, a_id);\n+                if pat_contains_local(rhs.pat, b_id);\n+                then {\n+                    entry.insert(b_id);\n+                    true\n+                } else {\n+                    false\n                 }\n-            };\n-            // Arms with a guard are ignored, those can\u2019t always be merged together\n-            // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-                && SpanlessEq::new(cx)\n-                    .expr_fallback(eq_fallback)\n-                    .eq_expr(lhs.body, rhs.body)\n-                // these checks could be removed to allow unused bindings\n-                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+            }\n         };\n+        // Arms with a guard are ignored, those can\u2019t always be merged together\n+        // This is also the case for arms in-between each there is an arm with a guard\n+        (min_index..=max_index).all(|index| arms[index].guard.is_none())\n+            && SpanlessEq::new(cx)\n+                .expr_fallback(eq_fallback)\n+                .eq_expr(lhs.body, rhs.body)\n+            // these checks could be removed to allow unused bindings\n+            && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+            && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+    };\n \n-        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |diag| {\n-                    diag.span_note(i.body.span, \"same as this\");\n+    let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+    for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n+        span_lint_and_then(\n+            cx,\n+            MATCH_SAME_ARMS,\n+            j.body.span,\n+            \"this `match` has identical arm bodies\",\n+            |diag| {\n+                diag.span_note(i.body.span, \"same as this\");\n \n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n+                // Note: this does not use `span_suggestion` on purpose:\n+                // there is no clean way\n+                // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                // makes an even more confusing error message. Also in order not to make up a\n+                // span for the whole pattern, the suggestion is only shown when there is only\n+                // one pattern. The user should know about `|` if they are already using it\u2026\n \n-                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+                let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n \n-                    if let PatKind::Wild = j.pat.kind {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pat cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        diag.span_note(\n-                            i.body.span,\n-                            &format!(\n-                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                                lhs\n-                            ),\n-                        );\n-                    } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n-                            .help(\"...or consider changing the match arm bodies\");\n-                    }\n-                },\n-            );\n-        }\n+                if let PatKind::Wild = j.pat.kind {\n+                    // if the last arm is _, then i could be integrated into _\n+                    // note that i.pat cannot be _, because that would mean that we're\n+                    // hiding all the subsequent arms, and rust won't compile\n+                    diag.span_note(\n+                        i.body.span,\n+                        &format!(\n+                            \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n+                            lhs\n+                        ),\n+                    );\n+                } else {\n+                    diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n+                        .help(\"...or consider changing the match arm bodies\");\n+                }\n+            },\n+        );\n     }\n }\n "}, {"sha": "614a824010f968554ed4b8495f83ba55b031d505", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=9bfcbf4f027fea5096e6a721b1b73fbf057e14cf", "patch": "@@ -604,33 +604,35 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             return;\n         }\n \n-        redundant_pattern_match::check(cx, expr);\n+        if let ExprKind::Match(ex, arms, source) = expr.kind {\n+            if source == MatchSource::Normal {\n+                if !(meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO)\n+                    && match_like_matches::check_match(cx, expr, ex, arms))\n+                {\n+                    match_same_arms::check(cx, arms);\n+                }\n \n-        if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n-            if !match_like_matches::check(cx, expr) {\n-                match_same_arms::check(cx, expr);\n-            }\n-        } else {\n-            match_same_arms::check(cx, expr);\n-        }\n-\n-        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n-            single_match::check(cx, ex, arms, expr);\n-            match_bool::check(cx, ex, arms, expr);\n-            overlapping_arms::check(cx, ex, arms);\n-            match_wild_err_arm::check(cx, ex, arms);\n-            match_wild_enum::check(cx, ex, arms);\n-            match_as_ref::check(cx, ex, arms, expr);\n-            wild_in_or_pats::check(cx, arms);\n+                redundant_pattern_match::check_match(cx, expr, ex, arms);\n+                single_match::check(cx, ex, arms, expr);\n+                match_bool::check(cx, ex, arms, expr);\n+                overlapping_arms::check(cx, ex, arms);\n+                match_wild_err_arm::check(cx, ex, arms);\n+                match_wild_enum::check(cx, ex, arms);\n+                match_as_ref::check(cx, ex, arms, expr);\n+                wild_in_or_pats::check(cx, arms);\n \n-            if self.infallible_destructuring_match_linted {\n-                self.infallible_destructuring_match_linted = false;\n-            } else {\n-                match_single_binding::check(cx, ex, arms, expr);\n+                if self.infallible_destructuring_match_linted {\n+                    self.infallible_destructuring_match_linted = false;\n+                } else {\n+                    match_single_binding::check(cx, ex, arms, expr);\n+                }\n             }\n-        }\n-        if let ExprKind::Match(ex, arms, _) = expr.kind {\n             match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n+        } else {\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n+                match_like_matches::check(cx, expr);\n+            }\n+            redundant_pattern_match::check(cx, expr);\n         }\n     }\n "}, {"sha": "c491b2775d8476ccaef59d6c41dc336763408682", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bfcbf4f027fea5096e6a721b1b73fbf057e14cf/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=9bfcbf4f027fea5096e6a721b1b73fbf057e14cf", "patch": "@@ -12,13 +12,13 @@ use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, PollPending};\n use rustc_hir::{\n     intravisit::{walk_expr, Visitor},\n-    Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n+    Arm, Block, Expr, ExprKind, LangItem, Node, Pat, PatKind, QPath, UnOp,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n use rustc_span::sym;\n \n-pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     if let Some(higher::IfLet {\n         if_else,\n         let_pat,\n@@ -27,11 +27,7 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     }) = higher::IfLet::hir(cx, expr)\n     {\n         find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n-    }\n-    if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n-        find_sugg_for_match(cx, expr, op, arms);\n-    }\n-    if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+    } else if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n         find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n     }\n }\n@@ -304,7 +300,7 @@ fn find_sugg_for_if_let<'tcx>(\n     );\n }\n \n-fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n     if arms.len() == 2 {\n         let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n "}]}