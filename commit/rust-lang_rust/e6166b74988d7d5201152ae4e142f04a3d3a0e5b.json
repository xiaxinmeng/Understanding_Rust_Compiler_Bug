{"sha": "e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MTY2Yjc0OTg4ZDdkNTIwMTE1MmFlNGUxNDJmMDRhM2QzYTBlNWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T17:07:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T17:07:43Z"}, "message": "rollup merge of #23712: nikomatsakis/reflect-trait\n\nThis PR introduces a `Reflect` marker trait which is a supertrait of `Any`. The idea is that `Reflect` is defined for all concrete types, but is not defined for type parameters unless there is a `T:Reflect` bound. This is intended to preserve the parametricity property. This allows the `Any` interface to be stabilized without committing us to unbounded reflection that is not easily detectable by the caller.\n\nThe implementation of `Reflect` relies on an experimental variant of OIBIT. This variant behaves differently for objects, since it requires that all types exposed as part of the object's *interface* are `Reflect`, but isn't concerned about other types that may be closed over. In other words, you don't have to write `Foo+Reflect` in order for `Foo: Reflect` to hold (where `Foo` is a trait).\n\nGiven that `Any` is slated to stabilization and hence that we are committed to some form of reflection, the goal of this PR is to leave our options open with respect to parametricity. I see the options for full stabilization as follows (I think an RFC would be an appropriate way to confirm whichever of these three routes we take):\n\n1. We make `Reflect` a lang-item.\n2. We stabilize some version of the OIBIT variation I implemented as a general mechanism that may be appropriate for other use cases.\n3. We give up on preserving parametricity here and just have `impl<T> Reflect for T` instead. In that case, `Reflect` is a harmless but not especially useful trait going forward.\n\ncc @aturon\ncc @alexcrichton\ncc @glaebhoerl (this is more-or-less your proposal, as I understood it)\ncc @reem (this is more-or-less what we discussed on IRC at some point)\ncc @FlaPer87 (vaguely pertains to OIBIT)", "tree": {"sha": "b235cfcdc92a8249c5061743cce03ea24c1468b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b235cfcdc92a8249c5061743cce03ea24c1468b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "html_url": "https://github.com/rust-lang/rust/commit/e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adbb5160675bcb9aba0569782ff15061b4dbbb92", "url": "https://api.github.com/repos/rust-lang/rust/commits/adbb5160675bcb9aba0569782ff15061b4dbbb92", "html_url": "https://github.com/rust-lang/rust/commit/adbb5160675bcb9aba0569782ff15061b4dbbb92"}, {"sha": "dd8cf9238940b7b0dc54cc05d0788d8d7282aa27", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd8cf9238940b7b0dc54cc05d0788d8d7282aa27", "html_url": "https://github.com/rust-lang/rust/commit/dd8cf9238940b7b0dc54cc05d0788d8d7282aa27"}], "stats": {"total": 741, "additions": 568, "deletions": 173}, "files": [{"sha": "f9bd0ab2f1e0fdbe1e3cb88fcb61413d1e21b8b6", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -244,13 +244,13 @@ pub trait BoxAny {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>>;\n+    fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BoxAny for Box<Any> {\n     #[inline]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n+    fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -270,7 +270,7 @@ impl BoxAny for Box<Any> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BoxAny for Box<Any+Send> {\n     #[inline]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n+    fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         <Box<Any>>::downcast(self)\n     }\n }"}, {"sha": "d3bc07b173ac8e963f5541204ab68e3fded38731", "filename": "src/libcore/any.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -55,7 +55,7 @@\n //! }\n //!\n //! // This function wants to log its parameter out prior to doing work with it.\n-//! fn do_work<T: Debug + 'static>(value: &T) {\n+//! fn do_work<T: Any + Debug>(value: &T) {\n //!     log(value);\n //!     // ...do some other work\n //! }\n@@ -76,7 +76,7 @@ use mem::transmute;\n use option::Option::{self, Some, None};\n use raw::TraitObject;\n use intrinsics;\n-use marker::Sized;\n+use marker::{Reflect, Sized};\n \n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n@@ -88,14 +88,16 @@ use marker::Sized;\n ///\n /// [mod]: ../index.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Any: 'static {\n+pub trait Any: Reflect + 'static {\n     /// Get the `TypeId` of `self`\n     #[unstable(feature = \"core\",\n                reason = \"this method will likely be replaced by an associated static\")]\n     fn get_type_id(&self) -> TypeId;\n }\n \n-impl<T: 'static> Any for T {\n+impl<T> Any for T\n+    where T: Reflect + 'static\n+{\n     fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }\n }\n \n@@ -107,7 +109,7 @@ impl Any {\n     /// Returns true if the boxed type is the same as `T`\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is<T: 'static>(&self) -> bool {\n+    pub fn is<T: Any>(&self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n         let t = TypeId::of::<T>();\n \n@@ -122,7 +124,7 @@ impl Any {\n     /// `None` if it isn't.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn downcast_ref<T: 'static>(&self) -> Option<&T> {\n+    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -140,7 +142,7 @@ impl Any {\n     /// `None` if it isn't.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn downcast_mut<T: 'static>(&mut self) -> Option<&mut T> {\n+    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -159,21 +161,21 @@ impl Any+Send {\n     /// Forwards to the method defined on the type `Any`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is<T: 'static>(&self) -> bool {\n+    pub fn is<T: Any>(&self) -> bool {\n         Any::is::<T>(self)\n     }\n \n     /// Forwards to the method defined on the type `Any`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn downcast_ref<T: 'static>(&self) -> Option<&T> {\n+    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         Any::downcast_ref::<T>(self)\n     }\n \n     /// Forwards to the method defined on the type `Any`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn downcast_mut<T: 'static>(&mut self) -> Option<&mut T> {\n+    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         Any::downcast_mut::<T>(self)\n     }\n }\n@@ -202,7 +204,7 @@ impl TypeId {\n     /// instantiated with\n     #[unstable(feature = \"core\",\n                reason = \"may grow a `Reflect` bound soon via marker traits\")]\n-    pub fn of<T: ?Sized + 'static>() -> TypeId {\n+    pub fn of<T: ?Sized + Any>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },\n         }"}, {"sha": "7225b016e6ba645c6a8315b1159dbd14517e3145", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -72,6 +72,7 @@\n #![feature(rustc_attrs)]\n #![feature(optin_builtin_traits)]\n #![feature(concat_idents)]\n+#![feature(reflect)]\n \n #[macro_use]\n mod macros;"}, {"sha": "35fde2cb64a310e029b14f626ac7aeb92f3c668b", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -450,3 +450,46 @@ pub struct CovariantType<T>;\n #[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<T>>`\")]\n #[lang=\"invariant_type\"]\n pub struct InvariantType<T>;\n+\n+/// A marker trait indicates a type that can be reflected over. This\n+/// trait is implemented for all types. Its purpose is to ensure that\n+/// when you write a generic function that will employ reflection,\n+/// that must be reflected (no pun intended) in the generic bounds of\n+/// that function. Here is an example:\n+///\n+/// ```\n+/// #![feature(core)]\n+/// use std::marker::Reflect;\n+/// use std::any::Any;\n+/// fn foo<T:Reflect+'static>(x: &T) {\n+///     let any: &Any = x;\n+///     if any.is::<u32>() { println!(\"u32\"); }\n+/// }\n+/// ```\n+///\n+/// Without the declaration `T:Reflect`, `foo` would not type check\n+/// (note: as a matter of style, it would be preferable to to write\n+/// `T:Any`, because `T:Any` implies `T:Reflect` and `T:'static`, but\n+/// we use `Reflect` here to show how it works). The `Reflect` bound\n+/// thus serves to alert `foo`'s caller to the fact that `foo` may\n+/// behave differently depending on whether `T=u32` or not. In\n+/// particular, thanks to the `Reflect` bound, callers know that a\n+/// function declared like `fn bar<T>(...)` will always act in\n+/// precisely the same way no matter what type `T` is supplied,\n+/// beacuse there are no bounds declared on `T`. (The ability for a\n+/// caller to reason about what a function may do based solely on what\n+/// generic bounds are declared is often called the [\"parametricity\n+/// property\"][1].)\n+///\n+/// [1]: http://en.wikipedia.org/wiki/Parametricity\n+#[rustc_reflect_like]\n+#[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n+pub trait Reflect : MarkerTrait {\n+}\n+\n+#[cfg(stage0)]\n+impl<T> Reflect for T { }\n+\n+#[cfg(not(stage0))]\n+impl Reflect for .. { }\n+"}, {"sha": "2eaa536dabebc29b6059ba99d0891881b529cf21", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -163,6 +163,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n \n+        assert!(!obligation.has_escaping_regions());\n+\n         if !self.duplicate_set.insert(obligation.predicate.clone()) {\n             debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n             return;"}, {"sha": "ffc11efe7c711e7c6c435225ca7d6af69a5d54d4", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -48,6 +48,8 @@ pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n+pub use self::util::supertrait_def_ids;\n+pub use self::util::SupertraitDefIds;\n pub use self::util::transitive_bounds;\n pub use self::util::upcast;\n \n@@ -640,7 +642,7 @@ impl<'tcx> FulfillmentError<'tcx> {\n }\n \n impl<'tcx> TraitObligation<'tcx> {\n-    fn self_ty(&self) -> Ty<'tcx> {\n-        self.predicate.0.self_ty()\n+    fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+        ty::Binder(self.predicate.skip_binder().self_ty())\n     }\n }"}, {"sha": "9dccadc932bb49e2fcbf3ab33aa298fbb413cdea", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -53,36 +53,36 @@ pub enum MethodViolationCode {\n }\n \n pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                            trait_ref: ty::PolyTraitRef<'tcx>)\n+                            trait_def_id: ast::DefId)\n                             -> bool\n {\n     // Because we query yes/no results frequently, we keep a cache:\n     let cached_result =\n-        tcx.object_safety_cache.borrow().get(&trait_ref.def_id()).cloned();\n+        tcx.object_safety_cache.borrow().get(&trait_def_id).cloned();\n \n     let result =\n         cached_result.unwrap_or_else(|| {\n-            let result = object_safety_violations(tcx, trait_ref.clone()).is_empty();\n+            let result = object_safety_violations(tcx, trait_def_id).is_empty();\n \n             // Record just a yes/no result in the cache; this is what is\n             // queried most frequently. Note that this may overwrite a\n             // previous result, but always with the same thing.\n-            tcx.object_safety_cache.borrow_mut().insert(trait_ref.def_id(), result);\n+            tcx.object_safety_cache.borrow_mut().insert(trait_def_id, result);\n \n             result\n         });\n \n-    debug!(\"is_object_safe({}) = {}\", trait_ref.repr(tcx), result);\n+    debug!(\"is_object_safe({}) = {}\", trait_def_id.repr(tcx), result);\n \n     result\n }\n \n pub fn object_safety_violations<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      sub_trait_ref: ty::PolyTraitRef<'tcx>)\n+                                      trait_def_id: ast::DefId)\n                                       -> Vec<ObjectSafetyViolation<'tcx>>\n {\n-    supertraits(tcx, sub_trait_ref)\n-        .flat_map(|tr| object_safety_violations_for_trait(tcx, tr.def_id()).into_iter())\n+    traits::supertrait_def_ids(tcx, trait_def_id)\n+        .flat_map(|def_id| object_safety_violations_for_trait(tcx, def_id).into_iter())\n         .collect()\n }\n "}, {"sha": "7e89534026ff37a5e1bf1b312f1dba997700db66", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 218, "deletions": 127, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -138,6 +138,7 @@ enum SelectionCandidate<'tcx> {\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(ast::DefId),\n     DefaultImplCandidate(ast::DefId),\n+    DefaultImplObjectCandidate(ast::DefId),\n \n     /// This is a trait matching with a projected type as `Self`, and\n     /// we found an applicable bound in the trait definition.\n@@ -171,7 +172,7 @@ struct SelectionCandidateSet<'tcx> {\n }\n \n enum BuiltinBoundConditions<'tcx> {\n-    If(Vec<Ty<'tcx>>),\n+    If(ty::Binder<Vec<Ty<'tcx>>>),\n     ParameterBuiltin,\n     AmbiguousBuiltin\n }\n@@ -292,7 +293,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // because if it is a closure type, it must be a closure type from\n         // within this current fn, and hence none of the higher-ranked\n         // lifetimes can appear inside the self-type.\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             _ => { return; }\n@@ -1050,7 +1051,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => { return Ok(()); }\n         };\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // ok to skip binder because the substs on closure types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n@@ -1093,7 +1097,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(());\n         }\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // ok to skip binder because what we are inspecting doesn't involve bound regions\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         match self_ty.sty {\n             ty::ty_infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n@@ -1125,8 +1130,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        debug!(\"assemble_candidates_from_impls(self_ty={})\", self_ty.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr(self.tcx()));\n \n         let def_id = obligation.predicate.def_id();\n         let all_impls = self.all_impls(def_id);\n@@ -1152,15 +1156,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               candidates: &mut SelectionCandidateSet<'tcx>)\n                                               -> Result<(), SelectionError<'tcx>>\n     {\n-\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // OK to skip binder here because the tests we do below do not involve bound regions\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         debug!(\"assemble_candidates_from_default_impls(self_ty={})\", self_ty.repr(self.tcx()));\n \n         let def_id = obligation.predicate.def_id();\n \n         if ty::trait_has_default_impl(self.tcx(), def_id) {\n             match self_ty.sty {\n-                ty::ty_trait(..) |\n+                ty::ty_trait(..) => {\n+                    // For object types, we don't know what the closed\n+                    // over types are. For most traits, this means we\n+                    // conservatively say nothing; a candidate may be\n+                    // added by `assemble_candidates_from_object_ty`.\n+                    // However, for the kind of magic reflect trait,\n+                    // we consider it to be implemented even for\n+                    // object types, because it just lets you reflect\n+                    // onto the object type, not into the object's\n+                    // interior.\n+                    if ty::has_attr(self.tcx(), def_id, \"rustc_reflect_like\") {\n+                        candidates.vec.push(DefaultImplObjectCandidate(def_id));\n+                    }\n+                }\n                 ty::ty_param(..) |\n                 ty::ty_projection(..) => {\n                     // In these cases, we don't know what the actual\n@@ -1210,10 +1227,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           obligation: &TraitObligation<'tcx>,\n                                           candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-\n         debug!(\"assemble_candidates_from_object_ty(self_ty={})\",\n-               self_ty.repr(self.tcx()));\n+               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()).repr(self.tcx()));\n \n         // Object-safety candidates are only applicable to object-safe\n         // traits. Including this check is useful because it helps\n@@ -1222,47 +1237,56 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // self-type from one of the other inputs. Without this check,\n         // these cases wind up being considered ambiguous due to a\n         // (spurious) ambiguity introduced here.\n-        if !object_safety::is_object_safe(self.tcx(), obligation.predicate.to_poly_trait_ref()) {\n+        let predicate_trait_ref = obligation.predicate.to_poly_trait_ref();\n+        if !object_safety::is_object_safe(self.tcx(), predicate_trait_ref.def_id()) {\n             return;\n         }\n \n-        let poly_trait_ref = match self_ty.sty {\n-            ty::ty_trait(ref data) => {\n-                match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n-                    Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n-                        if data.bounds.builtin_bounds.contains(&bound) {\n-                            debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n-                            pushing candidate\");\n-                            candidates.vec.push(BuiltinObjectCandidate);\n-                            return;\n+        self.infcx.try(|snapshot| {\n+            let bound_self_ty =\n+                self.infcx.resolve_type_vars_if_possible(&obligation.self_ty());\n+            let (self_ty, _) =\n+                self.infcx().skolemize_late_bound_regions(&bound_self_ty, snapshot);\n+            let poly_trait_ref = match self_ty.sty {\n+                ty::ty_trait(ref data) => {\n+                    match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n+                        Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n+                            if data.bounds.builtin_bounds.contains(&bound) {\n+                                debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n+                                        pushing candidate\");\n+                                candidates.vec.push(BuiltinObjectCandidate);\n+                                return Ok(());\n+                            }\n                         }\n+                        _ => {}\n                     }\n-                    _ => {}\n+\n+                    data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+                }\n+                ty::ty_infer(ty::TyVar(_)) => {\n+                    debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n+                    candidates.ambiguous = true; // could wind up being an object type\n+                    return Ok(());\n+                }\n+                _ => {\n+                    return Ok(());\n                 }\n+            };\n \n-                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n-            }\n-            ty::ty_infer(ty::TyVar(_)) => {\n-                debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n-                candidates.ambiguous = true; // could wind up being an object type\n-                return;\n-            }\n-            _ => {\n-                return;\n-            }\n-        };\n+            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n+                   poly_trait_ref.repr(self.tcx()));\n \n-        debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n-               poly_trait_ref.repr(self.tcx()));\n+            // see whether the object trait can be upcast to the trait we are looking for\n+            let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n+            if upcast_trait_refs.len() > 1 {\n+                // can be upcast in many ways; need more type information\n+                candidates.ambiguous = true;\n+            } else if upcast_trait_refs.len() == 1 {\n+                candidates.vec.push(ObjectCandidate);\n+            }\n \n-        // see whether the object trait can be upcast to the trait we are looking for\n-        let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n-        if upcast_trait_refs.len() > 1 {\n-            // can be upcast in many ways; need more type information\n-            candidates.ambiguous = true;\n-        } else if upcast_trait_refs.len() == 1 {\n-            candidates.vec.push(ObjectCandidate);\n-        }\n+            Ok::<(),()>(())\n+        }).unwrap();\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1397,23 +1421,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         return match self_ty.sty {\n-            ty::ty_infer(ty::IntVar(_))\n-            | ty::ty_infer(ty::FloatVar(_))\n-            | ty::ty_uint(_)\n-            | ty::ty_int(_)\n-            | ty::ty_bool\n-            | ty::ty_float(_)\n-            | ty::ty_bare_fn(..)\n-            | ty::ty_char => {\n+            ty::ty_infer(ty::IntVar(_)) |\n+            ty::ty_infer(ty::FloatVar(_)) |\n+            ty::ty_uint(_) |\n+            ty::ty_int(_) |\n+            ty::ty_bool |\n+            ty::ty_float(_) |\n+            ty::ty_bare_fn(..) |\n+            ty::ty_char => {\n                 // safe for everything\n-                Ok(If(Vec::new()))\n+                ok_if(Vec::new())\n             }\n \n             ty::ty_uniq(_) => {  // Box<T>\n                 match bound {\n                     ty::BoundCopy => Err(Unimplemented),\n \n-                    ty::BoundSized => Ok(If(Vec::new())),\n+                    ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1423,7 +1447,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::ty_ptr(..) => {     // *const T, *mut T\n                 match bound {\n-                    ty::BoundCopy | ty::BoundSized => Ok(If(Vec::new())),\n+                    ty::BoundCopy | ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1436,7 +1460,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundSized => Err(Unimplemented),\n                     ty::BoundCopy => {\n                         if data.bounds.builtin_bounds.contains(&bound) {\n-                            Ok(If(Vec::new()))\n+                            ok_if(Vec::new())\n                         } else {\n                             // Recursively check all supertraits to find out if any further\n                             // bounds are required and thus we must fulfill.\n@@ -1446,7 +1470,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             let desired_def_id = obligation.predicate.def_id();\n                             for tr in util::supertraits(self.tcx(), principal) {\n                                 if tr.def_id() == desired_def_id {\n-                                    return Ok(If(Vec::new()))\n+                                    return ok_if(Vec::new())\n                                 }\n                             }\n \n@@ -1468,11 +1492,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             ast::MutMutable => Err(Unimplemented),\n \n                             // &T is always copyable\n-                            ast::MutImmutable => Ok(If(Vec::new())),\n+                            ast::MutImmutable => ok_if(Vec::new()),\n                         }\n                     }\n \n-                    ty::BoundSized => Ok(If(Vec::new())),\n+                    ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1486,7 +1510,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => {\n                         match *len {\n                             // [T, ..n] is copy iff T is copy\n-                            Some(_) => Ok(If(vec![element_ty])),\n+                            Some(_) => ok_if(vec![element_ty]),\n \n                             // [T] is unsized and hence affine\n                             None => Err(Unimplemented),\n@@ -1495,7 +1519,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     ty::BoundSized => {\n                         if len.is_some() {\n-                            Ok(If(Vec::new()))\n+                            ok_if(Vec::new())\n                         } else {\n                             Err(Unimplemented)\n                         }\n@@ -1519,7 +1543,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-            ty::ty_tup(ref tys) => Ok(If(tys.clone())),\n+            ty::ty_tup(ref tys) => ok_if(tys.clone()),\n \n             ty::ty_closure(def_id, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n@@ -1544,11 +1568,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // unsized, so the closure struct as a whole must be\n                 // Sized.\n                 if bound == ty::BoundSized {\n-                    return Ok(If(Vec::new()));\n+                    return ok_if(Vec::new());\n                 }\n \n                 match self.closure_typer.closure_upvars(def_id, substs) {\n-                    Some(upvars) => Ok(If(upvars.iter().map(|c| c.ty).collect())),\n+                    Some(upvars) => ok_if(upvars.iter().map(|c| c.ty).collect()),\n                     None => {\n                         debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n                         Ok(AmbiguousBuiltin)\n@@ -1590,7 +1614,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(AmbiguousBuiltin)\n             }\n \n-            ty::ty_err => Ok(If(Vec::new())),\n+            ty::ty_err => ok_if(Vec::new()),\n \n             ty::ty_infer(ty::FreshTy(_))\n             | ty::ty_infer(ty::FreshIntTy(_)) => {\n@@ -1601,6 +1625,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n+        fn ok_if<'tcx>(v: Vec<Ty<'tcx>>)\n+                       -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>> {\n+            Ok(If(ty::Binder(v)))\n+        }\n+\n         fn nominal<'cx, 'tcx>(bound: ty::BuiltinBound,\n                               types: Vec<Ty<'tcx>>)\n                               -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>>\n@@ -1611,7 +1640,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::BoundCopy => Ok(ParameterBuiltin),\n \n                 // Sized if all the component types are sized.\n-                ty::BoundSized => Ok(If(types)),\n+                ty::BoundSized => ok_if(types),\n \n                 // Shouldn't be coming through here.\n                 ty::BoundSend | ty::BoundSync => unreachable!(),\n@@ -1714,8 +1743,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn collect_predicates_for_types(&mut self,\n                                     obligation: &TraitObligation<'tcx>,\n                                     trait_def_id: ast::DefId,\n-                                    types: Vec<Ty<'tcx>>) -> Vec<PredicateObligation<'tcx>> {\n-\n+                                    types: ty::Binder<Vec<Ty<'tcx>>>)\n+                                    -> Vec<PredicateObligation<'tcx>>\n+    {\n         let derived_cause = match self.tcx().lang_items.to_builtin_kind(trait_def_id) {\n             Some(_) => {\n                 self.derived_cause(obligation, BuiltinDerivedObligation)\n@@ -1725,43 +1755,52 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        let normalized = project::normalize_with_depth(self, obligation.cause.clone(),\n-                                                       obligation.recursion_depth + 1,\n-                                                       &types);\n-\n-        let obligations = normalized.value.iter().map(|&nested_ty| {\n-            // the obligation might be higher-ranked, e.g. for<'a> &'a\n-            // int : Copy. In that case, we will wind up with\n-            // late-bound regions in the `nested` vector. So for each\n-            // one we instantiate to a skolemized region, do our work\n-            // to produce something like `&'0 int : Copy`, and then\n-            // re-bind it. This is a bit of busy-work but preserves\n-            // the invariant that we only manipulate free regions, not\n-            // bound ones.\n+        // Because the types were potentially derived from\n+        // higher-ranked obligations they may reference late-bound\n+        // regions. For example, `for<'a> Foo<&'a int> : Copy` would\n+        // yield a type like `for<'a> &'a int`. In general, we\n+        // maintain the invariant that we never manipulate bound\n+        // regions, so we have to process these bound regions somehow.\n+        //\n+        // The strategy is to:\n+        //\n+        // 1. Instantiate those regions to skolemized regions (e.g.,\n+        //    `for<'a> &'a int` becomes `&0 int`.\n+        // 2. Produce something like `&'0 int : Copy`\n+        // 3. Re-bind the regions back to `for<'a> &'a int : Copy`\n+\n+        // Move the binder into the individual types\n+        let bound_types: Vec<ty::Binder<Ty<'tcx>>> =\n+            types.skip_binder()\n+                 .iter()\n+                 .map(|&nested_ty| ty::Binder(nested_ty))\n+                 .collect();\n+\n+        // For each type, produce a vector of resulting obligations\n+        let obligations: Result<Vec<Vec<_>>, _> = bound_types.iter().map(|nested_ty| {\n             self.infcx.try(|snapshot| {\n                 let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&ty::Binder(nested_ty), snapshot);\n-                let skol_predicate =\n-                    util::predicate_for_trait_def(\n-                        self.tcx(),\n-                        derived_cause.clone(),\n-                        trait_def_id,\n-                        obligation.recursion_depth + 1,\n-                        skol_ty);\n-                match skol_predicate {\n-                    Ok(skol_predicate) => Ok(self.infcx().plug_leaks(skol_map, snapshot,\n-                                                                     &skol_predicate)),\n-                    Err(ErrorReported) => Err(ErrorReported)\n-                }\n+                    self.infcx().skolemize_late_bound_regions(nested_ty, snapshot);\n+                let Normalized { value: normalized_ty, mut obligations } =\n+                    project::normalize_with_depth(self,\n+                                                  obligation.cause.clone(),\n+                                                  obligation.recursion_depth + 1,\n+                                                  &skol_ty);\n+                let skol_obligation =\n+                    try!(util::predicate_for_trait_def(self.tcx(),\n+                                                       derived_cause.clone(),\n+                                                       trait_def_id,\n+                                                       obligation.recursion_depth + 1,\n+                                                       normalized_ty));\n+                obligations.push(skol_obligation);\n+                Ok(self.infcx().plug_leaks(skol_map, snapshot, &obligations))\n             })\n-        }).collect::<Result<Vec<PredicateObligation<'tcx>>, _>>();\n+        }).collect();\n \n+        // Flatten those vectors (couldn't do it above due `collect`)\n         match obligations {\n-            Ok(mut obls) => {\n-                obls.push_all(&normalized.obligations);\n-                obls\n-            },\n-            Err(ErrorReported) => Vec::new()\n+            Ok(obligations) => obligations.into_iter().flat_map(|o| o.into_iter()).collect(),\n+            Err(ErrorReported) => Vec::new(),\n         }\n     }\n \n@@ -1798,7 +1837,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             DefaultImplCandidate(trait_def_id) => {\n-                let data = try!(self.confirm_default_impl_candidate(obligation, trait_def_id));\n+                let data = self.confirm_default_impl_candidate(obligation, trait_def_id);\n+                Ok(VtableDefaultImpl(data))\n+            }\n+\n+            DefaultImplObjectCandidate(trait_def_id) => {\n+                let data = self.confirm_default_impl_object_candidate(obligation, trait_def_id);\n                 Ok(VtableDefaultImpl(data))\n             }\n \n@@ -1900,7 +1944,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn vtable_builtin_data(&mut self,\n                            obligation: &TraitObligation<'tcx>,\n                            bound: ty::BuiltinBound,\n-                           nested: Vec<Ty<'tcx>>)\n+                           nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n         let trait_def = match self.tcx().lang_items.from_builtin_kind(bound) {\n@@ -1927,17 +1971,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.\n     fn confirm_default_impl_candidate(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      impl_def_id: ast::DefId)\n-                              -> Result<VtableDefaultImplData<PredicateObligation<'tcx>>,\n-                                        SelectionError<'tcx>>\n+                                      trait_def_id: ast::DefId)\n+                                      -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_default_impl_candidate({}, {})\",\n                obligation.repr(self.tcx()),\n-               impl_def_id.repr(self.tcx()));\n+               trait_def_id.repr(self.tcx()));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n+        // binder is moved below\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n         match self.constituent_types_for_ty(self_ty) {\n-            Some(types) => Ok(self.vtable_default_impl(obligation, impl_def_id, types)),\n+            Some(types) => self.vtable_default_impl(obligation, trait_def_id, ty::Binder(types)),\n             None => {\n                 self.tcx().sess.bug(\n                     &format!(\n@@ -1947,33 +1991,72 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn confirm_default_impl_object_candidate(&mut self,\n+                                             obligation: &TraitObligation<'tcx>,\n+                                             trait_def_id: ast::DefId)\n+                                             -> VtableDefaultImplData<PredicateObligation<'tcx>>\n+    {\n+        debug!(\"confirm_default_impl_object_candidate({}, {})\",\n+               obligation.repr(self.tcx()),\n+               trait_def_id.repr(self.tcx()));\n+\n+        assert!(ty::has_attr(self.tcx(), trait_def_id, \"rustc_reflect_like\"));\n+\n+        // OK to skip binder, it is reintroduced below\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n+        match self_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                // OK to skip the binder, it is reintroduced below\n+                let input_types = data.principal.skip_binder().substs.types.get_slice(TypeSpace);\n+                let assoc_types = data.bounds.projection_bounds\n+                                             .iter()\n+                                             .map(|pb| pb.skip_binder().ty);\n+                let all_types: Vec<_> = input_types.iter().cloned()\n+                                                          .chain(assoc_types)\n+                                                          .collect();\n+\n+                // reintroduce the two binding levels we skipped, then flatten into one\n+                let all_types = ty::Binder(ty::Binder(all_types));\n+                let all_types = ty::flatten_late_bound_regions(self.tcx(), &all_types);\n+\n+                self.vtable_default_impl(obligation, trait_def_id, all_types)\n+            }\n+            _ => {\n+                self.tcx().sess.bug(\n+                    &format!(\n+                        \"asked to confirm default object implementation for non-object type: {}\",\n+                        self_ty.repr(self.tcx())));\n+            }\n+        }\n+    }\n+\n     /// See `confirm_default_impl_candidate`\n     fn vtable_default_impl(&mut self,\n                            obligation: &TraitObligation<'tcx>,\n                            trait_def_id: ast::DefId,\n-                           nested: Vec<Ty<'tcx>>)\n+                           nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n+        debug!(\"vtable_default_impl_data: nested={}\", nested.repr(self.tcx()));\n \n         let mut obligations = self.collect_predicates_for_types(obligation,\n                                                                 trait_def_id,\n                                                                 nested);\n \n-        let _: Result<(),()> = self.infcx.try(|snapshot| {\n-            let (_, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n-\n-            let substs = obligation.predicate.to_poly_trait_ref().substs();\n-            let trait_obligations = self.impl_or_trait_obligations(obligation.cause.clone(),\n-                                                                   obligation.recursion_depth + 1,\n-                                                                   trait_def_id,\n-                                                                   substs,\n-                                                                   skol_map,\n-                                                                   snapshot);\n-            obligations.push_all(trait_obligations.as_slice());\n-            Ok(())\n+        let trait_obligations: Result<VecPerParamSpace<_>,()> = self.infcx.try(|snapshot| {\n+            let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+            let (trait_ref, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n+            Ok(self.impl_or_trait_obligations(obligation.cause.clone(),\n+                                              obligation.recursion_depth + 1,\n+                                              trait_def_id,\n+                                              &trait_ref.substs,\n+                                              skol_map,\n+                                              snapshot))\n         });\n \n+        obligations.extend(trait_obligations.unwrap().into_iter()); // no Errors in that code above\n+\n         debug!(\"vtable_default_impl_data: obligations={}\", obligations.repr(self.tcx()));\n \n         VtableDefaultImplData {\n@@ -2047,7 +2130,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_object_candidate({})\",\n                obligation.repr(self.tcx()));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // FIXME skipping binder here seems wrong -- we should\n+        // probably flatten the binder from the obligation and the\n+        // binder from the object. Have to try to make a broken test\n+        // case that results. -nmatsakis\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n             ty::ty_trait(ref data) => {\n                 data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n@@ -2085,15 +2172,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_fn_pointer_candidate({})\",\n                obligation.repr(self.tcx()));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // ok to skip binder; it is reintroduced below\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = ty::ty_fn_sig(self_ty);\n-        let ty::Binder((trait_ref, _)) =\n+        let trait_ref =\n             util::closure_trait_ref_and_return_type(self.tcx(),\n                                                     obligation.predicate.def_id(),\n                                                     self_ty,\n                                                     sig,\n-                                                    util::TupleArgumentsFlag::Yes);\n-        let trait_ref = ty::Binder(trait_ref);\n+                                                    util::TupleArgumentsFlag::Yes)\n+            .map_bound(|(trait_ref, _)| trait_ref);\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n@@ -2448,6 +2536,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  snapshot: &infer::CombinedSnapshot)\n                                  -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n+        debug!(\"impl_or_trait_obligations(def_id={})\", def_id.repr(self.tcx()));\n+\n         let predicates = ty::lookup_predicates(self.tcx(), def_id);\n         let predicates = predicates.instantiate(self.tcx(), substs);\n         let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);\n@@ -2530,6 +2620,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n             DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n+            DefaultImplObjectCandidate(t) => format!(\"DefaultImplObjectCandidate({:?})\", t),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n             FnPointerCandidate => format!(\"FnPointerCandidate\"),\n             ObjectCandidate => format!(\"ObjectCandidate\"),"}, {"sha": "06b687bd92b9e2a6eea49ffdc78e033b1a0109af", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -209,6 +209,47 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Iterator over def-ids of supertraits\n+\n+pub struct SupertraitDefIds<'cx, 'tcx:'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    stack: Vec<ast::DefId>,\n+    visited: FnvHashSet<ast::DefId>,\n+}\n+\n+pub fn supertrait_def_ids<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                                     trait_def_id: ast::DefId)\n+                                     -> SupertraitDefIds<'cx, 'tcx>\n+{\n+    SupertraitDefIds {\n+        tcx: tcx,\n+        stack: vec![trait_def_id],\n+        visited: Some(trait_def_id).into_iter().collect(),\n+    }\n+}\n+\n+impl<'cx, 'tcx> Iterator for SupertraitDefIds<'cx, 'tcx> {\n+    type Item = ast::DefId;\n+\n+    fn next(&mut self) -> Option<ast::DefId> {\n+        let def_id = match self.stack.pop() {\n+            Some(def_id) => def_id,\n+            None => { return None; }\n+        };\n+\n+        let predicates = ty::lookup_super_predicates(self.tcx, def_id);\n+        let visited = &mut self.visited;\n+        self.stack.extend(\n+            predicates.predicates\n+                      .iter()\n+                      .filter_map(|p| p.to_opt_poly_trait_ref())\n+                      .map(|t| t.def_id())\n+                      .filter(|&super_def_id| visited.insert(super_def_id)));\n+        Some(def_id)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "01e13887462b1235c102d1a21a5b484cc4193f6c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -1108,16 +1108,16 @@ pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n     pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n-        ty::Binder(self.0.inputs.clone())\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs.clone())\n     }\n     pub fn input(&self, index: uint) -> ty::Binder<Ty<'tcx>> {\n-        ty::Binder(self.0.inputs[index])\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs[index])\n     }\n     pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n-        ty::Binder(self.0.output.clone())\n+        self.map_bound_ref(|fn_sig| fn_sig.output.clone())\n     }\n     pub fn variadic(&self) -> bool {\n-        self.0.variadic\n+        self.skip_binder().variadic\n     }\n }\n \n@@ -1519,6 +1519,22 @@ impl<T> Binder<T> {\n     pub fn skip_binder(&self) -> &T {\n         &self.0\n     }\n+\n+    pub fn as_ref(&self) -> Binder<&T> {\n+        ty::Binder(&self.0)\n+    }\n+\n+    pub fn map_bound_ref<F,U>(&self, f: F) -> Binder<U>\n+        where F: FnOnce(&T) -> U\n+    {\n+        self.as_ref().map_bound(f)\n+    }\n+\n+    pub fn map_bound<F,U>(self, f: F) -> Binder<U>\n+        where F: FnOnce(T) -> U\n+    {\n+        ty::Binder(f(self.0))\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -2062,8 +2078,7 @@ impl<'tcx> ToPolyTraitRef<'tcx> for Rc<TraitRef<'tcx>> {\n \n impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n-        // We are just preserving the binder levels here\n-        ty::Binder(self.0.trait_ref.clone())\n+        self.map_bound_ref(|trait_pred| trait_pred.trait_ref.clone())\n     }\n }\n \n@@ -6753,6 +6768,30 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     count_late_bound_regions(tcx, value) > 0\n }\n \n+/// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n+/// becomes `for<'a,'b> Foo`.\n+pub fn flatten_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    bound2_value: &Binder<Binder<T>>)\n+    -> Binder<T>\n+    where T: TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    let bound0_value = bound2_value.skip_binder().skip_binder();\n+    let value = ty_fold::fold_regions(tcx, bound0_value, |region, current_depth| {\n+        match region {\n+            ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n+                // should be true if no escaping regions from bound2_value\n+                assert!(debruijn.depth - current_depth <= 1);\n+                ty::ReLateBound(DebruijnIndex::new(current_depth), br)\n+            }\n+            _ => {\n+                region\n+            }\n+        }\n+    });\n+    Binder(value)\n+}\n+\n pub fn no_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n@@ -7089,6 +7128,12 @@ impl<'tcx> RegionEscape for Predicate<'tcx> {\n     }\n }\n \n+impl<'tcx,P:RegionEscape> RegionEscape for traits::Obligation<'tcx,P> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.predicate.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<'tcx> RegionEscape for TraitRef<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) ||"}, {"sha": "67461ff561bb8beb529a74f4ba1a6a876c091113", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -28,18 +28,17 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TyTrait<'tcx>,\n                                  span: Span)\n {\n-    let object_trait_ref =\n-        object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n+    let trait_def_id = object_trait.principal_def_id();\n \n-    if traits::is_object_safe(tcx, object_trait_ref.clone()) {\n+    if traits::is_object_safe(tcx, trait_def_id) {\n         return;\n     }\n \n     span_err!(tcx.sess, span, E0038,\n               \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-              ty::item_path_str(tcx, object_trait_ref.def_id()));\n+              ty::item_path_str(tcx, trait_def_id));\n \n-    let violations = traits::object_safety_violations(tcx, object_trait_ref.clone());\n+    let violations = traits::object_safety_violations(tcx, trait_def_id);\n     for violation in violations {\n         match violation {\n             ObjectSafetyViolation::SizedSelf => {"}, {"sha": "3a716b28e73a711696a28cea07517b09dd385668", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -1059,14 +1059,29 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n \n                 ty::Predicate::Equate(ty::Binder(ref data)) => {\n-                    self.add_constraints_from_ty(generics, data.0, variance);\n-                    self.add_constraints_from_ty(generics, data.1, variance);\n+                    // A == B is only true if A and B are the same\n+                    // types, not subtypes of one another, so this is\n+                    // an invariant position:\n+                    self.add_constraints_from_ty(generics, data.0, self.invariant);\n+                    self.add_constraints_from_ty(generics, data.1, self.invariant);\n                 }\n \n                 ty::Predicate::TypeOutlives(ty::Binder(ref data)) => {\n-                    self.add_constraints_from_ty(generics, data.0, variance);\n+                    // Why contravariant on both? Let's consider:\n+                    //\n+                    // Under what conditions is `(T:'t) <: (U:'u)`,\n+                    // meaning that `(T:'t) => (U:'u)`. The answer is\n+                    // if `U <: T` or `'u <= 't`. Let's see some examples:\n+                    //\n+                    //   (T: 'big) => (T: 'small)\n+                    //   where 'small <= 'big\n+                    //\n+                    //   (&'small Foo: 't) => (&'big Foo: 't)\n+                    //   where 'small <= 'big\n+                    //   note that &'big Foo <: &'small Foo\n \n                     let variance_r = self.xform(variance, self.contravariant);\n+                    self.add_constraints_from_ty(generics, data.0, variance_r);\n                     self.add_constraints_from_region(generics, data.1, variance_r);\n                 }\n \n@@ -1084,6 +1099,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                                         &*data.projection_ty.trait_ref,\n                                                         variance);\n \n+                    // as the equality predicate above, a binder is a\n+                    // type equality relation, not a subtyping\n+                    // relation\n                     self.add_constraints_from_ty(generics, data.ty, self.invariant);\n                 }\n             }"}, {"sha": "46115ae468ff916aebf8f38d4a95d472f633e3b7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -74,6 +74,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n \n     (\"rustc_diagnostic_macros\", \"1.0.0\", Active),\n     (\"unboxed_closures\", \"1.0.0\", Active),\n+    (\"reflect\", \"1.0.0\", Active),\n     (\"import_shadowing\", \"1.0.0\", Removed),\n     (\"advanced_slice_patterns\", \"1.0.0\", Active),\n     (\"tuple_indexing\", \"1.0.0\", Accepted),\n@@ -281,7 +282,11 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     // FIXME: #19470 this shouldn't be needed forever\n     (\"old_orphan_check\", Whitelisted),\n     (\"old_impl_check\", Whitelisted),\n-    (\"rustc_paren_sugar\", Whitelisted), // FIXME: #18101 temporary unboxed closure hack\n+\n+    (\"rustc_paren_sugar\", Gated(\"unboxed_closures\",\n+                                \"unboxed_closures are still evolving\")),\n+    (\"rustc_reflect_like\", Gated(\"reflect\",\n+                                 \"defining reflective traits is still evolving\")),\n \n     // Crate level attributes\n     (\"crate_name\", CrateLevel),"}, {"sha": "bd47054f093ce71ebe0d1ba5c7a3cd41d0a99f9c", "filename": "src/test/auxiliary/typeid-intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(core)]\n \n-use std::any::TypeId;\n+use std::any::{Any, TypeId};\n \n pub struct A;\n pub struct B(Option<A>);\n@@ -31,4 +31,4 @@ pub unsafe fn id_F() -> TypeId { TypeId::of::<F>() }\n pub unsafe fn id_G() -> TypeId { TypeId::of::<G>() }\n pub unsafe fn id_H() -> TypeId { TypeId::of::<H>() }\n \n-pub unsafe fn foo<T: 'static>() -> TypeId { TypeId::of::<T>() }\n+pub unsafe fn foo<T: Any>() -> TypeId { TypeId::of::<T>() }"}, {"sha": "5e81bf50ae449f0f9f3d48de057741c132b25746", "filename": "src/test/auxiliary/typeid-intrinsic2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(core)]\n \n-use std::any::TypeId;\n+use std::any::{Any, TypeId};\n \n pub struct A;\n pub struct B(Option<A>);\n@@ -31,4 +31,4 @@ pub unsafe fn id_F() -> TypeId { TypeId::of::<F>() }\n pub unsafe fn id_G() -> TypeId { TypeId::of::<G>() }\n pub unsafe fn id_H() -> TypeId { TypeId::of::<H>() }\n \n-pub unsafe fn foo<T: 'static>() -> TypeId { TypeId::of::<T>() }\n+pub unsafe fn foo<T:Any>() -> TypeId { TypeId::of::<T>() }"}, {"sha": "9cf0d252c2d55ce2d7af9471ef6d0b3f1c09b8e2", "filename": "src/test/compile-fail/reflect-assoc.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fcompile-fail%2Freflect-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fcompile-fail%2Freflect-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freflect-assoc.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that types that appear in assoc bindings in an object\n+// type are subject to the reflect check.\n+\n+use std::marker::Reflect;\n+use std::io::Write;\n+\n+trait Get {\n+    type Output;\n+    fn get(self) -> Self::Output;\n+}\n+\n+struct Struct<T>(T);\n+\n+fn is_reflect<T:Reflect>() { }\n+\n+fn a<T>() {\n+    is_reflect::<Box<Get<Output=T>>>(); //~ ERROR not implemented\n+}\n+\n+fn ok_a<T: Reflect>() {\n+    is_reflect::<Box<Get<Output=T>>>(); // OK\n+}\n+\n+fn main() {\n+}"}, {"sha": "9f074667feb3dc67a80d60340c6556728fb06ec0", "filename": "src/test/compile-fail/reflect-object-param.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fcompile-fail%2Freflect-object-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fcompile-fail%2Freflect-object-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freflect-object-param.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that types that appear in input types in an object type are\n+// subject to the reflect check.\n+\n+use std::marker::Reflect;\n+use std::io::Write;\n+\n+trait Get<T> {\n+    fn get(self) -> T;\n+}\n+\n+struct Struct<T>(T);\n+\n+fn is_reflect<T:Reflect>() { }\n+\n+fn a<T>() {\n+    is_reflect::<T>(); //~ ERROR not implemented\n+}\n+\n+fn ok_a<T: Reflect>() {\n+    is_reflect::<T>(); // OK\n+}\n+\n+fn b<T>() {\n+    is_reflect::<Box<Get<T>>>(); //~ ERROR not implemented\n+}\n+\n+fn ok_b<T: Reflect>() {\n+    is_reflect::<Box<Get<T>>>(); // OK\n+}\n+\n+fn c<T>() {\n+    is_reflect::<Box<Get<Struct<T>>>>(); //~ ERROR not implemented\n+}\n+\n+fn main() {\n+    is_reflect::<Box<Get<Struct<()>>>>(); // OK\n+}"}, {"sha": "701aa5b40bc0a6314b50e04b28a6975c9a95280a", "filename": "src/test/compile-fail/reflect.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fcompile-fail%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fcompile-fail%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freflect.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that there is no way to get a generic type `T` to be\n+// considered as `Reflect` (or accessible via something that is\n+// considered `Reflect`) without a reflect bound, but that any\n+// concrete type works fine. Note that object types are tested\n+// separately.\n+\n+use std::marker::Reflect;\n+use std::io::Write;\n+\n+struct Struct<T>(T);\n+\n+fn is_reflect<T:Reflect>() { }\n+\n+fn c<T>() {\n+    is_reflect::<Struct<T>>(); //~ ERROR not implemented\n+}\n+\n+fn ok_c<T: Reflect>() {\n+    is_reflect::<Struct<T>>(); // OK\n+}\n+\n+fn d<T>() {\n+    is_reflect::<(i32, T)>(); //~ ERROR not implemented\n+}\n+\n+fn main() {\n+    is_reflect::<&i32>(); // OK\n+    is_reflect::<Box<Write>>(); // OK\n+}"}, {"sha": "96ae201f6ae94fb771b014b6384b67715ed8567f", "filename": "src/test/compile-fail/variance-region-bounds.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that `T:'a` is contravariant in T.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_variance]\n+trait Foo: 'static { //~ ERROR types=[[];[-];[]]\n+}\n+\n+#[rustc_variance]\n+trait Bar<T> { //~ ERROR types=[[+];[-];[]]\n+    fn do_it(&self)\n+        where T: 'static;\n+}\n+\n+fn main() { }"}, {"sha": "f4e056b3f21b1d68f9c15faa04ee73f07756541e", "filename": "src/test/run-pass/object-one-type-two-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Frun-pass%2Fobject-one-type-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Frun-pass%2Fobject-one-type-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-one-type-two-traits.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -30,7 +30,7 @@ impl Wrap for int {\n     }\n }\n \n-fn is<T:'static>(x: &Any) -> bool {\n+fn is<T:Any>(x: &Any) -> bool {\n     x.is::<T>()\n }\n "}, {"sha": "a40989d4e37fedc31a939414c17cec2b1816d1cc", "filename": "src/test/run-pass/type-id-higher-rank.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6166b74988d7d5201152ae4e142f04a3d3a0e5b/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs?ref=e6166b74988d7d5201152ae4e142f04a3d3a0e5b", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(unboxed_closures, core)]\n \n-use std::any::TypeId;\n+use std::any::{Any, TypeId};\n \n fn main() {\n     // Bare fns\n@@ -63,7 +63,7 @@ fn main() {\n         assert!(a != b);\n     }\n \n-    fn id<T:'static>(_: T) -> TypeId {\n+    fn id<T:Any>(_: T) -> TypeId {\n         TypeId::of::<T>()\n     }\n }"}]}