{"sha": "c56a38ac2aad69f9d58670da88e6d5c0c6bb5c74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NmEzOGFjMmFhZDY5ZjlkNTg2NzBkYTg4ZTZkNWMwYzZiYjVjNzQ=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-12T19:51:47Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-13T01:16:00Z"}, "message": "Added a version of msgsend that uses pipes and select. Here, select is way too slow to be useful, but this can be optimized.", "tree": {"sha": "3222841299cfdaa2a8ee7aff5e6426e262e22b72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3222841299cfdaa2a8ee7aff5e6426e262e22b72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c56a38ac2aad69f9d58670da88e6d5c0c6bb5c74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c56a38ac2aad69f9d58670da88e6d5c0c6bb5c74", "html_url": "https://github.com/rust-lang/rust/commit/c56a38ac2aad69f9d58670da88e6d5c0c6bb5c74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c56a38ac2aad69f9d58670da88e6d5c0c6bb5c74/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deb6476b2921bde505125042b1624efe05e7c3ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/deb6476b2921bde505125042b1624efe05e7c3ff", "html_url": "https://github.com/rust-lang/rust/commit/deb6476b2921bde505125042b1624efe05e7c3ff"}], "stats": {"total": 165, "additions": 165, "deletions": 0}, "files": [{"sha": "bbe892f50e8090571d40232562e95f096323278b", "filename": "src/test/bench/msgsend-pipes.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/c56a38ac2aad69f9d58670da88e6d5c0c6bb5c74/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56a38ac2aad69f9d58670da88e6d5c0c6bb5c74/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=c56a38ac2aad69f9d58670da88e6d5c0c6bb5c74", "patch": "@@ -0,0 +1,165 @@\n+// A port of the simplistic benchmark from\n+//\n+//    http://github.com/PaulKeeble/ScalaVErlangAgents\n+//\n+// I *think* it's the same, more or less.\n+\n+use std;\n+import io::writer;\n+import io::writer_util;\n+\n+import pipes::{port, chan};\n+\n+macro_rules! move {\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n+}\n+\n+enum request {\n+    get_count,\n+    bytes(uint),\n+    stop\n+}\n+\n+fn server(requests: port_set<request>, responses: pipes::chan<uint>) {\n+    let mut count = 0u;\n+    let mut done = false;\n+    while !done {\n+        alt requests.try_recv() {\n+          some(get_count) { responses.send(copy count); }\n+          some(bytes(b)) {\n+            //#error(\"server: received %? bytes\", b);\n+            count += b;\n+          }\n+          none { done = true; }\n+          _ { }\n+        }\n+    }\n+    responses.send(count);\n+    //#error(\"server exiting\");\n+}\n+\n+fn run(args: &[str]) {\n+    let (to_parent, from_child) = pipes::stream();\n+    let (to_child, from_parent_) = pipes::stream();\n+    let from_parent = port_set();\n+    from_parent.add(from_parent_);\n+\n+    let size = option::get(uint::from_str(args[1]));\n+    let workers = option::get(uint::from_str(args[2]));\n+    let num_bytes = 100;\n+    let start = std::time::precise_time_s();\n+    let mut worker_results = ~[];\n+    for uint::range(0u, workers) |i| {\n+        let builder = task::builder();\n+        vec::push(worker_results, task::future_result(builder));\n+        let (to_child, from_parent_) = pipes::stream();\n+        from_parent.add(from_parent_);\n+        do task::run(builder) {\n+            for uint::range(0u, size / workers) |_i| {\n+                //#error(\"worker %?: sending %? bytes\", i, num_bytes);\n+                to_child.send(bytes(num_bytes));\n+            }\n+            //#error(\"worker %? exiting\", i);\n+        };\n+    }\n+    do task::spawn {\n+        server(from_parent, to_parent);\n+    }\n+\n+    vec::iter(worker_results, |r| { future::get(r); } );\n+    //#error(\"sending stop message\");\n+    to_child.send(stop);\n+    move!{to_child};\n+    let result = from_child.recv();\n+    let end = std::time::precise_time_s();\n+    let elapsed = end - start;\n+    io::stdout().write_str(#fmt(\"Count is %?\\n\", result));\n+    io::stdout().write_str(#fmt(\"Test took %? seconds\\n\", elapsed));\n+    let thruput = ((size / workers * workers) as float) / (elapsed as float);\n+    io::stdout().write_str(#fmt(\"Throughput=%f per sec\\n\", thruput));\n+    assert result == num_bytes * size;\n+}\n+\n+fn main(args: ~[str]) {\n+    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+        ~[\"\", \"1000000\", \"10000\"]\n+    } else if args.len() <= 1u {\n+        ~[\"\", \"10000\", \"4\"]\n+    } else {\n+        copy args\n+    };        \n+\n+    #debug(\"%?\", args);\n+    run(args);\n+}\n+\n+// Treat a whole bunch of ports as one.\n+class box<T> {\n+    let mut contents: option<T>;\n+    new(+x: T) { self.contents = some(x); }\n+\n+    fn swap(f: fn(+T) -> T) {\n+        let mut tmp = none;\n+        self.contents <-> tmp;\n+        self.contents = some(f(option::unwrap(tmp)));\n+    }\n+\n+    fn unwrap() -> T {\n+        let mut tmp = none;\n+        self.contents <-> tmp;\n+        option::unwrap(tmp)\n+    }\n+}\n+\n+class port_set<T: send> {\n+    let ports: box<~[pipes::streamp::server::open<T>]>;\n+\n+    new() { self.ports = box(~[]); }\n+\n+    fn add(+port: pipes::port<T>) {\n+        let pipes::port_(port) <- port;\n+        let mut p = none;\n+        port.endp <-> p;\n+        do self.ports.swap |ports| {\n+            let mut p_ = none;\n+            p <-> p_;\n+            vec::append_one(ports, option::unwrap(p_))\n+        }\n+    }\n+\n+    fn try_recv() -> option<T> {\n+        let mut result = none;\n+        let mut done = false;\n+        while !done {\n+            do self.ports.swap |ports| {\n+                if ports.len() > 0 {\n+                    let old_len = ports.len();\n+                    let (_, m, ports) = pipes::select(ports);\n+                    alt m {\n+                      some(pipes::streamp::data(x, next)) {\n+                        result = some(move!{x});\n+                        done = true;\n+                        assert ports.len() == old_len - 1;\n+                        vec::append_one(ports, move!{next})\n+                      }\n+                      none {\n+                        //#error(\"pipe closed\");\n+                        assert ports.len() == old_len - 1;\n+                        ports\n+                      }\n+                    }\n+                }\n+                else {\n+                    //#error(\"no more pipes\");\n+                    done = true;\n+                    ~[]\n+                }\n+            }\n+        }\n+        result\n+    }\n+\n+    fn recv() -> T {\n+        option::unwrap(self.try_recv())\n+    }\n+}"}]}