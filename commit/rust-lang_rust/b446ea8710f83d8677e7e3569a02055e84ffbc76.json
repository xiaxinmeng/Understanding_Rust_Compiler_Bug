{"sha": "b446ea8710f83d8677e7e3569a02055e84ffbc76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NDZlYTg3MTBmODNkODY3N2U3ZTM1NjlhMDIwNTVlODRmZmJjNzY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-02T02:20:43Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-02T07:14:25Z"}, "message": "tutorial: Some work on closures", "tree": {"sha": "a38956f3418b9a03413e7445d15e4eb7aa334a12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a38956f3418b9a03413e7445d15e4eb7aa334a12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b446ea8710f83d8677e7e3569a02055e84ffbc76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b446ea8710f83d8677e7e3569a02055e84ffbc76", "html_url": "https://github.com/rust-lang/rust/commit/b446ea8710f83d8677e7e3569a02055e84ffbc76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b446ea8710f83d8677e7e3569a02055e84ffbc76/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "129de960236bb71bd55b744d3ee2c03539e0bb7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/129de960236bb71bd55b744d3ee2c03539e0bb7c", "html_url": "https://github.com/rust-lang/rust/commit/129de960236bb71bd55b744d3ee2c03539e0bb7c"}], "stats": {"total": 100, "additions": 63, "deletions": 37}, "files": [{"sha": "900180c5eb5e3d8b9b5afee7377319a27d249d59", "filename": "doc/lib/codemirror-rust.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b446ea8710f83d8677e7e3569a02055e84ffbc76/doc%2Flib%2Fcodemirror-rust.js", "raw_url": "https://github.com/rust-lang/rust/raw/b446ea8710f83d8677e7e3569a02055e84ffbc76/doc%2Flib%2Fcodemirror-rust.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Flib%2Fcodemirror-rust.js?ref=b446ea8710f83d8677e7e3569a02055e84ffbc76", "patch": "@@ -1,7 +1,7 @@\n CodeMirror.defineMode(\"rust\", function() {\n   var indentUnit = 4, altIndentUnit = 2;\n   var valKeywords = {\n-    \"if\": \"if-style\", \"while\": \"if-style\", \"else\": \"else-style\",\n+    \"if\": \"if-style\", \"while\": \"if-style\", \"loop\": \"if-style\", \"else\": \"else-style\",\n     \"do\": \"else-style\", \"ret\": \"else-style\", \"fail\": \"else-style\",\n     \"break\": \"atom\", \"cont\": \"atom\", \"const\": \"let\", \"resource\": \"fn\",\n     \"let\": \"let\", \"fn\": \"fn\", \"for\": \"for\", \"alt\": \"alt\", \"iface\": \"iface\","}, {"sha": "8096f67cafc8585161e7cada7366fefca69924ff", "filename": "doc/tutorial.md", "status": "modified", "additions": 62, "deletions": 36, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b446ea8710f83d8677e7e3569a02055e84ffbc76/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b446ea8710f83d8677e7e3569a02055e84ffbc76/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=b446ea8710f83d8677e7e3569a02055e84ffbc76", "patch": "@@ -75,7 +75,7 @@ builds require that:\n   * You can at least execute snapshot binaries of one of the forms we\n     offer them in. Currently we build and test snapshots on:\n     * Windows (7, server 2008 r2) x86 only\n-    * Linux 2.6.x (various distributions) x86 and x86-64\n+    * Linux (various distributions) x86 and x86-64\n     * OSX 10.6 (\"Snow leopard\") or 10.7 (\"Lion\") x86 and x86-64\n \n You may find other platforms work, but these are our \"tier 1\" supported\n@@ -97,9 +97,9 @@ Windows requires some extra steps: please see the\n [getting started][wiki-get-started] page on the Rust wiki.\n \n ~~~~ {.notrust}\n-$ wget http://dl.rust-lang.org/dist/rust-0.1.tar.gz\n-$ tar -xzf rust-0.1.tar.gz\n-$ cd rust-0.1\n+$ wget http://dl.rust-lang.org/dist/rust-0.3.tar.gz\n+$ tar -xzf rust-0.3.tar.gz\n+$ cd rust-0.3\n $ ./configure\n $ make && make install\n ~~~~\n@@ -535,16 +535,12 @@ information that can serve a variety of purposes. One of those is\n conditional compilation:\n \n ~~~~\n-#[cfg(target_os = \"win32\")]\n+#[cfg(windows)]\n fn register_win_service() { /* ... */ }\n ~~~~\n \n This will cause the function to vanish without a trace during\n-compilation on a non-Windows platform, much like `#ifdef` in C (it\n-allows `cfg(flag=value)` and `cfg(flag)` forms, where the second\n-simply checks whether the configuration flag is defined at all). Flags\n-for `target_os` and `target_arch` are set by the compiler. It is\n-possible to set additional flags with the `--cfg` command-line option.\n+compilation on a non-Windows platform, much like `#ifdef` in C.\n \n Attributes are always wrapped in hash-braces (`#[attr]`). Inside the\n braces, a small minilanguage is supported, whose interpretation\n@@ -554,8 +550,8 @@ framework](#testing)). A name-value pair can be provided using an `=`\n character followed by a literal (as in `#[license = \"BSD\"]`, which is\n a valid way to annotate a Rust program as being released under a\n BSD-style license). Finally, you can have a name followed by a\n-comma-separated list of nested attributes, as in the `cfg` example\n-above, or in this [crate](#modules-and-crates) metadata declaration:\n+comma-separated list of nested attributes, as in this\n+[crate](#modules-and-crates) metadata declaration:\n \n ~~~~ {.ignore}\n #[link(name = \"std\",\n@@ -593,6 +589,7 @@ compile-time.\n ~~~~\n io::println(#env(\"PATH\"));\n ~~~~\n+\n # Control structures\n \n ## Conditionals\n@@ -723,7 +720,7 @@ while cake_amount > 0 {\n \n ~~~~\n let mut x = 5;\n-while true {\n+loop {\n     x += x - 3;\n     if x % 5 == 0 { break; }\n     io::println(int::str(x));\n@@ -795,7 +792,9 @@ their arguments are also lazily evaluated.\n The keyword `assert`, followed by an expression with boolean type,\n will check that the given expression results in `true`, and cause a\n failure otherwise. It is typically used to double-check things that\n-*should* hold at a certain point in a program.\n+*should* hold at a certain point in a program. `assert` statements are\n+always active; there is no way to build Rust code with assertions\n+disabled.\n \n ~~~~\n let mut x = 100;\n@@ -805,7 +804,7 @@ assert x == 10;\n \n # Functions\n \n-Functions (like all other static declarations, such as `type`) can be\n+Like all other static declarations, such as `type`, functions can be\n declared both at the top level and inside other functions (or modules,\n which we'll come back to in moment).\n \n@@ -838,34 +837,60 @@ let dir = if can_go_left() { left }\n \n ## Closures\n \n-Named functions, like those in the previous section, do not close over\n-their environment. Rust also includes support for closures, which are\n-functions that can access variables in the scope in which they are\n-created.\n+Named functions, like those in the previous section, may not refer\n+to local variables decalared outside the function - they do not\n+close over their environment. For example you couldn't write the\n+following:\n+\n+~~~~ {.ignore}\n+let foo = 10;\n+\n+fn bar() -> int {\n+   ret foo; // `bar` cannot refer to `foo`\n+}\n+~~~~\n \n-There are several forms of closures, each with its own role. The most\n-common type is called a 'stack closure'; this is a closure which has\n-full access to its environment.\n+Rust also supports _closures_, functions that can\n+access variables in the enclosing scope.\n \n ~~~~\n fn call_closure_with_ten(b: fn(int)) { b(10); }\n \n-let x = 20;    \n-call_closure_with_ten(|arg| #info(\"x=%d, arg=%d\", x, arg) );\n+let x = 20;\n+let closure = |arg| #info(\"x=%d, arg=%d\", x, arg);\n+\n+call_closure_with_ten(closure);\n+~~~~\n+\n+A closure is defined by listing the arguments, between bars, followed\n+by an expression that acts as the function body. The types of the\n+arguments are generally omitted, as is the return type, because\n+the compiler can almost always infer them. In the rare case where\n+the compiler needs assistance though, the arguments and return\n+types may be annotated.\n+\n+~~~~\n+# type mygoodness = fn(str) -> str; type what_the = int;\n+let bloop = |well, oh: mygoodness| -> what_the { fail oh(well) };\n+~~~~\n+\n+There are several forms of closure, each with its own role. The most\n+common, called a _stack closure_ and written `&fn()` has direct access\n+to local variables in the enclosing scope.\n+\n+~~~~\n+let mut max = 0;\n+[1, 2, 3].map(|x| if x > max { max = x });\n ~~~~\n \n-This defines a function that accepts a closure, and then calls it with\n-a simple stack closure that executes a log statement, accessing both\n-its argument and the variable `x` from its environment.\n+Stack closures are very efficient because their environment is\n+allocated on the call stack and refers by pointer to captured\n+locals. To ensure that stack closures never outlive the local\n+variables to which they refer, they can only be used in argument\n+position and cannot be stored in structures nor returned from\n+functions.  Despite the usage limitations stack closures are used\n+pervasively in Rust code.\n \n-Stack closures are called stack closures because they directly access\n-the stack frame in which they are created.  This makes them very\n-lightweight to construct and lets them modify local variables from the\n-enclosing scope, but it also makes it unsafe for the closure to\n-survive the scope in which it was created.  To prevent them from being\n-used after the creating scope has returned, stack closures can only be\n-used in a restricted way: they are allowed to appear in function\n-argument position and in call position, but nowhere else.\n \n ### Boxed closures\n \n@@ -908,7 +933,8 @@ that callers have the flexibility to pass whatever they want.\n \n ~~~~\n fn call_twice(f: fn()) { f(); f(); }\n-call_twice(|| { \"I am a stack closure\"; } );\n+call_twice(|| { \"I am an inferred stack closure\"; } );\n+call_twice(fn&() { \"I am also a stack closure\"; } );\n call_twice(fn@() { \"I am a boxed closure\"; });\n fn bare_function() { \"I am a plain function\"; }\n call_twice(bare_function);"}]}