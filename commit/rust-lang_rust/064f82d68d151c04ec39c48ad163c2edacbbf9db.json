{"sha": "064f82d68d151c04ec39c48ad163c2edacbbf9db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NGY4MmQ2OGQxNTFjMDRlYzM5YzQ4YWQxNjNjMmVkYWNiYmY5ZGI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-27T10:33:13Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-27T10:33:13Z"}, "message": "Support returning from loop blocks\n\nThe code is somewhat invasive, but it seems hard to do this in a\nclean way, since the design itself involves a bunch of 'action\nat a distance'.\n\nIssue #1819", "tree": {"sha": "27a016fa7dde47f54c980a22a9d23571e98efa9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27a016fa7dde47f54c980a22a9d23571e98efa9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/064f82d68d151c04ec39c48ad163c2edacbbf9db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/064f82d68d151c04ec39c48ad163c2edacbbf9db", "html_url": "https://github.com/rust-lang/rust/commit/064f82d68d151c04ec39c48ad163c2edacbbf9db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/064f82d68d151c04ec39c48ad163c2edacbbf9db/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e3738b9c824e56f561e75f0ff11cf3a0d2dd09", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e3738b9c824e56f561e75f0ff11cf3a0d2dd09", "html_url": "https://github.com/rust-lang/rust/commit/f6e3738b9c824e56f561e75f0ff11cf3a0d2dd09"}], "stats": {"total": 294, "additions": 243, "deletions": 51}, "files": [{"sha": "4d69154aac8415ffc7eba804692947914602ba41", "filename": "src/rustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_loop.rs?ref=064f82d68d151c04ec39c48ad163c2edacbbf9db", "patch": "@@ -25,7 +25,8 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n                 v.visit_block(b, {in_loop: false, can_ret: false}, v);\n               }\n               expr_loop_body(@{node: expr_fn_block(_, b), _}) {\n-                v.visit_block(b, {in_loop: true, can_ret: false}, v);\n+                let blk = is_blockish(ty::ty_fn_proto(ty::expr_ty(tcx, e)));\n+                v.visit_block(b, {in_loop: true, can_ret: blk}, v);\n               }\n               expr_break {\n                 if !cx.in_loop {"}, {"sha": "75416b6dae9d34694808bb44c4fdb81d09d09c9c", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 102, "deletions": 19, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=064f82d68d151c04ec39c48ad163c2edacbbf9db", "patch": "@@ -2516,15 +2516,43 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n     ret store_in_dest(e_res.bcx, newval, dest);\n }\n \n+fn trans_loop_body(bcx: block, e: @ast::expr, ret_flag: option<ValueRef>,\n+                   dest: dest) -> block {\n+    alt check e.node {\n+      ast::expr_loop_body(b@@{node: ast::expr_fn_block(decl, body), _}) {\n+        alt check ty::get(expr_ty(bcx, e)).struct {\n+          ty::ty_fn({proto, _}) {\n+            closure::trans_expr_fn(bcx, proto, decl, body, e.span, b.id,\n+                                   {copies: [], moves: []}, some(ret_flag),\n+                                   dest)\n+          }\n+        }\n+      }\n+    }\n+}\n+\n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n-                  &temp_cleanups: [ValueRef]) -> result {\n+                  &temp_cleanups: [ValueRef], ret_flag: option<ValueRef>)\n+    -> result {\n     let _icx = cx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = cx.ccx();\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n-    let lv = trans_temp_lval(cx, e);\n+    let lv = alt ret_flag {\n+      // If there is a ret_flag, this *must* be a loop body\n+      some(ptr) {\n+        alt check e.node {\n+          ast::expr_loop_body(blk) {\n+            let scratch = alloc_ty(cx, expr_ty(cx, blk));\n+            let bcx = trans_loop_body(cx, e, ret_flag, save_in(scratch));\n+            {bcx: bcx, val: scratch, kind: temporary}\n+          }\n+        }\n+      }\n+      none { trans_temp_lval(cx, e) }\n+    };\n     let mut bcx = lv.bcx;\n     let mut val = lv.val;\n     let arg_mode = ty::resolved_mode(ccx.tcx, arg.mode);\n@@ -2595,7 +2623,7 @@ enum call_args {\n //  - new_fn_ctxt\n //  - trans_args\n fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n-              dest: dest)\n+              dest: dest, ret_flag: option<ValueRef>)\n     -> {bcx: block, args: [ValueRef], retslot: ValueRef} {\n     let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = [];\n@@ -2630,13 +2658,13 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n     alt args {\n       arg_exprs(es) {\n         let llarg_tys = type_of_explicit_args(ccx, arg_tys);\n-        let mut i = 0u;\n-        for e: @ast::expr in es {\n+        let last = es.len() - 1u;\n+        vec::iteri(es) {|i, e|\n             let r = trans_arg_expr(bcx, arg_tys[i], llarg_tys[i],\n-                                   e, temp_cleanups);\n+                                   e, temp_cleanups, if i == last { ret_flag }\n+                                                     else { none });\n             bcx = r.bcx;\n             llargs += [r.val];\n-            i += 1u;\n         }\n       }\n       arg_vals(vs) {\n@@ -2664,14 +2692,44 @@ fn trans_call(in_cx: block, f: @ast::expr,\n                      {|cx| trans_callee(cx, f)}, args, dest)\n }\n \n+fn body_contains_ret(body: ast::blk) -> bool {\n+    let cx = {mut found: false};\n+    visit::visit_block(body, cx, visit::mk_vt(@{\n+        visit_item: {|_i, _cx, _v|},\n+        visit_expr: {|e: @ast::expr, cx: {mut found: bool}, v|\n+            if !cx.found {\n+                alt e.node {\n+                  ast::expr_ret(_) { cx.found = true; }\n+                  _ { visit::visit_expr(e, cx, v); }\n+                }\n+            }\n+        } with *visit::default_visitor()\n+    }));\n+    cx.found\n+}\n+\n fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n                     get_callee: fn(block) -> lval_maybe_callee,\n                     args: call_args, dest: dest)\n     -> block {\n+    let ret_in_loop = alt args {\n+      arg_exprs(args) { args.len() > 0u && alt vec::last(args).node {\n+        ast::expr_loop_body(@{node: ast::expr_fn_block(_, body), _}) {\n+          body_contains_ret(body)\n+        }\n+        _ { false }\n+      } }\n+      _ { false }\n+    };\n     with_scope(in_cx, \"call\") {|cx|\n         let f_res = get_callee(cx);\n         let mut bcx = f_res.bcx;\n         let ccx = cx.ccx();\n+        let ret_flag = if ret_in_loop {\n+            let flag = alloca(in_cx, T_bool());\n+            Store(cx, C_bool(false), flag);\n+            some(flag)\n+        } else { none };\n \n         let mut faddr = f_res.val;\n         let llenv = alt f_res.env {\n@@ -2695,7 +2753,7 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n         };\n \n         let args_res = {\n-            trans_args(bcx, llenv, args, fn_expr_ty, dest)\n+            trans_args(bcx, llenv, args, fn_expr_ty, dest, ret_flag)\n         };\n         bcx = args_res.bcx;\n         let mut llargs = args_res.args;\n@@ -2718,7 +2776,19 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n             *cell = Load(bcx, llretslot);\n           }\n         }\n-        if ty::type_is_bot(ret_ty) { Unreachable(bcx); }\n+        if ty::type_is_bot(ret_ty) {\n+            Unreachable(bcx);\n+        } else if ret_in_loop {\n+            bcx = with_cond(bcx, Load(bcx, option::get(ret_flag))) {|bcx|\n+                option::may(bcx.fcx.loop_ret) {|lret|\n+                    Store(bcx, C_bool(true), lret.flagptr);\n+                    Store(bcx, C_bool(false), bcx.fcx.llretptr);\n+                }\n+                cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n+                Unreachable(bcx);\n+                bcx\n+            }\n+        }\n         bcx\n     }\n }\n@@ -2991,25 +3061,20 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       ast::expr_addr_of(_, x) { ret trans_addr_of(bcx, x, dest); }\n       ast::expr_fn(proto, decl, body, cap_clause) {\n         ret closure::trans_expr_fn(bcx, proto, decl, body, e.span, e.id,\n-                                   *cap_clause, false, dest);\n+                                   *cap_clause, none, dest);\n       }\n       ast::expr_fn_block(decl, body) {\n         alt check ty::get(expr_ty(bcx, e)).struct {\n           ty::ty_fn({proto, _}) {\n             #debug(\"translating fn_block %s with type %s\",\n                    expr_to_str(e), ty_to_str(tcx, expr_ty(bcx, e)));\n             ret closure::trans_expr_fn(bcx, proto, decl, body, e.span, e.id,\n-                                       {copies: [], moves: []}, false, dest);\n+                                       {copies: [], moves: []}, none, dest);\n           }\n         }\n       }\n-      ast::expr_loop_body(b@@{node: ast::expr_fn_block(decl, body), _}) {\n-        alt check ty::get(expr_ty(bcx, e)).struct {\n-          ty::ty_fn({proto, _}) {\n-            ret closure::trans_expr_fn(bcx, proto, decl, body, e.span, b.id,\n-                                       {copies: [], moves: []}, true, dest);\n-          }\n-        }\n+      ast::expr_loop_body(blk) {\n+        ret trans_loop_body(bcx, e, none, dest);\n       }\n       ast::expr_bind(f, args) {\n         ret closure::trans_bind(\n@@ -3406,8 +3471,25 @@ fn trans_cont(cx: block) -> block {\n fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n+    let retptr = alt bcx.fcx.loop_ret {\n+      some({flagptr, retptr}) {\n+        // This is a loop body return. Must set continue flag (our retptr)\n+        // to false, return flag to true, and then store the value in the\n+        // parent's retptr.\n+        Store(bcx, C_bool(true), flagptr);\n+        Store(bcx, C_bool(false), bcx.fcx.llretptr);\n+        alt e {\n+          some(x) { PointerCast(bcx, retptr,\n+                                T_ptr(type_of(bcx.ccx(), expr_ty(bcx, x)))) }\n+          none { retptr }\n+        }\n+      }\n+      none { bcx.fcx.llretptr }\n+    };\n     alt e {\n-      some(x) { bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr); }\n+      some(x) {\n+        bcx = trans_expr_save_in(bcx, x, retptr);\n+      }\n       _ {}\n     }\n     cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n@@ -3793,6 +3875,7 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n           mut llreturn: llbbs.rt,\n           mut llself: none,\n           mut personality: none,\n+          mut loop_ret: none,\n           llargs: int_hash::<local_val>(),\n           lllocals: int_hash::<local_val>(),\n           llupvars: int_hash::<ValueRef>(),"}, {"sha": "e614c4e8f0f3c3381b2f14a5dfe4b987e7240fe1", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=064f82d68d151c04ec39c48ad163c2edacbbf9db", "patch": "@@ -287,7 +287,8 @@ fn store_environment(bcx: block,\n fn build_closure(bcx0: block,\n                  cap_vars: [capture::capture_var],\n                  ck: ty::closure_kind,\n-                 id: ast::node_id) -> closure_result {\n+                 id: ast::node_id,\n+                 include_ret_handle: option<ValueRef>) -> closure_result {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n     let mut env_vals = [];\n@@ -324,6 +325,16 @@ fn build_closure(bcx0: block,\n           }\n         }\n     }\n+    option::may(include_ret_handle) {|flagptr|\n+        let our_ret = alt bcx.fcx.loop_ret {\n+          some({retptr, _}) { retptr }\n+          none { bcx.fcx.llretptr }\n+        };\n+        let nil_ret = PointerCast(bcx, our_ret, T_ptr(T_nil()));\n+        env_vals +=\n+            [env_ref(flagptr, ty::mk_mut_ptr(tcx, ty::mk_bool(tcx)), owned),\n+             env_ref(nil_ret, ty::mk_nil_ptr(tcx), owned)];\n+    }\n     ret store_environment(bcx, env_vals, ck);\n }\n \n@@ -333,6 +344,7 @@ fn build_closure(bcx0: block,\n fn load_environment(fcx: fn_ctxt,\n                     cdata_ty: ty::t,\n                     cap_vars: [capture::capture_var],\n+                    load_ret_handle: bool,\n                     ck: ty::closure_kind) {\n     let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n     let bcx = raw_block(fcx, fcx.llloadenv);\n@@ -341,23 +353,30 @@ fn load_environment(fcx: fn_ctxt,\n     let llcdata = base::opaque_box_body(bcx, cdata_ty, fcx.llenv);\n \n     // Populate the upvars from the environment.\n-    let mut i = 0u;\n+    let mut i = 0;\n     vec::iter(cap_vars) { |cap_var|\n         alt cap_var.mode {\n           capture::cap_drop { /* ignore */ }\n           _ {\n             let mut upvarptr =\n-                GEPi(bcx, llcdata, [0, abi::closure_body_bindings, i as int]);\n+                GEPi(bcx, llcdata, [0, abi::closure_body_bindings, i]);\n             alt ck {\n               ty::ck_block { upvarptr = Load(bcx, upvarptr); }\n               ty::ck_uniq | ty::ck_box { }\n             }\n             let def_id = ast_util::def_id_of_def(cap_var.def);\n             fcx.llupvars.insert(def_id.node, upvarptr);\n-            i += 1u;\n+            i += 1;\n           }\n         }\n     }\n+    if load_ret_handle {\n+        let flagptr = Load(bcx, GEPi(bcx, llcdata,\n+                                     [0, abi::closure_body_bindings, i]));\n+        let retptr = Load(bcx, GEPi(bcx, llcdata,\n+                                    [0, abi::closure_body_bindings, i+1]));\n+        fcx.loop_ret = some({flagptr: flagptr, retptr: retptr});\n+    }\n }\n \n fn trans_expr_fn(bcx: block,\n@@ -367,7 +386,7 @@ fn trans_expr_fn(bcx: block,\n                  sp: span,\n                  id: ast::node_id,\n                  cap_clause: ast::capture_clause,\n-                 is_loop_body: bool,\n+                 is_loop_body: option<option<ValueRef>>,\n                  dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"closure::trans_expr_fn\");\n     if dest == ignore { ret bcx; }\n@@ -382,12 +401,17 @@ fn trans_expr_fn(bcx: block,\n     let trans_closure_env = fn@(ck: ty::closure_kind) -> ValueRef {\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n-        let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck, id);\n+        let ret_handle = alt is_loop_body { some(x) { x } none { none } };\n+        let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck, id,\n+                                                   ret_handle);\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n                       bcx.fcx.param_substs, id, {|fcx|\n-            load_environment(fcx, cdata_ty, cap_vars, ck);\n+            load_environment(fcx, cdata_ty, cap_vars,\n+                             option::is_some(ret_handle), ck);\n         }, {|bcx|\n-            if is_loop_body { Store(bcx, C_bool(true), bcx.fcx.llretptr); }\n+            if option::is_some(is_loop_body) {\n+                Store(bcx, C_bool(true), bcx.fcx.llretptr);\n+            }\n         });\n         llbox\n     };"}, {"sha": "af3dd12690ed565305201897aa2bce876bad1481", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=064f82d68d151c04ec39c48ad163c2edacbbf9db", "patch": "@@ -165,6 +165,9 @@ type fn_ctxt = @{\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n     mut personality: option<ValueRef>,\n+    // If this is a for-loop body that returns, this holds the pointers needed\n+    // for that\n+    mut loop_ret: option<{flagptr: ValueRef, retptr: ValueRef}>,\n \n     // Maps arguments to allocas created for them in llallocas.\n     llargs: hashmap<ast::node_id, local_val>,"}, {"sha": "8cfa7c8433c1e132adefe4fb0ba2b3f3478dbe25", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=064f82d68d151c04ec39c48ad163c2edacbbf9db", "patch": "@@ -36,7 +36,7 @@ fn trans_self_arg(bcx: block, base: @ast::expr) -> result {\n     let mut temp_cleanups = [];\n     let result = trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n                                 T_ptr(type_of::type_of(bcx.ccx(), basety)),\n-                                base, temp_cleanups);\n+                                base, temp_cleanups, none);\n \n     // by-ref self argument should not require cleanup in the case of\n     // other arguments failing:"}, {"sha": "721b846e052f85c0a8e0d6270f8986b026112f34", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=064f82d68d151c04ec39c48ad163c2edacbbf9db", "patch": "@@ -71,6 +71,8 @@ type fn_ctxt =\n     // with any nested functions that capture the environment\n     // (and with any functions whose environment is being captured).\n     {ret_ty: ty::t,\n+     // Used by loop bodies that return from the outer function\n+     indirect_ret_ty: option<ty::t>,\n      purity: ast::purity,\n      proto: ast::proto,\n      infcx: infer::infer_ctxt,\n@@ -2286,7 +2288,8 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                               decl: ast::fn_decl,\n                               body: ast::blk,\n                               unify: unifier,\n-                              expected: ty::t) {\n+                              expected: ty::t,\n+                              is_loop_body: bool) {\n     let tcx = fcx.ccx.tcx;\n     let fty = ty::mk_fn(tcx,\n                         ty_of_fn_decl(tcx, m_check_tyvar(fcx), proto, decl));\n@@ -2303,7 +2306,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n     // record projection work on type inferred arguments.\n     unify(fcx, expr.span, expected, fty);\n \n-    check_fn(fcx.ccx, proto, decl, body, expr.id, some(fcx));\n+    check_fn(fcx.ccx, proto, decl, body, expr.id, is_loop_body, some(fcx));\n }\n \n type check_call_or_bind_result = {\n@@ -2766,15 +2769,18 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_cont { write_bot(tcx, id); bot = true; }\n       ast::expr_ret(expr_opt) {\n         bot = true;\n+        let ret_ty = alt fcx.indirect_ret_ty {\n+          some(t) { t } none { fcx.ret_ty }\n+        };\n         alt expr_opt {\n           none {\n             let nil = ty::mk_nil(tcx);\n-            if !are_compatible(fcx, fcx.ret_ty, nil) {\n+            if !are_compatible(fcx, ret_ty, nil) {\n                 tcx.sess.span_err(expr.span,\n                                   \"ret; in function returning non-nil\");\n             }\n           }\n-          some(e) { check_expr_with(fcx, e, fcx.ret_ty); }\n+          some(e) { check_expr_with(fcx, e, ret_ty); }\n         }\n         write_bot(tcx, id);\n       }\n@@ -2895,7 +2901,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_fn(proto, decl, body, captures) {\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n-                          unify, expected);\n+                                   unify, expected, false);\n         capture::check_capture_clause(tcx, expr.id, proto, *captures);\n       }\n       ast::expr_fn_block(decl, body) {\n@@ -2908,19 +2914,25 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                expr_to_str(expr),\n                ty_to_str(tcx, expected));\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n-                                   unify, expected);\n+                                   unify, expected, false);\n       }\n-      ast::expr_loop_body(block) {\n+      ast::expr_loop_body(b) {\n         let rty = structurally_resolved_type(fcx, expr.span, expected);\n-        let inner_ty = alt check ty::get(rty).struct {\n+        let (inner_ty, proto) = alt check ty::get(rty).struct {\n           ty::ty_fn(fty) {\n             demand::simple(fcx, expr.span, fty.output, ty::mk_bool(tcx));\n-            ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty})\n+            (ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty}),\n+             fty.proto)\n           }\n         };\n-        check_expr_with(fcx, block, inner_ty);\n+        alt check b.node {\n+          ast::expr_fn_block(decl, body) {\n+            check_expr_fn_with_unifier(fcx, b, proto, decl, body,\n+                                       unify, inner_ty, true);\n+          }\n+        }\n         let block_ty = structurally_resolved_type(\n-            fcx, expr.span, ty::node_id_to_type(tcx, block.id));\n+            fcx, expr.span, ty::node_id_to_type(tcx, b.id));\n         alt check ty::get(block_ty).struct {\n           ty::ty_fn(fty) {\n             write_ty(tcx, expr.id, ty::mk_fn(tcx, {output: ty::mk_bool(tcx)\n@@ -3045,18 +3057,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         write_ty(tcx, id, typ);\n       }\n       ast::expr_rec(fields, base) {\n-        alt base { none {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n-        let mut fields_t: [spanned<field>] = [];\n-        for f: ast::field in fields {\n+        option::may(base) {|b| check_expr(fcx, b); }\n+        let fields_t = vec::map(fields, {|f|\n             bot |= check_expr(fcx, f.node.expr);\n             let expr_t = expr_ty(tcx, f.node.expr);\n             let expr_mt = {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n             // should be f.node.expr.span, not f.span\n-            fields_t +=\n-                [respan(f.node.expr.span,\n-                        {ident: f.node.ident, mt: expr_mt})];\n-        }\n+            respan(f.node.expr.span, {ident: f.node.ident, mt: expr_mt})\n+        });\n         alt base {\n           none {\n             fn get_node(f: spanned<field>) -> field { f.node }\n@@ -3384,6 +3393,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     let rty = node_id_to_type(ccx.tcx, id);\n     let fcx: @fn_ctxt =\n         @{ret_ty: rty,\n+          indirect_ret_ty: none,\n           purity: ast::pure_fn,\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n@@ -3403,6 +3413,7 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n     let rty = node_id_to_type(ccx.tcx, id);\n     let fcx: @fn_ctxt =\n         @{ret_ty: rty,\n+          indirect_ret_ty: none,\n           purity: ast::pure_fn,\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n@@ -3570,6 +3581,7 @@ fn check_fn(ccx: @crate_ctxt,\n             decl: ast::fn_decl,\n             body: ast::blk,\n             id: ast::node_id,\n+            indirect_ret: bool,\n             old_fcx: option<@fn_ctxt>) {\n     // If old_fcx is some(...), this is a block fn { |x| ... }.\n     // In that case, the purity is inherited from the context.\n@@ -3579,8 +3591,16 @@ fn check_fn(ccx: @crate_ctxt,\n     };\n \n     let gather_result = gather_locals(ccx, decl, body, id, old_fcx);\n+    let indirect_ret_ty = if indirect_ret {\n+        let ofcx = option::get(old_fcx);\n+        alt ofcx.indirect_ret_ty {\n+          some(t) { some(t) }\n+          none { some(ofcx.ret_ty) }\n+        }\n+    } else { none };\n     let fcx: @fn_ctxt =\n         @{ret_ty: ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id)),\n+          indirect_ret_ty: indirect_ret_ty,\n           purity: purity,\n           proto: proto,\n           infcx: gather_result.infcx,\n@@ -3619,7 +3639,8 @@ fn check_fn(ccx: @crate_ctxt,\n }\n \n fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n-    check_fn(ccx, ast::proto_bare, method.decl, method.body, method.id, none);\n+    check_fn(ccx, ast::proto_bare, method.decl, method.body, method.id,\n+             false, none);\n }\n \n fn class_types(ccx: @crate_ctxt, members: [@ast::class_item]) -> class_map {\n@@ -3651,10 +3672,10 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n       ast::item_enum(vs, _) { check_enum_variants(ccx, it.span, vs, it.id); }\n       ast::item_fn(decl, tps, body) {\n-        check_fn(ccx, ast::proto_bare, decl, body, it.id, none);\n+        check_fn(ccx, ast::proto_bare, decl, body, it.id, false, none);\n       }\n       ast::item_res(decl, tps, body, dtor_id, _) {\n-        check_fn(ccx, ast::proto_bare, decl, body, dtor_id, none);\n+        check_fn(ccx, ast::proto_bare, decl, body, dtor_id, false, none);\n       }\n       ast::item_impl(tps, _, ty, ms) {\n         let mut self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n@@ -3671,7 +3692,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                             enclosing_class:members_info with *ccx};\n           // typecheck the ctor\n           check_fn(class_ccx, ast::proto_bare, ctor.node.dec,\n-                   ctor.node.body, ctor.node.id, none);\n+                   ctor.node.body, ctor.node.id, false, none);\n           // typecheck the members\n           for m in members { check_class_member(class_ccx, m.node.decl); }\n       }"}, {"sha": "95c5b607cd400239021b75301c85efb6f3f826cc", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=064f82d68d151c04ec39c48ad163c2edacbbf9db", "patch": "@@ -303,6 +303,9 @@ enum expr_ {\n     expr_alt(@expr, [arm], alt_mode),\n     expr_fn(proto, fn_decl, blk, @capture_clause),\n     expr_fn_block(fn_decl, blk),\n+    // Inner expr is always an expr_fn_block. We need the wrapping node to\n+    // sanely type this (a function returning nil on the inside but bool on\n+    // the outside).\n     expr_loop_body(@expr),\n     expr_block(blk),\n "}, {"sha": "e93ce8a32e94ece4490cba125af71ade9bb27061", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f82d68d151c04ec39c48ad163c2edacbbf9db/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=064f82d68d151c04ec39c48ad163c2edacbbf9db", "patch": "@@ -0,0 +1,57 @@\n+fn iter<T>(v: [T], it: fn(T) -> bool) {\n+    let mut i = 0u, l = v.len();\n+    while i < l {\n+        if !it(v[i]) { break; }\n+        i += 1u;\n+    }\n+}\n+\n+fn find_pos<T>(n: T, h: [T]) -> option<uint> {\n+    let mut i = 0u;\n+    for iter(h) {|e|\n+        if e == n { ret some(i); }\n+        i += 1u;\n+    }\n+    none\n+}\n+\n+fn bail_deep(x: [[bool]]) {\n+    let mut seen = false;\n+    for iter(x) {|x|\n+        for iter(x) {|x|\n+            assert !seen;\n+            if x { seen = true; ret; }\n+        }\n+    }\n+    assert !seen;\n+}\n+\n+fn ret_deep() -> str {\n+    for iter([1, 2]) {|e|\n+        for iter([3, 4]) {|x|\n+            if e + x > 4 { ret \"hi\"; }\n+        }\n+    }\n+    ret \"bye\";\n+}\n+\n+fn main() {\n+    let mut last = 0;\n+    for vec::all([1, 2, 3, 4, 5, 6, 7]) {|e|\n+        last = e;\n+        if e == 5 { break; }\n+        if e % 2 == 1 { cont; }\n+        assert e % 2 == 0;\n+    };\n+    assert last == 5;\n+\n+    assert find_pos(1, [0, 1, 2, 3]) == some(1u);\n+    assert find_pos(1, [0, 4, 2, 3]) == none;\n+    assert find_pos(\"hi\", [\"foo\", \"bar\", \"baz\", \"hi\"]) == some(3u);\n+\n+    bail_deep([[false, false], [true, true], [false, true]]);\n+    bail_deep([[true]]);\n+    bail_deep([[false, false, false]]);\n+\n+    assert ret_deep() == \"hi\";\n+}"}]}