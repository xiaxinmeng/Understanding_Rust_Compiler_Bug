{"sha": "b9e4fcbf04b21c39b5e704a1f24adbfe179f8814", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZTRmY2JmMDRiMjFjMzliNWU3MDRhMWYyNGFkYmZlMTc5Zjg4MTQ=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-05-14T18:08:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-15T20:50:39Z"}, "message": "shootout-mandelbrot: Precalc initial values & use SIMD in the main loop. +80-100%", "tree": {"sha": "2b547ee56fdc4ff01bb6d99df46205e1952fa6d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b547ee56fdc4ff01bb6d99df46205e1952fa6d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9e4fcbf04b21c39b5e704a1f24adbfe179f8814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9e4fcbf04b21c39b5e704a1f24adbfe179f8814", "html_url": "https://github.com/rust-lang/rust/commit/b9e4fcbf04b21c39b5e704a1f24adbfe179f8814", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9e4fcbf04b21c39b5e704a1f24adbfe179f8814/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03f48534b3ac38bc3792019cdd2b8a24eaebee50", "url": "https://api.github.com/repos/rust-lang/rust/commits/03f48534b3ac38bc3792019cdd2b8a24eaebee50", "html_url": "https://github.com/rust-lang/rust/commit/03f48534b3ac38bc3792019cdd2b8a24eaebee50"}], "stats": {"total": 186, "additions": 125, "deletions": 61}, "files": [{"sha": "debd12874da1ee6e1c485096df7ef1ae3143e7b1", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 125, "deletions": 61, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/b9e4fcbf04b21c39b5e704a1f24adbfe179f8814/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9e4fcbf04b21c39b5e704a1f24adbfe179f8814/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=b9e4fcbf04b21c39b5e704a1f24adbfe179f8814", "patch": "@@ -8,104 +8,168 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n #![feature(macro_rules)]\n+#![feature(simd)]\n+#![allow(experimental)]\n \n // ignore-pretty very bad with line comments\n \n extern crate sync;\n \n use std::io;\n+use std::os;\n+use std::unstable::simd::f64x2;\n use sync::Future;\n+use sync::Arc;\n \n static ITER: int = 50;\n static LIMIT: f64 = 2.0;\n+static WORKERS: uint = 16;\n \n-macro_rules! core_loop(\n-    ($pow:expr ~ $mask:expr: $ctx:ident, $b:ident) => (\n-        {\n-            let r = $ctx.r;\n-            let i = $ctx.i;\n+#[inline(always)]\n+fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n+    assert!(WORKERS % 2 == 0);\n \n-            $ctx.r = r * r - i * i + $ctx.init_r;\n-            $ctx.i = 2.0 * r * i + $ctx.init_i;\n+    // Ensure w and h are multiples of 8.\n+    let w = (w + 7) / 8 * 8;\n+    let h = w;\n+\n+    let chunk_size = h / WORKERS;\n \n-            if r * r + i * i > LIMIT * LIMIT {\n-                $b |= $pow;\n-                if $b == $mask { break; }\n+    // Account for remainders in workload division, e.g. 1000 / 16 = 62.5\n+    let first_chunk_size = if h % WORKERS != 0 {\n+        chunk_size + h % WORKERS\n+    } else {\n+        chunk_size\n+    };\n+\n+    // precalc values\n+    let inverse_w_doubled = 2.0 / w as f64;\n+    let inverse_h_doubled = 2.0 / h as f64;\n+    let v_inverses = f64x2(inverse_w_doubled, inverse_h_doubled);\n+    let v_consts = f64x2(1.5, 1.0);\n+\n+    // A lot of this code assumes this (so do other lang benchmarks)\n+    assert!(w == h);\n+    let mut precalc_r = Vec::with_capacity(w);\n+    let mut precalc_i = Vec::with_capacity(h);\n+\n+    let precalc_futures = Vec::from_fn(WORKERS, |i| {\n+        Future::spawn(proc () {\n+            let mut rs = Vec::with_capacity(w / WORKERS);\n+            let mut is = Vec::with_capacity(w / WORKERS);\n+\n+            let start = i * chunk_size;\n+            let end = if i == 0 {\n+                first_chunk_size\n+            } else {\n+                (i + 1) * chunk_size\n+            };\n+\n+            // This assumes w == h\n+            for x in range(start, end) {\n+                let xf = x as f64;\n+                let xy = f64x2(xf, xf);\n+\n+                let f64x2(r, i) = xy * v_inverses - v_consts;\n+                rs.push(r);\n+                is.push(i);\n             }\n-        }\n-    );\n-)\n \n-#[inline(always)]\n-fn write_line(init_i: f64, vec_init_r: &[f64], res: &mut Vec<u8>) {\n-    struct Context { r: f64, i: f64, init_i: f64, init_r: f64 }\n-    impl Context {\n-        #[inline(always)]\n-        fn new(i: f64, r: f64) -> Context {\n-            Context { r: r, i: i, init_r: r, init_i: i }\n-        }\n+            (rs, is)\n+        })\n+    });\n+\n+    for res in precalc_futures.move_iter() {\n+        let (rs, is) = res.unwrap();\n+        precalc_r.push_all_move(rs);\n+        precalc_i.push_all_move(is);\n+    }\n+\n+    assert_eq!(precalc_r.len(), w);\n+    assert_eq!(precalc_i.len(), h);\n+\n+    let arc_init_r = Arc::new(precalc_r);\n+    let arc_init_i = Arc::new(precalc_i);\n+\n+    let data = Vec::from_fn(WORKERS, |i| {\n+        let vec_init_r = arc_init_r.clone();\n+        let vec_init_i = arc_init_i.clone();\n+\n+        Future::spawn(proc () {\n+            let mut res: Vec<u8> = Vec::with_capacity((chunk_size * w) / 8);\n+            let init_r_slice = vec_init_r.as_slice();\n+            for &init_i in vec_init_i.slice(i * chunk_size, (i + 1) * chunk_size).iter() {\n+                write_line(init_i, init_r_slice, &mut res);\n+            }\n+\n+            res\n+        })\n+    });\n+\n+    try!(writeln!(&mut out as &mut Writer, \"P4\\n{} {}\", w, h));\n+    for res in data.move_iter() {\n+        try!(out.write(res.unwrap().as_slice()));\n     }\n+    out.flush()\n+}\n+\n+fn write_line(init_i: f64, vec_init_r: &[f64], res: &mut Vec<u8>) {\n+    let v_init_i : f64x2 = f64x2(init_i, init_i);\n+    let v_2 : f64x2 = f64x2(2.0, 2.0);\n+    static LIMIT_SQUARED: f64 = LIMIT * LIMIT;\n \n-    let mut cur_byte;\n-    let mut i;\n-    let mut bit_1;\n-    let mut bit_2;\n-    let mut b;\n     for chunk_init_r in vec_init_r.chunks(8) {\n-        cur_byte = 0xff;\n-        i = 0;\n+        let mut cur_byte = 0xff;\n+        let mut i = 0;\n \n         while i < 8 {\n-            bit_1 = Context::new(init_i, chunk_init_r[i]);\n-            bit_2 = Context::new(init_i, chunk_init_r[i + 1]);\n+            let v_init_r = f64x2(chunk_init_r[i], chunk_init_r[i + 1]);\n+            let mut cur_r = v_init_r;\n+            let mut cur_i = v_init_i;\n+            let mut r_sq = v_init_r * v_init_r;\n+            let mut i_sq = v_init_i * v_init_i;\n \n-            b = 0;\n+            let mut b = 0;\n             for _ in range(0, ITER) {\n-                core_loop!(2 ~ 3: bit_1, b);\n-                core_loop!(1 ~ 3: bit_2, b);\n+                let r = cur_r;\n+                let i = cur_i;\n+\n+                cur_i = v_2 * r * i + v_init_i;\n+                cur_r = r_sq - i_sq + v_init_r;\n+\n+                let f64x2(bit1, bit2) = r_sq + i_sq;\n+\n+                if bit1 > LIMIT_SQUARED {\n+                    b |= 2;\n+                    if b == 3 { break; }\n+                }\n+\n+                if bit2 > LIMIT_SQUARED {\n+                    b |= 1;\n+                    if b == 3 { break; }\n+                }\n+\n+                r_sq = cur_r * cur_r;\n+                i_sq = cur_i * cur_i;\n             }\n \n             cur_byte = (cur_byte << 2) + b;\n             i += 2;\n         }\n-        res.push(cur_byte^-1);\n-    }\n-}\n-\n-fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n-    // Ensure w and h are multiples of 8.\n-    let w = (w + 7) / 8 * 8;\n-    let h = w;\n-    let inverse_w_doubled = 2.0 / w as f64;\n-    let inverse_h_doubled = 2.0 / h as f64;\n-    let chunk_size = h / 16;\n-\n-    let data: Vec<Future<Vec<u8>>> = range(0u, 16).map(|i| Future::spawn(proc () {\n-        let vec_init_r = Vec::from_fn(w, |x| (x as f64) * inverse_w_doubled - 1.5);\n-        let mut res: Vec<u8> = Vec::with_capacity((chunk_size * w) / 8);\n-        for y in range(i * chunk_size, (i + 1) * chunk_size) {\n-            let init_i = (y as f64) * inverse_h_doubled - 1.0;\n-            write_line(init_i, vec_init_r.as_slice(), &mut res);\n-        }\n-        res\n-    })).collect();\n \n-    try!(writeln!(&mut out as &mut Writer, \"P4\\n{} {}\", w, h));\n-    for res in data.move_iter() {\n-        try!(out.write(res.unwrap().as_slice()));\n+        res.push(cur_byte^-1);\n     }\n-    out.flush()\n }\n \n fn main() {\n-    let args = std::os::args();\n+    let args = os::args();\n     let args = args.as_slice();\n     let res = if args.len() < 2 {\n         println!(\"Test mode: do not dump the image because it's not utf8, \\\n                   which interferes with the test runner.\");\n-        mandelbrot(1000, std::io::util::NullWriter)\n+        mandelbrot(1000, io::util::NullWriter)\n     } else {\n-        mandelbrot(from_str(args[1]).unwrap(), std::io::stdout())\n+        mandelbrot(from_str(args[1]).unwrap(), io::stdout())\n     };\n     res.unwrap();\n }"}]}