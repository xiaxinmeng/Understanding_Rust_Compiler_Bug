{"sha": "8081e8debf63726865e869aaacbd040755285a51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwODFlOGRlYmY2MzcyNjg2NWU4NjlhYWFjYmQwNDA3NTUyODVhNTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-04T21:25:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-04T22:43:51Z"}, "message": "Register snapshots", "tree": {"sha": "9154d7c17af39c1e817bf27652d6a9d45b4009b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9154d7c17af39c1e817bf27652d6a9d45b4009b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8081e8debf63726865e869aaacbd040755285a51", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8081e8debf63726865e869aaacbd040755285a51", "html_url": "https://github.com/rust-lang/rust/commit/8081e8debf63726865e869aaacbd040755285a51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8081e8debf63726865e869aaacbd040755285a51/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b872900a5b4adb53b7d74d45a3138083b22940d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b872900a5b4adb53b7d74d45a3138083b22940d6", "html_url": "https://github.com/rust-lang/rust/commit/b872900a5b4adb53b7d74d45a3138083b22940d6"}], "stats": {"total": 5980, "additions": 138, "deletions": 5842}, "files": [{"sha": "96e1c3bd1249be9d62439bad645b6794b653dde8", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -10,9 +10,7 @@\n \n //! Unsafe casting functions\n \n-#[cfg(not(stage0))]\n use sys;\n-#[cfg(not(stage0))]\n use unstable;\n \n pub mod rusti {\n@@ -21,35 +19,11 @@ pub mod rusti {\n     pub extern \"rust-intrinsic\" {\n         fn forget<T>(+x: T);\n \n-        #[cfg(stage0)]\n-        fn reinterpret_cast<T, U>(&&e: T) -> U;\n-\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n-        #[cfg(stage3)]\n         fn transmute<T,U>(e: T) -> U;\n     }\n }\n \n /// Casts the value at `src` to U. The two types must have the same length.\n-#[inline(always)]\n-#[cfg(stage0)]\n-pub unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n-    rusti::reinterpret_cast(*src)\n-}\n-\n-/// Unsafely copies and casts the value at `src` to U, even if the value is\n-/// noncopyable. The two types must have the same length.\n-#[inline(always)]\n-#[cfg(stage0)]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    rusti::reinterpret_cast(*src)\n-}\n-\n-#[inline(always)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = unstable::intrinsics::init();\n     {\n@@ -90,17 +64,6 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  *     assert!(transmute(\"L\") == ~[76u8, 0u8]);\n  */\n #[inline(always)]\n-#[cfg(stage0)]\n-pub unsafe fn transmute<L, G>(thing: L) -> G {\n-    let newthing: G = reinterpret_cast(&thing);\n-    forget(thing);\n-    newthing\n-}\n-\n-#[inline(always)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n     rusti::transmute(thing)\n }\n@@ -161,15 +124,6 @@ mod tests {\n     use cast::{bump_box_refcount, transmute};\n \n     #[test]\n-    #[cfg(stage0)]\n-    fn test_reinterpret_cast() {\n-        assert!(1u == unsafe { ::cast::reinterpret_cast(&1) });\n-    }\n-\n-    #[test]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn test_transmute_copy() {\n         assert!(1u == unsafe { ::cast::transmute_copy(&1) });\n     }"}, {"sha": "00ea4a9322111150357cad22aa436722b6442df5", "filename": "src/libcore/container.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -25,42 +25,6 @@ pub trait Mutable: Container {\n     fn clear(&mut self);\n }\n \n-#[cfg(stage0)]\n-pub trait Map<K, V>: Mutable {\n-    /// Return true if the map contains a value for the specified key\n-    fn contains_key(&self, key: &K) -> bool;\n-\n-    // Visits all keys and values\n-    fn each(&self, f: &fn(&K, &V) -> bool);\n-\n-    /// Visit all keys\n-    fn each_key(&self, f: &fn(&K) -> bool);\n-\n-    /// Visit all values\n-    fn each_value(&self, f: &fn(&V) -> bool);\n-\n-    /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n-\n-    /// Return a reference to the value corresponding to the key\n-    fn find(&self, key: &K) -> Option<&'self V>;\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    fn find_mut(&mut self, key: &K) -> Option<&'self mut V>;\n-\n-    /// Insert a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Return true if the key did\n-    /// not already exist in the map.\n-    fn insert(&mut self, key: K, value: V) -> bool;\n-\n-    /// Remove a key-value pair from the map. Return true if the key\n-    /// was present in the map, otherwise false.\n-    fn remove(&mut self, key: &K) -> bool;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, key: &K) -> bool;"}, {"sha": "9672bf887caff1d76533defb44694c987b275fc0", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -74,9 +74,6 @@ they contained the following prologue:\n \n pub use kinds::{Const, Copy, Owned, Durable};\n pub use ops::{Drop};\n-#[cfg(stage0)]\n-pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n-#[cfg(not(stage0))]\n pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Shl, Shr, Index};"}, {"sha": "392ad38e2093135ec3f38cd9079f1d99b92a05f4", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -184,18 +184,6 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn value_for_bucket(&self, idx: uint) -> &'self V {\n-        match self.buckets[idx] {\n-            Some(ref bkt) => &bkt.value,\n-            None => fail!(~\"HashMap::find: internal logic error\"),\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n         match self.buckets[idx] {\n@@ -204,18 +192,6 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn mut_value_for_bucket(&mut self, idx: uint) -> &'self mut V {\n-        match self.buckets[idx] {\n-            Some(ref mut bkt) => &mut bkt.value,\n-            None => unreachable()\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n         match self.buckets[idx] {\n@@ -329,21 +305,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all key-value pairs\n-    #[cfg(stage0)]\n-    fn each(&self, blk: &fn(&'self K, &'self V) -> bool) {\n-        for uint::range(0, self.buckets.len()) |i| {\n-            for self.buckets[i].each |bucket| {\n-                if !blk(&bucket.key, &bucket.value) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Visit all key-value pairs\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each<'a>(&'a self, blk: &fn(&'a K, &'a V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             for self.buckets[i].each |bucket| {\n@@ -360,15 +321,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all values\n-    #[cfg(stage0)]\n-    fn each_value(&self, blk: &fn(v: &V) -> bool) {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Visit all values\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n@@ -386,18 +338,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find(&self, k: &K) -> Option<&'self V> {\n-        match self.bucket_for_key(k) {\n-            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-            TableFull | FoundHole(_) => None,\n-        }\n-    }\n-\n-    /// Return a reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n         match self.bucket_for_key(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n@@ -406,21 +346,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find_mut(&mut self, k: &K) -> Option<&'self mut V> {\n-        let idx = match self.bucket_for_key(k) {\n-            FoundEntry(idx) => idx,\n-            TableFull | FoundHole(_) => return None\n-        };\n-        unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n-            Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n-        }\n-    }\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n         let idx = match self.bucket_for_key(k) {\n             FoundEntry(idx) => idx,\n@@ -503,40 +428,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n-    #[cfg(stage0)]\n-    fn find_or_insert(&mut self, k: K, v: V) -> &'self V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(~\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n-            FoundHole(idx) => {\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n-                self.size += 1;\n-                idx\n-            },\n-        };\n-\n-        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n-            ::cast::transmute_region(self.value_for_bucket(idx))\n-        }\n-    }\n-\n-    /// Return the value corresponding to the key in the map, or insert\n-    /// and return the value if it doesn't exist.\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -567,41 +458,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n-    #[cfg(stage0)]\n-    fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &'self V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(~\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n-            FoundHole(idx) => {\n-                let v = f(&k);\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n-                self.size += 1;\n-                idx\n-            },\n-        };\n-\n-        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n-            ::cast::transmute_region(self.value_for_bucket(idx))\n-        }\n-    }\n-\n-    /// Return the value corresponding to the key in the map, or create,\n-    /// insert, and return a new value if it doesn't exist.\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -647,17 +503,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn get(&self, k: &K) -> &'self V {\n-        match self.find(k) {\n-            Some(v) => v,\n-            None => fail!(fmt!(\"No entry found for key: %?\", k)),\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n@@ -676,19 +521,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, using\n     /// equivalence\n-    #[cfg(stage0)]\n-    fn find_equiv<Q:Hash + Equiv<K>>(&self, k: &Q) -> Option<&'self V> {\n-        match self.bucket_for_key_equiv(k) {\n-            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-            TableFull | FoundHole(_) => None,\n-        }\n-    }\n-\n-    /// Return the value corresponding to the key in the map, using\n-    /// equivalence\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_equiv<'a, Q:Hash + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),"}, {"sha": "416ec2069b5216e4327d6091f6108cfa99937eeb", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -284,12 +284,7 @@ impl Div<f32,f32> for f32 {\n     fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n \n-#[cfg(stage0,notest)]\n-impl Modulo<f32,f32> for f32 {\n-    #[inline(always)]\n-    fn modulo(&self, other: &f32) -> f32 { *self % *other }\n-}\n-#[cfg(not(stage0),notest)]\n+#[cfg(notest)]\n impl Rem<f32,f32> for f32 {\n     #[inline(always)]\n     fn rem(&self, other: &f32) -> f32 { *self % *other }"}, {"sha": "6e09ca61a7d4ccc2eea96d9d86429be00eb01e3a", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -299,11 +299,7 @@ impl Mul<f64,f64> for f64 {\n impl Div<f64,f64> for f64 {\n     fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n-#[cfg(stage0,notest)]\n-impl Modulo<f64,f64> for f64 {\n-    fn modulo(&self, other: &f64) -> f64 { *self % *other }\n-}\n-#[cfg(not(stage0),notest)]\n+#[cfg(notest)]\n impl Rem<f64,f64> for f64 {\n     #[inline(always)]\n     fn rem(&self, other: &f64) -> f64 { *self % *other }"}, {"sha": "da9d03f6a7bc363b11b0140d82003ba3bf2e9282", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -697,12 +697,7 @@ impl Div<float,float> for float {\n     fn div(&self, other: &float) -> float { *self / *other }\n }\n \n-#[cfg(stage0,notest)]\n-impl Modulo<float,float> for float {\n-    #[inline(always)]\n-    fn modulo(&self, other: &float) -> float { *self % *other }\n-}\n-#[cfg(not(stage0),notest)]\n+#[cfg(notest)]\n impl Rem<float,float> for float {\n     #[inline(always)]\n     fn rem(&self, other: &float) -> float { *self % *other }"}, {"sha": "95c187a7be22e60ce546a9fe56820803da7851d5", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -224,12 +224,7 @@ impl Div<T,T> for T {\n     fn div(&self, other: &T) -> T { *self / *other }\n }\n \n-#[cfg(stage0,notest)]\n-impl Modulo<T,T> for T {\n-    #[inline(always)]\n-    fn modulo(&self, other: &T) -> T { *self % *other }\n-}\n-#[cfg(not(stage0),notest)]\n+#[cfg(notest)]\n impl Rem<T,T> for T {\n     ///\n     /// Returns the integer remainder after division, satisfying:"}, {"sha": "1a59a069df7e899c75b6b47a79a9a57e569dde01", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -10,11 +10,6 @@\n \n //! An interface for numeric types\n use cmp::{Eq, Ord};\n-#[cfg(stage0)]\n-use ops::{Add, Sub, Mul, Div, Neg};\n-#[cfg(stage0)]\n-use Rem = ops::Modulo;\n-#[cfg(not(stage0))]\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n@@ -391,23 +386,7 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n }\n \n /// Helper function for testing numeric operations\n-#[cfg(stage0,test)]\n-pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n-    assert_eq!(ten.add(&two),    cast(12));\n-    assert_eq!(ten.sub(&two),    cast(8));\n-    assert_eq!(ten.mul(&two),    cast(20));\n-    assert_eq!(ten.div(&two),    cast(5));\n-    assert_eq!(ten.modulo(&two), cast(0));\n-\n-    assert_eq!(ten.add(&two),    ten + two);\n-    assert_eq!(ten.sub(&two),    ten - two);\n-    assert_eq!(ten.mul(&two),    ten * two);\n-    assert_eq!(ten.div(&two),    ten / two);\n-    assert_eq!(ten.modulo(&two), ten % two);\n-}\n-#[cfg(stage1,test)]\n-#[cfg(stage2,test)]\n-#[cfg(stage3,test)]\n+#[cfg(test)]\n pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n     assert_eq!(ten.add(&two),  cast(12));\n     assert_eq!(ten.sub(&two),  cast(8));"}, {"sha": "c16a29f8295e77d1d5d5c6bef20ececad2fa8284", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -9,13 +9,6 @@\n // except according to those terms.\n \n use core::cmp::{Ord, Eq};\n-#[cfg(stage0)]\n-use ops::{Add, Sub, Mul, Div, Neg};\n-#[cfg(stage0)]\n-use Rem = ops::Modulo;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n use char;"}, {"sha": "6d0f1fe1fc72b9bfed2db771f6973bd3ee7bd8e6", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -171,12 +171,7 @@ impl Div<T,T> for T {\n     fn div(&self, other: &T) -> T { *self / *other }\n }\n \n-#[cfg(stage0,notest)]\n-impl Modulo<T,T> for T {\n-    #[inline(always)]\n-    fn modulo(&self, other: &T) -> T { *self % *other }\n-}\n-#[cfg(not(stage0),notest)]\n+#[cfg(notest)]\n impl Rem<T,T> for T {\n     #[inline(always)]\n     fn rem(&self, other: &T) -> T { *self % *other }"}, {"sha": "47ff45be68726a5bc5ab73950102438fe4c1106f", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -35,13 +35,7 @@ pub trait Div<RHS,Result> {\n     fn div(&self, rhs: &RHS) -> Result;\n }\n \n-#[lang=\"modulo\"]\n-#[cfg(stage0)]\n-pub trait Modulo<RHS,Result> {\n-    fn modulo(&self, rhs: &RHS) -> Result;\n-}\n #[lang=\"rem\"]\n-#[cfg(not(stage0))]\n pub trait Rem<RHS,Result> {\n     fn rem(&self, rhs: &RHS) -> Result;\n }"}, {"sha": "b7c51147fba78c8422664bcf7c6c1ad6bc90299a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -100,16 +100,6 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n \n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each(&self, f: &fn(x: &'self T) -> bool) {\n-        match *self { None => (), Some(ref t) => { f(t); } }\n-    }\n-\n-    /// Performs an operation on the contained value by reference\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n@@ -122,15 +112,6 @@ impl<T> BaseIter<T> for Option<T> {\n }\n \n impl<T> MutableIter<T> for Option<T> {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each_mut(&mut self, f: &fn(&'self mut T) -> bool) {\n-        match *self { None => (), Some(ref mut t) => { f(t); } }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) {\n         match *self { None => (), Some(ref mut t) => { f(t); } }\n@@ -200,35 +181,12 @@ pub impl<T> Option<T> {\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn chain_ref<U>(&self, f: &fn(x: &'self T) -> Option<U>) -> Option<U> {\n-        match *self { Some(ref x) => f(x), None => None }\n-    }\n-\n-    /**\n-     * Update an optional value by optionally running its content by reference\n-     * through a function that returns an option.\n-     */\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n         match *self { Some(ref x) => f(x), None => None }\n     }\n \n     /// Maps a `some` value from one type to another by reference\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> {\n-        match *self { Some(ref x) => Some(f(x)), None => None }\n-    }\n-\n-    /// Maps a `some` value from one type to another by reference\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U> {\n         match *self { Some(ref x) => Some(f(x)), None => None }\n@@ -242,16 +200,6 @@ pub impl<T> Option<T> {\n     }\n \n     /// Applies a function to the contained value or returns a default\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n-        match *self { None => def, Some(ref t) => f(t) }\n-    }\n-\n-    /// Applies a function to the contained value or returns a default\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n         match *self { None => def, Some(ref t) => f(t) }\n@@ -295,32 +243,6 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn get_ref(&self) -> &'self T {\n-        match *self {\n-          Some(ref x) => x,\n-          None => fail!(~\"option::get_ref none\")\n-        }\n-    }\n-\n-    /**\n-    Gets an immutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n           Some(ref x) => x,\n@@ -343,32 +265,6 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn get_mut_ref(&mut self) -> &'self mut T {\n-        match *self {\n-          Some(ref mut x) => x,\n-          None => fail!(~\"option::get_mut_ref none\")\n-        }\n-    }\n-\n-    /**\n-    Gets a mutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n           Some(ref mut x) => x,"}, {"sha": "42401ae5a1fcdab61d70220f1032cfd9723ffc39", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -14,9 +14,6 @@\n \n pub use either::{Either, Left, Right};\n pub use kinds::{Const, Copy, Owned, Durable};\n-#[cfg(stage0)]\n-pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n-#[cfg(not(stage0))]\n pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Drop};"}, {"sha": "47de360f5899510abbdfefc713464c3bf1c47e4d", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -15,7 +15,7 @@ Runtime type reflection\n */\n \n use intrinsic::{TyDesc, TyVisitor};\n-#[cfg(not(stage0))] use intrinsic::Opaque;\n+use intrinsic::Opaque;\n use libc::c_void;\n use sys;\n use vec;\n@@ -394,17 +394,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enter_enum(&self, n_variants: uint, sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_enum(n_variants, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enter_enum(&self, n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         sz: uint, align: uint)\n@@ -428,15 +417,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_enum_variant_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n         self.inner.push_ptr();\n         self.bump(offset);\n@@ -457,17 +437,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_leave_enum(&self, n_variants: uint, sz: uint, align: uint)\n-                     -> bool {\n-        if ! self.inner.visit_leave_enum(n_variants, sz, align) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_leave_enum(&self, n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         sz: uint, align: uint) -> bool {"}, {"sha": "3d5259932592861d489ccf1bf6dc101a34e09819", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 1, "deletions": 110, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -18,12 +18,11 @@ use cast::transmute;\n use char;\n use intrinsic;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n-#[cfg(not(stage0))] use intrinsic::Opaque;\n+use intrinsic::Opaque;\n use io::{Writer, WriterUtil};\n use libc::c_void;\n use managed;\n use ptr;\n-#[cfg(stage0)] use sys;\n use reflect;\n use reflect::{MovePtr, align};\n use to_str::ToStr;\n@@ -138,14 +137,6 @@ impl Repr for char {\n \n // New implementation using reflect::MovePtr\n \n-#[cfg(stage0)]\n-enum VariantState {\n-    Degenerate,\n-    TagMatch,\n-    TagMismatch,\n-}\n-\n-#[cfg(not(stage0))]\n enum VariantState {\n     SearchingFor(int),\n     Matched,\n@@ -190,18 +181,6 @@ pub impl ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)] #[inline(always)]\n-    fn bump(&self, sz: uint) {\n-      do self.move_ptr() |p| {\n-            ((p as uint) + sz) as *c_void\n-      };\n-    }\n-\n-    #[cfg(stage0)] #[inline(always)]\n-    fn bump_past<T>(&self) {\n-        self.bump(sys::size_of::<T>());\n-    }\n-\n     #[inline(always)]\n     fn visit_inner(&self, inner: *TyDesc) -> bool {\n         self.visit_ptr_inner(self.ptr, inner)\n@@ -467,18 +446,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enter_enum(&self, n_variants: uint,\n-                        _sz: uint, _align: uint) -> bool {\n-        if n_variants == 1 {\n-            self.var_stk.push(Degenerate)\n-        } else {\n-            self.var_stk.push(TagMatch)\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enter_enum(&self, _n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool {\n@@ -487,40 +454,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enter_enum_variant(&self, _variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        let mut write = false;\n-        match self.var_stk.pop() {\n-            Degenerate => {\n-                write = true;\n-                self.var_stk.push(Degenerate);\n-            }\n-            TagMatch | TagMismatch => {\n-                do self.get::<int>() |t| {\n-                    if disr_val == *t {\n-                        write = true;\n-                        self.var_stk.push(TagMatch);\n-                    } else {\n-                        self.var_stk.push(TagMismatch);\n-                    }\n-                };\n-                self.bump_past::<int>();\n-            }\n-        }\n-\n-        if write {\n-            self.writer.write_str(name);\n-            if n_fields > 0 {\n-                self.writer.write_char('(');\n-            }\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enter_enum_variant(&self, _variant: uint,\n                                 disr_val: int,\n                                 n_fields: uint,\n@@ -549,23 +482,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n-        match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n-            Degenerate | TagMatch => {\n-                if i != 0 {\n-                    self.writer.write_str(\", \");\n-                }\n-                if ! self.visit_inner(inner) {\n-                    return false;\n-                }\n-            }\n-            TagMismatch => ()\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enum_variant_field(&self, i: uint, _offset: uint, inner: *TyDesc) -> bool {\n         match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n             Matched => {\n@@ -581,23 +497,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_leave_enum_variant(&self, _variant: uint,\n-                                _disr_val: int,\n-                                n_fields: uint,\n-                                _name: &str) -> bool {\n-        match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n-            Degenerate | TagMatch => {\n-                if n_fields > 0 {\n-                    self.writer.write_char(')');\n-                }\n-            }\n-            TagMismatch => ()\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_leave_enum_variant(&self, _variant: uint,\n                                 _disr_val: int,\n                                 n_fields: uint,\n@@ -613,14 +512,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_leave_enum(&self, _n_variants: uint,\n-                        _sz: uint, _align: uint) -> bool {\n-        self.var_stk.pop();\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_leave_enum(&self, _n_variants: uint,\n                         _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool {"}, {"sha": "17cc07c660d1af4d6b6fd2420c277bd849c5affd", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -226,13 +226,6 @@ pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n }\n \n pub impl<T, E> Result<T, E> {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn get_ref(&self) -> &'self T { get_ref(self) }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn get_ref<'a>(&'a self) -> &'a T { get_ref(self) }\n "}, {"sha": "97b3ee3e30ef65a50ee7abd3e374af5b3fa42aea", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -275,7 +275,6 @@ pub mod net {\n }\n \n /// Readers and Writers for memory buffers and strings.\n-#[cfg(not(stage0))] // XXX Using unsnapshotted features\n pub mod mem;\n \n /// Non-blocking access to stdin, stdout, stderr\n@@ -286,11 +285,9 @@ pub mod stdio;\n mod option;\n \n /// Basic stream compression. XXX: Belongs with other flate code\n-#[cfg(not(stage0))] // XXX Using unsnapshotted features\n pub mod flate;\n \n /// Interop between byte streams and pipes. Not sure where it belongs\n-#[cfg(not(stage0))] // XXX \"\n pub mod comm_adapters;\n \n /// Extension traits"}, {"sha": "a072fccd33d6c696a91bf2771452a2f7f8cb8ca7", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -37,27 +37,6 @@ mod local_heap;\n #[cfg(test)]\n pub mod test;\n \n-#[cfg(stage0)]\n-pub fn start(main: *u8, _argc: int, _argv: *c_char, _crate_map: *u8) -> int {\n-    use self::sched::{Scheduler, Task};\n-    use self::uvio::UvEventLoop;\n-\n-    let loop_ = ~UvEventLoop::new();\n-    let mut sched = ~Scheduler::new(loop_);\n-    let main_task = ~do Task::new(&mut sched.stack_pool) {\n-        // XXX: Can't call a C function pointer from Rust yet\n-        unsafe { rust_call_nullary_fn(main) };\n-    };\n-    sched.task_queue.push_back(main_task);\n-    sched.run();\n-    return 0;\n-\n-    extern {\n-        fn rust_call_nullary_fn(f: *u8);\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n     use self::sched::{Scheduler, Task};\n     use self::uvio::UvEventLoop;"}, {"sha": "fd64438c61b467db6daf1ade0757b99e2b2b0070", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -24,11 +24,6 @@ pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n     /// The asynchronous I/O services. Not all event loops may provide one\n-    #[cfg(stage0)]\n-    fn io(&mut self) -> Option<&'self mut IoFactoryObject>;\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }\n "}, {"sha": "ab8aea2b63c4f321c19ba331337dd0d5a4cc7370", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -68,14 +68,6 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn io(&mut self) -> Option<&'self mut IoFactoryObject> {\n-        Some(&mut self.uvio)\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n         Some(&mut self.uvio)\n     }\n@@ -98,14 +90,6 @@ fn test_callback_run_once() {\n pub struct UvIoFactory(Loop);\n \n pub impl UvIoFactory {\n-    #[cfg(stage0)]\n-    fn uv_loop(&mut self) -> &'self mut Loop {\n-        match self { &UvIoFactory(ref mut ptr) => ptr }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n         match self { &UvIoFactory(ref mut ptr) => ptr }\n     }"}, {"sha": "987d4064ab9f6bdb0d42ce4d0f78a17c4abd8cfa", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -93,9 +93,6 @@ pub mod rustrt {\n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     pub extern \"rust-intrinsic\" {\n-        #[cfg(stage0)]\n-        pub fn frame_address(f: &once fn(x: *u8));\n-        #[cfg(not(stage0))]\n         pub fn frame_address(+f: &once fn(x: *u8));\n     }\n }"}, {"sha": "4eca7ebbb371ed9efd9f0cff4cb1d4a5f2aedf3b", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -200,21 +200,6 @@ impl FailWithCause for &'static str {\n     }\n }\n \n-// NOTE: remove function after snapshot\n-#[cfg(stage0)]\n-pub fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n-\n-    do str::as_buf(msg) |msg_buf, _msg_len| {\n-        do str::as_buf(file) |file_buf, _file_len| {\n-            unsafe {\n-                let msg_buf = cast::transmute(msg_buf);\n-                let file_buf = cast::transmute(file_buf);\n-                begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n-            }\n-        }\n-    }\n-}\n-\n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use rt::{context, OldTaskContext};\n@@ -242,13 +227,6 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     }\n }\n \n-// NOTE: remove function after snapshot\n-#[cfg(stage0)]\n-pub fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n-    let (msg, file) = (msg.to_owned(), file.to_owned());\n-    begin_unwind(~\"assertion failed: \" + msg, file, line)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use cast;"}, {"sha": "f0756be994432743495172cff8d72a0cd093773f", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -56,16 +56,6 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all key-value pairs in order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&uint, &'self T) -> bool) {\n-        self.root.each(f);\n-    }\n-\n-    /// Visit all key-value pairs in order\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n         self.root.each(f);\n     }\n@@ -78,16 +68,6 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all values in order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_value(&self, f: &fn(&T) -> bool) {\n-        self.each(|_, v| f(v))\n-    }\n-\n-    /// Visit all values in order\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) {\n         self.each(|_, v| f(v))\n     }\n@@ -99,31 +79,6 @@ impl<T> Map<uint, T> for TrieMap<T> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    #[inline(hint)]\n-    fn find(&self, key: &uint) -> Option<&'self T> {\n-        let mut node: &'self TrieNode<T> = &self.root;\n-        let mut idx = 0;\n-        loop {\n-            match node.children[chunk(*key, idx)] {\n-              Internal(ref x) => node = &**x,\n-              External(stored, ref value) => {\n-                if stored == *key {\n-                    return Some(value)\n-                } else {\n-                    return None\n-                }\n-              }\n-              Nothing => return None\n-            }\n-            idx += 1;\n-        }\n-    }\n-\n-    /// Return a reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(hint)]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n         let mut node: &'a TrieNode<T> = &self.root;\n@@ -145,16 +100,6 @@ impl<T> Map<uint, T> for TrieMap<T> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn find_mut(&mut self, key: &uint) -> Option<&'self mut T> {\n-        find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n-    }\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n@@ -193,16 +138,6 @@ pub impl<T> TrieMap<T> {\n \n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) {\n-        self.root.each_reverse(f);\n-    }\n-\n-    /// Visit all key-value pairs in reverse order\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n         self.root.each_reverse(f);\n     }\n@@ -298,21 +233,6 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n-        for uint::range(0, self.children.len()) |idx| {\n-            match self.children[idx] {\n-                Internal(ref x) => if !x.each(f) { return false },\n-                External(k, ref v) => if !f(&k, v) { return false },\n-                Nothing => ()\n-            }\n-        }\n-        true\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n@@ -324,21 +244,6 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n-        for uint::range_rev(self.children.len(), 0) |idx| {\n-            match self.children[idx - 1] {\n-                Internal(ref x) => if !x.each_reverse(f) { return false },\n-                External(k, ref v) => if !f(&k, v) { return false },\n-                Nothing => ()\n-            }\n-        }\n-        true\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {"}, {"sha": "6da22657906ddbf45d76e90cd296ec180ad39763", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -56,39 +56,11 @@ impl<T:Clone,U:Clone> Clone for (T, U) {\n     }\n }\n \n-#[cfg(stage0)]\n-pub trait ImmutableTuple<T, U> {\n-    fn first_ref(&self) -> &'self T;\n-    fn second_ref(&self) -> &'self U;\n-}\n-\n-#[cfg(stage0)]\n-impl<T, U> ImmutableTuple<T, U> for (T, U) {\n-    #[inline(always)]\n-    fn first_ref(&self) -> &'self T {\n-        match *self {\n-            (ref t, _) => t,\n-        }\n-    }\n-    #[inline(always)]\n-    fn second_ref(&self) -> &'self U {\n-        match *self {\n-            (_, ref u) => u,\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub trait ImmutableTuple<T, U> {\n     fn first_ref<'a>(&'a self) -> &'a T;\n     fn second_ref<'a>(&'a self) -> &'a U;\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     #[inline(always)]\n     fn first_ref<'a>(&'a self) -> &'a T {"}, {"sha": "65cfc6ec1fe05e0db2d3bcd1148885583ab21ee3", "filename": "src/libcore/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -46,10 +46,6 @@ pub extern \"rust-intrinsic\" {\n \n     pub fn forget<T>(_: T) -> ();\n \n-    // XXX: intrinsic uses legacy modes\n-    #[cfg(stage0)]\n-    fn reinterpret_cast<T,U>(&&src: T) -> U;\n-\n     pub fn needs_drop<T>() -> bool;\n \n     // XXX: intrinsic uses legacy modes and has reference to TyDesc"}, {"sha": "7f6faa81012e8d9720de9d8ba5222002765e977c", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -17,9 +17,7 @@ use str;\n use sys;\n use unstable::exchange_alloc;\n use cast::transmute;\n-#[cfg(not(stage0))]\n use rt::{context, OldTaskContext};\n-#[cfg(not(stage0))]\n use rt::local_services::borrow_local_services;\n \n #[allow(non_camel_case_types)]\n@@ -91,14 +89,6 @@ pub unsafe fn exchange_free(ptr: *c_char) {\n }\n \n #[lang=\"malloc\"]\n-#[inline(always)]\n-#[cfg(stage0)] // For some reason this isn't working on windows in stage0\n-pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    return rustrt::rust_upcall_malloc_noswitch(td, size);\n-}\n-\n-#[lang=\"malloc\"]\n-#[cfg(not(stage0))]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     match context() {\n         OldTaskContext => {\n@@ -118,17 +108,6 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[lang=\"free\"]\n-#[inline(always)]\n-#[cfg(stage0)]\n-pub unsafe fn local_free(ptr: *c_char) {\n-    rustrt::rust_upcall_free_noswitch(ptr);\n-}\n-\n-// NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n-// inside a landing pad may corrupt the state of the exception handler. If a\n-// problem occurs, call exit instead.\n-#[lang=\"free\"]\n-#[cfg(not(stage0))]\n pub unsafe fn local_free(ptr: *c_char) {\n     match context() {\n         OldTaskContext => {\n@@ -176,32 +155,6 @@ pub unsafe fn strdup_uniq(ptr: *c_uchar, len: uint) -> ~str {\n }\n \n #[lang=\"start\"]\n-#[cfg(stage0)]\n-pub fn start(main: *u8, argc: int, argv: *c_char,\n-             crate_map: *u8) -> int {\n-    use libc::getenv;\n-    use rt::start;\n-\n-    unsafe {\n-        let use_old_rt = do str::as_c_str(\"RUST_NEWRT\") |s| {\n-            getenv(s).is_null()\n-        };\n-        if use_old_rt {\n-            return rust_start(main as *c_void, argc as c_int, argv,\n-                              crate_map as *c_void) as int;\n-        } else {\n-            return start(main, argc, argv, crate_map);\n-        }\n-    }\n-\n-    extern {\n-        fn rust_start(main: *c_void, argc: c_int, argv: *c_char,\n-                      crate_map: *c_void) -> c_int;\n-    }\n-}\n-\n-#[lang=\"start\"]\n-#[cfg(not(stage0))]\n pub fn start(main: *u8, argc: int, argv: **c_char,\n              crate_map: *u8) -> int {\n     use libc::getenv;"}, {"sha": "6ffb0b30917a32625a9939c7543d75c69462d07f", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -19,9 +19,6 @@ use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use old_iter::BaseIter;\n use old_iter;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n use iterator::Iterator;\n use kinds::Copy;\n use libc;\n@@ -1566,16 +1563,6 @@ pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n     }\n }\n \n-// see doc below\n-#[cfg(stage0)] // XXX: lifetimes!\n-pub fn windowed<T>(n: uint, v: &[T], it: &fn(&[T]) -> bool) {\n-    assert!(1u <= n);\n-    if n > v.len() { return; }\n-    for uint::range(0, v.len() - n + 1) |i| {\n-        if !it(v.slice(i, i+n)) { return }\n-    }\n-}\n-\n /**\n  * Iterate over all contiguous windows of length `n` of the vector `v`.\n  *\n@@ -1590,9 +1577,6 @@ pub fn windowed<T>(n: uint, v: &[T], it: &fn(&[T]) -> bool) {\n  * ~~~\n  *\n  */\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) {\n     assert!(1u <= n);\n     if n > v.len() { return; }\n@@ -1854,150 +1838,6 @@ impl<'self,T:Copy> CopyableVector<T> for &'self const [T] {\n     }\n }\n \n-#[cfg(stage0)]\n-pub trait ImmutableVector<T> {\n-    fn slice(&self, start: uint, end: uint) -> &'self [T];\n-    fn head(&self) -> &'self T;\n-    fn head_opt(&self) -> Option<&'self T>;\n-    fn tail(&self) -> &'self [T];\n-    fn tailn(&self, n: uint) -> &'self [T];\n-    fn init(&self) -> &'self [T];\n-    fn initn(&self, n: uint) -> &'self [T];\n-    fn last(&self) -> &'self T;\n-    fn last_opt(&self) -> Option<&'self T>;\n-    fn each_reverse(&self, blk: &fn(&T) -> bool);\n-    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n-    fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n-    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n-    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n-    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n-    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n-    unsafe fn unsafe_ref(&self, index: uint) -> *T;\n-}\n-\n-/// Extension methods for vectors\n-#[cfg(stage0)]\n-impl<'self,T> ImmutableVector<T> for &'self [T] {\n-    /// Return a slice that points into another slice.\n-    #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &'self [T] {\n-        slice(*self, start, end)\n-    }\n-\n-    /// Returns the first element of a vector, failing if the vector is empty.\n-    #[inline]\n-    fn head(&self) -> &'self T { head(*self) }\n-\n-    /// Returns the first element of a vector\n-    #[inline]\n-    fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n-\n-    /// Returns all but the first element of a vector\n-    #[inline]\n-    fn tail(&self) -> &'self [T] { tail(*self) }\n-\n-    /// Returns all but the first `n' elements of a vector\n-    #[inline]\n-    fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n-\n-    /// Returns all but the last elemnt of a vector\n-    #[inline]\n-    fn init(&self) -> &'self [T] { init(*self) }\n-\n-    /// Returns all but the last `n' elemnts of a vector\n-    #[inline]\n-    fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n-\n-    /// Returns the last element of a `v`, failing if the vector is empty.\n-    #[inline]\n-    fn last(&self) -> &'self T { last(*self) }\n-\n-    /// Returns the last element of a `v`, failing if the vector is empty.\n-    #[inline]\n-    fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n-\n-    /// Iterates over a vector's elements in reverse.\n-    #[inline]\n-    fn each_reverse(&self, blk: &fn(&T) -> bool) {\n-        each_reverse(*self, blk)\n-    }\n-\n-    /// Iterates over a vector's elements and indices in reverse.\n-    #[inline]\n-    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n-        eachi_reverse(*self, blk)\n-    }\n-\n-    /// Reduce a vector from right to left\n-    #[inline]\n-    fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n-        foldr(*self, z, p)\n-    }\n-\n-    /// Apply a function to each element of a vector and return the results\n-    #[inline]\n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n-\n-    /**\n-     * Apply a function to the index and value of each element in the vector\n-     * and return the results\n-     */\n-    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n-        mapi(*self, f)\n-    }\n-\n-    #[inline]\n-    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U] {\n-        let mut r = ~[];\n-        let mut i = 0;\n-        while i < self.len() {\n-            r.push(f(&self[i]));\n-            i += 1;\n-        }\n-        r\n-    }\n-\n-    /**\n-     * Returns true if the function returns true for all elements.\n-     *\n-     *     If the vector is empty, true is returned.\n-     */\n-    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n-        alli(*self, f)\n-    }\n-    /**\n-     * Apply a function to each element of a vector and return a concatenation\n-     * of each result vector\n-     */\n-    #[inline]\n-    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n-        flat_map(*self, f)\n-    }\n-    /**\n-     * Apply a function to each element of a vector and return the results\n-     *\n-     * If function `f` returns `none` then that element is excluded from\n-     * the resulting vector.\n-     */\n-    #[inline]\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n-        filter_mapped(*self, f)\n-    }\n-\n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    #[inline(always)]\n-    unsafe fn unsafe_ref(&self, index: uint) -> *T {\n-        let (ptr, _): (*T, uint) = transmute(*self);\n-        ptr.offset(index)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub trait ImmutableVector<'self, T> {\n     fn slice(&self, start: uint, end: uint) -> &'self [T];\n     fn iter(self) -> VecIterator<'self, T>;\n@@ -2022,9 +1862,6 @@ pub trait ImmutableVector<'self, T> {\n }\n \n /// Extension methods for vectors\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n@@ -2634,17 +2471,6 @@ pub mod bytes {\n // ___________________________________________________________________________\n // ITERATION TRAIT METHODS\n \n-#[cfg(stage0)]\n-impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n-    #[inline(always)]\n-    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n-    #[inline(always)]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n@@ -2653,18 +2479,6 @@ impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n }\n \n // FIXME(#4148): This should be redundant\n-#[cfg(stage0)]\n-impl<A> old_iter::BaseIter<A> for ~[A] {\n-    #[inline(always)]\n-    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n-    #[inline(always)]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<A> old_iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n@@ -2673,36 +2487,13 @@ impl<A> old_iter::BaseIter<A> for ~[A] {\n }\n \n // FIXME(#4148): This should be redundant\n-#[cfg(stage0)]\n-impl<A> old_iter::BaseIter<A> for @[A] {\n-    #[inline(always)]\n-    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n-    #[inline(always)]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<A> old_iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-#[cfg(stage0)]\n-impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n-    #[inline(always)]\n-    fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n-        each_mut(*self, blk)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n@@ -2711,17 +2502,6 @@ impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n }\n \n // FIXME(#4148): This should be redundant\n-#[cfg(stage0)]\n-impl<A> old_iter::MutableIter<A> for ~[A] {\n-    #[inline(always)]\n-    fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n-        each_mut(*self, blk)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<A> old_iter::MutableIter<A> for ~[A] {\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n@@ -2927,18 +2707,12 @@ impl<A:Clone> Clone for ~[A] {\n }\n \n // could be implemented with &[T] with .slice(), but this avoids bounds checks\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub struct VecIterator<'self, T> {\n     priv ptr: *T,\n     priv end: *T,\n     priv lifetime: &'self T // FIXME: #5922\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self, T> Iterator<&'self T> for VecIterator<'self, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {"}, {"sha": "1347fec5d667a338c6a026b367ce7fc0cada3a02", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -272,14 +272,6 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n     @bounds\n }\n \n-#[cfg(stage0)]\n-fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n-    reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n-        Decodable::decode(&reader::Decoder(*doc))\n-    })\n-}\n-\n-#[cfg(not(stage0))]\n fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n     reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n         let mut decoder = reader::Decoder(*doc);"}, {"sha": "6a9c564f36828575f43fe38c6db6e28282e7de85", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 116, "deletions": 1420, "changes": 1536, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -42,13 +42,6 @@ use writer = std::ebml::writer;\n // used by astencode:\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n-#[cfg(stage0)]\n-pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n-                                   ebml_w: &writer::Encoder,\n-                                   path: &[ast_map::path_elt],\n-                                   ii: ast::inlined_item);\n-\n-#[cfg(not(stage0))]\n pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    path: &[ast_map::path_elt],\n@@ -98,57 +91,23 @@ pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n     ecx.reachable.contains(&id)\n }\n \n-#[cfg(stage0)]\n-fn encode_name(ecx: @EncodeContext, ebml_w: &writer::Encoder, name: ident) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_name(ecx: @EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n }\n \n-#[cfg(stage0)]\n-fn encode_impl_type_basename(ecx: @EncodeContext,\n-                             ebml_w: &writer::Encoder,\n-                             name: ident) {\n-    ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n-                         *ecx.tcx.sess.str_of(name));\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_impl_type_basename(ecx: @EncodeContext,\n                              ebml_w: &mut writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          *ecx.tcx.sess.str_of(name));\n }\n \n-#[cfg(stage0)]\n-pub fn encode_def_id(ebml_w: &writer::Encoder, id: def_id) {\n-    ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n-}\n-\n-#[cfg(not(stage0))]\n pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-#[cfg(stage0)]\n-fn encode_region_param(ecx: @EncodeContext,\n-                       ebml_w: &writer::Encoder,\n-                       it: @ast::item) {\n-    let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n-    for opt_rp.each |rp| {\n-        do ebml_w.wr_tag(tag_region_param) {\n-            rp.encode(ebml_w);\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_region_param(ecx: @EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        it: @ast::item) {\n@@ -160,18 +119,6 @@ fn encode_region_param(ecx: @EncodeContext,\n     }\n }\n \n-#[cfg(stage0)]\n-fn encode_mutability(ebml_w: &writer::Encoder, mt: struct_mutability) {\n-    do ebml_w.wr_tag(tag_struct_mut) {\n-        let val = match mt {\n-          struct_immutable => 'a',\n-          struct_mutable => 'm'\n-        };\n-        ebml_w.writer.write(&[val as u8]);\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_mutability(ebml_w: &mut writer::Encoder, mt: struct_mutability) {\n     ebml_w.start_tag(tag_struct_mut);\n     let val = match mt {\n@@ -187,24 +134,6 @@ struct entry<T> {\n     pos: uint\n }\n \n-#[cfg(stage0)]\n-fn add_to_index(ecx: @EncodeContext,\n-                ebml_w: &writer::Encoder,\n-                path: &[ident],\n-                index: &mut ~[entry<~str>],\n-                name: ident) {\n-    let mut full_path = ~[];\n-    full_path.push_all(path);\n-    full_path.push(name);\n-    index.push(\n-        entry {\n-            val: ast_util::path_name_i(full_path,\n-                                       ecx.tcx.sess.parse_sess.interner),\n-            pos: ebml_w.writer.tell()\n-        });\n-}\n-\n-#[cfg(not(stage0))]\n fn add_to_index(ecx: @EncodeContext,\n                 ebml_w: &mut writer::Encoder,\n                 path: &[ident],\n@@ -221,24 +150,6 @@ fn add_to_index(ecx: @EncodeContext,\n         });\n }\n \n-#[cfg(stage0)]\n-fn encode_trait_ref(ebml_w: &writer::Encoder,\n-                    ecx: @EncodeContext,\n-                    trait_ref: &ty::TraitRef,\n-                    tag: uint) {\n-    let ty_str_ctxt = @tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_str,\n-        tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-\n-    ebml_w.start_tag(tag);\n-    tyencode::enc_trait_ref(ebml_w.writer, ty_str_ctxt, trait_ref);\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n                     ecx: @EncodeContext,\n                     trait_ref: &ty::TraitRef,\n@@ -256,15 +167,6 @@ fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n }\n \n // Item info table encoding\n-#[cfg(stage0)]\n-fn encode_family(ebml_w: &writer::Encoder, c: char) {\n-    ebml_w.start_tag(tag_items_data_item_family);\n-    ebml_w.writer.write(&[c as u8]);\n-    ebml_w.end_tag();\n-}\n-\n-// Item info table encoding\n-#[cfg(not(stage0))]\n fn encode_family(ebml_w: &mut writer::Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n@@ -275,25 +177,6 @@ pub fn def_to_str(did: def_id) -> ~str {\n     fmt!(\"%d:%d\", did.crate, did.node)\n }\n \n-#[cfg(stage0)]\n-fn encode_ty_type_param_defs(ebml_w: &writer::Encoder,\n-                             ecx: @EncodeContext,\n-                             params: @~[ty::TypeParameterDef],\n-                             tag: uint) {\n-    let ty_str_ctxt = @tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_str,\n-        tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-    for params.each |param| {\n-        ebml_w.start_tag(tag);\n-        tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n-        ebml_w.end_tag();\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n                              ecx: @EncodeContext,\n                              params: @~[ty::TypeParameterDef],\n@@ -311,17 +194,6 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n     }\n }\n \n-#[cfg(stage0)]\n-fn encode_type_param_bounds(ebml_w: &writer::Encoder,\n-                            ecx: @EncodeContext,\n-                            params: &OptVec<TyParam>) {\n-    let ty_param_defs =\n-        @params.map_to_vec(|param| *ecx.tcx.ty_param_defs.get(&param.id));\n-    encode_ty_type_param_defs(ebml_w, ecx, ty_param_defs,\n-                              tag_items_data_item_ty_param_bounds);\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n                             ecx: @EncodeContext,\n                             params: &OptVec<TyParam>) {\n@@ -331,32 +203,12 @@ fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n                               tag_items_data_item_ty_param_bounds);\n }\n \n-#[cfg(stage0)]\n-fn encode_variant_id(ebml_w: &writer::Encoder, vid: def_id) {\n-    ebml_w.start_tag(tag_items_data_item_variant);\n-    ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-pub fn write_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n-    let ty_str_ctxt = @tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_str,\n-        tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-    tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n-}\n-\n-#[cfg(not(stage0))]\n pub fn write_type(ecx: @EncodeContext,\n                   ebml_w: &mut writer::Encoder,\n                   typ: ty::t) {\n@@ -369,20 +221,6 @@ pub fn write_type(ecx: @EncodeContext,\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-#[cfg(stage0)]\n-pub fn write_vstore(ecx: @EncodeContext,\n-                    ebml_w: &writer::Encoder,\n-                    vstore: ty::vstore) {\n-    let ty_str_ctxt = @tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_str,\n-        tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-    tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n-}\n-\n-#[cfg(not(stage0))]\n pub fn write_vstore(ecx: @EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     vstore: ty::vstore) {\n@@ -395,14 +233,6 @@ pub fn write_vstore(ecx: @EncodeContext,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-#[cfg(stage0)]\n-fn encode_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n-    ebml_w.start_tag(tag_items_data_item_type);\n-    write_type(ecx, ebml_w, typ);\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_type(ecx: @EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                typ: ty::t) {\n@@ -411,18 +241,6 @@ fn encode_type(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_transformed_self_ty(ecx: @EncodeContext,\n-                              ebml_w: &writer::Encoder,\n-                              opt_typ: Option<ty::t>) {\n-    for opt_typ.each |&typ| {\n-        ebml_w.start_tag(tag_item_method_transformed_self_ty);\n-        write_type(ecx, ebml_w, typ);\n-        ebml_w.end_tag();\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_transformed_self_ty(ecx: @EncodeContext,\n                               ebml_w: &mut writer::Encoder,\n                               opt_typ: Option<ty::t>) {\n@@ -433,24 +251,6 @@ fn encode_transformed_self_ty(ecx: @EncodeContext,\n     }\n }\n \n-#[cfg(stage0)]\n-fn encode_method_fty(ecx: @EncodeContext,\n-                     ebml_w: &writer::Encoder,\n-                     typ: &ty::BareFnTy) {\n-    ebml_w.start_tag(tag_item_method_fty);\n-\n-    let ty_str_ctxt = @tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_str,\n-        tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-    tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n-\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_method_fty(ecx: @EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      typ: &ty::BareFnTy) {\n@@ -467,23 +267,6 @@ fn encode_method_fty(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_symbol(ecx: @EncodeContext, ebml_w: &writer::Encoder, id: node_id) {\n-    ebml_w.start_tag(tag_items_data_item_symbol);\n-    match ecx.item_symbols.find(&id) {\n-        Some(x) => {\n-            debug!(\"encode_symbol(id=%?, str=%s)\", id, *x);\n-            ebml_w.writer.write(str::to_bytes(*x));\n-        }\n-        None => {\n-            ecx.diag.handler().bug(\n-                fmt!(\"encode_symbol: id not found %d\", id));\n-        }\n-    }\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_symbol(ecx: @EncodeContext,\n                  ebml_w: &mut writer::Encoder,\n                  id: node_id) {\n@@ -501,16 +284,6 @@ fn encode_symbol(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_discriminant(ecx: @EncodeContext,\n-                       ebml_w: &writer::Encoder,\n-                       id: node_id) {\n-    ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::to_bytes(**ecx.discrim_symbols.get(&id)));\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_discriminant(ecx: @EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        id: node_id) {\n@@ -519,16 +292,6 @@ fn encode_discriminant(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_disr_val(_: @EncodeContext,\n-                   ebml_w: &writer::Encoder,\n-                   disr_val: int) {\n-    ebml_w.start_tag(tag_disr_val);\n-    ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_disr_val(_: @EncodeContext,\n                    ebml_w: &mut writer::Encoder,\n                    disr_val: int) {\n@@ -537,65 +300,12 @@ fn encode_disr_val(_: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_parent_item(ebml_w: &writer::Encoder, id: def_id) {\n-    ebml_w.start_tag(tag_items_data_parent_item);\n-    ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_parent_item(ebml_w: &mut writer::Encoder, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_enum_variant_info(ecx: @EncodeContext,\n-                            ebml_w: &writer::Encoder,\n-                            id: node_id,\n-                            variants: &[variant],\n-                            path: &[ast_map::path_elt],\n-                            index: @mut ~[entry<int>],\n-                            generics: &ast::Generics) {\n-    debug!(\"encode_enum_variant_info(id=%?)\", id);\n-\n-    let mut disr_val = 0;\n-    let mut i = 0;\n-    let vi = ty::enum_variants(ecx.tcx,\n-                               ast::def_id { crate: local_crate, node: id });\n-    for variants.each |variant| {\n-        index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(variant.node.id));\n-        encode_family(ebml_w, 'v');\n-        encode_name(ecx, ebml_w, variant.node.name);\n-        encode_parent_item(ebml_w, local_def(id));\n-        encode_type(ecx, ebml_w,\n-                    node_id_to_type(ecx.tcx, variant.node.id));\n-        match variant.node.kind {\n-            ast::tuple_variant_kind(ref args)\n-                    if args.len() > 0 && generics.ty_params.len() == 0 => {\n-                encode_symbol(ecx, ebml_w, variant.node.id);\n-            }\n-            ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) => {}\n-        }\n-        encode_discriminant(ecx, ebml_w, variant.node.id);\n-        if vi[i].disr_val != disr_val {\n-            encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n-            disr_val = vi[i].disr_val;\n-        }\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_path(ecx, ebml_w, path,\n-                    ast_map::path_name(variant.node.name));\n-        ebml_w.end_tag();\n-        disr_val += 1;\n-        i += 1;\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_enum_variant_info(ecx: @EncodeContext,\n                             ebml_w: &mut writer::Encoder,\n                             id: node_id,\n@@ -639,31 +349,6 @@ fn encode_enum_variant_info(ecx: @EncodeContext,\n     }\n }\n \n-#[cfg(stage0)]\n-fn encode_path(ecx: @EncodeContext,\n-               ebml_w: &writer::Encoder,\n-               path: &[ast_map::path_elt],\n-               name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                       elt: ast_map::path_elt) {\n-        let (tag, name) = match elt {\n-          ast_map::path_mod(name) => (tag_path_elt_mod, name),\n-          ast_map::path_name(name) => (tag_path_elt_name, name)\n-        };\n-\n-        ebml_w.wr_tagged_str(tag, *ecx.tcx.sess.str_of(name));\n-    }\n-\n-    do ebml_w.wr_tag(tag_path) {\n-        ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n-        for path.each |pe| {\n-            encode_path_elt(ecx, ebml_w, *pe);\n-        }\n-        encode_path_elt(ecx, ebml_w, name);\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_path(ecx: @EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                path: &[ast_map::path_elt],\n@@ -688,9 +373,8 @@ fn encode_path(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n fn encode_info_for_mod(ecx: @EncodeContext,\n-                       ebml_w: &writer::Encoder,\n+                       ebml_w: &mut writer::Encoder,\n                        md: &_mod,\n                        id: node_id,\n                        path: &[ast_map::path_elt],\n@@ -750,101 +434,15 @@ fn encode_info_for_mod(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(not(stage0))]\n-fn encode_info_for_mod(ecx: @EncodeContext,\n-                       ebml_w: &mut writer::Encoder,\n-                       md: &_mod,\n-                       id: node_id,\n-                       path: &[ast_map::path_elt],\n-                       name: ident) {\n-    ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(id));\n-    encode_family(ebml_w, 'm');\n-    encode_name(ecx, ebml_w, name);\n-    debug!(\"(encoding info for module) encoding info for module ID %d\", id);\n+fn encode_struct_field_family(ebml_w: &mut writer::Encoder,\n+                              visibility: visibility) {\n+    encode_family(ebml_w, match visibility {\n+        public => 'g',\n+        private => 'j',\n+        inherited => 'N'\n+    });\n+}\n \n-    // Encode info about all the module children.\n-    for md.items.each |item| {\n-        match item.node {\n-            item_impl(*) => {\n-                let (ident, did) = (item.ident, item.id);\n-                debug!(\"(encoding info for module) ... encoding impl %s \\\n-                        (%?/%?)\",\n-                        *ecx.tcx.sess.str_of(ident),\n-                        did,\n-                        ast_map::node_id_to_str(ecx.tcx.items, did, ecx.tcx\n-                                                .sess.parse_sess.interner));\n-\n-                ebml_w.start_tag(tag_mod_impl);\n-                ebml_w.wr_str(def_to_str(local_def(did)));\n-                ebml_w.end_tag();\n-            }\n-            _ => {} // FIXME #4573: Encode these too.\n-        }\n-    }\n-\n-    encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n-\n-    // Encode the reexports of this module.\n-    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n-    match ecx.reexports2.find(&id) {\n-        Some(ref exports) => {\n-            debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for exports.each |exp| {\n-                debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       *exp.name, id);\n-                ebml_w.start_tag(tag_items_data_item_reexport);\n-                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                ebml_w.wr_str(def_to_str(exp.def_id));\n-                ebml_w.end_tag();\n-                ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(*exp.name);\n-                ebml_w.end_tag();\n-                ebml_w.end_tag();\n-            }\n-        }\n-        None => {\n-            debug!(\"(encoding info for module) found no reexports for %d\",\n-                   id);\n-        }\n-    }\n-\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(stage0)]\n-fn encode_struct_field_family(ebml_w: &writer::Encoder,\n-                              visibility: visibility) {\n-    encode_family(ebml_w, match visibility {\n-        public => 'g',\n-        private => 'j',\n-        inherited => 'N'\n-    });\n-}\n-\n-#[cfg(not(stage0))]\n-fn encode_struct_field_family(ebml_w: &mut writer::Encoder,\n-                              visibility: visibility) {\n-    encode_family(ebml_w, match visibility {\n-        public => 'g',\n-        private => 'j',\n-        inherited => 'N'\n-    });\n-}\n-\n-#[cfg(stage0)]\n-fn encode_visibility(ebml_w: &writer::Encoder, visibility: visibility) {\n-    ebml_w.start_tag(tag_items_data_item_visibility);\n-    let ch = match visibility {\n-        public => 'y',\n-        private => 'n',\n-        inherited => 'i',\n-    };\n-    ebml_w.wr_str(str::from_char(ch));\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: visibility) {\n     ebml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n@@ -856,52 +454,6 @@ fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: visibility) {\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_self_type(ebml_w: &writer::Encoder, self_type: ast::self_ty_) {\n-    ebml_w.start_tag(tag_item_trait_method_self_ty);\n-\n-    // Encode the base self type.\n-    match self_type {\n-        sty_static => {\n-            ebml_w.writer.write(&[ 's' as u8 ]);\n-        }\n-        sty_value => {\n-            ebml_w.writer.write(&[ 'v' as u8 ]);\n-        }\n-        sty_region(_, m) => {\n-            // FIXME(#4846) encode custom lifetime\n-            ebml_w.writer.write(&[ '&' as u8 ]);\n-            encode_mutability(ebml_w, m);\n-        }\n-        sty_box(m) => {\n-            ebml_w.writer.write(&[ '@' as u8 ]);\n-            encode_mutability(ebml_w, m);\n-        }\n-        sty_uniq(m) => {\n-            ebml_w.writer.write(&[ '~' as u8 ]);\n-            encode_mutability(ebml_w, m);\n-        }\n-    }\n-\n-    ebml_w.end_tag();\n-\n-    fn encode_mutability(ebml_w: &writer::Encoder,\n-                         m: ast::mutability) {\n-        match m {\n-            m_imm => {\n-                ebml_w.writer.write(&[ 'i' as u8 ]);\n-            }\n-            m_mutbl => {\n-                ebml_w.writer.write(&[ 'm' as u8 ]);\n-            }\n-            m_const => {\n-                ebml_w.writer.write(&[ 'c' as u8 ]);\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_self_type(ebml_w: &mut writer::Encoder, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n@@ -946,62 +498,13 @@ fn encode_self_type(ebml_w: &mut writer::Encoder, self_type: ast::self_ty_) {\n     }\n }\n \n-#[cfg(stage0)]\n-fn encode_method_sort(ebml_w: &writer::Encoder, sort: char) {\n-    ebml_w.start_tag(tag_item_trait_method_sort);\n-    ebml_w.writer.write(&[ sort as u8 ]);\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n     ebml_w.start_tag(tag_item_trait_method_sort);\n     ebml_w.writer.write(&[ sort as u8 ]);\n     ebml_w.end_tag();\n }\n \n /* Returns an index of items in this class */\n-#[cfg(stage0)]\n-fn encode_info_for_struct(ecx: @EncodeContext,\n-                          ebml_w: &writer::Encoder,\n-                          path: &[ast_map::path_elt],\n-                          fields: &[@struct_field],\n-                          global_index: @mut~[entry<int>])\n-                          -> ~[entry<int>] {\n-    /* Each class has its own index, since different classes\n-       may have fields with the same name */\n-    let index = @mut ~[];\n-    let tcx = ecx.tcx;\n-     /* We encode both private and public fields -- need to include\n-        private fields to get the offsets right */\n-    for fields.each |field| {\n-        let (nm, mt, vis) = match field.node.kind {\n-            named_field(nm, mt, vis) => (nm, mt, vis),\n-            unnamed_field => (\n-                special_idents::unnamed_field,\n-                struct_immutable,\n-                inherited\n-            )\n-        };\n-\n-        let id = field.node.id;\n-        index.push(entry {val: id, pos: ebml_w.writer.tell()});\n-        global_index.push(entry {val: id, pos: ebml_w.writer.tell()});\n-        ebml_w.start_tag(tag_items_data_item);\n-        debug!(\"encode_info_for_struct: doing %s %d\",\n-               *tcx.sess.str_of(nm), id);\n-        encode_struct_field_family(ebml_w, vis);\n-        encode_name(ecx, ebml_w, nm);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n-        encode_mutability(ebml_w, mt);\n-        encode_def_id(ebml_w, local_def(id));\n-        ebml_w.end_tag();\n-    }\n-    /*bad*/copy *index\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_info_for_struct(ecx: @EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           path: &[ast_map::path_elt],\n@@ -1042,37 +545,6 @@ fn encode_info_for_struct(ecx: @EncodeContext,\n }\n \n // This is for encoding info for ctors and dtors\n-#[cfg(stage0)]\n-fn encode_info_for_ctor(ecx: @EncodeContext,\n-                        ebml_w: &writer::Encoder,\n-                        id: node_id,\n-                        ident: ident,\n-                        path: &[ast_map::path_elt],\n-                        item: Option<inlined_item>,\n-                        generics: &ast::Generics) {\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_name(ecx, ebml_w, ident);\n-        encode_def_id(ebml_w, local_def(id));\n-        encode_family(ebml_w, purity_fn_family(ast::impure_fn));\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        let its_ty = node_id_to_type(ecx.tcx, id);\n-        debug!(\"fn name = %s ty = %s its node id = %d\",\n-               *ecx.tcx.sess.str_of(ident),\n-               ty_to_str(ecx.tcx, its_ty), id);\n-        encode_type(ecx, ebml_w, its_ty);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n-        match item {\n-           Some(it) => {\n-             (ecx.encode_inlined_item)(ecx, ebml_w, path, it);\n-           }\n-           None => {\n-             encode_symbol(ecx, ebml_w, id);\n-           }\n-        }\n-        ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_info_for_ctor(ecx: @EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         id: node_id,\n@@ -1094,512 +566,121 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n         match item {\n            Some(it) => {\n              (ecx.encode_inlined_item)(ecx, ebml_w, path, it);\n-           }\n-           None => {\n-             encode_symbol(ecx, ebml_w, id);\n-           }\n-        }\n-        ebml_w.end_tag();\n-}\n-\n-#[cfg(stage0)]\n-fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n-                               ebml_w: &writer::Encoder,\n-                               path: &[ast_map::path_elt],\n-                               name: ast::ident,\n-                               ctor_id: node_id,\n-                               index: @mut ~[entry<int>]) {\n-    index.push(entry { val: ctor_id, pos: ebml_w.writer.tell() });\n-\n-    ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(ctor_id));\n-    encode_family(ebml_w, 'f');\n-    encode_name(ecx, ebml_w, name);\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, ctor_id));\n-    encode_path(ecx, ebml_w, path, ast_map::path_name(name));\n-\n-    if ecx.item_symbols.contains_key(&ctor_id) {\n-        encode_symbol(ecx, ebml_w, ctor_id);\n-    }\n-\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n-fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n-                               ebml_w: &mut writer::Encoder,\n-                               path: &[ast_map::path_elt],\n-                               name: ast::ident,\n-                               ctor_id: node_id,\n-                               index: @mut ~[entry<int>]) {\n-    index.push(entry { val: ctor_id, pos: ebml_w.writer.tell() });\n-\n-    ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(ctor_id));\n-    encode_family(ebml_w, 'f');\n-    encode_name(ecx, ebml_w, name);\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, ctor_id));\n-    encode_path(ecx, ebml_w, path, ast_map::path_name(name));\n-\n-    if ecx.item_symbols.contains_key(&ctor_id) {\n-        encode_symbol(ecx, ebml_w, ctor_id);\n-    }\n-\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(stage0)]\n-fn encode_method_ty_fields(ecx: @EncodeContext,\n-                           ebml_w: &writer::Encoder,\n-                           method_ty: &ty::method) {\n-    encode_def_id(ebml_w, method_ty.def_id);\n-    encode_name(ecx, ebml_w, method_ty.ident);\n-    encode_ty_type_param_defs(ebml_w, ecx,\n-                              method_ty.generics.type_param_defs,\n-                              tag_item_method_tps);\n-    encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n-    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n-    encode_visibility(ebml_w, method_ty.vis);\n-    encode_self_type(ebml_w, method_ty.self_ty);\n-}\n-\n-#[cfg(not(stage0))]\n-fn encode_method_ty_fields(ecx: @EncodeContext,\n-                           ebml_w: &mut writer::Encoder,\n-                           method_ty: &ty::method) {\n-    encode_def_id(ebml_w, method_ty.def_id);\n-    encode_name(ecx, ebml_w, method_ty.ident);\n-    encode_ty_type_param_defs(ebml_w, ecx,\n-                              method_ty.generics.type_param_defs,\n-                              tag_item_method_tps);\n-    encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n-    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n-    encode_visibility(ebml_w, method_ty.vis);\n-    encode_self_type(ebml_w, method_ty.self_ty);\n-}\n-\n-#[cfg(stage0)]\n-fn encode_info_for_method(ecx: @EncodeContext,\n-                          ebml_w: &writer::Encoder,\n-                          impl_path: &[ast_map::path_elt],\n-                          should_inline: bool,\n-                          parent_id: node_id,\n-                          m: @method,\n-                          owner_generics: &ast::Generics,\n-                          method_generics: &ast::Generics) {\n-    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n-           *ecx.tcx.sess.str_of(m.ident),\n-           owner_generics.ty_params.len(),\n-           method_generics.ty_params.len());\n-    ebml_w.start_tag(tag_items_data_item);\n-\n-    let method_def_id = local_def(m.id);\n-    let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n-    encode_method_ty_fields(ecx, ebml_w, method_ty);\n-\n-    match m.self_ty.node {\n-        ast::sty_static => {\n-            encode_family(ebml_w, purity_static_method_family(m.purity));\n-        }\n-        _ => encode_family(ebml_w, purity_fn_family(m.purity))\n-    }\n-\n-    let mut combined_ty_params = opt_vec::Empty;\n-    combined_ty_params.push_all(&owner_generics.ty_params);\n-    combined_ty_params.push_all(&method_generics.ty_params);\n-    let len = combined_ty_params.len();\n-    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n-\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n-    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n-\n-    if len > 0u || should_inline {\n-        (ecx.encode_inlined_item)(\n-           ecx, ebml_w, impl_path,\n-           ii_method(local_def(parent_id), m));\n-    } else {\n-        encode_symbol(ecx, ebml_w, m.id);\n-    }\n-\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n-fn encode_info_for_method(ecx: @EncodeContext,\n-                          ebml_w: &mut writer::Encoder,\n-                          impl_path: &[ast_map::path_elt],\n-                          should_inline: bool,\n-                          parent_id: node_id,\n-                          m: @method,\n-                          owner_generics: &ast::Generics,\n-                          method_generics: &ast::Generics) {\n-    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n-           *ecx.tcx.sess.str_of(m.ident),\n-           owner_generics.ty_params.len(),\n-           method_generics.ty_params.len());\n-    ebml_w.start_tag(tag_items_data_item);\n-\n-    let method_def_id = local_def(m.id);\n-    let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n-    encode_method_ty_fields(ecx, ebml_w, method_ty);\n-\n-    match m.self_ty.node {\n-        ast::sty_static => {\n-            encode_family(ebml_w, purity_static_method_family(m.purity));\n-        }\n-        _ => encode_family(ebml_w, purity_fn_family(m.purity))\n-    }\n-\n-    let mut combined_ty_params = opt_vec::Empty;\n-    combined_ty_params.push_all(&owner_generics.ty_params);\n-    combined_ty_params.push_all(&method_generics.ty_params);\n-    let len = combined_ty_params.len();\n-    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n-\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n-    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n-\n-    if len > 0u || should_inline {\n-        (ecx.encode_inlined_item)(\n-           ecx, ebml_w, impl_path,\n-           ii_method(local_def(parent_id), m));\n-    } else {\n-        encode_symbol(ecx, ebml_w, m.id);\n-    }\n-\n-    ebml_w.end_tag();\n-}\n-\n-fn purity_fn_family(p: purity) -> char {\n-    match p {\n-      unsafe_fn => 'u',\n-      pure_fn => 'p',\n-      impure_fn => 'f',\n-      extern_fn => 'e'\n-    }\n-}\n-\n-fn purity_static_method_family(p: purity) -> char {\n-    match p {\n-      unsafe_fn => 'U',\n-      pure_fn => 'P',\n-      impure_fn => 'F',\n-      _ => fail!(~\"extern fn can't be static\")\n-    }\n-}\n-\n-\n-fn should_inline(attrs: &[attribute]) -> bool {\n-    match attr::find_inline_attr(attrs) {\n-        attr::ia_none | attr::ia_never  => false,\n-        attr::ia_hint | attr::ia_always => true\n-    }\n-}\n-\n-#[cfg(stage0)]\n-fn encode_info_for_item(ecx: @EncodeContext,\n-                        ebml_w: &writer::Encoder,\n-                        item: @item,\n-                        index: @mut ~[entry<int>],\n-                        path: &[ast_map::path_elt]) {\n-    let tcx = ecx.tcx;\n-    let must_write =\n-        match item.node {\n-          item_enum(_, _) | item_impl(*) | item_trait(*) | item_struct(*) |\n-          item_mod(*) | item_foreign_mod(*) | item_const(*) => true,\n-          _ => false\n-        };\n-    if !must_write && !reachable(ecx, item.id) { return; }\n-\n-    fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n-                     index: @mut ~[entry<int>]) {\n-        index.push(entry { val: item.id, pos: ebml_w.writer.tell() });\n-    }\n-    let add_to_index: &fn() = || add_to_index_(item, ebml_w, index);\n-\n-    debug!(\"encoding info for item at %s\",\n-           ecx.tcx.sess.codemap.span_to_str(item.span));\n-\n-    match item.node {\n-      item_const(_, _) => {\n-        add_to_index();\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'c');\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_symbol(ecx, ebml_w, item.id);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n-        ebml_w.end_tag();\n-      }\n-      item_fn(_, purity, _, ref generics, _) => {\n-        add_to_index();\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, purity_fn_family(purity));\n-        let tps_len = generics.ty_params.len();\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_attributes(ebml_w, item.attrs);\n-        if tps_len > 0u || should_inline(item.attrs) {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n-        } else {\n-            encode_symbol(ecx, ebml_w, item.id);\n-        }\n-        ebml_w.end_tag();\n-      }\n-      item_mod(ref m) => {\n-        add_to_index();\n-        encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n-      }\n-      item_foreign_mod(_) => {\n-        add_to_index();\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'n');\n-        encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        ebml_w.end_tag();\n-      }\n-      item_ty(_, ref generics) => {\n-        add_to_index();\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'y');\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ecx, ebml_w, item);\n-        ebml_w.end_tag();\n-      }\n-      item_enum(ref enum_definition, ref generics) => {\n-        add_to_index();\n-        do ebml_w.wr_tag(tag_items_data_item) {\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_family(ebml_w, 't');\n-            encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-            encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-            encode_name(ecx, ebml_w, item.ident);\n-            for (*enum_definition).variants.each |v| {\n-                encode_variant_id(ebml_w, local_def(v.node.id));\n-            }\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n-            encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-            encode_region_param(ecx, ebml_w, item);\n-        }\n-        encode_enum_variant_info(ecx,\n-                                 ebml_w,\n-                                 item.id,\n-                                 (*enum_definition).variants,\n-                                 path,\n-                                 index,\n-                                 generics);\n-      }\n-      item_struct(struct_def, ref generics) => {\n-        /* First, encode the fields\n-           These come first because we need to write them to make\n-           the index, and the index needs to be in the item for the\n-           class itself */\n-        let idx = encode_info_for_struct(ecx, ebml_w, path,\n-                                         struct_def.fields, index);\n-\n-        /* Index the class*/\n-        add_to_index();\n-\n-        /* Now, make an item for the class itself */\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'S');\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-\n-        // If this is a tuple- or enum-like struct, encode the type of the\n-        // constructor.\n-        if struct_def.fields.len() > 0 &&\n-                struct_def.fields[0].node.kind == ast::unnamed_field {\n-            let ctor_id = match struct_def.ctor_id {\n-                Some(ctor_id) => ctor_id,\n-                None => ecx.tcx.sess.bug(~\"struct def didn't have ctor id\"),\n-            };\n-\n-            encode_info_for_struct_ctor(ecx,\n-                                        ebml_w,\n-                                        path,\n-                                        item.ident,\n-                                        ctor_id,\n-                                        index);\n-        }\n-\n-        encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ecx, ebml_w, item);\n-\n-        /* Encode def_ids for each field and method\n-         for methods, write all the stuff get_trait_method\n-        needs to know*/\n-        for struct_def.fields.each |f| {\n-            match f.node.kind {\n-                named_field(ident, _, vis) => {\n-                   ebml_w.start_tag(tag_item_field);\n-                   encode_struct_field_family(ebml_w, vis);\n-                   encode_name(ecx, ebml_w, ident);\n-                   encode_def_id(ebml_w, local_def(f.node.id));\n-                   ebml_w.end_tag();\n-                }\n-                unnamed_field => {\n-                    ebml_w.start_tag(tag_item_unnamed_field);\n-                    encode_def_id(ebml_w, local_def(f.node.id));\n-                    ebml_w.end_tag();\n-                }\n-            }\n-        }\n-\n-        /* Each class has its own index -- encode it */\n-        let bkts = create_index(idx);\n-        encode_index(ebml_w, bkts, write_int);\n-        ebml_w.end_tag();\n-      }\n-      item_impl(ref generics, opt_trait, ty, ref methods) => {\n-        add_to_index();\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'i');\n-        encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_name(ecx, ebml_w, item.ident);\n-        encode_attributes(ebml_w, item.attrs);\n-        match ty.node {\n-            ast::ty_path(path, _) if path.idents.len() == 1 => {\n-                encode_impl_type_basename(ecx, ebml_w,\n-                                          ast_util::path_to_ident(path));\n-            }\n-            _ => {}\n-        }\n-        for methods.each |m| {\n-            ebml_w.start_tag(tag_item_impl_method);\n-            let method_def_id = local_def(m.id);\n-            ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n-            ebml_w.end_tag();\n-        }\n-        for opt_trait.each |ast_trait_ref| {\n-            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n-        }\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        ebml_w.end_tag();\n-\n-        // >:-<\n-        let mut impl_path = vec::append(~[], path);\n-        impl_path += ~[ast_map::path_name(item.ident)];\n-\n-        for methods.each |m| {\n-            index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n-            encode_info_for_method(ecx,\n-                                   ebml_w,\n-                                   impl_path,\n-                                   should_inline(m.attrs),\n-                                   item.id,\n-                                   *m,\n-                                   generics,\n-                                   &m.generics);\n-        }\n-      }\n-      item_trait(ref generics, ref super_traits, ref ms) => {\n-        add_to_index();\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'I');\n-        encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        let trait_def = ty::lookup_trait_def(tcx, local_def(item.id));\n-        encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-        encode_name(ecx, ebml_w, item.ident);\n-        encode_attributes(ebml_w, item.attrs);\n-        for ty::trait_method_def_ids(tcx, local_def(item.id)).each |&method_def_id| {\n-            ebml_w.start_tag(tag_item_trait_method);\n-            encode_def_id(ebml_w, method_def_id);\n-            ebml_w.end_tag();\n-        }\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        for super_traits.each |ast_trait_ref| {\n-            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n+           }\n+           None => {\n+             encode_symbol(ecx, ebml_w, id);\n+           }\n         }\n         ebml_w.end_tag();\n+}\n \n-        // Now output the method info for each method.\n-        for ty::trait_method_def_ids(tcx, local_def(item.id)).eachi |i, &method_def_id| {\n-            assert!(method_def_id.crate == ast::local_crate);\n+fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n+                               ebml_w: &mut writer::Encoder,\n+                               path: &[ast_map::path_elt],\n+                               name: ast::ident,\n+                               ctor_id: node_id,\n+                               index: @mut ~[entry<int>]) {\n+    index.push(entry { val: ctor_id, pos: ebml_w.writer.tell() });\n \n-            let method_ty: @ty::method = ty::method(tcx, method_def_id);\n+    ebml_w.start_tag(tag_items_data_item);\n+    encode_def_id(ebml_w, local_def(ctor_id));\n+    encode_family(ebml_w, 'f');\n+    encode_name(ecx, ebml_w, name);\n+    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, ctor_id));\n+    encode_path(ecx, ebml_w, path, ast_map::path_name(name));\n \n-            index.push(entry {val: method_def_id.node, pos: ebml_w.writer.tell()});\n+    if ecx.item_symbols.contains_key(&ctor_id) {\n+        encode_symbol(ecx, ebml_w, ctor_id);\n+    }\n \n-            ebml_w.start_tag(tag_items_data_item);\n+    ebml_w.end_tag();\n+}\n \n-            encode_method_ty_fields(ecx, ebml_w, method_ty);\n+fn encode_method_ty_fields(ecx: @EncodeContext,\n+                           ebml_w: &mut writer::Encoder,\n+                           method_ty: &ty::method) {\n+    encode_def_id(ebml_w, method_ty.def_id);\n+    encode_name(ecx, ebml_w, method_ty.ident);\n+    encode_ty_type_param_defs(ebml_w, ecx,\n+                              method_ty.generics.type_param_defs,\n+                              tag_item_method_tps);\n+    encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n+    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n+    encode_visibility(ebml_w, method_ty.vis);\n+    encode_self_type(ebml_w, method_ty.self_ty);\n+}\n \n-            encode_parent_item(ebml_w, local_def(item.id));\n+fn encode_info_for_method(ecx: @EncodeContext,\n+                          ebml_w: &mut writer::Encoder,\n+                          impl_path: &[ast_map::path_elt],\n+                          should_inline: bool,\n+                          parent_id: node_id,\n+                          m: @method,\n+                          owner_generics: &ast::Generics,\n+                          method_generics: &ast::Generics) {\n+    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n+           *ecx.tcx.sess.str_of(m.ident),\n+           owner_generics.ty_params.len(),\n+           method_generics.ty_params.len());\n+    ebml_w.start_tag(tag_items_data_item);\n \n-            let mut trait_path = vec::append(~[], path);\n-            trait_path.push(ast_map::path_name(item.ident));\n-            encode_path(ecx, ebml_w, trait_path, ast_map::path_name(method_ty.ident));\n+    let method_def_id = local_def(m.id);\n+    let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n+    encode_method_ty_fields(ecx, ebml_w, method_ty);\n \n-            match method_ty.self_ty {\n-                sty_static => {\n-                    encode_family(ebml_w,\n-                                  purity_static_method_family(\n-                                      method_ty.fty.purity));\n+    match m.self_ty.node {\n+        ast::sty_static => {\n+            encode_family(ebml_w, purity_static_method_family(m.purity));\n+        }\n+        _ => encode_family(ebml_w, purity_fn_family(m.purity))\n+    }\n \n-                    let tpt = ty::lookup_item_type(tcx, method_def_id);\n-                    encode_ty_type_param_defs(ebml_w, ecx,\n-                                              tpt.generics.type_param_defs,\n-                                              tag_items_data_item_ty_param_bounds);\n-                    encode_type(ecx, ebml_w, tpt.ty);\n-                }\n+    let mut combined_ty_params = opt_vec::Empty;\n+    combined_ty_params.push_all(&owner_generics.ty_params);\n+    combined_ty_params.push_all(&method_generics.ty_params);\n+    let len = combined_ty_params.len();\n+    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n \n-                _ => {\n-                    encode_family(ebml_w,\n-                                  purity_fn_family(\n-                                      method_ty.fty.purity));\n-                }\n-            }\n+    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n+    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n \n-            match ms[i] {\n-                required(_) => {\n-                    encode_method_sort(ebml_w, 'r');\n-                }\n+    if len > 0u || should_inline {\n+        (ecx.encode_inlined_item)(\n+           ecx, ebml_w, impl_path,\n+           ii_method(local_def(parent_id), m));\n+    } else {\n+        encode_symbol(ecx, ebml_w, m.id);\n+    }\n \n-                provided(m) => {\n-                    // This is obviously a bogus assert but I don't think this\n-                    // ever worked before anyhow...near as I can tell, before\n-                    // we would emit two items.\n-                    if method_ty.self_ty == sty_static {\n-                        tcx.sess.span_unimpl(\n-                            item.span,\n-                            fmt!(\"Method %s is both provided and static\",\n-                                 *tcx.sess.intr().get(method_ty.ident)));\n-                    }\n-                    encode_type_param_bounds(ebml_w, ecx,\n-                                             &m.generics.ty_params);\n-                    encode_method_sort(ebml_w, 'p');\n-                    (ecx.encode_inlined_item)(\n-                        ecx, ebml_w, path,\n-                        ii_method(local_def(item.id), m));\n-                }\n-            }\n+    ebml_w.end_tag();\n+}\n \n-            ebml_w.end_tag();\n-        }\n-      }\n-      item_mac(*) => fail!(~\"item macros unimplemented\")\n+fn purity_fn_family(p: purity) -> char {\n+    match p {\n+      unsafe_fn => 'u',\n+      pure_fn => 'p',\n+      impure_fn => 'f',\n+      extern_fn => 'e'\n+    }\n+}\n+\n+fn purity_static_method_family(p: purity) -> char {\n+    match p {\n+      unsafe_fn => 'U',\n+      pure_fn => 'P',\n+      impure_fn => 'F',\n+      _ => fail!(~\"extern fn can't be static\")\n+    }\n+}\n+\n+\n+fn should_inline(attrs: &[attribute]) -> bool {\n+    match attr::find_inline_attr(attrs) {\n+        attr::ia_none | attr::ia_never  => false,\n+        attr::ia_hint | attr::ia_always => true\n     }\n }\n \n-#[cfg(not(stage0))]\n fn encode_info_for_item(ecx: @EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n@@ -1904,42 +985,6 @@ fn encode_info_for_item(ecx: @EncodeContext,\n     }\n }\n \n-#[cfg(stage0)]\n-fn encode_info_for_foreign_item(ecx: @EncodeContext,\n-                                ebml_w: &writer::Encoder,\n-                                nitem: @foreign_item,\n-                                index: @mut ~[entry<int>],\n-                                path: ast_map::path,\n-                                abi: AbiSet) {\n-    if !reachable(ecx, nitem.id) { return; }\n-    index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n-\n-    ebml_w.start_tag(tag_items_data_item);\n-    match nitem.node {\n-      foreign_item_fn(_, purity, ref generics) => {\n-        encode_def_id(ebml_w, local_def(nitem.id));\n-        encode_family(ebml_w, purity_fn_family(purity));\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n-        if abi.is_intrinsic() {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));\n-        } else {\n-            encode_symbol(ecx, ebml_w, nitem.id);\n-        }\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n-      }\n-      foreign_item_const(*) => {\n-        encode_def_id(ebml_w, local_def(nitem.id));\n-        encode_family(ebml_w, 'c');\n-        encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n-        encode_symbol(ecx, ebml_w, nitem.id);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n-      }\n-    }\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_info_for_foreign_item(ecx: @EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: @foreign_item,\n@@ -1974,54 +1019,6 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_info_for_items(ecx: @EncodeContext,\n-                         ebml_w: &writer::Encoder,\n-                         crate: &crate)\n-                         -> ~[entry<int>] {\n-    let index = @mut ~[];\n-    ebml_w.start_tag(tag_items_data);\n-    index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n-    encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n-                        crate_node_id, ~[],\n-                        syntax::parse::token::special_idents::invalid);\n-    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n-        visit_expr: |_e, _cx, _v| { },\n-        visit_item: {\n-            let ebml_w = copy *ebml_w;\n-            |i, cx, v| {\n-                visit::visit_item(i, cx, v);\n-                match *ecx.tcx.items.get(&i.id) {\n-                    ast_map::node_item(_, pt) => {\n-                        encode_info_for_item(ecx, &ebml_w, i,\n-                                             index, *pt);\n-                    }\n-                    _ => fail!(~\"bad item\")\n-                }\n-            }\n-        },\n-        visit_foreign_item: {\n-            let ebml_w = copy *ebml_w;\n-            |ni, cx, v| {\n-                visit::visit_foreign_item(ni, cx, v);\n-                match *ecx.tcx.items.get(&ni.id) {\n-                    ast_map::node_foreign_item(_, abi, _, pt) => {\n-                        encode_info_for_foreign_item(ecx, &ebml_w, ni,\n-                                                     index, /*bad*/copy *pt,\n-                                                     abi);\n-                    }\n-                    // case for separate item and foreign-item tables\n-                    _ => fail!(~\"bad foreign item\")\n-                }\n-            }\n-        },\n-        ..*visit::default_visitor()\n-    }));\n-    ebml_w.end_tag();\n-    return /*bad*/copy *index;\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_info_for_items(ecx: @EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n                          crate: &crate)\n@@ -2077,51 +1074,20 @@ fn encode_info_for_items(ecx: @EncodeContext,\n \n fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n    ~[@~[entry<T>]] {\n-    let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n-    for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };\n-    for index.each |elt| {\n-        let h = elt.val.hash() as uint;\n-        buckets[h % 256].push(*elt);\n-    }\n-\n-    let mut buckets_frozen = ~[];\n-    for buckets.each |bucket| {\n-        buckets_frozen.push(@/*bad*/copy **bucket);\n-    }\n-    return buckets_frozen;\n-}\n-\n-#[cfg(stage0)]\n-fn encode_index<T>(ebml_w: &writer::Encoder,\n-                   buckets: ~[@~[entry<T>]],\n-                   write_fn: &fn(@io::Writer, &T)) {\n-    let writer = ebml_w.writer;\n-    ebml_w.start_tag(tag_index);\n-    let mut bucket_locs: ~[uint] = ~[];\n-    ebml_w.start_tag(tag_index_buckets);\n-    for buckets.each |bucket| {\n-        bucket_locs.push(ebml_w.writer.tell());\n-        ebml_w.start_tag(tag_index_buckets_bucket);\n-        for vec::each(**bucket) |elt| {\n-            ebml_w.start_tag(tag_index_buckets_bucket_elt);\n-            assert!(elt.pos < 0xffff_ffff);\n-            writer.write_be_u32(elt.pos as u32);\n-            write_fn(writer, &elt.val);\n-            ebml_w.end_tag();\n-        }\n-        ebml_w.end_tag();\n+    let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n+    for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };\n+    for index.each |elt| {\n+        let h = elt.val.hash() as uint;\n+        buckets[h % 256].push(*elt);\n     }\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_index_table);\n-    for bucket_locs.each |pos| {\n-        assert!(*pos < 0xffff_ffff);\n-        writer.write_be_u32(*pos as u32);\n+\n+    let mut buckets_frozen = ~[];\n+    for buckets.each |bucket| {\n+        buckets_frozen.push(@/*bad*/copy **bucket);\n     }\n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n+    return buckets_frozen;\n }\n \n-#[cfg(not(stage0))]\n fn encode_index<T>(ebml_w: &mut writer::Encoder,\n                    buckets: ~[@~[entry<T>]],\n                    write_fn: &fn(@io::Writer, &T)) {\n@@ -2160,45 +1126,6 @@ fn write_int(writer: @io::Writer, &n: &int) {\n     writer.write_be_u32(n as u32);\n }\n \n-#[cfg(stage0)]\n-fn encode_meta_item(ebml_w: &writer::Encoder, mi: @meta_item) {\n-    match mi.node {\n-      meta_word(name) => {\n-        ebml_w.start_tag(tag_meta_item_word);\n-        ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes(*name));\n-        ebml_w.end_tag();\n-        ebml_w.end_tag();\n-      }\n-      meta_name_value(name, value) => {\n-        match value.node {\n-          lit_str(value) => {\n-            ebml_w.start_tag(tag_meta_item_name_value);\n-            ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(str::to_bytes(*name));\n-            ebml_w.end_tag();\n-            ebml_w.start_tag(tag_meta_item_value);\n-            ebml_w.writer.write(str::to_bytes(*value));\n-            ebml_w.end_tag();\n-            ebml_w.end_tag();\n-          }\n-          _ => {/* FIXME (#623): encode other variants */ }\n-        }\n-      }\n-      meta_list(name, ref items) => {\n-        ebml_w.start_tag(tag_meta_item_list);\n-        ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes(*name));\n-        ebml_w.end_tag();\n-        for items.each |inner_item| {\n-            encode_meta_item(ebml_w, *inner_item);\n-        }\n-        ebml_w.end_tag();\n-      }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n     match mi.node {\n       meta_word(name) => {\n@@ -2236,18 +1163,6 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n     }\n }\n \n-#[cfg(stage0)]\n-fn encode_attributes(ebml_w: &writer::Encoder, attrs: &[attribute]) {\n-    ebml_w.start_tag(tag_attributes);\n-    for attrs.each |attr| {\n-        ebml_w.start_tag(tag_attribute);\n-        encode_meta_item(ebml_w, attr.node.value);\n-        ebml_w.end_tag();\n-    }\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n@@ -2312,50 +1227,6 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n     return attrs;\n }\n \n-#[cfg(stage0)]\n-fn encode_crate_deps(ecx: @EncodeContext,\n-                     ebml_w: &writer::Encoder,\n-                     cstore: @mut cstore::CStore) {\n-    fn get_ordered_deps(ecx: @EncodeContext, cstore: @mut cstore::CStore)\n-                     -> ~[decoder::crate_dep] {\n-        type numdep = decoder::crate_dep;\n-\n-        // Pull the cnums and name,vers,hash out of cstore\n-        let mut deps = ~[];\n-        do cstore::iter_crate_data(cstore) |key, val| {\n-            let dep = decoder::crate_dep {cnum: key,\n-                       name: ecx.tcx.sess.ident_of(/*bad*/ copy *val.name),\n-                       vers: decoder::get_crate_vers(val.data),\n-                       hash: decoder::get_crate_hash(val.data)};\n-            deps.push(dep);\n-        };\n-\n-        // Sort by cnum\n-        std::sort::quick_sort(deps, |kv1, kv2| kv1.cnum <= kv2.cnum);\n-\n-        // Sanity-check the crate numbers\n-        let mut expected_cnum = 1;\n-        for deps.each |n| {\n-            assert!((n.cnum == expected_cnum));\n-            expected_cnum += 1;\n-        }\n-\n-        // mut -> immutable hack for vec::map\n-        deps.slice(0, deps.len()).to_owned()\n-    }\n-\n-    // We're just going to write a list of crate 'name-hash-version's, with\n-    // the assumption that they are numbered 1 to n.\n-    // FIXME (#2166): This is not nearly enough to support correct versioning\n-    // but is enough to get transitive crate dependencies working.\n-    ebml_w.start_tag(tag_crate_deps);\n-    for get_ordered_deps(ecx, cstore).each |dep| {\n-        encode_crate_dep(ecx, ebml_w, *dep);\n-    }\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_crate_deps(ecx: @EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      cstore: @mut cstore::CStore) {\n@@ -2398,32 +1269,6 @@ fn encode_crate_deps(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_lang_items(ecx: @EncodeContext, ebml_w: &writer::Encoder) {\n-    ebml_w.start_tag(tag_lang_items);\n-\n-    for ecx.tcx.lang_items.each_item |def_id, i| {\n-        if def_id.crate != local_crate {\n-            loop;\n-        }\n-\n-        ebml_w.start_tag(tag_lang_items_item);\n-\n-        ebml_w.start_tag(tag_lang_items_item_id);\n-        ebml_w.writer.write_be_u32(i as u32);\n-        ebml_w.end_tag();   // tag_lang_items_item_id\n-\n-        ebml_w.start_tag(tag_lang_items_item_node_id);\n-        ebml_w.writer.write_be_u32(def_id.node as u32);\n-        ebml_w.end_tag();   // tag_lang_items_item_node_id\n-\n-        ebml_w.end_tag();   // tag_lang_items_item\n-    }\n-\n-    ebml_w.end_tag();   // tag_lang_items\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_lang_items(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n@@ -2448,21 +1293,6 @@ fn encode_lang_items(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();   // tag_lang_items\n }\n \n-#[cfg(stage0)]\n-fn encode_link_args(ecx: @EncodeContext, ebml_w: &writer::Encoder) {\n-    ebml_w.start_tag(tag_link_args);\n-\n-    let link_args = cstore::get_used_link_args(ecx.cstore);\n-    for link_args.each |link_arg| {\n-        ebml_w.start_tag(tag_link_args_arg);\n-        ebml_w.writer.write_str(link_arg.to_str());\n-        ebml_w.end_tag();\n-    }\n-\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_link_args(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n@@ -2476,24 +1306,6 @@ fn encode_link_args(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_crate_dep(ecx: @EncodeContext,\n-                    ebml_w: &writer::Encoder,\n-                    dep: decoder::crate_dep) {\n-    ebml_w.start_tag(tag_crate_dep);\n-    ebml_w.start_tag(tag_crate_dep_name);\n-    ebml_w.writer.write(str::to_bytes(*ecx.tcx.sess.str_of(dep.name)));\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_crate_dep_vers);\n-    ebml_w.writer.write(str::to_bytes(*dep.vers));\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(str::to_bytes(*dep.hash));\n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_crate_dep(ecx: @EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     dep: decoder::crate_dep) {\n@@ -2510,14 +1322,6 @@ fn encode_crate_dep(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_hash(ebml_w: &writer::Encoder, hash: &str) {\n-    ebml_w.start_tag(tag_crate_hash);\n-    ebml_w.writer.write(str::to_bytes(hash));\n-    ebml_w.end_tag();\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_hash(ebml_w: &mut writer::Encoder, hash: &str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n@@ -2532,114 +1336,6 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x74, //'t' as u8,\n       0, 0, 0, 1 ];\n \n-#[cfg(stage0)]\n-pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n-    let wr = @io::BytesWriter();\n-    let stats = Stats {\n-        inline_bytes: 0,\n-        attr_bytes: 0,\n-        dep_bytes: 0,\n-        lang_item_bytes: 0,\n-        link_args_bytes: 0,\n-        item_bytes: 0,\n-        index_bytes: 0,\n-        zero_bytes: 0,\n-        total_bytes: 0,\n-        n_inlines: 0\n-    };\n-    let EncodeParams{item_symbols, diag, tcx, reachable, reexports2,\n-                     discrim_symbols, cstore, encode_inlined_item,\n-                     link_meta, _} = parms;\n-    let ecx = @EncodeContext {\n-        diag: diag,\n-        tcx: tcx,\n-        stats: @mut stats,\n-        reachable: reachable,\n-        reexports2: reexports2,\n-        item_symbols: item_symbols,\n-        discrim_symbols: discrim_symbols,\n-        link_meta: link_meta,\n-        cstore: cstore,\n-        encode_inlined_item: encode_inlined_item,\n-        type_abbrevs: @mut HashMap::new()\n-     };\n-\n-    let ebml_w = writer::Encoder(wr as @io::Writer);\n-\n-    encode_hash(&ebml_w, ecx.link_meta.extras_hash);\n-\n-    let mut i = wr.pos;\n-    let crate_attrs = synthesize_crate_attrs(ecx, crate);\n-    encode_attributes(&ebml_w, crate_attrs);\n-    ecx.stats.attr_bytes = wr.pos - i;\n-\n-    i = wr.pos;\n-    encode_crate_deps(ecx, &ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes = wr.pos - i;\n-\n-    // Encode the language items.\n-    i = wr.pos;\n-    encode_lang_items(ecx, &ebml_w);\n-    ecx.stats.lang_item_bytes = wr.pos - i;\n-\n-    // Encode the link args.\n-    i = wr.pos;\n-    encode_link_args(ecx, &ebml_w);\n-    ecx.stats.link_args_bytes = wr.pos - i;\n-\n-    // Encode and index the items.\n-    ebml_w.start_tag(tag_items);\n-    i = wr.pos;\n-    let items_index = encode_info_for_items(ecx, &ebml_w, crate);\n-    ecx.stats.item_bytes = wr.pos - i;\n-\n-    i = wr.pos;\n-    let items_buckets = create_index(items_index);\n-    encode_index(&ebml_w, items_buckets, write_int);\n-    ecx.stats.index_bytes = wr.pos - i;\n-    ebml_w.end_tag();\n-\n-    ecx.stats.total_bytes = wr.pos;\n-\n-    if (tcx.sess.meta_stats()) {\n-\n-        do wr.bytes.each |e| {\n-            if *e == 0 {\n-                ecx.stats.zero_bytes += 1;\n-            }\n-            true\n-        }\n-\n-        io::println(\"metadata stats:\");\n-        io::println(fmt!(\"    inline bytes: %u\", ecx.stats.inline_bytes));\n-        io::println(fmt!(\" attribute bytes: %u\", ecx.stats.attr_bytes));\n-        io::println(fmt!(\"       dep bytes: %u\", ecx.stats.dep_bytes));\n-        io::println(fmt!(\" lang item bytes: %u\", ecx.stats.lang_item_bytes));\n-        io::println(fmt!(\" link args bytes: %u\", ecx.stats.link_args_bytes));\n-        io::println(fmt!(\"      item bytes: %u\", ecx.stats.item_bytes));\n-        io::println(fmt!(\"     index bytes: %u\", ecx.stats.index_bytes));\n-        io::println(fmt!(\"      zero bytes: %u\", ecx.stats.zero_bytes));\n-        io::println(fmt!(\"     total bytes: %u\", ecx.stats.total_bytes));\n-    }\n-\n-    // Pad this, since something (LLVM, presumably) is cutting off the\n-    // remaining % 4 bytes.\n-    wr.write(&[0u8, 0u8, 0u8, 0u8]);\n-\n-    // FIXME #3396: weird bug here, for reasons unclear this emits random\n-    // looking bytes (mostly 0x1) if we use the version byte-array constant\n-    // above; so we use a string constant inline instead.\n-    //\n-    // Should be:\n-    //\n-    //   vec::from_slice(metadata_encoding_version) +\n-\n-    (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n-        vec::slice(*bytes, 0, 8).to_vec()\n-    }) + flate::deflate_bytes(wr.bytes)\n-}\n-\n-#[cfg(not(stage0))]\n pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n     let stats = Stats {"}, {"sha": "c6f01153a906e87523d93bd4b431218379652c3b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 774, "changes": 774, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -77,31 +77,6 @@ trait tr_intern {\n // ______________________________________________________________________\n // Top-level methods.\n \n-#[cfg(stage0)]\n-pub fn encode_inlined_item(ecx: @e::EncodeContext,\n-                           ebml_w: &writer::Encoder,\n-                           path: &[ast_map::path_elt],\n-                           ii: ast::inlined_item,\n-                           maps: Maps) {\n-    debug!(\"> Encoding inlined item: %s::%s (%u)\",\n-           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n-           *ecx.tcx.sess.str_of(ii.ident()),\n-           ebml_w.writer.tell());\n-\n-    let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n-    do ebml_w.wr_tag(c::tag_ast as uint) {\n-        id_range.encode(ebml_w);\n-        encode_ast(ebml_w, simplify_ast(&ii));\n-        encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n-    }\n-\n-    debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n-           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n-           *ecx.tcx.sess.str_of(ii.ident()),\n-           ebml_w.writer.tell());\n-}\n-\n-#[cfg(not(stage0))]\n pub fn encode_inlined_item(ecx: @e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            path: &[ast_map::path_elt],\n@@ -126,53 +101,6 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n            ebml_w.writer.tell());\n }\n \n-#[cfg(stage0)]\n-pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n-                           tcx: ty::ctxt,\n-                           maps: Maps,\n-                           path: ast_map::path,\n-                           par_doc: ebml::Doc)\n-                        -> Option<ast::inlined_item> {\n-    let dcx = @DecodeContext {\n-        cdata: cdata,\n-        tcx: tcx,\n-        maps: maps\n-    };\n-    match par_doc.opt_child(c::tag_ast) {\n-      None => None,\n-      Some(ast_doc) => {\n-        debug!(\"> Decoding inlined fn: %s::?\",\n-               ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n-        let ast_dsr = &reader::Decoder(ast_doc);\n-        let from_id_range = Decodable::decode(ast_dsr);\n-        let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n-        let xcx = @ExtendedDecodeContext {\n-            dcx: dcx,\n-            from_id_range: from_id_range,\n-            to_id_range: to_id_range\n-        };\n-        let raw_ii = decode_ast(ast_doc);\n-        let ii = renumber_ast(xcx, raw_ii);\n-        debug!(\"Fn named: %s\", *tcx.sess.str_of(ii.ident()));\n-        debug!(\"< Decoded inlined fn: %s::%s\",\n-               ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n-               *tcx.sess.str_of(ii.ident()));\n-        ast_map::map_decoded_item(tcx.sess.diagnostic(),\n-                                  dcx.tcx.items, path, &ii);\n-        decode_side_tables(xcx, ast_doc);\n-        match ii {\n-          ast::ii_item(i) => {\n-            debug!(\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_str(i, tcx.sess.intr()));\n-          }\n-          _ => { }\n-        }\n-        Some(ii)\n-      }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n@@ -309,49 +237,20 @@ impl tr for span {\n     }\n }\n \n-#[cfg(stage0)]\n-trait def_id_encoder_helpers {\n-    fn emit_def_id(&self, did: ast::def_id);\n-}\n-\n-#[cfg(not(stage0))]\n trait def_id_encoder_helpers {\n     fn emit_def_id(&mut self, did: ast::def_id);\n }\n \n-#[cfg(stage0)]\n-impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n-    fn emit_def_id(&self, did: ast::def_id) {\n-        did.encode(self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n     fn emit_def_id(&mut self, did: ast::def_id) {\n         did.encode(self)\n     }\n }\n \n-#[cfg(stage0)]\n-trait def_id_decoder_helpers {\n-    fn read_def_id(&self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n-}\n-\n-#[cfg(not(stage0))]\n trait def_id_decoder_helpers {\n     fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n }\n \n-#[cfg(stage0)]\n-impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n-    fn read_def_id(&self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n-        let did: ast::def_id = Decodable::decode(self);\n-        did.tr(xcx)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n     fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n         let did: ast::def_id = Decodable::decode(self);\n@@ -374,14 +273,6 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-#[cfg(stage0)]\n-fn encode_ast(ebml_w: &writer::Encoder, item: ast::inlined_item) {\n-    do ebml_w.wr_tag(c::tag_tree as uint) {\n-        item.encode(ebml_w)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n     ebml_w.start_tag(c::tag_tree as uint);\n     item.encode(ebml_w);\n@@ -439,14 +330,6 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     }\n }\n \n-#[cfg(stage0)]\n-fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n-    let chi_doc = par_doc.get(c::tag_tree as uint);\n-    let d = &reader::Decoder(chi_doc);\n-    Decodable::decode(d)\n-}\n-\n-#[cfg(not(stage0))]\n fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder(chi_doc);\n@@ -477,24 +360,10 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-#[cfg(stage0)]\n-fn encode_def(ebml_w: &writer::Encoder, def: ast::def) {\n-    def.encode(ebml_w)\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_def(ebml_w: &mut writer::Encoder, def: ast::def) {\n     def.encode(ebml_w)\n }\n \n-#[cfg(stage0)]\n-fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n-    let dsr = &reader::Decoder(doc);\n-    let def: ast::def = Decodable::decode(dsr);\n-    def.tr(xcx)\n-}\n-\n-#[cfg(not(stage0))]\n fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n     let mut dsr = reader::Decoder(doc);\n     let def: ast::def = Decodable::decode(&mut dsr);\n@@ -602,38 +471,15 @@ impl tr for ty::bound_region {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-#[cfg(stage0)]\n-fn encode_freevar_entry(ebml_w: &writer::Encoder, fv: @freevar_entry) {\n-    (*fv).encode(ebml_w)\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_freevar_entry(ebml_w: &mut writer::Encoder, fv: @freevar_entry) {\n     (*fv).encode(ebml_w)\n }\n \n-#[cfg(stage0)]\n-trait ebml_decoder_helper {\n-    fn read_freevar_entry(&self, xcx: @ExtendedDecodeContext)\n-                          -> freevar_entry;\n-}\n-\n-#[cfg(not(stage0))]\n trait ebml_decoder_helper {\n     fn read_freevar_entry(&mut self, xcx: @ExtendedDecodeContext)\n                           -> freevar_entry;\n }\n \n-#[cfg(stage0)]\n-impl ebml_decoder_helper for reader::Decoder {\n-    fn read_freevar_entry(&self, xcx: @ExtendedDecodeContext)\n-                          -> freevar_entry {\n-        let fv: freevar_entry = Decodable::decode(self);\n-        fv.tr(xcx)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl ebml_decoder_helper for reader::Decoder {\n     fn read_freevar_entry(&mut self, xcx: @ExtendedDecodeContext)\n                           -> freevar_entry {\n@@ -654,28 +500,11 @@ impl tr for freevar_entry {\n // ______________________________________________________________________\n // Encoding and decoding of CaptureVar information\n \n-#[cfg(stage0)]\n-trait capture_var_helper {\n-    fn read_capture_var(&self, xcx: @ExtendedDecodeContext)\n-                        -> moves::CaptureVar;\n-}\n-\n-#[cfg(not(stage0))]\n trait capture_var_helper {\n     fn read_capture_var(&mut self, xcx: @ExtendedDecodeContext)\n                         -> moves::CaptureVar;\n }\n \n-#[cfg(stage0)]\n-impl capture_var_helper for reader::Decoder {\n-    fn read_capture_var(&self, xcx: @ExtendedDecodeContext)\n-                        -> moves::CaptureVar {\n-        let cvar: moves::CaptureVar = Decodable::decode(self);\n-        cvar.tr(xcx)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl capture_var_helper for reader::Decoder {\n     fn read_capture_var(&mut self, xcx: @ExtendedDecodeContext)\n                         -> moves::CaptureVar {\n@@ -698,35 +527,10 @@ impl tr for moves::CaptureVar {\n // Encoding and decoding of method_map_entry\n \n trait read_method_map_entry_helper {\n-    #[cfg(stage0)]\n-    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n-                             -> method_map_entry;\n-    #[cfg(not(stage0))]\n     fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n                              -> method_map_entry;\n }\n \n-#[cfg(stage0)]\n-fn encode_method_map_entry(ecx: @e::EncodeContext,\n-                           ebml_w: &writer::Encoder,\n-                           mme: method_map_entry) {\n-    do ebml_w.emit_struct(\"method_map_entry\", 3) {\n-        do ebml_w.emit_field(~\"self_arg\", 0u) {\n-            ebml_w.emit_arg(ecx, mme.self_arg);\n-        }\n-        do ebml_w.emit_field(~\"explicit_self\", 2u) {\n-            mme.explicit_self.encode(ebml_w);\n-        }\n-        do ebml_w.emit_field(~\"origin\", 1u) {\n-            mme.origin.encode(ebml_w);\n-        }\n-        do ebml_w.emit_field(~\"self_mode\", 3) {\n-            mme.self_mode.encode(ebml_w);\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            mme: method_map_entry) {\n@@ -747,32 +551,6 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n }\n \n impl read_method_map_entry_helper for reader::Decoder {\n-    #[cfg(stage0)]\n-    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n-                             -> method_map_entry {\n-        do self.read_struct(\"method_map_entry\", 3) {\n-            method_map_entry {\n-                self_arg: self.read_field(~\"self_arg\", 0u, || {\n-                    self.read_arg(xcx)\n-                }),\n-                explicit_self: self.read_field(~\"explicit_self\", 2u, || {\n-                    let self_type: ast::self_ty_ = Decodable::decode(self);\n-                    self_type\n-                }),\n-                origin: self.read_field(~\"origin\", 1u, || {\n-                    let method_origin: method_origin =\n-                        Decodable::decode(self);\n-                    method_origin.tr(xcx)\n-                }),\n-                self_mode: self.read_field(~\"self_mode\", 3, || {\n-                    let self_mode: ty::SelfMode = Decodable::decode(self);\n-                    self_mode\n-                }),\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n                              -> method_map_entry {\n         do self.read_struct(\"method_map_entry\", 3) |this| {\n@@ -830,20 +608,6 @@ impl tr for method_origin {\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n-#[cfg(stage0)]\n-fn encode_vtable_res(ecx: @e::EncodeContext,\n-                     ebml_w: &writer::Encoder,\n-                     dr: typeck::vtable_res) {\n-    // can't autogenerate this code because automatic code of\n-    // ty::t doesn't work, and there is no way (atm) to have\n-    // hand-written encoding routines combine with auto-generated\n-    // ones.  perhaps we should fix this.\n-    do ebml_w.emit_from_vec(*dr) |vtable_origin| {\n-        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_vtable_res(ecx: @e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      dr: typeck::vtable_res) {\n@@ -856,40 +620,6 @@ fn encode_vtable_res(ecx: @e::EncodeContext,\n     }\n }\n \n-#[cfg(stage0)]\n-fn encode_vtable_origin(ecx: @e::EncodeContext,\n-                        ebml_w: &writer::Encoder,\n-                        vtable_origin: &typeck::vtable_origin) {\n-    do ebml_w.emit_enum(~\"vtable_origin\") {\n-        match *vtable_origin {\n-          typeck::vtable_static(def_id, ref tys, vtable_res) => {\n-            do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) {\n-                do ebml_w.emit_enum_variant_arg(0u) {\n-                    ebml_w.emit_def_id(def_id)\n-                }\n-                do ebml_w.emit_enum_variant_arg(1u) {\n-                    ebml_w.emit_tys(ecx, /*bad*/copy *tys);\n-                }\n-                do ebml_w.emit_enum_variant_arg(2u) {\n-                    encode_vtable_res(ecx, ebml_w, vtable_res);\n-                }\n-            }\n-          }\n-          typeck::vtable_param(pn, bn) => {\n-            do ebml_w.emit_enum_variant(~\"vtable_param\", 1u, 2u) {\n-                do ebml_w.emit_enum_variant_arg(0u) {\n-                    ebml_w.emit_uint(pn);\n-                }\n-                do ebml_w.emit_enum_variant_arg(1u) {\n-                    ebml_w.emit_uint(bn);\n-                }\n-            }\n-          }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_vtable_origin(ecx: @e::EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n@@ -923,70 +653,18 @@ fn encode_vtable_origin(ecx: @e::EncodeContext,\n }\n \n trait vtable_decoder_helpers {\n-    #[cfg(stage0)]\n-    fn read_vtable_res(&self, xcx: @ExtendedDecodeContext)\n-                      -> typeck::vtable_res;\n-    #[cfg(not(stage0))]\n     fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n                       -> typeck::vtable_res;\n-    #[cfg(stage0)]\n-    fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n-                          -> typeck::vtable_origin;\n-    #[cfg(not(stage0))]\n     fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n                           -> typeck::vtable_origin;\n }\n \n impl vtable_decoder_helpers for reader::Decoder {\n-    #[cfg(stage0)]\n-    fn read_vtable_res(&self, xcx: @ExtendedDecodeContext)\n-                      -> typeck::vtable_res {\n-        @self.read_to_vec(|| self.read_vtable_origin(xcx))\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n                       -> typeck::vtable_res {\n         @self.read_to_vec(|this| this.read_vtable_origin(xcx))\n     }\n \n-    #[cfg(stage0)]\n-    fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n-                          -> typeck::vtable_origin {\n-        do self.read_enum(\"vtable_origin\") {\n-            do self.read_enum_variant([\"vtable_static\", \"vtable_param\"]) |i| {\n-                match i {\n-                  0 => {\n-                    typeck::vtable_static(\n-                        do self.read_enum_variant_arg(0u) {\n-                            self.read_def_id(xcx)\n-                        },\n-                        do self.read_enum_variant_arg(1u) {\n-                            self.read_tys(xcx)\n-                        },\n-                        do self.read_enum_variant_arg(2u) {\n-                            self.read_vtable_res(xcx)\n-                        }\n-                    )\n-                  }\n-                  1 => {\n-                    typeck::vtable_param(\n-                        do self.read_enum_variant_arg(0u) {\n-                            self.read_uint()\n-                        },\n-                        do self.read_enum_variant_arg(1u) {\n-                            self.read_uint()\n-                        }\n-                    )\n-                  }\n-                  // hard to avoid - user input\n-                  _ => fail!(~\"bad enum variant\")\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n         -> typeck::vtable_origin {\n         do self.read_enum(\"vtable_origin\") |this| {\n@@ -1042,20 +720,6 @@ impl get_ty_str_ctxt for e::EncodeContext {\n     }\n }\n \n-#[cfg(stage0)]\n-trait ebml_writer_helpers {\n-    fn emit_arg(&self, ecx: @e::EncodeContext, arg: ty::arg);\n-    fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t);\n-    fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore);\n-    fn emit_tys(&self, ecx: @e::EncodeContext, tys: ~[ty::t]);\n-    fn emit_type_param_def(&self,\n-                           ecx: @e::EncodeContext,\n-                           type_param_def: &ty::TypeParameterDef);\n-    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n-                 tpbt: ty::ty_param_bounds_and_ty);\n-}\n-\n-#[cfg(not(stage0))]\n trait ebml_writer_helpers {\n     fn emit_arg(&mut self, ecx: @e::EncodeContext, arg: ty::arg);\n     fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t);\n@@ -1070,73 +734,30 @@ trait ebml_writer_helpers {\n }\n \n impl ebml_writer_helpers for writer::Encoder {\n-    #[cfg(stage0)]\n-    fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t) {\n-        do self.emit_opaque {\n-            e::write_type(ecx, self, ty)\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t) {\n         do self.emit_opaque |this| {\n             e::write_type(ecx, this, ty)\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n-        do self.emit_opaque {\n-            e::write_vstore(ecx, self, vstore)\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n         do self.emit_opaque |this| {\n             e::write_vstore(ecx, this, vstore)\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn emit_arg(&self, ecx: @e::EncodeContext, arg: ty::arg) {\n-        do self.emit_opaque {\n-            tyencode::enc_arg(self.writer, ecx.ty_str_ctxt(), arg);\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn emit_arg(&mut self, ecx: @e::EncodeContext, arg: ty::arg) {\n         do self.emit_opaque |this| {\n             tyencode::enc_arg(this.writer, ecx.ty_str_ctxt(), arg);\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn emit_tys(&self, ecx: @e::EncodeContext, tys: ~[ty::t]) {\n-        do self.emit_from_vec(tys) |ty| {\n-            self.emit_ty(ecx, *ty)\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: ~[ty::t]) {\n         do self.emit_from_vec(tys) |this, ty| {\n             this.emit_ty(ecx, *ty)\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn emit_type_param_def(&self,\n-                           ecx: @e::EncodeContext,\n-                           type_param_def: &ty::TypeParameterDef) {\n-        do self.emit_opaque {\n-            tyencode::enc_type_param_def(self.writer, ecx.ty_str_ctxt(),\n-                                         type_param_def)\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn emit_type_param_def(&mut self,\n                            ecx: @e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n@@ -1147,31 +768,6 @@ impl ebml_writer_helpers for writer::Encoder {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn emit_tpbt(&self,\n-                 ecx: @e::EncodeContext,\n-                 tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n-            do self.emit_field(~\"generics\", 0) {\n-                do self.emit_struct(\"Generics\", 2) {\n-                    do self.emit_field(~\"type_param_defs\", 0) {\n-                        do self.emit_from_vec(*tpbt.generics.type_param_defs)\n-                                |type_param_def| {\n-                            self.emit_type_param_def(ecx, type_param_def);\n-                        }\n-                    }\n-                    do self.emit_field(~\"region_param\", 1) {\n-                        tpbt.generics.region_param.encode(self);\n-                    }\n-                }\n-            }\n-            do self.emit_field(~\"ty\", 1) {\n-                self.emit_ty(ecx, tpbt.ty);\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn emit_tpbt(&mut self,\n                  ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n@@ -1196,30 +792,11 @@ impl ebml_writer_helpers for writer::Encoder {\n     }\n }\n \n-#[cfg(stage0)]\n-trait write_tag_and_id {\n-    fn tag(&self, tag_id: c::astencode_tag, f: &fn());\n-    fn id(&self, id: ast::node_id);\n-}\n-\n-#[cfg(not(stage0))]\n trait write_tag_and_id {\n     fn tag(&mut self, tag_id: c::astencode_tag, f: &fn(&mut Self));\n     fn id(&mut self, id: ast::node_id);\n }\n \n-#[cfg(stage0)]\n-impl write_tag_and_id for writer::Encoder {\n-    fn tag(&self, tag_id: c::astencode_tag, f: &fn()) {\n-        do self.wr_tag(tag_id as uint) { f() }\n-    }\n-\n-    fn id(&self, id: ast::node_id) {\n-        self.wr_tagged_u64(c::tag_table_id as uint, id as u64)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl write_tag_and_id for writer::Encoder {\n     fn tag(&mut self,\n            tag_id: c::astencode_tag,\n@@ -1234,26 +811,6 @@ impl write_tag_and_id for writer::Encoder {\n     }\n }\n \n-#[cfg(stage0)]\n-fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n-                             maps: Maps,\n-                             ebml_w: &writer::Encoder,\n-                             ii: &ast::inlined_item) {\n-    do ebml_w.wr_tag(c::tag_table as uint) {\n-        let ebml_w = copy *ebml_w;\n-        ast_util::visit_ids_for_inlined_item(\n-            ii,\n-            |id: ast::node_id| {\n-                // Note: this will cause a copy of ebml_w, which is bad as\n-                // it has mut fields.  But I believe it's harmless since\n-                // we generate balanced EBML.\n-                /*let ebml_w = copy ebml_w;*/\n-                encode_side_tables_for_id(ecx, maps, &ebml_w, id)\n-            });\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &mut writer::Encoder,\n@@ -1272,137 +829,6 @@ fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n     ebml_w.end_tag();\n }\n \n-#[cfg(stage0)]\n-fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n-                             maps: Maps,\n-                             ebml_w: &writer::Encoder,\n-                             id: ast::node_id) {\n-    let tcx = ecx.tcx;\n-\n-    debug!(\"Encoding side tables for id %d\", id);\n-\n-    for tcx.def_map.find(&id).each |def| {\n-        do ebml_w.tag(c::tag_table_def) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                (*def).encode(ebml_w)\n-            }\n-        }\n-    }\n-\n-    for tcx.node_types.find(&(id as uint)).each |&ty| {\n-        do ebml_w.tag(c::tag_table_node_type) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                ebml_w.emit_ty(ecx, *ty);\n-            }\n-        }\n-    }\n-\n-    for tcx.node_type_substs.find(&id).each |tys| {\n-        do ebml_w.tag(c::tag_table_node_type_subst) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                // FIXME(#5562): removing this copy causes a segfault\n-                //               before stage2\n-                ebml_w.emit_tys(ecx, /*bad*/copy **tys)\n-            }\n-        }\n-    }\n-\n-    for tcx.freevars.find(&id).each |&fv| {\n-        do ebml_w.tag(c::tag_table_freevars) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec(**fv) |fv_entry| {\n-                    encode_freevar_entry(ebml_w, *fv_entry)\n-                }\n-            }\n-        }\n-    }\n-\n-    let lid = ast::def_id { crate: ast::local_crate, node: id };\n-    for tcx.tcache.find(&lid).each |&tpbt| {\n-        do ebml_w.tag(c::tag_table_tcache) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                ebml_w.emit_tpbt(ecx, *tpbt);\n-            }\n-        }\n-    }\n-\n-    for tcx.ty_param_defs.find(&id).each |&type_param_def| {\n-        do ebml_w.tag(c::tag_table_param_defs) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                ebml_w.emit_type_param_def(ecx, type_param_def)\n-            }\n-        }\n-    }\n-\n-    if maps.mutbl_map.contains(&id) {\n-        do ebml_w.tag(c::tag_table_mutbl) {\n-            ebml_w.id(id);\n-        }\n-    }\n-\n-    for maps.last_use_map.find(&id).each |&m| {\n-        do ebml_w.tag(c::tag_table_last_use) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec(/*bad*/ copy **m) |id| {\n-                    id.encode(ebml_w);\n-                }\n-            }\n-        }\n-    }\n-\n-    for maps.method_map.find(&id).each |&mme| {\n-        do ebml_w.tag(c::tag_table_method_map) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                encode_method_map_entry(ecx, ebml_w, *mme)\n-            }\n-        }\n-    }\n-\n-    for maps.vtable_map.find(&id).each |&dr| {\n-        do ebml_w.tag(c::tag_table_vtable_map) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                encode_vtable_res(ecx, ebml_w, *dr);\n-            }\n-        }\n-    }\n-\n-    for tcx.adjustments.find(&id).each |adj| {\n-        do ebml_w.tag(c::tag_table_adjustments) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                (**adj).encode(ebml_w)\n-            }\n-        }\n-    }\n-\n-    if maps.moves_map.contains(&id) {\n-        do ebml_w.tag(c::tag_table_moves_map) {\n-            ebml_w.id(id);\n-        }\n-    }\n-\n-    for maps.capture_map.find(&id).each |&cap_vars| {\n-        do ebml_w.tag(c::tag_table_capture_map) {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec(*cap_vars) |cap_var| {\n-                    cap_var.encode(ebml_w);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &mut writer::Encoder,\n@@ -1544,20 +970,6 @@ impl doc_decoder_helpers for ebml::Doc {\n     }\n }\n \n-#[cfg(stage0)]\n-trait ebml_decoder_decoder_helpers {\n-    fn read_arg(&self, xcx: @ExtendedDecodeContext) -> ty::arg;\n-    fn read_ty(&self, xcx: @ExtendedDecodeContext) -> ty::t;\n-    fn read_tys(&self, xcx: @ExtendedDecodeContext) -> ~[ty::t];\n-    fn read_type_param_def(&self, xcx: @ExtendedDecodeContext) -> ty::TypeParameterDef;\n-    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n-                                -> ty::ty_param_bounds_and_ty;\n-    fn convert_def_id(&self, xcx: @ExtendedDecodeContext,\n-                      source: DefIdSource,\n-                      did: ast::def_id) -> ast::def_id;\n-}\n-\n-#[cfg(not(stage0))]\n trait ebml_decoder_decoder_helpers {\n     fn read_arg(&mut self, xcx: @ExtendedDecodeContext) -> ty::arg;\n     fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t;\n@@ -1574,16 +986,6 @@ trait ebml_decoder_decoder_helpers {\n }\n \n impl ebml_decoder_decoder_helpers for reader::Decoder {\n-    #[cfg(stage0)]\n-    fn read_arg(&self, xcx: @ExtendedDecodeContext) -> ty::arg {\n-        do self.read_opaque |doc| {\n-            tydecode::parse_arg_data(\n-                doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n-                |s, a| self.convert_def_id(xcx, s, a))\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn read_arg(&mut self, xcx: @ExtendedDecodeContext) -> ty::arg {\n         do self.read_opaque |this, doc| {\n             tydecode::parse_arg_data(\n@@ -1595,35 +997,6 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn read_ty(&self, xcx: @ExtendedDecodeContext) -> ty::t {\n-        // Note: regions types embed local node ids.  In principle, we\n-        // should translate these node ids into the new decode\n-        // context.  However, we do not bother, because region types\n-        // are not used during trans.\n-\n-        return do self.read_opaque |doc| {\n-\n-            let ty = tydecode::parse_ty_data(\n-                doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n-                |s, a| self.convert_def_id(xcx, s, a));\n-\n-            debug!(\"read_ty(%s) = %s\",\n-                   type_string(doc), ty_to_str(xcx.dcx.tcx, ty));\n-\n-            ty\n-        };\n-\n-        fn type_string(doc: ebml::Doc) -> ~str {\n-            let mut str = ~\"\";\n-            for uint::range(doc.start, doc.end) |i| {\n-                str::push_char(&mut str, doc.data[i] as char);\n-            }\n-            str\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n@@ -1654,27 +1027,10 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn read_tys(&self, xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n-        self.read_to_vec(|| self.read_ty(xcx) )\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n         self.read_to_vec(|this| this.read_ty(xcx) )\n     }\n \n-    #[cfg(stage0)]\n-    fn read_type_param_def(&self, xcx: @ExtendedDecodeContext)\n-                           -> ty::TypeParameterDef {\n-        do self.read_opaque |doc| {\n-            tydecode::parse_type_param_def_data(\n-                doc.data, doc.start, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n-                |s, a| self.convert_def_id(xcx, s, a))\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n                            -> ty::TypeParameterDef {\n         do self.read_opaque |this, doc| {\n@@ -1687,31 +1043,6 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n-                                   -> ty::ty_param_bounds_and_ty {\n-        do self.read_struct(\"ty_param_bounds_and_ty\", 2) {\n-            ty::ty_param_bounds_and_ty {\n-                generics: do self.read_field(\"generics\", 0) {\n-                    do self.read_struct(\"Generics\", 2) {\n-                        ty::Generics {\n-                            type_param_defs: self.read_field(\"type_param_defs\", 0, || {\n-                                @self.read_to_vec(|| self.read_type_param_def(xcx))\n-                            }),\n-                            region_param: self.read_field(~\"region_param\", 1, || {\n-                                Decodable::decode(self)\n-                            })\n-                        }\n-                    }\n-                },\n-                ty: self.read_field(~\"ty\", 1, || {\n-                    self.read_ty(xcx)\n-                })\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n                                    -> ty::ty_param_bounds_and_ty {\n         do self.read_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n@@ -1742,35 +1073,6 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn convert_def_id(&self,\n-                      xcx: @ExtendedDecodeContext,\n-                      source: tydecode::DefIdSource,\n-                      did: ast::def_id)\n-                      -> ast::def_id {\n-        /*!\n-         *\n-         * Converts a def-id that appears in a type.  The correct\n-         * translation will depend on what kind of def-id this is.\n-         * This is a subtle point: type definitions are not\n-         * inlined into the current crate, so if the def-id names\n-         * a nominal type or type alias, then it should be\n-         * translated to refer to the source crate.\n-         *\n-         * However, *type parameters* are cloned along with the function\n-         * they are attached to.  So we should translate those def-ids\n-         * to refer to the new, cloned copy of the type parameter.\n-         */\n-\n-        let r = match source {\n-            NominalType | TypeWithId => xcx.tr_def_id(did),\n-            TypeParameter => xcx.tr_intern_def_id(did)\n-        };\n-        debug!(\"convert_def_id(source=%?, did=%?)=%?\", source, did, r);\n-        return r;\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn convert_def_id(&mut self,\n                       xcx: @ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n@@ -1799,82 +1101,6 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n     }\n }\n \n-#[cfg(stage0)]\n-fn decode_side_tables(xcx: @ExtendedDecodeContext,\n-                      ast_doc: ebml::Doc) {\n-    let dcx = xcx.dcx;\n-    let tbl_doc = ast_doc.get(c::tag_table as uint);\n-    for reader::docs(tbl_doc) |tag, entry_doc| {\n-        let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n-        let id = xcx.tr_id(id0);\n-\n-        debug!(\">> Side table document with tag 0x%x \\\n-                found for id %d (orig %d)\",\n-               tag, id, id0);\n-\n-        if tag == (c::tag_table_mutbl as uint) {\n-            dcx.maps.mutbl_map.insert(id);\n-        } else if tag == (c::tag_table_moves_map as uint) {\n-            dcx.maps.moves_map.insert(id);\n-        } else {\n-            let val_doc = entry_doc.get(c::tag_table_val as uint);\n-            let val_dsr = &reader::Decoder(val_doc);\n-            if tag == (c::tag_table_def as uint) {\n-                let def = decode_def(xcx, val_doc);\n-                dcx.tcx.def_map.insert(id, def);\n-            } else if tag == (c::tag_table_node_type as uint) {\n-                let ty = val_dsr.read_ty(xcx);\n-                debug!(\"inserting ty for node %?: %s\",\n-                       id, ty_to_str(dcx.tcx, ty));\n-                dcx.tcx.node_types.insert(id as uint, ty);\n-            } else if tag == (c::tag_table_node_type_subst as uint) {\n-                let tys = val_dsr.read_tys(xcx);\n-                dcx.tcx.node_type_substs.insert(id, tys);\n-            } else if tag == (c::tag_table_freevars as uint) {\n-                let fv_info = @val_dsr.read_to_vec(|| {\n-                    @val_dsr.read_freevar_entry(xcx)\n-                });\n-                dcx.tcx.freevars.insert(id, fv_info);\n-            } else if tag == (c::tag_table_tcache as uint) {\n-                let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n-                let lid = ast::def_id { crate: ast::local_crate, node: id };\n-                dcx.tcx.tcache.insert(lid, tpbt);\n-            } else if tag == (c::tag_table_param_defs as uint) {\n-                let bounds = val_dsr.read_type_param_def(xcx);\n-                dcx.tcx.ty_param_defs.insert(id, bounds);\n-            } else if tag == (c::tag_table_last_use as uint) {\n-                let ids = val_dsr.read_to_vec(|| {\n-                    xcx.tr_id(val_dsr.read_int())\n-                });\n-                dcx.maps.last_use_map.insert(id, @mut ids);\n-            } else if tag == (c::tag_table_method_map as uint) {\n-                dcx.maps.method_map.insert(\n-                    id,\n-                    val_dsr.read_method_map_entry(xcx));\n-            } else if tag == (c::tag_table_vtable_map as uint) {\n-                dcx.maps.vtable_map.insert(id,\n-                                           val_dsr.read_vtable_res(xcx));\n-            } else if tag == (c::tag_table_adjustments as uint) {\n-                let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);\n-                adj.tr(xcx);\n-                dcx.tcx.adjustments.insert(id, adj);\n-            } else if tag == (c::tag_table_capture_map as uint) {\n-                let cvars =\n-                    at_vec::from_owned(\n-                        val_dsr.read_to_vec(\n-                            || val_dsr.read_capture_var(xcx)));\n-                dcx.maps.capture_map.insert(id, cvars);\n-            } else {\n-                xcx.dcx.tcx.sess.bug(\n-                    fmt!(\"unknown tag found in side tables: %x\", tag));\n-            }\n-        }\n-\n-        debug!(\">< Side table doc loaded\");\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                       ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;"}, {"sha": "b9a09323f81d068c9f3fa13ce188a5b1a0382742", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -203,21 +203,6 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    priv fn alloc_pod<T>(&mut self, op: &fn() -> T) -> &'self T {\n-        unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n-            let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n-            let ptr: *mut T = transmute(ptr);\n-            rusti::move_val_init(&mut (*ptr), op());\n-            return transmute(ptr);\n-        }\n-    }\n-\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     priv fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n@@ -265,31 +250,6 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    priv fn alloc_nonpod<T>(&mut self, op: &fn() -> T) -> &'self T {\n-        unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n-            let (ty_ptr, ptr) =\n-                self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n-            let ty_ptr: *mut uint = transmute(ty_ptr);\n-            let ptr: *mut T = transmute(ptr);\n-            // Write in our tydesc along with a bit indicating that it\n-            // has *not* been initialized yet.\n-            *ty_ptr = transmute(tydesc);\n-            // Actually initialize it\n-            rusti::move_val_init(&mut(*ptr), op());\n-            // Now that we are done, update the tydesc to indicate that\n-            // the object is there.\n-            *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n-\n-            return transmute(ptr);\n-        }\n-    }\n-\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     priv fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n@@ -312,25 +272,6 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn alloc<T>(&mut self, op: &fn() -> T) -> &'self T {\n-        unsafe {\n-            // XXX: Borrow check\n-            let this = transmute_mut_region(self);\n-            if !rusti::needs_drop::<T>() {\n-                return this.alloc_pod(op);\n-            }\n-            // XXX: Borrow check\n-            let this = transmute_mut_region(self);\n-            this.alloc_nonpod(op)\n-        }\n-    }\n-\n-    // The external interface\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             // XXX: Borrow check"}, {"sha": "65e71869a1f0f39d293df3cda775690f7914ade2", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -37,128 +37,6 @@ impl<T> Mutable for Deque<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-pub impl<T> Deque<T> {\n-    /// Create an empty Deque\n-    fn new() -> Deque<T> {\n-        Deque{nelts: 0, lo: 0, hi: 0,\n-              elts: vec::from_fn(initial_capacity, |_| None)}\n-    }\n-\n-    /// Return a reference to the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    #[cfg(stage0)]\n-    fn peek_front(&self) -> &'self T { get(self.elts, self.lo) }\n-\n-    /// Return a reference to the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n-\n-    /// Return a reference to the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    #[cfg(stage0)]\n-    fn peek_back(&self) -> &'self T { get(self.elts, self.hi - 1u) }\n-\n-    /// Return a reference to the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n-\n-    /// Retrieve an element in the deque by index\n-    ///\n-    /// Fails if there is no element with the given index\n-    #[cfg(stage0)]\n-    fn get(&self, i: int) -> &'self T {\n-        let idx = (self.lo + (i as uint)) % self.elts.len();\n-        get(self.elts, idx)\n-    }\n-\n-    /// Retrieve an element in the deque by index\n-    ///\n-    /// Fails if there is no element with the given index\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn get<'a>(&'a self, i: int) -> &'a T {\n-        let idx = (self.lo + (i as uint)) % self.elts.len();\n-        get(self.elts, idx)\n-    }\n-\n-    /// Iterate over the elements in the deque\n-    fn each(&self, f: &fn(&T) -> bool) {\n-        self.eachi(|_i, e| f(e))\n-    }\n-\n-    /// Iterate over the elements in the deque by index\n-    fn eachi(&self, f: &fn(uint, &T) -> bool) {\n-        for uint::range(0, self.nelts) |i| {\n-            if !f(i, self.get(i as int)) { return; }\n-        }\n-    }\n-\n-    /// Remove and return the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    fn pop_front(&mut self) -> T {\n-        let result = self.elts[self.lo].swap_unwrap();\n-        self.lo = (self.lo + 1u) % self.elts.len();\n-        self.nelts -= 1u;\n-        result\n-    }\n-\n-    /// Remove and return the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    fn pop_back(&mut self) -> T {\n-        if self.hi == 0u {\n-            self.hi = self.elts.len() - 1u;\n-        } else { self.hi -= 1u; }\n-        let result = self.elts[self.hi].swap_unwrap();\n-        self.elts[self.hi] = None;\n-        self.nelts -= 1u;\n-        result\n-    }\n-\n-    /// Prepend an element to the deque\n-    fn add_front(&mut self, t: T) {\n-        let oldlo = self.lo;\n-        if self.lo == 0u {\n-            self.lo = self.elts.len() - 1u;\n-        } else { self.lo -= 1u; }\n-        if self.lo == self.hi {\n-            self.elts = grow(self.nelts, oldlo, self.elts);\n-            self.lo = self.elts.len() - 1u;\n-            self.hi = self.nelts;\n-        }\n-        self.elts[self.lo] = Some(t);\n-        self.nelts += 1u;\n-    }\n-\n-    /// Append an element to the deque\n-    fn add_back(&mut self, t: T) {\n-        if self.lo == self.hi && self.nelts != 0u {\n-            self.elts = grow(self.nelts, self.lo, self.elts);\n-            self.lo = 0u;\n-            self.hi = self.nelts;\n-        }\n-        self.elts[self.hi] = Some(t);\n-        self.hi = (self.hi + 1u) % self.elts.len();\n-        self.nelts += 1u;\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub impl<T> Deque<T> {\n     /// Create an empty Deque\n     fn new() -> Deque<T> {"}, {"sha": "8a4bc823fd881018f5befc7f892b8e6657d5690b", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 0, "deletions": 539, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -263,13 +263,6 @@ pub mod reader {\n     pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n     pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n-    #[cfg(stage0)]\n-    pub struct Decoder {\n-        priv mut parent: Doc,\n-        priv mut pos: uint,\n-    }\n-\n-    #[cfg(not(stage0))]\n     pub struct Decoder {\n         priv parent: Doc,\n         priv pos: uint,\n@@ -283,25 +276,6 @@ pub mod reader {\n     }\n \n     priv impl Decoder {\n-        #[cfg(stage0)]\n-        fn _check_label(&self, lbl: &str) {\n-            if self.pos < self.parent.end {\n-                let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                    doc_at(self.parent.data, self.pos);\n-\n-                if r_tag == (EsLabel as uint) {\n-                    self.pos = r_doc.end;\n-                    let str = doc_as_str(r_doc);\n-                    if lbl != str {\n-                        fail!(fmt!(\"Expected label %s but found %s\",\n-                                   lbl,\n-                                   str));\n-                    }\n-                }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]\n         fn _check_label(&mut self, lbl: &str) {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n@@ -319,30 +293,6 @@ pub mod reader {\n             }\n         }\n \n-        #[cfg(stage0)]\n-        fn next_doc(&self, exp_tag: EbmlEncoderTag) -> Doc {\n-            debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n-            if self.pos >= self.parent.end {\n-                fail!(~\"no more documents in current node!\");\n-            }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                doc_at(self.parent.data, self.pos);\n-            debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n-                   copy self.parent.start, copy self.parent.end,\n-                   copy self.pos, r_tag, r_doc.start, r_doc.end);\n-            if r_tag != (exp_tag as uint) {\n-                fail!(fmt!(\"expected EBML doc with tag %? but found tag %?\",\n-                          exp_tag, r_tag));\n-            }\n-            if r_doc.end > self.parent.end {\n-                fail!(fmt!(\"invalid EBML, child extends to 0x%x, \\\n-                           parent to 0x%x\", r_doc.end, self.parent.end));\n-            }\n-            self.pos = r_doc.end;\n-            r_doc\n-        }\n-\n-        #[cfg(not(stage0))]\n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc {\n             debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n             if self.pos >= self.parent.end {\n@@ -365,19 +315,6 @@ pub mod reader {\n             r_doc\n         }\n \n-        #[cfg(stage0)]\n-        fn push_doc<T>(&self, d: Doc, f: &fn() -> T) -> T {\n-            let old_parent = self.parent;\n-            let old_pos = self.pos;\n-            self.parent = d;\n-            self.pos = d.start;\n-            let r = f();\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            r\n-        }\n-\n-        #[cfg(not(stage0))]\n         fn push_doc<T>(&mut self, d: Doc, f: &fn() -> T) -> T {\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n@@ -389,14 +326,6 @@ pub mod reader {\n             r\n         }\n \n-        #[cfg(stage0)]\n-        fn _next_uint(&self, exp_tag: EbmlEncoderTag) -> uint {\n-            let r = doc_as_u32(self.next_doc(exp_tag));\n-            debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n-            r as uint\n-        }\n-\n-        #[cfg(not(stage0))]\n         fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> uint {\n             let r = doc_as_u32(self.next_doc(exp_tag));\n             debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n@@ -405,14 +334,6 @@ pub mod reader {\n     }\n \n     pub impl Decoder {\n-        #[cfg(stage0)]\n-        fn read_opaque<R>(&self, op: &fn(Doc) -> R) -> R {\n-            do self.push_doc(self.next_doc(EsOpaque)) {\n-                op(copy self.parent)\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]\n         fn read_opaque<R>(&mut self, op: &fn(&mut Decoder, Doc) -> R) -> R {\n             let doc = self.next_doc(EsOpaque);\n \n@@ -428,188 +349,6 @@ pub mod reader {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    impl serialize::Decoder for Decoder {\n-        fn read_nil(&self) -> () { () }\n-\n-        fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n-        fn read_u32(&self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n-        fn read_u16(&self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n-        fn read_u8 (&self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n-        fn read_uint(&self) -> uint {\n-            let v = doc_as_u64(self.next_doc(EsUint));\n-            if v > (::core::uint::max_value as u64) {\n-                fail!(fmt!(\"uint %? too large for this architecture\", v));\n-            }\n-            v as uint\n-        }\n-\n-        fn read_i64(&self) -> i64 {\n-            doc_as_u64(self.next_doc(EsI64)) as i64\n-        }\n-        fn read_i32(&self) -> i32 {\n-            doc_as_u32(self.next_doc(EsI32)) as i32\n-        }\n-        fn read_i16(&self) -> i16 {\n-            doc_as_u16(self.next_doc(EsI16)) as i16\n-        }\n-        fn read_i8 (&self) -> i8 {\n-            doc_as_u8(self.next_doc(EsI8 )) as i8\n-        }\n-        fn read_int(&self) -> int {\n-            let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n-            if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-                fail!(fmt!(\"int %? out of range for this architecture\", v));\n-            }\n-            v as int\n-        }\n-\n-        fn read_bool(&self) -> bool {\n-            doc_as_u8(self.next_doc(EsBool)) as bool\n-        }\n-\n-        fn read_f64(&self) -> f64 { fail!(~\"read_f64()\"); }\n-        fn read_f32(&self) -> f32 { fail!(~\"read_f32()\"); }\n-        fn read_float(&self) -> float { fail!(~\"read_float()\"); }\n-        fn read_char(&self) -> char { fail!(~\"read_char()\"); }\n-        fn read_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n-\n-        // Compound types:\n-        fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n-            debug!(\"read_enum(%s)\", name);\n-            self._check_label(name);\n-            self.push_doc(self.next_doc(EsEnum), f)\n-        }\n-\n-        fn read_enum_variant<T>(&self,\n-                                _: &[&str],\n-                                f: &fn(uint) -> T)\n-                                -> T {\n-            debug!(\"read_enum_variant()\");\n-            let idx = self._next_uint(EsEnumVid);\n-            debug!(\"  idx=%u\", idx);\n-            do self.push_doc(self.next_doc(EsEnumBody)) {\n-                f(idx)\n-            }\n-        }\n-\n-        fn read_enum_variant_arg<T>(&self,\n-                                    idx: uint,\n-                                    f: &fn() -> T) -> T {\n-            debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-            f()\n-        }\n-\n-        fn read_enum_struct_variant<T>(&self,\n-                                       _: &[&str],\n-                                       f: &fn(uint) -> T)\n-                                       -> T {\n-            debug!(\"read_enum_struct_variant()\");\n-            let idx = self._next_uint(EsEnumVid);\n-            debug!(\"  idx=%u\", idx);\n-            do self.push_doc(self.next_doc(EsEnumBody)) {\n-                f(idx)\n-            }\n-        }\n-\n-        fn read_enum_struct_variant_field<T>(&self,\n-                                             name: &str,\n-                                             idx: uint,\n-                                             f: &fn() -> T)\n-                                             -> T {\n-            debug!(\"read_enum_struct_variant_arg(name=%?, idx=%u)\", name, idx);\n-            f()\n-        }\n-\n-        fn read_struct<T>(&self,\n-                          name: &str,\n-                          _: uint,\n-                          f: &fn() -> T)\n-                          -> T {\n-            debug!(\"read_struct(name=%s)\", name);\n-            f()\n-        }\n-\n-        fn read_field<T>(&self,\n-                         name: &str,\n-                         idx: uint,\n-                         f: &fn() -> T)\n-                         -> T {\n-            debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n-            self._check_label(name);\n-            f()\n-        }\n-\n-        fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T {\n-            debug!(\"read_tuple()\");\n-            self.read_seq(f)\n-        }\n-\n-        fn read_tuple_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_tuple_arg(idx=%u)\", idx);\n-            self.read_seq_elt(idx, f)\n-        }\n-\n-        fn read_tuple_struct<T>(&self,\n-                                name: &str,\n-                                f: &fn(uint) -> T)\n-                                -> T {\n-            debug!(\"read_tuple_struct(name=%?)\", name);\n-            self.read_tuple(f)\n-        }\n-\n-        fn read_tuple_struct_arg<T>(&self,\n-                                    idx: uint,\n-                                    f: &fn() -> T)\n-                                    -> T {\n-            debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n-            self.read_tuple_arg(idx, f)\n-        }\n-\n-        fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n-            debug!(\"read_option()\");\n-            do self.read_enum(\"Option\") || {\n-                do self.read_enum_variant([\"None\", \"Some\"]) |idx| {\n-                    match idx {\n-                        0 => f(false),\n-                        1 => f(true),\n-                        _ => fail!(),\n-                    }\n-                }\n-            }\n-        }\n-\n-        fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n-            debug!(\"read_seq()\");\n-            do self.push_doc(self.next_doc(EsVec)) {\n-                let len = self._next_uint(EsVecLen);\n-                debug!(\"  len=%u\", len);\n-                f(len)\n-            }\n-        }\n-\n-        fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_seq_elt(idx=%u)\", idx);\n-            self.push_doc(self.next_doc(EsVecElt), f)\n-        }\n-\n-        fn read_map<T>(&self, _f: &fn(uint) -> T) -> T {\n-            debug!(\"read_map()\");\n-            fail!(~\"read_map is unimplemented\");\n-        }\n-\n-        fn read_map_elt_key<T>(&self, idx: uint, _f: &fn() -> T) -> T {\n-            debug!(\"read_map_elt_key(idx=%u)\", idx);\n-            fail!(~\"read_map_elt_val is unimplemented\");\n-        }\n-\n-        fn read_map_elt_val<T>(&self, idx: uint, _f: &fn() -> T) -> T {\n-            debug!(\"read_map_elt_val(idx=%u)\", idx);\n-            fail!(~\"read_map_elt_val is unimplemented\");\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     impl serialize::Decoder for Decoder {\n         fn read_nil(&mut self) -> () { () }\n \n@@ -891,104 +630,6 @@ pub mod writer {\n     }\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n-    #[cfg(stage0)]\n-    pub impl Encoder {\n-        fn start_tag(&self, tag_id: uint) {\n-            debug!(\"Start tag %u\", tag_id);\n-\n-            // Write the enum ID:\n-            write_vuint(self.writer, tag_id);\n-\n-            // Write a placeholder four-byte size.\n-            self.size_positions.push(self.writer.tell());\n-            let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-            self.writer.write(zeroes);\n-        }\n-\n-        fn end_tag(&self) {\n-            let last_size_pos = self.size_positions.pop();\n-            let cur_pos = self.writer.tell();\n-            self.writer.seek(last_size_pos as int, io::SeekSet);\n-            let size = (cur_pos - last_size_pos - 4u);\n-            write_sized_vuint(self.writer, size, 4u);\n-            self.writer.seek(cur_pos as int, io::SeekSet);\n-\n-            debug!(\"End tag (size = %u)\", size);\n-        }\n-\n-        fn wr_tag(&self, tag_id: uint, blk: &fn()) {\n-            self.start_tag(tag_id);\n-            blk();\n-            self.end_tag();\n-        }\n-\n-        fn wr_tagged_bytes(&self, tag_id: uint, b: &[u8]) {\n-            write_vuint(self.writer, tag_id);\n-            write_vuint(self.writer, vec::len(b));\n-            self.writer.write(b);\n-        }\n-\n-        fn wr_tagged_u64(&self, tag_id: uint, v: u64) {\n-            do io::u64_to_be_bytes(v, 8u) |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            }\n-        }\n-\n-        fn wr_tagged_u32(&self, tag_id: uint, v: u32) {\n-            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            }\n-        }\n-\n-        fn wr_tagged_u16(&self, tag_id: uint, v: u16) {\n-            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            }\n-        }\n-\n-        fn wr_tagged_u8(&self, tag_id: uint, v: u8) {\n-            self.wr_tagged_bytes(tag_id, &[v]);\n-        }\n-\n-        fn wr_tagged_i64(&self, tag_id: uint, v: i64) {\n-            do io::u64_to_be_bytes(v as u64, 8u) |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            }\n-        }\n-\n-        fn wr_tagged_i32(&self, tag_id: uint, v: i32) {\n-            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            }\n-        }\n-\n-        fn wr_tagged_i16(&self, tag_id: uint, v: i16) {\n-            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            }\n-        }\n-\n-        fn wr_tagged_i8(&self, tag_id: uint, v: i8) {\n-            self.wr_tagged_bytes(tag_id, &[v as u8]);\n-        }\n-\n-        fn wr_tagged_str(&self, tag_id: uint, v: &str) {\n-            str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n-        }\n-\n-        fn wr_bytes(&self, b: &[u8]) {\n-            debug!(\"Write %u bytes\", vec::len(b));\n-            self.writer.write(b);\n-        }\n-\n-        fn wr_str(&self, s: &str) {\n-            debug!(\"Write str: %?\", s);\n-            self.writer.write(str::to_bytes(s));\n-        }\n-    }\n-\n-    // FIXME (#2741): Provide a function to write the standard ebml header.\n-    #[cfg(not(stage0))]\n     pub impl Encoder {\n         fn start_tag(&mut self, tag_id: uint) {\n             debug!(\"Start tag %u\", tag_id);\n@@ -1091,26 +732,6 @@ pub mod writer {\n     // Totally lame approach.\n     static debug: bool = true;\n \n-    #[cfg(stage0)]\n-    priv impl Encoder {\n-        // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_uint(&self, t: EbmlEncoderTag, v: uint) {\n-            assert!(v <= 0xFFFF_FFFF_u);\n-            self.wr_tagged_u32(t as uint, v as u32);\n-        }\n-\n-        fn _emit_label(&self, label: &str) {\n-            // There are various strings that we have access to, such as\n-            // the name of a record field, which do not actually appear in\n-            // the encoded EBML (normally).  This is just for\n-            // efficiency.  When debugging, though, we can emit such\n-            // labels and then they will be checked by decoder to\n-            // try and check failures more quickly.\n-            if debug { self.wr_tagged_str(EsLabel as uint, label) }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     priv impl Encoder {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n@@ -1129,16 +750,6 @@ pub mod writer {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    pub impl Encoder {\n-        fn emit_opaque(&self, f: &fn()) {\n-            do self.wr_tag(EsOpaque as uint) {\n-                f()\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     pub impl Encoder {\n         fn emit_opaque(&mut self, f: &fn(&mut Encoder)) {\n             self.start_tag(EsOpaque as uint);\n@@ -1147,156 +758,6 @@ pub mod writer {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    impl ::serialize::Encoder for Encoder {\n-        fn emit_nil(&self) {}\n-\n-        fn emit_uint(&self, v: uint) {\n-            self.wr_tagged_u64(EsUint as uint, v as u64);\n-        }\n-        fn emit_u64(&self, v: u64) {\n-            self.wr_tagged_u64(EsU64 as uint, v);\n-        }\n-        fn emit_u32(&self, v: u32) {\n-            self.wr_tagged_u32(EsU32 as uint, v);\n-        }\n-        fn emit_u16(&self, v: u16) {\n-            self.wr_tagged_u16(EsU16 as uint, v);\n-        }\n-        fn emit_u8(&self, v: u8) {\n-            self.wr_tagged_u8(EsU8 as uint, v);\n-        }\n-\n-        fn emit_int(&self, v: int) {\n-            self.wr_tagged_i64(EsInt as uint, v as i64);\n-        }\n-        fn emit_i64(&self, v: i64) {\n-            self.wr_tagged_i64(EsI64 as uint, v);\n-        }\n-        fn emit_i32(&self, v: i32) {\n-            self.wr_tagged_i32(EsI32 as uint, v);\n-        }\n-        fn emit_i16(&self, v: i16) {\n-            self.wr_tagged_i16(EsI16 as uint, v);\n-        }\n-        fn emit_i8(&self, v: i8) {\n-            self.wr_tagged_i8(EsI8 as uint, v);\n-        }\n-\n-        fn emit_bool(&self, v: bool) {\n-            self.wr_tagged_u8(EsBool as uint, v as u8)\n-        }\n-\n-        // FIXME (#2742): implement these\n-        fn emit_f64(&self, _v: f64) {\n-            fail!(~\"Unimplemented: serializing an f64\");\n-        }\n-        fn emit_f32(&self, _v: f32) {\n-            fail!(~\"Unimplemented: serializing an f32\");\n-        }\n-        fn emit_float(&self, _v: float) {\n-            fail!(~\"Unimplemented: serializing a float\");\n-        }\n-\n-        fn emit_char(&self, _v: char) {\n-            fail!(~\"Unimplemented: serializing a char\");\n-        }\n-\n-        fn emit_str(&self, v: &str) {\n-            self.wr_tagged_str(EsStr as uint, v)\n-        }\n-\n-        fn emit_enum(&self, name: &str, f: &fn()) {\n-            self._emit_label(name);\n-            self.wr_tag(EsEnum as uint, f)\n-        }\n-\n-        fn emit_enum_variant(&self,\n-                             _: &str,\n-                             v_id: uint,\n-                             _: uint,\n-                             f: &fn()) {\n-            self._emit_tagged_uint(EsEnumVid, v_id);\n-            self.wr_tag(EsEnumBody as uint, f)\n-        }\n-\n-        fn emit_enum_variant_arg(&self, _: uint, f: &fn()) {\n-            f()\n-        }\n-\n-        fn emit_enum_struct_variant(&self,\n-                                    v_name: &str,\n-                                    v_id: uint,\n-                                    cnt: uint,\n-                                    f: &fn()) {\n-            self.emit_enum_variant(v_name, v_id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field(&self,\n-                                          _: &str,\n-                                          idx: uint,\n-                                          f: &fn()) {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct(&self, _: &str, _len: uint, f: &fn()) {\n-            f()\n-        }\n-\n-        fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n-            self._emit_label(name);\n-            f()\n-        }\n-\n-        fn emit_tuple(&self, len: uint, f: &fn()) {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_arg(&self, idx: uint, f: &fn()) {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_option(&self, f: &fn()) {\n-            self.emit_enum(\"Option\", f);\n-        }\n-        fn emit_option_none(&self) {\n-            self.emit_enum_variant(\"None\", 0, 0, || ())\n-        }\n-        fn emit_option_some(&self, f: &fn()) {\n-            self.emit_enum_variant(\"Some\", 1, 1, f)\n-        }\n-\n-        fn emit_seq(&self, len: uint, f: &fn()) {\n-            do self.wr_tag(EsVec as uint) {\n-                self._emit_tagged_uint(EsVecLen, len);\n-                f()\n-            }\n-        }\n-\n-        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n-            self.wr_tag(EsVecElt as uint, f)\n-        }\n-\n-        fn emit_map(&self, _len: uint, _f: &fn()) {\n-            fail!(~\"emit_map is unimplemented\");\n-        }\n-\n-        fn emit_map_elt_key(&self, _idx: uint, _f: &fn()) {\n-            fail!(~\"emit_map_elt_key is unimplemented\");\n-        }\n-\n-        fn emit_map_elt_val(&self, _idx: uint, _f: &fn()) {\n-            fail!(~\"emit_map_elt_val is unimplemented\");\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     impl ::serialize::Encoder for Encoder {\n         fn emit_nil(&mut self) {}\n "}, {"sha": "88de53f360519a3f291b7e34801f783ba640225e", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -438,19 +438,6 @@ pub mod flatteners {\n     SerializingFlattener\n     */\n \n-    #[cfg(stage0)]\n-    pub fn deserialize_buffer<D: Decoder + FromReader,\n-                              T: Decodable<D>>(\n-                              buf: &[u8])\n-                              -> T {\n-        let buf = vec::from_slice(buf);\n-        let buf_reader = @BufReader::new(buf);\n-        let reader = buf_reader as @Reader;\n-        let deser: D = FromReader::from_reader(reader);\n-        Decodable::decode(&deser)\n-    }\n-\n-    #[cfg(not(stage0))]\n     pub fn deserialize_buffer<D: Decoder + FromReader,\n                               T: Decodable<D>>(\n                               buf: &[u8])\n@@ -462,18 +449,6 @@ pub mod flatteners {\n         Decodable::decode(&mut deser)\n     }\n \n-    #[cfg(stage0)]\n-    pub fn serialize_value<D: Encoder + FromWriter,\n-                           T: Encodable<D>>(\n-                           val: &T)\n-                           -> ~[u8] {\n-        do io::with_bytes_writer |writer| {\n-            let ser = FromWriter::from_writer(writer);\n-            val.encode(&ser);\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     pub fn serialize_value<D: Encoder + FromWriter,\n                            T: Encodable<D>>(\n                            val: &T)"}, {"sha": "5e3e64b2f1cfa783a6748c16927d706c00e7bbb5", "filename": "src/libstd/future.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -54,35 +54,6 @@ pub impl<A:Copy> Future<A> {\n }\n \n pub impl<A> Future<A> {\n-    #[cfg(stage0)]\n-    fn get_ref(&self) -> &'self A {\n-        /*!\n-        * Executes the future's closure and then returns a borrowed\n-        * pointer to the result.  The borrowed pointer lasts as long as\n-        * the future.\n-        */\n-        unsafe {\n-            match self.state {\n-                Forced(ref mut v) => { return cast::transmute(v); }\n-                Evaluating => fail!(~\"Recursive forcing of future!\"),\n-                Pending(_) => {}\n-            }\n-\n-            let mut state = Evaluating;\n-            self.state <-> state;\n-            match state {\n-                Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n-                Pending(f) => {\n-                    self.state = Forced(f());\n-                    self.get_ref()\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get_ref<'a>(&'a self) -> &'a A {\n         /*!\n         * Executes the future's closure and then returns a borrowed"}, {"sha": "3960a07dfce7bb6f3c2ea9f51f0503a79413b985", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 631, "changes": 631, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -77,150 +77,6 @@ pub fn Encoder(wr: @io::Writer) -> Encoder {\n     }\n }\n \n-#[cfg(stage0)]\n-impl serialize::Encoder for Encoder {\n-    fn emit_nil(&self) { self.wr.write_str(\"null\") }\n-\n-    fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n-    fn emit_u64(&self, v: u64) { self.emit_float(v as float); }\n-    fn emit_u32(&self, v: u32) { self.emit_float(v as float); }\n-    fn emit_u16(&self, v: u16) { self.emit_float(v as float); }\n-    fn emit_u8(&self, v: u8)   { self.emit_float(v as float); }\n-\n-    fn emit_int(&self, v: int) { self.emit_float(v as float); }\n-    fn emit_i64(&self, v: i64) { self.emit_float(v as float); }\n-    fn emit_i32(&self, v: i32) { self.emit_float(v as float); }\n-    fn emit_i16(&self, v: i16) { self.emit_float(v as float); }\n-    fn emit_i8(&self, v: i8)   { self.emit_float(v as float); }\n-\n-    fn emit_bool(&self, v: bool) {\n-        if v {\n-            self.wr.write_str(\"true\");\n-        } else {\n-            self.wr.write_str(\"false\");\n-        }\n-    }\n-\n-    fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n-    fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n-    fn emit_float(&self, v: float) {\n-        self.wr.write_str(float::to_str_digits(v, 6u));\n-    }\n-\n-    fn emit_char(&self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)) }\n-\n-    fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n-\n-    fn emit_enum_variant(&self,\n-                         name: &str,\n-                         _id: uint,\n-                         cnt: uint,\n-                         f: &fn()) {\n-        // enums are encoded as strings or vectors:\n-        // Bunny => \"Bunny\"\n-        // Kangaroo(34,\"William\") => [\"Kangaroo\",[34,\"William\"]]\n-\n-        if cnt == 0 {\n-            self.wr.write_str(escape_str(name));\n-        } else {\n-            self.wr.write_char('[');\n-            self.wr.write_str(escape_str(name));\n-            self.wr.write_char(',');\n-            f();\n-            self.wr.write_char(']');\n-        }\n-    }\n-\n-    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n-        if idx != 0 {self.wr.write_char(',');}\n-        f();\n-    }\n-\n-    fn emit_enum_struct_variant(&self,\n-                                name: &str,\n-                                id: uint,\n-                                cnt: uint,\n-                                f: &fn()) {\n-        self.emit_enum_variant(name, id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field(&self,\n-                                      _: &str,\n-                                      idx: uint,\n-                                      f: &fn()) {\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-    fn emit_struct(&self, _: &str, _: uint, f: &fn()) {\n-        self.wr.write_char('{');\n-        f();\n-        self.wr.write_char('}');\n-    }\n-\n-    #[cfg(stage0)]\n-    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_char(':');\n-        f();\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_char(':');\n-        f();\n-    }\n-\n-    fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-    fn emit_tuple_arg(&self, idx: uint, f: &fn()) {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) {\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option(&self, f: &fn()) { f(); }\n-    fn emit_option_none(&self) { self.emit_nil(); }\n-    fn emit_option_some(&self, f: &fn()) { f(); }\n-\n-    fn emit_seq(&self, _len: uint, f: &fn()) {\n-        self.wr.write_char('[');\n-        f();\n-        self.wr.write_char(']');\n-    }\n-\n-    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        f()\n-    }\n-\n-    fn emit_map(&self, _len: uint, f: &fn()) {\n-        self.wr.write_char('{');\n-        f();\n-        self.wr.write_char('}');\n-    }\n-\n-    fn emit_map_elt_key(&self, idx: uint, f: &fn()) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        f()\n-    }\n-\n-    fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n-        self.wr.write_char(':');\n-        f()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl serialize::Encoder for Encoder {\n     fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n \n@@ -376,202 +232,6 @@ pub fn PrettyEncoder(wr: @io::Writer) -> PrettyEncoder {\n     }\n }\n \n-#[cfg(stage0)]\n-impl serialize::Encoder for PrettyEncoder {\n-    fn emit_nil(&self) { self.wr.write_str(\"null\") }\n-\n-    fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n-    fn emit_u64(&self, v: u64) { self.emit_float(v as float); }\n-    fn emit_u32(&self, v: u32) { self.emit_float(v as float); }\n-    fn emit_u16(&self, v: u16) { self.emit_float(v as float); }\n-    fn emit_u8(&self, v: u8)   { self.emit_float(v as float); }\n-\n-    fn emit_int(&self, v: int) { self.emit_float(v as float); }\n-    fn emit_i64(&self, v: i64) { self.emit_float(v as float); }\n-    fn emit_i32(&self, v: i32) { self.emit_float(v as float); }\n-    fn emit_i16(&self, v: i16) { self.emit_float(v as float); }\n-    fn emit_i8(&self, v: i8)   { self.emit_float(v as float); }\n-\n-    fn emit_bool(&self, v: bool) {\n-        if v {\n-            self.wr.write_str(\"true\");\n-        } else {\n-            self.wr.write_str(\"false\");\n-        }\n-    }\n-\n-    fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n-    fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n-    fn emit_float(&self, v: float) {\n-        self.wr.write_str(float::to_str_digits(v, 6u));\n-    }\n-\n-    fn emit_char(&self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)); }\n-\n-    fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n-\n-    fn emit_enum_variant(&self,\n-                         name: &str,\n-                         _: uint,\n-                         cnt: uint,\n-                         f: &fn()) {\n-        if cnt == 0 {\n-            self.wr.write_str(escape_str(name));\n-        } else {\n-            self.wr.write_char('[');\n-            self.indent += 2;\n-            self.wr.write_char('\\n');\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_str(escape_str(name));\n-            self.wr.write_str(\",\\n\");\n-            f();\n-            self.wr.write_char('\\n');\n-            self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char(']');\n-        }\n-    }\n-\n-    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n-        if idx != 0 {\n-            self.wr.write_str(\",\\n\");\n-        }\n-        self.wr.write_str(spaces(self.indent));\n-        f()\n-    }\n-\n-    fn emit_enum_struct_variant(&self,\n-                                name: &str,\n-                                id: uint,\n-                                cnt: uint,\n-                                f: &fn()) {\n-        self.emit_enum_variant(name, id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field(&self,\n-                                      _: &str,\n-                                      idx: uint,\n-                                      f: &fn()) {\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-\n-    fn emit_struct(&self, _name: &str, len: uint, f: &fn()) {\n-        if len == 0 {\n-            self.wr.write_str(\"{}\");\n-        } else {\n-            self.wr.write_char('{');\n-            self.indent += 2;\n-            f();\n-            self.wr.write_char('\\n');\n-            self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char('}');\n-        }\n-    }\n-\n-    #[cfg(stage0)]\n-    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n-        if idx == 0 {\n-            self.wr.write_char('\\n');\n-        } else {\n-            self.wr.write_str(\",\\n\");\n-        }\n-        self.wr.write_str(spaces(self.indent));\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_str(\": \");\n-        f();\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n-        if idx == 0 {\n-            self.wr.write_char('\\n');\n-        } else {\n-            self.wr.write_str(\",\\n\");\n-        }\n-        self.wr.write_str(spaces(self.indent));\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_str(\": \");\n-        f();\n-    }\n-\n-    fn emit_tuple(&self, len: uint, f: &fn()) {\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_arg(&self, idx: uint, f: &fn()) {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) {\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option(&self, f: &fn()) { f(); }\n-    fn emit_option_none(&self) { self.emit_nil(); }\n-    fn emit_option_some(&self, f: &fn()) { f(); }\n-\n-    fn emit_seq(&self, len: uint, f: &fn()) {\n-        if len == 0 {\n-            self.wr.write_str(\"[]\");\n-        } else {\n-            self.wr.write_char('[');\n-            self.indent += 2;\n-            f();\n-            self.wr.write_char('\\n');\n-            self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char(']');\n-        }\n-    }\n-\n-    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n-        if idx == 0 {\n-            self.wr.write_char('\\n');\n-        } else {\n-            self.wr.write_str(\",\\n\");\n-        }\n-        self.wr.write_str(spaces(self.indent));\n-        f()\n-    }\n-\n-    fn emit_map(&self, len: uint, f: &fn()) {\n-        if len == 0 {\n-            self.wr.write_str(\"{}\");\n-        } else {\n-            self.wr.write_char('{');\n-            self.indent += 2;\n-            f();\n-            self.wr.write_char('\\n');\n-            self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char('}');\n-        }\n-    }\n-\n-    fn emit_map_elt_key(&self, idx: uint, f: &fn()) {\n-        if idx == 0 {\n-            self.wr.write_char('\\n');\n-        } else {\n-            self.wr.write_str(\",\\n\");\n-        }\n-        self.wr.write_str(spaces(self.indent));\n-        f();\n-    }\n-\n-    fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n-        self.wr.write_str(\": \");\n-        f();\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl serialize::Encoder for PrettyEncoder {\n     fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n \n@@ -765,21 +425,6 @@ impl serialize::Encoder for PrettyEncoder {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n-    fn encode(&self, e: &E) {\n-        match *self {\n-            Number(v) => v.encode(e),\n-            String(ref v) => v.encode(e),\n-            Boolean(v) => v.encode(e),\n-            List(ref v) => v.encode(e),\n-            Object(ref v) => v.encode(e),\n-            Null => e.emit_nil(),\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n     fn encode(&self, e: &mut E) {\n         match *self {\n@@ -794,14 +439,6 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n }\n \n /// Encodes a json value into a io::writer\n-#[cfg(stage0)]\n-pub fn to_writer(wr: @io::Writer, json: &Json) {\n-    let encoder = Encoder(wr);\n-    json.encode(&encoder)\n-}\n-\n-/// Encodes a json value into a io::writer\n-#[cfg(not(stage0))]\n pub fn to_writer(wr: @io::Writer, json: &Json) {\n     let mut encoder = Encoder(wr);\n     json.encode(&mut encoder)\n@@ -813,14 +450,6 @@ pub fn to_str(json: &Json) -> ~str {\n }\n \n /// Encodes a json value into a io::writer\n-#[cfg(stage0)]\n-pub fn to_pretty_writer(wr: @io::Writer, json: &Json) {\n-    let encoder = PrettyEncoder(wr);\n-    json.encode(&encoder)\n-}\n-\n-/// Encodes a json value into a io::writer\n-#[cfg(not(stage0))]\n pub fn to_pretty_writer(wr: @io::Writer, json: &Json) {\n     let mut encoder = PrettyEncoder(wr);\n     json.encode(&mut encoder)\n@@ -1219,243 +848,6 @@ pub fn Decoder(json: Json) -> Decoder {\n     }\n }\n \n-#[cfg(stage0)]\n-impl serialize::Decoder for Decoder {\n-    fn read_nil(&self) -> () {\n-        debug!(\"read_nil\");\n-        match self.stack.pop() {\n-            Null => (),\n-            value => fail!(fmt!(\"not a null: %?\", value))\n-        }\n-    }\n-\n-    fn read_u64(&self)  -> u64  { self.read_float() as u64 }\n-    fn read_u32(&self)  -> u32  { self.read_float() as u32 }\n-    fn read_u16(&self)  -> u16  { self.read_float() as u16 }\n-    fn read_u8 (&self)  -> u8   { self.read_float() as u8 }\n-    fn read_uint(&self) -> uint { self.read_float() as uint }\n-\n-    fn read_i64(&self) -> i64 { self.read_float() as i64 }\n-    fn read_i32(&self) -> i32 { self.read_float() as i32 }\n-    fn read_i16(&self) -> i16 { self.read_float() as i16 }\n-    fn read_i8 (&self) -> i8  { self.read_float() as i8 }\n-    fn read_int(&self) -> int { self.read_float() as int }\n-\n-    fn read_bool(&self) -> bool {\n-        debug!(\"read_bool\");\n-        match self.stack.pop() {\n-            Boolean(b) => b,\n-            value => fail!(fmt!(\"not a boolean: %?\", value))\n-        }\n-    }\n-\n-    fn read_f64(&self) -> f64 { self.read_float() as f64 }\n-    fn read_f32(&self) -> f32 { self.read_float() as f32 }\n-    fn read_float(&self) -> float {\n-        debug!(\"read_float\");\n-        match self.stack.pop() {\n-            Number(f) => f,\n-            value => fail!(fmt!(\"not a number: %?\", value))\n-        }\n-    }\n-\n-    fn read_char(&self) -> char {\n-        let mut v = ~[];\n-        for str::each_char(self.read_str()) |c| { v.push(c) }\n-        if v.len() != 1 { fail!(~\"string must have one character\") }\n-        v[0]\n-    }\n-\n-    fn read_str(&self) -> ~str {\n-        debug!(\"read_str\");\n-        match self.stack.pop() {\n-            String(s) => s,\n-            json => fail!(fmt!(\"not a string: %?\", json))\n-        }\n-    }\n-\n-    fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n-        debug!(\"read_enum(%s)\", name);\n-        f()\n-    }\n-\n-    fn read_enum_variant<T>(&self,\n-                            names: &[&str],\n-                            f: &fn(uint) -> T)\n-                            -> T {\n-        debug!(\"read_enum_variant(names=%?)\", names);\n-        let name = match self.stack.pop() {\n-            String(s) => s,\n-            List(list) => {\n-                do vec::consume_reverse(list) |_i, v| {\n-                    self.stack.push(v);\n-                }\n-                match self.stack.pop() {\n-                    String(s) => s,\n-                    value => fail!(fmt!(\"invalid variant name: %?\", value)),\n-                }\n-            }\n-            ref json => fail!(fmt!(\"invalid variant: %?\", *json)),\n-        };\n-        let idx = match vec::position(names, |n| str::eq_slice(*n, name)) {\n-            Some(idx) => idx,\n-            None => fail!(fmt!(\"Unknown variant name: %?\", name)),\n-        };\n-        f(idx)\n-    }\n-\n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-        f()\n-    }\n-\n-    fn read_enum_struct_variant<T>(&self,\n-                                   names: &[&str],\n-                                   f: &fn(uint) -> T)\n-                                   -> T {\n-        debug!(\"read_enum_struct_variant(names=%?)\", names);\n-        self.read_enum_variant(names, f)\n-    }\n-\n-\n-    fn read_enum_struct_variant_field<T>(&self,\n-                                         name: &str,\n-                                         idx: uint,\n-                                         f: &fn() -> T)\n-                                         -> T {\n-        debug!(\"read_enum_struct_variant_field(name=%?, idx=%u)\", name, idx);\n-        self.read_enum_variant_arg(idx, f)\n-    }\n-\n-    fn read_struct<T>(&self, name: &str, len: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_struct(name=%s, len=%u)\", name, len);\n-        let value = f();\n-        self.stack.pop();\n-        value\n-    }\n-\n-    #[cfg(stage0)]\n-    fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n-        match self.stack.pop() {\n-            Object(obj) => {\n-                let mut obj = obj;\n-                let value = match obj.pop(&name.to_owned()) {\n-                    None => fail!(fmt!(\"no such field: %s\", name)),\n-                    Some(json) => {\n-                        self.stack.push(json);\n-                        f()\n-                    }\n-                };\n-                self.stack.push(Object(obj));\n-                value\n-            }\n-            value => fail!(fmt!(\"not an object: %?\", value))\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn read_struct_field<T>(&self,\n-                            name: &str,\n-                            idx: uint,\n-                            f: &fn() -> T)\n-                            -> T {\n-        debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n-        match self.stack.pop() {\n-            Object(obj) => {\n-                let mut obj = obj;\n-                let value = match obj.pop(&name.to_owned()) {\n-                    None => fail!(fmt!(\"no such field: %s\", name)),\n-                    Some(json) => {\n-                        self.stack.push(json);\n-                        f()\n-                    }\n-                };\n-                self.stack.push(Object(obj));\n-                value\n-            }\n-            value => fail!(fmt!(\"not an object: %?\", value))\n-        }\n-    }\n-\n-    fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T {\n-        debug!(\"read_tuple()\");\n-        self.read_seq(f)\n-    }\n-\n-    fn read_tuple_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_tuple_arg(idx=%u)\", idx);\n-        self.read_seq_elt(idx, f)\n-    }\n-\n-    fn read_tuple_struct<T>(&self, name: &str, f: &fn(uint) -> T) -> T {\n-        debug!(\"read_tuple_struct(name=%?)\", name);\n-        self.read_tuple(f)\n-    }\n-\n-    fn read_tuple_struct_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n-        self.read_tuple_arg(idx, f)\n-    }\n-\n-    fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n-        match self.stack.pop() {\n-            Null => f(false),\n-            value => { self.stack.push(value); f(true) }\n-        }\n-    }\n-\n-    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n-        debug!(\"read_seq()\");\n-        let len = match self.stack.pop() {\n-            List(list) => {\n-                let len = list.len();\n-                do vec::consume_reverse(list) |_i, v| {\n-                    self.stack.push(v);\n-                }\n-                len\n-            }\n-            _ => fail!(~\"not a list\"),\n-        };\n-        f(len)\n-    }\n-\n-    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_seq_elt(idx=%u)\", idx);\n-        f()\n-    }\n-\n-    fn read_map<T>(&self, f: &fn(uint) -> T) -> T {\n-        debug!(\"read_map()\");\n-        let len = match self.stack.pop() {\n-            Object(obj) => {\n-                let mut obj = obj;\n-                let len = obj.len();\n-                do obj.consume |key, value| {\n-                    self.stack.push(value);\n-                    self.stack.push(String(key));\n-                }\n-                len\n-            }\n-            json => fail!(fmt!(\"not an object: %?\", json)),\n-        };\n-        f(len)\n-    }\n-\n-    fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_map_elt_key(idx=%u)\", idx);\n-        f()\n-    }\n-\n-    fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_map_elt_val(idx=%u)\", idx);\n-        f()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl serialize::Decoder for Decoder {\n     fn read_nil(&mut self) -> () {\n         debug!(\"read_nil\");\n@@ -1577,29 +969,6 @@ impl serialize::Decoder for Decoder {\n         value\n     }\n \n-    #[cfg(stage0)]\n-    fn read_field<T>(&mut self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n-        match self.stack.pop() {\n-            Object(obj) => {\n-                let mut obj = obj;\n-                let value = match obj.pop(&name.to_owned()) {\n-                    None => fail!(fmt!(\"no such field: %s\", name)),\n-                    Some(json) => {\n-                        self.stack.push(json);\n-                        f()\n-                    }\n-                };\n-                self.stack.push(Object(obj));\n-                value\n-            }\n-            value => fail!(fmt!(\"not an object: %?\", value))\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn read_struct_field<T>(&mut self,\n                             name: &str,\n                             idx: uint,"}, {"sha": "33fe1cfff8e59b0deb699cb12c2635034765009f", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -45,25 +45,9 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n \n pub impl <T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n-    #[cfg(stage0)]\n-    fn top(&self) -> &'self T { &self.data[0] }\n-\n-    /// Returns the greatest item in the queue - fails if empty\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n \n     /// Returns the greatest item in the queue - None if empty\n-    #[cfg(stage0)]\n-    fn maybe_top(&self) -> Option<&'self T> {\n-        if self.is_empty() { None } else { Some(self.top()) }\n-    }\n-\n-    /// Returns the greatest item in the queue - None if empty\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }"}, {"sha": "a5d2604b6f6db5b6c5f3126e2af263fda3bd019b", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 6, "deletions": 984, "changes": 990, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -20,80 +20,8 @@ use core::hashmap::{HashMap, HashSet};\n use core::trie::{TrieMap, TrieSet};\n use deque::Deque;\n use dlist::DList;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n use treemap::{TreeMap, TreeSet};\n \n-#[cfg(stage0)]\n-pub trait Encoder {\n-    // Primitive types:\n-    fn emit_nil(&self);\n-    fn emit_uint(&self, v: uint);\n-    fn emit_u64(&self, v: u64);\n-    fn emit_u32(&self, v: u32);\n-    fn emit_u16(&self, v: u16);\n-    fn emit_u8(&self, v: u8);\n-    fn emit_int(&self, v: int);\n-    fn emit_i64(&self, v: i64);\n-    fn emit_i32(&self, v: i32);\n-    fn emit_i16(&self, v: i16);\n-    fn emit_i8(&self, v: i8);\n-    fn emit_bool(&self, v: bool);\n-    fn emit_float(&self, v: float);\n-    fn emit_f64(&self, v: f64);\n-    fn emit_f32(&self, v: f32);\n-    fn emit_char(&self, v: char);\n-    fn emit_str(&self, v: &str);\n-\n-    // Compound types:\n-    fn emit_enum(&self, name: &str, f: &fn());\n-\n-    fn emit_enum_variant(&self,\n-                         v_name: &str,\n-                         v_id: uint,\n-                         len: uint,\n-                         f: &fn());\n-    fn emit_enum_variant_arg(&self, a_idx: uint, f: &fn());\n-\n-    fn emit_enum_struct_variant(&self,\n-                                v_name: &str,\n-                                v_id: uint,\n-                                len: uint,\n-                                f: &fn());\n-    fn emit_enum_struct_variant_field(&self,\n-                                      f_name: &str,\n-                                      f_idx: uint,\n-                                      f: &fn());\n-\n-    fn emit_struct(&self, name: &str, len: uint, f: &fn());\n-    #[cfg(stage0)]\n-    fn emit_field(&self, f_name: &str, f_idx: uint, f: &fn());\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn emit_struct_field(&self, f_name: &str, f_idx: uint, f: &fn());\n-\n-    fn emit_tuple(&self, len: uint, f: &fn());\n-    fn emit_tuple_arg(&self, idx: uint, f: &fn());\n-\n-    fn emit_tuple_struct(&self, name: &str, len: uint, f: &fn());\n-    fn emit_tuple_struct_arg(&self, f_idx: uint, f: &fn());\n-\n-    // Specialized types:\n-    fn emit_option(&self, f: &fn());\n-    fn emit_option_none(&self);\n-    fn emit_option_some(&self, f: &fn());\n-\n-    fn emit_seq(&self, len: uint, f: &fn());\n-    fn emit_seq_elt(&self, idx: uint, f: &fn());\n-\n-    fn emit_map(&self, len: uint, f: &fn());\n-    fn emit_map_elt_key(&self, idx: uint, f: &fn());\n-    fn emit_map_elt_val(&self, idx: uint, f: &fn());\n-}\n-\n-#[cfg(not(stage0))]\n pub trait Encoder {\n     // Primitive types:\n     fn emit_nil(&mut self);\n@@ -159,80 +87,6 @@ pub trait Encoder {\n     fn emit_map_elt_val(&mut self, idx: uint, f: &fn(&mut Self));\n }\n \n-#[cfg(stage0)]\n-pub trait Decoder {\n-    // Primitive types:\n-    fn read_nil(&self) -> ();\n-    fn read_uint(&self) -> uint;\n-    fn read_u64(&self) -> u64;\n-    fn read_u32(&self) -> u32;\n-    fn read_u16(&self) -> u16;\n-    fn read_u8(&self) -> u8;\n-    fn read_int(&self) -> int;\n-    fn read_i64(&self) -> i64;\n-    fn read_i32(&self) -> i32;\n-    fn read_i16(&self) -> i16;\n-    fn read_i8(&self) -> i8;\n-    fn read_bool(&self) -> bool;\n-    fn read_f64(&self) -> f64;\n-    fn read_f32(&self) -> f32;\n-    fn read_float(&self) -> float;\n-    fn read_char(&self) -> char;\n-    fn read_str(&self) -> ~str;\n-\n-    // Compound types:\n-    fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T;\n-\n-    fn read_enum_variant<T>(&self,\n-                            names: &[&str],\n-                            f: &fn(uint) -> T)\n-                            -> T;\n-    fn read_enum_variant_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n-\n-    fn read_enum_struct_variant<T>(&self,\n-                                   names: &[&str],\n-                                   f: &fn(uint) -> T)\n-                                   -> T;\n-    fn read_enum_struct_variant_field<T>(&self,\n-                                         &f_name: &str,\n-                                         f_idx: uint,\n-                                         f: &fn() -> T)\n-                                         -> T;\n-\n-    fn read_struct<T>(&self, s_name: &str, len: uint, f: &fn() -> T) -> T;\n-    #[cfg(stage0)]\n-    fn read_field<T>(&self,\n-                     f_name: &str,\n-                     f_idx: uint,\n-                     f: &fn() -> T)\n-                     -> T;\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn read_struct_field<T>(&self,\n-                            f_name: &str,\n-                            f_idx: uint,\n-                            f: &fn() -> T)\n-                            -> T;\n-\n-    fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_tuple_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n-\n-    fn read_tuple_struct<T>(&self, s_name: &str, f: &fn(uint) -> T) -> T;\n-    fn read_tuple_struct_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n-\n-    // Specialized types:\n-    fn read_option<T>(&self, f: &fn(bool) -> T) -> T;\n-\n-    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n-\n-    fn read_map<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T;\n-    fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T;\n-}\n-\n-#[cfg(not(stage0))]\n pub trait Decoder {\n     // Primitive types:\n     fn read_nil(&mut self) -> ();\n@@ -280,15 +134,6 @@ pub trait Decoder {\n                       len: uint,\n                       f: &fn(&mut Self) -> T)\n                       -> T;\n-    #[cfg(stage0)]\n-    fn read_field<T>(&mut self,\n-                     f_name: &str,\n-                     f_idx: uint,\n-                     f: &fn() -> T)\n-                     -> T;\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn read_struct_field<T>(&mut self,\n                             f_name: &str,\n                             f_idx: uint,\n@@ -318,598 +163,254 @@ pub trait Decoder {\n     fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n }\n \n-#[cfg(stage0)]\n-pub trait Encodable<S:Encoder> {\n-    fn encode(&self, s: &S);\n-}\n-\n-#[cfg(not(stage0))]\n pub trait Encodable<S:Encoder> {\n     fn encode(&self, s: &mut S);\n }\n \n-#[cfg(stage0)]\n-pub trait Decodable<D:Decoder> {\n-    fn decode(d: &D) -> Self;\n-}\n-\n-#[cfg(not(stage0))]\n pub trait Decodable<D:Decoder> {\n     fn decode(d: &mut D) -> Self;\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for uint {\n-    fn encode(&self, s: &S) {\n-        s.emit_uint(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for uint {\n     fn encode(&self, s: &mut S) {\n         s.emit_uint(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for uint {\n-    fn decode(d: &D) -> uint {\n-        d.read_uint()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for uint {\n     fn decode(d: &mut D) -> uint {\n         d.read_uint()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for u8 {\n-    fn encode(&self, s: &S) {\n-        s.emit_u8(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for u8 {\n     fn encode(&self, s: &mut S) {\n         s.emit_u8(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for u8 {\n-    fn decode(d: &D) -> u8 {\n-        d.read_u8()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for u8 {\n     fn decode(d: &mut D) -> u8 {\n         d.read_u8()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for u16 {\n-    fn encode(&self, s: &S) {\n-        s.emit_u16(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for u16 {\n     fn encode(&self, s: &mut S) {\n         s.emit_u16(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for u16 {\n-    fn decode(d: &D) -> u16 {\n-        d.read_u16()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for u16 {\n     fn decode(d: &mut D) -> u16 {\n         d.read_u16()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for u32 {\n-    fn encode(&self, s: &S) {\n-        s.emit_u32(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for u32 {\n     fn encode(&self, s: &mut S) {\n         s.emit_u32(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for u32 {\n-    fn decode(d: &D) -> u32 {\n-        d.read_u32()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for u32 {\n     fn decode(d: &mut D) -> u32 {\n         d.read_u32()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for u64 {\n-    fn encode(&self, s: &S) {\n-        s.emit_u64(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for u64 {\n     fn encode(&self, s: &mut S) {\n         s.emit_u64(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for u64 {\n-    fn decode(d: &D) -> u64 {\n-        d.read_u64()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for u64 {\n     fn decode(d: &mut D) -> u64 {\n         d.read_u64()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for int {\n-    fn encode(&self, s: &S) {\n-        s.emit_int(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for int {\n     fn encode(&self, s: &mut S) {\n         s.emit_int(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for int {\n-    fn decode(d: &D) -> int {\n-        d.read_int()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for int {\n     fn decode(d: &mut D) -> int {\n         d.read_int()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for i8 {\n-    fn encode(&self, s: &S) {\n-        s.emit_i8(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for i8 {\n     fn encode(&self, s: &mut S) {\n         s.emit_i8(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for i8 {\n-    fn decode(d: &D) -> i8 {\n-        d.read_i8()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for i8 {\n     fn decode(d: &mut D) -> i8 {\n         d.read_i8()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for i16 {\n-    fn encode(&self, s: &S) {\n-        s.emit_i16(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for i16 {\n     fn encode(&self, s: &mut S) {\n         s.emit_i16(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for i16 {\n-    fn decode(d: &D) -> i16 {\n-        d.read_i16()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for i16 {\n     fn decode(d: &mut D) -> i16 {\n         d.read_i16()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for i32 {\n-    fn encode(&self, s: &S) {\n-        s.emit_i32(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for i32 {\n     fn encode(&self, s: &mut S) {\n         s.emit_i32(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for i32 {\n-    fn decode(d: &D) -> i32 {\n-        d.read_i32()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for i32 {\n     fn decode(d: &mut D) -> i32 {\n         d.read_i32()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for i64 {\n-    fn encode(&self, s: &S) {\n-        s.emit_i64(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for i64 {\n     fn encode(&self, s: &mut S) {\n         s.emit_i64(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for i64 {\n-    fn decode(d: &D) -> i64 {\n-        d.read_i64()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for i64 {\n     fn decode(d: &mut D) -> i64 {\n         d.read_i64()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'self, S:Encoder> Encodable<S> for &'self str {\n-    fn encode(&self, s: &S) {\n-        s.emit_str(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'self, S:Encoder> Encodable<S> for &'self str {\n     fn encode(&self, s: &mut S) {\n         s.emit_str(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for ~str {\n-    fn encode(&self, s: &S) {\n-        s.emit_str(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for ~str {\n     fn encode(&self, s: &mut S) {\n         s.emit_str(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for ~str {\n-    fn decode(d: &D) -> ~str {\n-        d.read_str()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for ~str {\n     fn decode(d: &mut D) -> ~str {\n         d.read_str()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for @str {\n-    fn encode(&self, s: &S) {\n-        s.emit_str(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for @str {\n     fn encode(&self, s: &mut S) {\n         s.emit_str(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for @str {\n-    fn decode(d: &D) -> @str {\n-        d.read_str().to_managed()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for @str {\n     fn decode(d: &mut D) -> @str {\n         d.read_str().to_managed()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for float {\n-    fn encode(&self, s: &S) {\n-        s.emit_float(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for float {\n     fn encode(&self, s: &mut S) {\n         s.emit_float(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for float {\n-    fn decode(d: &D) -> float {\n-        d.read_float()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for float {\n     fn decode(d: &mut D) -> float {\n         d.read_float()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for f32 {\n-    fn encode(&self, s: &S) {\n-        s.emit_f32(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for f32 {\n     fn encode(&self, s: &mut S) {\n         s.emit_f32(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for f32 {\n-    fn decode(d: &D) -> f32 {\n-        d.read_f32()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for f32 {\n     fn decode(d: &mut D) -> f32 {\n         d.read_f32()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for f64 {\n-    fn encode(&self, s: &S) {\n-        s.emit_f64(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for f64 {\n     fn encode(&self, s: &mut S) {\n         s.emit_f64(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for f64 {\n-    fn decode(d: &D) -> f64 {\n-        d.read_f64()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for f64 {\n     fn decode(d: &mut D) -> f64 {\n         d.read_f64()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for bool {\n-    fn encode(&self, s: &S) {\n-        s.emit_bool(*self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for bool {\n     fn encode(&self, s: &mut S) {\n         s.emit_bool(*self)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for bool {\n-    fn decode(d: &D) -> bool {\n-        d.read_bool()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for bool {\n     fn decode(d: &mut D) -> bool {\n         d.read_bool()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for () {\n-    fn encode(&self, s: &S) {\n-        s.emit_nil()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for () {\n     fn encode(&self, s: &mut S) {\n         s.emit_nil()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for () {\n-    fn decode(d: &D) -> () {\n-        d.read_nil()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for () {\n     fn decode(d: &mut D) -> () {\n         d.read_nil()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self T {\n-    fn encode(&self, s: &S) {\n-        (**self).encode(s)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self T {\n     fn encode(&self, s: &mut S) {\n         (**self).encode(s)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n-    fn encode(&self, s: &S) {\n-        (**self).encode(s)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n     fn encode(&self, s: &mut S) {\n         (**self).encode(s)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n-    fn decode(d: &D) -> ~T {\n-        ~Decodable::decode(d)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n     fn decode(d: &mut D) -> ~T {\n         ~Decodable::decode(d)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n-    fn encode(&self, s: &S) {\n-        (**self).encode(s)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n     fn encode(&self, s: &mut S) {\n         (**self).encode(s)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n-    fn decode(d: &D) -> @T {\n-        @Decodable::decode(d)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n     fn decode(d: &mut D) -> @T {\n         @Decodable::decode(d)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_seq_elt(i, || e.encode(s))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n@@ -920,18 +421,6 @@ impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_seq_elt(i, || e.encode(s))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n@@ -942,18 +431,6 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n-    fn decode(d: &D) -> ~[T] {\n-        do d.read_seq |len| {\n-            do vec::from_fn(len) |i| {\n-                d.read_seq_elt(i, || Decodable::decode(d))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     fn decode(d: &mut D) -> ~[T] {\n         do d.read_seq |d, len| {\n@@ -964,18 +441,6 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_seq_elt(i, || e.encode(s))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n@@ -986,18 +451,6 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n-    fn decode(d: &D) -> @[T] {\n-        do d.read_seq |len| {\n-            do at_vec::from_fn(len) |i| {\n-                d.read_seq_elt(i, || Decodable::decode(d))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     fn decode(d: &mut D) -> @[T] {\n         do d.read_seq |d, len| {\n@@ -1008,19 +461,6 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_option {\n-            match *self {\n-                None => s.emit_option_none(),\n-                Some(ref v) => s.emit_option_some(|| v.encode(s)),\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_option |s| {\n@@ -1032,47 +472,18 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n-    fn decode(d: &D) -> Option<T> {\n-        do d.read_option |b| {\n-            if b {\n-                Some(Decodable::decode(d))\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n-    fn decode(d: &mut D) -> Option<T> {\n-        do d.read_option |d, b| {\n-            if b {\n-                Some(Decodable::decode(d))\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n-    fn encode(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1) => {\n-                do s.emit_seq(2) {\n-                    s.emit_seq_elt(0, || t0.encode(s));\n-                    s.emit_seq_elt(1, || t1.encode(s));\n-                }\n+    fn decode(d: &mut D) -> Option<T> {\n+        do d.read_option |d, b| {\n+            if b {\n+                Some(Decodable::decode(d))\n+            } else {\n+                None\n             }\n         }\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n     fn encode(&self, s: &mut S) {\n         match *self {\n@@ -1086,20 +497,6 @@ impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n-    fn decode(d: &D) -> (T0, T1) {\n-        do d.read_seq |len| {\n-            assert!(len == 2);\n-            (\n-                d.read_seq_elt(0, || Decodable::decode(d)),\n-                d.read_seq_elt(1, || Decodable::decode(d))\n-            )\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n     fn decode(d: &mut D) -> (T0, T1) {\n         do d.read_seq |d, len| {\n@@ -1112,27 +509,6 @@ impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>\n-> Encodable<S> for (T0, T1, T2) {\n-    fn encode(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2) => {\n-                do s.emit_seq(3) {\n-                    s.emit_seq_elt(0, || t0.encode(s));\n-                    s.emit_seq_elt(1, || t1.encode(s));\n-                    s.emit_seq_elt(2, || t2.encode(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     S: Encoder,\n     T0: Encodable<S>,\n@@ -1152,26 +528,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>\n-> Decodable<D> for (T0, T1, T2) {\n-    fn decode(d: &D) -> (T0, T1, T2) {\n-        do d.read_seq |len| {\n-            assert!(len == 3);\n-            (\n-                d.read_seq_elt(0, || Decodable::decode(d)),\n-                d.read_seq_elt(1, || Decodable::decode(d)),\n-                d.read_seq_elt(2, || Decodable::decode(d))\n-            )\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     T0: Decodable<D>,\n@@ -1190,29 +546,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>\n-> Encodable<S> for (T0, T1, T2, T3) {\n-    fn encode(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_seq(4) {\n-                    s.emit_seq_elt(0, || t0.encode(s));\n-                    s.emit_seq_elt(1, || t1.encode(s));\n-                    s.emit_seq_elt(2, || t2.encode(s));\n-                    s.emit_seq_elt(3, || t3.encode(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     S: Encoder,\n     T0: Encodable<S>,\n@@ -1234,28 +567,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>\n-> Decodable<D> for (T0, T1, T2, T3) {\n-    fn decode(d: &D) -> (T0, T1, T2, T3) {\n-        do d.read_seq |len| {\n-            assert!(len == 4);\n-            (\n-                d.read_seq_elt(0, || Decodable::decode(d)),\n-                d.read_seq_elt(1, || Decodable::decode(d)),\n-                d.read_seq_elt(2, || Decodable::decode(d)),\n-                d.read_seq_elt(3, || Decodable::decode(d))\n-            )\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     T0: Decodable<D>,\n@@ -1276,31 +587,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>,\n-    T4: Encodable<S>\n-> Encodable<S> for (T0, T1, T2, T3, T4) {\n-    fn encode(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_seq(5) {\n-                    s.emit_seq_elt(0, || t0.encode(s));\n-                    s.emit_seq_elt(1, || t1.encode(s));\n-                    s.emit_seq_elt(2, || t2.encode(s));\n-                    s.emit_seq_elt(3, || t3.encode(s));\n-                    s.emit_seq_elt(4, || t4.encode(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     S: Encoder,\n     T0: Encodable<S>,\n@@ -1324,30 +610,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>,\n-    T4: Decodable<D>\n-> Decodable<D> for (T0, T1, T2, T3, T4) {\n-    fn decode(d: &D) -> (T0, T1, T2, T3, T4) {\n-        do d.read_seq |len| {\n-            assert!(len == 5);\n-            (\n-                d.read_seq_elt(0, || Decodable::decode(d)),\n-                d.read_seq_elt(1, || Decodable::decode(d)),\n-                d.read_seq_elt(2, || Decodable::decode(d)),\n-                d.read_seq_elt(3, || Decodable::decode(d)),\n-                d.read_seq_elt(4, || Decodable::decode(d))\n-            )\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     T0: Decodable<D>,\n@@ -1370,23 +632,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    S: Encoder,\n-    T: Encodable<S> + Copy\n-> Encodable<S> for @mut DList<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.size) {\n-            let mut i = 0;\n-            for self.each |e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n-                i += 1;\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     S: Encoder,\n     T: Encodable<S> + Copy\n@@ -1402,20 +647,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n-    fn decode(d: &D) -> @mut DList<T> {\n-        let list = DList();\n-        do d.read_seq |len| {\n-            for uint::range(0, len) |i| {\n-                list.push(d.read_seq_elt(i, || Decodable::decode(d)));\n-            }\n-        }\n-        list\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n     fn decode(d: &mut D) -> @mut DList<T> {\n         let list = DList();\n@@ -1428,21 +659,6 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    S: Encoder,\n-    T: Encodable<S>\n-> Encodable<S> for Deque<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     S: Encoder,\n     T: Encodable<S>\n@@ -1456,20 +672,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n-    fn decode(d: &D) -> Deque<T> {\n-        let mut deque = Deque::new();\n-        do d.read_seq |len| {\n-            for uint::range(0, len) |i| {\n-                deque.add_back(d.read_seq_elt(i, || Decodable::decode(d)));\n-            }\n-        }\n-        deque\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n     fn decode(d: &mut D) -> Deque<T> {\n         let mut deque = Deque::new();\n@@ -1482,25 +684,6 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    E: Encoder,\n-    K: Encodable<E> + Hash + IterBytes + Eq,\n-    V: Encodable<E>\n-> Encodable<E> for HashMap<K, V> {\n-    fn encode(&self, e: &E) {\n-        do e.emit_map(self.len()) {\n-            let mut i = 0;\n-            for self.each |key, val| {\n-                e.emit_map_elt_key(i, || key.encode(e));\n-                e.emit_map_elt_val(i, || val.encode(e));\n-                i += 1;\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     E: Encoder,\n     K: Encodable<E> + Hash + IterBytes + Eq,\n@@ -1518,26 +701,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    D: Decoder,\n-    K: Decodable<D> + Hash + IterBytes + Eq,\n-    V: Decodable<D>\n-> Decodable<D> for HashMap<K, V> {\n-    fn decode(d: &D) -> HashMap<K, V> {\n-        do d.read_map |len| {\n-            let mut map = HashMap::with_capacity(len);\n-            for uint::range(0, len) |i| {\n-                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     K: Decodable<D> + Hash + IterBytes + Eq,\n@@ -1556,23 +719,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    S: Encoder,\n-    T: Encodable<S> + Hash + IterBytes + Eq\n-> Encodable<S> for HashSet<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n-            let mut i = 0;\n-            for self.each |e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n-                i += 1;\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     S: Encoder,\n     T: Encodable<S> + Hash + IterBytes + Eq\n@@ -1588,23 +734,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    D: Decoder,\n-    T: Decodable<D> + Hash + IterBytes + Eq\n-> Decodable<D> for HashSet<T> {\n-    fn decode(d: &D) -> HashSet<T> {\n-        do d.read_seq |len| {\n-            let mut set = HashSet::with_capacity(len);\n-            for uint::range(0, len) |i| {\n-                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n-            }\n-            set\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     T: Decodable<D> + Hash + IterBytes + Eq\n@@ -1620,24 +749,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    E: Encoder,\n-    V: Encodable<E>\n-> Encodable<E> for TrieMap<V> {\n-    fn encode(&self, e: &E) {\n-        do e.emit_map(self.len()) {\n-            let mut i = 0;\n-            for self.each |key, val| {\n-                e.emit_map_elt_key(i, || key.encode(e));\n-                e.emit_map_elt_val(i, || val.encode(e));\n-                i += 1;\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     E: Encoder,\n     V: Encodable<E>\n@@ -1654,25 +765,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<\n-    D: Decoder,\n-    V: Decodable<D>\n-> Decodable<D> for TrieMap<V> {\n-    fn decode(d: &D) -> TrieMap<V> {\n-        do d.read_map |len| {\n-            let mut map = TrieMap::new();\n-            for uint::range(0, len) |i| {\n-                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     V: Decodable<D>\n@@ -1690,20 +782,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Encoder> Encodable<S> for TrieSet {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n-            let mut i = 0;\n-            for self.each |e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n-                i += 1;\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S: Encoder> Encodable<S> for TrieSet {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n@@ -1716,20 +794,6 @@ impl<S: Encoder> Encodable<S> for TrieSet {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D: Decoder> Decodable<D> for TrieSet {\n-    fn decode(d: &D) -> TrieSet {\n-        do d.read_seq |len| {\n-            let mut set = TrieSet::new();\n-            for uint::range(0, len) |i| {\n-                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n-            }\n-            set\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D: Decoder> Decodable<D> for TrieSet {\n     fn decode(d: &mut D) -> TrieSet {\n         do d.read_seq |d, len| {\n@@ -1742,7 +806,6 @@ impl<D: Decoder> Decodable<D> for TrieSet {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<\n     E: Encoder,\n     K: Encodable<E> + Eq + TotalOrd,\n@@ -1760,7 +823,6 @@ impl<\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     K: Decodable<D> + Eq + TotalOrd,\n@@ -1779,7 +841,6 @@ impl<\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<\n     S: Encoder,\n     T: Encodable<S> + Eq + TotalOrd\n@@ -1795,7 +856,6 @@ impl<\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<\n     D: Decoder,\n     T: Decodable<D> + Eq + TotalOrd\n@@ -1816,30 +876,10 @@ impl<\n //\n // In some cases, these should eventually be coded as traits.\n \n-#[cfg(stage0)]\n-pub trait EncoderHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T));\n-}\n-\n-#[cfg(not(stage0))]\n pub trait EncoderHelpers {\n     fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut Self, v: &T));\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T)) {\n-        do self.emit_seq(v.len()) {\n-            for v.eachi |i, e| {\n-                do self.emit_seq_elt(i) {\n-                    f(e)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut S, &T)) {\n         do self.emit_seq(v.len()) |this| {\n@@ -1852,28 +892,10 @@ impl<S:Encoder> EncoderHelpers for S {\n     }\n }\n \n-#[cfg(stage0)]\n-pub trait DecoderHelpers {\n-    fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T];\n-}\n-\n-#[cfg(not(stage0))]\n pub trait DecoderHelpers {\n     fn read_to_vec<T>(&mut self, f: &fn(&mut Self) -> T) -> ~[T];\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T] {\n-        do self.read_seq |len| {\n-            do vec::from_fn(len) |i| {\n-                self.read_seq_elt(i, || f())\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> DecoderHelpers for D {\n     fn read_to_vec<T>(&mut self, f: &fn(&mut D) -> T) -> ~[T] {\n         do self.read_seq |this, len| {"}, {"sha": "1b72300a178bad17f20049474752741cba8d8eb3", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -50,20 +50,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all key-value pairs in order\n-    #[cfg(stage0)]\n-    fn each(&self, it: &fn(&uint, &'self V) -> bool) {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref elt) => if !it(&i, elt) { break },\n-              None => ()\n-            }\n-        }\n-    }\n-\n-    /// Visit all key-value pairs in order\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n@@ -79,15 +65,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all values in order\n-    #[cfg(stage0)]\n-    fn each_value(&self, blk: &fn(value: &V) -> bool) {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Visit all values in order\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n@@ -103,22 +80,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find(&self, key: &uint) -> Option<&'self V> {\n-        if *key < self.v.len() {\n-            match self.v[*key] {\n-              Some(ref value) => Some(value),\n-              None => None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Return a reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -131,22 +92,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find_mut(&mut self, key: &uint) -> Option<&'self mut V> {\n-        if *key < self.v.len() {\n-            match self.v[*key] {\n-              Some(ref mut value) => Some(value),\n-              None => None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -188,20 +133,6 @@ pub impl<V> SmallIntMap<V> {\n     fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n     /// Visit all key-value pairs in reverse order\n-    #[cfg(stage0)]\n-    fn each_reverse(&self, it: &fn(uint, &'self V) -> bool) {\n-        for uint::range_rev(self.v.len(), 0) |i| {\n-            match self.v[i - 1] {\n-              Some(ref elt) => if !it(i - 1, elt) { break },\n-              None => ()\n-            }\n-        }\n-    }\n-\n-    /// Visit all key-value pairs in reverse order\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n@@ -211,14 +142,6 @@ pub impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn get(&self, key: &uint) -> &'self V {\n-        self.find(key).expect(\"key not present\")\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }"}, {"sha": "4f9de29e7262faeeb81915d5fbb3c33d5e851635", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -71,7 +71,6 @@ pub mod rope;\n pub mod smallintmap;\n pub mod sort;\n pub mod dlist;\n-#[cfg(not(stage0))]\n pub mod treemap;\n \n // And ... other stuff\n@@ -91,13 +90,10 @@ pub mod cmp;\n pub mod base64;\n pub mod rl;\n pub mod workcache;\n-#[cfg(not(stage0))]\n #[path=\"num/bigint.rs\"]\n pub mod bigint;\n-#[cfg(not(stage0))]\n #[path=\"num/rational.rs\"]\n pub mod rational;\n-#[cfg(not(stage0))]\n #[path=\"num/complex.rs\"]\n pub mod complex;\n pub mod stats;"}, {"sha": "e681382ffc8289b213a4f89df0189c46a55ba409", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -138,19 +138,6 @@ impl WorkMap {\n     fn new() -> WorkMap { WorkMap(HashMap::new()) }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for WorkMap {\n-    fn encode(&self, s: &S) {\n-        let mut d = ~[];\n-        for self.each |k, v| {\n-            d.push((copy *k, copy *v))\n-        }\n-        sort::tim_sort(d);\n-        d.encode(s)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &mut S) {\n         let mut d = ~[];\n@@ -162,19 +149,6 @@ impl<S:Encoder> Encodable<S> for WorkMap {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for WorkMap {\n-    fn decode(d: &D) -> WorkMap {\n-        let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n-        let mut w = WorkMap::new();\n-        for v.each |&(k, v)| {\n-            w.insert(copy k, copy v);\n-        }\n-        w\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for WorkMap {\n     fn decode(d: &mut D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n@@ -253,14 +227,6 @@ struct Work<T> {\n     res: Option<Either<T,PortOne<(Exec,T)>>>\n }\n \n-#[cfg(stage0)]\n-fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    do io::with_str_writer |wr| {\n-        t.encode(&json::Encoder(wr));\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n     do io::with_str_writer |wr| {\n         let mut encoder = json::Encoder(wr);\n@@ -269,17 +235,6 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n }\n \n // FIXME(#5121)\n-#[cfg(stage0)]\n-fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n-    do io::with_str_reader(s) |rdr| {\n-        let j = result::unwrap(json::from_reader(rdr));\n-        let decoder = json::Decoder(j);\n-        Decodable::decode(&decoder)\n-    }\n-}\n-\n-// FIXME(#5121)\n-#[cfg(not(stage0))]\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     do io::with_str_reader(s) |rdr| {\n         let j = result::unwrap(json::from_reader(rdr));"}, {"sha": "2216226ecb3ab29d6243b4e347031994924524e6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -70,22 +70,6 @@ pub type Name = uint;\n // with a macro expansion\n pub type Mrk = uint;\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for ident {\n-    fn encode(&self, s: &S) {\n-        unsafe {\n-            let intr =\n-                match task::local_data::local_data_get(interner_key!()) {\n-                    None => fail!(~\"encode: TLS interner not set up\"),\n-                    Some(intr) => intr\n-                };\n-\n-            s.emit_str(*(*intr).get(*self));\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &mut S) {\n         unsafe {\n@@ -100,21 +84,6 @@ impl<S:Encoder> Encodable<S> for ident {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for ident {\n-    fn decode(d: &D) -> ident {\n-        let intr = match unsafe {\n-            task::local_data::local_data_get(interner_key!())\n-        } {\n-            None => fail!(~\"decode: TLS interner not set up\"),\n-            Some(intr) => intr\n-        };\n-\n-        (*intr).intern(@d.read_str())\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for ident {\n     fn decode(d: &mut D) -> ident {\n         let intr = match unsafe {"}, {"sha": "66ed52f03528e32ea84f440223b2aac2efe270b6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -125,28 +125,13 @@ impl cmp::Eq for span {\n     fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for span {\n-    /* Note #1972 -- spans are encoded but not decoded */\n-    fn encode(&self, _s: &S) { _s.emit_nil() }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder> Encodable<S> for span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, s: &mut S) {\n         s.emit_nil()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for span {\n-    fn decode(_d: &D) -> span {\n-        dummy_sp()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder> Decodable<D> for span {\n     fn decode(_d: &mut D) -> span {\n         dummy_sp()"}, {"sha": "e56dab6db207e1ff655b31dca05d65cf0f921189", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -451,17 +451,6 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // ugh: can't get this to compile with mut because of the\n     // lack of flow sensitivity.\n-    #[cfg(stage0)]\n-    fn get_map(&self) -> &'self HashMap<K,@V> {\n-        match *self {\n-            BaseMapChain (~ref map) => map,\n-            ConsMapChain (~ref map,_) => map\n-        }\n-    }\n-\n-    // ugh: can't get this to compile with mut because of the\n-    // lack of flow sensitivity.\n-    #[cfg(not(stage0))]\n     fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n         match *self {\n             BaseMapChain (~ref map) => map,"}, {"sha": "600ab964e5238fc52c09f5fb4880a9dae5d9a6c5", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -61,15 +61,6 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn get(&self, i: uint) -> &'self T {\n-        match *self {\n-            Empty => fail!(fmt!(\"Invalid index %u\", i)),\n-            Vec(ref v) => &v[i]\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n             Empty => fail!(fmt!(\"Invalid index %u\", i)),"}, {"sha": "c643b4dd25d43d6b10de9ef8cece24c17a919b8f", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8081e8debf63726865e869aaacbd040755285a51/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8081e8debf63726865e869aaacbd040755285a51/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=8081e8debf63726865e869aaacbd040755285a51", "patch": "@@ -1,3 +1,11 @@\n+S 2013-05-03 213f7b2\n+  macos-i386 0bf8b88ea01cc4cdd81ac4db1d301ea9b3371f13\n+  macos-x86_64 2da3990639ab5a9c9d51b3478c437cb459de84e3\n+  linux-i386 094500e587bfac27d7be752b635c242e07774c0d\n+  linux-x86_64 75733a5a58f53aa783253c8cfd56923b78676705\n+  winnt-i386 bd07c935a917c0796d4dc803d973b864d4794ade\n+  freebsd-x86_64 b95d648d9bfeacdd04cc5213bdc803b0fd94add7\n+\n S 2013-03-28 f7a2371\n   macos-i386 2e05a33716fc4982db53946c3b0dccf0194826fe\n   macos-x86_64 fbd3feec8dd17a6b6c8df114e6e9b4cd17cc6172"}]}