{"sha": "7164a9f151a56316a382d8bc2b15ccf373e129ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNjRhOWYxNTFhNTYzMTZhMzgyZDhiYzJiMTVjY2YzNzNlMTI5Y2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-21T13:55:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-21T13:55:45Z"}, "message": "Auto merge of #55045 - kleimkuhler:add-std-is_sorted, r=KodrAus\n\nAdd `is_sorted` to `Iterator` and `[T]`\n\nThis is an initial implementation for the first step of [RFC 2351](https://github.com/rust-lang/rfcs/blob/master/text/2351-is-sorted.md)\n\nTracking issue: https://github.com/rust-lang/rust/issues/53485", "tree": {"sha": "f6805eb9f6bf3ca6c37c8c1806a42c88a6c8119f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6805eb9f6bf3ca6c37c8c1806a42c88a6c8119f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7164a9f151a56316a382d8bc2b15ccf373e129ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7164a9f151a56316a382d8bc2b15ccf373e129ca", "html_url": "https://github.com/rust-lang/rust/commit/7164a9f151a56316a382d8bc2b15ccf373e129ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7164a9f151a56316a382d8bc2b15ccf373e129ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0974bdc7e8e0be00fded2309b5f01cd7cbf2d777", "url": "https://api.github.com/repos/rust-lang/rust/commits/0974bdc7e8e0be00fded2309b5f01cd7cbf2d777", "html_url": "https://github.com/rust-lang/rust/commit/0974bdc7e8e0be00fded2309b5f01cd7cbf2d777"}, {"sha": "b4766f80775a2635c026626070201356f33d2700", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4766f80775a2635c026626070201356f33d2700", "html_url": "https://github.com/rust-lang/rust/commit/b4766f80775a2635c026626070201356f33d2700"}], "stats": {"total": 275, "additions": 271, "deletions": 4}, "files": [{"sha": "e3b7dc3b28eb2fe62537b662ebce429c4ab1192e", "filename": "src/doc/unstable-book/src/library-features/is-sorted.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fis-sorted.md", "raw_url": "https://github.com/rust-lang/rust/raw/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fis-sorted.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fis-sorted.md?ref=7164a9f151a56316a382d8bc2b15ccf373e129ca", "patch": "@@ -0,0 +1,11 @@\n+# `is_sorted`\n+\n+The tracking issue for this feature is: [#53485]\n+\n+[#53485]: https://github.com/rust-lang/rust/issues/53485\n+\n+------------------------\n+\n+Add the methods `is_sorted`, `is_sorted_by` and `is_sorted_by_key` to `[T]`;\n+add the methods `is_sorted`, `is_sorted_by` and `is_sorted_by_key` to\n+`Iterator`."}, {"sha": "ac21586c0b8a91f40a8914c2b14fb0d282386bf6", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=7164a9f151a56316a382d8bc2b15ccf373e129ca", "patch": "@@ -2605,6 +2605,95 @@ pub trait Iterator {\n             }\n         }\n     }\n+\n+    /// Checks if the elements of this iterator are sorted.\n+    ///\n+    /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n+    /// iterator yields exactly zero or one element, `true` is returned.\n+    ///\n+    /// Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition\n+    /// implies that this function returns `false` if any two consecutive items are not\n+    /// comparable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    ///\n+    /// assert!([1, 2, 2, 9].iter().is_sorted());\n+    /// assert!(![1, 3, 2, 4].iter().is_sorted());\n+    /// assert!([0].iter().is_sorted());\n+    /// assert!(std::iter::empty::<i32>().is_sorted());\n+    /// assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted());\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n+    fn is_sorted(self) -> bool\n+    where\n+        Self: Sized,\n+        Self::Item: PartialOrd,\n+    {\n+        self.is_sorted_by(|a, b| a.partial_cmp(b))\n+    }\n+\n+    /// Checks if the elements of this iterator are sorted using the given comparator function.\n+    ///\n+    /// Instead of using `PartialOrd::partial_cmp`, this function uses the given `compare`\n+    /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n+    /// [`is_sorted`]; see its documentation for more information.\n+    ///\n+    /// [`is_sorted`]: trait.Iterator.html#method.is_sorted\n+    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n+    fn is_sorted_by<F>(mut self, mut compare: F) -> bool\n+    where\n+        Self: Sized,\n+        F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>\n+    {\n+        let mut last = match self.next() {\n+            Some(e) => e,\n+            None => return true,\n+        };\n+\n+        while let Some(curr) = self.next() {\n+            if compare(&last, &curr)\n+                .map(|o| o == Ordering::Greater)\n+                .unwrap_or(true)\n+            {\n+                return false;\n+            }\n+            last = curr;\n+        }\n+\n+        true\n+    }\n+\n+    /// Checks if the elements of this iterator are sorted using the given key extraction\n+    /// function.\n+    ///\n+    /// Instead of comparing the iterator's elements directly, this function compares the keys of\n+    /// the elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see\n+    /// its documentation for more information.\n+    ///\n+    /// [`is_sorted`]: trait.Iterator.html#method.is_sorted\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    ///\n+    /// assert!([\"c\", \"bb\", \"aaa\"].iter().is_sorted_by_key(|s| s.len()));\n+    /// assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n+    fn is_sorted_by_key<F, K>(self, mut f: F) -> bool\n+    where\n+        Self: Sized,\n+        F: FnMut(&Self::Item) -> K,\n+        K: PartialOrd\n+    {\n+        self.is_sorted_by(|a, b| f(a).partial_cmp(&f(b)))\n+    }\n }\n \n /// Select an element from an iterator based on the given \"projection\""}, {"sha": "df32cfa337313ab2eb2e1e796451bd070d24c8bf", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7164a9f151a56316a382d8bc2b15ccf373e129ca", "patch": "@@ -79,6 +79,7 @@\n #![feature(extern_types)]\n #![feature(fundamental)]\n #![feature(intrinsics)]\n+#![feature(is_sorted)]\n #![feature(iter_once_with)]\n #![feature(lang_items)]\n #![feature(link_llvm_intrinsics)]"}, {"sha": "df4d97ee6a44d74704e57d8a09b40dec7cdcd1d5", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 93, "deletions": 4, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=7164a9f151a56316a382d8bc2b15ccf373e129ca", "patch": "@@ -1783,7 +1783,7 @@ impl<T> [T] {\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a[1..5].rotate_left(1);\n     /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n-   /// ```\n+    /// ```\n     #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n@@ -2250,6 +2250,77 @@ impl<T> [T] {\n              from_raw_parts_mut(mut_ptr.add(rest.len() - ts_len), ts_len))\n         }\n     }\n+\n+    /// Checks if the elements of this slice are sorted.\n+    ///\n+    /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n+    /// slice yields exactly zero or one element, `true` is returned.\n+    ///\n+    /// Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition\n+    /// implies that this function returns `false` if any two consecutive items are not\n+    /// comparable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    /// let empty: [i32; 0] = [];\n+    ///\n+    /// assert!([1, 2, 2, 9].is_sorted());\n+    /// assert!(![1, 3, 2, 4].is_sorted());\n+    /// assert!([0].is_sorted());\n+    /// assert!(empty.is_sorted());\n+    /// assert!(![0.0, 1.0, std::f32::NAN].is_sorted());\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n+    pub fn is_sorted(&self) -> bool\n+    where\n+        T: PartialOrd,\n+    {\n+        self.is_sorted_by(|a, b| a.partial_cmp(b))\n+    }\n+\n+    /// Checks if the elements of this slice are sorted using the given comparator function.\n+    ///\n+    /// Instead of using `PartialOrd::partial_cmp`, this function uses the given `compare`\n+    /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n+    /// [`is_sorted`]; see its documentation for more information.\n+    ///\n+    /// [`is_sorted`]: #method.is_sorted\n+    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n+    pub fn is_sorted_by<F>(&self, mut compare: F) -> bool\n+    where\n+        F: FnMut(&T, &T) -> Option<Ordering>\n+    {\n+        self.iter().is_sorted_by(|a, b| compare(*a, *b))\n+    }\n+\n+    /// Checks if the elements of this slice are sorted using the given key extraction function.\n+    ///\n+    /// Instead of comparing the slice's elements directly, this function compares the keys of the\n+    /// elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see its\n+    /// documentation for more information.\n+    ///\n+    /// [`is_sorted`]: #method.is_sorted\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    ///\n+    /// assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n+    /// assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n+    pub fn is_sorted_by_key<F, K>(&self, mut f: F) -> bool\n+    where\n+        F: FnMut(&T) -> K,\n+        K: PartialOrd\n+    {\n+        self.is_sorted_by(|a, b| f(a).partial_cmp(&f(b)))\n+    }\n }\n \n #[lang = \"slice_u8\"]\n@@ -2773,7 +2844,13 @@ macro_rules! len {\n \n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n-    (struct $name:ident -> $ptr:ty, $elem:ty, $raw_mut:tt, $( $mut_:tt )*) => {\n+    (\n+        struct $name:ident -> $ptr:ty,\n+        $elem:ty,\n+        $raw_mut:tt,\n+        {$( $mut_:tt )*},\n+        {$($extra:tt)*}\n+    ) => {\n         impl<'a, T> $name<'a, T> {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n@@ -2950,6 +3027,8 @@ macro_rules! iterator {\n                         i\n                     })\n             }\n+\n+            $($extra)*\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -3087,7 +3166,17 @@ impl<'a, T> Iter<'a, T> {\n     }\n }\n \n-iterator!{struct Iter -> *const T, &'a T, const, /* no mut */}\n+iterator!{struct Iter -> *const T, &'a T, const, {/* no mut */}, {\n+    fn is_sorted_by<F>(self, mut compare: F) -> bool\n+    where\n+        Self: Sized,\n+        F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>,\n+    {\n+        self.as_slice().windows(2).all(|w| {\n+            compare(&&w[0], &&w[1]).map(|o| o != Ordering::Greater).unwrap_or(false)\n+        })\n+    }\n+}}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Iter<'_, T> {\n@@ -3188,7 +3277,7 @@ impl<'a, T> IterMut<'a, T> {\n     }\n }\n \n-iterator!{struct IterMut -> *mut T, &'a mut T, mut, mut}\n+iterator!{struct IterMut -> *mut T, &'a mut T, mut, {mut}, {}}\n \n /// An internal abstraction over the splitting iterators, so that\n /// splitn, splitn_mut etc can be implemented once."}, {"sha": "0fa99745d9065ab75c860690203f22c00165378c", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=7164a9f151a56316a382d8bc2b15ccf373e129ca", "patch": "@@ -2235,3 +2235,16 @@ fn test_monad_laws_associativity() {\n     assert_eq!((0..10).flat_map(f).flat_map(g).sum::<usize>(),\n                 (0..10).flat_map(|x| f(x).flat_map(g)).sum::<usize>());\n }\n+\n+#[test]\n+fn test_is_sorted() {\n+    assert!([1, 2, 2, 9].iter().is_sorted());\n+    assert!(![1, 3, 2].iter().is_sorted());\n+    assert!([0].iter().is_sorted());\n+    assert!(std::iter::empty::<i32>().is_sorted());\n+    assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted());\n+    assert!([-2, -1, 0, 3].iter().is_sorted());\n+    assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n+    assert!(![\"c\", \"bb\", \"aaa\"].iter().is_sorted());\n+    assert!([\"c\", \"bb\", \"aaa\"].iter().is_sorted_by_key(|s| s.len()));\n+}"}, {"sha": "3e8549f8ae366da46c5b1a02f1289e30636866e3", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=7164a9f151a56316a382d8bc2b15ccf373e129ca", "patch": "@@ -10,6 +10,7 @@\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n #![feature(hashmap_internals)]\n+#![feature(is_sorted)]\n #![feature(iter_copied)]\n #![feature(iter_nth_back)]\n #![feature(iter_once_with)]"}, {"sha": "e210e83122c47537e6a09e9459bc14526e1ebbed", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=7164a9f151a56316a382d8bc2b15ccf373e129ca", "patch": "@@ -1317,3 +1317,18 @@ fn test_copy_within_panics_src_inverted() {\n     // 2 is greater than 1, so this range is invalid.\n     bytes.copy_within(2..1, 0);\n }\n+\n+#[test]\n+fn test_is_sorted() {\n+    let empty: [i32; 0] = [];\n+\n+    assert!([1, 2, 2, 9].is_sorted());\n+    assert!(![1, 3, 2].is_sorted());\n+    assert!([0].is_sorted());\n+    assert!(empty.is_sorted());\n+    assert!(![0.0, 1.0, std::f32::NAN].is_sorted());\n+    assert!([-2, -1, 0, 3].is_sorted());\n+    assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n+    assert!(![\"c\", \"bb\", \"aaa\"].is_sorted());\n+    assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n+}"}, {"sha": "078ecc577610ba6a140cd11d88e285bf4678ae64", "filename": "src/test/ui/feature-gates/feature-gate-is_sorted.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-is_sorted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-is_sorted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-is_sorted.rs?ref=7164a9f151a56316a382d8bc2b15ccf373e129ca", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    // Assert `Iterator` methods are feature gated\n+    assert!([1, 2, 2, 9].iter().is_sorted());\n+    //~^ ERROR: use of unstable library feature 'is_sorted': new API\n+    assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n+    //~^ ERROR: use of unstable library feature 'is_sorted': new API\n+\n+    // Assert `[T]` methods are feature gated\n+    assert!([1, 2, 2, 9].is_sorted());\n+    //~^ ERROR: use of unstable library feature 'is_sorted': new API\n+    assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n+    //~^ ERROR: use of unstable library feature 'is_sorted': new API\n+}"}, {"sha": "8230c1e3a38dc5d73cd5bbf63de3379e658b9118", "filename": "src/test/ui/feature-gates/feature-gate-is_sorted.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-is_sorted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7164a9f151a56316a382d8bc2b15ccf373e129ca/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-is_sorted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-is_sorted.stderr?ref=7164a9f151a56316a382d8bc2b15ccf373e129ca", "patch": "@@ -0,0 +1,35 @@\n+error[E0658]: use of unstable library feature 'is_sorted': new API (see issue #53485)\n+  --> $DIR/feature-gate-is_sorted.rs:3:33\n+   |\n+LL |     assert!([1, 2, 2, 9].iter().is_sorted());\n+   |                                 ^^^^^^^^^\n+   |\n+   = help: add #![feature(is_sorted)] to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'is_sorted': new API (see issue #53485)\n+  --> $DIR/feature-gate-is_sorted.rs:5:39\n+   |\n+LL |     assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n+   |                                       ^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(is_sorted)] to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'is_sorted': new API (see issue #53485)\n+  --> $DIR/feature-gate-is_sorted.rs:9:26\n+   |\n+LL |     assert!([1, 2, 2, 9].is_sorted());\n+   |                          ^^^^^^^^^\n+   |\n+   = help: add #![feature(is_sorted)] to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'is_sorted': new API (see issue #53485)\n+  --> $DIR/feature-gate-is_sorted.rs:11:32\n+   |\n+LL |     assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n+   |                                ^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(is_sorted)] to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}]}