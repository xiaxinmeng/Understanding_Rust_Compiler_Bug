{"sha": "c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YWZjZjQ0ZDJjNzBiMmMxNzZiZGYyODMwODJhN2JkZDRiZTU4MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-19T10:11:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-19T10:11:48Z"}, "message": "auto merge of #12339 : alexcrichton/rust/rustdoc-fixes, r=sfackler\n\nCommits have the details", "tree": {"sha": "d9678297bc030da543bdf174489418bf418d554c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9678297bc030da543bdf174489418bf418d554c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "html_url": "https://github.com/rust-lang/rust/commit/c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f68f793d444285e5d7f00f57b5635ece43613b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f68f793d444285e5d7f00f57b5635ece43613b3", "html_url": "https://github.com/rust-lang/rust/commit/9f68f793d444285e5d7f00f57b5635ece43613b3"}, {"sha": "429ef870f67b02664b6ac35b08f3b36b71e8bd00", "url": "https://api.github.com/repos/rust-lang/rust/commits/429ef870f67b02664b6ac35b08f3b36b71e8bd00", "html_url": "https://github.com/rust-lang/rust/commit/429ef870f67b02664b6ac35b08f3b36b71e8bd00"}], "stats": {"total": 357, "additions": 314, "deletions": 43}, "files": [{"sha": "586323358c241234494ea2560f6e0954957208e5", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -25,7 +25,6 @@ use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n \n use std;\n-use std::hashmap::HashMap;\n \n use doctree;\n use visit_ast;\n@@ -68,17 +67,17 @@ impl<T: Clean<U>, U> Clean<~[U]> for syntax::opt_vec::OptVec<T> {\n pub struct Crate {\n     name: ~str,\n     module: Option<Item>,\n-    externs: HashMap<ast::CrateNum, ExternalCrate>,\n+    externs: ~[(ast::CrateNum, ExternalCrate)],\n }\n \n impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n     fn clean(&self) -> Crate {\n         use syntax::attr::find_crateid;\n         let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n \n-        let mut externs = HashMap::new();\n+        let mut externs = ~[];\n         cx.sess.cstore.iter_crate_data(|n, meta| {\n-            externs.insert(n, meta.clean());\n+            externs.push((n, meta.clean()));\n         });\n \n         Crate {\n@@ -181,6 +180,7 @@ pub enum ItemEnum {\n     VariantItem(Variant),\n     ForeignFunctionItem(Function),\n     ForeignStaticItem(Static),\n+    MacroItem(Macro),\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -206,7 +206,8 @@ impl Clean<Item> for doctree::Module {\n                        self.fns.clean(), self.foreigns.clean().concat_vec(),\n                        self.mods.clean(), self.typedefs.clean(),\n                        self.statics.clean(), self.traits.clean(),\n-                       self.impls.clean(), self.view_items.clean()].concat_vec()\n+                       self.impls.clean(), self.view_items.clean(),\n+                       self.macros.clean()].concat_vec()\n             })\n         }\n     }\n@@ -1263,3 +1264,23 @@ fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n         None => None\n     }\n }\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Macro {\n+    source: ~str,\n+}\n+\n+impl Clean<Item> for doctree::Macro {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: Some(self.name.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            visibility: ast::Public.clean(),\n+            id: self.id,\n+            inner: MacroItem(Macro {\n+                source: self.where.to_src(),\n+            }),\n+        }\n+    }\n+}"}, {"sha": "03186c16733a52273061767e5ca381466f994891", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -32,6 +32,7 @@ pub struct Module {\n     impls: ~[Impl],\n     foreigns: ~[ast::ForeignMod],\n     view_items: ~[ast::ViewItem],\n+    macros: ~[Macro],\n }\n \n impl Module {\n@@ -52,6 +53,7 @@ impl Module {\n             impls      : ~[],\n             view_items : ~[],\n             foreigns   : ~[],\n+            macros     : ~[],\n         }\n     }\n }\n@@ -157,6 +159,13 @@ pub struct Impl {\n     id: ast::NodeId,\n }\n \n+pub struct Macro {\n+    name: Ident,\n+    id: ast::NodeId,\n+    attrs: ~[ast::Attribute],\n+    where: Span,\n+}\n+\n pub fn struct_type_from_def(sd: &ast::StructDef) -> StructType {\n     if sd.ctor_id.is_some() {\n         // We are in a tuple-struct"}, {"sha": "649d5f592c5c58869b2a00dd6c11b77f959c4fe1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 60, "deletions": 32, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -157,6 +157,7 @@ pub struct Cache {\n     priv parent_stack: ~[ast::NodeId],\n     priv search_index: ~[IndexItem],\n     priv privmod: bool,\n+    priv public_items: HashSet<ast::NodeId>,\n }\n \n /// Helper struct to render all source code to HTML pages\n@@ -231,18 +232,23 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     }\n \n     // Crawl the crate to build various caches used for the output\n-    let mut cache = Cache {\n-        impls: HashMap::new(),\n-        typarams: HashMap::new(),\n-        paths: HashMap::new(),\n-        traits: HashMap::new(),\n-        implementors: HashMap::new(),\n-        stack: ~[],\n-        parent_stack: ~[],\n-        search_index: ~[],\n-        extern_locations: HashMap::new(),\n-        privmod: false,\n-    };\n+    let mut cache = local_data::get(::analysiskey, |analysis| {\n+        let public_items = analysis.map(|a| a.public_items.clone());\n+        let public_items = public_items.unwrap_or(HashSet::new());\n+        Cache {\n+            impls: HashMap::new(),\n+            typarams: HashMap::new(),\n+            paths: HashMap::new(),\n+            traits: HashMap::new(),\n+            implementors: HashMap::new(),\n+            stack: ~[],\n+            parent_stack: ~[],\n+            search_index: ~[],\n+            extern_locations: HashMap::new(),\n+            privmod: false,\n+            public_items: public_items,\n+        }\n+    });\n     cache.stack.push(krate.name.clone());\n     krate = cache.fold_crate(krate);\n \n@@ -305,7 +311,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         krate = folder.fold_crate(krate);\n     }\n \n-    for (&n, e) in krate.externs.iter() {\n+    for &(n, ref e) in krate.externs.iter() {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n     }\n \n@@ -565,8 +571,24 @@ impl DocFolder for Cache {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::VariantItem(..) => {\n-                self.paths.insert(item.id, (self.stack.clone(), shortty(&item)));\n+            clean::ForeignFunctionItem(..) => {\n+                // Reexported items mean that the same id can show up twice in\n+                // the rustdoc ast that we're looking at. We know, however, that\n+                // a reexported item doesn't show up in the `public_items` map,\n+                // so we can skip inserting into the paths map if there was\n+                // already an entry present and we're not a public item.\n+                if !self.paths.contains_key(&item.id) ||\n+                   self.public_items.contains(&item.id) {\n+                    self.paths.insert(item.id,\n+                                      (self.stack.clone(), shortty(&item)));\n+                }\n+            }\n+            // link variants to their parent enum because pages aren't emitted\n+            // for each variant\n+            clean::VariantItem(..) => {\n+                let mut stack = self.stack.clone();\n+                stack.pop();\n+                self.paths.insert(item.id, (stack, \"enum\"));\n             }\n             _ => {}\n         }\n@@ -791,6 +813,7 @@ fn shortty(item: &clean::Item) -> &'static str {\n         clean::VariantItem(..)         => \"variant\",\n         clean::ForeignFunctionItem(..) => \"ffi\",\n         clean::ForeignStaticItem(..)   => \"ffs\",\n+        clean::MacroItem(..)           => \"macro\",\n     }\n }\n \n@@ -869,6 +892,7 @@ impl<'a> fmt::Show for Item<'a> {\n             clean::StructItem(ref s) => item_struct(fmt.buf, self.item, s),\n             clean::EnumItem(ref e) => item_enum(fmt.buf, self.item, e),\n             clean::TypedefItem(ref t) => item_typedef(fmt.buf, self.item, t),\n+            clean::MacroItem(ref m) => item_macro(fmt.buf, self.item, m),\n             _ => Ok(())\n         }\n     }\n@@ -937,6 +961,8 @@ fn item_module(w: &mut Writer, cx: &Context,\n             (_, &clean::ViewItemItem(..)) => Greater,\n             (&clean::ModuleItem(..), _) => Less,\n             (_, &clean::ModuleItem(..)) => Greater,\n+            (&clean::MacroItem(..), _) => Less,\n+            (_, &clean::MacroItem(..)) => Greater,\n             (&clean::StructItem(..), _) => Less,\n             (_, &clean::StructItem(..)) => Greater,\n             (&clean::EnumItem(..), _) => Less,\n@@ -987,6 +1013,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 clean::VariantItem(..)         => \"Variants\",\n                 clean::ForeignFunctionItem(..) => \"Foreign Functions\",\n                 clean::ForeignStaticItem(..)   => \"Foreign Statics\",\n+                clean::MacroItem(..)           => \"Macros\",\n             }));\n         }\n \n@@ -1099,15 +1126,15 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n         if_ok!(write!(w, \"\\\\{\\n\"));\n         for m in required.iter() {\n             if_ok!(write!(w, \"    \"));\n-            if_ok!(render_method(w, m.item(), true));\n+            if_ok!(render_method(w, m.item()));\n             if_ok!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n             if_ok!(w.write(\"\\n\".as_bytes()));\n         }\n         for m in provided.iter() {\n             if_ok!(write!(w, \"    \"));\n-            if_ok!(render_method(w, m.item(), true));\n+            if_ok!(render_method(w, m.item()));\n             if_ok!(write!(w, \" \\\\{ ... \\\\}\\n\"));\n         }\n         if_ok!(write!(w, \"\\\\}\"));\n@@ -1121,7 +1148,7 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n         if_ok!(write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n                       shortty(m.item()),\n                       *m.item().name.get_ref()));\n-        if_ok!(render_method(w, m.item(), false));\n+        if_ok!(render_method(w, m.item()));\n         if_ok!(write!(w, \"</code></h3>\"));\n         if_ok!(document(w, m.item()));\n         Ok(())\n@@ -1176,32 +1203,27 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     })\n }\n \n-fn render_method(w: &mut Writer, meth: &clean::Item,\n-                 withlink: bool) -> fmt::Result {\n+fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n     fn fun(w: &mut Writer, it: &clean::Item, purity: ast::Purity,\n-           g: &clean::Generics, selfty: &clean::SelfTy, d: &clean::FnDecl,\n-           withlink: bool) -> fmt::Result {\n-        write!(w, \"{}fn {withlink, select,\n-                            true{<a href='\\\\#{ty}.{name}'\n-                                    class='fnname'>{name}</a>}\n-                            other{<span class='fnname'>{name}</span>}\n-                        }{generics}{decl}\",\n+           g: &clean::Generics, selfty: &clean::SelfTy,\n+           d: &clean::FnDecl) -> fmt::Result {\n+        write!(w, \"{}fn <a href='\\\\#{ty}.{name}' class='fnname'>{name}</a>\\\n+                   {generics}{decl}\",\n                match purity {\n                    ast::UnsafeFn => \"unsafe \",\n                    _ => \"\",\n                },\n                ty = shortty(it),\n                name = it.name.get_ref().as_slice(),\n                generics = *g,\n-               decl = Method(selfty, d),\n-               withlink = if withlink {\"true\"} else {\"false\"})\n+               decl = Method(selfty, d))\n     }\n     match meth.inner {\n         clean::TyMethodItem(ref m) => {\n-            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink)\n+            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl)\n         }\n         clean::MethodItem(ref m) => {\n-            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink)\n+            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl)\n         }\n         _ => unreachable!()\n     }\n@@ -1432,7 +1454,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n     fn docmeth(w: &mut Writer, item: &clean::Item) -> io::IoResult<bool> {\n         if_ok!(write!(w, \"<h4 id='method.{}' class='method'><code>\",\n                       *item.name.get_ref()));\n-        if_ok!(render_method(w, item, false));\n+        if_ok!(render_method(w, item));\n         if_ok!(write!(w, \"</code></h4>\\n\"));\n         match item.doc_value() {\n             Some(s) => {\n@@ -1609,3 +1631,9 @@ impl<'a> fmt::Show for Source<'a> {\n         Ok(())\n     }\n }\n+\n+fn item_macro(w: &mut Writer, it: &clean::Item,\n+              t: &clean::Macro) -> fmt::Result {\n+    if_ok!(write!(w, \"<pre class='macro'>{}</pre>\", t.source));\n+    document(w, it)\n+}"}, {"sha": "8e1876bad036804fc286fffb6ecace8dd8077494", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -301,3 +301,5 @@ a {\n .stability.Stable { border-color: #AEC516; color: #7c8b10; }\n .stability.Frozen { border-color: #009431; color: #007726; }\n .stability.Locked { border-color: #0084B6; color: #00668c; }\n+\n+:target { background: #FDFFD3; }"}, {"sha": "4194f5e47293628610fe8eaf809c49e42c96ece5", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -344,7 +344,7 @@ fn json_output(krate: clean::Crate, res: ~[plugins::PluginJson],\n     };\n     let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,\n-        Err(_) => fail!(\"Rust generated JSON is invalid??\")\n+        Err(e) => fail!(\"Rust generated JSON is invalid: {:?}\", e)\n     };\n \n     json.insert(~\"crate\", crate_json);"}, {"sha": "2b8f01cfac8cacd57c1ff204310e0e698193b3d0", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -150,8 +150,8 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             }\n             clean::ImplItem(..) => {}\n \n-            // tymethods have no control over privacy\n-            clean::TyMethodItem(..) => {}\n+            // tymethods/macros have no control over privacy\n+            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n         }\n \n         let fastreturn = match i.inner {"}, {"sha": "ef02d7345672154bb0951df944e363deb06db2da", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -280,7 +280,14 @@ impl<'a> RustdocVisitor<'a> {\n             ast::ItemForeignMod(ref fm) => {\n                 om.foreigns.push(fm.clone());\n             }\n-            _ => (),\n+            ast::ItemMac(ref _m) => {\n+                om.macros.push(Macro {\n+                    id: item.id,\n+                    attrs: item.attrs.clone(),\n+                    name: item.ident,\n+                    where: item.span,\n+                })\n+            }\n         }\n     }\n }"}, {"sha": "d3ddd9ae78380dfad3298b40b75b0f40329b7a3a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -77,7 +77,7 @@\n #[cfg(test)] pub use ops = realstd::ops;\n #[cfg(test)] pub use cmp = realstd::cmp;\n \n-mod macros;\n+pub mod macros;\n \n mod rtdeps;\n "}, {"sha": "34b33003786e73b050108f5e7d4aab8dec5ca321", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 176, "deletions": 1, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -7,8 +7,29 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n+//! Standard library macros\n+//!\n+//! This modules contains a set of macros which are exported from the standard\n+//! library. Each macro is available for use when linking against the standard\n+//! library.\n+\n #[macro_escape];\n \n+/// The standard logging macro\n+///\n+/// This macro will generically log over a provided level (of type u32) with a\n+/// format!-based argument list. See documentation in `std::fmt` for details on\n+/// how to use the syntax, and documentation in `std::logging` for info about\n+/// logging macros.\n+///\n+/// # Example\n+///\n+/// ```\n+/// log!(::std::logging::DEBUG, \"this is a debug message\");\n+/// log!(::std::logging::WARN, \"this is a warning {}\", \"message\");\n+/// log!(6, \"this is a custom logging level: {level}\", level=6);\n+/// ```\n #[macro_export]\n macro_rules! log(\n     ($lvl:expr, $($arg:tt)+) => ({\n@@ -21,26 +42,73 @@ macro_rules! log(\n     })\n )\n \n+/// A convenience macro for logging at the error log level. See `std::logging`\n+/// for more information. about logging.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # let error = 3;\n+/// error!(\"the build has failed with error code: {}\", error);\n+/// ```\n #[macro_export]\n macro_rules! error(\n     ($($arg:tt)*) => (log!(1u32, $($arg)*))\n )\n \n+/// A convenience macro for logging at the warning log level. See `std::logging`\n+/// for more information. about logging.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # let code = 3;\n+/// warn!(\"you may like to know that a process exited with: {}\", code);\n+/// ```\n #[macro_export]\n macro_rules! warn(\n     ($($arg:tt)*) => (log!(2u32, $($arg)*))\n )\n \n+/// A convenience macro for logging at the info log level. See `std::logging`\n+/// for more information. about logging.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # let ret = 3;\n+/// info!(\"this function is about to return: {}\", ret);\n+/// ```\n #[macro_export]\n macro_rules! info(\n     ($($arg:tt)*) => (log!(3u32, $($arg)*))\n )\n \n+/// A convenience macro for logging at the debug log level. See `std::logging`\n+/// for more information. about logging.\n+///\n+/// # Example\n+///\n+/// ```\n+/// debug!(\"x = {x}, y = {y}\", x=10, y=20);\n+/// ```\n #[macro_export]\n macro_rules! debug(\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { log!(4u32, $($arg)*) })\n )\n \n+/// A macro to test whether a log level is enabled for the current module.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # struct Point { x: int, y: int }\n+/// # fn some_expensive_computation() -> Point { Point { x: 1, y: 2 } }\n+/// if log_enabled!(std::logging::DEBUG) {\n+///     let x = some_expensive_computation();\n+///     debug!(\"x.x = {}, x.y = {}\", x.x, x.y);\n+/// }\n+/// ```\n #[macro_export]\n macro_rules! log_enabled(\n     ($lvl:expr) => ({\n@@ -49,6 +117,25 @@ macro_rules! log_enabled(\n     })\n )\n \n+/// The entry point for failure of rust tasks.\n+///\n+/// This macro is used to inject failure into a rust task, causing the task to\n+/// unwind and fail entirely. Each task's failure can be reaped as the `~Any`\n+/// type, and the single-argument form of the `fail!` macro will be the value\n+/// which is transmitted.\n+///\n+/// The multi-argument form of this macro fails with a string and has the\n+/// `format!` sytnax for building a string.\n+///\n+/// # Example\n+///\n+/// ```should_fail\n+/// # #[allow(unreachable_code)];\n+/// fail!();\n+/// fail!(\"this is a terrible mistake!\");\n+/// fail!(4); // fail with the value of 4 to be collected elsewhere\n+/// fail!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n+/// ```\n #[macro_export]\n macro_rules! fail(\n     () => (\n@@ -70,6 +157,26 @@ macro_rules! fail(\n     });\n )\n \n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `fail!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the failure message for these assertions is the stringified value of the\n+/// // expression given.\n+/// assert!(true);\n+/// # fn some_computation() -> bool { true }\n+/// assert!(some_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// assert!(x, \"x wasn't true!\");\n+/// # let a = 3; let b = 27;\n+/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n #[macro_export]\n macro_rules! assert(\n     ($cond:expr) => (\n@@ -89,6 +196,18 @@ macro_rules! assert(\n     );\n )\n \n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On failure, this macro will print the values of the expressions.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3;\n+/// let b = 1 + 2;\n+/// assert_eq!(a, b);\n+/// ```\n #[macro_export]\n macro_rules! assert_eq(\n     ($given:expr , $expected:expr) => ({\n@@ -110,13 +229,15 @@ macro_rules! assert_eq(\n /// # Example\n ///\n /// ~~~rust\n+/// struct Item { weight: uint }\n+///\n /// fn choose_weighted_item(v: &[Item]) -> Item {\n ///     assert!(!v.is_empty());\n ///     let mut so_far = 0u;\n ///     for item in v.iter() {\n ///         so_far += item.weight;\n ///         if so_far > 100 {\n-///             return item;\n+///             return *item;\n ///         }\n ///     }\n ///     // The above loop always returns, so we must hint to the\n@@ -136,13 +257,36 @@ macro_rules! unimplemented(\n     () => (fail!(\"not yet implemented\"))\n )\n \n+/// Use the syntax described in `std::fmt` to create a value of type `~str`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// format!(\"test\");\n+/// format!(\"hello {}\", \"world!\");\n+/// format!(\"x = {}, y = {y}\", 10, y = 30);\n+/// ```\n #[macro_export]\n macro_rules! format(\n     ($($arg:tt)*) => (\n         format_args!(::std::fmt::format, $($arg)*)\n     )\n )\n \n+/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # #[allow(unused_must_use)];\n+/// use std::io::MemWriter;\n+///\n+/// let mut w = MemWriter::new();\n+/// write!(&mut w, \"test\");\n+/// write!(&mut w, \"formatted {}\", \"arguments\");\n+/// ```\n #[macro_export]\n macro_rules! write(\n     ($dst:expr, $($arg:tt)*) => ({\n@@ -151,6 +295,8 @@ macro_rules! write(\n     })\n )\n \n+/// Equivalent to the `write!` macro, except that a newline is appended after\n+/// the message is written.\n #[macro_export]\n macro_rules! writeln(\n     ($dst:expr, $($arg:tt)*) => ({\n@@ -159,16 +305,42 @@ macro_rules! writeln(\n     })\n )\n \n+/// Equivalent to the `println!` macro except that a newline is not printed at\n+/// the end of the message.\n #[macro_export]\n macro_rules! print(\n     ($($arg:tt)*) => (format_args!(::std::io::stdio::print_args, $($arg)*))\n )\n \n+/// Macro for printing to a task's stdout handle.\n+///\n+/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n+/// The syntax of this macro is the same as that used for `format!`. For more\n+/// information, see `std::fmt` and `std::io::stdio`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// println!(\"hello there!\");\n+/// println!(\"format {} arguments\", \"some\");\n+/// ```\n #[macro_export]\n macro_rules! println(\n     ($($arg:tt)*) => (format_args!(::std::io::stdio::println_args, $($arg)*))\n )\n \n+/// Declare a task-local key with a specific type.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::local_data;\n+///\n+/// local_data_key!(my_integer: int)\n+///\n+/// local_data::set(my_integer, 2);\n+/// local_data::get(my_integer, |val| println!(\"{}\", val.map(|i| *i)));\n+/// ```\n #[macro_export]\n macro_rules! local_data_key(\n     ($name:ident: $ty:ty) => (\n@@ -179,6 +351,9 @@ macro_rules! local_data_key(\n     );\n )\n \n+/// Helper macro for unwrapping `Result` values while returning early with an\n+/// error if the value of the expression is `Err`. For more information, see\n+/// `std::io`.\n #[macro_export]\n macro_rules! if_ok(\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })"}, {"sha": "5e6ab4b790ee5efd2c8c72df6989c81fc7fd6ed0", "filename": "src/test/run-make/rustdoc-json/Makefile", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Ftest%2Frun-make%2Frustdoc-json%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Ftest%2Frun-make%2Frustdoc-json%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-json%2FMakefile?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -0,0 +1,4 @@\n+-include ../tools.mk\n+all:\n+\t$(RUSTDOC) -w json -o $(TMPDIR)/doc.json foo.rs\n+\t$(RUSTDOC) -o $(TMPDIR)/doc $(TMPDIR)/doc.json"}, {"sha": "818ec1e5eb79013ce4ad7275cf9559d6bce200a5", "filename": "src/test/run-make/rustdoc-json/foo.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4afcf44d2c70b2c176bdf283082a7bdd4be5826/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs?ref=c4afcf44d2c70b2c176bdf283082a7bdd4be5826", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_id = \"foo#0.1\"];\n+\n+//! Very docs\n+\n+pub mod bar {\n+\n+    /// So correct\n+    pub mod baz {\n+        /// Much detail\n+        pub fn baz() { }\n+    }\n+\n+    /// *wow*\n+    pub trait Doge { }\n+}"}]}