{"sha": "63b314c367ad37ca7fdd40d7d3678ad42d93057a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYjMxNGMzNjdhZDM3Y2E3ZmRkNDBkN2QzNjc4YWQ0MmQ5MzA1N2E=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-07T00:28:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-07T00:28:54Z"}, "message": "Rollup merge of #72810 - RalfJung:mir-terminate-sanity, r=jonas-schievink\n\nvalidate basic sanity for TerminatorKind\n\nr? @jonas-schievink\n\nThis mainly checks that all `BasicBlock` actually exist. On top of that, it checks that `Call` actually calls something of `FnPtr`/`FnDef` type, and `Assert` has to work on a `bool`. Also `SwitchInt` cannot have an empty target list.", "tree": {"sha": "309d91cbf129be457c8119fe54bfaf3fc985c3ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/309d91cbf129be457c8119fe54bfaf3fc985c3ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63b314c367ad37ca7fdd40d7d3678ad42d93057a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe3DTHCRBK7hj4Ov3rIwAAdHIIAKqLE7aOCYnC+zBL7+GZmfGJ\nb/hPFSU2qt4e6N4oGFvCTzLP/T7rsPGyNqLXrxzJ7iZCwKZ1Bvd6z46w8Xc8O4UW\nmAaaV9iR2HDrcYXjl1lISGQICAWEK6Sl77Z2yQMIp7LLLl6LHb5RtbAhpog9smT1\npol4Om2t8+/j9S/xKxvX24DFS29GYDoBUviNC28Z6bUf7SyTTOepgTX8XYz5ViSJ\njRJkNV/CqyPHIi42f+xIp9EHBb1G+fUZl1pMdbBvcKlOHI1p3MxHSS/pQT3tm3/d\njcdSkqjKuCB5TZ2gRtMLACS0grGyClqGIA0imPxGHA0Vo3p5tUKtcVdnXN5xkVk=\n=0rx+\n-----END PGP SIGNATURE-----\n", "payload": "tree 309d91cbf129be457c8119fe54bfaf3fc985c3ee\nparent 9c1857fad849ad56d38327b9bc11377a0bdbb4cf\nparent f793c0b1bf3392c19eb11331fddc8c9f561361ee\nauthor Dylan DPC <dylan.dpc@gmail.com> 1591489734 +0200\ncommitter GitHub <noreply@github.com> 1591489734 +0200\n\nRollup merge of #72810 - RalfJung:mir-terminate-sanity, r=jonas-schievink\n\nvalidate basic sanity for TerminatorKind\n\nr? @jonas-schievink\n\nThis mainly checks that all `BasicBlock` actually exist. On top of that, it checks that `Call` actually calls something of `FnPtr`/`FnDef` type, and `Assert` has to work on a `bool`. Also `SwitchInt` cannot have an empty target list.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63b314c367ad37ca7fdd40d7d3678ad42d93057a", "html_url": "https://github.com/rust-lang/rust/commit/63b314c367ad37ca7fdd40d7d3678ad42d93057a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63b314c367ad37ca7fdd40d7d3678ad42d93057a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c1857fad849ad56d38327b9bc11377a0bdbb4cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1857fad849ad56d38327b9bc11377a0bdbb4cf", "html_url": "https://github.com/rust-lang/rust/commit/9c1857fad849ad56d38327b9bc11377a0bdbb4cf"}, {"sha": "f793c0b1bf3392c19eb11331fddc8c9f561361ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/f793c0b1bf3392c19eb11331fddc8c9f561361ee", "html_url": "https://github.com/rust-lang/rust/commit/f793c0b1bf3392c19eb11331fddc8c9f561361ee"}], "stats": {"total": 143, "additions": 127, "deletions": 16}, "files": [{"sha": "3db16a71bab150b8ec009af7d0db911d58a2828d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63b314c367ad37ca7fdd40d7d3678ad42d93057a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b314c367ad37ca7fdd40d7d3678ad42d93057a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=63b314c367ad37ca7fdd40d7d3678ad42d93057a", "patch": "@@ -50,7 +50,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.go_to_block(target_block);\n             }\n \n-            Call { ref func, ref args, destination, ref cleanup, .. } => {\n+            Call {\n+                ref func,\n+                ref args,\n+                destination,\n+                ref cleanup,\n+                from_hir_call: _from_hir_call,\n+            } => {\n                 let old_stack = self.frame_idx();\n                 let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;"}, {"sha": "7d301b2f49648356b92adff8762fd3a1da78e61d", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 120, "deletions": 15, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/63b314c367ad37ca7fdd40d7d3678ad42d93057a/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b314c367ad37ca7fdd40d7d3678ad42d93057a/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=63b314c367ad37ca7fdd40d7d3678ad42d93057a", "patch": "@@ -3,10 +3,13 @@\n use super::{MirPass, MirSource};\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::{\n-    mir::{Body, Location, Operand, Rvalue, Statement, StatementKind},\n-    ty::{ParamEnv, TyCtxt},\n+    mir::{\n+        BasicBlock, Body, Location, Operand, Rvalue, Statement, StatementKind, Terminator,\n+        TerminatorKind,\n+    },\n+    ty::{self, ParamEnv, TyCtxt},\n };\n-use rustc_span::{def_id::DefId, Span, DUMMY_SP};\n+use rustc_span::def_id::DefId;\n \n pub struct Validator {\n     /// Describes at which point in the pipeline this validation is happening.\n@@ -30,27 +33,38 @@ struct TypeChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n-    fn fail(&self, span: Span, msg: impl AsRef<str>) {\n+    fn fail(&self, location: Location, msg: impl AsRef<str>) {\n+        let span = self.body.source_info(location).span;\n         // We use `delay_span_bug` as we might see broken MIR when other errors have already\n         // occurred.\n         self.tcx.sess.diagnostic().delay_span_bug(\n             span,\n-            &format!(\"broken MIR in {:?} ({}): {}\", self.def_id, self.when, msg.as_ref()),\n+            &format!(\n+                \"broken MIR in {:?} ({}) at {:?}:\\n{}\",\n+                self.def_id,\n+                self.when,\n+                location,\n+                msg.as_ref()\n+            ),\n         );\n     }\n+\n+    fn check_bb(&self, location: Location, bb: BasicBlock) {\n+        if self.body.basic_blocks().get(bb).is_none() {\n+            self.fail(location, format!(\"encountered jump to invalid basic block {:?}\", bb))\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         // `Operand::Copy` is only supposed to be used with `Copy` types.\n         if let Operand::Copy(place) = operand {\n             let ty = place.ty(&self.body.local_decls, self.tcx).ty;\n+            let span = self.body.source_info(location).span;\n \n-            if !ty.is_copy_modulo_regions(self.tcx, self.param_env, DUMMY_SP) {\n-                self.fail(\n-                    DUMMY_SP,\n-                    format!(\"`Operand::Copy` with non-`Copy` type {} at {:?}\", ty, location),\n-                );\n+            if !ty.is_copy_modulo_regions(self.tcx, self.param_env, span) {\n+                self.fail(location, format!(\"`Operand::Copy` with non-`Copy` type {}\", ty));\n             }\n         }\n \n@@ -65,16 +79,107 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) => {\n                     if dest == src {\n                         self.fail(\n-                            DUMMY_SP,\n-                            format!(\n-                                \"encountered `Assign` statement with overlapping memory at {:?}\",\n-                                location\n-                            ),\n+                            location,\n+                            \"encountered `Assign` statement with overlapping memory\",\n                         );\n                     }\n                 }\n                 _ => {}\n             }\n         }\n     }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        match &terminator.kind {\n+            TerminatorKind::Goto { target } => {\n+                self.check_bb(location, *target);\n+            }\n+            TerminatorKind::SwitchInt { targets, values, .. } => {\n+                if targets.len() != values.len() + 1 {\n+                    self.fail(\n+                        location,\n+                        format!(\n+                            \"encountered `SwitchInt` terminator with {} values, but {} targets (should be values+1)\",\n+                            values.len(),\n+                            targets.len(),\n+                        ),\n+                    );\n+                }\n+                for target in targets {\n+                    self.check_bb(location, *target);\n+                }\n+            }\n+            TerminatorKind::Drop { target, unwind, .. } => {\n+                self.check_bb(location, *target);\n+                if let Some(unwind) = unwind {\n+                    self.check_bb(location, *unwind);\n+                }\n+            }\n+            TerminatorKind::DropAndReplace { target, unwind, .. } => {\n+                self.check_bb(location, *target);\n+                if let Some(unwind) = unwind {\n+                    self.check_bb(location, *unwind);\n+                }\n+            }\n+            TerminatorKind::Call { func, destination, cleanup, .. } => {\n+                let func_ty = func.ty(&self.body.local_decls, self.tcx);\n+                match func_ty.kind {\n+                    ty::FnPtr(..) | ty::FnDef(..) => {}\n+                    _ => self.fail(\n+                        location,\n+                        format!(\"encountered non-callable type {} in `Call` terminator\", func_ty),\n+                    ),\n+                }\n+                if let Some((_, target)) = destination {\n+                    self.check_bb(location, *target);\n+                }\n+                if let Some(cleanup) = cleanup {\n+                    self.check_bb(location, *cleanup);\n+                }\n+            }\n+            TerminatorKind::Assert { cond, target, cleanup, .. } => {\n+                let cond_ty = cond.ty(&self.body.local_decls, self.tcx);\n+                if cond_ty != self.tcx.types.bool {\n+                    self.fail(\n+                        location,\n+                        format!(\n+                            \"encountered non-boolean condition of type {} in `Assert` terminator\",\n+                            cond_ty\n+                        ),\n+                    );\n+                }\n+                self.check_bb(location, *target);\n+                if let Some(cleanup) = cleanup {\n+                    self.check_bb(location, *cleanup);\n+                }\n+            }\n+            TerminatorKind::Yield { resume, drop, .. } => {\n+                self.check_bb(location, *resume);\n+                if let Some(drop) = drop {\n+                    self.check_bb(location, *drop);\n+                }\n+            }\n+            TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n+                self.check_bb(location, *real_target);\n+                self.check_bb(location, *imaginary_target);\n+            }\n+            TerminatorKind::FalseUnwind { real_target, unwind } => {\n+                self.check_bb(location, *real_target);\n+                if let Some(unwind) = unwind {\n+                    self.check_bb(location, *unwind);\n+                }\n+            }\n+            TerminatorKind::InlineAsm { destination, .. } => {\n+                if let Some(destination) = destination {\n+                    self.check_bb(location, *destination);\n+                }\n+            }\n+            // Nothing to validate for these.\n+            TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop => {}\n+        }\n+    }\n }"}]}