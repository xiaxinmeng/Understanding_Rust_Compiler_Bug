{"sha": "18a30aff4564437ccd2698be367ca98c81122ac0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YTMwYWZmNDU2NDQzN2NjZDI2OThiZTM2N2NhOThjODExMjJhYzA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-19T05:54:13Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-19T20:40:19Z"}, "message": "libextra: Convert uses of `&fn(A)->B` to `|A|->B`.", "tree": {"sha": "6d26718ee84b0f096fbf5496698e47f3219479df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d26718ee84b0f096fbf5496698e47f3219479df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18a30aff4564437ccd2698be367ca98c81122ac0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18a30aff4564437ccd2698be367ca98c81122ac0", "html_url": "https://github.com/rust-lang/rust/commit/18a30aff4564437ccd2698be367ca98c81122ac0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18a30aff4564437ccd2698be367ca98c81122ac0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1946265e1a1a32eb922846f314657a4aa7eb1d23", "url": "https://api.github.com/repos/rust-lang/rust/commits/1946265e1a1a32eb922846f314657a4aa7eb1d23", "html_url": "https://github.com/rust-lang/rust/commit/1946265e1a1a32eb922846f314657a4aa7eb1d23"}], "stats": {"total": 455, "additions": 224, "deletions": 231}, "files": [{"sha": "4660036a774e093ff7839b58b51de68f720bff60", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -220,7 +220,7 @@ impl<T:Send> MutexArc<T> {\n      * blocked on the mutex) will also fail immediately.\n      */\n     #[inline]\n-    pub unsafe fn unsafe_access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub unsafe fn unsafe_access<U>(&self, blk: |x: &mut T| -> U) -> U {\n         let state = self.x.get();\n         // Borrowck would complain about this if the function were\n         // not already unsafe. See borrow_rwlock, far below.\n@@ -234,8 +234,7 @@ impl<T:Send> MutexArc<T> {\n     /// As unsafe_access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline]\n     pub unsafe fn unsafe_access_cond<U>(&self,\n-                                        blk: &fn(x: &mut T,\n-                                                 c: &Condvar) -> U)\n+                                        blk: |x: &mut T, c: &Condvar| -> U)\n                                         -> U {\n         let state = self.x.get();\n         do (&(*state).lock).lock_cond |cond| {\n@@ -284,15 +283,14 @@ impl<T:Freeze + Send> MutexArc<T> {\n      * unsafe_access_cond.\n      */\n     #[inline]\n-    pub fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn access<U>(&self, blk: |x: &mut T| -> U) -> U {\n         unsafe { self.unsafe_access(blk) }\n     }\n \n     /// As unsafe_access_cond but safe and Freeze.\n     #[inline]\n     pub fn access_cond<U>(&self,\n-                          blk: &fn(x: &mut T,\n-                                   c: &Condvar) -> U)\n+                          blk: |x: &mut T, c: &Condvar| -> U)\n                           -> U {\n         unsafe { self.unsafe_access_cond(blk) }\n     }\n@@ -389,7 +387,7 @@ impl<T:Freeze + Send> RWArc<T> {\n      * poison the Arc, so subsequent readers and writers will both also fail.\n      */\n     #[inline]\n-    pub fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn write<U>(&self, blk: |x: &mut T| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write {\n@@ -403,7 +401,7 @@ impl<T:Freeze + Send> RWArc<T> {\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline]\n     pub fn write_cond<U>(&self,\n-                         blk: &fn(x: &mut T, c: &Condvar) -> U)\n+                         blk: |x: &mut T, c: &Condvar| -> U)\n                          -> U {\n         unsafe {\n             let state = self.x.get();\n@@ -427,7 +425,7 @@ impl<T:Freeze + Send> RWArc<T> {\n      * Failing will unlock the Arc while unwinding. However, unlike all other\n      * access modes, this will not poison the Arc.\n      */\n-    pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n+    pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*state).lock.read {\n@@ -457,7 +455,7 @@ impl<T:Freeze + Send> RWArc<T> {\n      * }\n      * ```\n      */\n-    pub fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n+    pub fn write_downgrade<U>(&self, blk: |v: RWWriteMode<T>| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n@@ -539,7 +537,7 @@ pub struct RWReadMode<'self, T> {\n \n impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n     /// Access the pre-downgrade RWArc in write mode.\n-    pub fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn write<U>(&mut self, blk: |x: &mut T| -> U) -> U {\n         match *self {\n             RWWriteMode {\n                 data: &ref mut data,\n@@ -555,7 +553,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n \n     /// Access the pre-downgrade RWArc in write mode with a condvar.\n     pub fn write_cond<U>(&mut self,\n-                         blk: &fn(x: &mut T, c: &Condvar) -> U)\n+                         blk: |x: &mut T, c: &Condvar| -> U)\n                          -> U {\n         match *self {\n             RWWriteMode {\n@@ -580,7 +578,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n \n impl<'self, T:Freeze + Send> RWReadMode<'self, T> {\n     /// Access the post-downgrade rwlock in read mode.\n-    pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n+    pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n         match *self {\n             RWReadMode {\n                 data: data,"}, {"sha": "2bb36e25fcb04afba523f382f6797b5c90a809a9", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -184,7 +184,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    fn alloc_pod<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -241,7 +241,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    fn alloc_nonpod<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n@@ -263,7 +263,7 @@ impl Arena {\n \n     // The external interface\n     #[inline]\n-    pub fn alloc<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+    pub fn alloc<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n             // XXX: Borrow check\n             let this = transmute_mut(self);"}, {"sha": "c68133dac10106e361885b9430561957828b3584", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -40,7 +40,7 @@ impl SmallBitv {\n     pub fn bits_op(&mut self,\n                    right_bits: uint,\n                    nbits: uint,\n-                   f: &fn(uint, uint) -> uint)\n+                   f: |uint, uint| -> uint)\n                    -> bool {\n         let mask = small_mask(nbits);\n         let old_b: uint = self.bits;\n@@ -140,7 +140,7 @@ impl BigBitv {\n     pub fn process(&mut self,\n                    b: &BigBitv,\n                    nbits: uint,\n-                   op: &fn(uint, uint) -> uint)\n+                   op: |uint, uint| -> uint)\n                    -> bool {\n         let len = b.storage.len();\n         assert_eq!(self.storage.len(), len);\n@@ -161,7 +161,7 @@ impl BigBitv {\n     }\n \n     #[inline]\n-    pub fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n+    pub fn each_storage(&mut self, op: |v: &mut uint| -> bool) -> bool {\n         self.storage.mut_iter().advance(|elt| op(elt))\n     }\n \n@@ -512,7 +512,7 @@ impl Bitv {\n         true\n     }\n \n-    pub fn ones(&self, f: &fn(uint) -> bool) -> bool {\n+    pub fn ones(&self, f: |uint| -> bool) -> bool {\n         range(0u, self.nbits).advance(|i| !self.get(i) || f(i))\n     }\n \n@@ -542,7 +542,7 @@ pub fn from_bools(bools: &[bool]) -> Bitv {\n  * Create a `Bitv` of the specified length where the value at each\n  * index is `f(index)`.\n  */\n-pub fn from_fn(len: uint, f: &fn(index: uint) -> bool) -> Bitv {\n+pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n     let mut bitv = Bitv::new(len, false);\n     for i in range(0u, len) {\n         bitv.set(i, f(i));\n@@ -557,7 +557,7 @@ impl ops::Index<uint,bool> for Bitv {\n }\n \n #[inline]\n-fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n+fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool {\n     if bits == 0 {\n         return true;\n     }\n@@ -675,7 +675,7 @@ impl BitvSet {\n     }\n \n     #[inline]\n-    fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n+    fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;\n             for _ in range(0u, uint::bits) {\n@@ -722,7 +722,7 @@ impl BitvSet {\n         BitvSetIterator {set: self, next_idx: 0}\n     }\n \n-    pub fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+    pub fn difference(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n         for (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n                 return false\n@@ -734,8 +734,8 @@ impl BitvSet {\n         )\n     }\n \n-    pub fn symmetric_difference(&self, other: &BitvSet,\n-                            f: &fn(&uint) -> bool) -> bool {\n+    pub fn symmetric_difference(&self, other: &BitvSet, f: |&uint| -> bool)\n+                                -> bool {\n         for (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n                 return false\n@@ -744,11 +744,11 @@ impl BitvSet {\n         self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n     }\n \n-    pub fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+    pub fn intersection(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n         self.common_iter(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n     }\n \n-    pub fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+    pub fn union(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n         for (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n                 return false"}, {"sha": "418b8256189f940178413acd2921272bf4ea5253", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -320,7 +320,7 @@ impl<T> DList<T> {\n     /// or at the end.\n     ///\n     /// O(N)\n-    pub fn insert_when(&mut self, elt: T, f: &fn(&T, &T) -> bool) {\n+    pub fn insert_when(&mut self, elt: T, f: |&T, &T| -> bool) {\n         {\n             let mut it = self.mut_iter();\n             loop {\n@@ -339,7 +339,7 @@ impl<T> DList<T> {\n     /// put `a` in the result if `f(a, b)` is true, else `b`.\n     ///\n     /// O(max(N, M))\n-    pub fn merge(&mut self, mut other: DList<T>, f: &fn(&T, &T) -> bool) {\n+    pub fn merge(&mut self, mut other: DList<T>, f: |&T, &T| -> bool) {\n         {\n             let mut it = self.mut_iter();\n             loop {"}, {"sha": "c82ee733a4cbe90f43be6cf588e7ef51f6391878", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 42, "deletions": 50, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -216,7 +216,7 @@ pub mod reader {\n         }\n     }\n \n-    pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) -> bool {\n+    pub fn docs(d: Doc, it: |uint, Doc| -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = vuint_at(*d.data, pos);\n@@ -230,7 +230,7 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) -> bool {\n+    pub fn tagged_docs(d: Doc, tg: uint, it: |Doc| -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = vuint_at(*d.data, pos);\n@@ -247,7 +247,7 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn with_doc_data<T>(d: Doc, f: &fn(x: &[u8]) -> T) -> T {\n+    pub fn with_doc_data<T>(d: Doc, f: |x: &[u8]| -> T) -> T {\n         f(d.data.slice(d.start, d.end))\n     }\n \n@@ -332,7 +332,7 @@ pub mod reader {\n         }\n \n         fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n-                       f: &fn(&mut Decoder) -> T) -> T {\n+                       f: |&mut Decoder| -> T) -> T {\n             let d = self.next_doc(exp_tag);\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n@@ -352,8 +352,7 @@ pub mod reader {\n     }\n \n     impl Decoder {\n-        pub fn read_opaque<R>(&mut self, op: &fn(&mut Decoder, Doc) -> R)\n-                              -> R {\n+        pub fn read_opaque<R>(&mut self, op: |&mut Decoder, Doc| -> R) -> R {\n             let doc = self.next_doc(EsOpaque);\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n@@ -424,10 +423,7 @@ pub mod reader {\n         }\n \n         // Compound types:\n-        fn read_enum<T>(&mut self,\n-                        name: &str,\n-                        f: &fn(&mut Decoder) -> T)\n-                        -> T {\n+        fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder| -> T) -> T {\n             debug!(\"read_enum({})\", name);\n             self._check_label(name);\n \n@@ -446,7 +442,7 @@ pub mod reader {\n \n         fn read_enum_variant<T>(&mut self,\n                                 _: &[&str],\n-                                f: &fn(&mut Decoder, uint) -> T)\n+                                f: |&mut Decoder, uint| -> T)\n                                 -> T {\n             debug!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n@@ -467,14 +463,14 @@ pub mod reader {\n \n         fn read_enum_variant_arg<T>(&mut self,\n                                     idx: uint,\n-                                    f: &fn(&mut Decoder) -> T) -> T {\n+                                    f: |&mut Decoder| -> T) -> T {\n             debug!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n         fn read_enum_struct_variant<T>(&mut self,\n                                        _: &[&str],\n-                                       f: &fn(&mut Decoder, uint) -> T)\n+                                       f: |&mut Decoder, uint| -> T)\n                                        -> T {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n@@ -496,7 +492,7 @@ pub mod reader {\n         fn read_enum_struct_variant_field<T>(&mut self,\n                                              name: &str,\n                                              idx: uint,\n-                                             f: &fn(&mut Decoder) -> T)\n+                                             f: |&mut Decoder| -> T)\n                                              -> T {\n             debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n@@ -505,7 +501,7 @@ pub mod reader {\n         fn read_struct<T>(&mut self,\n                           name: &str,\n                           _: uint,\n-                          f: &fn(&mut Decoder) -> T)\n+                          f: |&mut Decoder| -> T)\n                           -> T {\n             debug!(\"read_struct(name={})\", name);\n             f(self)\n@@ -514,41 +510,41 @@ pub mod reader {\n         fn read_struct_field<T>(&mut self,\n                                 name: &str,\n                                 idx: uint,\n-                                f: &fn(&mut Decoder) -> T)\n+                                f: |&mut Decoder| -> T)\n                                 -> T {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n             self._check_label(name);\n             f(self)\n         }\n \n-        fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+        fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_tuple()\");\n             self.read_seq(f)\n         }\n \n-        fn read_tuple_arg<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                              -> T {\n             debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n         fn read_tuple_struct<T>(&mut self,\n                                 name: &str,\n-                                f: &fn(&mut Decoder, uint) -> T)\n+                                f: |&mut Decoder, uint| -> T)\n                                 -> T {\n             debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(f)\n         }\n \n         fn read_tuple_struct_arg<T>(&mut self,\n                                     idx: uint,\n-                                    f: &fn(&mut Decoder) -> T)\n+                                    f: |&mut Decoder| -> T)\n                                     -> T {\n             debug!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n-        fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n+        fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n             debug!(\"read_option()\");\n             do self.read_enum(\"Option\") |this| {\n                 do this.read_enum_variant([\"None\", \"Some\"]) |this, idx| {\n@@ -561,7 +557,7 @@ pub mod reader {\n             }\n         }\n \n-        fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+        fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_seq()\");\n             do self.push_doc(EsVec) |d| {\n                 let len = d._next_uint(EsVecLen);\n@@ -570,13 +566,13 @@ pub mod reader {\n             }\n         }\n \n-        fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                            -> T {\n             debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n-        fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+        fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_map()\");\n             do self.push_doc(EsMap) |d| {\n                 let len = d._next_uint(EsMapLen);\n@@ -585,17 +581,13 @@ pub mod reader {\n             }\n         }\n \n-        fn read_map_elt_key<T>(&mut self,\n-                               idx: uint,\n-                               f: &fn(&mut Decoder) -> T)\n+        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                                -> T {\n             debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n-        fn read_map_elt_val<T>(&mut self,\n-                               idx: uint,\n-                               f: &fn(&mut Decoder) -> T)\n+        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                                -> T {\n             debug!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n@@ -682,7 +674,7 @@ pub mod writer {\n             debug!(\"End tag (size = {})\", size);\n         }\n \n-        pub fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n+        pub fn wr_tag(&mut self, tag_id: uint, blk: ||) {\n             self.start_tag(tag_id);\n             blk();\n             self.end_tag();\n@@ -779,7 +771,7 @@ pub mod writer {\n     }\n \n     impl Encoder {\n-        pub fn emit_opaque(&mut self, f: &fn(&mut Encoder)) {\n+        pub fn emit_opaque(&mut self, f: |&mut Encoder|) {\n             self.start_tag(EsOpaque as uint);\n             f(self);\n             self.end_tag();\n@@ -841,7 +833,7 @@ pub mod writer {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum(&mut self, name: &str, f: &fn(&mut Encoder)) {\n+        fn emit_enum(&mut self, name: &str, f: |&mut Encoder|) {\n             self._emit_label(name);\n             self.start_tag(EsEnum as uint);\n             f(self);\n@@ -852,98 +844,98 @@ pub mod writer {\n                              _: &str,\n                              v_id: uint,\n                              _: uint,\n-                             f: &fn(&mut Encoder)) {\n+                             f: |&mut Encoder|) {\n             self._emit_tagged_uint(EsEnumVid, v_id);\n             self.start_tag(EsEnumBody as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_enum_variant_arg(&mut self, _: uint, f: &fn(&mut Encoder)) {\n+        fn emit_enum_variant_arg(&mut self, _: uint, f: |&mut Encoder|) {\n             f(self)\n         }\n \n         fn emit_enum_struct_variant(&mut self,\n                                     v_name: &str,\n                                     v_id: uint,\n                                     cnt: uint,\n-                                    f: &fn(&mut Encoder)) {\n+                                    f: |&mut Encoder|) {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n         fn emit_enum_struct_variant_field(&mut self,\n                                           _: &str,\n                                           idx: uint,\n-                                          f: &fn(&mut Encoder)) {\n+                                          f: |&mut Encoder|) {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&mut self, _: &str, _len: uint, f: &fn(&mut Encoder)) {\n+        fn emit_struct(&mut self, _: &str, _len: uint, f: |&mut Encoder|) {\n             f(self)\n         }\n \n         fn emit_struct_field(&mut self,\n                              name: &str,\n                              _: uint,\n-                             f: &fn(&mut Encoder)) {\n+                             f: |&mut Encoder|) {\n             self._emit_label(name);\n             f(self)\n         }\n \n-        fn emit_tuple(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+        fn emit_tuple(&mut self, len: uint, f: |&mut Encoder|) {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n             self.emit_seq_elt(idx, f)\n         }\n \n         fn emit_tuple_struct(&mut self,\n                              _: &str,\n                              len: uint,\n-                             f: &fn(&mut Encoder)) {\n+                             f: |&mut Encoder|) {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_struct_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_option(&mut self, f: &fn(&mut Encoder)) {\n+        fn emit_option(&mut self, f: |&mut Encoder|) {\n             self.emit_enum(\"Option\", f);\n         }\n         fn emit_option_none(&mut self) {\n             self.emit_enum_variant(\"None\", 0, 0, |_| ())\n         }\n-        fn emit_option_some(&mut self, f: &fn(&mut Encoder)) {\n+        fn emit_option_some(&mut self, f: |&mut Encoder|) {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+        fn emit_seq(&mut self, len: uint, f: |&mut Encoder|) {\n             self.start_tag(EsVec as uint);\n             self._emit_tagged_uint(EsVecLen, len);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_seq_elt(&mut self, _idx: uint, f: |&mut Encoder|) {\n             self.start_tag(EsVecElt as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+        fn emit_map(&mut self, len: uint, f: |&mut Encoder|) {\n             self.start_tag(EsMap as uint);\n             self._emit_tagged_uint(EsMapLen, len);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: |&mut Encoder|) {\n             self.start_tag(EsMapKey as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder|) {\n             self.start_tag(EsMapVal as uint);\n             f(self);\n             self.end_tag();"}, {"sha": "d0df9dbe8383221f3f1932d46e2fc2939a88f1dd", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -768,9 +768,8 @@ pub mod groups {\n     ///\n     /// Fails during iteration if the string contains a non-whitespace\n     /// sequence longer than the limit.\n-    fn each_split_within<'a>(ss: &'a str,\n-                             lim: uint,\n-                             it: &fn(&'a str) -> bool) -> bool {\n+    fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n+                         -> bool {\n         // Just for fun, let's write this as a state machine:\n \n         enum SplitWithinState {\n@@ -795,14 +794,14 @@ pub mod groups {\n         let mut lim = lim;\n \n         let mut cont = true;\n-        let slice: &fn() = || { cont = it(ss.slice(slice_start, last_end)) };\n+        let slice: || = || { cont = it(ss.slice(slice_start, last_end)) };\n \n         // if the limit is larger than the string, lower it to save cycles\n         if (lim >= fake_i) {\n             lim = fake_i;\n         }\n \n-        let machine: &fn((uint, char)) -> bool = |(i, c)| {\n+        let machine: |(uint, char)| -> bool = |(i, c)| {\n             let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n             let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n "}, {"sha": "64655ca2b70f87c02b90e9e86d883f79f4ef0da4", "filename": "src/libextra/json.rs", "status": "modified", "additions": 54, "deletions": 61, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -129,13 +129,13 @@ impl serialize::Encoder for Encoder {\n         write!(self.wr, \"{}\", escape_str(v))\n     }\n \n-    fn emit_enum(&mut self, _name: &str, f: &fn(&mut Encoder)) { f(self) }\n+    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder|) { f(self) }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _id: uint,\n                          cnt: uint,\n-                         f: &fn(&mut Encoder)) {\n+                         f: |&mut Encoder|) {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n@@ -150,7 +150,7 @@ impl serialize::Encoder for Encoder {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n@@ -161,18 +161,18 @@ impl serialize::Encoder for Encoder {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: &fn(&mut Encoder)) {\n+                                f: |&mut Encoder|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: &fn(&mut Encoder)) {\n+                                      f: |&mut Encoder|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&mut self, _: &str, _: uint, f: &fn(&mut Encoder)) {\n+    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n@@ -181,58 +181,58 @@ impl serialize::Encoder for Encoder {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: &fn(&mut Encoder)) {\n+                         f: |&mut Encoder|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         write!(self.wr, \"{}:\", escape_str(name));\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _name: &str,\n                          len: uint,\n-                         f: &fn(&mut Encoder)) {\n+                         f: |&mut Encoder|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: &fn(&mut Encoder)) { f(self); }\n+    fn emit_option(&mut self, f: |&mut Encoder|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: &fn(&mut Encoder)) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut Encoder|) { f(self); }\n \n-    fn emit_seq(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n+    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder|) {\n         write!(self.wr, \"[\");\n         f(self);\n         write!(self.wr, \"]\");\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n         f(self)\n     }\n \n-    fn emit_map(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n+    fn emit_map(&mut self, _len: uint, f: |&mut Encoder|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         f(self)\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder|) {\n         write!(self.wr, \":\");\n         f(self)\n     }\n@@ -284,15 +284,15 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) { write!(self.wr, \"{}\", escape_str(v)); }\n \n-    fn emit_enum(&mut self, _name: &str, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder|) {\n         f(self)\n     }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _: uint,\n                          cnt: uint,\n-                         f: &fn(&mut PrettyEncoder)) {\n+                         f: |&mut PrettyEncoder|) {\n         if cnt == 0 {\n             write!(self.wr, \"{}\", escape_str(name));\n         } else {\n@@ -306,7 +306,7 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n-                             f: &fn(&mut PrettyEncoder)) {\n+                             f: |&mut PrettyEncoder|) {\n         if idx != 0 {\n             write!(self.wr, \",\\n\");\n         }\n@@ -318,22 +318,22 @@ impl serialize::Encoder for PrettyEncoder {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: &fn(&mut PrettyEncoder)) {\n+                                f: |&mut PrettyEncoder|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: &fn(&mut PrettyEncoder)) {\n+                                      f: |&mut PrettyEncoder|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n     fn emit_struct(&mut self,\n                    _: &str,\n                    len: uint,\n-                   f: &fn(&mut PrettyEncoder)) {\n+                   f: |&mut PrettyEncoder|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -348,7 +348,7 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: &fn(&mut PrettyEncoder)) {\n+                         f: |&mut PrettyEncoder|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -358,30 +358,30 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _: &str,\n                          len: uint,\n-                         f: &fn(&mut PrettyEncoder)) {\n+                         f: |&mut PrettyEncoder|) {\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg(&mut self,\n                              idx: uint,\n-                             f: &fn(&mut PrettyEncoder)) {\n+                             f: |&mut PrettyEncoder|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: &fn(&mut PrettyEncoder)) { f(self); }\n+    fn emit_option(&mut self, f: |&mut PrettyEncoder|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: &fn(&mut PrettyEncoder)) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut PrettyEncoder|) { f(self); }\n \n-    fn emit_seq(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n         if len == 0 {\n             write!(self.wr, \"[]\");\n         } else {\n@@ -393,7 +393,7 @@ impl serialize::Encoder for PrettyEncoder {\n         }\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -403,7 +403,7 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self)\n     }\n \n-    fn emit_map(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -415,7 +415,7 @@ impl serialize::Encoder for PrettyEncoder {\n         }\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -425,7 +425,7 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self);\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder|) {\n         write!(self.wr, \": \");\n         f(self);\n     }\n@@ -921,14 +921,14 @@ impl serialize::Decoder for Decoder {\n         }\n     }\n \n-    fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Decoder) -> T) -> T {\n+    fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder| -> T) -> T {\n         debug!(\"read_enum({})\", name);\n         f(self)\n     }\n \n     fn read_enum_variant<T>(&mut self,\n                             names: &[&str],\n-                            f: &fn(&mut Decoder, uint) -> T)\n+                            f: |&mut Decoder, uint| -> T)\n                             -> T {\n         debug!(\"read_enum_variant(names={:?})\", names);\n         let name = match self.stack.pop() {\n@@ -957,17 +957,15 @@ impl serialize::Decoder for Decoder {\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T>(&mut self,\n-                                idx: uint,\n-                                f: &fn(&mut Decoder) -> T)\n+    fn read_enum_variant_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                                 -> T {\n         debug!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T>(&mut self,\n                                    names: &[&str],\n-                                   f: &fn(&mut Decoder, uint) -> T)\n+                                   f: |&mut Decoder, uint| -> T)\n                                    -> T {\n         debug!(\"read_enum_struct_variant(names={:?})\", names);\n         self.read_enum_variant(names, f)\n@@ -977,7 +975,7 @@ impl serialize::Decoder for Decoder {\n     fn read_enum_struct_variant_field<T>(&mut self,\n                                          name: &str,\n                                          idx: uint,\n-                                         f: &fn(&mut Decoder) -> T)\n+                                         f: |&mut Decoder| -> T)\n                                          -> T {\n         debug!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n@@ -986,7 +984,7 @@ impl serialize::Decoder for Decoder {\n     fn read_struct<T>(&mut self,\n                       name: &str,\n                       len: uint,\n-                      f: &fn(&mut Decoder) -> T)\n+                      f: |&mut Decoder| -> T)\n                       -> T {\n         debug!(\"read_struct(name={}, len={})\", name, len);\n         let value = f(self);\n@@ -997,7 +995,7 @@ impl serialize::Decoder for Decoder {\n     fn read_struct_field<T>(&mut self,\n                             name: &str,\n                             idx: uint,\n-                            f: &fn(&mut Decoder) -> T)\n+                            f: |&mut Decoder| -> T)\n                             -> T {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         match self.stack.pop() {\n@@ -1017,43 +1015,40 @@ impl serialize::Decoder for Decoder {\n         }\n     }\n \n-    fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+    fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_tuple()\");\n         self.read_seq(f)\n     }\n \n-    fn read_tuple_arg<T>(&mut self,\n-                         idx: uint,\n-                         f: &fn(&mut Decoder) -> T)\n-                         -> T {\n+    fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n         debug!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T>(&mut self,\n                             name: &str,\n-                            f: &fn(&mut Decoder, uint) -> T)\n+                            f: |&mut Decoder, uint| -> T)\n                             -> T {\n         debug!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(f)\n     }\n \n     fn read_tuple_struct_arg<T>(&mut self,\n                                 idx: uint,\n-                                f: &fn(&mut Decoder) -> T)\n+                                f: |&mut Decoder| -> T)\n                                 -> T {\n         debug!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n-    fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n+    fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n         match self.stack.pop() {\n             Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n         }\n     }\n \n-    fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+    fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_seq()\");\n         let len = match self.stack.pop() {\n             List(list) => {\n@@ -1068,12 +1063,12 @@ impl serialize::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T) -> T {\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n         debug!(\"read_seq_elt(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+    fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_map()\");\n         let len = match self.stack.pop() {\n             Object(obj) => {\n@@ -1089,15 +1084,13 @@ impl serialize::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T>(&mut self,\n-                           idx: uint,\n-                           f: &fn(&mut Decoder) -> T)\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                            -> T {\n         debug!(\"read_map_elt_key(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                            -> T {\n         debug!(\"read_map_elt_val(idx={})\", idx);\n         f(self)\n@@ -1482,7 +1475,7 @@ mod tests {\n         assert_eq!(a.clone(), from_str(a.to_pretty_str()).unwrap());\n     }\n \n-    fn with_str_writer(f: &fn(@mut io::Writer)) -> ~str {\n+    fn with_str_writer(f: |@mut io::Writer|) -> ~str {\n         use std::io::mem::MemWriter;\n         use std::io::Decorator;\n         use std::str;"}, {"sha": "22d273e5747cd7d972ca05db6e693a54935fa36d", "filename": "src/libextra/list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -44,7 +44,7 @@ pub fn from_vec<T:Clone + 'static>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n+pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: |&T, &U| -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, elt);}\n     accum\n@@ -57,7 +57,7 @@ pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub fn find<T:Clone>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n+pub fn find<T:Clone>(ls: @List<T>, f: |&T| -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -131,7 +131,7 @@ fn push<T:Clone>(ll: &mut @list<T>, vv: T) {\n */\n \n /// Iterate over a list\n-pub fn iter<T>(l: @List<T>, f: &fn(&T)) {\n+pub fn iter<T>(l: @List<T>, f: |&T|) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -145,7 +145,7 @@ pub fn iter<T>(l: @List<T>, f: &fn(&T)) {\n }\n \n /// Iterate over a list\n-pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) -> bool {\n+pub fn each<T>(l: @List<T>, f: |&T| -> bool) -> bool {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -160,7 +160,7 @@ pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) -> bool {\n \n impl<T> MutList<T> {\n     /// Iterate over a mutable list\n-    pub fn each(@mut self, f: &fn(&mut T) -> bool) -> bool {\n+    pub fn each(@mut self, f: |&mut T| -> bool) -> bool {\n         let mut cur = self;\n         loop {\n             let borrowed = &mut *cur;"}, {"sha": "3de71c83c49bed706554c321cc1004a5981033bc", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -145,8 +145,8 @@ condition! {\n     bad_parse: () -> ();\n }\n \n-fn take_nonempty_prefix<T: Iterator<char>>(rdr: &mut T,\n-                        pred: &fn(char) -> bool) -> (~str, Option<char>) {\n+fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n+                        -> (~str, Option<char>) {\n     let mut buf = ~\"\";\n     let mut ch = rdr.next();\n     loop {"}, {"sha": "8e75be651cfa604ce4cb12b6440514eea619a5c7", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -47,48 +47,48 @@ pub trait Encoder {\n     fn emit_str(&mut self, v: &str);\n \n     // Compound types:\n-    fn emit_enum(&mut self, name: &str, f: &fn(&mut Self));\n+    fn emit_enum(&mut self, name: &str, f: |&mut Self|);\n \n     fn emit_enum_variant(&mut self,\n                          v_name: &str,\n                          v_id: uint,\n                          len: uint,\n-                         f: &fn(&mut Self));\n-    fn emit_enum_variant_arg(&mut self, a_idx: uint, f: &fn(&mut Self));\n+                         f: |&mut Self|);\n+    fn emit_enum_variant_arg(&mut self, a_idx: uint, f: |&mut Self|);\n \n     fn emit_enum_struct_variant(&mut self,\n                                 v_name: &str,\n                                 v_id: uint,\n                                 len: uint,\n-                                f: &fn(&mut Self));\n+                                f: |&mut Self|);\n     fn emit_enum_struct_variant_field(&mut self,\n                                       f_name: &str,\n                                       f_idx: uint,\n-                                      f: &fn(&mut Self));\n+                                      f: |&mut Self|);\n \n-    fn emit_struct(&mut self, name: &str, len: uint, f: &fn(&mut Self));\n+    fn emit_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n     fn emit_struct_field(&mut self,\n                          f_name: &str,\n                          f_idx: uint,\n-                         f: &fn(&mut Self));\n+                         f: |&mut Self|);\n \n-    fn emit_tuple(&mut self, len: uint, f: &fn(&mut Self));\n-    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Self));\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Self|);\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Self|);\n \n-    fn emit_tuple_struct(&mut self, name: &str, len: uint, f: &fn(&mut Self));\n-    fn emit_tuple_struct_arg(&mut self, f_idx: uint, f: &fn(&mut Self));\n+    fn emit_tuple_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n+    fn emit_tuple_struct_arg(&mut self, f_idx: uint, f: |&mut Self|);\n \n     // Specialized types:\n-    fn emit_option(&mut self, f: &fn(&mut Self));\n+    fn emit_option(&mut self, f: |&mut Self|);\n     fn emit_option_none(&mut self);\n-    fn emit_option_some(&mut self, f: &fn(&mut Self));\n+    fn emit_option_some(&mut self, f: |&mut Self|);\n \n-    fn emit_seq(&mut self, len: uint, f: &fn(this: &mut Self));\n-    fn emit_seq_elt(&mut self, idx: uint, f: &fn(this: &mut Self));\n+    fn emit_seq(&mut self, len: uint, f: |this: &mut Self|);\n+    fn emit_seq_elt(&mut self, idx: uint, f: |this: &mut Self|);\n \n-    fn emit_map(&mut self, len: uint, f: &fn(&mut Self));\n-    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Self));\n-    fn emit_map_elt_val(&mut self, idx: uint, f: &fn(&mut Self));\n+    fn emit_map(&mut self, len: uint, f: |&mut Self|);\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Self|);\n+    fn emit_map_elt_val(&mut self, idx: uint, f: |&mut Self|);\n }\n \n pub trait Decoder {\n@@ -111,59 +111,56 @@ pub trait Decoder {\n     fn read_str(&mut self) -> ~str;\n \n     // Compound types:\n-    fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Self) -> T) -> T;\n+    fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> T) -> T;\n \n     fn read_enum_variant<T>(&mut self,\n                             names: &[&str],\n-                            f: &fn(&mut Self, uint) -> T)\n+                            f: |&mut Self, uint| -> T)\n                             -> T;\n     fn read_enum_variant_arg<T>(&mut self,\n                                 a_idx: uint,\n-                                f: &fn(&mut Self) -> T)\n+                                f: |&mut Self| -> T)\n                                 -> T;\n \n     fn read_enum_struct_variant<T>(&mut self,\n                                    names: &[&str],\n-                                   f: &fn(&mut Self, uint) -> T)\n+                                   f: |&mut Self, uint| -> T)\n                                    -> T;\n     fn read_enum_struct_variant_field<T>(&mut self,\n                                          &f_name: &str,\n                                          f_idx: uint,\n-                                         f: &fn(&mut Self) -> T)\n+                                         f: |&mut Self| -> T)\n                                          -> T;\n \n-    fn read_struct<T>(&mut self,\n-                      s_name: &str,\n-                      len: uint,\n-                      f: &fn(&mut Self) -> T)\n+    fn read_struct<T>(&mut self, s_name: &str, len: uint, f: |&mut Self| -> T)\n                       -> T;\n     fn read_struct_field<T>(&mut self,\n                             f_name: &str,\n                             f_idx: uint,\n-                            f: &fn(&mut Self) -> T)\n+                            f: |&mut Self| -> T)\n                             -> T;\n \n-    fn read_tuple<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n-    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: &fn(&mut Self) -> T) -> T;\n+    fn read_tuple<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n+    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: |&mut Self| -> T) -> T;\n \n     fn read_tuple_struct<T>(&mut self,\n                             s_name: &str,\n-                            f: &fn(&mut Self, uint) -> T)\n+                            f: |&mut Self, uint| -> T)\n                             -> T;\n     fn read_tuple_struct_arg<T>(&mut self,\n                                 a_idx: uint,\n-                                f: &fn(&mut Self) -> T)\n+                                f: |&mut Self| -> T)\n                                 -> T;\n \n     // Specialized types:\n-    fn read_option<T>(&mut self, f: &fn(&mut Self, bool) -> T) -> T;\n+    fn read_option<T>(&mut self, f: |&mut Self, bool| -> T) -> T;\n \n-    fn read_seq<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n-    fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n+    fn read_seq<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n \n-    fn read_map<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n+    fn read_map<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n }\n \n pub trait Encodable<S:Encoder> {\n@@ -892,11 +889,11 @@ impl<\n // In some cases, these should eventually be coded as traits.\n \n pub trait EncoderHelpers {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut Self, v: &T));\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut Self, v: &T|);\n }\n \n impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut S, &T)) {\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T|) {\n         do self.emit_seq(v.len()) |this| {\n             for (i, e) in v.iter().enumerate() {\n                 do this.emit_seq_elt(i) |this| {\n@@ -908,11 +905,11 @@ impl<S:Encoder> EncoderHelpers for S {\n }\n \n pub trait DecoderHelpers {\n-    fn read_to_vec<T>(&mut self, f: &fn(&mut Self) -> T) -> ~[T];\n+    fn read_to_vec<T>(&mut self, f: |&mut Self| -> T) -> ~[T];\n }\n \n impl<D:Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T>(&mut self, f: &fn(&mut D) -> T) -> ~[T] {\n+    fn read_to_vec<T>(&mut self, f: |&mut D| -> T) -> ~[T] {\n         do self.read_seq |this, len| {\n             do vec::from_fn(len) |i| {\n                 this.read_seq_elt(i, |this| f(this))"}, {"sha": "119988735a75e07314303f2e1d6cc4746fcb47f4", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -164,17 +164,19 @@ impl<V> SmallIntMap<V> {\n }\n \n impl<V:Clone> SmallIntMap<V> {\n-    pub fn update_with_key(&mut self, key: uint, val: V,\n-                           ff: &fn(uint, V, V) -> V) -> bool {\n+    pub fn update_with_key(&mut self,\n+                           key: uint,\n+                           val: V,\n+                           ff: |uint, V, V| -> V)\n+                           -> bool {\n         let new_val = match self.find(&key) {\n             None => val,\n             Some(orig) => ff(key, (*orig).clone(), val)\n         };\n         self.insert(key, new_val)\n     }\n \n-    pub fn update(&mut self, key: uint, newval: V, ff: &fn(V, V) -> V)\n-                  -> bool {\n+    pub fn update(&mut self, key: uint, newval: V, ff: |V, V| -> V) -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }\n }"}, {"sha": "f01eb7ef2afe9267089cf6f034abe4e26f517ef5", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -133,7 +133,7 @@ impl<Q:Send> Sem<Q> {\n         }\n     }\n \n-    pub fn access<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn access<U>(&self, blk: || -> U) -> U {\n         do task::unkillable {\n             do (|| {\n                 self.acquire();\n@@ -305,8 +305,12 @@ impl<'self> Condvar<'self> {\n // something else next on success.\n #[inline]\n #[doc(hidden)]\n-fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n-                        blk: &fn() -> U) -> U {\n+fn check_cvar_bounds<U>(\n+                     out_of_bounds: Option<uint>,\n+                     id: uint,\n+                     act: &str,\n+                     blk: || -> U)\n+                     -> U {\n     match out_of_bounds {\n         Some(0) =>\n             fail!(\"{} with illegal ID {} - this lock has no condvars!\", act, id),\n@@ -320,7 +324,7 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n impl Sem<~[WaitQueue]> {\n     // The only other places that condvars get built are rwlock.write_cond()\n     // and rwlock_write_mode.\n-    pub fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn access_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         do self.access {\n             blk(&Condvar { sem: self, order: Nothing, token: NonCopyable::new() })\n         }\n@@ -361,7 +365,7 @@ impl Semaphore {\n     pub fn release(&self) { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n-    pub fn access<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n+    pub fn access<U>(&self, blk: || -> U) -> U { (&self.sem).access(blk) }\n }\n \n /****************************************************************************\n@@ -399,12 +403,12 @@ impl Mutex {\n \n \n     /// Run a function with ownership of the mutex.\n-    pub fn lock<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn lock<U>(&self, blk: || -> U) -> U {\n         (&self.sem).access(blk)\n     }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n-    pub fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn lock_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         (&self.sem).access_cond(blk)\n     }\n }\n@@ -478,7 +482,7 @@ impl RWLock {\n      * Run a function with the rwlock in read mode. Calls to 'read' from other\n      * tasks may run concurrently with this one.\n      */\n-    pub fn read<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn read<U>(&self, blk: || -> U) -> U {\n         unsafe {\n             do task::unkillable {\n                 do (&self.order_lock).access {\n@@ -513,7 +517,7 @@ impl RWLock {\n      * Run a function with the rwlock in write mode. No calls to 'read' or\n      * 'write' from other tasks will run concurrently with this one.\n      */\n-    pub fn write<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn write<U>(&self, blk: || -> U) -> U {\n         do task::unkillable {\n             (&self.order_lock).acquire();\n             do (&self.access_lock).access {\n@@ -531,7 +535,7 @@ impl RWLock {\n      * the waiting task is signalled. (Note: a writer that waited and then\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn write_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         // It's important to thread our order lock into the condvar, so that\n         // when a cond.wait() wakes up, it uses it while reacquiring the\n         // access lock. If we permitted a waking-up writer to \"cut in line\",\n@@ -592,7 +596,7 @@ impl RWLock {\n      * }\n      * ```\n      */\n-    pub fn write_downgrade<U>(&self, blk: &fn(v: RWLockWriteMode) -> U) -> U {\n+    pub fn write_downgrade<U>(&self, blk: |v: RWLockWriteMode| -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         do task::unkillable {\n@@ -671,9 +675,9 @@ pub struct RWLockReadMode<'self> { priv lock: &'self RWLock,\n \n impl<'self> RWLockWriteMode<'self> {\n     /// Access the pre-downgrade rwlock in write mode.\n-    pub fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n+    pub fn write<U>(&self, blk: || -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn write_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         // Need to make the condvar use the order lock when reacquiring the\n         // access lock. See comment in RWLock::write_cond for why.\n         blk(&Condvar { sem:        &self.lock.access_lock,\n@@ -684,7 +688,7 @@ impl<'self> RWLockWriteMode<'self> {\n \n impl<'self> RWLockReadMode<'self> {\n     /// Access the post-downgrade rwlock in read mode.\n-    pub fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n+    pub fn read<U>(&self, blk: || -> U) -> U { blk() }\n }\n \n /****************************************************************************\n@@ -1060,7 +1064,7 @@ mod tests {\n     #[cfg(test)]\n     pub enum RWLockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    fn lock_rwlock_in_mode(x: &RWLock, mode: RWLockMode, blk: &fn()) {\n+    fn lock_rwlock_in_mode(x: &RWLock, mode: RWLockMode, blk: ||) {\n         match mode {\n             Read => x.read(blk),\n             Write => x.write(blk),\n@@ -1221,7 +1225,7 @@ mod tests {\n                                              dg1: bool,\n                                              dg2: bool) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n-        fn lock_cond(x: &RWLock, downgrade: bool, blk: &fn(c: &Condvar)) {\n+        fn lock_cond(x: &RWLock, downgrade: bool, blk: |c: &Condvar|) {\n             if downgrade {\n                 do x.write_downgrade |mode| {\n                     do mode.write_cond |c| { blk(c) }"}, {"sha": "37deba43e3a15afb388401786ac158be05fabb0b", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -49,7 +49,7 @@ impl<T> TaskPool<T> {\n     /// local data to be kept around in that task.\n     pub fn new(n_tasks: uint,\n                opt_sched_mode: Option<SchedMode>,\n-               init_fn_factory: &fn() -> proc(uint) -> T)\n+               init_fn_factory: || -> proc(uint) -> T)\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n@@ -97,7 +97,7 @@ impl<T> TaskPool<T> {\n \n #[test]\n fn test_task_pool() {\n-    let f: &fn() -> proc(uint) -> uint = || {\n+    let f: || -> proc(uint) -> uint = || {\n         let g: proc(uint) -> uint = |i| i;\n         g\n     };"}, {"sha": "e9f38471d48629db0d0a632e47816e626cb21da9", "filename": "src/libextra/test.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -715,8 +715,7 @@ type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts,\n              tests: ~[TestDescAndFn],\n-             callback: &fn(e: TestEvent)) {\n-\n+             callback: |e: TestEvent|) {\n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.map(|t| t.desc.clone());\n \n@@ -1058,7 +1057,7 @@ impl MetricMap {\n \n impl BenchHarness {\n     /// Callback for benchmark functions to run in their body.\n-    pub fn iter(&mut self, inner:&fn()) {\n+    pub fn iter(&mut self, inner: ||) {\n         self.ns_start = precise_time_ns();\n         let k = self.iterations;\n         for _ in range(0u64, k) {\n@@ -1083,15 +1082,15 @@ impl BenchHarness {\n         }\n     }\n \n-    pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n+    pub fn bench_n(&mut self, n: u64, f: |&mut BenchHarness|) {\n         self.iterations = n;\n         debug!(\"running benchmark for {} iterations\",\n                n as uint);\n         f(self);\n     }\n \n     // This is a more statistics-driven benchmark algorithm\n-    pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> stats::Summary {\n+    pub fn auto_bench(&mut self, f: |&mut BenchHarness|) -> stats::Summary {\n \n         // Initial bench run to get ballpark figure.\n         let mut n = 1_u64;\n@@ -1161,8 +1160,7 @@ impl BenchHarness {\n pub mod bench {\n     use test::{BenchHarness, BenchSamples};\n \n-    pub fn benchmark(f: &fn(&mut BenchHarness)) -> BenchSamples {\n-\n+    pub fn benchmark(f: |&mut BenchHarness|) -> BenchSamples {\n         let mut bs = BenchHarness {\n             iterations: 0,\n             ns_start: 0,"}, {"sha": "a19f501010e896d40488c69b06b2b7218a672715", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -136,7 +136,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Iterate over the map and mutate the contained values\n-    pub fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n+    pub fn mutate_values(&mut self, f: |&K, &mut V| -> bool) -> bool {\n         mutate_values(&mut self.root, f)\n     }\n \n@@ -678,9 +678,12 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n     }\n }\n \n-fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n-                                     f: &fn(&'r K, &'r mut V) -> bool)\n-                                  -> bool {\n+fn mutate_values<'r,\n+                 K:TotalOrd,\n+                 V>(\n+                 node: &'r mut Option<~TreeNode<K,V>>,\n+                 f: |&'r K, &'r mut V| -> bool)\n+                 -> bool {\n     match *node {\n       Some(~TreeNode{key: ref key, value: ref mut value, left: ref mut left,\n                      right: ref mut right, _}) => {\n@@ -1400,8 +1403,10 @@ mod test_set {\n         }\n     }\n \n-    fn check(a: &[int], b: &[int], expected: &[int],\n-             f: &fn(&TreeSet<int>, &TreeSet<int>, f: &fn(&int) -> bool) -> bool) {\n+    fn check(a: &[int],\n+             b: &[int],\n+             expected: &[int],\n+             f: |&TreeSet<int>, &TreeSet<int>, f: |&int| -> bool| -> bool) {\n         let mut set_a = TreeSet::new();\n         let mut set_b = TreeSet::new();\n "}, {"sha": "09f95800b3dc1f71979366e0f5384279b313971a", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a30aff4564437ccd2698be367ca98c81122ac0/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=18a30aff4564437ccd2698be367ca98c81122ac0", "patch": "@@ -295,7 +295,12 @@ impl Context {\n         Prep::new(self, fn_name)\n     }\n \n-    pub fn with_prep<'a, T>(&'a self, fn_name: &'a str, blk: &fn(p: &mut Prep) -> T) -> T {\n+    pub fn with_prep<'a,\n+                     T>(\n+                     &'a self,\n+                     fn_name: &'a str,\n+                     blk: |p: &mut Prep| -> T)\n+                     -> T {\n         let mut p = self.prep(fn_name);\n         blk(&mut p)\n     }"}]}