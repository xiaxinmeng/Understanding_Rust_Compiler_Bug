{"sha": "18a9d58266dfb86a3e3e6b53a42798dd4348d93b", "node_id": "C_kwDOAAsO6NoAKDE4YTlkNTgyNjZkZmI4NmEzZTNlNmI1M2E0Mjc5OGRkNDM0OGQ5M2I", "commit": {"author": {"name": "Jason A. Donenfeld", "email": "Jason@zx2c4.com", "date": "2022-04-08T20:09:44Z"}, "committer": {"name": "Jason A. Donenfeld", "email": "Jason@zx2c4.com", "date": "2022-05-20T22:02:20Z"}, "message": "Use GRND_INSECURE instead of /dev/urandom when possible\n\nFrom reading the source code, it appears like the desired semantic of\nstd::unix::rand is to always provide some bytes and never block. For\nthat reason GRND_NONBLOCK is checked before calling getrandom(0), so\nthat getrandom(0) won't block. If it would block, then the function\nfalls back to using /dev/urandom, which for the time being doesn't\nblock. There are some drawbacks to using /dev/urandom, however, and so\ngetrandom(GRND_INSECURE) was created as a replacement for this exact\ncircumstance.\n\ngetrandom(GRND_INSECURE) is the same as /dev/urandom, except:\n\n- It won't leave a warning in dmesg if used at early boot time, which is\n  a common occurance (and the reason why I found this issue);\n\n- It won't introduce a tiny delay at early boot on newer kernels when\n  /dev/urandom tries to opportunistically create jitter entropy;\n\n- It only requires 1 syscall, rather than 3.\n\nOther than that, it returns the same \"quality\" of randomness as\n/dev/urandom, and never blocks.\n\nIt's only available on kernels \u22655.6, so we try to use it, cache the\nresult of that attempt, and fall back to to the previous code if it\ndidn't work.", "tree": {"sha": "ee8cad0e916c301c1e3aced705ea22e4f9810d5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee8cad0e916c301c1e3aced705ea22e4f9810d5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18a9d58266dfb86a3e3e6b53a42798dd4348d93b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18a9d58266dfb86a3e3e6b53a42798dd4348d93b", "html_url": "https://github.com/rust-lang/rust/commit/18a9d58266dfb86a3e3e6b53a42798dd4348d93b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18a9d58266dfb86a3e3e6b53a42798dd4348d93b/comments", "author": {"login": "zx2c4", "id": 10643, "node_id": "MDQ6VXNlcjEwNjQz", "avatar_url": "https://avatars.githubusercontent.com/u/10643?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zx2c4", "html_url": "https://github.com/zx2c4", "followers_url": "https://api.github.com/users/zx2c4/followers", "following_url": "https://api.github.com/users/zx2c4/following{/other_user}", "gists_url": "https://api.github.com/users/zx2c4/gists{/gist_id}", "starred_url": "https://api.github.com/users/zx2c4/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zx2c4/subscriptions", "organizations_url": "https://api.github.com/users/zx2c4/orgs", "repos_url": "https://api.github.com/users/zx2c4/repos", "events_url": "https://api.github.com/users/zx2c4/events{/privacy}", "received_events_url": "https://api.github.com/users/zx2c4/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zx2c4", "id": 10643, "node_id": "MDQ6VXNlcjEwNjQz", "avatar_url": "https://avatars.githubusercontent.com/u/10643?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zx2c4", "html_url": "https://github.com/zx2c4", "followers_url": "https://api.github.com/users/zx2c4/followers", "following_url": "https://api.github.com/users/zx2c4/following{/other_user}", "gists_url": "https://api.github.com/users/zx2c4/gists{/gist_id}", "starred_url": "https://api.github.com/users/zx2c4/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zx2c4/subscriptions", "organizations_url": "https://api.github.com/users/zx2c4/orgs", "repos_url": "https://api.github.com/users/zx2c4/repos", "events_url": "https://api.github.com/users/zx2c4/events{/privacy}", "received_events_url": "https://api.github.com/users/zx2c4/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "204da52c34db2aa7e58e7b743c2bf2cdf485c048", "url": "https://api.github.com/repos/rust-lang/rust/commits/204da52c34db2aa7e58e7b743c2bf2cdf485c048", "html_url": "https://github.com/rust-lang/rust/commit/204da52c34db2aa7e58e7b743c2bf2cdf485c048"}], "stats": {"total": 15, "additions": 15, "deletions": 0}, "files": [{"sha": "ea6df7247137c3e8ec58e744d42d1bf10893d144", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18a9d58266dfb86a3e3e6b53a42798dd4348d93b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a9d58266dfb86a3e3e6b53a42798dd4348d93b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=18a9d58266dfb86a3e3e6b53a42798dd4348d93b", "patch": "@@ -30,6 +30,9 @@ mod imp {\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn getrandom(buf: &mut [u8]) -> libc::ssize_t {\n+        use crate::sync::atomic::{AtomicBool, Ordering};\n+        use crate::sys::os::errno;\n+\n         // A weak symbol allows interposition, e.g. for perf measurements that want to\n         // disable randomness for consistency. Otherwise, we'll try a raw syscall.\n         // (`getrandom` was added in glibc 2.25, musl 1.1.20, android API level 28)\n@@ -41,6 +44,18 @@ mod imp {\n             ) -> libc::ssize_t\n         }\n \n+        // This provides the best quality random numbers available at the given moment\n+        // without ever blocking, and is preferable to falling back to /dev/urandom.\n+        static GRND_INSECURE_AVAILABLE: AtomicBool = AtomicBool::new(true);\n+        if GRND_INSECURE_AVAILABLE.load(Ordering::Relaxed) {\n+            let ret = unsafe { getrandom(buf.as_mut_ptr().cast(), buf.len(), libc::GRND_INSECURE) };\n+            if ret == -1 && errno() as libc::c_int == libc::EINVAL {\n+                GRND_INSECURE_AVAILABLE.store(false, Ordering::Relaxed);\n+            } else {\n+                return ret;\n+            }\n+        }\n+\n         unsafe { getrandom(buf.as_mut_ptr().cast(), buf.len(), libc::GRND_NONBLOCK) }\n     }\n "}]}