{"sha": "19d8527890b59ed25432fbf5a9f1bd75ac814ae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZDg1Mjc4OTBiNTllZDI1NDMyZmJmNWE5ZjFiZDc1YWM4MTRhZTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-01-19T19:21:48Z"}, "committer": {"name": "Adam Perry", "email": "adam.n.perry@gmail.com", "date": "2020-01-19T22:26:28Z"}, "message": "rustc_mir: don't require a self argument for ReifyShim.", "tree": {"sha": "2f008281a74e367db206333177ff086f6aab2fef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f008281a74e367db206333177ff086f6aab2fef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19d8527890b59ed25432fbf5a9f1bd75ac814ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19d8527890b59ed25432fbf5a9f1bd75ac814ae2", "html_url": "https://github.com/rust-lang/rust/commit/19d8527890b59ed25432fbf5a9f1bd75ac814ae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19d8527890b59ed25432fbf5a9f1bd75ac814ae2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anp", "id": 6812281, "node_id": "MDQ6VXNlcjY4MTIyODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6812281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anp", "html_url": "https://github.com/anp", "followers_url": "https://api.github.com/users/anp/followers", "following_url": "https://api.github.com/users/anp/following{/other_user}", "gists_url": "https://api.github.com/users/anp/gists{/gist_id}", "starred_url": "https://api.github.com/users/anp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anp/subscriptions", "organizations_url": "https://api.github.com/users/anp/orgs", "repos_url": "https://api.github.com/users/anp/repos", "events_url": "https://api.github.com/users/anp/events{/privacy}", "received_events_url": "https://api.github.com/users/anp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ee922123facae1a170257bf1d6c493f8fa9f29e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee922123facae1a170257bf1d6c493f8fa9f29e", "html_url": "https://github.com/rust-lang/rust/commit/0ee922123facae1a170257bf1d6c493f8fa9f29e"}], "stats": {"total": 80, "additions": 53, "deletions": 27}, "files": [{"sha": "b84616142cb07d843c060e1a405b985545c0a8a9", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/19d8527890b59ed25432fbf5a9f1bd75ac814ae2/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d8527890b59ed25432fbf5a9f1bd75ac814ae2/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=19d8527890b59ed25432fbf5a9f1bd75ac814ae2", "patch": "@@ -31,9 +31,13 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n \n     let mut result = match instance {\n         ty::InstanceDef::Item(..) => bug!(\"item {:?} passed to make_shim\", instance),\n-        ty::InstanceDef::VtableShim(def_id) => {\n-            build_call_shim(tcx, instance, Adjustment::DerefMove, CallKind::Direct(def_id), None)\n-        }\n+        ty::InstanceDef::VtableShim(def_id) => build_call_shim(\n+            tcx,\n+            instance,\n+            Some(Adjustment::DerefMove),\n+            CallKind::Direct(def_id),\n+            None,\n+        ),\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n             let adjustment = match tcx.lang_items().fn_trait_kind(trait_) {\n@@ -50,15 +54,15 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n             let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n             let arg_tys = sig.inputs();\n \n-            build_call_shim(tcx, instance, adjustment, CallKind::Indirect, Some(arg_tys))\n+            build_call_shim(tcx, instance, Some(adjustment), CallKind::Indirect, Some(arg_tys))\n         }\n         // We are generating a call back to our def-id, which the\n         // codegen backend knows to turn to an actual call, be it\n         // a virtual call, or a direct call to a function for which\n         // indirect calls must be codegen'd differently than direct ones\n         // (such as `#[track_caller]`).\n         ty::InstanceDef::ReifyShim(def_id) => {\n-            build_call_shim(tcx, instance, Adjustment::Identity, CallKind::Direct(def_id), None)\n+            build_call_shim(tcx, instance, None, CallKind::Direct(def_id), None)\n         }\n         ty::InstanceDef::ClosureOnceShim { call_once: _ } => {\n             let fn_mut = tcx.lang_items().fn_mut_trait().unwrap();\n@@ -68,7 +72,13 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n                 .unwrap()\n                 .def_id;\n \n-            build_call_shim(tcx, instance, Adjustment::RefMut, CallKind::Direct(call_mut), None)\n+            build_call_shim(\n+                tcx,\n+                instance,\n+                Some(Adjustment::RefMut),\n+                CallKind::Direct(call_mut),\n+                None,\n+            )\n         }\n         ty::InstanceDef::DropGlue(def_id, ty) => build_drop_shim(tcx, def_id, ty),\n         ty::InstanceDef::CloneShim(def_id, ty) => {\n@@ -648,7 +658,7 @@ impl CloneShimBuilder<'tcx> {\n fn build_call_shim<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,\n-    rcvr_adjustment: Adjustment,\n+    rcvr_adjustment: Option<Adjustment>,\n     call_kind: CallKind,\n     untuple_args: Option<&[Ty<'tcx>]>,\n ) -> BodyAndCache<'tcx> {\n@@ -680,14 +690,16 @@ fn build_call_shim<'tcx>(\n     let mut local_decls = local_decls_for_sig(&sig, span);\n     let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n \n-    let rcvr_arg = Local::new(1 + 0);\n-    let rcvr_l = Place::from(rcvr_arg);\n+    let rcvr_place = || {\n+        assert!(rcvr_adjustment.is_some());\n+        Place::from(Local::new(1 + 0))\n+    };\n     let mut statements = vec![];\n \n-    let rcvr = match rcvr_adjustment {\n-        Adjustment::Identity => Operand::Move(rcvr_l),\n-        Adjustment::Deref => Operand::Copy(tcx.mk_place_deref(rcvr_l)),\n-        Adjustment::DerefMove => Operand::Move(tcx.mk_place_deref(rcvr_l)),\n+    let rcvr = rcvr_adjustment.map(|rcvr_adjustment| match rcvr_adjustment {\n+        Adjustment::Identity => Operand::Move(rcvr_place()),\n+        Adjustment::Deref => Operand::Copy(tcx.mk_place_deref(rcvr_place())),\n+        Adjustment::DerefMove => Operand::Move(tcx.mk_place_deref(rcvr_place())),\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n             let ref_rcvr = local_decls.push(temp_decl(\n@@ -703,15 +715,15 @@ fn build_call_shim<'tcx>(\n                 source_info,\n                 kind: StatementKind::Assign(box (\n                     Place::from(ref_rcvr),\n-                    Rvalue::Ref(tcx.lifetimes.re_erased, borrow_kind, rcvr_l),\n+                    Rvalue::Ref(tcx.lifetimes.re_erased, borrow_kind, rcvr_place()),\n                 )),\n             });\n             Operand::Move(Place::from(ref_rcvr))\n         }\n-    };\n+    });\n \n     let (callee, mut args) = match call_kind {\n-        CallKind::Indirect => (rcvr, vec![]),\n+        CallKind::Indirect => (rcvr.unwrap(), vec![]),\n         CallKind::Direct(def_id) => {\n             let ty = tcx.type_of(def_id);\n             (\n@@ -720,21 +732,35 @@ fn build_call_shim<'tcx>(\n                     user_ty: None,\n                     literal: ty::Const::zero_sized(tcx, ty),\n                 }),\n-                vec![rcvr],\n+                rcvr.into_iter().collect::<Vec<_>>(),\n             )\n         }\n     };\n \n+    let mut arg_range = 0..sig.inputs().len();\n+\n+    // Take the `self` (\"receiver\") argument out of the range (it's adjusted above).\n+    if rcvr_adjustment.is_some() {\n+        arg_range.start += 1;\n+    }\n+\n+    // Take the last argument, if we need to untuple it (handled below).\n+    if untuple_args.is_some() {\n+        arg_range.end -= 1;\n+    }\n+\n+    // Pass all of the non-special arguments directly.\n+    args.extend(arg_range.map(|i| Operand::Move(Place::from(Local::new(1 + i)))));\n+\n+    // Untuple the last argument, if we have to.\n     if let Some(untuple_args) = untuple_args {\n+        let tuple_arg = Local::new(1 + (sig.inputs().len() - 1));\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n-            let arg_place = Place::from(Local::new(1 + 1));\n-            Operand::Move(tcx.mk_place_field(arg_place, Field::new(i), *ity))\n+            Operand::Move(tcx.mk_place_field(Place::from(tuple_arg), Field::new(i), *ity))\n         }));\n-    } else {\n-        args.extend((1..sig.inputs().len()).map(|i| Operand::Move(Place::from(Local::new(1 + i)))));\n     }\n \n-    let n_blocks = if let Adjustment::RefMut = rcvr_adjustment { 5 } else { 2 };\n+    let n_blocks = if let Some(Adjustment::RefMut) = rcvr_adjustment { 5 } else { 2 };\n     let mut blocks = IndexVec::with_capacity(n_blocks);\n     let block = |blocks: &mut IndexVec<_, _>, statements, kind, is_cleanup| {\n         blocks.push(BasicBlockData {\n@@ -752,7 +778,7 @@ fn build_call_shim<'tcx>(\n             func: callee,\n             args,\n             destination: Some((Place::return_place(), BasicBlock::new(1))),\n-            cleanup: if let Adjustment::RefMut = rcvr_adjustment {\n+            cleanup: if let Some(Adjustment::RefMut) = rcvr_adjustment {\n                 Some(BasicBlock::new(3))\n             } else {\n                 None\n@@ -762,13 +788,13 @@ fn build_call_shim<'tcx>(\n         false,\n     );\n \n-    if let Adjustment::RefMut = rcvr_adjustment {\n+    if let Some(Adjustment::RefMut) = rcvr_adjustment {\n         // BB #1 - drop for Self\n         block(\n             &mut blocks,\n             vec![],\n             TerminatorKind::Drop {\n-                location: Place::from(rcvr_arg),\n+                location: rcvr_place(),\n                 target: BasicBlock::new(2),\n                 unwind: None,\n             },\n@@ -777,13 +803,13 @@ fn build_call_shim<'tcx>(\n     }\n     // BB #1/#2 - return\n     block(&mut blocks, vec![], TerminatorKind::Return, false);\n-    if let Adjustment::RefMut = rcvr_adjustment {\n+    if let Some(Adjustment::RefMut) = rcvr_adjustment {\n         // BB #3 - drop if closure panics\n         block(\n             &mut blocks,\n             vec![],\n             TerminatorKind::Drop {\n-                location: Place::from(rcvr_arg),\n+                location: rcvr_place(),\n                 target: BasicBlock::new(4),\n                 unwind: None,\n             },"}]}