{"sha": "da6ab956e1002517803ecd38b904504a1223274b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNmFiOTU2ZTEwMDI1MTc4MDNlY2QzOGI5MDQ1MDRhMTIyMzI3NGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-27T20:50:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-27T20:50:17Z"}, "message": "Auto merge of #56932 - clarcharr:iter_refactor, r=Centril\n\nRefactor core::iter module\n\nA while back, I refactored `core::ops` in #42523 because the module had become a giant mess and was difficult to modify. Now, I'm doing the same with the `core::iter` module.\n\nLike the `core::ops` refactor, things have been split up into multiple commits to make rebasing easier, and so that you can follow changes. Although the diffs are hard to decipher, the only actual code changes I've made in the first few commits are to modify exports and imports. I save all of the actual code refactoring, e.g. modifying what methods are called, for the end.", "tree": {"sha": "0a8619efe66523f5a6aeae38b3259eb241af9d7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a8619efe66523f5a6aeae38b3259eb241af9d7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da6ab956e1002517803ecd38b904504a1223274b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da6ab956e1002517803ecd38b904504a1223274b", "html_url": "https://github.com/rust-lang/rust/commit/da6ab956e1002517803ecd38b904504a1223274b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da6ab956e1002517803ecd38b904504a1223274b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8611577360e66f90470bd40c498cf8d194f67926", "url": "https://api.github.com/repos/rust-lang/rust/commits/8611577360e66f90470bd40c498cf8d194f67926", "html_url": "https://github.com/rust-lang/rust/commit/8611577360e66f90470bd40c498cf8d194f67926"}, {"sha": "02bda7a0617fd0d0d3ac11dffb17ffba8c0f0601", "url": "https://api.github.com/repos/rust-lang/rust/commits/02bda7a0617fd0d0d3ac11dffb17ffba8c0f0601", "html_url": "https://github.com/rust-lang/rust/commit/02bda7a0617fd0d0d3ac11dffb17ffba8c0f0601"}], "stats": {"total": 7894, "additions": 4032, "deletions": 3862}, "files": [{"sha": "573b096fb463e6860f905b366f68d62280cd5949", "filename": "src/libcore/iter/adapters/chain.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,260 @@\n+use ops::Try;\n+use usize;\n+use super::super::{Iterator, DoubleEndedIterator, FusedIterator, TrustedLen};\n+\n+/// An iterator that strings two iterators together.\n+///\n+/// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`chain`]: trait.Iterator.html#method.chain\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Chain<A, B> {\n+    a: A,\n+    b: B,\n+    state: ChainState,\n+}\n+impl<A, B> Chain<A, B> {\n+    pub(in super::super) fn new(a: A, b: B) -> Chain<A, B> {\n+        Chain { a, b, state: ChainState::Both }\n+    }\n+}\n+\n+// The iterator protocol specifies that iteration ends with the return value\n+// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n+// further calls return. The chain adaptor must account for this since it uses\n+// two subiterators.\n+//\n+//  It uses three states:\n+//\n+//  - Both: `a` and `b` are remaining\n+//  - Front: `a` remaining\n+//  - Back: `b` remaining\n+//\n+//  The fourth state (neither iterator is remaining) only occurs after Chain has\n+//  returned None once, so we don't need to store this state.\n+#[derive(Clone, Debug)]\n+enum ChainState {\n+    // both front and back iterator are remaining\n+    Both,\n+    // only front is remaining\n+    Front,\n+    // only back is remaining\n+    Back,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Chain<A, B> where\n+    A: Iterator,\n+    B: Iterator<Item = A::Item>\n+{\n+    type Item = A::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.a.next() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Back;\n+                    self.b.next()\n+                }\n+            },\n+            ChainState::Front => self.a.next(),\n+            ChainState::Back => self.b.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn count(self) -> usize {\n+        match self.state {\n+            ChainState::Both => self.a.count() + self.b.count(),\n+            ChainState::Front => self.a.count(),\n+            ChainState::Back => self.b.count(),\n+        }\n+    }\n+\n+    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.try_fold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            _ => { }\n+        }\n+        if let ChainState::Back = self.state {\n+            accum = self.b.try_fold(accum, &mut f)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        accum\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                for x in self.a.by_ref() {\n+                    if n == 0 {\n+                        return Some(x)\n+                    }\n+                    n -= 1;\n+                }\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            ChainState::Back => {}\n+        }\n+        if let ChainState::Back = self.state {\n+            self.b.nth(n)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        match self.state {\n+            ChainState::Both => match self.a.find(&mut predicate) {\n+                None => {\n+                    self.state = ChainState::Back;\n+                    self.b.find(predicate)\n+                }\n+                v => v\n+            },\n+            ChainState::Front => self.a.find(predicate),\n+            ChainState::Back => self.b.find(predicate),\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => {\n+                // Must exhaust a before b.\n+                let a_last = self.a.last();\n+                let b_last = self.b.last();\n+                b_last.or(a_last)\n+            },\n+            ChainState::Front => self.a.last(),\n+            ChainState::Back => self.b.last()\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = a_lower.saturating_add(b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => x.checked_add(y),\n+            _ => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Chain<A, B> where\n+    A: DoubleEndedIterator,\n+    B: DoubleEndedIterator<Item=A::Item>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.b.next_back() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Front;\n+                    self.a.next_back()\n+                }\n+            },\n+            ChainState::Front => self.a.next_back(),\n+            ChainState::Back => self.b.next_back(),\n+        }\n+    }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.try_rfold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Front;\n+                }\n+            }\n+            _ => { }\n+        }\n+        if let ChainState::Front = self.state {\n+            accum = self.a.try_rfold(accum, &mut f)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.rfold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.rfold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        accum\n+    }\n+\n+}\n+\n+// Note: *both* must be fused to handle double-ended iterators.\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<A, B> FusedIterator for Chain<A, B>\n+    where A: FusedIterator,\n+          B: FusedIterator<Item=A::Item>,\n+{}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, B> TrustedLen for Chain<A, B>\n+    where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n+{}\n+"}, {"sha": "40f6865d38bcf036c827b77288e2e9a575572aac", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,330 @@\n+use fmt;\n+use ops::Try;\n+use super::super::{Iterator, DoubleEndedIterator, FusedIterator};\n+use super::Map;\n+\n+/// An iterator that maps each element to an iterator, and yields the elements\n+/// of the produced iterators.\n+///\n+/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flat_map`]: trait.Iterator.html#method.flat_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct FlatMap<I, U: IntoIterator, F> {\n+    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+}\n+impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {\n+    pub(in super::super) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n+        FlatMap { inner: FlattenCompat::new(iter.map(f)) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n+    where <U as IntoIterator>::IntoIter: Clone\n+{\n+    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n+    where U::IntoIter: fmt::Debug\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+          U: IntoIterator,\n+          U::IntoIter: DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n+    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n+\n+/// An iterator that flattens one level of nesting in an iterator of things\n+/// that can be turned into iterators.\n+///\n+/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flatten`]: trait.Iterator.html#method.flatten\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+pub struct Flatten<I: Iterator>\n+where I::Item: IntoIterator {\n+    inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n+}\n+impl<I: Iterator> Flatten<I>\n+where I::Item: IntoIterator {\n+    pub(in super::super) fn new(iter: I) -> Flatten<I> {\n+        Flatten { inner: FlattenCompat::new(iter) }\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> fmt::Debug for Flatten<I>\n+    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> Clone for Flatten<I>\n+    where I: Iterator + Clone, U: Iterator + Clone,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> Iterator for Flatten<I>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> DoubleEndedIterator for Flatten<I>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> FusedIterator for Flatten<I>\n+    where I: FusedIterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n+\n+/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n+/// this type.\n+#[derive(Clone, Debug)]\n+struct FlattenCompat<I, U> {\n+    iter: I,\n+    frontiter: Option<U>,\n+    backiter: Option<U>,\n+}\n+impl<I, U> FlattenCompat<I, U> {\n+    /// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n+    fn new(iter: I) -> FlattenCompat<I, U> {\n+        FlattenCompat { iter, frontiter: None, backiter: None }\n+    }\n+}\n+\n+impl<I, U> Iterator for FlattenCompat<I, U>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.frontiter {\n+                if let elt@Some(_) = inner.next() { return elt }\n+            }\n+            match self.iter.next() {\n+                None => return self.backiter.as_mut().and_then(|it| it.next()),\n+                Some(inner) => self.frontiter = Some(inner.into_iter()),\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let lo = flo.saturating_add(blo);\n+        match (self.iter.size_hint(), fhi, bhi) {\n+            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n+            _ => (lo, None)\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_fold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        {\n+            let frontiter = &mut self.frontiter;\n+            init = self.iter.try_fold(init, |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_fold(acc, &mut fold);\n+                *frontiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.frontiter = None;\n+\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_fold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.frontiter.into_iter()\n+            .chain(self.iter.map(IntoIterator::into_iter))\n+            .chain(self.backiter)\n+            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n+    }\n+}\n+\n+impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.backiter {\n+                if let elt@Some(_) = inner.next_back() { return elt }\n+            }\n+            match self.iter.next_back() {\n+                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n+                next => self.backiter = next.map(IntoIterator::into_iter),\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_rfold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        {\n+            let backiter = &mut self.backiter;\n+            init = self.iter.try_rfold(init, |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_rfold(acc, &mut fold);\n+                *backiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.backiter = None;\n+\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_rfold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.frontiter.into_iter()\n+            .chain(self.iter.map(IntoIterator::into_iter))\n+            .chain(self.backiter)\n+            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+    }\n+}\n+"}, {"sha": "f8d6bedeace255c25d61aaf70caab4f7bc887201", "filename": "src/libcore/iter/adapters/mod.rs", "status": "added", "additions": 2044, "deletions": 0, "changes": 2044, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,2044 @@\n+use cmp;\n+use fmt;\n+use ops::Try;\n+use usize;\n+use intrinsics;\n+use super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n+use super::LoopState;\n+\n+mod chain;\n+mod flatten;\n+mod zip;\n+\n+pub use self::chain::Chain;\n+pub use self::flatten::{FlatMap, Flatten};\n+pub use self::zip::Zip;\n+pub(crate) use self::zip::TrustedRandomAccess;\n+\n+/// A double-ended iterator with the direction inverted.\n+///\n+/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`rev`]: trait.Iterator.html#method.rev\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Rev<T> {\n+    iter: T\n+}\n+impl<T> Rev<T> {\n+    pub(super) fn new(iter: T) -> Rev<T> {\n+        Rev { iter }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth_back(n) }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.iter.try_rfold(init, f)\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, f)\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+        where P: FnMut(&Self::Item) -> bool\n+    {\n+        self.iter.rfind(predicate)\n+    }\n+\n+    #[inline]\n+    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n+        P: FnMut(Self::Item) -> bool\n+    {\n+        self.iter.position(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth(n) }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.iter.try_fold(init, f)\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, f)\n+    }\n+\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+        where P: FnMut(&Self::Item) -> bool\n+    {\n+        self.iter.find(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Rev<I>\n+    where I: ExactSizeIterator + DoubleEndedIterator\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Rev<I>\n+    where I: FusedIterator + DoubleEndedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Rev<I>\n+    where I: TrustedLen + DoubleEndedIterator {}\n+\n+/// An iterator that copies the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`copied`]: trait.Iterator.html#method.copied\n+/// [`Iterator`]: trait.Iterator.html\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Copied<I> {\n+    it: I,\n+}\n+impl<I> Copied<I> {\n+    pub(super) fn new(it: I) -> Copied<I> {\n+        Copied { it }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> Iterator for Copied<I>\n+    where I: Iterator<Item=&'a T>, T: Copy\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().copied()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_fold(init, move |acc, &elt| f(acc, elt))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, move |acc, &elt| f(acc, elt))\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n+    where I: DoubleEndedIterator<Item=&'a T>, T: Copy\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().copied()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_rfold(init, move |acc, &elt| f(acc, elt))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, move |acc, &elt| f(acc, elt))\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n+    where I: ExactSizeIterator<Item=&'a T>, T: Copy\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> FusedIterator for Copied<I>\n+    where I: FusedIterator<Item=&'a T>, T: Copy\n+{}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Copied<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        *self.it.get_unchecked(i)\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n+    where I: TrustedLen<Item=&'a T>,\n+          T: Copy\n+{}\n+\n+/// An iterator that clones the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cloned`]: trait.Iterator.html#method.cloned\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Cloned<I> {\n+    it: I,\n+}\n+impl<I> Cloned<I> {\n+    pub(super) fn new(it: I) -> Cloned<I> {\n+        Cloned { it }\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+    where I: Iterator<Item=&'a T>, T: Clone\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().cloned()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_fold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n+    where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().cloned()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n+    where I: ExactSizeIterator<Item=&'a T>, T: Clone\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n+    where I: FusedIterator<Item=&'a T>, T: Clone\n+{}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n+{\n+    default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        self.it.get_unchecked(i).clone()\n+    }\n+\n+    #[inline]\n+    default fn may_have_side_effect() -> bool { true }\n+}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        *self.it.get_unchecked(i)\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n+    where I: TrustedLen<Item=&'a T>,\n+          T: Clone\n+{}\n+\n+/// An iterator that repeats endlessly.\n+///\n+/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cycle`]: trait.Iterator.html#method.cycle\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Cycle<I> {\n+    orig: I,\n+    iter: I,\n+}\n+impl<I: Clone> Cycle<I> {\n+    pub(super) fn new(iter: I) -> Cycle<I> {\n+        Cycle { orig: iter.clone(), iter }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        match self.iter.next() {\n+            None => { self.iter = self.orig.clone(); self.iter.next() }\n+            y => y\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // the cycle iterator is either empty or infinite\n+        match self.orig.size_hint() {\n+            sz @ (0, Some(0)) => sz,\n+            (0, _) => (0, None),\n+            _ => (usize::MAX, None)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n+\n+/// An iterator for stepping iterators by a custom amount.\n+///\n+/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n+/// its documentation for more.\n+///\n+/// [`step_by`]: trait.Iterator.html#method.step_by\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+#[derive(Clone, Debug)]\n+pub struct StepBy<I> {\n+    iter: I,\n+    step: usize,\n+    first_take: bool,\n+}\n+impl<I> StepBy<I> {\n+    pub(super) fn new(iter: I, step: usize) -> StepBy<I> {\n+        assert!(step != 0);\n+        StepBy { iter, step: step - 1, first_take: true }\n+    }\n+}\n+\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> Iterator for StepBy<I> where I: Iterator {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            self.iter.next()\n+        } else {\n+            self.iter.nth(self.step)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let inner_hint = self.iter.size_hint();\n+\n+        if self.first_take {\n+            let f = |n| if n == 0 { 0 } else { 1 + (n-1)/(self.step+1) };\n+            (f(inner_hint.0), inner_hint.1.map(f))\n+        } else {\n+            let f = |n| n / (self.step+1);\n+            (f(inner_hint.0), inner_hint.1.map(f))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            let first = self.iter.next();\n+            if n == 0 {\n+                return first;\n+            }\n+            n -= 1;\n+        }\n+        // n and self.step are indices, we need to add 1 to get the amount of elements\n+        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n+        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n+        let mut step = self.step + 1;\n+        // n + 1 could overflow\n+        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n+        if n == usize::MAX {\n+            self.iter.nth(step - 1);\n+        } else {\n+            n += 1;\n+        }\n+\n+        // overflow handling\n+        loop {\n+            let mul = n.checked_mul(step);\n+            if unsafe { intrinsics::likely(mul.is_some()) } {\n+                return self.iter.nth(mul.unwrap() - 1);\n+            }\n+            let div_n = usize::MAX / n;\n+            let div_step = usize::MAX / step;\n+            let nth_n = div_n * n;\n+            let nth_step = div_step * step;\n+            let nth = if nth_n > nth_step {\n+                step -= div_n;\n+                nth_n\n+            } else {\n+                n -= div_step;\n+                nth_step\n+            };\n+            self.iter.nth(nth - 1);\n+        }\n+    }\n+}\n+\n+// StepBy can only make the iterator shorter, so the len will still fit.\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n+\n+/// An iterator that maps the values of `iter` with `f`.\n+///\n+/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map`]: trait.Iterator.html#method.map\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Notes about side effects\n+///\n+/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n+/// you can also [`map`] backwards:\n+///\n+/// ```rust\n+/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n+///\n+/// assert_eq!(v, [4, 3, 2]);\n+/// ```\n+///\n+/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+///\n+/// But if your closure has state, iterating backwards may act in a way you do\n+/// not expect. Let's go through an example. First, in the forward direction:\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) }) {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+///\n+/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n+///\n+/// Now consider this twist where we add a call to `rev`. This version will\n+/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n+/// but the values of the counter still go in order. This is because `map()` is\n+/// still being called lazily on each item, but we are popping items off the\n+/// back of the vector now, instead of shifting them from the front.\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) })\n+///                                .rev() {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Map<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> Map<I, F> {\n+    pub(super) fn new(iter: I, f: F) -> Map<I, F> {\n+        Map { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Map\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+\n+    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+        where G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        self.iter.next_back().map(&mut self.f)\n+    }\n+\n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+\n+    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+        where G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n+    where F: FnMut(I::Item) -> B\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n+    where F: FnMut(I::Item) -> B {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<B, I, F> TrustedLen for Map<I, F>\n+    where I: TrustedLen,\n+          F: FnMut(I::Item) -> B {}\n+\n+#[doc(hidden)]\n+unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n+    where I: TrustedRandomAccess,\n+          F: FnMut(I::Item) -> B,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        (self.f)(self.iter.get_unchecked(i))\n+    }\n+    #[inline]\n+    fn may_have_side_effect() -> bool { true }\n+}\n+\n+/// An iterator that filters the elements of `iter` with `predicate`.\n+///\n+/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter`]: trait.Iterator.html#method.filter\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Filter<I, P> {\n+    iter: I,\n+    predicate: P,\n+}\n+impl<I, P> Filter<I, P> {\n+    pub(super) fn new(iter: I, predicate: P) -> Filter<I, P> {\n+        Filter { iter, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Filter\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        for x in &mut self.iter {\n+            if (self.predicate)(&x) {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    // this special case allows the compiler to make `.filter(_).count()`\n+    // branchless. Barring perfect branch prediction (which is unattainable in\n+    // the general case), this will be much faster in >90% of cases (containing\n+    // virtually all real workloads) and only a tiny bit slower in the rest.\n+    //\n+    // Having this specialization thus allows us to write `.filter(p).count()`\n+    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n+    // less readable and also less backwards-compatible to Rust before 1.10.\n+    //\n+    // Using the branchless version will also simplify the LLVM byte code, thus\n+    // leaving more budget for LLVM optimizations.\n+    #[inline]\n+    fn count(mut self) -> usize {\n+        let mut count = 0;\n+        for x in &mut self.iter {\n+            count += (self.predicate)(&x) as usize;\n+        }\n+        count\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let predicate = &mut self.predicate;\n+        self.iter.try_fold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            Try::from_ok(acc)\n+        })\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.fold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n+    where P: FnMut(&I::Item) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        for x in self.iter.by_ref().rev() {\n+            if (self.predicate)(&x) {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let predicate = &mut self.predicate;\n+        self.iter.try_rfold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            Try::from_ok(acc)\n+        })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, P> FusedIterator for Filter<I, P>\n+    where P: FnMut(&I::Item) -> bool {}\n+\n+/// An iterator that uses `f` to both filter and map elements from `iter`.\n+///\n+/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter_map`]: trait.Iterator.html#method.filter_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct FilterMap<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> FilterMap<I, F> {\n+    pub(super) fn new(iter: I, f: F) -> FilterMap<I, F> {\n+        FilterMap { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FilterMap\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        for x in self.iter.by_ref() {\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => Try::from_ok(acc),\n+        })\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        for x in self.iter.by_ref().rev() {\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => Try::from_ok(acc),\n+        })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B> {}\n+\n+/// An iterator that yields the current count and the element during iteration.\n+///\n+/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`enumerate`]: trait.Iterator.html#method.enumerate\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Enumerate<I> {\n+    iter: I,\n+    count: usize,\n+}\n+impl<I> Enumerate<I> {\n+    pub(super) fn new(iter: I) -> Enumerate<I> {\n+        Enumerate { iter, count: 0 }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Enumerate<I> where I: Iterator {\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Might panic if the index of the element overflows a `usize`.\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.iter.next().map(|a| {\n+            let ret = (self.count, a);\n+            // Possible undefined overflow.\n+            self.count += 1;\n+            ret\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n+        self.iter.nth(n).map(|a| {\n+            let i = self.count + n;\n+            self.count = i + 1;\n+            (i, a)\n+        })\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let count = &mut self.count;\n+        self.iter.try_fold(init, move |acc, item| {\n+            let acc = fold(acc, (*count, item));\n+            *count += 1;\n+            acc\n+        })\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut count = self.count;\n+        self.iter.fold(init, move |acc, item| {\n+            let acc = fold(acc, (count, item));\n+            count += 1;\n+            acc\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Enumerate<I> where\n+    I: ExactSizeIterator + DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.iter.next_back().map(|a| {\n+            let len = self.iter.len();\n+            // Can safely add, `ExactSizeIterator` promises that the number of\n+            // elements fits into a `usize`.\n+            (self.count + len, a)\n+        })\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        let mut count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, move |acc, item| {\n+            count -= 1;\n+            fold(acc, (count, item))\n+        })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        let mut count = self.count + self.iter.len();\n+        self.iter.rfold(init, move |acc, item| {\n+            count -= 1;\n+            fold(acc, (count, item))\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[doc(hidden)]\n+unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n+    where I: TrustedRandomAccess\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n+        (self.count + i, self.iter.get_unchecked(i))\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Enumerate<I>\n+    where I: TrustedLen,\n+{}\n+\n+\n+/// An iterator with a `peek()` that returns an optional reference to the next\n+/// element.\n+///\n+/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`peekable`]: trait.Iterator.html#method.peekable\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Peekable<I: Iterator> {\n+    iter: I,\n+    /// Remember a peeked value, even if it was None.\n+    peeked: Option<Option<I::Item>>,\n+}\n+impl<I: Iterator> Peekable<I> {\n+    pub(super) fn new(iter: I) -> Peekable<I> {\n+        Peekable { iter, peeked: None }\n+    }\n+}\n+\n+// Peekable must remember if a None has been seen in the `.peek()` method.\n+// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n+// underlying iterator at most once. This does not by itself make the iterator\n+// fused.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> Iterator for Peekable<I> {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(v) => v,\n+            None => self.iter.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn count(mut self) -> usize {\n+        match self.peeked.take() {\n+            Some(None) => 0,\n+            Some(Some(_)) => 1 + self.iter.count(),\n+            None => self.iter.count(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(None) => None,\n+            Some(v @ Some(_)) if n == 0 => v,\n+            Some(Some(_)) => self.iter.nth(n - 1),\n+            None => self.iter.nth(n),\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        let peek_opt = match self.peeked.take() {\n+            Some(None) => return None,\n+            Some(v) => v,\n+            None => None,\n+        };\n+        self.iter.last().or(peek_opt)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let peek_len = match self.peeked {\n+            Some(None) => return (0, Some(0)),\n+            Some(Some(_)) => 1,\n+            None => 0,\n+        };\n+        let (lo, hi) = self.iter.size_hint();\n+        let lo = lo.saturating_add(peek_len);\n+        let hi = hi.and_then(|x| x.checked_add(peek_len));\n+        (lo, hi)\n+    }\n+\n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        let acc = match self.peeked.take() {\n+            Some(None) => return Try::from_ok(init),\n+            Some(Some(v)) => f(init, v)?,\n+            None => init,\n+        };\n+        self.iter.try_fold(acc, f)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let acc = match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => fold(init, v),\n+            None => init,\n+        };\n+        self.iter.fold(acc, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n+\n+impl<I: Iterator> Peekable<I> {\n+    /// Returns a reference to the next() value without advancing the iterator.\n+    ///\n+    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n+    /// But if the iteration is over, `None` is returned.\n+    ///\n+    /// [`next`]: trait.Iterator.html#tymethod.next\n+    ///\n+    /// Because `peek()` returns a reference, and many iterators iterate over\n+    /// references, there can be a possibly confusing situation where the\n+    /// return value is a double reference. You can see this effect in the\n+    /// examples below.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // The iterator does not advance even if we `peek` multiple times\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // After the iterator is finished, so is `peek()`\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&mut self) -> Option<&I::Item> {\n+        let iter = &mut self.iter;\n+        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n+    }\n+}\n+\n+/// An iterator that rejects elements while `predicate` is true.\n+///\n+/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip_while`]: trait.Iterator.html#method.skip_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct SkipWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+impl<I, P> SkipWhile<I, P> {\n+    pub(super) fn new(iter: I, predicate: P) -> SkipWhile<I, P> {\n+        SkipWhile { iter, flag: false, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SkipWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        let flag = &mut self.flag;\n+        let pred = &mut self.predicate;\n+        self.iter.find(move |x| {\n+            if *flag || !pred(x) {\n+                *flag = true;\n+                true\n+            } else {\n+                false\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v)?,\n+                None => return Try::from_ok(init),\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v),\n+                None => return init,\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for SkipWhile<I, P>\n+    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n+\n+/// An iterator that only accepts elements while `predicate` is true.\n+///\n+/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take_while`]: trait.Iterator.html#method.take_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct TakeWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+impl<I, P> TakeWhile<I, P> {\n+    pub(super) fn new(iter: I, predicate: P) -> TakeWhile<I, P> {\n+        TakeWhile { iter, flag: false, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"TakeWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.flag {\n+            None\n+        } else {\n+            self.iter.next().and_then(|x| {\n+                if (self.predicate)(&x) {\n+                    Some(x)\n+                } else {\n+                    self.flag = true;\n+                    None\n+                }\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.flag {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper) // can't know a lower bound, due to the predicate\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.flag {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, move |acc, x|{\n+                if p(&x) {\n+                    LoopState::from_try(fold(acc, x))\n+                } else {\n+                    *flag = true;\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            }).into_try()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for TakeWhile<I, P>\n+    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n+\n+/// An iterator that skips over `n` elements of `iter`.\n+///\n+/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip`]: trait.Iterator.html#method.skip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Skip<I> {\n+    iter: I,\n+    n: usize\n+}\n+impl<I> Skip<I> {\n+    pub(super) fn new(iter: I, n: usize) -> Skip<I> {\n+        Skip { iter, n }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Skip<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.next()\n+        } else {\n+            let old_n = self.n;\n+            self.n = 0;\n+            self.iter.nth(old_n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        // Can't just add n + self.n due to overflow.\n+        if self.n == 0 {\n+            self.iter.nth(n)\n+        } else {\n+            let to_skip = self.n;\n+            self.n = 0;\n+            // nth(n) skips n+1\n+            if self.iter.nth(to_skip-1).is_none() {\n+                return None;\n+            }\n+            self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count().saturating_sub(self.n)\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.last()\n+        } else {\n+            let next = self.next();\n+            if next.is_some() {\n+                // recurse. n should be 0.\n+                self.last().or(next)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = lower.saturating_sub(self.n);\n+        let upper = upper.map(|x| x.saturating_sub(self.n));\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let n = self.n;\n+        self.n = 0;\n+        if n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(n - 1).is_none() {\n+                return Try::from_ok(init);\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return init;\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n+impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.len() > 0 {\n+            self.iter.next_back()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut n = self.len();\n+        if n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            self.iter.try_rfold(init, move |acc, x| {\n+                n -= 1;\n+                let r = fold(acc, x);\n+                if n == 0 { LoopState::Break(r) }\n+                else { LoopState::from_try(r) }\n+            }).into_try()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n+\n+/// An iterator that only iterates over the first `n` iterations of `iter`.\n+///\n+/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take`]: trait.Iterator.html#method.take\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Take<I> {\n+    pub(super) iter: I,\n+    pub(super) n: usize\n+}\n+impl<I> Take<I> {\n+    pub(super) fn new(iter: I, n: usize) -> Take<I> {\n+        Take { iter, n }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Take<I> where I: Iterator{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.n != 0 {\n+            self.n -= 1;\n+            self.iter.next()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.n > n {\n+            self.n -= n + 1;\n+            self.iter.nth(n)\n+        } else {\n+            if self.n > 0 {\n+                self.iter.nth(self.n - 1);\n+                self.n = 0;\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.n == 0 {\n+            return (0, Some(0));\n+        }\n+\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = cmp::min(lower, self.n);\n+\n+        let upper = match upper {\n+            Some(x) if x < self.n => Some(x),\n+            _ => Some(self.n)\n+        };\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, move |acc, x| {\n+                *n -= 1;\n+                let r = fold(acc, x);\n+                if *n == 0 { LoopState::Break(r) }\n+                else { LoopState::from_try(r) }\n+            }).into_try()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}\n+\n+/// An iterator to maintain state while iterating another iterator.\n+///\n+/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`scan`]: trait.Iterator.html#method.scan\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Scan<I, St, F> {\n+    iter: I,\n+    f: F,\n+    state: St,\n+}\n+impl<I, St, F> Scan<I, St, F> {\n+    pub(super) fn new(iter: I, state: St, f: F) -> Scan<I, St, F> {\n+        Scan { iter, state, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Scan\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"state\", &self.state)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I, St, F> Iterator for Scan<I, St, F> where\n+    I: Iterator,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the scan function\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let state = &mut self.state;\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, x| {\n+            match f(state, x) {\n+                None => LoopState::Break(Try::from_ok(acc)),\n+                Some(x) => LoopState::from_try(fold(acc, x)),\n+            }\n+        }).into_try()\n+    }\n+}\n+\n+/// An iterator that yields `None` forever after the underlying iterator\n+/// yields `None` once.\n+///\n+/// This `struct` is created by the [`fuse`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`fuse`]: trait.Iterator.html#method.fuse\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Fuse<I> {\n+    iter: I,\n+    done: bool\n+}\n+impl<I> Fuse<I> {\n+    pub(super) fn new(iter: I) -> Fuse<I> {\n+        Fuse { iter, done: false }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Fuse<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let next = self.iter.next();\n+            self.done = next.is_none();\n+            next\n+        }\n+    }\n+\n+    #[inline]\n+    default fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let nth = self.iter.nth(n);\n+            self.done = nth.is_none();\n+            nth\n+        }\n+    }\n+\n+    #[inline]\n+    default fn last(self) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            self.iter.last()\n+        }\n+    }\n+\n+    #[inline]\n+    default fn count(self) -> usize {\n+        if self.done {\n+            0\n+        } else {\n+            self.iter.count()\n+        }\n+    }\n+\n+    #[inline]\n+    default fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.done {\n+            (0, Some(0))\n+        } else {\n+            self.iter.size_hint()\n+        }\n+    }\n+\n+    #[inline]\n+    default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.done {\n+            Try::from_ok(init)\n+        } else {\n+            let acc = self.iter.try_fold(init, fold)?;\n+            self.done = true;\n+            Try::from_ok(acc)\n+        }\n+    }\n+\n+    #[inline]\n+    default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.fold(init, fold)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let next = self.iter.next_back();\n+            self.done = next.is_none();\n+            next\n+        }\n+    }\n+\n+    #[inline]\n+    default fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.done {\n+            Try::from_ok(init)\n+        } else {\n+            let acc = self.iter.try_rfold(init, fold)?;\n+            self.done = true;\n+            Try::from_ok(acc)\n+        }\n+    }\n+\n+    #[inline]\n+    default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.rfold(init, fold)\n+        }\n+    }\n+}\n+\n+unsafe impl<I> TrustedRandomAccess for Fuse<I>\n+    where I: TrustedRandomAccess,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n+        self.iter.get_unchecked(i)\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> Iterator for Fuse<I> where I: FusedIterator {\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        self.iter.last()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I>\n+    where I: DoubleEndedIterator + FusedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next_back()\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.iter.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, fold)\n+    }\n+}\n+\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+/// An iterator that calls a function with a reference to each element before\n+/// yielding it.\n+///\n+/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`inspect`]: trait.Iterator.html#method.inspect\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Inspect<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> Inspect<I, F> {\n+    pub(super) fn new(iter: I, f: F) -> Inspect<I, F> {\n+        Inspect { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Inspect\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n+    #[inline]\n+    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n+        if let Some(ref a) = elt {\n+            (self.f)(a);\n+        }\n+\n+        elt\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next_back();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item)\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item) {}"}, {"sha": "3548d0e282602ddcacd39be6541c046e3d749136", "filename": "src/libcore/iter/adapters/zip.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,282 @@\n+use cmp;\n+use super::super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n+\n+/// An iterator that iterates two other iterators simultaneously.\n+///\n+/// This `struct` is created by the [`zip`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`zip`]: trait.Iterator.html#method.zip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Zip<A, B> {\n+    a: A,\n+    b: B,\n+    // index and len are only used by the specialized version of zip\n+    index: usize,\n+    len: usize,\n+}\n+impl<A: Iterator, B: Iterator> Zip<A, B> {\n+    pub(in super::super) fn new(a: A, b: B) -> Zip<A, B> {\n+        ZipImpl::new(a, b)\n+    }\n+    fn super_nth(&mut self, mut n: usize) -> Option<(A::Item, B::Item)> {\n+        while let Some(x) = Iterator::next(self) {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n+{\n+    type Item = (A::Item, B::Item);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        ZipImpl::next(self)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        ZipImpl::size_hint(self)\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        ZipImpl::nth(self, n)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Zip<A, B> where\n+    A: DoubleEndedIterator + ExactSizeIterator,\n+    B: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n+        ZipImpl::next_back(self)\n+    }\n+}\n+\n+// Zip specialization trait\n+#[doc(hidden)]\n+trait ZipImpl<A, B> {\n+    type Item;\n+    fn new(a: A, b: B) -> Self;\n+    fn next(&mut self) -> Option<Self::Item>;\n+    fn size_hint(&self) -> (usize, Option<usize>);\n+    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n+    fn next_back(&mut self) -> Option<Self::Item>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator;\n+}\n+\n+// General Zip impl\n+#[doc(hidden)]\n+impl<A, B> ZipImpl<A, B> for Zip<A, B>\n+    where A: Iterator, B: Iterator\n+{\n+    type Item = (A::Item, B::Item);\n+    default fn new(a: A, b: B) -> Self {\n+        Zip {\n+            a,\n+            b,\n+            index: 0, // unused\n+            len: 0, // unused\n+        }\n+    }\n+\n+    #[inline]\n+    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        self.a.next().and_then(|x| {\n+            self.b.next().and_then(|y| {\n+                Some((x, y))\n+            })\n+        })\n+    }\n+\n+    #[inline]\n+    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.super_nth(n)\n+    }\n+\n+    #[inline]\n+    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator\n+    {\n+        let a_sz = self.a.len();\n+        let b_sz = self.b.len();\n+        if a_sz != b_sz {\n+            // Adjust a, b to equal length\n+            if a_sz > b_sz {\n+                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n+            } else {\n+                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n+            }\n+        }\n+        match (self.a.next_back(), self.b.next_back()) {\n+            (Some(x), Some(y)) => Some((x, y)),\n+            (None, None) => None,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    #[inline]\n+    default fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = cmp::min(a_lower, b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n+            (Some(x), None) => Some(x),\n+            (None, Some(y)) => Some(y),\n+            (None, None) => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[doc(hidden)]\n+impl<A, B> ZipImpl<A, B> for Zip<A, B>\n+    where A: TrustedRandomAccess, B: TrustedRandomAccess\n+{\n+    fn new(a: A, b: B) -> Self {\n+        let len = cmp::min(a.len(), b.len());\n+        Zip {\n+            a,\n+            b,\n+            index: 0,\n+            len,\n+        }\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        if self.index < self.len {\n+            let i = self.index;\n+            self.index += 1;\n+            unsafe {\n+                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n+            }\n+        } else if A::may_have_side_effect() && self.index < self.a.len() {\n+            // match the base implementation's potential side effects\n+            unsafe {\n+                self.a.get_unchecked(self.index);\n+            }\n+            self.index += 1;\n+            None\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.len - self.index;\n+        (len, Some(len))\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let delta = cmp::min(n, self.len - self.index);\n+        let end = self.index + delta;\n+        while self.index < end {\n+            let i = self.index;\n+            self.index += 1;\n+            if A::may_have_side_effect() {\n+                unsafe { self.a.get_unchecked(i); }\n+            }\n+            if B::may_have_side_effect() {\n+                unsafe { self.b.get_unchecked(i); }\n+            }\n+        }\n+\n+        self.super_nth(n - delta)\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator\n+    {\n+        // Adjust a, b to equal length\n+        if A::may_have_side_effect() {\n+            let sz = self.a.len();\n+            if sz > self.len {\n+                for _ in 0..sz - cmp::max(self.len, self.index) {\n+                    self.a.next_back();\n+                }\n+            }\n+        }\n+        if B::may_have_side_effect() {\n+            let sz = self.b.len();\n+            if sz > self.len {\n+                for _ in 0..sz - self.len {\n+                    self.b.next_back();\n+                }\n+            }\n+        }\n+        if self.index < self.len {\n+            self.len -= 1;\n+            let i = self.len;\n+            unsafe {\n+                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> ExactSizeIterator for Zip<A, B>\n+    where A: ExactSizeIterator, B: ExactSizeIterator {}\n+\n+#[doc(hidden)]\n+unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n+    where A: TrustedRandomAccess,\n+          B: TrustedRandomAccess,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n+        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        A::may_have_side_effect() || B::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<A, B> FusedIterator for Zip<A, B>\n+    where A: FusedIterator, B: FusedIterator, {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, B> TrustedLen for Zip<A, B>\n+    where A: TrustedLen, B: TrustedLen,\n+{}\n+\n+/// An iterator whose items are random-accessible efficiently\n+///\n+/// # Safety\n+///\n+/// The iterator's .len() and size_hint() must be exact.\n+/// `.len()` must be cheap to call.\n+///\n+/// .get_unchecked() must return distinct mutable references for distinct\n+/// indices (if applicable), and must return a valid reference if index is in\n+/// 0..self.len().\n+pub(crate) unsafe trait TrustedRandomAccess : ExactSizeIterator {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n+    /// Returns `true` if getting an iterator element may have\n+    /// side effects. Remember to take inner iterators into account.\n+    fn may_have_side_effect() -> bool;\n+}"}, {"sha": "b6bb5f01b2d299dd72b7dae3d5b23a02ad2f70b6", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 19, "deletions": 2771, "changes": 2790, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -306,15 +306,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use cmp;\n-use fmt;\n-use iter_private::TrustedRandomAccess;\n use ops::Try;\n-use usize;\n-use intrinsics;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::iterator::Iterator;\n+pub use self::traits::Iterator;\n \n #[unstable(feature = \"step_trait\",\n            reason = \"likely to be replaced by finer-grained traits\",\n@@ -343,10 +338,27 @@ pub use self::traits::FusedIterator;\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub use self::traits::TrustedLen;\n \n-mod iterator;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::adapters::{Rev, Cycle, Chain, Zip, Map, Filter, FilterMap, Enumerate};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::adapters::{Peekable, SkipWhile, TakeWhile, Skip, Take, Scan, FlatMap};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::adapters::{Fuse, Inspect};\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+pub use self::adapters::Cloned;\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+pub use self::adapters::StepBy;\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+pub use self::adapters::Flatten;\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+pub use self::adapters::Copied;\n+\n+pub(crate) use self::adapters::TrustedRandomAccess;\n+\n mod range;\n mod sources;\n mod traits;\n+mod adapters;\n \n /// Used to make try_fold closures more like normal loops\n #[derive(PartialEq)]\n@@ -397,2767 +409,3 @@ impl<R: Try> LoopState<R::Ok, R> {\n         }\n     }\n }\n-\n-/// A double-ended iterator with the direction inverted.\n-///\n-/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`rev`]: trait.Iterator.html#method.rev\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Rev<T> {\n-    iter: T\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth_back(n) }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.iter.try_rfold(init, f)\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, f)\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n-        where P: FnMut(&Self::Item) -> bool\n-    {\n-        self.iter.rfind(predicate)\n-    }\n-\n-    #[inline]\n-    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n-        P: FnMut(Self::Item) -> bool\n-    {\n-        self.iter.position(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth(n) }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.iter.try_fold(init, f)\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, f)\n-    }\n-\n-    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n-        where P: FnMut(&Self::Item) -> bool\n-    {\n-        self.iter.find(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Rev<I>\n-    where I: ExactSizeIterator + DoubleEndedIterator\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Rev<I>\n-    where I: FusedIterator + DoubleEndedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Rev<I>\n-    where I: TrustedLen + DoubleEndedIterator {}\n-\n-/// An iterator that copies the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`copied`]: trait.Iterator.html#method.copied\n-/// [`Iterator`]: trait.Iterator.html\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Copied<I> {\n-    it: I,\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-impl<'a, I, T: 'a> Iterator for Copied<I>\n-    where I: Iterator<Item=&'a T>, T: Copy\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().copied()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.it.try_fold(init, move |acc, &elt| f(acc, elt))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.fold(init, move |acc, &elt| f(acc, elt))\n-    }\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n-    where I: DoubleEndedIterator<Item=&'a T>, T: Copy\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().copied()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.it.try_rfold(init, move |acc, &elt| f(acc, elt))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.rfold(init, move |acc, &elt| f(acc, elt))\n-    }\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n-    where I: ExactSizeIterator<Item=&'a T>, T: Copy\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-impl<'a, I, T: 'a> FusedIterator for Copied<I>\n-    where I: FusedIterator<Item=&'a T>, T: Copy\n-{}\n-\n-#[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Copied<I>\n-    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n-    }\n-\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n-    where I: TrustedLen<Item=&'a T>,\n-          T: Copy\n-{}\n-\n-/// An iterator that clones the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cloned`]: trait.Iterator.html#method.cloned\n-/// [`Iterator`]: trait.Iterator.html\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Cloned<I> {\n-    it: I,\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> Iterator for Cloned<I>\n-    where I: Iterator<Item=&'a T>, T: Clone\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().cloned()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.it.try_fold(init, move |acc, elt| f(acc, elt.clone()))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n-    where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().cloned()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.rfold(init, move |acc, elt| f(acc, elt.clone()))\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n-    where I: ExactSizeIterator<Item=&'a T>, T: Clone\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n-    where I: FusedIterator<Item=&'a T>, T: Clone\n-{}\n-\n-#[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n-    where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n-{\n-    default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        self.it.get_unchecked(i).clone()\n-    }\n-\n-    #[inline]\n-    default fn may_have_side_effect() -> bool { true }\n-}\n-\n-#[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n-    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n-    }\n-\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n-    where I: TrustedLen<Item=&'a T>,\n-          T: Clone\n-{}\n-\n-/// An iterator that repeats endlessly.\n-///\n-/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cycle`]: trait.Iterator.html#method.cycle\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Cycle<I> {\n-    orig: I,\n-    iter: I,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        match self.iter.next() {\n-            None => { self.iter = self.orig.clone(); self.iter.next() }\n-            y => y\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // the cycle iterator is either empty or infinite\n-        match self.orig.size_hint() {\n-            sz @ (0, Some(0)) => sz,\n-            (0, _) => (0, None),\n-            _ => (usize::MAX, None)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n-\n-/// An iterator for stepping iterators by a custom amount.\n-///\n-/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n-/// its documentation for more.\n-///\n-/// [`step_by`]: trait.Iterator.html#method.step_by\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-#[derive(Clone, Debug)]\n-pub struct StepBy<I> {\n-    iter: I,\n-    step: usize,\n-    first_take: bool,\n-}\n-\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> Iterator for StepBy<I> where I: Iterator {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            self.iter.next()\n-        } else {\n-            self.iter.nth(self.step)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let inner_hint = self.iter.size_hint();\n-\n-        if self.first_take {\n-            let f = |n| if n == 0 { 0 } else { 1 + (n-1)/(self.step+1) };\n-            (f(inner_hint.0), inner_hint.1.map(f))\n-        } else {\n-            let f = |n| n / (self.step+1);\n-            (f(inner_hint.0), inner_hint.1.map(f))\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            let first = self.iter.next();\n-            if n == 0 {\n-                return first;\n-            }\n-            n -= 1;\n-        }\n-        // n and self.step are indices, we need to add 1 to get the amount of elements\n-        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n-        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n-        let mut step = self.step + 1;\n-        // n + 1 could overflow\n-        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n-        if n == usize::MAX {\n-            self.iter.nth(step - 1);\n-        } else {\n-            n += 1;\n-        }\n-\n-        // overflow handling\n-        loop {\n-            let mul = n.checked_mul(step);\n-            if unsafe { intrinsics::likely(mul.is_some()) } {\n-                return self.iter.nth(mul.unwrap() - 1);\n-            }\n-            let div_n = usize::MAX / n;\n-            let div_step = usize::MAX / step;\n-            let nth_n = div_n * n;\n-            let nth_step = div_step * step;\n-            let nth = if nth_n > nth_step {\n-                step -= div_n;\n-                nth_n\n-            } else {\n-                n -= div_step;\n-                nth_step\n-            };\n-            self.iter.nth(nth - 1);\n-        }\n-    }\n-}\n-\n-// StepBy can only make the iterator shorter, so the len will still fit.\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n-\n-/// An iterator that strings two iterators together.\n-///\n-/// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`chain`]: trait.Iterator.html#method.chain\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Chain<A, B> {\n-    a: A,\n-    b: B,\n-    state: ChainState,\n-}\n-\n-// The iterator protocol specifies that iteration ends with the return value\n-// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n-// further calls return. The chain adaptor must account for this since it uses\n-// two subiterators.\n-//\n-//  It uses three states:\n-//\n-//  - Both: `a` and `b` are remaining\n-//  - Front: `a` remaining\n-//  - Back: `b` remaining\n-//\n-//  The fourth state (neither iterator is remaining) only occurs after Chain has\n-//  returned None once, so we don't need to store this state.\n-#[derive(Clone, Debug)]\n-enum ChainState {\n-    // both front and back iterator are remaining\n-    Both,\n-    // only front is remaining\n-    Front,\n-    // only back is remaining\n-    Back,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> Iterator for Chain<A, B> where\n-    A: Iterator,\n-    B: Iterator<Item = A::Item>\n-{\n-    type Item = A::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.a.next() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.next()\n-                }\n-            },\n-            ChainState::Front => self.a.next(),\n-            ChainState::Back => self.b.next(),\n-        }\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn count(self) -> usize {\n-        match self.state {\n-            ChainState::Both => self.a.count() + self.b.count(),\n-            ChainState::Front => self.a.count(),\n-            ChainState::Back => self.b.count(),\n-        }\n-    }\n-\n-    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n-        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.try_fold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n-                }\n-            }\n-            _ => { }\n-        }\n-        if let ChainState::Back = self.state {\n-            accum = self.b.try_fold(accum, &mut f)?;\n-        }\n-        Try::from_ok(accum)\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.fold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.fold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        accum\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                for x in self.a.by_ref() {\n-                    if n == 0 {\n-                        return Some(x)\n-                    }\n-                    n -= 1;\n-                }\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n-                }\n-            }\n-            ChainState::Back => {}\n-        }\n-        if let ChainState::Back = self.state {\n-            self.b.nth(n)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        match self.state {\n-            ChainState::Both => match self.a.find(&mut predicate) {\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.find(predicate)\n-                }\n-                v => v\n-            },\n-            ChainState::Front => self.a.find(predicate),\n-            ChainState::Back => self.b.find(predicate),\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => {\n-                // Must exhaust a before b.\n-                let a_last = self.a.last();\n-                let b_last = self.b.last();\n-                b_last.or(a_last)\n-            },\n-            ChainState::Front => self.a.last(),\n-            ChainState::Back => self.b.last()\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n-\n-        let lower = a_lower.saturating_add(b_lower);\n-\n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => x.checked_add(y),\n-            _ => None\n-        };\n-\n-        (lower, upper)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> DoubleEndedIterator for Chain<A, B> where\n-    A: DoubleEndedIterator,\n-    B: DoubleEndedIterator<Item=A::Item>,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.b.next_back() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Front;\n-                    self.a.next_back()\n-                }\n-            },\n-            ChainState::Front => self.a.next_back(),\n-            ChainState::Back => self.b.next_back(),\n-        }\n-    }\n-\n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n-        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.try_rfold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Front;\n-                }\n-            }\n-            _ => { }\n-        }\n-        if let ChainState::Front = self.state {\n-            accum = self.a.try_rfold(accum, &mut f)?;\n-        }\n-        Try::from_ok(accum)\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.rfold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.rfold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        accum\n-    }\n-\n-}\n-\n-// Note: *both* must be fused to handle double-ended iterators.\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<A, B> FusedIterator for Chain<A, B>\n-    where A: FusedIterator,\n-          B: FusedIterator<Item=A::Item>,\n-{}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A, B> TrustedLen for Chain<A, B>\n-    where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n-{}\n-\n-/// An iterator that iterates two other iterators simultaneously.\n-///\n-/// This `struct` is created by the [`zip`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`zip`]: trait.Iterator.html#method.zip\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Zip<A, B> {\n-    a: A,\n-    b: B,\n-    // index and len are only used by the specialized version of zip\n-    index: usize,\n-    len: usize,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n-{\n-    type Item = (A::Item, B::Item);\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        ZipImpl::next(self)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        ZipImpl::size_hint(self)\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        ZipImpl::nth(self, n)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> DoubleEndedIterator for Zip<A, B> where\n-    A: DoubleEndedIterator + ExactSizeIterator,\n-    B: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n-        ZipImpl::next_back(self)\n-    }\n-}\n-\n-// Zip specialization trait\n-#[doc(hidden)]\n-trait ZipImpl<A, B> {\n-    type Item;\n-    fn new(a: A, b: B) -> Self;\n-    fn next(&mut self) -> Option<Self::Item>;\n-    fn size_hint(&self) -> (usize, Option<usize>);\n-    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n-    fn super_nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        while let Some(x) = self.next() {\n-            if n == 0 { return Some(x) }\n-            n -= 1;\n-        }\n-        None\n-    }\n-    fn next_back(&mut self) -> Option<Self::Item>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator;\n-}\n-\n-// General Zip impl\n-#[doc(hidden)]\n-impl<A, B> ZipImpl<A, B> for Zip<A, B>\n-    where A: Iterator, B: Iterator\n-{\n-    type Item = (A::Item, B::Item);\n-    default fn new(a: A, b: B) -> Self {\n-        Zip {\n-            a,\n-            b,\n-            index: 0, // unused\n-            len: 0, // unused\n-        }\n-    }\n-\n-    #[inline]\n-    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        self.a.next().and_then(|x| {\n-            self.b.next().and_then(|y| {\n-                Some((x, y))\n-            })\n-        })\n-    }\n-\n-    #[inline]\n-    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        self.super_nth(n)\n-    }\n-\n-    #[inline]\n-    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator\n-    {\n-        let a_sz = self.a.len();\n-        let b_sz = self.b.len();\n-        if a_sz != b_sz {\n-            // Adjust a, b to equal length\n-            if a_sz > b_sz {\n-                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n-            } else {\n-                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n-            }\n-        }\n-        match (self.a.next_back(), self.b.next_back()) {\n-            (Some(x), Some(y)) => Some((x, y)),\n-            (None, None) => None,\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    #[inline]\n-    default fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n-\n-        let lower = cmp::min(a_lower, b_lower);\n-\n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n-            (Some(x), None) => Some(x),\n-            (None, Some(y)) => Some(y),\n-            (None, None) => None\n-        };\n-\n-        (lower, upper)\n-    }\n-}\n-\n-#[doc(hidden)]\n-impl<A, B> ZipImpl<A, B> for Zip<A, B>\n-    where A: TrustedRandomAccess, B: TrustedRandomAccess\n-{\n-    fn new(a: A, b: B) -> Self {\n-        let len = cmp::min(a.len(), b.len());\n-        Zip {\n-            a,\n-            b,\n-            index: 0,\n-            len,\n-        }\n-    }\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        if self.index < self.len {\n-            let i = self.index;\n-            self.index += 1;\n-            unsafe {\n-                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n-            }\n-        } else if A::may_have_side_effect() && self.index < self.a.len() {\n-            // match the base implementation's potential side effects\n-            unsafe {\n-                self.a.get_unchecked(self.index);\n-            }\n-            self.index += 1;\n-            None\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.len - self.index;\n-        (len, Some(len))\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        let delta = cmp::min(n, self.len - self.index);\n-        let end = self.index + delta;\n-        while self.index < end {\n-            let i = self.index;\n-            self.index += 1;\n-            if A::may_have_side_effect() {\n-                unsafe { self.a.get_unchecked(i); }\n-            }\n-            if B::may_have_side_effect() {\n-                unsafe { self.b.get_unchecked(i); }\n-            }\n-        }\n-\n-        self.super_nth(n - delta)\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator\n-    {\n-        // Adjust a, b to equal length\n-        if A::may_have_side_effect() {\n-            let sz = self.a.len();\n-            if sz > self.len {\n-                for _ in 0..sz - cmp::max(self.len, self.index) {\n-                    self.a.next_back();\n-                }\n-            }\n-        }\n-        if B::may_have_side_effect() {\n-            let sz = self.b.len();\n-            if sz > self.len {\n-                for _ in 0..sz - self.len {\n-                    self.b.next_back();\n-                }\n-            }\n-        }\n-        if self.index < self.len {\n-            self.len -= 1;\n-            let i = self.len;\n-            unsafe {\n-                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> ExactSizeIterator for Zip<A, B>\n-    where A: ExactSizeIterator, B: ExactSizeIterator {}\n-\n-#[doc(hidden)]\n-unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n-    where A: TrustedRandomAccess,\n-          B: TrustedRandomAccess,\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n-        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n-    }\n-\n-    fn may_have_side_effect() -> bool {\n-        A::may_have_side_effect() || B::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<A, B> FusedIterator for Zip<A, B>\n-    where A: FusedIterator, B: FusedIterator, {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A, B> TrustedLen for Zip<A, B>\n-    where A: TrustedLen, B: TrustedLen,\n-{}\n-\n-/// An iterator that maps the values of `iter` with `f`.\n-///\n-/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`map`]: trait.Iterator.html#method.map\n-/// [`Iterator`]: trait.Iterator.html\n-///\n-/// # Notes about side effects\n-///\n-/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n-/// you can also [`map`] backwards:\n-///\n-/// ```rust\n-/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n-///\n-/// assert_eq!(v, [4, 3, 2]);\n-/// ```\n-///\n-/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n-///\n-/// But if your closure has state, iterating backwards may act in a way you do\n-/// not expect. Let's go through an example. First, in the forward direction:\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) }) {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-///\n-/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n-///\n-/// Now consider this twist where we add a call to `rev`. This version will\n-/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n-/// but the values of the counter still go in order. This is because `map()` is\n-/// still being called lazily on each item, but we are popping items off the\n-/// back of the vector now, instead of shifting them from the front.\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) })\n-///                                .rev() {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Map<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Map\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.next().map(&mut self.f)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    fn try_fold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n-        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, elt| g(acc, f(elt)))\n-    }\n-\n-    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n-        where G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n-    F: FnMut(I::Item) -> B,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        self.iter.next_back().map(&mut self.f)\n-    }\n-\n-    fn try_rfold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n-        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, elt| g(acc, f(elt)))\n-    }\n-\n-    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n-        where G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, elt| g(acc, f(elt)))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n-    where F: FnMut(I::Item) -> B\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n-    where F: FnMut(I::Item) -> B {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<B, I, F> TrustedLen for Map<I, F>\n-    where I: TrustedLen,\n-          F: FnMut(I::Item) -> B {}\n-\n-#[doc(hidden)]\n-unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n-    where I: TrustedRandomAccess,\n-          F: FnMut(I::Item) -> B,\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        (self.f)(self.iter.get_unchecked(i))\n-    }\n-    #[inline]\n-    fn may_have_side_effect() -> bool { true }\n-}\n-\n-/// An iterator that filters the elements of `iter` with `predicate`.\n-///\n-/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter`]: trait.Iterator.html#method.filter\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Filter<I, P> {\n-    iter: I,\n-    predicate: P,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Filter\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        for x in &mut self.iter {\n-            if (self.predicate)(&x) {\n-                return Some(x);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    // this special case allows the compiler to make `.filter(_).count()`\n-    // branchless. Barring perfect branch prediction (which is unattainable in\n-    // the general case), this will be much faster in >90% of cases (containing\n-    // virtually all real workloads) and only a tiny bit slower in the rest.\n-    //\n-    // Having this specialization thus allows us to write `.filter(p).count()`\n-    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n-    // less readable and also less backwards-compatible to Rust before 1.10.\n-    //\n-    // Using the branchless version will also simplify the LLVM byte code, thus\n-    // leaving more budget for LLVM optimizations.\n-    #[inline]\n-    fn count(mut self) -> usize {\n-        let mut count = 0;\n-        for x in &mut self.iter {\n-            count += (self.predicate)(&x) as usize;\n-        }\n-        count\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut predicate = self.predicate;\n-        self.iter.fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n-    where P: FnMut(&I::Item) -> bool,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        for x in self.iter.by_ref().rev() {\n-            if (self.predicate)(&x) {\n-                return Some(x);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut predicate = self.predicate;\n-        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, P> FusedIterator for Filter<I, P>\n-    where P: FnMut(&I::Item) -> bool {}\n-\n-/// An iterator that uses `f` to both filter and map elements from `iter`.\n-///\n-/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter_map`]: trait.Iterator.html#method.filter_map\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct FilterMap<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FilterMap\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n-    where F: FnMut(I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        for x in self.iter.by_ref() {\n-            if let Some(y) = (self.f)(x) {\n-                return Some(y);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n-    where F: FnMut(I::Item) -> Option<B>,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        for x in self.iter.by_ref().rev() {\n-            if let Some(y) = (self.f)(x) {\n-                return Some(y);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F>\n-    where F: FnMut(I::Item) -> Option<B> {}\n-\n-/// An iterator that yields the current count and the element during iteration.\n-///\n-/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`enumerate`]: trait.Iterator.html#method.enumerate\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Enumerate<I> {\n-    iter: I,\n-    count: usize,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Enumerate<I> where I: Iterator {\n-    type Item = (usize, <I as Iterator>::Item);\n-\n-    /// # Overflow Behavior\n-    ///\n-    /// The method does no guarding against overflows, so enumerating more than\n-    /// `usize::MAX` elements either produces the wrong result or panics. If\n-    /// debug assertions are enabled, a panic is guaranteed.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Might panic if the index of the element overflows a `usize`.\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next().map(|a| {\n-            let ret = (self.count, a);\n-            // Possible undefined overflow.\n-            self.count += 1;\n-            ret\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n-        self.iter.nth(n).map(|a| {\n-            let i = self.count + n;\n-            self.count = i + 1;\n-            (i, a)\n-        })\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let count = &mut self.count;\n-        self.iter.try_fold(init, move |acc, item| {\n-            let acc = fold(acc, (*count, item));\n-            *count += 1;\n-            acc\n-        })\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut count = self.count;\n-        self.iter.fold(init, move |acc, item| {\n-            let acc = fold(acc, (count, item));\n-            count += 1;\n-            acc\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Enumerate<I> where\n-    I: ExactSizeIterator + DoubleEndedIterator\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next_back().map(|a| {\n-            let len = self.iter.len();\n-            // Can safely add, `ExactSizeIterator` promises that the number of\n-            // elements fits into a `usize`.\n-            (self.count + len, a)\n-        })\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.try_rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[doc(hidden)]\n-unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n-    where I: TrustedRandomAccess\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n-        (self.count + i, self.iter.get_unchecked(i))\n-    }\n-\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Enumerate<I>\n-    where I: TrustedLen,\n-{}\n-\n-\n-/// An iterator with a `peek()` that returns an optional reference to the next\n-/// element.\n-///\n-/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`peekable`]: trait.Iterator.html#method.peekable\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Peekable<I: Iterator> {\n-    iter: I,\n-    /// Remember a peeked value, even if it was None.\n-    peeked: Option<Option<I::Item>>,\n-}\n-\n-// Peekable must remember if a None has been seen in the `.peek()` method.\n-// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n-// underlying iterator at most once. This does not by itself make the iterator\n-// fused.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> Iterator for Peekable<I> {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(v) => v,\n-            None => self.iter.next(),\n-        }\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn count(mut self) -> usize {\n-        match self.peeked.take() {\n-            Some(None) => 0,\n-            Some(Some(_)) => 1 + self.iter.count(),\n-            None => self.iter.count(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(None) => None,\n-            Some(v @ Some(_)) if n == 0 => v,\n-            Some(Some(_)) => self.iter.nth(n - 1),\n-            None => self.iter.nth(n),\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        let peek_opt = match self.peeked.take() {\n-            Some(None) => return None,\n-            Some(v) => v,\n-            None => None,\n-        };\n-        self.iter.last().or(peek_opt)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let peek_len = match self.peeked {\n-            Some(None) => return (0, Some(0)),\n-            Some(Some(_)) => 1,\n-            None => 0,\n-        };\n-        let (lo, hi) = self.iter.size_hint();\n-        let lo = lo.saturating_add(peek_len);\n-        let hi = hi.and_then(|x| x.checked_add(peek_len));\n-        (lo, hi)\n-    }\n-\n-    #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        let acc = match self.peeked.take() {\n-            Some(None) => return Try::from_ok(init),\n-            Some(Some(v)) => f(init, v)?,\n-            None => init,\n-        };\n-        self.iter.try_fold(acc, f)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let acc = match self.peeked {\n-            Some(None) => return init,\n-            Some(Some(v)) => fold(init, v),\n-            None => init,\n-        };\n-        self.iter.fold(acc, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n-\n-impl<I: Iterator> Peekable<I> {\n-    /// Returns a reference to the next() value without advancing the iterator.\n-    ///\n-    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n-    /// But if the iteration is over, `None` is returned.\n-    ///\n-    /// [`next`]: trait.Iterator.html#tymethod.next\n-    ///\n-    /// Because `peek()` returns a reference, and many iterators iterate over\n-    /// references, there can be a possibly confusing situation where the\n-    /// return value is a double reference. You can see this effect in the\n-    /// examples below.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let xs = [1, 2, 3];\n-    ///\n-    /// let mut iter = xs.iter().peekable();\n-    ///\n-    /// // peek() lets us see into the future\n-    /// assert_eq!(iter.peek(), Some(&&1));\n-    /// assert_eq!(iter.next(), Some(&1));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&2));\n-    ///\n-    /// // The iterator does not advance even if we `peek` multiple times\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&3));\n-    ///\n-    /// // After the iterator is finished, so is `peek()`\n-    /// assert_eq!(iter.peek(), None);\n-    /// assert_eq!(iter.next(), None);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn peek(&mut self) -> Option<&I::Item> {\n-        let iter = &mut self.iter;\n-        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n-    }\n-}\n-\n-/// An iterator that rejects elements while `predicate` is true.\n-///\n-/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip_while`]: trait.Iterator.html#method.skip_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct SkipWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"SkipWhile\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"flag\", &self.flag)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n-    where P: FnMut(&I::Item) -> bool\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        let flag = &mut self.flag;\n-        let pred = &mut self.predicate;\n-        self.iter.find(move |x| {\n-            if *flag || !pred(x) {\n-                *flag = true;\n-                true\n-            } else {\n-                false\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v)?,\n-                None => return Try::from_ok(init),\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v),\n-                None => return init,\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for SkipWhile<I, P>\n-    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n-\n-/// An iterator that only accepts elements while `predicate` is true.\n-///\n-/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take_while`]: trait.Iterator.html#method.take_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct TakeWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"TakeWhile\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"flag\", &self.flag)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n-    where P: FnMut(&I::Item) -> bool\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.flag {\n-            None\n-        } else {\n-            self.iter.next().and_then(|x| {\n-                if (self.predicate)(&x) {\n-                    Some(x)\n-                } else {\n-                    self.flag = true;\n-                    None\n-                }\n-            })\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.flag {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper) // can't know a lower bound, due to the predicate\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if self.flag {\n-            Try::from_ok(init)\n-        } else {\n-            let flag = &mut self.flag;\n-            let p = &mut self.predicate;\n-            self.iter.try_fold(init, move |acc, x|{\n-                if p(&x) {\n-                    LoopState::from_try(fold(acc, x))\n-                } else {\n-                    *flag = true;\n-                    LoopState::Break(Try::from_ok(acc))\n-                }\n-            }).into_try()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for TakeWhile<I, P>\n-    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n-\n-/// An iterator that skips over `n` elements of `iter`.\n-///\n-/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip`]: trait.Iterator.html#method.skip\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Skip<I> {\n-    iter: I,\n-    n: usize\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Skip<I> where I: Iterator {\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.n == 0 {\n-            self.iter.next()\n-        } else {\n-            let old_n = self.n;\n-            self.n = 0;\n-            self.iter.nth(old_n)\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        // Can't just add n + self.n due to overflow.\n-        if self.n == 0 {\n-            self.iter.nth(n)\n-        } else {\n-            let to_skip = self.n;\n-            self.n = 0;\n-            // nth(n) skips n+1\n-            if self.iter.nth(to_skip-1).is_none() {\n-                return None;\n-            }\n-            self.iter.nth(n)\n-        }\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count().saturating_sub(self.n)\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        if self.n == 0 {\n-            self.iter.last()\n-        } else {\n-            let next = self.next();\n-            if next.is_some() {\n-                // recurse. n should be 0.\n-                self.last().or(next)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = lower.saturating_sub(self.n);\n-        let upper = upper.map(|x| x.saturating_sub(self.n));\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let n = self.n;\n-        self.n = 0;\n-        if n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(n - 1).is_none() {\n-                return Try::from_ok(init);\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(self.n - 1).is_none() {\n-                return init;\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n-impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSizeIterator {\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.len() > 0 {\n-            self.iter.next_back()\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let mut n = self.len();\n-        if n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            self.iter.try_rfold(init, move |acc, x| {\n-                n -= 1;\n-                let r = fold(acc, x);\n-                if n == 0 { LoopState::Break(r) }\n-                else { LoopState::from_try(r) }\n-            }).into_try()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n-\n-/// An iterator that only iterates over the first `n` iterations of `iter`.\n-///\n-/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take`]: trait.Iterator.html#method.take\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Take<I> {\n-    iter: I,\n-    n: usize\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Take<I> where I: Iterator{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.n != 0 {\n-            self.n -= 1;\n-            self.iter.next()\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        if self.n > n {\n-            self.n -= n + 1;\n-            self.iter.nth(n)\n-        } else {\n-            if self.n > 0 {\n-                self.iter.nth(self.n - 1);\n-                self.n = 0;\n-            }\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.n == 0 {\n-            return (0, Some(0));\n-        }\n-\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = cmp::min(lower, self.n);\n-\n-        let upper = match upper {\n-            Some(x) if x < self.n => Some(x),\n-            _ => Some(self.n)\n-        };\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if self.n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            let n = &mut self.n;\n-            self.iter.try_fold(init, move |acc, x| {\n-                *n -= 1;\n-                let r = fold(acc, x);\n-                if *n == 0 { LoopState::Break(r) }\n-                else { LoopState::from_try(r) }\n-            }).into_try()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}\n-\n-/// An iterator to maintain state while iterating another iterator.\n-///\n-/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`scan`]: trait.Iterator.html#method.scan\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Scan<I, St, F> {\n-    iter: I,\n-    f: F,\n-    state: St,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Scan\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"state\", &self.state)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I, St, F> Iterator for Scan<I, St, F> where\n-    I: Iterator,\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the scan function\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let state = &mut self.state;\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, x| {\n-            match f(state, x) {\n-                None => LoopState::Break(Try::from_ok(acc)),\n-                Some(x) => LoopState::from_try(fold(acc, x)),\n-            }\n-        }).into_try()\n-    }\n-}\n-\n-/// An iterator that maps each element to an iterator, and yields the elements\n-/// of the produced iterators.\n-///\n-/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`flat_map`]: trait.Iterator.html#method.flat_map\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct FlatMap<I, U: IntoIterator, F> {\n-    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n-    where <U as IntoIterator>::IntoIter: Clone\n-{\n-    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n-    where U::IntoIter: fmt::Debug\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n-{\n-    type Item = U::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n-          U: IntoIterator,\n-          U::IntoIter: DoubleEndedIterator\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.rfold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n-    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n-\n-/// An iterator that flattens one level of nesting in an iterator of things\n-/// that can be turned into iterators.\n-///\n-/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`flatten`]: trait.Iterator.html#method.flatten\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-pub struct Flatten<I: Iterator>\n-where I::Item: IntoIterator {\n-    inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> fmt::Debug for Flatten<I>\n-    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n-    }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> Clone for Flatten<I>\n-    where I: Iterator + Clone, U: Iterator + Clone,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n-{\n-    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> Iterator for Flatten<I>\n-    where I: Iterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    type Item = U::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> DoubleEndedIterator for Flatten<I>\n-    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.rfold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> FusedIterator for Flatten<I>\n-    where I: FusedIterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n-\n-/// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n-fn flatten_compat<I, U>(iter: I) -> FlattenCompat<I, U> {\n-    FlattenCompat { iter, frontiter: None, backiter: None }\n-}\n-\n-/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n-/// this type.\n-#[derive(Clone, Debug)]\n-struct FlattenCompat<I, U> {\n-    iter: I,\n-    frontiter: Option<U>,\n-    backiter: Option<U>,\n-}\n-\n-impl<I, U> Iterator for FlattenCompat<I, U>\n-    where I: Iterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    type Item = U::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<U::Item> {\n-        loop {\n-            if let Some(ref mut inner) = self.frontiter {\n-                if let elt@Some(_) = inner.next() { return elt }\n-            }\n-            match self.iter.next() {\n-                None => return self.backiter.as_mut().and_then(|it| it.next()),\n-                Some(inner) => self.frontiter = Some(inner.into_iter()),\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let lo = flo.saturating_add(blo);\n-        match (self.iter.size_hint(), fhi, bhi) {\n-            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n-            _ => (lo, None)\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if let Some(ref mut front) = self.frontiter {\n-            init = front.try_fold(init, &mut fold)?;\n-        }\n-        self.frontiter = None;\n-\n-        {\n-            let frontiter = &mut self.frontiter;\n-            init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_fold(acc, &mut fold);\n-                *frontiter = Some(mid);\n-                r\n-            })?;\n-        }\n-        self.frontiter = None;\n-\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_fold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n-        Try::from_ok(init)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.frontiter.into_iter()\n-            .chain(self.iter.map(IntoIterator::into_iter))\n-            .chain(self.backiter)\n-            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n-    }\n-}\n-\n-impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n-    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> {\n-        loop {\n-            if let Some(ref mut inner) = self.backiter {\n-                if let elt@Some(_) = inner.next_back() { return elt }\n-            }\n-            match self.iter.next_back() {\n-                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n-                next => self.backiter = next.map(IntoIterator::into_iter),\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_rfold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n-        {\n-            let backiter = &mut self.backiter;\n-            init = self.iter.try_rfold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_rfold(acc, &mut fold);\n-                *backiter = Some(mid);\n-                r\n-            })?;\n-        }\n-        self.backiter = None;\n-\n-        if let Some(ref mut front) = self.frontiter {\n-            init = front.try_rfold(init, &mut fold)?;\n-        }\n-        self.frontiter = None;\n-\n-        Try::from_ok(init)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.frontiter.into_iter()\n-            .chain(self.iter.map(IntoIterator::into_iter))\n-            .chain(self.backiter)\n-            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n-    }\n-}\n-\n-/// An iterator that yields `None` forever after the underlying iterator\n-/// yields `None` once.\n-///\n-/// This `struct` is created by the [`fuse`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`fuse`]: trait.Iterator.html#method.fuse\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Fuse<I> {\n-    iter: I,\n-    done: bool\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Fuse<I> where I: Iterator {\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let next = self.iter.next();\n-            self.done = next.is_none();\n-            next\n-        }\n-    }\n-\n-    #[inline]\n-    default fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let nth = self.iter.nth(n);\n-            self.done = nth.is_none();\n-            nth\n-        }\n-    }\n-\n-    #[inline]\n-    default fn last(self) -> Option<I::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            self.iter.last()\n-        }\n-    }\n-\n-    #[inline]\n-    default fn count(self) -> usize {\n-        if self.done {\n-            0\n-        } else {\n-            self.iter.count()\n-        }\n-    }\n-\n-    #[inline]\n-    default fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.done {\n-            (0, Some(0))\n-        } else {\n-            self.iter.size_hint()\n-        }\n-    }\n-\n-    #[inline]\n-    default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if self.done {\n-            Try::from_ok(init)\n-        } else {\n-            let acc = self.iter.try_fold(init, fold)?;\n-            self.done = true;\n-            Try::from_ok(acc)\n-        }\n-    }\n-\n-    #[inline]\n-    default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.done {\n-            init\n-        } else {\n-            self.iter.fold(init, fold)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n-    #[inline]\n-    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let next = self.iter.next_back();\n-            self.done = next.is_none();\n-            next\n-        }\n-    }\n-\n-    #[inline]\n-    default fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if self.done {\n-            Try::from_ok(init)\n-        } else {\n-            let acc = self.iter.try_rfold(init, fold)?;\n-            self.done = true;\n-            Try::from_ok(acc)\n-        }\n-    }\n-\n-    #[inline]\n-    default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.done {\n-            init\n-        } else {\n-            self.iter.rfold(init, fold)\n-        }\n-    }\n-}\n-\n-unsafe impl<I> TrustedRandomAccess for Fuse<I>\n-    where I: TrustedRandomAccess,\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n-        self.iter.get_unchecked(i)\n-    }\n-\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> Iterator for Fuse<I> where I: FusedIterator {\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next()\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        self.iter.nth(n)\n-    }\n-\n-    #[inline]\n-    fn last(self) -> Option<I::Item> {\n-        self.iter.last()\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I>\n-    where I: DoubleEndedIterator + FusedIterator\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next_back()\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.iter.try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, fold)\n-    }\n-}\n-\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-/// An iterator that calls a function with a reference to each element before\n-/// yielding it.\n-///\n-/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`inspect`]: trait.Iterator.html#method.inspect\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Inspect<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Inspect\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n-    }\n-}\n-\n-impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n-    #[inline]\n-    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n-        if let Some(ref a) = elt {\n-            (self.f)(a);\n-        }\n-\n-        elt\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| { f(&item); fold(acc, item) })\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item),\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next_back();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item)\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item) {}"}, {"sha": "e8c6cd8b79c72a2f57da16c12fbd8b0c4ade91a6", "filename": "src/libcore/iter/traits.rs", "status": "removed", "additions": 0, "deletions": 1060, "changes": 1060, "blob_url": "https://github.com/rust-lang/rust/blob/8611577360e66f90470bd40c498cf8d194f67926/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8611577360e66f90470bd40c498cf8d194f67926/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=8611577360e66f90470bd40c498cf8d194f67926", "patch": "@@ -1,1060 +0,0 @@\n-use ops::{Mul, Add, Try};\n-use num::Wrapping;\n-\n-use super::LoopState;\n-\n-/// Conversion from an `Iterator`.\n-///\n-/// By implementing `FromIterator` for a type, you define how it will be\n-/// created from an iterator. This is common for types which describe a\n-/// collection of some kind.\n-///\n-/// `FromIterator`'s [`from_iter`] is rarely called explicitly, and is instead\n-/// used through [`Iterator`]'s [`collect`] method. See [`collect`]'s\n-/// documentation for more examples.\n-///\n-/// [`from_iter`]: #tymethod.from_iter\n-/// [`Iterator`]: trait.Iterator.html\n-/// [`collect`]: trait.Iterator.html#method.collect\n-///\n-/// See also: [`IntoIterator`].\n-///\n-/// [`IntoIterator`]: trait.IntoIterator.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter::FromIterator;\n-///\n-/// let five_fives = std::iter::repeat(5).take(5);\n-///\n-/// let v = Vec::from_iter(five_fives);\n-///\n-/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n-/// ```\n-///\n-/// Using [`collect`] to implicitly use `FromIterator`:\n-///\n-/// ```\n-/// let five_fives = std::iter::repeat(5).take(5);\n-///\n-/// let v: Vec<i32> = five_fives.collect();\n-///\n-/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n-/// ```\n-///\n-/// Implementing `FromIterator` for your type:\n-///\n-/// ```\n-/// use std::iter::FromIterator;\n-///\n-/// // A sample collection, that's just a wrapper over Vec<T>\n-/// #[derive(Debug)]\n-/// struct MyCollection(Vec<i32>);\n-///\n-/// // Let's give it some methods so we can create one and add things\n-/// // to it.\n-/// impl MyCollection {\n-///     fn new() -> MyCollection {\n-///         MyCollection(Vec::new())\n-///     }\n-///\n-///     fn add(&mut self, elem: i32) {\n-///         self.0.push(elem);\n-///     }\n-/// }\n-///\n-/// // and we'll implement FromIterator\n-/// impl FromIterator<i32> for MyCollection {\n-///     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {\n-///         let mut c = MyCollection::new();\n-///\n-///         for i in iter {\n-///             c.add(i);\n-///         }\n-///\n-///         c\n-///     }\n-/// }\n-///\n-/// // Now we can make a new iterator...\n-/// let iter = (0..5).into_iter();\n-///\n-/// // ... and make a MyCollection out of it\n-/// let c = MyCollection::from_iter(iter);\n-///\n-/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n-///\n-/// // collect works too!\n-///\n-/// let iter = (0..5).into_iter();\n-/// let c: MyCollection = iter.collect();\n-///\n-/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(\n-    message=\"a collection of type `{Self}` cannot be built from an iterator \\\n-             over elements of type `{A}`\",\n-    label=\"a collection of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\",\n-)]\n-pub trait FromIterator<A>: Sized {\n-    /// Creates a value from an iterator.\n-    ///\n-    /// See the [module-level documentation] for more.\n-    ///\n-    /// [module-level documentation]: index.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::iter::FromIterator;\n-    ///\n-    /// let five_fives = std::iter::repeat(5).take(5);\n-    ///\n-    /// let v = Vec::from_iter(five_fives);\n-    ///\n-    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> Self;\n-}\n-\n-/// Conversion into an `Iterator`.\n-///\n-/// By implementing `IntoIterator` for a type, you define how it will be\n-/// converted to an iterator. This is common for types which describe a\n-/// collection of some kind.\n-///\n-/// One benefit of implementing `IntoIterator` is that your type will [work\n-/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n-///\n-/// See also: [`FromIterator`].\n-///\n-/// [`FromIterator`]: trait.FromIterator.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// let mut iter = v.into_iter();\n-///\n-/// assert_eq!(Some(1), iter.next());\n-/// assert_eq!(Some(2), iter.next());\n-/// assert_eq!(Some(3), iter.next());\n-/// assert_eq!(None, iter.next());\n-/// ```\n-/// Implementing `IntoIterator` for your type:\n-///\n-/// ```\n-/// // A sample collection, that's just a wrapper over Vec<T>\n-/// #[derive(Debug)]\n-/// struct MyCollection(Vec<i32>);\n-///\n-/// // Let's give it some methods so we can create one and add things\n-/// // to it.\n-/// impl MyCollection {\n-///     fn new() -> MyCollection {\n-///         MyCollection(Vec::new())\n-///     }\n-///\n-///     fn add(&mut self, elem: i32) {\n-///         self.0.push(elem);\n-///     }\n-/// }\n-///\n-/// // and we'll implement IntoIterator\n-/// impl IntoIterator for MyCollection {\n-///     type Item = i32;\n-///     type IntoIter = ::std::vec::IntoIter<i32>;\n-///\n-///     fn into_iter(self) -> Self::IntoIter {\n-///         self.0.into_iter()\n-///     }\n-/// }\n-///\n-/// // Now we can make a new collection...\n-/// let mut c = MyCollection::new();\n-///\n-/// // ... add some stuff to it ...\n-/// c.add(0);\n-/// c.add(1);\n-/// c.add(2);\n-///\n-/// // ... and then turn it into an Iterator:\n-/// for (i, n) in c.into_iter().enumerate() {\n-///     assert_eq!(i as i32, n);\n-/// }\n-/// ```\n-///\n-/// It is common to use `IntoIterator` as a trait bound. This allows\n-/// the input collection type to change, so long as it is still an\n-/// iterator. Additional bounds can be specified by restricting on\n-/// `Item`:\n-///\n-/// ```rust\n-/// fn collect_as_strings<T>(collection: T) -> Vec<String>\n-///     where T: IntoIterator,\n-///           T::Item : std::fmt::Debug,\n-/// {\n-///     collection\n-///         .into_iter()\n-///         .map(|item| format!(\"{:?}\", item))\n-///         .collect()\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait IntoIterator {\n-    /// The type of the elements being iterated over.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Item;\n-\n-    /// Which kind of iterator are we turning this into?\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type IntoIter: Iterator<Item=Self::Item>;\n-\n-    /// Creates an iterator from a value.\n-    ///\n-    /// See the [module-level documentation] for more.\n-    ///\n-    /// [module-level documentation]: index.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v = vec![1, 2, 3];\n-    /// let mut iter = v.into_iter();\n-    ///\n-    /// assert_eq!(Some(1), iter.next());\n-    /// assert_eq!(Some(2), iter.next());\n-    /// assert_eq!(Some(3), iter.next());\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn into_iter(self) -> Self::IntoIter;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> IntoIterator for I {\n-    type Item = I::Item;\n-    type IntoIter = I;\n-\n-    fn into_iter(self) -> I {\n-        self\n-    }\n-}\n-\n-/// Extend a collection with the contents of an iterator.\n-///\n-/// Iterators produce a series of values, and collections can also be thought\n-/// of as a series of values. The `Extend` trait bridges this gap, allowing you\n-/// to extend a collection by including the contents of that iterator. When\n-/// extending a collection with an already existing key, that entry is updated\n-/// or, in the case of collections that permit multiple entries with equal\n-/// keys, that entry is inserted.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// // You can extend a String with some chars:\n-/// let mut message = String::from(\"The first three letters are: \");\n-///\n-/// message.extend(&['a', 'b', 'c']);\n-///\n-/// assert_eq!(\"abc\", &message[29..32]);\n-/// ```\n-///\n-/// Implementing `Extend`:\n-///\n-/// ```\n-/// // A sample collection, that's just a wrapper over Vec<T>\n-/// #[derive(Debug)]\n-/// struct MyCollection(Vec<i32>);\n-///\n-/// // Let's give it some methods so we can create one and add things\n-/// // to it.\n-/// impl MyCollection {\n-///     fn new() -> MyCollection {\n-///         MyCollection(Vec::new())\n-///     }\n-///\n-///     fn add(&mut self, elem: i32) {\n-///         self.0.push(elem);\n-///     }\n-/// }\n-///\n-/// // since MyCollection has a list of i32s, we implement Extend for i32\n-/// impl Extend<i32> for MyCollection {\n-///\n-///     // This is a bit simpler with the concrete type signature: we can call\n-///     // extend on anything which can be turned into an Iterator which gives\n-///     // us i32s. Because we need i32s to put into MyCollection.\n-///     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {\n-///\n-///         // The implementation is very straightforward: loop through the\n-///         // iterator, and add() each element to ourselves.\n-///         for elem in iter {\n-///             self.add(elem);\n-///         }\n-///     }\n-/// }\n-///\n-/// let mut c = MyCollection::new();\n-///\n-/// c.add(5);\n-/// c.add(6);\n-/// c.add(7);\n-///\n-/// // let's extend our collection with three more numbers\n-/// c.extend(vec![1, 2, 3]);\n-///\n-/// // we've added these elements onto the end\n-/// assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{:?}\", c));\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Extend<A> {\n-    /// Extends a collection with the contents of an iterator.\n-    ///\n-    /// As this is the only method for this trait, the [trait-level] docs\n-    /// contain more details.\n-    ///\n-    /// [trait-level]: trait.Extend.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// // You can extend a String with some chars:\n-    /// let mut message = String::from(\"abc\");\n-    ///\n-    /// message.extend(['d', 'e', 'f'].iter());\n-    ///\n-    /// assert_eq!(\"abcdef\", &message);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T);\n-}\n-\n-#[stable(feature = \"extend_for_unit\", since = \"1.28.0\")]\n-impl Extend<()> for () {\n-    fn extend<T: IntoIterator<Item = ()>>(&mut self, iter: T) {\n-        iter.into_iter().for_each(drop)\n-    }\n-}\n-\n-/// An iterator able to yield elements from both ends.\n-///\n-/// Something that implements `DoubleEndedIterator` has one extra capability\n-/// over something that implements [`Iterator`]: the ability to also take\n-/// `Item`s from the back, as well as the front.\n-///\n-/// It is important to note that both back and forth work on the same range,\n-/// and do not cross: iteration is over when they meet in the middle.\n-///\n-/// In a similar fashion to the [`Iterator`] protocol, once a\n-/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n-/// may or may not ever return `Some` again. `next()` and `next_back()` are\n-/// interchangeable for this purpose.\n-///\n-/// [`Iterator`]: trait.Iterator.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// let numbers = vec![1, 2, 3, 4, 5, 6];\n-///\n-/// let mut iter = numbers.iter();\n-///\n-/// assert_eq!(Some(&1), iter.next());\n-/// assert_eq!(Some(&6), iter.next_back());\n-/// assert_eq!(Some(&5), iter.next_back());\n-/// assert_eq!(Some(&2), iter.next());\n-/// assert_eq!(Some(&3), iter.next());\n-/// assert_eq!(Some(&4), iter.next());\n-/// assert_eq!(None, iter.next());\n-/// assert_eq!(None, iter.next_back());\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait DoubleEndedIterator: Iterator {\n-    /// Removes and returns an element from the end of the iterator.\n-    ///\n-    /// Returns `None` when there are no more elements.\n-    ///\n-    /// The [trait-level] docs contain more details.\n-    ///\n-    /// [trait-level]: trait.DoubleEndedIterator.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let numbers = vec![1, 2, 3, 4, 5, 6];\n-    ///\n-    /// let mut iter = numbers.iter();\n-    ///\n-    /// assert_eq!(Some(&1), iter.next());\n-    /// assert_eq!(Some(&6), iter.next_back());\n-    /// assert_eq!(Some(&5), iter.next_back());\n-    /// assert_eq!(Some(&2), iter.next());\n-    /// assert_eq!(Some(&3), iter.next());\n-    /// assert_eq!(Some(&4), iter.next());\n-    /// assert_eq!(None, iter.next());\n-    /// assert_eq!(None, iter.next_back());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn next_back(&mut self) -> Option<Self::Item>;\n-\n-    /// Returns the `n`th element from the end of the iterator.\n-    ///\n-    /// This is essentially the reversed version of [`nth`]. Although like most indexing\n-    /// operations, the count starts from zero, so `nth_back(0)` returns the first value fro\n-    /// the end, `nth_back(1)` the second, and so on.\n-    ///\n-    /// Note that all elements between the end and the returned element will be\n-    /// consumed, including the returned element. This also means that calling\n-    /// `nth_back(0)` multiple times on the same iterator will return different\n-    /// elements.\n-    ///\n-    /// `nth_back()` will return [`None`] if `n` is greater than or equal to the length of the\n-    /// iterator.\n-    ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`nth`]: ../../std/iter/trait.Iterator.html#method.nth\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(iter_nth_back)]\n-    /// let a = [1, 2, 3];\n-    /// assert_eq!(a.iter().nth_back(2), Some(&1));\n-    /// ```\n-    ///\n-    /// Calling `nth_back()` multiple times doesn't rewind the iterator:\n-    ///\n-    /// ```\n-    /// #![feature(iter_nth_back)]\n-    /// let a = [1, 2, 3];\n-    ///\n-    /// let mut iter = a.iter();\n-    ///\n-    /// assert_eq!(iter.nth_back(1), Some(&2));\n-    /// assert_eq!(iter.nth_back(1), None);\n-    /// ```\n-    ///\n-    /// Returning `None` if there are less than `n + 1` elements:\n-    ///\n-    /// ```\n-    /// #![feature(iter_nth_back)]\n-    /// let a = [1, 2, 3];\n-    /// assert_eq!(a.iter().nth_back(10), None);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"iter_nth_back\", issue = \"56995\")]\n-    fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n-        for x in self.rev() {\n-            if n == 0 { return Some(x) }\n-            n -= 1;\n-        }\n-        None\n-    }\n-\n-    /// This is the reverse version of [`try_fold()`]: it takes elements\n-    /// starting from the back of the iterator.\n-    ///\n-    /// [`try_fold()`]: trait.Iterator.html#method.try_fold\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let a = [\"1\", \"2\", \"3\"];\n-    /// let sum = a.iter()\n-    ///     .map(|&s| s.parse::<i32>())\n-    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n-    /// assert_eq!(sum, Ok(6));\n-    /// ```\n-    ///\n-    /// Short-circuiting:\n-    ///\n-    /// ```\n-    /// let a = [\"1\", \"rust\", \"3\"];\n-    /// let mut it = a.iter();\n-    /// let sum = it\n-    ///     .by_ref()\n-    ///     .map(|&s| s.parse::<i32>())\n-    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n-    /// assert!(sum.is_err());\n-    ///\n-    /// // Because it short-circuited, the remaining elements are still\n-    /// // available through the iterator.\n-    /// assert_eq!(it.next_back(), Some(&\"1\"));\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok=B>\n-    {\n-        let mut accum = init;\n-        while let Some(x) = self.next_back() {\n-            accum = f(accum, x)?;\n-        }\n-        Try::from_ok(accum)\n-    }\n-\n-    /// An iterator method that reduces the iterator's elements to a single,\n-    /// final value, starting from the back.\n-    ///\n-    /// This is the reverse version of [`fold()`]: it takes elements starting from\n-    /// the back of the iterator.\n-    ///\n-    /// `rfold()` takes two arguments: an initial value, and a closure with two\n-    /// arguments: an 'accumulator', and an element. The closure returns the value that\n-    /// the accumulator should have for the next iteration.\n-    ///\n-    /// The initial value is the value the accumulator will have on the first\n-    /// call.\n-    ///\n-    /// After applying this closure to every element of the iterator, `rfold()`\n-    /// returns the accumulator.\n-    ///\n-    /// This operation is sometimes called 'reduce' or 'inject'.\n-    ///\n-    /// Folding is useful whenever you have a collection of something, and want\n-    /// to produce a single value from it.\n-    ///\n-    /// [`fold()`]: trait.Iterator.html#method.fold\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    ///\n-    /// // the sum of all of the elements of a\n-    /// let sum = a.iter()\n-    ///            .rfold(0, |acc, &x| acc + x);\n-    ///\n-    /// assert_eq!(sum, 6);\n-    /// ```\n-    ///\n-    /// This example builds a string, starting with an initial value\n-    /// and continuing with each element from the back until the front:\n-    ///\n-    /// ```\n-    /// let numbers = [1, 2, 3, 4, 5];\n-    ///\n-    /// let zero = \"0\".to_string();\n-    ///\n-    /// let result = numbers.iter().rfold(zero, |acc, &x| {\n-    ///     format!(\"({} + {})\", x, acc)\n-    /// });\n-    ///\n-    /// assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n-    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> B,\n-    {\n-        self.try_rfold(accum, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n-    }\n-\n-    /// Searches for an element of an iterator from the back that satisfies a predicate.\n-    ///\n-    /// `rfind()` takes a closure that returns `true` or `false`. It applies\n-    /// this closure to each element of the iterator, starting at the end, and if any\n-    /// of them return `true`, then `rfind()` returns [`Some(element)`]. If they all return\n-    /// `false`, it returns [`None`].\n-    ///\n-    /// `rfind()` is short-circuiting; in other words, it will stop processing\n-    /// as soon as the closure returns `true`.\n-    ///\n-    /// Because `rfind()` takes a reference, and many iterators iterate over\n-    /// references, this leads to a possibly confusing situation where the\n-    /// argument is a double reference. You can see this effect in the\n-    /// examples below, with `&&x`.\n-    ///\n-    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    ///\n-    /// assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n-    ///\n-    /// assert_eq!(a.iter().rfind(|&&x| x == 5), None);\n-    /// ```\n-    ///\n-    /// Stopping at the first `true`:\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    ///\n-    /// let mut iter = a.iter();\n-    ///\n-    /// assert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n-    ///\n-    /// // we can still use `iter`, as there are more elements.\n-    /// assert_eq!(iter.next_back(), Some(&1));\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n-    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n-    where\n-        Self: Sized,\n-        P: FnMut(&Self::Item) -> bool\n-    {\n-        self.try_rfold((), move |(), x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        (**self).next_back()\n-    }\n-    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n-        (**self).nth_back(n)\n-    }\n-}\n-\n-/// An iterator that knows its exact length.\n-///\n-/// Many [`Iterator`]s don't know how many times they will iterate, but some do.\n-/// If an iterator knows how many times it can iterate, providing access to\n-/// that information can be useful. For example, if you want to iterate\n-/// backwards, a good start is to know where the end is.\n-///\n-/// When implementing an `ExactSizeIterator`, you must also implement\n-/// [`Iterator`]. When doing so, the implementation of [`size_hint`] *must*\n-/// return the exact size of the iterator.\n-///\n-/// [`Iterator`]: trait.Iterator.html\n-/// [`size_hint`]: trait.Iterator.html#method.size_hint\n-///\n-/// The [`len`] method has a default implementation, so you usually shouldn't\n-/// implement it. However, you may be able to provide a more performant\n-/// implementation than the default, so overriding it in this case makes sense.\n-///\n-/// [`len`]: #method.len\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// // a finite range knows exactly how many times it will iterate\n-/// let five = 0..5;\n-///\n-/// assert_eq!(5, five.len());\n-/// ```\n-///\n-/// In the [module level docs][moddocs], we implemented an [`Iterator`],\n-/// `Counter`. Let's implement `ExactSizeIterator` for it as well:\n-///\n-/// [moddocs]: index.html\n-///\n-/// ```\n-/// # struct Counter {\n-/// #     count: usize,\n-/// # }\n-/// # impl Counter {\n-/// #     fn new() -> Counter {\n-/// #         Counter { count: 0 }\n-/// #     }\n-/// # }\n-/// # impl Iterator for Counter {\n-/// #     type Item = usize;\n-/// #     fn next(&mut self) -> Option<usize> {\n-/// #         self.count += 1;\n-/// #         if self.count < 6 {\n-/// #             Some(self.count)\n-/// #         } else {\n-/// #             None\n-/// #         }\n-/// #     }\n-/// # }\n-/// impl ExactSizeIterator for Counter {\n-///     // We can easily calculate the remaining number of iterations.\n-///     fn len(&self) -> usize {\n-///         5 - self.count\n-///     }\n-/// }\n-///\n-/// // And now we can use it!\n-///\n-/// let counter = Counter::new();\n-///\n-/// assert_eq!(5, counter.len());\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait ExactSizeIterator: Iterator {\n-    /// Returns the exact number of times the iterator will iterate.\n-    ///\n-    /// This method has a default implementation, so you usually should not\n-    /// implement it directly. However, if you can provide a more efficient\n-    /// implementation, you can do so. See the [trait-level] docs for an\n-    /// example.\n-    ///\n-    /// This function has the same safety guarantees as the [`size_hint`]\n-    /// function.\n-    ///\n-    /// [trait-level]: trait.ExactSizeIterator.html\n-    /// [`size_hint`]: trait.Iterator.html#method.size_hint\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// // a finite range knows exactly how many times it will iterate\n-    /// let five = 0..5;\n-    ///\n-    /// assert_eq!(5, five.len());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len(&self) -> usize {\n-        let (lower, upper) = self.size_hint();\n-        // Note: This assertion is overly defensive, but it checks the invariant\n-        // guaranteed by the trait. If this trait were rust-internal,\n-        // we could use debug_assert!; assert_eq! will check all Rust user\n-        // implementations too.\n-        assert_eq!(upper, Some(lower));\n-        lower\n-    }\n-\n-    /// Returns whether the iterator is empty.\n-    ///\n-    /// This method has a default implementation using `self.len()`, so you\n-    /// don't need to implement it yourself.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(exact_size_is_empty)]\n-    ///\n-    /// let mut one_element = std::iter::once(0);\n-    /// assert!(!one_element.is_empty());\n-    ///\n-    /// assert_eq!(one_element.next(), Some(0));\n-    /// assert!(one_element.is_empty());\n-    ///\n-    /// assert_eq!(one_element.next(), None);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"exact_size_is_empty\", issue = \"35428\")]\n-    fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for &mut I {\n-    fn len(&self) -> usize {\n-        (**self).len()\n-    }\n-    fn is_empty(&self) -> bool {\n-        (**self).is_empty()\n-    }\n-}\n-\n-/// Trait to represent types that can be created by summing up an iterator.\n-///\n-/// This trait is used to implement the [`sum`] method on iterators. Types which\n-/// implement the trait can be generated by the [`sum`] method. Like\n-/// [`FromIterator`] this trait should rarely be called directly and instead\n-/// interacted with through [`Iterator::sum`].\n-///\n-/// [`sum`]: ../../std/iter/trait.Sum.html#tymethod.sum\n-/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n-/// [`Iterator::sum`]: ../../std/iter/trait.Iterator.html#method.sum\n-#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-pub trait Sum<A = Self>: Sized {\n-    /// Method which takes an iterator and generates `Self` from the elements by\n-    /// \"summing up\" the items.\n-    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n-}\n-\n-/// Trait to represent types that can be created by multiplying elements of an\n-/// iterator.\n-///\n-/// This trait is used to implement the [`product`] method on iterators. Types\n-/// which implement the trait can be generated by the [`product`] method. Like\n-/// [`FromIterator`] this trait should rarely be called directly and instead\n-/// interacted with through [`Iterator::product`].\n-///\n-/// [`product`]: ../../std/iter/trait.Product.html#tymethod.product\n-/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n-/// [`Iterator::product`]: ../../std/iter/trait.Iterator.html#method.product\n-#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-pub trait Product<A = Self>: Sized {\n-    /// Method which takes an iterator and generates `Self` from the elements by\n-    /// multiplying the items.\n-    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n-}\n-\n-// N.B., explicitly use Add and Mul here to inherit overflow checks\n-macro_rules! integer_sum_product {\n-    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n-        #[$attr]\n-        impl Sum for $a {\n-            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold($zero, Add::add)\n-            }\n-        }\n-\n-        #[$attr]\n-        impl Product for $a {\n-            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold($one, Mul::mul)\n-            }\n-        }\n-\n-        #[$attr]\n-        impl<'a> Sum<&'a $a> for $a {\n-            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold($zero, Add::add)\n-            }\n-        }\n-\n-        #[$attr]\n-        impl<'a> Product<&'a $a> for $a {\n-            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold($one, Mul::mul)\n-            }\n-        }\n-    )*);\n-    ($($a:ty)*) => (\n-        integer_sum_product!(@impls 0, 1,\n-                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n-                $($a)+);\n-        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n-                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n-                $(Wrapping<$a>)+);\n-    );\n-}\n-\n-macro_rules! float_sum_product {\n-    ($($a:ident)*) => ($(\n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-        impl Sum for $a {\n-            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + b)\n-            }\n-        }\n-\n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-        impl Product for $a {\n-            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * b)\n-            }\n-        }\n-\n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-        impl<'a> Sum<&'a $a> for $a {\n-            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + *b)\n-            }\n-        }\n-\n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-        impl<'a> Product<&'a $a> for $a {\n-            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * *b)\n-            }\n-        }\n-    )*)\n-}\n-\n-integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n-float_sum_product! { f32 f64 }\n-\n-/// An iterator adapter that produces output as long as the underlying\n-/// iterator produces `Result::Ok` values.\n-///\n-/// If an error is encountered, the iterator stops and the error is\n-/// stored. The error may be recovered later via `reconstruct`.\n-struct ResultShunt<I, E> {\n-    iter: I,\n-    error: Option<E>,\n-}\n-\n-impl<I, T, E> ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n-{\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Result<T, _>`. Any errors will stop the inner iterator and\n-    /// the overall result will be an error.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n-        where F: FnMut(&mut Self) -> U\n-    {\n-        let mut shunt = ResultShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        ResultShunt {\n-            iter,\n-            error: None,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Result` value. This should\n-    /// *always* be called, otherwise any potential error would be\n-    /// lost.\n-    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n-        match self.error {\n-            None => Ok(val),\n-            Some(e) => Err(e),\n-        }\n-    }\n-}\n-\n-impl<I, T, E> Iterator for ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Ok(v)) => Some(v),\n-            Some(Err(e)) => {\n-                self.error = Some(e);\n-                None\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.error.is_some() {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n-impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n-    where T: Sum<U>,\n-{\n-    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n-    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n-    /// the sum of all elements is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This sums up every integer in a vector, rejecting the sum if a negative\n-    /// element is encountered:\n-    ///\n-    /// ```\n-    /// let v = vec![1, 2];\n-    /// let res: Result<i32, &'static str> = v.iter().map(|&x: &i32|\n-    ///     if x < 0 { Err(\"Negative element found\") }\n-    ///     else { Ok(x) }\n-    /// ).sum();\n-    /// assert_eq!(res, Ok(3));\n-    /// ```\n-    fn sum<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n-    {\n-        ResultShunt::process(iter, |i| i.sum())\n-    }\n-}\n-\n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n-impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n-    where T: Product<U>,\n-{\n-    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n-    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n-    /// the product of all elements is returned.\n-    fn product<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n-    {\n-        ResultShunt::process(iter, |i| i.product())\n-    }\n-}\n-\n-/// An iterator that always continues to yield `None` when exhausted.\n-///\n-/// Calling next on a fused iterator that has returned `None` once is guaranteed\n-/// to return [`None`] again. This trait should be implemented by all iterators\n-/// that behave this way because it allows optimizing [`Iterator::fuse`].\n-///\n-/// Note: In general, you should not use `FusedIterator` in generic bounds if\n-/// you need a fused iterator. Instead, you should just call [`Iterator::fuse`]\n-/// on the iterator. If the iterator is already fused, the additional [`Fuse`]\n-/// wrapper will be a no-op with no performance penalty.\n-///\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [`Iterator::fuse`]: ../../std/iter/trait.Iterator.html#method.fuse\n-/// [`Fuse`]: ../../std/iter/struct.Fuse.html\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-pub trait FusedIterator: Iterator {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n-\n-/// An iterator that reports an accurate length using size_hint.\n-///\n-/// The iterator reports a size hint where it is either exact\n-/// (lower bound is equal to upper bound), or the upper bound is [`None`].\n-/// The upper bound must only be [`None`] if the actual iterator length is\n-/// larger than [`usize::MAX`]. In that case, the lower bound must be\n-/// [`usize::MAX`], resulting in a [`.size_hint`] of `(usize::MAX, None)`.\n-///\n-/// The iterator must produce exactly the number of elements it reported\n-/// or diverge before reaching the end.\n-///\n-/// # Safety\n-///\n-/// This trait must only be implemented when the contract is upheld.\n-/// Consumers of this trait must inspect [`.size_hint`]\u2019s upper bound.\n-///\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n-/// [`.size_hint`]: ../../std/iter/trait.Iterator.html#method.size_hint\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-pub unsafe trait TrustedLen : Iterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I: TrustedLen + ?Sized> TrustedLen for &mut I {}"}, {"sha": "dfe1d2a1006d7b1ff8fa0352c1f507af1e9c7b50", "filename": "src/libcore/iter/traits/accum.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,225 @@\n+use ops::{Mul, Add};\n+use num::Wrapping;\n+\n+/// Trait to represent types that can be created by summing up an iterator.\n+///\n+/// This trait is used to implement the [`sum`] method on iterators. Types which\n+/// implement the trait can be generated by the [`sum`] method. Like\n+/// [`FromIterator`] this trait should rarely be called directly and instead\n+/// interacted with through [`Iterator::sum`].\n+///\n+/// [`sum`]: ../../std/iter/trait.Sum.html#tymethod.sum\n+/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n+/// [`Iterator::sum`]: ../../std/iter/trait.Iterator.html#method.sum\n+#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+pub trait Sum<A = Self>: Sized {\n+    /// Method which takes an iterator and generates `Self` from the elements by\n+    /// \"summing up\" the items.\n+    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n+}\n+\n+/// Trait to represent types that can be created by multiplying elements of an\n+/// iterator.\n+///\n+/// This trait is used to implement the [`product`] method on iterators. Types\n+/// which implement the trait can be generated by the [`product`] method. Like\n+/// [`FromIterator`] this trait should rarely be called directly and instead\n+/// interacted with through [`Iterator::product`].\n+///\n+/// [`product`]: ../../std/iter/trait.Product.html#tymethod.product\n+/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n+/// [`Iterator::product`]: ../../std/iter/trait.Iterator.html#method.product\n+#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+pub trait Product<A = Self>: Sized {\n+    /// Method which takes an iterator and generates `Self` from the elements by\n+    /// multiplying the items.\n+    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n+}\n+\n+// N.B., explicitly use Add and Mul here to inherit overflow checks\n+macro_rules! integer_sum_product {\n+    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n+        #[$attr]\n+        impl Sum for $a {\n+            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold($zero, Add::add)\n+            }\n+        }\n+\n+        #[$attr]\n+        impl Product for $a {\n+            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold($one, Mul::mul)\n+            }\n+        }\n+\n+        #[$attr]\n+        impl<'a> Sum<&'a $a> for $a {\n+            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold($zero, Add::add)\n+            }\n+        }\n+\n+        #[$attr]\n+        impl<'a> Product<&'a $a> for $a {\n+            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold($one, Mul::mul)\n+            }\n+        }\n+    )*);\n+    ($($a:ty)*) => (\n+        integer_sum_product!(@impls 0, 1,\n+                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n+                $($a)+);\n+        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n+                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n+                $(Wrapping<$a>)+);\n+    );\n+}\n+\n+macro_rules! float_sum_product {\n+    ($($a:ident)*) => ($(\n+        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        impl Sum for $a {\n+            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(0.0, |a, b| a + b)\n+            }\n+        }\n+\n+        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        impl Product for $a {\n+            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(1.0, |a, b| a * b)\n+            }\n+        }\n+\n+        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        impl<'a> Sum<&'a $a> for $a {\n+            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(0.0, |a, b| a + *b)\n+            }\n+        }\n+\n+        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        impl<'a> Product<&'a $a> for $a {\n+            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(1.0, |a, b| a * *b)\n+            }\n+        }\n+    )*)\n+}\n+\n+integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n+float_sum_product! { f32 f64 }\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Result::Ok` values.\n+///\n+/// If an error is encountered, the iterator stops and the error is\n+/// stored. The error may be recovered later via `reconstruct`.\n+struct ResultShunt<I, E> {\n+    iter: I,\n+    error: Option<E>,\n+}\n+\n+impl<I, T, E> ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Result<T, _>`. Any errors will stop the inner iterator and\n+    /// the overall result will be an error.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n+        where F: FnMut(&mut Self) -> U\n+    {\n+        let mut shunt = ResultShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        ResultShunt {\n+            iter,\n+            error: None,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Result` value. This should\n+    /// *always* be called, otherwise any potential error would be\n+    /// lost.\n+    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n+        match self.error {\n+            None => Ok(val),\n+            Some(e) => Err(e),\n+        }\n+    }\n+}\n+\n+impl<I, T, E> Iterator for ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Ok(v)) => Some(v),\n+            Some(Err(e)) => {\n+                self.error = Some(e);\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.error.is_some() {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n+    where T: Sum<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n+    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n+    /// the sum of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This sums up every integer in a vector, rejecting the sum if a negative\n+    /// element is encountered:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2];\n+    /// let res: Result<i32, &'static str> = v.iter().map(|&x: &i32|\n+    ///     if x < 0 { Err(\"Negative element found\") }\n+    ///     else { Ok(x) }\n+    /// ).sum();\n+    /// assert_eq!(res, Ok(3));\n+    /// ```\n+    fn sum<I>(iter: I) -> Result<T, E>\n+        where I: Iterator<Item = Result<U, E>>,\n+    {\n+        ResultShunt::process(iter, |i| i.sum())\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n+    where T: Product<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n+    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n+    /// the product of all elements is returned.\n+    fn product<I>(iter: I) -> Result<T, E>\n+        where I: Iterator<Item = Result<U, E>>,\n+    {\n+        ResultShunt::process(iter, |i| i.product())\n+    }\n+}"}, {"sha": "5204f6a64250959f1ff72aa2099f0764f41fb4c0", "filename": "src/libcore/iter/traits/collect.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,349 @@\n+/// Conversion from an `Iterator`.\n+///\n+/// By implementing `FromIterator` for a type, you define how it will be\n+/// created from an iterator. This is common for types which describe a\n+/// collection of some kind.\n+///\n+/// `FromIterator`'s [`from_iter`] is rarely called explicitly, and is instead\n+/// used through [`Iterator`]'s [`collect`] method. See [`collect`]'s\n+/// documentation for more examples.\n+///\n+/// [`from_iter`]: #tymethod.from_iter\n+/// [`Iterator`]: trait.Iterator.html\n+/// [`collect`]: trait.Iterator.html#method.collect\n+///\n+/// See also: [`IntoIterator`].\n+///\n+/// [`IntoIterator`]: trait.IntoIterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter::FromIterator;\n+///\n+/// let five_fives = std::iter::repeat(5).take(5);\n+///\n+/// let v = Vec::from_iter(five_fives);\n+///\n+/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+/// ```\n+///\n+/// Using [`collect`] to implicitly use `FromIterator`:\n+///\n+/// ```\n+/// let five_fives = std::iter::repeat(5).take(5);\n+///\n+/// let v: Vec<i32> = five_fives.collect();\n+///\n+/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+/// ```\n+///\n+/// Implementing `FromIterator` for your type:\n+///\n+/// ```\n+/// use std::iter::FromIterator;\n+///\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // and we'll implement FromIterator\n+/// impl FromIterator<i32> for MyCollection {\n+///     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {\n+///         let mut c = MyCollection::new();\n+///\n+///         for i in iter {\n+///             c.add(i);\n+///         }\n+///\n+///         c\n+///     }\n+/// }\n+///\n+/// // Now we can make a new iterator...\n+/// let iter = (0..5).into_iter();\n+///\n+/// // ... and make a MyCollection out of it\n+/// let c = MyCollection::from_iter(iter);\n+///\n+/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n+///\n+/// // collect works too!\n+///\n+/// let iter = (0..5).into_iter();\n+/// let c: MyCollection = iter.collect();\n+///\n+/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented(\n+    message=\"a collection of type `{Self}` cannot be built from an iterator \\\n+             over elements of type `{A}`\",\n+    label=\"a collection of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\",\n+)]\n+pub trait FromIterator<A>: Sized {\n+    /// Creates a value from an iterator.\n+    ///\n+    /// See the [module-level documentation] for more.\n+    ///\n+    /// [module-level documentation]: index.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::iter::FromIterator;\n+    ///\n+    /// let five_fives = std::iter::repeat(5).take(5);\n+    ///\n+    /// let v = Vec::from_iter(five_fives);\n+    ///\n+    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> Self;\n+}\n+\n+/// Conversion into an `Iterator`.\n+///\n+/// By implementing `IntoIterator` for a type, you define how it will be\n+/// converted to an iterator. This is common for types which describe a\n+/// collection of some kind.\n+///\n+/// One benefit of implementing `IntoIterator` is that your type will [work\n+/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n+///\n+/// See also: [`FromIterator`].\n+///\n+/// [`FromIterator`]: trait.FromIterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// let mut iter = v.into_iter();\n+///\n+/// assert_eq!(Some(1), iter.next());\n+/// assert_eq!(Some(2), iter.next());\n+/// assert_eq!(Some(3), iter.next());\n+/// assert_eq!(None, iter.next());\n+/// ```\n+/// Implementing `IntoIterator` for your type:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // and we'll implement IntoIterator\n+/// impl IntoIterator for MyCollection {\n+///     type Item = i32;\n+///     type IntoIter = ::std::vec::IntoIter<i32>;\n+///\n+///     fn into_iter(self) -> Self::IntoIter {\n+///         self.0.into_iter()\n+///     }\n+/// }\n+///\n+/// // Now we can make a new collection...\n+/// let mut c = MyCollection::new();\n+///\n+/// // ... add some stuff to it ...\n+/// c.add(0);\n+/// c.add(1);\n+/// c.add(2);\n+///\n+/// // ... and then turn it into an Iterator:\n+/// for (i, n) in c.into_iter().enumerate() {\n+///     assert_eq!(i as i32, n);\n+/// }\n+/// ```\n+///\n+/// It is common to use `IntoIterator` as a trait bound. This allows\n+/// the input collection type to change, so long as it is still an\n+/// iterator. Additional bounds can be specified by restricting on\n+/// `Item`:\n+///\n+/// ```rust\n+/// fn collect_as_strings<T>(collection: T) -> Vec<String>\n+///     where T: IntoIterator,\n+///           T::Item : std::fmt::Debug,\n+/// {\n+///     collection\n+///         .into_iter()\n+///         .map(|item| format!(\"{:?}\", item))\n+///         .collect()\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IntoIterator {\n+    /// The type of the elements being iterated over.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Item;\n+\n+    /// Which kind of iterator are we turning this into?\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type IntoIter: Iterator<Item=Self::Item>;\n+\n+    /// Creates an iterator from a value.\n+    ///\n+    /// See the [module-level documentation] for more.\n+    ///\n+    /// [module-level documentation]: index.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2, 3];\n+    /// let mut iter = v.into_iter();\n+    ///\n+    /// assert_eq!(Some(1), iter.next());\n+    /// assert_eq!(Some(2), iter.next());\n+    /// assert_eq!(Some(3), iter.next());\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_iter(self) -> Self::IntoIter;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> IntoIterator for I {\n+    type Item = I::Item;\n+    type IntoIter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+/// Extend a collection with the contents of an iterator.\n+///\n+/// Iterators produce a series of values, and collections can also be thought\n+/// of as a series of values. The `Extend` trait bridges this gap, allowing you\n+/// to extend a collection by including the contents of that iterator. When\n+/// extending a collection with an already existing key, that entry is updated\n+/// or, in the case of collections that permit multiple entries with equal\n+/// keys, that entry is inserted.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // You can extend a String with some chars:\n+/// let mut message = String::from(\"The first three letters are: \");\n+///\n+/// message.extend(&['a', 'b', 'c']);\n+///\n+/// assert_eq!(\"abc\", &message[29..32]);\n+/// ```\n+///\n+/// Implementing `Extend`:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // since MyCollection has a list of i32s, we implement Extend for i32\n+/// impl Extend<i32> for MyCollection {\n+///\n+///     // This is a bit simpler with the concrete type signature: we can call\n+///     // extend on anything which can be turned into an Iterator which gives\n+///     // us i32s. Because we need i32s to put into MyCollection.\n+///     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {\n+///\n+///         // The implementation is very straightforward: loop through the\n+///         // iterator, and add() each element to ourselves.\n+///         for elem in iter {\n+///             self.add(elem);\n+///         }\n+///     }\n+/// }\n+///\n+/// let mut c = MyCollection::new();\n+///\n+/// c.add(5);\n+/// c.add(6);\n+/// c.add(7);\n+///\n+/// // let's extend our collection with three more numbers\n+/// c.extend(vec![1, 2, 3]);\n+///\n+/// // we've added these elements onto the end\n+/// assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{:?}\", c));\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Extend<A> {\n+    /// Extends a collection with the contents of an iterator.\n+    ///\n+    /// As this is the only method for this trait, the [trait-level] docs\n+    /// contain more details.\n+    ///\n+    /// [trait-level]: trait.Extend.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // You can extend a String with some chars:\n+    /// let mut message = String::from(\"abc\");\n+    ///\n+    /// message.extend(['d', 'e', 'f'].iter());\n+    ///\n+    /// assert_eq!(\"abcdef\", &message);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T);\n+}\n+\n+#[stable(feature = \"extend_for_unit\", since = \"1.28.0\")]\n+impl Extend<()> for () {\n+    fn extend<T: IntoIterator<Item = ()>>(&mut self, iter: T) {\n+        iter.into_iter().for_each(drop)\n+    }\n+}"}, {"sha": "2976afc0b4f81db5729d175f596a791b85e6eac3", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,297 @@\n+use ops::Try;\n+use iter::LoopState;\n+\n+/// An iterator able to yield elements from both ends.\n+///\n+/// Something that implements `DoubleEndedIterator` has one extra capability\n+/// over something that implements [`Iterator`]: the ability to also take\n+/// `Item`s from the back, as well as the front.\n+///\n+/// It is important to note that both back and forth work on the same range,\n+/// and do not cross: iteration is over when they meet in the middle.\n+///\n+/// In a similar fashion to the [`Iterator`] protocol, once a\n+/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n+/// may or may not ever return `Some` again. `next()` and `next_back()` are\n+/// interchangeable for this purpose.\n+///\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let numbers = vec![1, 2, 3, 4, 5, 6];\n+///\n+/// let mut iter = numbers.iter();\n+///\n+/// assert_eq!(Some(&1), iter.next());\n+/// assert_eq!(Some(&6), iter.next_back());\n+/// assert_eq!(Some(&5), iter.next_back());\n+/// assert_eq!(Some(&2), iter.next());\n+/// assert_eq!(Some(&3), iter.next());\n+/// assert_eq!(Some(&4), iter.next());\n+/// assert_eq!(None, iter.next());\n+/// assert_eq!(None, iter.next_back());\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait DoubleEndedIterator: Iterator {\n+    /// Removes and returns an element from the end of the iterator.\n+    ///\n+    /// Returns `None` when there are no more elements.\n+    ///\n+    /// The [trait-level] docs contain more details.\n+    ///\n+    /// [trait-level]: trait.DoubleEndedIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let numbers = vec![1, 2, 3, 4, 5, 6];\n+    ///\n+    /// let mut iter = numbers.iter();\n+    ///\n+    /// assert_eq!(Some(&1), iter.next());\n+    /// assert_eq!(Some(&6), iter.next_back());\n+    /// assert_eq!(Some(&5), iter.next_back());\n+    /// assert_eq!(Some(&2), iter.next());\n+    /// assert_eq!(Some(&3), iter.next());\n+    /// assert_eq!(Some(&4), iter.next());\n+    /// assert_eq!(None, iter.next());\n+    /// assert_eq!(None, iter.next_back());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn next_back(&mut self) -> Option<Self::Item>;\n+\n+    /// Returns the `n`th element from the end of the iterator.\n+    ///\n+    /// This is essentially the reversed version of [`nth`]. Although like most indexing\n+    /// operations, the count starts from zero, so `nth_back(0)` returns the first value fro\n+    /// the end, `nth_back(1)` the second, and so on.\n+    ///\n+    /// Note that all elements between the end and the returned element will be\n+    /// consumed, including the returned element. This also means that calling\n+    /// `nth_back(0)` multiple times on the same iterator will return different\n+    /// elements.\n+    ///\n+    /// `nth_back()` will return [`None`] if `n` is greater than or equal to the length of the\n+    /// iterator.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`nth`]: ../../std/iter/trait.Iterator.html#method.nth\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_nth_back)]\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth_back(2), Some(&1));\n+    /// ```\n+    ///\n+    /// Calling `nth_back()` multiple times doesn't rewind the iterator:\n+    ///\n+    /// ```\n+    /// #![feature(iter_nth_back)]\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.nth_back(1), Some(&2));\n+    /// assert_eq!(iter.nth_back(1), None);\n+    /// ```\n+    ///\n+    /// Returning `None` if there are less than `n + 1` elements:\n+    ///\n+    /// ```\n+    /// #![feature(iter_nth_back)]\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth_back(10), None);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_nth_back\", issue = \"56995\")]\n+    fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n+        for x in self.rev() {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+\n+    /// This is the reverse version of [`try_fold()`]: it takes elements\n+    /// starting from the back of the iterator.\n+    ///\n+    /// [`try_fold()`]: trait.Iterator.html#method.try_fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [\"1\", \"2\", \"3\"];\n+    /// let sum = a.iter()\n+    ///     .map(|&s| s.parse::<i32>())\n+    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n+    /// assert_eq!(sum, Ok(6));\n+    /// ```\n+    ///\n+    /// Short-circuiting:\n+    ///\n+    /// ```\n+    /// let a = [\"1\", \"rust\", \"3\"];\n+    /// let mut it = a.iter();\n+    /// let sum = it\n+    ///     .by_ref()\n+    ///     .map(|&s| s.parse::<i32>())\n+    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n+    /// assert!(sum.is_err());\n+    ///\n+    /// // Because it short-circuited, the remaining elements are still\n+    /// // available through the iterator.\n+    /// assert_eq!(it.next_back(), Some(&\"1\"));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok=B>\n+    {\n+        let mut accum = init;\n+        while let Some(x) = self.next_back() {\n+            accum = f(accum, x)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n+    /// An iterator method that reduces the iterator's elements to a single,\n+    /// final value, starting from the back.\n+    ///\n+    /// This is the reverse version of [`fold()`]: it takes elements starting from\n+    /// the back of the iterator.\n+    ///\n+    /// `rfold()` takes two arguments: an initial value, and a closure with two\n+    /// arguments: an 'accumulator', and an element. The closure returns the value that\n+    /// the accumulator should have for the next iteration.\n+    ///\n+    /// The initial value is the value the accumulator will have on the first\n+    /// call.\n+    ///\n+    /// After applying this closure to every element of the iterator, `rfold()`\n+    /// returns the accumulator.\n+    ///\n+    /// This operation is sometimes called 'reduce' or 'inject'.\n+    ///\n+    /// Folding is useful whenever you have a collection of something, and want\n+    /// to produce a single value from it.\n+    ///\n+    /// [`fold()`]: trait.Iterator.html#method.fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// // the sum of all of the elements of a\n+    /// let sum = a.iter()\n+    ///            .rfold(0, |acc, &x| acc + x);\n+    ///\n+    /// assert_eq!(sum, 6);\n+    /// ```\n+    ///\n+    /// This example builds a string, starting with an initial value\n+    /// and continuing with each element from the back until the front:\n+    ///\n+    /// ```\n+    /// let numbers = [1, 2, 3, 4, 5];\n+    ///\n+    /// let zero = \"0\".to_string();\n+    ///\n+    /// let result = numbers.iter().rfold(zero, |acc, &x| {\n+    ///     format!(\"({} + {})\", x, acc)\n+    /// });\n+    ///\n+    /// assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n+    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        self.try_rfold(accum, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+    }\n+\n+    /// Searches for an element of an iterator from the back that satisfies a predicate.\n+    ///\n+    /// `rfind()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, starting at the end, and if any\n+    /// of them return `true`, then `rfind()` returns [`Some(element)`]. If they all return\n+    /// `false`, it returns [`None`].\n+    ///\n+    /// `rfind()` is short-circuiting; in other words, it will stop processing\n+    /// as soon as the closure returns `true`.\n+    ///\n+    /// Because `rfind()` takes a reference, and many iterators iterate over\n+    /// references, this leads to a possibly confusing situation where the\n+    /// argument is a double reference. You can see this effect in the\n+    /// examples below, with `&&x`.\n+    ///\n+    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n+    ///\n+    /// assert_eq!(a.iter().rfind(|&&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next_back(), Some(&1));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n+    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    where\n+        Self: Sized,\n+        P: FnMut(&Self::Item) -> bool\n+    {\n+        self.try_rfold((), move |(), x| {\n+            if predicate(&x) { LoopState::Break(x) }\n+            else { LoopState::Continue(()) }\n+        }).break_value()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        (**self).next_back()\n+    }\n+    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n+        (**self).nth_back(n)\n+    }\n+}"}, {"sha": "3bfba29e2196026c40ab2836958ccd75ac8b1441", "filename": "src/libcore/iter/traits/exact_size.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,143 @@\n+/// An iterator that knows its exact length.\n+///\n+/// Many [`Iterator`]s don't know how many times they will iterate, but some do.\n+/// If an iterator knows how many times it can iterate, providing access to\n+/// that information can be useful. For example, if you want to iterate\n+/// backwards, a good start is to know where the end is.\n+///\n+/// When implementing an `ExactSizeIterator`, you must also implement\n+/// [`Iterator`]. When doing so, the implementation of [`size_hint`] *must*\n+/// return the exact size of the iterator.\n+///\n+/// [`Iterator`]: trait.Iterator.html\n+/// [`size_hint`]: trait.Iterator.html#method.size_hint\n+///\n+/// The [`len`] method has a default implementation, so you usually shouldn't\n+/// implement it. However, you may be able to provide a more performant\n+/// implementation than the default, so overriding it in this case makes sense.\n+///\n+/// [`len`]: #method.len\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // a finite range knows exactly how many times it will iterate\n+/// let five = 0..5;\n+///\n+/// assert_eq!(5, five.len());\n+/// ```\n+///\n+/// In the [module level docs][moddocs], we implemented an [`Iterator`],\n+/// `Counter`. Let's implement `ExactSizeIterator` for it as well:\n+///\n+/// [moddocs]: index.html\n+///\n+/// ```\n+/// # struct Counter {\n+/// #     count: usize,\n+/// # }\n+/// # impl Counter {\n+/// #     fn new() -> Counter {\n+/// #         Counter { count: 0 }\n+/// #     }\n+/// # }\n+/// # impl Iterator for Counter {\n+/// #     type Item = usize;\n+/// #     fn next(&mut self) -> Option<usize> {\n+/// #         self.count += 1;\n+/// #         if self.count < 6 {\n+/// #             Some(self.count)\n+/// #         } else {\n+/// #             None\n+/// #         }\n+/// #     }\n+/// # }\n+/// impl ExactSizeIterator for Counter {\n+///     // We can easily calculate the remaining number of iterations.\n+///     fn len(&self) -> usize {\n+///         5 - self.count\n+///     }\n+/// }\n+///\n+/// // And now we can use it!\n+///\n+/// let counter = Counter::new();\n+///\n+/// assert_eq!(5, counter.len());\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ExactSizeIterator: Iterator {\n+    /// Returns the exact number of times the iterator will iterate.\n+    ///\n+    /// This method has a default implementation, so you usually should not\n+    /// implement it directly. However, if you can provide a more efficient\n+    /// implementation, you can do so. See the [trait-level] docs for an\n+    /// example.\n+    ///\n+    /// This function has the same safety guarantees as the [`size_hint`]\n+    /// function.\n+    ///\n+    /// [trait-level]: trait.ExactSizeIterator.html\n+    /// [`size_hint`]: trait.Iterator.html#method.size_hint\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // a finite range knows exactly how many times it will iterate\n+    /// let five = 0..5;\n+    ///\n+    /// assert_eq!(5, five.len());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn len(&self) -> usize {\n+        let (lower, upper) = self.size_hint();\n+        // Note: This assertion is overly defensive, but it checks the invariant\n+        // guaranteed by the trait. If this trait were rust-internal,\n+        // we could use debug_assert!; assert_eq! will check all Rust user\n+        // implementations too.\n+        assert_eq!(upper, Some(lower));\n+        lower\n+    }\n+\n+    /// Returns whether the iterator is empty.\n+    ///\n+    /// This method has a default implementation using `self.len()`, so you\n+    /// don't need to implement it yourself.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(exact_size_is_empty)]\n+    ///\n+    /// let mut one_element = std::iter::once(0);\n+    /// assert!(!one_element.is_empty());\n+    ///\n+    /// assert_eq!(one_element.next(), Some(0));\n+    /// assert!(one_element.is_empty());\n+    ///\n+    /// assert_eq!(one_element.next(), None);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"exact_size_is_empty\", issue = \"35428\")]\n+    fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for &mut I {\n+    fn len(&self) -> usize {\n+        (**self).len()\n+    }\n+    fn is_empty(&self) -> bool {\n+        (**self).is_empty()\n+    }\n+}\n+"}, {"sha": "9dfa83f473bafbd0a51e129abba75e707cc8685b", "filename": "src/libcore/iter/traits/iterator.rs", "status": "renamed", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -1,12 +1,11 @@\n use cmp::Ordering;\n use ops::Try;\n \n-use super::LoopState;\n-use super::{Chain, Cycle, Copied, Cloned, Enumerate, Filter, FilterMap, Fuse};\n-use super::{Flatten, FlatMap, flatten_compat};\n-use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n-use super::{Zip, Sum, Product};\n-use super::{ChainState, FromIterator, ZipImpl};\n+use super::super::LoopState;\n+use super::super::{Chain, Cycle, Copied, Cloned, Enumerate, Filter, FilterMap, Fuse};\n+use super::super::{Flatten, FlatMap};\n+use super::super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n+use super::super::{Zip, Sum, Product, FromIterator};\n \n fn _assert_is_object_safe(_: &dyn Iterator<Item=()>) {}\n \n@@ -367,8 +366,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n     fn step_by(self, step: usize) -> StepBy<Self> where Self: Sized {\n-        assert!(step != 0);\n-        StepBy{iter: self, step: step - 1, first_take: true}\n+        StepBy::new(self, step)\n     }\n \n     /// Takes two iterators and creates a new iterator over both in sequence.\n@@ -425,7 +423,7 @@ pub trait Iterator {\n     fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter> where\n         Self: Sized, U: IntoIterator<Item=Self::Item>,\n     {\n-        Chain{a: self, b: other.into_iter(), state: ChainState::Both}\n+        Chain::new(self, other.into_iter())\n     }\n \n     /// 'Zips up' two iterators into a single iterator of pairs.\n@@ -560,7 +558,7 @@ pub trait Iterator {\n     fn map<B, F>(self, f: F) -> Map<Self, F> where\n         Self: Sized, F: FnMut(Self::Item) -> B,\n     {\n-        Map { iter: self, f }\n+        Map::new(self, f)\n     }\n \n     /// Calls a closure on each element of an iterator.\n@@ -671,7 +669,7 @@ pub trait Iterator {\n     fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n         Self: Sized, P: FnMut(&Self::Item) -> bool,\n     {\n-        Filter {iter: self, predicate }\n+        Filter::new(self, predicate)\n     }\n \n     /// Creates an iterator that both filters and maps.\n@@ -728,7 +726,7 @@ pub trait Iterator {\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n         Self: Sized, F: FnMut(Self::Item) -> Option<B>,\n     {\n-        FilterMap { iter: self, f }\n+        FilterMap::new(self, f)\n     }\n \n     /// Creates an iterator which gives the current iteration count as well as\n@@ -772,7 +770,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn enumerate(self) -> Enumerate<Self> where Self: Sized {\n-        Enumerate { iter: self, count: 0 }\n+        Enumerate::new(self)\n     }\n \n     /// Creates an iterator which can use `peek` to look at the next element of\n@@ -818,7 +816,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn peekable(self) -> Peekable<Self> where Self: Sized {\n-        Peekable{iter: self, peeked: None}\n+        Peekable::new(self)\n     }\n \n     /// Creates an iterator that [`skip`]s elements based on a predicate.\n@@ -881,7 +879,7 @@ pub trait Iterator {\n     fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where\n         Self: Sized, P: FnMut(&Self::Item) -> bool,\n     {\n-        SkipWhile { iter: self, flag: false, predicate }\n+        SkipWhile::new(self, predicate)\n     }\n \n     /// Creates an iterator that yields elements based on a predicate.\n@@ -961,7 +959,7 @@ pub trait Iterator {\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n         Self: Sized, P: FnMut(&Self::Item) -> bool,\n     {\n-        TakeWhile { iter: self, flag: false, predicate }\n+        TakeWhile::new(self, predicate)\n     }\n \n     /// Creates an iterator that skips the first `n` elements.\n@@ -983,7 +981,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip(self, n: usize) -> Skip<Self> where Self: Sized {\n-        Skip { iter: self, n }\n+        Skip::new(self, n)\n     }\n \n     /// Creates an iterator that yields its first `n` elements.\n@@ -1015,7 +1013,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, n: usize) -> Take<Self> where Self: Sized, {\n-        Take { iter: self, n }\n+        Take::new(self, n)\n     }\n \n     /// An iterator adaptor similar to [`fold`] that holds internal state and\n@@ -1060,7 +1058,7 @@ pub trait Iterator {\n     fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n         where Self: Sized, F: FnMut(&mut St, Self::Item) -> Option<B>,\n     {\n-        Scan { iter: self, f, state: initial_state }\n+        Scan::new(self, initial_state, f)\n     }\n \n     /// Creates an iterator that works like map, but flattens nested structure.\n@@ -1098,7 +1096,7 @@ pub trait Iterator {\n     fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n         where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -> U,\n     {\n-        FlatMap { inner: flatten_compat(self.map(f)) }\n+        FlatMap::new(self, f)\n     }\n \n     /// Creates an iterator that flattens nested structure.\n@@ -1166,7 +1164,7 @@ pub trait Iterator {\n     #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n     fn flatten(self) -> Flatten<Self>\n     where Self: Sized, Self::Item: IntoIterator {\n-        Flatten { inner: flatten_compat(self) }\n+        Flatten::new(self)\n     }\n \n     /// Creates an iterator which ends after the first [`None`].\n@@ -1226,7 +1224,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fuse(self) -> Fuse<Self> where Self: Sized {\n-        Fuse{iter: self, done: false}\n+        Fuse::new(self)\n     }\n \n     /// Do something with each element of an iterator, passing the value on.\n@@ -1309,7 +1307,7 @@ pub trait Iterator {\n     fn inspect<F>(self, f: F) -> Inspect<Self, F> where\n         Self: Sized, F: FnMut(&Self::Item),\n     {\n-        Inspect { iter: self, f }\n+        Inspect::new(self, f)\n     }\n \n     /// Borrows an iterator, rather than consuming it.\n@@ -2183,7 +2181,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rev(self) -> Rev<Self> where Self: Sized + DoubleEndedIterator {\n-        Rev{iter: self}\n+        Rev::new(self)\n     }\n \n     /// Converts an iterator of pairs into a pair of containers.\n@@ -2251,7 +2249,7 @@ pub trait Iterator {\n     fn copied<'a, T: 'a>(self) -> Copied<Self>\n         where Self: Sized + Iterator<Item=&'a T>, T: Copy\n     {\n-        Copied { it: self }\n+        Copied::new(self)\n     }\n \n     /// Creates an iterator which [`clone`]s all of its elements.\n@@ -2280,7 +2278,7 @@ pub trait Iterator {\n     fn cloned<'a, T: 'a>(self) -> Cloned<Self>\n         where Self: Sized + Iterator<Item=&'a T>, T: Clone\n     {\n-        Cloned { it: self }\n+        Cloned::new(self)\n     }\n \n     /// Repeats an iterator endlessly.\n@@ -2311,7 +2309,7 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn cycle(self) -> Cycle<Self> where Self: Sized + Clone {\n-        Cycle{orig: self.clone(), iter: self}\n+        Cycle::new(self)\n     }\n \n     /// Sums the elements of an iterator.", "previous_filename": "src/libcore/iter/iterator.rs"}, {"sha": "602619bce5a9653e3ce9d65e7c530c2221a88c43", "filename": "src/libcore/iter/traits/marker.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,44 @@\n+/// An iterator that always continues to yield `None` when exhausted.\n+///\n+/// Calling next on a fused iterator that has returned `None` once is guaranteed\n+/// to return [`None`] again. This trait should be implemented by all iterators\n+/// that behave this way because it allows optimizing [`Iterator::fuse`].\n+///\n+/// Note: In general, you should not use `FusedIterator` in generic bounds if\n+/// you need a fused iterator. Instead, you should just call [`Iterator::fuse`]\n+/// on the iterator. If the iterator is already fused, the additional [`Fuse`]\n+/// wrapper will be a no-op with no performance penalty.\n+///\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`Iterator::fuse`]: ../../std/iter/trait.Iterator.html#method.fuse\n+/// [`Fuse`]: ../../std/iter/struct.Fuse.html\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+pub trait FusedIterator: Iterator {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n+\n+/// An iterator that reports an accurate length using size_hint.\n+///\n+/// The iterator reports a size hint where it is either exact\n+/// (lower bound is equal to upper bound), or the upper bound is [`None`].\n+/// The upper bound must only be [`None`] if the actual iterator length is\n+/// larger than [`usize::MAX`]. In that case, the lower bound must be\n+/// [`usize::MAX`], resulting in a [`.size_hint`] of `(usize::MAX, None)`.\n+///\n+/// The iterator must produce exactly the number of elements it reported\n+/// or diverge before reaching the end.\n+///\n+/// # Safety\n+///\n+/// This trait must only be implemented when the contract is upheld.\n+/// Consumers of this trait must inspect [`.size_hint`]\u2019s upper bound.\n+///\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+/// [`.size_hint`]: ../../std/iter/trait.Iterator.html#method.size_hint\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+pub unsafe trait TrustedLen : Iterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I: TrustedLen + ?Sized> TrustedLen for &mut I {}"}, {"sha": "000b9fad70b9465632861d900dd9006fc1470506", "filename": "src/libcore/iter/traits/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -0,0 +1,13 @@\n+mod iterator;\n+mod double_ended;\n+mod exact_size;\n+mod collect;\n+mod accum;\n+mod marker;\n+\n+pub use self::iterator::Iterator;\n+pub use self::double_ended::DoubleEndedIterator;\n+pub use self::exact_size::ExactSizeIterator;\n+pub use self::collect::{FromIterator, IntoIterator, Extend};\n+pub use self::accum::{Sum, Product};\n+pub use self::marker::{FusedIterator, TrustedLen};"}, {"sha": "825e5148fd5038240ff17afce618a4d093895271", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -216,7 +216,6 @@ pub mod task;\n pub mod alloc;\n \n // note: does not need to be public\n-mod iter_private;\n mod tuple;\n mod unit;\n "}, {"sha": "d062da0c247adfb9ccb517365d94ddfb5ea4bc0c", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -34,7 +34,6 @@ use result::Result::{Ok, Err};\n use ptr;\n use mem;\n use marker::{Copy, Send, Sync, Sized, self};\n-use iter_private::TrustedRandomAccess;\n \n #[unstable(feature = \"slice_internals\", issue = \"0\",\n            reason = \"exposed from core to be reused in std; use the memchr crate\")]"}, {"sha": "ac920185636549b5eadc80504d1ddc2cb5f80c2a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6ab956e1002517803ecd38b904504a1223274b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=da6ab956e1002517803ecd38b904504a1223274b", "patch": "@@ -9,8 +9,7 @@ use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char;\n use fmt;\n-use iter::{Map, Cloned, FusedIterator, TrustedLen, Filter};\n-use iter_private::TrustedRandomAccess;\n+use iter::{Map, Cloned, FusedIterator, TrustedLen, TrustedRandomAccess, Filter};\n use slice::{self, SliceIndex, Split as SliceSplit};\n use mem;\n "}]}