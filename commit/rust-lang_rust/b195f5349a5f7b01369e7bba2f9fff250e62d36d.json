{"sha": "b195f5349a5f7b01369e7bba2f9fff250e62d36d", "node_id": "C_kwDOAAsO6NoAKGIxOTVmNTM0OWE1ZjdiMDEzNjllN2JiYTJmOWZmZjI1MGU2MmQzNmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-17T08:15:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-17T08:15:35Z"}, "message": "Auto merge of #101784 - reitermarkus:const-memchr, r=thomcc\n\nSimplify `const` `memchr`.\n\nExtracted from https://github.com/rust-lang/rust/pull/101607.\n\nRemoves the need for `const_eval_select`.", "tree": {"sha": "7f34bd97a16f0682dd141ce557640dd7974a99a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f34bd97a16f0682dd141ce557640dd7974a99a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b195f5349a5f7b01369e7bba2f9fff250e62d36d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b195f5349a5f7b01369e7bba2f9fff250e62d36d", "html_url": "https://github.com/rust-lang/rust/commit/b195f5349a5f7b01369e7bba2f9fff250e62d36d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b195f5349a5f7b01369e7bba2f9fff250e62d36d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a12d10bcc4536108efad1613b57f725302c207e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a12d10bcc4536108efad1613b57f725302c207e", "html_url": "https://github.com/rust-lang/rust/commit/4a12d10bcc4536108efad1613b57f725302c207e"}, {"sha": "db29de7745047383031231857745c5ec9b0bb4e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/db29de7745047383031231857745c5ec9b0bb4e8", "html_url": "https://github.com/rust-lang/rust/commit/db29de7745047383031231857745c5ec9b0bb4e8"}], "stats": {"total": 48, "additions": 23, "deletions": 25}, "files": [{"sha": "7de1f48e6c9022dbe685eeb11e03b1312f28d524", "filename": "library/core/src/slice/memchr.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b195f5349a5f7b01369e7bba2f9fff250e62d36d/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b195f5349a5f7b01369e7bba2f9fff250e62d36d/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs?ref=b195f5349a5f7b01369e7bba2f9fff250e62d36d", "patch": "@@ -2,7 +2,6 @@\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n use crate::cmp;\n-use crate::intrinsics;\n use crate::mem;\n \n const LO_USIZE: usize = usize::repeat_u8(0x01);\n@@ -17,53 +16,51 @@ const USIZE_BYTES: usize = mem::size_of::<usize>();\n /// bytes where the borrow propagated all the way to the most significant\n /// bit.\"\n #[inline]\n-fn contains_zero_byte(x: usize) -> bool {\n+const fn contains_zero_byte(x: usize) -> bool {\n     x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[inline]\n-fn repeat_byte(b: u8) -> usize {\n+const fn repeat_byte(b: u8) -> usize {\n     (b as usize) << 8 | b as usize\n }\n \n #[cfg(not(target_pointer_width = \"16\"))]\n #[inline]\n-fn repeat_byte(b: u8) -> usize {\n+const fn repeat_byte(b: u8) -> usize {\n     (b as usize) * (usize::MAX / 255)\n }\n \n /// Returns the first index matching the byte `x` in `text`.\n #[must_use]\n #[inline]\n pub const fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n-    #[inline]\n-    fn rt_impl(x: u8, text: &[u8]) -> Option<usize> {\n-        // Fast path for small slices\n-        if text.len() < 2 * USIZE_BYTES {\n-            return text.iter().position(|elt| *elt == x);\n-        }\n-\n-        memchr_general_case(x, text)\n+    // Fast path for small slices.\n+    if text.len() < 2 * USIZE_BYTES {\n+        return memchr_naive(x, text);\n     }\n \n-    const fn const_impl(x: u8, bytes: &[u8]) -> Option<usize> {\n-        let mut i = 0;\n-        while i < bytes.len() {\n-            if bytes[i] == x {\n-                return Some(i);\n-            }\n-            i += 1;\n+    memchr_aligned(x, text)\n+}\n+\n+#[inline]\n+const fn memchr_naive(x: u8, text: &[u8]) -> Option<usize> {\n+    let mut i = 0;\n+\n+    // FIXME(const-hack): Replace with `text.iter().pos(|c| *c == x)`.\n+    while i < text.len() {\n+        if text[i] == x {\n+            return Some(i);\n         }\n \n-        None\n+        i += 1;\n     }\n \n-    // SAFETY: The const and runtime versions have identical behavior\n-    unsafe { intrinsics::const_eval_select((x, text), const_impl, rt_impl) }\n+    None\n }\n \n-fn memchr_general_case(x: u8, text: &[u8]) -> Option<usize> {\n+const fn memchr_aligned(x: u8, text: &[u8]) -> Option<usize> {\n     // Scan for a single byte value by reading two `usize` words at a time.\n     //\n     // Split `text` in three parts\n@@ -78,7 +75,7 @@ fn memchr_general_case(x: u8, text: &[u8]) -> Option<usize> {\n \n     if offset > 0 {\n         offset = cmp::min(offset, len);\n-        if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n+        if let Some(index) = memchr_naive(x, &text[..offset]) {\n             return Some(index);\n         }\n     }\n@@ -103,7 +100,8 @@ fn memchr_general_case(x: u8, text: &[u8]) -> Option<usize> {\n     }\n \n     // Find the byte after the point the body loop stopped.\n-    text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n+    // FIXME(const-hack): Use `?` instead.\n+    if let Some(i) = memchr_naive(x, &text[offset..]) { Some(offset + i) } else { None }\n }\n \n /// Returns the last index matching the byte `x` in `text`."}]}