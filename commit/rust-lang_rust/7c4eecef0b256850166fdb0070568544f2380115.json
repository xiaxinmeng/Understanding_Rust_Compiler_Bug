{"sha": "7c4eecef0b256850166fdb0070568544f2380115", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNGVlY2VmMGIyNTY4NTAxNjZmZGIwMDcwNTY4NTQ0ZjIzODAxMTU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-10T11:27:11Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: pass ty::print::PrintCx by value.", "tree": {"sha": "a6f82b1a39d649155a64ab0fca88a6c463fdeebb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6f82b1a39d649155a64ab0fca88a6c463fdeebb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c4eecef0b256850166fdb0070568544f2380115", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4eecef0b256850166fdb0070568544f2380115", "html_url": "https://github.com/rust-lang/rust/commit/7c4eecef0b256850166fdb0070568544f2380115", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c4eecef0b256850166fdb0070568544f2380115/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0", "html_url": "https://github.com/rust-lang/rust/commit/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0"}], "stats": {"total": 802, "additions": 498, "deletions": 304}, "files": [{"sha": "6b1fea581e60f23466c516b4f99253d59b8c2d3d", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7c4eecef0b256850166fdb0070568544f2380115", "patch": "@@ -459,37 +459,52 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type Path = Vec<String>;\n \n             fn path_crate(\n-                self: &mut PrintCx<'_, '_, '_, Self>,\n+                self: PrintCx<'_, '_, '_, Self>,\n                 cnum: CrateNum,\n             ) -> Result<Self::Path, Self::Error> {\n                 Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n             }\n             fn path_qualified<'tcx>(\n-                self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-                _impl_prefix: Option<Self::Path>,\n+                self: PrintCx<'_, '_, 'tcx, Self>,\n                 _self_ty: Ty<'tcx>,\n                 _trait_ref: Option<ty::TraitRef<'tcx>>,\n                 _ns: Namespace,\n             ) -> Result<Self::Path, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n-            fn path_append(\n-                self: &mut PrintCx<'_, '_, '_, Self>,\n-                mut path: Self::Path,\n+\n+            fn path_append_impl<'gcx, 'tcx>(\n+                self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+                _print_prefix: impl FnOnce(\n+                    PrintCx<'_, 'gcx, 'tcx, Self>,\n+                ) -> Result<Self::Path, Self::Error>,\n+                _self_ty: Ty<'tcx>,\n+                _trait_ref: Option<ty::TraitRef<'tcx>>,\n+            ) -> Result<Self::Path, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+            fn path_append<'gcx, 'tcx>(\n+                self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+                print_prefix: impl FnOnce(\n+                    PrintCx<'_, 'gcx, 'tcx, Self>,\n+                ) -> Result<Self::Path, Self::Error>,\n                 text: &str,\n             ) -> Result<Self::Path, Self::Error> {\n+                let mut path = print_prefix(self)?;\n                 path.push(text.to_string());\n                 Ok(path)\n             }\n-            fn path_generic_args<'tcx>(\n-                self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-                path: Self::Path,\n+            fn path_generic_args<'gcx, 'tcx>(\n+                self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+                print_prefix: impl FnOnce(\n+                    PrintCx<'_, 'gcx, 'tcx, Self>,\n+                ) -> Result<Self::Path, Self::Error>,\n                 _params: &[ty::GenericParamDef],\n                 _substs: SubstsRef<'tcx>,\n                 _ns: Namespace,\n                 _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n             ) -> Result<Self::Path, Self::Error> {\n-                Ok(path)\n+                print_prefix(self)\n             }\n         }\n \n@@ -498,7 +513,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // module we could have false positives\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n                 let abs_path = |def_id| {\n-                    PrintCx::with(self.tcx, AbsolutePathPrinter, |mut cx| {\n+                    PrintCx::with(self.tcx, AbsolutePathPrinter, |cx| {\n                         cx.print_def_path(def_id, None, Namespace::TypeNS, iter::empty())\n                     })\n                 };"}, {"sha": "70ebb7111ef7aa5deba3383fee9b4c9d38485ce9", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7c4eecef0b256850166fdb0070568544f2380115", "patch": "@@ -2369,7 +2369,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 };\n \n                 // When printing regions, add trailing space if necessary.\n-                ty::print::PrintCx::with_tls_tcx(ty::print::FmtPrinter { fmt }, |cx| {\n+                ty::print::PrintCx::with_tls_tcx(ty::print::FmtPrinter::new(fmt), |cx| {\n                     let region = if cx.config.is_verbose || cx.config.identify_regions {\n                         let mut region = region.to_string();\n                         if region.len() > 0 {"}, {"sha": "986d65b2d9b6a374a3007f0775cb0a9c31dad505", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 252, "deletions": 135, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=7c4eecef0b256850166fdb0070568544f2380115", "patch": "@@ -88,7 +88,7 @@ pub struct PrintCx<'a, 'gcx, 'tcx, P> {\n     pub(crate) config: &'a mut PrintConfig,\n }\n \n-// HACK(eddyb) this is solely for `self: &mut PrintCx<Self>`, e.g. to\n+// HACK(eddyb) this is solely for `self: PrintCx<Self>`, e.g. to\n // implement traits on the printer and call the methods on the context.\n impl<P> Deref for PrintCx<'_, '_, '_, P> {\n     type Target = P;\n@@ -127,21 +127,29 @@ pub trait Print<'tcx, P> {\n     type Output;\n     type Error;\n \n-    fn print(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error>;\n+    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error>;\n     fn print_display(\n         &self,\n-        cx: &mut PrintCx<'_, '_, 'tcx, P>,\n+        cx: PrintCx<'_, '_, 'tcx, P>,\n     ) -> Result<Self::Output, Self::Error> {\n         let old_debug = cx.config.is_debug;\n         cx.config.is_debug = false;\n-        let result = self.print(cx);\n+        let result = self.print(PrintCx {\n+            tcx: cx.tcx,\n+            printer: cx.printer,\n+            config: cx.config,\n+        });\n         cx.config.is_debug = old_debug;\n         result\n     }\n-    fn print_debug(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+    fn print_debug(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n         let old_debug = cx.config.is_debug;\n         cx.config.is_debug = true;\n-        let result = self.print(cx);\n+        let result = self.print(PrintCx {\n+            tcx: cx.tcx,\n+            printer: cx.printer,\n+            config: cx.config,\n+        });\n         cx.config.is_debug = old_debug;\n         result\n     }\n@@ -153,7 +161,7 @@ pub trait Printer: Sized {\n     type Path;\n \n     fn print_def_path(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n@@ -162,7 +170,7 @@ pub trait Printer: Sized {\n         self.default_print_def_path(def_id, substs, ns, projections)\n     }\n     fn print_impl_path(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n         impl_def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n@@ -173,38 +181,69 @@ pub trait Printer: Sized {\n     }\n \n     fn path_crate(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n+        self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error>;\n     fn path_qualified(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        impl_prefix: Option<Self::Path>,\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n     ) -> Result<Self::Path, Self::Error>;\n-    fn path_append(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n-        path: Self::Path,\n+\n+    fn path_append_impl<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error>;\n+    fn path_append<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n         text: &str,\n     ) -> Result<Self::Path, Self::Error>;\n-    fn path_generic_args(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        path: Self::Path,\n+    fn path_generic_args<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n         params: &[ty::GenericParamDef],\n         substs: SubstsRef<'tcx>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<Self::Path, Self::Error>;\n }\n \n-#[must_use]\n-pub struct PrettyPath {\n-    pub empty: bool,\n+/// Trait for printers that pretty-print using `fmt::Write` to the printer.\n+pub trait PrettyPrinter: Printer<Error = fmt::Error, Path = Self> + fmt::Write {\n+    /// Enter a nested print context, for pretty-printing\n+    /// nested components in some larger context.\n+    fn nest<'a, 'gcx, 'tcx, E>(\n+        self: PrintCx<'a, 'gcx, 'tcx, Self>,\n+        f: impl for<'b> FnOnce(PrintCx<'b, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n+    ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n+        let printer = f(PrintCx {\n+            tcx: self.tcx,\n+            printer: self.printer,\n+            config: self.config,\n+        })?;\n+        Ok(PrintCx {\n+            tcx: self.tcx,\n+            printer,\n+            config: self.config,\n+        })\n+    }\n }\n \n-/// Trait for printers that pretty-print using `fmt::Write` to the printer.\n-pub trait PrettyPrinter: Printer<Error = fmt::Error, Path = PrettyPath> + fmt::Write {}\n+macro_rules! nest {\n+    ($cx:ident, $closure:expr) => {\n+        $cx = $cx.nest($closure)?\n+    }\n+}\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n@@ -231,7 +270,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let ns = self.guess_def_namespace(def_id);\n         debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n         let mut s = String::new();\n-        let _ = PrintCx::with(self, FmtPrinter { fmt: &mut s }, |mut cx| {\n+        let _ = PrintCx::with(self, FmtPrinter::new(&mut s), |cx| {\n             cx.print_def_path(def_id, None, ns, iter::empty())\n         });\n         s\n@@ -240,7 +279,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n     pub fn default_print_def_path(\n-        &mut self,\n+        self,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n@@ -273,48 +312,52 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n                 let generics = substs.map(|_| self.tcx.generics_of(def_id));\n                 let generics_parent = generics.as_ref().and_then(|g| g.parent);\n                 let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n-                let path = if let Some(generics_parent_def_id) = generics_parent {\n-                    assert_eq!(parent_def_id, generics_parent_def_id);\n-\n-                    // FIXME(eddyb) try to move this into the parent's printing\n-                    // logic, instead of doing it when printing the child.\n-                    let parent_generics = self.tcx.generics_of(parent_def_id);\n-                    let parent_has_own_self =\n-                        parent_generics.has_self && parent_generics.parent_count == 0;\n-                    if let (Some(substs), true) = (substs, parent_has_own_self) {\n-                        let trait_ref = ty::TraitRef::new(parent_def_id, substs);\n-                        self.path_qualified(None, trait_ref.self_ty(), Some(trait_ref), ns)?\n+                let print_parent_path = |cx: PrintCx<'_, 'gcx, 'tcx, P>| {\n+                    if let Some(generics_parent_def_id) = generics_parent {\n+                        assert_eq!(parent_def_id, generics_parent_def_id);\n+\n+                        // FIXME(eddyb) try to move this into the parent's printing\n+                        // logic, instead of doing it when printing the child.\n+                        let parent_generics = cx.tcx.generics_of(parent_def_id);\n+                        let parent_has_own_self =\n+                            parent_generics.has_self && parent_generics.parent_count == 0;\n+                        if let (Some(substs), true) = (substs, parent_has_own_self) {\n+                            let trait_ref = ty::TraitRef::new(parent_def_id, substs);\n+                            cx.path_qualified(trait_ref.self_ty(), Some(trait_ref), ns)\n+                        } else {\n+                            cx.print_def_path(parent_def_id, substs, ns, iter::empty())\n+                        }\n                     } else {\n-                        self.print_def_path(parent_def_id, substs, ns, iter::empty())?\n+                        cx.print_def_path(parent_def_id, None, ns, iter::empty())\n                     }\n-                } else {\n-                    self.print_def_path(parent_def_id, None, ns, iter::empty())?\n                 };\n-                let path = match key.disambiguated_data.data {\n-                    // Skip `::{{constructor}}` on tuple/unit structs.\n-                    DefPathData::StructCtor => path,\n-\n-                    _ => {\n-                        self.path_append(\n-                            path,\n-                            &key.disambiguated_data.data.as_interned_str().as_str(),\n-                        )?\n+                let print_path = |cx: PrintCx<'_, 'gcx, 'tcx, P>| {\n+                    match key.disambiguated_data.data {\n+                        // Skip `::{{constructor}}` on tuple/unit structs.\n+                        DefPathData::StructCtor => print_parent_path(cx),\n+\n+                        _ => {\n+                            cx.path_append(\n+                                print_parent_path,\n+                                &key.disambiguated_data.data.as_interned_str().as_str(),\n+                            )\n+                        }\n                     }\n                 };\n \n                 if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let has_own_self = generics.has_self && generics.parent_count == 0;\n                     let params = &generics.params[has_own_self as usize..];\n-                    self.path_generic_args(path, params, substs, ns, projections)\n+                    self.path_generic_args(print_path, params, substs, ns, projections)\n                 } else {\n-                    Ok(path)\n+                    print_path(self)\n                 }\n             }\n         }\n     }\n \n     fn default_print_impl_path(\n-        &mut self,\n+        self,\n         impl_def_id: DefId,\n         _substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n@@ -339,18 +382,20 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n             Some(trait_ref) => self.tcx.parent(trait_ref.def_id) == Some(parent_def_id),\n         };\n \n-        let prefix_path = if !in_self_mod && !in_trait_mod {\n+        if !in_self_mod && !in_trait_mod {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            Some(self.print_def_path(parent_def_id, None, ns, iter::empty())?)\n+            self.path_append_impl(\n+                |cx| cx.print_def_path(parent_def_id, None, ns, iter::empty()),\n+                self_ty,\n+                impl_trait_ref,\n+            )\n         } else {\n             // Otherwise, try to give a good form that would be valid language\n             // syntax. Preferably using associated item notation.\n-            None\n-        };\n-\n-        self.path_qualified(prefix_path, self_ty, impl_trait_ref, ns)\n+            self.path_qualified(self_ty, impl_trait_ref, ns)\n+        }\n     }\n }\n \n@@ -403,14 +448,27 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n }\n \n pub struct FmtPrinter<F: fmt::Write> {\n-    pub fmt: F,\n+    pub(crate) fmt: F,\n+    empty: bool,\n }\n \n-impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n+impl<F: fmt::Write> FmtPrinter<F> {\n+    pub fn new(fmt: F) -> Self {\n+        FmtPrinter {\n+            fmt,\n+            empty: true,\n+        }\n+    }\n+}\n+\n+impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n     /// If possible, this returns a global path resolving to `def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    fn try_print_visible_def_path(&mut self, def_id: DefId) -> Result<Option<P::Path>, P::Error> {\n+    fn try_print_visible_def_path(\n+        mut self,\n+        def_id: DefId,\n+    ) -> Result<(P, bool), P::Error> {\n         debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n \n         // If `def_id` is a direct or injected extern crate, return the\n@@ -419,7 +477,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             let cnum = def_id.krate;\n \n             if cnum == LOCAL_CRATE {\n-                return Ok(Some(self.path_crate(cnum)?));\n+                return Ok((self.path_crate(cnum)?, true));\n             }\n \n             // In local mode, when we encounter a crate other than\n@@ -440,22 +498,21 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n                     ..\n                 }) => {\n                     debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n-                    let path = if !span.is_dummy() {\n+                    return Ok((if !span.is_dummy() {\n                         self.print_def_path(def_id, None, Namespace::TypeNS, iter::empty())?\n                     } else {\n                         self.path_crate(cnum)?\n-                    };\n-                    return Ok(Some(path));\n+                    }, true));\n                 }\n                 None => {\n-                    return Ok(Some(self.path_crate(cnum)?));\n+                    return Ok((self.path_crate(cnum)?, true));\n                 }\n                 _ => {},\n             }\n         }\n \n         if def_id.is_local() {\n-            return Ok(None);\n+            return Ok((self.printer, false));\n         }\n \n         let visible_parent_map = self.tcx.visible_parent_map(LOCAL_CRATE);\n@@ -475,11 +532,20 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n \n         let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n             Some(parent) => parent,\n-            None => return Ok(None),\n+            None => return Ok((self.printer, false)),\n         };\n-        let path = match self.try_print_visible_def_path(visible_parent)? {\n-            Some(path) => path,\n-            None => return Ok(None),\n+        // HACK(eddyb) this uses `nest` to avoid knowing ahead of time whether\n+        // the entire path will succeed or not. To support printers that do not\n+        // implement `PrettyPrinter`, a `Vec` or linked list on the stack would\n+        // need to be built, before starting to print anything.\n+        let mut prefix_success = false;\n+        nest!(self, |cx| {\n+            let (printer, success) = cx.try_print_visible_def_path(visible_parent)?;\n+            prefix_success = success;\n+            Ok(printer)\n+        });\n+        if !prefix_success {\n+            return Ok((self.printer, false));\n         };\n         let actual_parent = self.tcx.parent(def_id);\n \n@@ -541,29 +607,15 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             },\n         };\n         debug!(\"try_print_visible_def_path: symbol={:?}\", symbol);\n-        Ok(Some(self.path_append(path, &symbol)?))\n+        Ok((self.path_append(|cx| Ok(cx.printer), &symbol)?, true))\n     }\n \n     pub fn pretty_path_qualified(\n-        &mut self,\n-        impl_prefix: Option<P::Path>,\n+        mut self,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n     ) -> Result<P::Path, P::Error> {\n-        if let Some(prefix) = impl_prefix {\n-            // HACK(eddyb) going through `path_append` means symbol name\n-            // computation gets to handle its equivalent of `::` correctly.\n-            let _ = self.path_append(prefix, \"<impl \")?;\n-            if let Some(trait_ref) = trait_ref {\n-                trait_ref.print_display(self)?;\n-                write!(self.printer, \" for \")?;\n-            }\n-            self_ty.print_display(self)?;\n-            write!(self.printer, \">\")?;\n-            return Ok(PrettyPath { empty: false });\n-        }\n-\n         if trait_ref.is_none() {\n             // Inherent impls. Try to print `Foo::bar` for an inherent\n             // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n@@ -578,37 +630,62 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n \n                 ty::Bool | ty::Char | ty::Str |\n                 ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n-                    self_ty.print_display(self)?;\n-                    return Ok(PrettyPath { empty: false });\n+                    return self_ty.print_display(self);\n                 }\n \n                 _ => {}\n             }\n         }\n \n         write!(self.printer, \"<\")?;\n-        self_ty.print_display(self)?;\n+        nest!(self, |cx| self_ty.print_display(cx));\n         if let Some(trait_ref) = trait_ref {\n             write!(self.printer, \" as \")?;\n-            let _ = self.print_def_path(\n+            nest!(self, |cx| cx.print_def_path(\n                 trait_ref.def_id,\n                 Some(trait_ref.substs),\n                 Namespace::TypeNS,\n                 iter::empty(),\n-            )?;\n+            ));\n         }\n         write!(self.printer, \">\")?;\n-        Ok(PrettyPath { empty: false })\n+\n+        Ok(self.printer)\n+    }\n+\n+    pub fn pretty_path_append_impl(\n+        mut self,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, P>,\n+        ) -> Result<P::Path, P::Error>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<P::Path, P::Error> {\n+        // HACK(eddyb) going through `path_append` means symbol name\n+        // computation gets to handle its equivalent of `::` correctly.\n+        nest!(self, |cx| cx.path_append(print_prefix, \"<impl \"));\n+        if let Some(trait_ref) = trait_ref {\n+            nest!(self, |cx| trait_ref.print_display(cx));\n+            write!(self.printer, \" for \")?;\n+        }\n+        nest!(self, |cx| self_ty.print_display(cx));\n+        write!(self.printer, \">\")?;\n+\n+        Ok(self.printer)\n     }\n \n     pub fn pretty_path_generic_args(\n-        &mut self,\n-        path: P::Path,\n+        mut self,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, P>,\n+        ) -> Result<P::Path, P::Error>,\n         params: &[ty::GenericParamDef],\n         substs: SubstsRef<'tcx>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<P::Path, P::Error> {\n+        nest!(self, |cx| print_prefix(cx));\n+\n         let mut empty = true;\n         let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n             write!(cx.printer, \"{}\", if empty {\n@@ -652,21 +729,21 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n                     if !print_regions {\n                         continue;\n                     }\n-                    start_or_continue(self, start, \", \")?;\n-                    if !region.display_outputs_anything(self) {\n+                    start_or_continue(&mut self, start, \", \")?;\n+                    if !region.display_outputs_anything(&self) {\n                         // This happens when the value of the region\n                         // parameter is not easily serialized. This may be\n                         // because the user omitted it in the first place,\n                         // or because it refers to some block in the code,\n                         // etc. I'm not sure how best to serialize this.\n                         write!(self.printer, \"'_\")?;\n                     } else {\n-                        region.print_display(self)?;\n+                        nest!(self, |cx| region.print_display(cx));\n                     }\n                 }\n                 UnpackedKind::Type(ty) => {\n-                    start_or_continue(self, start, \", \")?;\n-                    ty.print_display(self)?;\n+                    start_or_continue(&mut self, start, \", \")?;\n+                    nest!(self, |cx| ty.print_display(cx));\n                 }\n                 UnpackedKind::Const(ct) => {\n                     start_or_continue(self, start, \", \")?;\n@@ -676,31 +753,32 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n         }\n \n         for projection in projections {\n-            start_or_continue(self, start, \", \")?;\n+            start_or_continue(&mut self, start, \", \")?;\n             write!(self.printer, \"{}=\",\n                    self.tcx.associated_item(projection.item_def_id).ident)?;\n-            projection.ty.print_display(self)?;\n+            nest!(self, |cx| projection.ty.print_display(cx));\n         }\n \n-        start_or_continue(self, \"\", \">\")?;\n+        start_or_continue(&mut self, \"\", \">\")?;\n \n-        Ok(path)\n+        Ok(self.printer)\n     }\n }\n \n impl<F: fmt::Write> fmt::Write for FmtPrinter<F> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.empty &= s.is_empty();\n         self.fmt.write_str(s)\n     }\n }\n \n impl<F: fmt::Write> Printer for FmtPrinter<F> {\n     type Error = fmt::Error;\n \n-    type Path = PrettyPath;\n+    type Path = Self;\n \n     fn print_def_path(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        mut self: PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n@@ -710,15 +788,20 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         // both here and in `default_print_def_path`.\n         let generics = substs.map(|_| self.tcx.generics_of(def_id));\n         if generics.as_ref().and_then(|g| g.parent).is_none() {\n-            if let Some(path) = self.try_print_visible_def_path(def_id)? {\n-                let path = if let (Some(generics), Some(substs)) = (generics, substs) {\n+            let mut visible_path_success = false;\n+            nest!(self, |cx| {\n+                let (printer, success) = cx.try_print_visible_def_path(def_id)?;\n+                visible_path_success = success;\n+                Ok(printer)\n+            });\n+            if visible_path_success {\n+                return if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let has_own_self = generics.has_self && generics.parent_count == 0;\n                     let params = &generics.params[has_own_self as usize..];\n-                    self.path_generic_args(path, params, substs, ns, projections)?\n+                    self.path_generic_args(|cx| Ok(cx.printer), params, substs, ns, projections)\n                 } else {\n-                    path\n+                    Ok(self.printer)\n                 };\n-                return Ok(path);\n             }\n         }\n \n@@ -738,69 +821,103 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n                 // pretty printing some span information. This should\n                 // only occur very early in the compiler pipeline.\n                 let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n-                let path = self.print_def_path(parent_def_id, None, ns, iter::empty())?;\n                 let span = self.tcx.def_span(def_id);\n-                return self.path_append(path, &format!(\"<impl at {:?}>\", span));\n+                return self.path_append(\n+                    |cx| cx.print_def_path(parent_def_id, None, ns, iter::empty()),\n+                    &format!(\"<impl at {:?}>\", span),\n+                );\n             }\n         }\n \n         self.default_print_def_path(def_id, substs, ns, projections)\n     }\n \n     fn path_crate(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n+        mut self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error> {\n         if cnum == LOCAL_CRATE {\n             if self.tcx.sess.rust_2018() {\n                 // We add the `crate::` keyword on Rust 2018, only when desired.\n                 if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n                     write!(self.printer, \"{}\", keywords::Crate.name())?;\n-                    return Ok(PrettyPath { empty: false });\n                 }\n             }\n-            Ok(PrettyPath { empty: true })\n+            Ok(self.printer)\n         } else {\n             write!(self.printer, \"{}\", self.tcx.crate_name(cnum))?;\n-            Ok(PrettyPath { empty: false })\n+            Ok(self.printer)\n         }\n     }\n     fn path_qualified(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        impl_prefix: Option<Self::Path>,\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_qualified(impl_prefix, self_ty, trait_ref, ns)\n+        self.pretty_path_qualified(self_ty, trait_ref, ns)\n     }\n-    fn path_append(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n-        path: Self::Path,\n+\n+    fn path_append_impl<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.pretty_path_append_impl(print_prefix, self_ty, trait_ref)\n+    }\n+    fn path_append<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n         text: &str,\n     ) -> Result<Self::Path, Self::Error> {\n-        // FIXME(eddyb) this shouldn't happen, but is currently\n-        // the case for `extern { ... }` \"foreign modules\".\n-        if text.is_empty() {\n-            return Ok(path);\n-        }\n+        let mut printer = print_prefix(self)?;\n \n-        if !path.empty {\n-            write!(self.printer, \"::\")?;\n+        // FIXME(eddyb) `text` should never be empty, but it\n+        // currently is for `extern { ... }` \"foreign modules\".\n+        if !text.is_empty() {\n+            if !printer.empty {\n+                write!(printer, \"::\")?;\n+            }\n+            write!(printer, \"{}\", text)?;\n         }\n-        write!(self.printer, \"{}\", text)?;\n-        Ok(PrettyPath { empty: false })\n+\n+        Ok(printer)\n     }\n-    fn path_generic_args(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        path: Self::Path,\n+    fn path_generic_args<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n         params: &[ty::GenericParamDef],\n         substs: SubstsRef<'tcx>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_generic_args(path, params, substs, ns, projections)\n+        self.pretty_path_generic_args(print_prefix, params, substs, ns, projections)\n     }\n }\n \n-impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {}\n+impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n+    fn nest<'a, 'gcx, 'tcx, E>(\n+        mut self: PrintCx<'a, 'gcx, 'tcx, Self>,\n+        f: impl for<'b> FnOnce(PrintCx<'b, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n+    ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n+        let was_empty = std::mem::replace(&mut self.printer.empty, true);\n+        let mut printer = f(PrintCx {\n+            tcx: self.tcx,\n+            printer: self.printer,\n+            config: self.config,\n+        })?;\n+        printer.empty &= was_empty;\n+        Ok(PrintCx {\n+            tcx: self.tcx,\n+            printer,\n+            config: self.config,\n+        })\n+    }\n+}"}, {"sha": "ff5d9335909eee7fee9d5864872ef7ed4248db1e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 113, "deletions": 92, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7c4eecef0b256850166fdb0070568544f2380115", "patch": "@@ -161,8 +161,9 @@ impl RegionHighlightMode {\n macro_rules! gen_display_debug_body {\n     ( $with:path ) => {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            PrintCx::with_tls_tcx(FmtPrinter { fmt: f }, |mut cx| {\n-                $with(&cx.tcx.lift(self).expect(\"could not lift for printing\"), &mut cx)\n+            PrintCx::with_tls_tcx(FmtPrinter::new(f), |cx| {\n+                $with(&cx.tcx.lift(self).expect(\"could not lift for printing\"), cx)?;\n+                Ok(())\n             })\n         }\n     };\n@@ -193,27 +194,35 @@ macro_rules! gen_display_debug {\n macro_rules! gen_print_impl {\n     ( ($($x:tt)+) $target:ty, ($self:ident, $cx:ident) $disp:block $dbg:block ) => {\n         impl<$($x)+, P: PrettyPrinter> Print<'tcx, P> for $target {\n-            type Output = ();\n+            type Output = P;\n             type Error = fmt::Error;\n-            fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, P>) -> fmt::Result {\n-                Ok({\n+            fn print(&$self, $cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+                #[allow(unused_mut)]\n+                let mut $cx = $cx;\n+                let _: () = {\n                     define_scoped_cx!($cx);\n+\n                     if $cx.config.is_debug $dbg\n                     else $disp\n-                })\n+                };\n+                Ok($cx.printer)\n             }\n         }\n     };\n     ( () $target:ty, ($self:ident, $cx:ident) $disp:block $dbg:block ) => {\n         impl<P: PrettyPrinter> Print<'tcx, P> for $target {\n-            type Output = ();\n+            type Output = P;\n             type Error = fmt::Error;\n-            fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, P>) -> fmt::Result {\n-                Ok({\n+            fn print(&$self, $cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+                #[allow(unused_mut)]\n+                let mut $cx = $cx;\n+                let _: () = {\n                     define_scoped_cx!($cx);\n+\n                     if $cx.config.is_debug $dbg\n                     else $disp\n-                })\n+                };\n+                Ok($cx.printer)\n             }\n         }\n     };\n@@ -251,18 +260,23 @@ macro_rules! define_print_multi {\n         $(define_print! { $generic $target, $vars $def })*\n     };\n }\n+macro_rules! nest {\n+    ($closure:expr) => {\n+        scoped_cx!() = scoped_cx!().nest($closure)?\n+    }\n+}\n macro_rules! print_inner {\n     (write ($($data:expr),+)) => {\n-        write!(scoped_cx!().printer, $($data),+)\n+        write!(scoped_cx!().printer, $($data),+)?\n     };\n     ($kind:ident ($data:expr)) => {\n-        $data.$kind(scoped_cx!())\n+        nest!(|cx| $data.$kind(cx))\n     };\n }\n macro_rules! p {\n     ($($kind:ident $data:tt),+) => {\n         {\n-            $(print_inner!($kind $data)?);+\n+            $(print_inner!($kind $data));+\n         }\n     };\n }\n@@ -277,11 +291,11 @@ macro_rules! define_scoped_cx {\n \n impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n     fn fn_sig(\n-        &mut self,\n+        mut self,\n         inputs: &[Ty<'tcx>],\n         c_variadic: bool,\n         output: Ty<'tcx>,\n-    ) -> fmt::Result {\n+    ) -> Result<P, fmt::Error> {\n         define_scoped_cx!(self);\n \n         p!(write(\"(\"));\n@@ -300,11 +314,11 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             p!(write(\" -> \"), print_display(output));\n         }\n \n-        Ok(())\n+        Ok(self.printer)\n     }\n \n-    fn in_binder<T>(&mut self, value: &ty::Binder<T>) -> Result<T::Output, fmt::Error>\n-        where T: Print<'tcx, P, Error = fmt::Error> + TypeFoldable<'tcx>\n+    fn in_binder<T>(mut self, value: &ty::Binder<T>) -> Result<P, fmt::Error>\n+        where T: Print<'tcx, P, Output = P, Error = fmt::Error> + TypeFoldable<'tcx>\n     {\n         fn name_by_region_index(index: usize) -> InternedString {\n             match index {\n@@ -341,7 +355,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n         let old_region_index = self.config.region_index;\n         let mut region_index = old_region_index;\n         let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n-            let _ = start_or_continue(self, \"for<\", \", \");\n+            let _ = start_or_continue(&mut self, \"for<\", \", \");\n             let br = match br {\n                 ty::BrNamed(_, name) => {\n                     let _ = write!(self.printer, \"{}\", name);\n@@ -363,12 +377,16 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             };\n             self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n         }).0;\n-        start_or_continue(self, \"\", \"> \")?;\n+        start_or_continue(&mut self, \"\", \"> \")?;\n \n         // Push current state to gcx, and restore after writing new_value.\n         self.config.binder_depth += 1;\n         self.config.region_index = region_index;\n-        let result = new_value.print_display(self);\n+        let result = new_value.print_display(PrintCx {\n+            tcx: self.tcx,\n+            printer: self.printer,\n+            config: self.config,\n+        });\n         self.config.region_index = old_region_index;\n         self.config.binder_depth -= 1;\n         result\n@@ -388,9 +406,9 @@ pub fn parameterized<F: fmt::Write>(\n     substs: SubstsRef<'_>,\n     ns: Namespace,\n ) -> fmt::Result {\n-    PrintCx::with_tls_tcx(FmtPrinter { fmt: f }, |mut cx| {\n+    PrintCx::with_tls_tcx(FmtPrinter::new(f), |cx| {\n         let substs = cx.tcx.lift(&substs).expect(\"could not lift for printing\");\n-        let _ = cx.print_def_path(did, Some(substs), ns, iter::empty())?;\n+        cx.print_def_path(did, Some(substs), ns, iter::empty())?;\n         Ok(())\n     })\n }\n@@ -410,13 +428,13 @@ define_print! {\n                     if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n                         let mut projections = self.projection_bounds();\n                         if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                            let _ = cx.print_def_path(\n+                            nest!(|cx| cx.print_def_path(\n                                 principal.def_id,\n                                 None,\n                                 Namespace::TypeNS,\n                                 iter::empty(),\n-                            )?;\n-                            cx.fn_sig(args, false, proj.ty)?;\n+                            ));\n+                            nest!(|cx| cx.fn_sig(args, false, proj.ty));\n                             resugared_principal = true;\n                         }\n                     }\n@@ -426,12 +444,12 @@ define_print! {\n                     // Use a type that can't appear in defaults of type parameters.\n                     let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n                     let principal = principal.with_self_ty(cx.tcx, dummy_self);\n-                    let _ = cx.print_def_path(\n+                    nest!(|cx| cx.print_def_path(\n                         principal.def_id,\n                         Some(principal.substs),\n                         Namespace::TypeNS,\n                         self.projection_bounds(),\n-                    )?;\n+                    ));\n                 }\n                 first = false;\n             }\n@@ -458,12 +476,12 @@ define_print! {\n                 }\n                 first = false;\n \n-                let _ = cx.print_def_path(\n+                nest!(|cx| cx.print_def_path(\n                     def_id,\n                     None,\n                     Namespace::TypeNS,\n                     iter::empty(),\n-                )?;\n+                ));\n             }\n         }\n     }\n@@ -486,8 +504,8 @@ impl fmt::Debug for ty::GenericParamDef {\n \n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter { fmt: f }, |mut cx| {\n-            let _ = cx.print_def_path(\n+        PrintCx::with_tls_tcx(FmtPrinter::new(f), |cx| {\n+            cx.print_def_path(\n                 self.def_id,\n                 None,\n                 Namespace::TypeNS,\n@@ -500,8 +518,8 @@ impl fmt::Debug for ty::TraitDef {\n \n impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter { fmt: f }, |mut cx| {\n-            let _ = cx.print_def_path(\n+        PrintCx::with_tls_tcx(FmtPrinter::new(f), |cx| {\n+            cx.print_def_path(\n                 self.did,\n                 None,\n                 Namespace::TypeNS,\n@@ -522,7 +540,7 @@ impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n \n impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter { fmt: f }, |mut cx| {\n+        PrintCx::with_tls_tcx(FmtPrinter::new(f), |mut cx| {\n             define_scoped_cx!(cx);\n             p!(write(\"UpvarId({:?};`{}`;{:?})\",\n                 self.var_path.hir_id,\n@@ -571,9 +589,10 @@ define_print! {\n         display {\n             let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n \n-            p!(print_display(ty::Binder::bind(*self)\n+            let trait_ref = *ty::Binder::bind(*self)\n                 .with_self_ty(cx.tcx, dummy_self)\n-                .skip_binder()))\n+                .skip_binder();\n+            p!(print_display(trait_ref))\n         }\n         debug {\n             p!(print_display(self))\n@@ -599,7 +618,7 @@ define_print! {\n             if let BrNamed(_, name) = *self {\n                 if name != \"\" && name != \"'_\" {\n                     p!(write(\"{}\", name));\n-                    return Ok(());\n+                    return Ok(cx.printer);\n                 }\n             }\n \n@@ -628,7 +647,7 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::BoundRegion {\n-    fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool {\n         if cx.config.is_verbose {\n             return true;\n         }\n@@ -671,7 +690,7 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::PlaceholderRegion {\n-    fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool {\n         if cx.config.is_verbose {\n             return true;\n         }\n@@ -695,7 +714,7 @@ define_print! {\n             // Watch out for region highlights.\n             if let Some(n) = RegionHighlightMode::get().region_highlighted(self) {\n                 p!(write(\"'{:?}\", n));\n-                return Ok(());\n+                return Ok(cx.printer);\n             }\n \n             // These printouts are concise.  They do not contain all the information\n@@ -798,7 +817,7 @@ define_print! {\n // NB: this must be kept in sync with the printing logic above.\n impl ty::RegionKind {\n     // HACK(eddyb) `pub(crate)` only for `ty::print`.\n-    pub(crate) fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n+    pub(crate) fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool {\n         if cx.config.is_verbose {\n             return true;\n         }\n@@ -867,7 +886,7 @@ define_print! {\n             }\n \n             p!(write(\"fn\"));\n-            cx.fn_sig(self.inputs(), self.c_variadic, self.output())?\n+            nest!(|cx| cx.fn_sig(self.inputs(), self.c_variadic, self.output()));\n         }\n         debug {\n             p!(write(\"({:?}; c_variadic: {})->{:?}\",\n@@ -929,7 +948,7 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::RegionVid {\n-    fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool {\n         if cx.config.is_verbose {\n             return true;\n         }\n@@ -1011,23 +1030,23 @@ define_print_multi! {\n     ]\n     (self, cx) {\n         display {\n-            cx.in_binder(self)?\n+            nest!(|cx| cx.in_binder(self))\n         }\n     }\n }\n \n define_print! {\n     ('tcx) ty::TraitRef<'tcx>, (self, cx) {\n         display {\n-            let _ = cx.print_def_path(\n+            nest!(|cx| cx.print_def_path(\n                 self.def_id,\n                 Some(self.substs),\n                 Namespace::TypeNS,\n                 iter::empty(),\n-            )?;\n+            ));\n         }\n         debug {\n-            let _ = cx.path_qualified(None, self.self_ty(), Some(*self), Namespace::TypeNS)?;\n+            nest!(|cx| cx.path_qualified(self.self_ty(), Some(*self), Namespace::TypeNS));\n         }\n     }\n }\n@@ -1050,7 +1069,7 @@ define_print! {\n                 }\n                 Ref(r, ty, mutbl) => {\n                     p!(write(\"&\"));\n-                    if r.display_outputs_anything(cx) {\n+                    if r.display_outputs_anything(&cx) {\n                         p!(print_display(r), write(\" \"));\n                     }\n                     p!(print(ty::TypeAndMut { ty, mutbl }))\n@@ -1073,12 +1092,12 @@ define_print! {\n                 FnDef(def_id, substs) => {\n                     let sig = cx.tcx.fn_sig(def_id).subst(cx.tcx, substs);\n                     p!(print(sig), write(\" {{\"));\n-                    let _ = cx.print_def_path(\n+                    nest!(|cx| cx.print_def_path(\n                         def_id,\n                         Some(substs),\n                         Namespace::ValueNS,\n                         iter::empty(),\n-                    )?;\n+                    ));\n                     p!(write(\"}}\"))\n                 }\n                 FnPtr(ref bare_fn) => {\n@@ -1101,15 +1120,15 @@ define_print! {\n                     }\n                 }\n                 Adt(def, substs) => {\n-                    let _ = cx.print_def_path(\n+                    nest!(|cx| cx.print_def_path(\n                         def.did,\n                         Some(substs),\n                         Namespace::TypeNS,\n                         iter::empty(),\n-                    )?;\n+                    ));\n                 }\n                 Dynamic(data, r) => {\n-                    let print_r = r.display_outputs_anything(cx);\n+                    let print_r = r.display_outputs_anything(&cx);\n                     if print_r {\n                         p!(write(\"(\"));\n                     }\n@@ -1119,26 +1138,24 @@ define_print! {\n                     }\n                 }\n                 Foreign(def_id) => {\n-                    let _ = cx.print_def_path(\n+                    nest!(|cx| cx.print_def_path(\n                         def_id,\n                         None,\n                         Namespace::TypeNS,\n                         iter::empty(),\n-                    )?;\n+                    ));\n                 }\n                 Projection(ref data) => p!(print(data)),\n                 UnnormalizedProjection(ref data) => {\n-                    p!(write(\"Unnormalized(\"));\n-                    data.print(cx)?;\n-                    p!(write(\")\"))\n+                    p!(write(\"Unnormalized(\"), print(data), write(\")\"))\n                 }\n                 Placeholder(placeholder) => {\n                     p!(write(\"Placeholder({:?})\", placeholder))\n                 }\n                 Opaque(def_id, substs) => {\n                     if cx.config.is_verbose {\n                         p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n-                        return Ok(());\n+                        return Ok(cx.printer);\n                     }\n \n                     let def_key = cx.tcx.def_key(def_id);\n@@ -1154,7 +1171,7 @@ define_print! {\n                             }\n                             p!(write(\">\"));\n                         }\n-                        return Ok(());\n+                        return Ok(cx.printer);\n                     }\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id.\n@@ -1197,17 +1214,19 @@ define_print! {\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n                         p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)));\n                         let mut sep = \" \";\n-                        cx.tcx.with_freevars(hir_id, |freevars| {\n-                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                p!(\n-                                       write(\"{}{}:\",\n-                                             sep,\n-                                             cx.tcx.hir().name(freevar.var_id())),\n-                                       print(upvar_ty));\n-                                sep = \", \";\n-                            }\n-                            Ok(())\n-                        })?\n+                        for (freevar, upvar_ty) in cx.tcx.freevars(did)\n+                            .as_ref()\n+                            .map_or(&[][..], |fv| &fv[..])\n+                            .iter()\n+                            .zip(upvar_tys)\n+                        {\n+                            p!(\n+                                write(\"{}{}:\",\n+                                        sep,\n+                                        cx.tcx.hir().name(freevar.var_id())),\n+                                print(upvar_ty));\n+                            sep = \", \";\n+                        }\n                     } else {\n                         // cross-crate closure types should only be\n                         // visible in codegen bug reports, I imagine.\n@@ -1224,7 +1243,7 @@ define_print! {\n                     p!(write(\" \"), print(witness), write(\"]\"))\n                 },\n                 GeneratorWitness(types) => {\n-                    cx.in_binder(&types)?\n+                    nest!(|cx| cx.in_binder(&types))\n                 }\n                 Closure(did, substs) => {\n                     let upvar_tys = substs.upvar_tys(did, cx.tcx);\n@@ -1238,17 +1257,19 @@ define_print! {\n                             p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)));\n                         }\n                         let mut sep = \" \";\n-                        cx.tcx.with_freevars(hir_id, |freevars| {\n-                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                p!(\n-                                       write(\"{}{}:\",\n-                                             sep,\n-                                             cx.tcx.hir().name(freevar.var_id())),\n-                                       print(upvar_ty));\n-                                sep = \", \";\n-                            }\n-                            Ok(())\n-                        })?\n+                        for (freevar, upvar_ty) in cx.tcx.freevars(did)\n+                            .as_ref()\n+                            .map_or(&[][..], |fv| &fv[..])\n+                            .iter()\n+                            .zip(upvar_tys)\n+                        {\n+                            p!(\n+                                write(\"{}{}:\",\n+                                        sep,\n+                                        cx.tcx.hir().name(freevar.var_id())),\n+                                print(upvar_ty));\n+                            sep = \", \";\n+                        }\n                     } else {\n                         // cross-crate closure types should only be\n                         // visible in codegen bug reports, I imagine.\n@@ -1406,12 +1427,12 @@ define_print! {\n define_print! {\n     ('tcx) ty::ProjectionTy<'tcx>, (self, cx) {\n         display {\n-            let _ = cx.print_def_path(\n+            nest!(|cx| cx.print_def_path(\n                 self.item_def_id,\n                 Some(self.substs),\n                 Namespace::TypeNS,\n                 iter::empty(),\n-            )?;\n+            ));\n         }\n     }\n }\n@@ -1440,32 +1461,32 @@ define_print! {\n                 ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n                     p!(write(\"the trait `\"));\n-                    let _ = cx.print_def_path(\n+                    nest!(|cx| cx.print_def_path(\n                         trait_def_id,\n                         None,\n                         Namespace::TypeNS,\n                         iter::empty(),\n-                    )?;\n+                    ));\n                     p!(write(\"` is object-safe\"))\n                 }\n                 ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                     p!(write(\"the closure `\"));\n-                    let _ = cx.print_def_path(\n+                    nest!(|cx| cx.print_def_path(\n                         closure_def_id,\n                         None,\n                         Namespace::ValueNS,\n                         iter::empty(),\n-                    )?;\n+                    ));\n                     p!(write(\"` implements the trait `{}`\", kind))\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                     p!(write(\"the constant `\"));\n-                    let _ = cx.print_def_path(\n+                    nest!(|cx| cx.print_def_path(\n                         def_id,\n                         Some(substs),\n                         Namespace::ValueNS,\n                         iter::empty(),\n-                    )?;\n+                    ));\n                     p!(write(\"` can be evaluated\"))\n                 }\n             }"}, {"sha": "2f9627331189f7e3faec2f4bb11644ec4a300005", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 69, "deletions": 48, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=7c4eecef0b256850166fdb0070568544f2380115", "patch": "@@ -93,7 +93,7 @@ use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::print::{PrettyPath, PrettyPrinter, PrintCx, Printer};\n+use rustc::ty::print::{PrettyPrinter, PrintCx, Printer};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -225,9 +225,10 @@ fn get_symbol_hash<'a, 'tcx>(\n }\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n-    PrintCx::with(tcx, SymbolPath::new(tcx), |mut cx| {\n-        let _ = cx.print_def_path(def_id, None, Namespace::ValueNS, iter::empty());\n-        cx.printer.into_interned()\n+    PrintCx::with(tcx, SymbolPath::new(tcx), |cx| {\n+        cx.print_def_path(def_id, None, Namespace::ValueNS, iter::empty())\n+            .unwrap()\n+            .into_interned()\n     })\n }\n \n@@ -348,7 +349,7 @@ struct SymbolPath {\n     temp_buf: String,\n     strict_naming: bool,\n \n-    // When `true`, `finalize_pending_component` is a noop.\n+    // When `true`, `finalize_pending_component` isn't used.\n     // This is needed when recursing into `path_qualified`,\n     // or `path_generic_args`, as any nested paths are\n     // logically within one component.\n@@ -407,18 +408,17 @@ impl SymbolPath {\n impl Printer for SymbolPath {\n     type Error = fmt::Error;\n \n-    type Path = PrettyPath;\n+    type Path = Self;\n \n     fn path_crate(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n+        mut self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error> {\n         self.printer.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n-        Ok(PrettyPath { empty: false })\n+        Ok(self.printer)\n     }\n     fn path_qualified(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        impl_prefix: Option<Self::Path>,\n+        mut self: PrintCx<'_, '_, 'tcx, Self>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n@@ -429,64 +429,85 @@ impl Printer for SymbolPath {\n             ty::Adt(..) | ty::Foreign(_) |\n             ty::Bool | ty::Char | ty::Str |\n             ty::Int(_) | ty::Uint(_) | ty::Float(_)\n-                if impl_prefix.is_none() && trait_ref.is_none() =>\n+                if trait_ref.is_none() =>\n             {\n-                return self.pretty_path_qualified(None, self_ty, trait_ref, ns);\n+                return self.pretty_path_qualified(self_ty, trait_ref, ns);\n             }\n             _ => {}\n         }\n \n-        // HACK(eddyb) make sure to finalize the last component of the\n-        // `impl` prefix, to avoid it fusing with the following text.\n-        let impl_prefix = match impl_prefix {\n-            Some(prefix) => {\n-                let mut prefix = self.path_append(prefix, \"\")?;\n-\n-                // HACK(eddyb) also avoid an unnecessary `::`.\n-                prefix.empty = true;\n-\n-                Some(prefix)\n-            }\n-            None => None,\n-        };\n-\n         let kept_within_component = mem::replace(&mut self.printer.keep_within_component, true);\n-        let r = self.pretty_path_qualified(impl_prefix, self_ty, trait_ref, ns);\n-        self.printer.keep_within_component = kept_within_component;\n-        r\n+        let mut path = self.pretty_path_qualified(self_ty, trait_ref, ns)?;\n+        path.keep_within_component = kept_within_component;\n+        Ok(path)\n+    }\n+\n+    fn path_append_impl<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let kept_within_component = self.printer.keep_within_component;\n+        let mut path = self.pretty_path_append_impl(\n+            |cx| {\n+                let mut path = print_prefix(cx)?;\n+                path.keep_within_component = true;\n+                Ok(path)\n+            },\n+            self_ty,\n+            trait_ref,\n+        )?;\n+        path.keep_within_component = kept_within_component;\n+        Ok(path)\n     }\n-    fn path_append(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n-        mut path: Self::Path,\n+    fn path_append<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n         text: &str,\n     ) -> Result<Self::Path, Self::Error> {\n-        if self.keep_within_component {\n+        let keep_within_component = self.printer.keep_within_component;\n+\n+        let mut path = print_prefix(self)?;\n+\n+        if keep_within_component {\n             // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n-            if !path.empty {\n-                self.printer.write_str(\"::\")?;\n-            } else {\n-                path.empty = text.is_empty();\n-            }\n+            path.write_str(\"::\")?;\n         } else {\n-            self.printer.finalize_pending_component();\n-            path.empty = false;\n+            path.finalize_pending_component();\n         }\n \n-        self.printer.write_str(text)?;\n+        path.write_str(text)?;\n         Ok(path)\n     }\n-    fn path_generic_args(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        path: Self::Path,\n+    fn path_generic_args<'gcx, 'tcx>(\n+        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        print_prefix: impl FnOnce(\n+            PrintCx<'_, 'gcx, 'tcx, Self>,\n+        ) -> Result<Self::Path, Self::Error>,\n         params: &[ty::GenericParamDef],\n         substs: SubstsRef<'tcx>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     )  -> Result<Self::Path, Self::Error> {\n-        let kept_within_component = mem::replace(&mut self.printer.keep_within_component, true);\n-        let r = self.pretty_path_generic_args(path, params, substs, ns, projections);\n-        self.printer.keep_within_component = kept_within_component;\n-        r\n+        let kept_within_component = self.printer.keep_within_component;\n+        let mut path = self.pretty_path_generic_args(\n+            |cx| {\n+                let mut path = print_prefix(cx)?;\n+                path.keep_within_component = true;\n+                Ok(path)\n+            },\n+            params,\n+            substs,\n+            ns,\n+            projections,\n+        )?;\n+        path.keep_within_component = kept_within_component;\n+        Ok(path)\n     }\n }\n "}, {"sha": "536ee3d58d65ff1b1f444d2402af32f85dd24a13", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4eecef0b256850166fdb0070568544f2380115/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7c4eecef0b256850166fdb0070568544f2380115", "patch": "@@ -4235,50 +4235,70 @@ where F: Fn(DefId) -> Def {\n         type Path = Vec<String>;\n \n         fn path_crate(\n-            self: &mut PrintCx<'_, '_, '_, Self>,\n+            self: PrintCx<'_, '_, '_, Self>,\n             cnum: CrateNum,\n         ) -> Result<Self::Path, Self::Error> {\n             Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n         }\n         fn path_qualified(\n-            self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-            impl_prefix: Option<Self::Path>,\n+            self: PrintCx<'_, '_, 'tcx, Self>,\n             self_ty: Ty<'tcx>,\n             trait_ref: Option<ty::TraitRef<'tcx>>,\n             _ns: Namespace,\n         ) -> Result<Self::Path, Self::Error> {\n-            let mut path = impl_prefix.unwrap_or(vec![]);\n+            // This shouldn't ever be needed, but just in case:\n+            Ok(vec![match trait_ref {\n+                Some(trait_ref) => format!(\"{:?}\", trait_ref),\n+                None => format!(\"<{}>\", self_ty),\n+            }])\n+        }\n+\n+        fn path_append_impl<'gcx, 'tcx>(\n+            self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+            print_prefix: impl FnOnce(\n+                PrintCx<'_, 'gcx, 'tcx, Self>,\n+            ) -> Result<Self::Path, Self::Error>,\n+            self_ty: Ty<'tcx>,\n+            trait_ref: Option<ty::TraitRef<'tcx>>,\n+        ) -> Result<Self::Path, Self::Error> {\n+            let mut path = print_prefix(self)?;\n \n             // This shouldn't ever be needed, but just in case:\n-            if let Some(trait_ref) = trait_ref {\n-                path.push(format!(\"{:?}\", trait_ref));\n-            } else {\n-                path.push(format!(\"<{}>\", self_ty));\n-            }\n+            path.push(match trait_ref {\n+                Some(trait_ref) => {\n+                    format!(\"<impl {} for {}>\", trait_ref, self_ty)\n+                }\n+                None => format!(\"<impl {}>\", self_ty),\n+            });\n \n             Ok(path)\n         }\n-        fn path_append(\n-            self: &mut PrintCx<'_, '_, '_, Self>,\n-            mut path: Self::Path,\n+        fn path_append<'gcx, 'tcx>(\n+            self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+            print_prefix: impl FnOnce(\n+                PrintCx<'_, 'gcx, 'tcx, Self>,\n+            ) -> Result<Self::Path, Self::Error>,\n             text: &str,\n         ) -> Result<Self::Path, Self::Error> {\n+            let mut path = print_prefix(self)?;\n             path.push(text.to_string());\n             Ok(path)\n         }\n-        fn path_generic_args(\n-            self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-            path: Self::Path,\n+        fn path_generic_args<'gcx, 'tcx>(\n+            self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+            print_prefix: impl FnOnce(\n+                PrintCx<'_, 'gcx, 'tcx, Self>,\n+            ) -> Result<Self::Path, Self::Error>,\n             _params: &[ty::GenericParamDef],\n             _substs: SubstsRef<'tcx>,\n             _ns: Namespace,\n             _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n         ) -> Result<Self::Path, Self::Error> {\n-            Ok(path)\n+            print_prefix(self)\n         }\n     }\n \n-    let names = PrintCx::with(tcx, AbsolutePathPrinter, |mut cx| {\n+    let names = PrintCx::with(tcx, AbsolutePathPrinter, |cx| {\n         cx.print_def_path(def_id, None, Namespace::TypeNS, iter::empty()).unwrap()\n     });\n "}]}