{"sha": "6ce22733b973355573efd1e6294e585460e90e17", "node_id": "C_kwDOAAsO6NoAKDZjZTIyNzMzYjk3MzM1NTU3M2VmZDFlNjI5NGU1ODU0NjBlOTBlMTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-27T09:55:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-27T09:55:37Z"}, "message": "Auto merge of #110882 - BoxyUwU:rename-some-ty-flags, r=compiler-errors\n\nrename `NEEDS_SUBST` and `NEEDS_INFER`\n\nimplements rust-lang/compiler-team#617", "tree": {"sha": "7d4b61f63e41d619867b50cac41429e24233381f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d4b61f63e41d619867b50cac41429e24233381f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ce22733b973355573efd1e6294e585460e90e17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce22733b973355573efd1e6294e585460e90e17", "html_url": "https://github.com/rust-lang/rust/commit/6ce22733b973355573efd1e6294e585460e90e17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ce22733b973355573efd1e6294e585460e90e17/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b8110e1469d459a196f6feb60d82dec48c3cfc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b8110e1469d459a196f6feb60d82dec48c3cfc2", "html_url": "https://github.com/rust-lang/rust/commit/8b8110e1469d459a196f6feb60d82dec48c3cfc2"}, {"sha": "842419712a9ed7be166bfdac2d5588356191dabb", "url": "https://api.github.com/repos/rust-lang/rust/commits/842419712a9ed7be166bfdac2d5588356191dabb", "html_url": "https://github.com/rust-lang/rust/commit/842419712a9ed7be166bfdac2d5588356191dabb"}], "stats": {"total": 171, "additions": 86, "deletions": 85}, "files": [{"sha": "0b4d4ecf2e46dfc9b65af1a64a331924ffc3dbc1", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -70,7 +70,7 @@ pub(crate) fn get_function_sig<'tcx>(\n     default_call_conv: CallConv,\n     inst: Instance<'tcx>,\n ) -> Signature {\n-    assert!(!inst.substs.needs_infer());\n+    assert!(!inst.substs.has_infer());\n     clif_sig_from_fn_abi(\n         tcx,\n         default_call_conv,"}, {"sha": "c181c73e4be949a5a8d546fe7164464c5b616ed1", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -28,7 +28,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) -> CodegenedFunction {\n-    debug_assert!(!instance.substs.needs_infer());\n+    debug_assert!(!instance.substs.has_infer());\n \n     let symbol_name = tcx.symbol_name(instance).name.to_string();\n     let _timer = tcx.prof.generic_activity_with_arg(\"codegen fn\", &*symbol_name);"}, {"sha": "433b2585f82a844730da8baf4eb28aecdd75d62b", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -17,7 +17,7 @@ use crate::context::CodegenCx;\n pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> Function<'gcc> {\n     let tcx = cx.tcx();\n \n-    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n     let sym = tcx.symbol_name(instance).name;"}, {"sha": "342b830cedb1206922c1b00ee70fc3f0f2891a42", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -31,7 +31,7 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n     fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n-        assert!(!instance.substs.needs_infer());\n+        assert!(!instance.substs.has_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));"}, {"sha": "30a0cf1d01914c8718b77b9ee9d7ceff6cdabac7", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -27,7 +27,7 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n \n     debug!(\"get_fn(instance={:?})\", instance);\n \n-    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n     if let Some(&llfn) = cx.instances.borrow().get(&instance) {"}, {"sha": "2e9f89f41969642233c5cbe82c7973db64aabdfb", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -515,7 +515,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         ty::Adt(def, ..) if !def.is_box() => {\n                             // Again, only create type information if full debuginfo is enabled\n                             if cx.sess().opts.debuginfo == DebugInfo::Full\n-                                && !impl_self_ty.needs_subst()\n+                                && !impl_self_ty.has_param()\n                             {\n                                 Some(type_di_node(cx, impl_self_ty))\n                             } else {"}, {"sha": "59bdc60830f80016fc76d58ab35fd7a9bd5edee5", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> PreDefineMethods<'tcx> for CodegenCx<'_, 'tcx> {\n         visibility: Visibility,\n         symbol_name: &str,\n     ) {\n-        assert!(!instance.substs.needs_infer());\n+        assert!(!instance.substs.has_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         let lldecl = self.declare_fn(symbol_name, fn_abi);"}, {"sha": "f6e937a740c2677069b2c3adc8c4be6a50b7b12a", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -152,7 +152,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     instance: Instance<'tcx>,\n ) {\n-    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_infer());\n \n     let llfn = cx.get_fn(instance);\n "}, {"sha": "22bdd4d2c3fbcd165088d7e0f2fd3c8eae02aeb3", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -14,7 +14,7 @@ where\n     T: TypeVisitable<TyCtxt<'tcx>>,\n {\n     debug!(\"ensure_monomorphic_enough: ty={:?}\", ty);\n-    if !ty.needs_subst() {\n+    if !ty.has_param() {\n         return Ok(());\n     }\n \n@@ -27,7 +27,7 @@ where\n         type BreakTy = FoundParam;\n \n         fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if !ty.needs_subst() {\n+            if !ty.has_param() {\n                 return ControlFlow::Continue(());\n             }\n \n@@ -46,7 +46,7 @@ where\n                         // are used and require substitution.\n                         // Just in case there are closures or generators within this subst,\n                         // recurse.\n-                        if unused_params.is_used(index) && subst.needs_subst() {\n+                        if unused_params.is_used(index) && subst.has_param() {\n                             return subst.visit_with(self);\n                         }\n                     }"}, {"sha": "709dea43d84aa5113beb672ce08e14532a1db97a", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -2318,7 +2318,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let infcx = match self.infcx() {\n             Some(infcx) => infcx,\n             None => {\n-                assert!(!self_ty.needs_infer());\n+                assert!(!self_ty.has_infer());\n                 infcx_ = tcx.infer_ctxt().ignoring_regions().build();\n                 &infcx_\n             }\n@@ -2489,7 +2489,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let infcx = if let Some(infcx) = self.infcx() {\n             infcx\n         } else {\n-            assert!(!qself_ty.needs_infer());\n+            assert!(!qself_ty.has_infer());\n             infcx_ = tcx.infer_ctxt().build();\n             &infcx_\n         };\n@@ -3039,7 +3039,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // the anon const, which is empty. This is why the\n                 // `AlwaysApplicable` impl needs a `T: ?Sized` bound for\n                 // this to compile if we were to normalize here.\n-                if forbid_generic && ty.needs_subst() {\n+                if forbid_generic && ty.has_param() {\n                     let mut err = tcx.sess.struct_span_err(\n                         path.span,\n                         \"generic `Self` types are currently not permitted in anonymous constants\","}, {"sha": "c066c396766624caeef30d570b96d063cbbf03b4", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -1027,7 +1027,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n                 packed && {\n                     let ty = tcx.type_of(variant.fields.raw.last().unwrap().did).subst_identity();\n                     let ty = tcx.erase_regions(ty);\n-                    if ty.needs_infer() {\n+                    if ty.has_infer() {\n                         tcx.sess\n                             .delay_span_bug(item.span, &format!(\"inference variables in {:?}\", ty));\n                         // Just treat unresolved type expression as if it needs drop.\n@@ -1292,7 +1292,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                     // Ignore dependent defaults -- that is, where the default of one type\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n-                    if !ty.needs_subst() {\n+                    if !ty.has_param() {\n                         wfcx.register_wf_obligation(\n                             tcx.def_span(param.def_id),\n                             Some(WellFormedLoc::Ty(param.def_id.expect_local())),\n@@ -1308,7 +1308,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                     // for `struct Foo<const N: usize, const M: usize = { 1 - 2 }>`\n                     // we should eagerly error.\n                     let default_ct = tcx.const_param_default(param.def_id).subst_identity();\n-                    if !default_ct.needs_subst() {\n+                    if !default_ct.has_param() {\n                         wfcx.register_wf_obligation(\n                             tcx.def_span(param.def_id),\n                             None,\n@@ -1342,7 +1342,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                 if is_our_default(param) {\n                     let default_ty = tcx.type_of(param.def_id).subst_identity();\n                     // ... and it's not a dependent default, ...\n-                    if !default_ty.needs_subst() {\n+                    if !default_ty.has_param() {\n                         // ... then substitute it with the default.\n                         return default_ty.into();\n                     }\n@@ -1355,7 +1355,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                 if is_our_default(param) {\n                     let default_ct = tcx.const_param_default(param.def_id).subst_identity();\n                     // ... and it's not a dependent default, ...\n-                    if !default_ct.needs_subst() {\n+                    if !default_ct.has_param() {\n                         // ... then substitute it with the default.\n                         return default_ct.into();\n                     }"}, {"sha": "89175c0ef745064121c6ebd5ccb0290e1f918204", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -457,7 +457,7 @@ fn emit_newtype_suggestion_for_raw_ptr(\n     ptr_ty: &ty::TypeAndMut<'_>,\n     diag: &mut Diagnostic,\n ) {\n-    if !self_ty.needs_subst() {\n+    if !self_ty.has_param() {\n         let mut_key = ptr_ty.mutbl.prefix_str();\n         let msg_sugg = \"consider introducing a new wrapper type\".to_owned();\n         let sugg = vec!["}, {"sha": "c09457e1d65ecb5097dd2f8b02861a4238fdc00e", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -366,7 +366,7 @@ fn check_predicates<'tcx>(\n             wf::obligations(infcx, tcx.param_env(impl1_def_id), impl1_def_id, 0, arg, span)\n                 .unwrap();\n \n-        assert!(!obligations.needs_infer());\n+        assert!(!obligations.has_infer());\n         impl2_predicates\n             .extend(traits::elaborate(tcx, obligations).map(|obligation| obligation.predicate))\n     }"}, {"sha": "73a7bbebb6581b7f62e1836dcfdc953ee5528543", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ocx.normalize(&ObligationCause::dummy(), self.param_env, fn_sig);\n                     if ocx.select_all_or_error().is_empty() {\n                         let normalized_fn_sig = self.resolve_vars_if_possible(normalized_fn_sig);\n-                        if !normalized_fn_sig.needs_infer() {\n+                        if !normalized_fn_sig.has_infer() {\n                             return normalized_fn_sig;\n                         }\n                     }"}, {"sha": "82fc1256bba64ac901a74231adb4b31fd527976a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -1384,7 +1384,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         let item_ty = self.tcx.type_of(item.def_id).subst_identity();\n         // FIXME(compiler-errors): This check is *so* rudimentary\n-        if item_ty.needs_subst() {\n+        if item_ty.has_param() {\n             return false;\n         }\n         if self.can_coerce(item_ty, expected_ty) {"}, {"sha": "5136d895f22686c06176b822177441c066ed05d6", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -202,7 +202,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         // If the type being assigned needs dropped, then the mutation counts as a borrow\n         // since it is essentially doing `Drop::drop(&mut x); x = new_value;`.\n         let ty = self.tcx.erase_regions(assignee_place.place.base_ty);\n-        if ty.needs_infer() {\n+        if ty.has_infer() {\n             self.tcx.sess.delay_span_bug(\n                 self.tcx.hir().span(assignee_place.hir_id),\n                 &format!(\"inference variables in {ty}\"),"}, {"sha": "915280a5bea022db041a18aac4821d5f65fd43d9", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                 // Avoid ICEs in needs_drop.\n                 let ty = self.fcx.resolve_vars_if_possible(ty);\n                 let ty = self.fcx.tcx.erase_regions(ty);\n-                if ty.needs_infer() {\n+                if ty.has_infer() {\n                     self.fcx\n                         .tcx\n                         .sess"}, {"sha": "1a429142e01481eb593fb7848571861379c5fcc9", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -2032,7 +2032,7 @@ impl<'tcx> Candidate<'tcx> {\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n                     assert!(\n-                        !trait_ref.skip_binder().substs.needs_infer()\n+                        !trait_ref.skip_binder().substs.has_infer()\n                             && !trait_ref.skip_binder().substs.has_placeholders()\n                     );\n "}, {"sha": "817918257beb433ec9f4d7b3c43d63abe8f8a760", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -133,7 +133,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn write_ty_to_typeck_results(&mut self, hir_id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty_to_typeck_results({:?}, {:?})\", hir_id, ty);\n-        assert!(!ty.needs_infer() && !ty.has_placeholders() && !ty.has_free_regions());\n+        assert!(!ty.has_infer() && !ty.has_placeholders() && !ty.has_free_regions());\n         self.typeck_results.node_types_mut().insert(hir_id, ty);\n     }\n \n@@ -508,7 +508,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             fcx_typeck_results.user_provided_types().items().map(|(local_id, c_ty)| {\n                 let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n-                if cfg!(debug_assertions) && c_ty.needs_infer() {\n+                if cfg!(debug_assertions) && c_ty.has_infer() {\n                     span_bug!(\n                         hir_id.to_span(self.fcx.tcx),\n                         \"writeback: `{:?}` has inference variables\",\n@@ -527,7 +527,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n         self.typeck_results.user_provided_sigs.extend(\n             fcx_typeck_results.user_provided_sigs.items().map(|(&def_id, c_sig)| {\n-                if cfg!(debug_assertions) && c_sig.needs_infer() {\n+                if cfg!(debug_assertions) && c_sig.has_infer() {\n                     span_bug!(\n                         self.fcx.tcx.def_span(def_id),\n                         \"writeback: `{:?}` has inference variables\",\n@@ -618,7 +618,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         if let Some(substs) = self.fcx.typeck_results.borrow().node_substs_opt(hir_id) {\n             let substs = self.resolve(substs, &span);\n             debug!(\"write_substs_to_tcx({:?}, {:?})\", hir_id, substs);\n-            assert!(!substs.needs_infer() && !substs.has_placeholders());\n+            assert!(!substs.has_infer() && !substs.has_placeholders());\n             self.typeck_results.node_substs_mut().insert(hir_id, substs);\n         }\n     }\n@@ -693,7 +693,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n-            if cfg!(debug_assertions) && container.needs_infer() {\n+            if cfg!(debug_assertions) && container.has_infer() {\n                 span_bug!(\n                     hir_id.to_span(self.fcx.tcx),\n                     \"writeback: `{:?}` has inference variables\",\n@@ -711,7 +711,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     {\n         let mut resolver = Resolver::new(self.fcx, span, self.body);\n         let x = x.fold_with(&mut resolver);\n-        if cfg!(debug_assertions) && x.needs_infer() {\n+        if cfg!(debug_assertions) && x.has_infer() {\n             span_bug!(span.to_span(self.fcx.tcx), \"writeback: `{:?}` has inference variables\", x);\n         }\n "}, {"sha": "c29f652034fc071681beb3e54b33fc6ad92bf16d", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -564,12 +564,12 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         let _inside_canonical_ctxt_guard = infcx.set_canonicalization_ctxt();\n \n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n-            TypeFlags::NEEDS_INFER |\n+            TypeFlags::HAS_INFER |\n             TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`\n             TypeFlags::HAS_TY_PLACEHOLDER |\n             TypeFlags::HAS_CT_PLACEHOLDER\n         } else {\n-            TypeFlags::NEEDS_INFER\n+            TypeFlags::HAS_INFER\n                 | TypeFlags::HAS_RE_PLACEHOLDER\n                 | TypeFlags::HAS_TY_PLACEHOLDER\n                 | TypeFlags::HAS_CT_PLACEHOLDER\n@@ -600,7 +600,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         // Once we have canonicalized `out_value`, it should not\n         // contain anything that ties it to this inference context\n         // anymore.\n-        debug_assert!(!out_value.needs_infer() && !out_value.has_placeholders());\n+        debug_assert!(!out_value.has_infer() && !out_value.has_placeholders());\n \n         let canonical_variables =\n             tcx.mk_canonical_var_infos(&canonicalizer.universe_canonicalized_variables());"}, {"sha": "0219167f6e58b53cda7fb27354a2f14f5ad5a752", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for TypeFreshener<'a, 'tcx> {\n \n     #[inline]\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_infer() && !t.has_erasable_regions() {\n+        if !t.has_infer() && !t.has_erasable_regions() {\n             t\n         } else {\n             match *t.kind() {"}, {"sha": "1cfdb791cd6ae44c244783e441b1d2422df48bfa", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -1327,7 +1327,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n-        if !value.needs_infer() {\n+        if !value.has_infer() {\n             return value; // Avoid duplicated subst-folding.\n         }\n         let mut r = InferenceLiteralEraser { tcx: self.tcx };\n@@ -1365,7 +1365,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     pub fn fully_resolve<T: TypeFoldable<TyCtxt<'tcx>>>(&self, value: T) -> FixupResult<'tcx, T> {\n         let value = resolve::fully_resolve(self, value);\n         assert!(\n-            value.as_ref().map_or(true, |value| !value.needs_infer()),\n+            value.as_ref().map_or(true, |value| !value.has_infer()),\n             \"`{value:?}` is not fully resolved\"\n         );\n         value"}, {"sha": "d3f7eeff9976cccaa429bdb37cfedf2b8ef99961", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -347,7 +347,7 @@ where\n         let is_opaque = alias_ty.kind(self.tcx) == ty::Opaque;\n         if approx_env_bounds.is_empty()\n             && trait_bounds.is_empty()\n-            && (alias_ty.needs_infer() || is_opaque)\n+            && (alias_ty.has_infer() || is_opaque)\n         {\n             debug!(\"no declared bounds\");\n             let opt_variances = is_opaque.then(|| self.tcx.variances_of(alias_ty.def_id));"}, {"sha": "3c41e8b37838a8e6f51c9782689d59cd6476c8b0", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for FullTypeResolver<'a, 'tcx> {\n     }\n \n     fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        if !t.needs_infer() {\n+        if !t.has_infer() {\n             Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for FullTypeResolver<'a, 'tcx> {\n     }\n \n     fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n-        if !c.needs_infer() {\n+        if !c.has_infer() {\n             Ok(c) // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let c = self.infcx.shallow_resolve(c);"}, {"sha": "2ce28f3a049e860ab4576c9741e2b06583565ce8", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -42,7 +42,7 @@ declare_lint_pass!(EnumIntrinsicsNonEnums => [ENUM_INTRINSICS_NON_ENUMS]);\n /// Returns `true` if we know for sure that the given type is not an enum. Note that for cases where\n /// the type is generic, we can't be certain if it will be an enum so we have to assume that it is.\n fn is_non_enum(t: Ty<'_>) -> bool {\n-    !t.is_enum() && !t.needs_subst()\n+    !t.is_enum() && !t.has_param()\n }\n \n fn enforce_mem_discriminant("}, {"sha": "830231646c659d6123f8381882e821af888f825e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -215,7 +215,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n     ) -> Fingerprint {\n         // It's impossible to hash inference variables (and will ICE), so we don't need to try to cache them.\n         // Without incremental, we rarely stable-hash types, so let's not do it proactively.\n-        if flags.flags.intersects(TypeFlags::NEEDS_INFER) || sess.opts.incremental.is_none() {\n+        if flags.flags.intersects(TypeFlags::HAS_INFER) || sess.opts.incremental.is_none() {\n             Fingerprint::ZERO\n         } else {\n             let mut hasher = StableHasher::new();"}, {"sha": "ad930d1e6b64ad95009cdb85810d27cbaedc736f", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -40,7 +40,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for RegionEraserVisitor<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.needs_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n+        if ty.has_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n     }\n \n     fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>"}, {"sha": "43f95635ab00a577198539e7ed785e066ed9bdad", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -761,7 +761,7 @@ impl<'tcx, T: TypeFoldable<TyCtxt<'tcx>>> ty::EarlyBinder<T> {\n \n     /// Returns the inner value, but only if it contains no bound vars.\n     pub fn no_bound_vars(self) -> Option<T> {\n-        if !self.0.needs_subst() { Some(self.0) } else { None }\n+        if !self.0.has_param() { Some(self.0) } else { None }\n     }\n }\n \n@@ -840,7 +840,7 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for SubstFolder<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_subst() {\n+        if !t.has_param() {\n             return t;\n         }\n "}, {"sha": "c77985c6bd6350a35f6b20df90a86c3924843fc4", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -1151,7 +1151,7 @@ impl<'tcx> Ty<'tcx> {\n                 // context, or *something* like that, but for now just avoid passing inference\n                 // variables to queries that can't cope with them. Instead, conservatively\n                 // return \"true\" (may change drop order).\n-                if query_ty.needs_infer() {\n+                if query_ty.has_infer() {\n                     return true;\n                 }\n "}, {"sha": "5eaa58d69ed660c5c46501d4ce0dcbe057be6fd8", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -70,7 +70,7 @@ pub trait TypeVisitableExt<'tcx>: TypeVisitable<TyCtxt<'tcx>> {\n         }\n     }\n     fn has_non_region_param(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_SUBST - TypeFlags::HAS_RE_PARAM)\n+        self.has_type_flags(TypeFlags::HAS_PARAM - TypeFlags::HAS_RE_PARAM)\n     }\n     fn has_infer_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_INFER)\n@@ -79,10 +79,10 @@ pub trait TypeVisitableExt<'tcx>: TypeVisitable<TyCtxt<'tcx>> {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n     fn has_non_region_infer(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_INFER - TypeFlags::HAS_RE_INFER)\n+        self.has_type_flags(TypeFlags::HAS_INFER - TypeFlags::HAS_RE_INFER)\n     }\n-    fn needs_infer(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_INFER)\n+    fn has_infer(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_INFER)\n     }\n     fn has_placeholders(&self) -> bool {\n         self.has_type_flags(\n@@ -94,8 +94,8 @@ pub trait TypeVisitableExt<'tcx>: TypeVisitable<TyCtxt<'tcx>> {\n     fn has_non_region_placeholders(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_PLACEHOLDER | TypeFlags::HAS_CT_PLACEHOLDER)\n     }\n-    fn needs_subst(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_SUBST)\n+    fn has_param(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_PARAM)\n     }\n     /// \"Free\" regions in this context means that it has any region\n     /// that is not (a) erased or (b) late-bound."}, {"sha": "880745b8f0eb7bb2da77d433cf28dfbb9ed903a6", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -391,7 +391,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Returns the value, if any, of evaluating `c`.\n     fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n-        if c.needs_subst() {\n+        if c.has_param() {\n             return None;\n         }\n \n@@ -490,7 +490,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME we need to revisit this for #67176\n-        if rvalue.needs_subst() {\n+        if rvalue.has_param() {\n             return None;\n         }\n         if !rvalue"}, {"sha": "a4049d08d7b82522ed0697c931ddb931415c7eff", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -281,7 +281,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Returns the value, if any, of evaluating `c`.\n     fn eval_constant(&mut self, c: &Constant<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n-        if c.needs_subst() {\n+        if c.has_param() {\n             return None;\n         }\n \n@@ -474,7 +474,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME we need to revisit this for #67176\n-        if rvalue.needs_subst() {\n+        if rvalue.has_param() {\n             return None;\n         }\n         if !rvalue.ty(self.local_decls(), self.tcx).is_sized(self.tcx, self.param_env) {"}, {"sha": "6046c3876bee0cf48f2f4bd0f3b948963f2f00e0", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -92,7 +92,7 @@ pub(crate) fn mir_callgraph_reachable<'tcx>(\n                     // FIXME: A not fully substituted drop shim can cause ICEs if one attempts to\n                     // have its MIR built. Likely oli-obk just screwed up the `ParamEnv`s, so this\n                     // needs some more analysis.\n-                    if callee.needs_subst() {\n+                    if callee.has_param() {\n                         continue;\n                     }\n                 }"}, {"sha": "03183a406603378d19362a498fc4492376749122", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -305,7 +305,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n \n                 // When polymorphization is enabled, methods which do not depend on their generic\n                 // parameters, but the self-type of their impl block do will fail to normalize.\n-                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.needs_subst() {\n+                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.has_param() {\n                     // This is a method within an impl, find out what the self-type is:\n                     let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n                         instance.substs,"}, {"sha": "a3f262905c74f8b495df3443f728f65adffcb2e8", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -108,7 +108,7 @@ fn get_symbol_hash<'tcx>(\n             tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n \n             // Include the main item-type. Note that, in this case, the\n-            // assertions about `needs_subst` may not hold, but this item-type\n+            // assertions about `has_param` may not hold, but this item-type\n             // ought to be the same for every reference anyway.\n             assert!(!item_type.has_erasable_regions());\n             hcx.while_hashing_spans(false, |hcx| {"}, {"sha": "fcf86da08f4695dda16949bebe420634e58dde9b", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     fn type_is_copy_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n         let ty = self.resolve_vars_if_possible(ty);\n \n-        if !(param_env, ty).needs_infer() {\n+        if !(param_env, ty).has_infer() {\n             return ty.is_copy_modulo_regions(self.tcx, param_env);\n         }\n "}, {"sha": "ff4bff10cc8a39c8141bca9f08cbb151c9ad3beb", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> Canonicalizer<'a, 'tcx> {\n         };\n \n         let value = value.fold_with(&mut canonicalizer);\n-        assert!(!value.needs_infer());\n+        assert!(!value.has_infer());\n         assert!(!value.has_placeholders());\n \n         let (max_universe, variables) = canonicalizer.finalize();"}, {"sha": "b7690f79933d95d289dbd6c21fd23d101856a691", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -582,7 +582,7 @@ fn orphan_check_trait_ref<'tcx>(\n     trait_ref: ty::TraitRef<'tcx>,\n     in_crate: InCrate,\n ) -> Result<(), OrphanCheckErr<'tcx>> {\n-    if trait_ref.needs_infer() && trait_ref.needs_subst() {\n+    if trait_ref.has_infer() && trait_ref.has_param() {\n         bug!(\n             \"can't orphan check a trait ref with both params and inference variables {:?}\",\n             trait_ref"}, {"sha": "0e8c74a6765ce9acd3aeaa9364788d6a9b340f44", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -414,7 +414,7 @@ fn subst_and_check_impossible_predicates<'tcx>(\n         predicates.push(ty::Binder::dummy(trait_ref).to_predicate(tcx));\n     }\n \n-    predicates.retain(|predicate| !predicate.needs_subst());\n+    predicates.retain(|predicate| !predicate.has_param());\n     let result = impossible_predicates(tcx, predicates);\n \n     debug!(\"subst_and_check_impossible_predicates(key={:?}) = {:?}\", key, result);"}, {"sha": "0db802328912715a9d5ac24e3fa2814b80ca534c", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         // We may however encounter unconstrained lifetime variables in invalid\n         // code. See #110161 for context.\n         assert!(!ty.has_non_region_infer());\n-        if ty.needs_infer() {\n+        if ty.has_infer() {\n             self.tcx.sess.delay_span_bug(\n                 self.tcx.def_span(body_id),\n                 \"skipped implied_outlives_bounds due to unconstrained lifetimes\","}, {"sha": "863553670dee27deefe37aeecfcaaac6e3adef52", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -449,7 +449,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n \n-        let needs_infer = stack.obligation.predicate.has_non_region_infer();\n+        let has_non_region_infer = stack.obligation.predicate.has_non_region_infer();\n \n         // If there are STILL multiple candidates, we can further\n         // reduce the list by dropping duplicates -- including\n@@ -461,7 +461,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     self.candidate_should_be_dropped_in_favor_of(\n                         &candidates[i],\n                         &candidates[j],\n-                        needs_infer,\n+                        has_non_region_infer,\n                     ) == DropVictim::Yes\n                 });\n                 if should_drop_i {\n@@ -1000,7 +1000,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<EvaluationResult, OverflowError> {\n         if !self.is_intercrate()\n             && obligation.is_global()\n-            && obligation.param_env.caller_bounds().iter().all(|bound| bound.needs_subst())\n+            && obligation.param_env.caller_bounds().iter().all(|bound| bound.has_param())\n         {\n             // If a param env has no global bounds, global obligations do not\n             // depend on its particular value in order to work, so we can clear\n@@ -1330,7 +1330,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         if self.can_use_global_caches(param_env) {\n-            if !trait_pred.needs_infer() {\n+            if !trait_pred.has_infer() {\n                 debug!(?trait_pred, ?result, \"insert_evaluation_cache global\");\n                 // This may overwrite the cache with the same value\n                 // FIXME: Due to #50507 this overwrites the different values\n@@ -1516,7 +1516,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // If there are any inference variables in the `ParamEnv`, then we\n         // always use a cache local to this particular scope. Otherwise, we\n         // switch to a global cache.\n-        if param_env.needs_infer() {\n+        if param_env.has_infer() {\n             return false;\n         }\n \n@@ -1587,7 +1587,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return false;\n         }\n         match result {\n-            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.needs_infer(),\n+            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.has_infer(),\n             _ => true,\n         }\n     }\n@@ -1613,8 +1613,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if self.can_use_global_caches(param_env) {\n             if let Err(Overflow(OverflowError::Canonical)) = candidate {\n                 // Don't cache overflow globally; we only produce this in certain modes.\n-            } else if !pred.needs_infer() {\n-                if !candidate.needs_infer() {\n+            } else if !pred.has_infer() {\n+                if !candidate.has_infer() {\n                     debug!(?pred, ?candidate, \"insert_candidate_cache global\");\n                     // This may overwrite the cache with the same value.\n                     tcx.selection_cache.insert((param_env, pred), dep_node, candidate);\n@@ -1724,7 +1724,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map(|InferOk { obligations: _, value: () }| {\n                 // This method is called within a probe, so we can't have\n                 // inference variables and placeholders escape.\n-                if !trait_bound.needs_infer() && !trait_bound.has_placeholders() {\n+                if !trait_bound.has_infer() && !trait_bound.has_placeholders() {\n                     Some(trait_bound)\n                 } else {\n                     None\n@@ -1840,7 +1840,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n         &mut self,\n         victim: &EvaluatedCandidate<'tcx>,\n         other: &EvaluatedCandidate<'tcx>,\n-        needs_infer: bool,\n+        has_non_region_infer: bool,\n     ) -> DropVictim {\n         if victim.candidate == other.candidate {\n             return DropVictim::Yes;\n@@ -1956,7 +1956,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n             | (ObjectCandidate(i), ObjectCandidate(j)) => {\n                 // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                DropVictim::drop_if(i < j && !needs_infer)\n+                DropVictim::drop_if(i < j && !has_non_region_infer)\n             }\n             (ObjectCandidate(_), ProjectionCandidate(..))\n             | (ProjectionCandidate(..), ObjectCandidate(_)) => {\n@@ -2062,7 +2062,8 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                         // existence of multiple marker trait impls tells us nothing\n                         // about which one should actually apply.\n                         DropVictim::drop_if(\n-                            !needs_infer && other.evaluation.must_apply_considering_regions(),\n+                            !has_non_region_infer\n+                                && other.evaluation.must_apply_considering_regions(),\n                         )\n                     }\n                     None => DropVictim::No,"}, {"sha": "c56e7c7cadd81129a1fa02f02131becba4153f0f", "filename": "compiler/rustc_trait_selection/src/traits/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -353,8 +353,8 @@ pub(crate) fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n     ),\n ) -> Option<usize> {\n     let (source, target) = key;\n-    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.needs_infer());\n-    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.needs_infer());\n+    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.has_infer());\n+    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.has_infer());\n \n     // this has been typecked-before, so diagnostics is not really needed.\n     let unsize_trait_did = tcx.require_lang_item(LangItem::Unsize, None);"}, {"sha": "5da0f16c2bf05d18127fe1553e3489648cd32eec", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -47,7 +47,7 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<TyCtxt<'tcx>> + Par\n             // us a test case.\n             debug_assert_eq!(normalized_value, resolved_value);\n             let erased = infcx.tcx.erase_regions(resolved_value);\n-            debug_assert!(!erased.needs_infer(), \"{erased:?}\");\n+            debug_assert!(!erased.has_infer(), \"{erased:?}\");\n             Ok(erased)\n         }\n         Err(NoSolution) => Err(NoSolution),"}, {"sha": "64586a6782b18c2848c6d42b0196607fef0ec1ec", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -104,8 +104,8 @@ fn resolve_associated_item<'tcx>(\n                 \"resolving ImplSource::UserDefined: {:?}, {:?}, {:?}, {:?}\",\n                 param_env, trait_item_id, rcvr_substs, impl_data\n             );\n-            assert!(!rcvr_substs.needs_infer());\n-            assert!(!trait_ref.needs_infer());\n+            assert!(!rcvr_substs.has_infer());\n+            assert!(!trait_ref.has_infer());\n \n             let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n             let trait_def = tcx.trait_def(trait_def_id);"}, {"sha": "1e91e26e2afe9811c7ecf0c41f3b10cfa88abfcd", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -179,7 +179,7 @@ bitflags! {\n         /// Does this have `ConstKind::Param`?\n         const HAS_CT_PARAM                = 1 << 2;\n \n-        const NEEDS_SUBST                 = TypeFlags::HAS_TY_PARAM.bits\n+        const HAS_PARAM                 = TypeFlags::HAS_TY_PARAM.bits\n                                           | TypeFlags::HAS_RE_PARAM.bits\n                                           | TypeFlags::HAS_CT_PARAM.bits;\n \n@@ -192,7 +192,7 @@ bitflags! {\n \n         /// Does this have inference variables? Used to determine whether\n         /// inference is required.\n-        const NEEDS_INFER                 = TypeFlags::HAS_TY_INFER.bits\n+        const HAS_INFER                 = TypeFlags::HAS_TY_INFER.bits\n                                           | TypeFlags::HAS_RE_INFER.bits\n                                           | TypeFlags::HAS_CT_INFER.bits;\n "}, {"sha": "a65720116440e3bdb5d49db508f5b1b9c1c64fba", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce22733b973355573efd1e6294e585460e90e17/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce22733b973355573efd1e6294e585460e90e17/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=6ce22733b973355573efd1e6294e585460e90e17", "patch": "@@ -226,7 +226,7 @@ pub fn implements_trait_with_env<'tcx>(\n     ty_params: impl IntoIterator<Item = Option<GenericArg<'tcx>>>,\n ) -> bool {\n     // Clippy shouldn't have infer types\n-    assert!(!ty.needs_infer());\n+    assert!(!ty.has_infer());\n \n     let ty = tcx.erase_regions(ty);\n     if ty.has_escaping_bound_vars() {"}]}