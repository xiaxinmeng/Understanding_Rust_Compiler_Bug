{"sha": "65e763fa84ae70ec9cee13f434acaae5371ad8e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZTc2M2ZhODRhZTcwZWM5Y2VlMTNmNDM0YWNhYWU1MzcxYWQ4ZTU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-17T08:51:06Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-17T08:51:06Z"}, "message": "Merge #947\n\n947: Add missing impl members r=matklad a=Xanewok\n\nCloses #878.\r\n\r\nThis took longer than expected as I wrapped my head around the API and the project - hopefully I didn't miss any edge case here.\r\n\r\nr? @matklad \n\nCo-authored-by: Igor Matuszewski <xanewok@gmail.com>", "tree": {"sha": "b60ae6575b9ca697a35788a4555c21c1d359b3c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b60ae6575b9ca697a35788a4555c21c1d359b3c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65e763fa84ae70ec9cee13f434acaae5371ad8e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65e763fa84ae70ec9cee13f434acaae5371ad8e5", "html_url": "https://github.com/rust-lang/rust/commit/65e763fa84ae70ec9cee13f434acaae5371ad8e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65e763fa84ae70ec9cee13f434acaae5371ad8e5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "9a59272f5f3efd502f666c78ce901fff8db0dfba", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a59272f5f3efd502f666c78ce901fff8db0dfba", "html_url": "https://github.com/rust-lang/rust/commit/9a59272f5f3efd502f666c78ce901fff8db0dfba"}, {"sha": "30a226c72532f04033d4c283ba7c94790e2da541", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a226c72532f04033d4c283ba7c94790e2da541", "html_url": "https://github.com/rust-lang/rust/commit/30a226c72532f04033d4c283ba7c94790e2da541"}], "stats": {"total": 285, "additions": 285, "deletions": 0}, "files": [{"sha": "4435c4b5d4df857d3df2e849d686e4f2c1223564", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/65e763fa84ae70ec9cee13f434acaae5371ad8e5/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e763fa84ae70ec9cee13f434acaae5371ad8e5/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=65e763fa84ae70ec9cee13f434acaae5371ad8e5", "patch": "@@ -0,0 +1,283 @@\n+use crate::{Assist, AssistId, AssistCtx};\n+\n+use hir::Resolver;\n+use hir::db::HirDatabase;\n+use ra_syntax::{SmolStr, SyntaxKind, TextRange, TextUnit, TreeArc};\n+use ra_syntax::ast::{self, AstNode, FnDef, ImplItem, ImplItemKind, NameOwner};\n+use ra_db::FilePosition;\n+use ra_fmt::{leading_indent, reindent};\n+\n+use itertools::Itertools;\n+\n+pub(crate) fn add_missing_impl_members(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let impl_node = ctx.node_at_offset::<ast::ImplBlock>()?;\n+    let impl_item_list = impl_node.item_list()?;\n+\n+    let trait_def = {\n+        let file_id = ctx.frange.file_id;\n+        let position = FilePosition { file_id, offset: impl_node.syntax().range().start() };\n+        let resolver = hir::source_binder::resolver_for_position(ctx.db, position);\n+\n+        resolve_target_trait_def(ctx.db, &resolver, impl_node)?\n+    };\n+\n+    let missing_fns: Vec<_> = {\n+        let fn_def_opt = |kind| if let ImplItemKind::FnDef(def) = kind { Some(def) } else { None };\n+        let def_name = |def| -> Option<&SmolStr> { FnDef::name(def).map(ast::Name::text) };\n+\n+        let trait_items =\n+            trait_def.syntax().descendants().find_map(ast::ItemList::cast)?.impl_items();\n+        let impl_items = impl_item_list.impl_items();\n+\n+        let trait_fns = trait_items.map(ImplItem::kind).filter_map(fn_def_opt).collect::<Vec<_>>();\n+        let impl_fns = impl_items.map(ImplItem::kind).filter_map(fn_def_opt).collect::<Vec<_>>();\n+\n+        trait_fns\n+            .into_iter()\n+            .filter(|t| def_name(t).is_some())\n+            .filter(|t| impl_fns.iter().all(|i| def_name(i) != def_name(t)))\n+            .collect()\n+    };\n+    if missing_fns.is_empty() {\n+        return None;\n+    }\n+\n+    ctx.add_action(AssistId(\"add_impl_missing_members\"), \"add missing impl members\", |edit| {\n+        let (parent_indent, indent) = {\n+            // FIXME: Find a way to get the indent already used in the file.\n+            // Now, we copy the indent of first item or indent with 4 spaces relative to impl block\n+            const DEFAULT_INDENT: &str = \"    \";\n+            let first_item = impl_item_list.impl_items().next();\n+            let first_item_indent =\n+                first_item.and_then(|i| leading_indent(i.syntax())).map(ToOwned::to_owned);\n+            let impl_block_indent = leading_indent(impl_node.syntax()).unwrap_or_default();\n+\n+            (\n+                impl_block_indent.to_owned(),\n+                first_item_indent.unwrap_or_else(|| impl_block_indent.to_owned() + DEFAULT_INDENT),\n+            )\n+        };\n+\n+        let changed_range = {\n+            let children = impl_item_list.syntax().children();\n+            let last_whitespace = children.filter_map(ast::Whitespace::cast).last();\n+\n+            last_whitespace.map(|w| w.syntax().range()).unwrap_or_else(|| {\n+                let in_brackets = impl_item_list.syntax().range().end() - TextUnit::of_str(\"}\");\n+                TextRange::from_to(in_brackets, in_brackets)\n+            })\n+        };\n+\n+        let func_bodies = format!(\"\\n{}\", missing_fns.into_iter().map(build_func_body).join(\"\\n\"));\n+        let trailing_whitespace = format!(\"\\n{}\", parent_indent);\n+        let func_bodies = reindent(&func_bodies, &indent) + &trailing_whitespace;\n+\n+        let replaced_text_range = TextUnit::of_str(&func_bodies);\n+\n+        edit.replace(changed_range, func_bodies);\n+        edit.set_cursor(\n+            changed_range.start() + replaced_text_range - TextUnit::of_str(&trailing_whitespace),\n+        );\n+    });\n+\n+    ctx.build()\n+}\n+\n+/// Given an `ast::ImplBlock`, resolves the target trait (the one being\n+/// implemented) to a `ast::TraitDef`.\n+fn resolve_target_trait_def(\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    impl_block: &ast::ImplBlock,\n+) -> Option<TreeArc<ast::TraitDef>> {\n+    let ast_path = impl_block.target_trait().map(AstNode::syntax).and_then(ast::PathType::cast)?;\n+    let hir_path = ast_path.path().and_then(hir::Path::from_ast)?;\n+\n+    match resolver.resolve_path(db, &hir_path).take_types() {\n+        Some(hir::Resolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).1),\n+        _ => None,\n+    }\n+}\n+\n+fn build_func_body(def: &ast::FnDef) -> String {\n+    let mut buf = String::new();\n+\n+    for child in def.syntax().children() {\n+        if child.kind() == SyntaxKind::SEMI {\n+            buf.push_str(\" { unimplemented!() }\")\n+        } else {\n+            child.text().push_to(&mut buf);\n+        }\n+    }\n+\n+    buf.trim_end().to_string()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn test_add_missing_impl_members() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+trait Foo {\n+    fn foo(&self);\n+    fn bar(&self);\n+    fn baz(&self);\n+}\n+\n+struct S;\n+\n+impl Foo for S {\n+    fn bar(&self) {}\n+    <|>\n+}\",\n+            \"\n+trait Foo {\n+    fn foo(&self);\n+    fn bar(&self);\n+    fn baz(&self);\n+}\n+\n+struct S;\n+\n+impl Foo for S {\n+    fn bar(&self) {}\n+    fn foo(&self) { unimplemented!() }\n+    fn baz(&self) { unimplemented!() }<|>\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_copied_overriden_members() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+trait Foo {\n+    fn foo(&self);\n+    fn bar(&self) -> bool { true }\n+    fn baz(&self) -> u32 { 42 }\n+}\n+\n+struct S;\n+\n+impl Foo for S {\n+    fn bar(&self) {}\n+    <|>\n+}\",\n+            \"\n+trait Foo {\n+    fn foo(&self);\n+    fn bar(&self) -> bool { true }\n+    fn baz(&self) -> u32 { 42 }\n+}\n+\n+struct S;\n+\n+impl Foo for S {\n+    fn bar(&self) {}\n+    fn foo(&self) { unimplemented!() }\n+    fn baz(&self) -> u32 { 42 }<|>\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_empty_impl_block() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+trait Foo { fn foo(&self); }\n+struct S;\n+impl Foo for S {<|>}\",\n+            \"\n+trait Foo { fn foo(&self); }\n+struct S;\n+impl Foo for S {\n+    fn foo(&self) { unimplemented!() }<|>\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_cursor_after_empty_impl_block() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+trait Foo { fn foo(&self); }\n+struct S;\n+impl Foo for S {}<|>\",\n+            \"\n+trait Foo { fn foo(&self); }\n+struct S;\n+impl Foo for S {\n+    fn foo(&self) { unimplemented!() }<|>\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_empty_trait() {\n+        check_assist_not_applicable(\n+            add_missing_impl_members,\n+            \"\n+trait Foo;\n+struct S;\n+impl Foo for S { <|> }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_ignore_unnamed_trait_members() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+trait Foo {\n+    fn (arg: u32);\n+    fn valid(some: u32) -> bool { false }\n+}\n+struct S;\n+impl Foo for S { <|> }\",\n+            \"\n+trait Foo {\n+    fn (arg: u32);\n+    fn valid(some: u32) -> bool { false }\n+}\n+struct S;\n+impl Foo for S {\n+    fn valid(some: u32) -> bool { false }<|>\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_indented_impl_block() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+trait Foo {\n+    fn valid(some: u32) -> bool { false }\n+}\n+struct S;\n+\n+mod my_mod {\n+    impl crate::Foo for S { <|> }\n+}\",\n+            \"\n+trait Foo {\n+    fn valid(some: u32) -> bool { false }\n+}\n+struct S;\n+\n+mod my_mod {\n+    impl crate::Foo for S {\n+        fn valid(some: u32) -> bool { false }<|>\n+    }\n+}\",\n+        )\n+    }\n+}"}, {"sha": "0c4abb4506c4728e70fad9d65791d70ac3cd1116", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65e763fa84ae70ec9cee13f434acaae5371ad8e5/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e763fa84ae70ec9cee13f434acaae5371ad8e5/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=65e763fa84ae70ec9cee13f434acaae5371ad8e5", "patch": "@@ -95,6 +95,7 @@ mod replace_if_let_with_match;\n mod split_import;\n mod remove_dbg;\n mod auto_import;\n+mod add_missing_impl_members;\n \n fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assist>] {\n     &[\n@@ -108,6 +109,7 @@ fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assis\n         split_import::split_import,\n         remove_dbg::remove_dbg,\n         auto_import::auto_import,\n+        add_missing_impl_members::add_missing_impl_members,\n     ]\n }\n "}]}