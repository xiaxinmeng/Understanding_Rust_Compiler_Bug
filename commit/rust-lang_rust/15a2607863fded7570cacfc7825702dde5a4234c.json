{"sha": "15a2607863fded7570cacfc7825702dde5a4234c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1YTI2MDc4NjNmZGVkNzU3MGNhY2ZjNzgyNTcwMmRkZTVhNDIzNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-07T06:34:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-07T06:34:16Z"}, "message": "Auto merge of #56066 - jethrogb:jb/sgx-target, r=alexcrichton\n\nAdd SGX target to std and dependencies\n\nThis PR adds tier 3 `std` support for the `x86_64-fortanix-unknown-sgx` target.\n\n### Background\n\nIntel Software Guard Extensions (SGX) is an instruction set extension for x86 that allows executing code in fully-isolated *secure enclaves*. These enclaves reside in the address space of a regular user process, but access to the enclave's address space from outside (by e.g. the OS or a hypervisor) is blocked.\n\nFrom within such enclaves, there is no access to the operating system or hardware peripherals. In order to communicate with the outside world, enclaves require an untrusted \u201chelper\u201d program that runs as a normal user process.\n\nSGX is **not** a sandboxing technology: code inside SGX has full access to all memory belonging to the process it is running in.\n\n### Overview\n\nThe Fortanix SGX ABI (compiler target `x86_64-fortanix-unknown-sgx`) is an interface for Intel SGX enclaves. It is a small yet functional interface suitable for writing larger enclaves. In contrast to other enclave interfaces, this interface is primarly designed for running entire applications in an enclave. The interface has been under development since early 2016 and builds on Fortanix's significant experience running enclaves in production.\n\nAlso unlike other enclave interfaces, this is the only implementation of an enclave interface that is nearly pure-Rust (except for the entry point code).\n\nA description of the ABI may be found at https://docs.rs/fortanix-sgx-abi/ and https://github.com/fortanix/rust-sgx/blob/master/doc/FORTANIX-SGX-ABI.md.\n\nThe following parts of `std` are not supported and most operations will error when used:\n\n* `std::fs`\n* `std::process`\n* `std::net::UdpSocket`\n\n### Future plans\n\nA separate PR (https://github.com/rust-lang/rust/pull/56067/) will add the SGX target to the rust compiler. In the very near future, I expect to upgrade this target to tier 2.\n\nThis PR is just the initial support to make things mostly work. There will be more work coming in the future, for example to add interfaces to the native SGX primitives, implement unwinding, optimize usercalls.\n\nUDP and some form of filesystem support may be added in the future, but process support seems unlikely given the platform's constraints.\n\n### Testing build\n\n1. Install [Xargo](https://github.com/japaric/xargo): `cargo install xargo`\n2. Create a new Cargo project, for example: `cargo new --bin sgxtest`.\n3. Put the following in a file `Xargo.toml` next to your `Cargo.toml`:\n\n```toml\n[target.x86_64-fortanix-unknown-sgx.dependencies.std]\ngit = \"https://github.com/jethrogb/rust\"\nbranch = \"jb/sgx-target\"\n```\n\nNB. This can be quite slow. Instead, you can have a local checkout of that branch and use `path = \"/path/to/rust/src/libstd\"` instead. Don't forget to checkout the submodules too!\n\n4. Build:\n\n```sh\nxargo build --target x86_64-fortanix-unknown-sgx\n```\n\n### Testing execution\n\nExecution is currently only supported on x86-64 Linux, but support for Windows is planned.\n\n1. Install pre-requisites. In order to test execution, you'll need to have a CPU with Intel SGX support. SGX support needs to be enabled in the BIOS. You'll also need to install the SGX driver and Platform Software (PSW) from [Intel](https://01.org/intel-software-guard-extensions).\n\n2. Install toolchain, executor:\n```sh\ncargo install sgxs-tools --version 0.6.0-rc1\ncargo install fortanix-sgx-tools --version 0.1.0-rc1\n```\n\n3. Start the enclave:\n\n```sh\nftxsgx-elf2sgxs target/x86_64-fortanix-unknown-sgx/debug/sgxtest --heap-size 0x20000 --ssaframesize 1 --stack-size 0x20000 --threads 1 --debug\nsgxs-append -i target/x86_64-fortanix-unknown-sgx/debug/sgxtest.sgxs\nftxsgx-runner target/x86_64-fortanix-unknown-sgx/debug/sgxtest.sgxs\n```", "tree": {"sha": "c27f5e06b985789b7e6f75c63eded958fe0b643f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c27f5e06b985789b7e6f75c63eded958fe0b643f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15a2607863fded7570cacfc7825702dde5a4234c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15a2607863fded7570cacfc7825702dde5a4234c", "html_url": "https://github.com/rust-lang/rust/commit/15a2607863fded7570cacfc7825702dde5a4234c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15a2607863fded7570cacfc7825702dde5a4234c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2fb99bc17527798aeeef1d7ccc61811a9362131", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2fb99bc17527798aeeef1d7ccc61811a9362131", "html_url": "https://github.com/rust-lang/rust/commit/a2fb99bc17527798aeeef1d7ccc61811a9362131"}, {"sha": "7bea6a19641118937781d7971ba96e8d4a81497c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bea6a19641118937781d7971ba96e8d4a81497c", "html_url": "https://github.com/rust-lang/rust/commit/7bea6a19641118937781d7971ba96e8d4a81497c"}], "stats": {"total": 5224, "additions": 4978, "deletions": 246}, "files": [{"sha": "3fc6e45db3e397449b71cd5c134cb2bfac2ff142", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -61,10 +61,12 @@\n \tpath = src/tools/clang\n \turl = https://github.com/rust-lang-nursery/clang.git\n \tbranch = rust-release-80-v2\n-\n [submodule \"src/doc/rustc-guide\"]\n \tpath = src/doc/rustc-guide\n \turl = https://github.com/rust-lang/rustc-guide.git\n [submodule \"src/doc/edition-guide\"]\n \tpath = src/doc/edition-guide\n \turl = https://github.com/rust-lang-nursery/edition-guide\n+[submodule \"src/rust-sgx\"]\n+\tpath = src/rust-sgx\n+\turl = https://github.com/fortanix/rust-sgx"}, {"sha": "316724ca6515884f871a0fa376ddae87412abdd0", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -797,6 +797,14 @@ name = \"foreign-types-shared\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"fortanix-sgx-abi\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"compiler_builtins 0.0.0\",\n+ \"core 0.0.0\",\n+]\n+\n [[package]]\n name = \"fs2\"\n version = \"0.4.3\"\n@@ -2773,6 +2781,7 @@ dependencies = [\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n  \"dlmalloc 0.0.0\",\n+ \"fortanix-sgx-abi 0.0.0\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\","}, {"sha": "6108692e43c667ddaac1443e20c0a7c9f4458561", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -874,6 +874,7 @@ impl Step for Src {\n             \"src/rustc/compiler_builtins_shim\",\n             \"src/rustc/libc_shim\",\n             \"src/rustc/dlmalloc_shim\",\n+            \"src/rustc/fortanix-sgx-abi_shim\",\n             \"src/libtest\",\n             \"src/libterm\",\n             \"src/libprofiler_builtins\","}, {"sha": "de99f4b0c886f5916cd1a146464276d65bef61b8", "filename": "src/dlmalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdlmalloc?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -1 +1 @@\n-Subproject commit c99638dc2ecfc750cc1656f6edb2bd062c1e0981\n+Subproject commit de99f4b0c886f5916cd1a146464276d65bef61b8"}, {"sha": "10f4f35f9670bb29715a8c1ec01284852d47ed35", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -1 +1 @@\n-Subproject commit fe74674f6e4be76d47b66f67d529ebf4186f4eb1\n+Subproject commit 10f4f35f9670bb29715a8c1ec01284852d47ed35"}, {"sha": "5b403753da9ec8ff501adf34cb6d63b319b4a3ae", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -1 +1 @@\n-Subproject commit c75ca6465a139704e00295be355b1f067af2f535\n+Subproject commit 5b403753da9ec8ff501adf34cb6d63b319b4a3ae"}, {"sha": "95c3514185e2f87cce797e4f5a70e47643e12a8a", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -66,6 +66,12 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n     unsafe fn abort() -> ! {\n         core::intrinsics::abort();\n     }\n+\n+    #[cfg(target_env=\"sgx\")]\n+    unsafe fn abort() -> ! {\n+        extern \"C\" { pub fn panic_exit() -> !; }\n+        panic_exit();\n+    }\n }\n \n // This... is a bit of an oddity. The tl;dr; is that this is required to link"}, {"sha": "49f8a429126b70e5a31ed128d216ad366572e79f", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -62,7 +62,7 @@ cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod imp;\n-    } else if #[cfg(target_arch = \"wasm32\")] {\n+    } else if #[cfg(any(target_arch = \"wasm32\", target_env = \"sgx\"))] {\n         #[path = \"dummy.rs\"]\n         mod imp;\n     } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {"}, {"sha": "274d5bec6622fbdcf78ae08fa43eb62b32ba4693", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -35,9 +35,12 @@ rustc_lsan = { path = \"../librustc_lsan\" }\n rustc_msan = { path = \"../librustc_msan\" }\n rustc_tsan = { path = \"../librustc_tsan\" }\n \n-[target.'cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))'.dependencies]\n+[target.'cfg(any(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")), target_env = \"sgx\"))'.dependencies]\n dlmalloc = { path = '../rustc/dlmalloc_shim' }\n \n+[target.x86_64-fortanix-unknown-sgx.dependencies]\n+fortanix-sgx-abi = { path = \"../rustc/fortanix-sgx-abi_shim\" }\n+\n [build-dependencies]\n cc = \"1.0\"\n build_helper = { path = \"../build_helper\" }"}, {"sha": "32e29962760bf7d4b9f4344f180acd25b07014e2", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -184,7 +184,7 @@ pub enum ErrorKind {\n }\n \n impl ErrorKind {\n-    fn as_str(&self) -> &'static str {\n+    pub(crate) fn as_str(&self) -> &'static str {\n         match *self {\n             ErrorKind::NotFound => \"entity not found\",\n             ErrorKind::PermissionDenied => \"permission denied\","}, {"sha": "c2aaeb98907454c069cfd9a88702e23bd1437a7c", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -26,6 +26,7 @@ const fn done<T>() -> *mut Arc<T> { 1_usize as *mut _ }\n unsafe impl<T> Sync for Lazy<T> {}\n \n impl<T> Lazy<T> {\n+    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Lazy<T> {\n         Lazy {\n             lock: Mutex::new(),"}, {"sha": "66771b3c4a2f01fda1faaa4b77808b68d58c441a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -312,6 +312,8 @@\n #![feature(non_exhaustive)]\n #![feature(alloc_layout_extra)]\n #![feature(maybe_uninit)]\n+#![cfg_attr(target_env = \"sgx\", feature(global_asm, range_contains, slice_index_methods,\n+                                        decl_macro, coerce_unsized))]\n \n #![default_lib_allocator]\n \n@@ -354,6 +356,12 @@ extern crate unwind;\n // testing gives test-std access to real-std lang items and globals. See #2912\n #[cfg(test)] extern crate std as realstd;\n \n+#[cfg(target_env = \"sgx\")]\n+#[macro_use]\n+#[allow(unused_imports)] // FIXME: without `#[macro_use]`, get error: \u201ccannot\n+                         // determine resolution for the macro `usercalls_asm`\u201d\n+extern crate fortanix_sgx_abi;\n+\n // The standard macros that are not built-in to the compiler.\n #[macro_use]\n mod macros;"}, {"sha": "1ac0bdf922f885a598ef691c3a34ff5ef7d1a82e", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -16,10 +16,11 @@ use net::{ntoh, hton, IpAddr, Ipv4Addr, Ipv6Addr};\n use option;\n use sys::net::netc as c;\n use sys_common::{FromInner, AsInner, IntoInner};\n-use sys_common::net::lookup_host;\n+use sys_common::net::LookupHost;\n use vec;\n use iter;\n use slice;\n+use convert::TryInto;\n \n /// An internet socket address, either IPv4 or IPv6.\n ///\n@@ -863,9 +864,9 @@ impl ToSocketAddrs for (Ipv6Addr, u16) {\n     }\n }\n \n-fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> {\n-    let ips = lookup_host(s)?;\n-    let v: Vec<_> = ips.map(|mut a| { a.set_port(p); a }).collect();\n+fn resolve_socket_addr(lh: LookupHost) -> io::Result<vec::IntoIter<SocketAddr>> {\n+    let p = lh.port();\n+    let v: Vec<_> = lh.map(|mut a| { a.set_port(p); a }).collect();\n     Ok(v.into_iter())\n }\n \n@@ -885,7 +886,7 @@ impl<'a> ToSocketAddrs for (&'a str, u16) {\n             return Ok(vec![SocketAddr::V6(addr)].into_iter())\n         }\n \n-        resolve_socket_addr(host, port)\n+        resolve_socket_addr((host, port).try_into()?)\n     }\n }\n \n@@ -899,22 +900,7 @@ impl ToSocketAddrs for str {\n             return Ok(vec![addr].into_iter());\n         }\n \n-        macro_rules! try_opt {\n-            ($e:expr, $msg:expr) => (\n-                match $e {\n-                    Some(r) => r,\n-                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                                      $msg)),\n-                }\n-            )\n-        }\n-\n-        // split the string by ':' and convert the second part to u16\n-        let mut parts_iter = self.rsplitn(2, ':');\n-        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n-        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n-        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n-        resolve_socket_addr(host, port)\n+        resolve_socket_addr(self.try_into()?)\n     }\n }\n "}, {"sha": "ff579a5feb12dff1781534e8dd1f1a0f413f6905", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -112,11 +112,15 @@ fn hton<I: NetInt>(i: I) -> I { i.to_be() }\n fn ntoh<I: NetInt>(i: I) -> I { I::from_be(i) }\n \n fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n-    where F: FnMut(&SocketAddr) -> io::Result<T>\n+    where F: FnMut(io::Result<&SocketAddr>) -> io::Result<T>\n {\n+    let addrs = match addr.to_socket_addrs() {\n+        Ok(addrs) => addrs,\n+        Err(e) => return f(Err(e))\n+    };\n     let mut last_err = None;\n-    for addr in addr.to_socket_addrs()? {\n-        match f(&addr) {\n+    for addr in addrs {\n+        match f(Ok(&addr)) {\n             Ok(l) => return Ok(l),\n             Err(e) => last_err = Some(e),\n         }"}, {"sha": "b70d56f9e593d7fc259eb129873e309e10db3770", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -29,7 +29,7 @@ use intrinsics;\n use mem;\n use ptr;\n use raw;\n-use sys::stdio::{Stderr, stderr_prints_nothing};\n+use sys::stdio::panic_output;\n use sys_common::rwlock::RWLock;\n use sys_common::thread_info;\n use sys_common::util;\n@@ -193,7 +193,6 @@ fn default_hook(info: &PanicInfo) {\n             None => \"Box<Any>\",\n         }\n     };\n-    let mut err = Stderr::new().ok();\n     let thread = thread_info::current_thread();\n     let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n \n@@ -215,17 +214,14 @@ fn default_hook(info: &PanicInfo) {\n         }\n     };\n \n-    let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n-    match (prev, err.as_mut()) {\n-       (Some(mut stderr), _) => {\n-           write(&mut *stderr);\n-           let mut s = Some(stderr);\n-           LOCAL_STDERR.with(|slot| {\n-               *slot.borrow_mut() = s.take();\n-           });\n-       }\n-       (None, Some(ref mut err)) => { write(err) }\n-       _ => {}\n+    if let Some(mut local) = LOCAL_STDERR.with(|s| s.borrow_mut().take()) {\n+       write(&mut *local);\n+       let mut s = Some(local);\n+       LOCAL_STDERR.with(|slot| {\n+           *slot.borrow_mut() = s.take();\n+       });\n+    } else if let Some(mut out) = panic_output() {\n+        write(&mut out);\n     }\n }\n \n@@ -485,7 +481,7 @@ fn rust_panic_with_hook(payload: &mut dyn BoxMeUp,\n             // Some platforms know that printing to stderr won't ever actually\n             // print anything, and if that's the case we can skip the default\n             // hook.\n-            Hook::Default if stderr_prints_nothing() => {}\n+            Hook::Default if panic_output().is_none() => {}\n             Hook::Default => {\n                 info.set_payload(payload.get());\n                 default_hook(&info);\n@@ -494,7 +490,7 @@ fn rust_panic_with_hook(payload: &mut dyn BoxMeUp,\n                 info.set_payload(payload.get());\n                 (*ptr)(&info);\n             }\n-        }\n+        };\n         HOOK_LOCK.read_unlock();\n     }\n "}, {"sha": "7229e71d175213a0fdca195620d913e67fca97ca", "filename": "src/libstd/sys/cloudabi/shims/net.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -13,13 +13,14 @@ use io;\n use net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use time::Duration;\n use sys::{unsupported, Void};\n+use convert::TryFrom;\n \n pub extern crate libc as netc;\n \n pub struct TcpStream(Void);\n \n impl TcpStream {\n-    pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n         unsupported()\n     }\n \n@@ -105,7 +106,7 @@ impl fmt::Debug for TcpStream {\n pub struct TcpListener(Void);\n \n impl TcpListener {\n-    pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n         unsupported()\n     }\n \n@@ -155,7 +156,7 @@ impl fmt::Debug for TcpListener {\n pub struct UdpSocket(Void);\n \n impl UdpSocket {\n-    pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n         unsupported()\n     }\n \n@@ -271,7 +272,7 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n         match self.0 {}\n     }\n }\n@@ -284,13 +285,31 @@ impl fmt::Debug for UdpSocket {\n \n pub struct LookupHost(Void);\n \n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        match self.0 {}\n+    }\n+}\n+\n impl Iterator for LookupHost {\n     type Item = SocketAddr;\n     fn next(&mut self) -> Option<SocketAddr> {\n         match self.0 {}\n     }\n }\n \n-pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n-    unsupported()\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n }"}, {"sha": "c90dbd8beab869ea1cab1ebea50dc511c3a440a6", "filename": "src/libstd/sys/cloudabi/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -78,6 +78,6 @@ pub fn is_ebadf(err: &io::Error) -> bool {\n \n pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n \n-pub fn stderr_prints_nothing() -> bool {\n-    false\n+pub fn panic_output() -> Option<impl io::Write> {\n+    Stderr::new().ok()\n }"}, {"sha": "a76e1fa3345cdbc5c231622814e5b5ff494823a8", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -32,7 +32,8 @@ unsafe impl Send for Thread {}\n unsafe impl Sync for Thread {}\n \n impl Thread {\n-    pub unsafe fn new<'a>(stack: usize, p: Box<dyn FnBox() + 'a>) -> io::Result<Thread> {\n+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnBox()>) -> io::Result<Thread> {\n         let p = box p;\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();"}, {"sha": "04c47aeb8276b80e0e10e67a95e58f5e0cc47368", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -48,6 +48,9 @@ cfg_if! {\n     } else if #[cfg(target_arch = \"wasm32\")] {\n         mod wasm;\n         pub use self::wasm::*;\n+    } else if #[cfg(target_env = \"sgx\")] {\n+        mod sgx;\n+        pub use self::sgx::*;\n     } else {\n         compile_error!(\"libstd doesn't compile for this platform yet\");\n     }"}, {"sha": "04a183f2417a9f997ea2d6c914bcc85ddc078dbe", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "modified", "additions": 94, "deletions": 59, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n use fs::File;\n-use io::{Error, Result, Read};\n+use io::{Error, Read, self};\n use iter::Iterator;\n use net::{Ipv4Addr, SocketAddr, SocketAddrV4};\n use str::FromStr;\n use string::{String, ToString};\n use sys::syscall::EINVAL;\n use time::{self, Duration};\n use vec::{IntoIter, Vec};\n+use convert::{TryFrom, TryInto};\n \n use self::dns::{Dns, DnsQuery};\n \n@@ -29,7 +30,13 @@ mod dns;\n mod tcp;\n mod udp;\n \n-pub struct LookupHost(IntoIter<SocketAddr>);\n+pub struct LookupHost(IntoIter<SocketAddr>, u16);\n+\n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        self.1\n+    }\n+}\n \n impl Iterator for LookupHost {\n     type Item = SocketAddr;\n@@ -38,65 +45,93 @@ impl Iterator for LookupHost {\n     }\n }\n \n-pub fn lookup_host(host: &str) -> Result<LookupHost> {\n-    let mut ip_string = String::new();\n-    File::open(\"/etc/net/ip\")?.read_to_string(&mut ip_string)?;\n-    let ip: Vec<u8> = ip_string.trim().split('.').map(|part| part.parse::<u8>()\n-                               .unwrap_or(0)).collect();\n-\n-    let mut dns_string = String::new();\n-    File::open(\"/etc/net/dns\")?.read_to_string(&mut dns_string)?;\n-    let dns: Vec<u8> = dns_string.trim().split('.').map(|part| part.parse::<u8>()\n-                                 .unwrap_or(0)).collect();\n-\n-    if ip.len() == 4 && dns.len() == 4 {\n-        let time = time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap();\n-        let tid = (time.subsec_nanos() >> 16) as u16;\n-\n-        let packet = Dns {\n-            transaction_id: tid,\n-            flags: 0x0100,\n-            queries: vec![DnsQuery {\n-                name: host.to_string(),\n-                q_type: 0x0001,\n-                q_class: 0x0001,\n-            }],\n-            answers: vec![]\n-        };\n-\n-        let packet_data = packet.compile();\n-\n-        let my_ip = Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3]);\n-        let dns_ip = Ipv4Addr::new(dns[0], dns[1], dns[2], dns[3]);\n-        let socket = UdpSocket::bind(&SocketAddr::V4(SocketAddrV4::new(my_ip, 0)))?;\n-        socket.set_read_timeout(Some(Duration::new(5, 0)))?;\n-        socket.set_write_timeout(Some(Duration::new(5, 0)))?;\n-        socket.connect(&SocketAddr::V4(SocketAddrV4::new(dns_ip, 53)))?;\n-        socket.send(&packet_data)?;\n-\n-        let mut buf = [0; 65536];\n-        let count = socket.recv(&mut buf)?;\n-\n-        match Dns::parse(&buf[.. count]) {\n-            Ok(response) => {\n-                let mut addrs = vec![];\n-                for answer in response.answers.iter() {\n-                    if answer.a_type == 0x0001 && answer.a_class == 0x0001\n-                       && answer.data.len() == 4\n-                    {\n-                        let answer_ip = Ipv4Addr::new(answer.data[0],\n-                                                      answer.data[1],\n-                                                      answer.data[2],\n-                                                      answer.data[3]);\n-                        addrs.push(SocketAddr::V4(SocketAddrV4::new(answer_ip, 0)));\n-                    }\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(s: &str) -> io::Result<LookupHost> {\n+        macro_rules! try_opt {\n+            ($e:expr, $msg:expr) => (\n+                match $e {\n+                    Some(r) => r,\n+                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                                      $msg)),\n                 }\n-                Ok(LookupHost(addrs.into_iter()))\n-            },\n-            Err(_err) => Err(Error::from_raw_os_error(EINVAL))\n+            )\n+        }\n+\n+        // split the string by ':' and convert the second part to u16\n+        let mut parts_iter = s.rsplitn(2, ':');\n+        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n+\n+        (host, port).try_into()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n+        let mut ip_string = String::new();\n+        File::open(\"/etc/net/ip\")?.read_to_string(&mut ip_string)?;\n+        let ip: Vec<u8> = ip_string.trim().split('.').map(|part| part.parse::<u8>()\n+                                   .unwrap_or(0)).collect();\n+\n+        let mut dns_string = String::new();\n+        File::open(\"/etc/net/dns\")?.read_to_string(&mut dns_string)?;\n+        let dns: Vec<u8> = dns_string.trim().split('.').map(|part| part.parse::<u8>()\n+                                     .unwrap_or(0)).collect();\n+\n+        if ip.len() == 4 && dns.len() == 4 {\n+            let time = time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap();\n+            let tid = (time.subsec_nanos() >> 16) as u16;\n+\n+            let packet = Dns {\n+                transaction_id: tid,\n+                flags: 0x0100,\n+                queries: vec![DnsQuery {\n+                    name: host.to_string(),\n+                    q_type: 0x0001,\n+                    q_class: 0x0001,\n+                }],\n+                answers: vec![]\n+            };\n+\n+            let packet_data = packet.compile();\n+\n+            let my_ip = Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3]);\n+            let dns_ip = Ipv4Addr::new(dns[0], dns[1], dns[2], dns[3]);\n+            let socket = UdpSocket::bind(Ok(&SocketAddr::V4(SocketAddrV4::new(my_ip, 0))))?;\n+            socket.set_read_timeout(Some(Duration::new(5, 0)))?;\n+            socket.set_write_timeout(Some(Duration::new(5, 0)))?;\n+            socket.connect(Ok(&SocketAddr::V4(SocketAddrV4::new(dns_ip, 53))))?;\n+            socket.send(&packet_data)?;\n+\n+            let mut buf = [0; 65536];\n+            let count = socket.recv(&mut buf)?;\n+\n+            match Dns::parse(&buf[.. count]) {\n+                Ok(response) => {\n+                    let mut addrs = vec![];\n+                    for answer in response.answers.iter() {\n+                        if answer.a_type == 0x0001 && answer.a_class == 0x0001\n+                           && answer.data.len() == 4\n+                        {\n+                            let answer_ip = Ipv4Addr::new(answer.data[0],\n+                                                          answer.data[1],\n+                                                          answer.data[2],\n+                                                          answer.data[3]);\n+                            addrs.push(SocketAddr::V4(SocketAddrV4::new(answer_ip, 0)));\n+                        }\n+                    }\n+                    Ok(LookupHost(addrs.into_iter(), port))\n+                },\n+                Err(_err) => Err(Error::from_raw_os_error(EINVAL))\n+            }\n+        } else {\n+            Err(Error::from_raw_os_error(EINVAL))\n         }\n-    } else {\n-        Err(Error::from_raw_os_error(EINVAL))\n     }\n }\n "}, {"sha": "37457d87f331b6fe0affbb7008e0feb06aff7b9b", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -24,8 +24,8 @@ use super::{path_to_peer_addr, path_to_local_addr};\n pub struct TcpStream(File);\n \n impl TcpStream {\n-    pub fn connect(addr: &SocketAddr) -> Result<TcpStream> {\n-        let path = format!(\"tcp:{}\", addr);\n+    pub fn connect(addr: Result<&SocketAddr>) -> Result<TcpStream> {\n+        let path = format!(\"tcp:{}\", addr?);\n         let mut options = OpenOptions::new();\n         options.read(true);\n         options.write(true);\n@@ -180,8 +180,8 @@ impl IntoInner<File> for TcpStream {\n pub struct TcpListener(File);\n \n impl TcpListener {\n-    pub fn bind(addr: &SocketAddr) -> Result<TcpListener> {\n-        let path = format!(\"tcp:/{}\", addr);\n+    pub fn bind(addr: Result<&SocketAddr>) -> Result<TcpListener> {\n+        let path = format!(\"tcp:/{}\", addr?);\n         let mut options = OpenOptions::new();\n         options.read(true);\n         options.write(true);"}, {"sha": "85bfd425924934ed313116e3664eecbf1d126367", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -25,8 +25,8 @@ use super::{path_to_peer_addr, path_to_local_addr};\n pub struct UdpSocket(File, UnsafeCell<Option<SocketAddr>>);\n \n impl UdpSocket {\n-    pub fn bind(addr: &SocketAddr) -> Result<UdpSocket> {\n-        let path = format!(\"udp:/{}\", addr);\n+    pub fn bind(addr: Result<&SocketAddr>) -> Result<UdpSocket> {\n+        let path = format!(\"udp:/{}\", addr?);\n         let mut options = OpenOptions::new();\n         options.read(true);\n         options.write(true);\n@@ -37,8 +37,8 @@ impl UdpSocket {\n         unsafe { &mut *(self.1.get()) }\n     }\n \n-    pub fn connect(&self, addr: &SocketAddr) -> Result<()> {\n-        unsafe { *self.1.get() = Some(*addr) };\n+    pub fn connect(&self, addr: Result<&SocketAddr>) -> Result<()> {\n+        unsafe { *self.1.get() = Some(*addr?) };\n         Ok(())\n     }\n "}, {"sha": "52cd9334ffbbf4ab7b9c0c987ad57327446397d0", "filename": "src/libstd/sys/redox/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -76,6 +76,6 @@ pub fn is_ebadf(err: &io::Error) -> bool {\n \n pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n \n-pub fn stderr_prints_nothing() -> bool {\n-    false\n+pub fn panic_output() -> Option<impl io::Write> {\n+    Stderr::new().ok()\n }"}, {"sha": "ff86180538283c4ed092535a9f800a240837dcc4", "filename": "src/libstd/sys/redox/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -28,7 +28,8 @@ unsafe impl Send for Thread {}\n unsafe impl Sync for Thread {}\n \n impl Thread {\n-    pub unsafe fn new<'a>(_stack: usize, p: Box<dyn FnBox() + 'a>) -> io::Result<Thread> {\n+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+    pub unsafe fn new(_stack: usize, p: Box<dyn FnBox()>) -> io::Result<Thread> {\n         let p = box p;\n \n         let id = cvt(syscall::clone(syscall::CLONE_VM | syscall::CLONE_FS | syscall::CLONE_FILES))?;"}, {"sha": "4d5cc02e11e2ccdb93e0ee91961ee5d3312e2719", "filename": "src/libstd/sys/sgx/abi/entry.S", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,327 @@\n+/* Copyright 2018 The Rust Project Developers. See the COPYRIGHT     */\n+/* file at the top-level directory of this distribution and at       */\n+/* http://rust-lang.org/COPYRIGHT.                                   */\n+/*                                                                   */\n+/* Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or */\n+/* http://www.apache.org/licenses/LICENSE-2.0> or the MIT license    */\n+/* <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your      */\n+/* option. This file may not be copied, modified, or distributed     */\n+/* except according to those terms.                                  */\n+\n+/*  This symbol is used at runtime to figure out the virtual address that the */\n+/*  enclave is loaded at. */\n+.section absolute\n+.global IMAGE_BASE\n+IMAGE_BASE:\n+\n+.section .rodata\n+/*  The XSAVE area needs to be a large chunk of readable memory, but since we are */\n+/*  going to restore everything to its initial state (XSTATE_BV=0), only certain */\n+/*  parts need to have a defined value. In particular: */\n+/*  */\n+/*    * MXCSR in the legacy area. This register is always restored if RFBM[1] or */\n+/*      RFBM[2] is set, regardless of the value of XSTATE_BV */\n+/*    * XSAVE header */\n+.align 64\n+.Lxsave_clear:\n+.org .+24\n+.Lxsave_mxcsr:\n+    .int 0\n+\n+/*  We can store a bunch of data in the gap between MXCSR and the XSAVE header */\n+\n+/*  The following symbols point at read-only data that will be filled in by the */\n+/*  post-linker. */\n+\n+/*  When using this macro, don't forget to adjust the linker version script! */\n+.macro globvar name:req size:req\n+    .global \\name\n+    .protected \\name\n+    .align \\size\n+    .size \\name , \\size\n+    \\name :\n+        .org .+\\size\n+.endm\n+    /*  The base address (relative to enclave start) of the heap area */\n+    globvar HEAP_BASE 8\n+    /*  The heap size in bytes */\n+    globvar HEAP_SIZE 8\n+    /*  Value of the RELA entry in the dynamic table */\n+    globvar RELA 8\n+    /*  Value of the RELACOUNT entry in the dynamic table */\n+    globvar RELACOUNT 8\n+    /*  The enclave size in bytes */\n+    globvar ENCLAVE_SIZE 8\n+    /*  The base address (relative to enclave start) of the enclave configuration area */\n+    globvar CFGDATA_BASE 8\n+    /*  Non-zero if debugging is enabled, zero otherwise */\n+    globvar DEBUG 1\n+\n+.Lreentry_panic_msg:\n+    .asciz \"Re-entered panicked enclave!\"\n+.Lreentry_panic_msg_end:\n+\n+.Lusercall_panic_msg:\n+    .asciz \"Invalid usercall#!\"\n+.Lusercall_panic_msg_end:\n+\n+.org .Lxsave_clear+512\n+.Lxsave_header:\n+    .int 0, 0 /*  XSTATE_BV */\n+    .int 0, 0 /*  XCOMP_BV */\n+    .org .+48 /*  reserved bits */\n+\n+.data\n+.Lpanicked:\n+    .byte 0\n+\n+/*  TCS local storage section */\n+.equ tcsls_tos,                 0x00 /*  initialized by loader to *offset* from image base to TOS */\n+.equ tcsls_flags,               0x08 /*  initialized by loader */\n+.equ tcsls_flag_secondary,      0    /*  initialized by loader; 0 = standard TCS, 1 = secondary TCS */\n+.equ tcsls_flag_init_once,      1    /*  initialized by loader to 0 */\n+/*  14 unused bits */\n+.equ tcsls_user_fcw,            0x0a\n+.equ tcsls_user_mxcsr,          0x0c\n+.equ tcsls_last_rsp,            0x10 /*  initialized by loader to 0 */\n+.equ tcsls_panic_last_rsp,      0x18 /*  initialized by loader to 0 */\n+.equ tcsls_debug_panic_buf_ptr, 0x20 /*  initialized by loader to 0 */\n+.equ tcsls_user_rsp,            0x28\n+.equ tcsls_user_retip,          0x30\n+.equ tcsls_user_rbp,            0x38\n+.equ tcsls_user_r12,            0x40\n+.equ tcsls_user_r13,            0x48\n+.equ tcsls_user_r14,            0x50\n+.equ tcsls_user_r15,            0x58\n+.equ tcsls_tls_ptr,             0x60\n+.equ tcsls_tcs_addr,            0x68\n+\n+.macro load_tcsls_flag_secondary_bool reg:req comments:vararg\n+    .ifne tcsls_flag_secondary /* to convert to a bool, must be the first bit */\n+    .abort\n+    .endif\n+        mov $(1<<tcsls_flag_secondary),%e\\reg\n+        and %gs:tcsls_flags,%\\reg\n+.endm\n+\n+.text\n+.global sgx_entry\n+.type sgx_entry,function\n+sgx_entry:\n+/*  save user registers */\n+    mov %rcx,%gs:tcsls_user_retip\n+    mov %rsp,%gs:tcsls_user_rsp\n+    mov %rbp,%gs:tcsls_user_rbp\n+    mov %r12,%gs:tcsls_user_r12\n+    mov %r13,%gs:tcsls_user_r13\n+    mov %r14,%gs:tcsls_user_r14\n+    mov %r15,%gs:tcsls_user_r15\n+    mov %rbx,%gs:tcsls_tcs_addr\n+    stmxcsr %gs:tcsls_user_mxcsr\n+    fnstcw %gs:tcsls_user_fcw\n+/*  reset user state */\n+    cld /* x86-64 ABI requires DF to be unset at function entry/exit */\n+/*  check for debug buffer pointer */\n+    testb  $0xff,DEBUG(%rip)\n+    jz .Lskip_debug_init\n+    mov %r10,%gs:tcsls_debug_panic_buf_ptr\n+.Lskip_debug_init:\n+/*  check if returning from usercall */\n+    mov %gs:tcsls_last_rsp,%r11\n+    test %r11,%r11\n+    jnz .Lusercall_ret\n+/*  setup stack */\n+    mov %gs:tcsls_tos,%rsp /*  initially, RSP is not set to the correct value */\n+                           /*  here. This is fixed below under \"adjust stack\". */\n+/*  check for thread init */\n+    bts $tcsls_flag_init_once,%gs:tcsls_flags\n+    jc .Lskip_init\n+/*  adjust stack */\n+    lea IMAGE_BASE(%rip),%rax\n+    add %rax,%rsp\n+    mov %rsp,%gs:tcsls_tos\n+/*  call tcs_init */\n+/*  store caller-saved registers in callee-saved registers */\n+    mov %rdi,%rbx\n+    mov %rsi,%r12\n+    mov %rdx,%r13\n+    mov %r8,%r14\n+    mov %r9,%r15\n+    load_tcsls_flag_secondary_bool di /* RDI = tcs_init() argument: secondary: bool */\n+    call tcs_init\n+/*  reload caller-saved registers */\n+    mov %rbx,%rdi\n+    mov %r12,%rsi\n+    mov %r13,%rdx\n+    mov %r14,%r8\n+    mov %r15,%r9\n+.Lskip_init:\n+/*  check for panic */\n+    bt $0,.Lpanicked(%rip)\n+    jc .Lreentry_panic\n+/*  call into main entry point */\n+    load_tcsls_flag_secondary_bool cx /* RCX = entry() argument: secondary: bool */\n+    call entry /* RDI, RSI, RDX, R8, R9 passed in from userspace */\n+    mov %rax,%rsi  /* RSI = return value */\n+    /* NOP: mov %rdx,%rdx */ /*  RDX = return value */\n+    xor %rdi,%rdi  /* RDI = normal exit */\n+.Lexit:\n+/*  clear general purpose register state */\n+    /*  RAX overwritten by ENCLU */\n+    /*  RBX set later */\n+    /*  RCX overwritten by ENCLU */\n+    /*  RDX contains return value */\n+    /*  RSP set later */\n+    /*  RBP set later */\n+    /*  RDI contains exit mode */\n+    /*  RSI contains return value */\n+    xor %r8,%r8\n+    xor %r9,%r9\n+    xor %r10,%r10\n+    xor %r11,%r11\n+    /*  R12 ~ R15 set by sgx_exit */\n+.Lsgx_exit:\n+/*  clear extended register state */\n+    mov %rdx, %rcx /*  save RDX */\n+    mov $-1, %rax\n+    mov %rax, %rdx\n+    xrstor .Lxsave_clear(%rip)\n+    mov %rcx, %rdx /*  restore RDX */\n+/*  clear flags */\n+    pushq $0\n+    popfq\n+/*  restore user registers */\n+    mov %gs:tcsls_user_r12,%r12\n+    mov %gs:tcsls_user_r13,%r13\n+    mov %gs:tcsls_user_r14,%r14\n+    mov %gs:tcsls_user_r15,%r15\n+    mov %gs:tcsls_user_retip,%rbx\n+    mov %gs:tcsls_user_rsp,%rsp\n+    mov %gs:tcsls_user_rbp,%rbp\n+    fldcw %gs:tcsls_user_fcw\n+    ldmxcsr %gs:tcsls_user_mxcsr\n+/*  exit enclave */\n+    mov $0x4,%eax /*  EEXIT */\n+    enclu\n+/*  end sgx_entry */\n+\n+.Lreentry_panic:\n+    lea .Lreentry_panic_msg(%rip),%rdi\n+    mov $.Lreentry_panic_msg_end-.Lreentry_panic_msg,%esi\n+    orq $8,%rsp\n+    jmp panic_msg\n+\n+.Lusercall_panic:\n+    lea .Lusercall_panic_msg(%rip),%rdi\n+    mov $.Lusercall_panic_msg_end-.Lusercall_panic_msg,%esi\n+    orq $8,%rsp\n+    jmp panic_msg\n+\n+.macro push_callee_saved_registers\n+    push %r15\n+    push %r14\n+    push %r13\n+    push %r12\n+    push %rbp\n+    push %rbx\n+    sub $8, %rsp\n+    fstcw 4(%rsp)\n+    stmxcsr (%rsp)\n+.endm\n+\n+.global panic_exit\n+panic_exit:\n+/* save registers in DEBUG mode, so that debugger can reconstruct the stack */\n+    testb $0xff,DEBUG(%rip)\n+    jz .Lskip_save_registers\n+    push_callee_saved_registers\n+    movq %rsp,%gs:tcsls_panic_last_rsp\n+.Lskip_save_registers:\n+/* set panicked bit */\n+    movb $1,.Lpanicked(%rip)\n+/* call usercall exit(true) */\n+    mov $1,%esi   /*  RSI = usercall() argument: panic = true */\n+    xor %rdx,%rdx /*  RDX cleared */\n+    movq $usercall_nr_exit,%rdi /*  RDI = usercall exit */\n+    jmp .Lexit\n+\n+/*  This *MUST* be called with 6 parameters, otherwise register information */\n+/*  might leak! */\n+.global usercall\n+usercall:\n+    test %rdi,%rdi\n+    jle .Lusercall_panic\n+/*  save callee-saved state */\n+    push_callee_saved_registers\n+    movq %rsp,%gs:tcsls_last_rsp\n+/*  clear general purpose register state */\n+    /*  RAX overwritten by ENCLU */\n+    /*  RBX set by sgx_exit */\n+    /*  RCX overwritten by ENCLU */\n+    /*  RDX contains parameter */\n+    /*  RSP set by sgx_exit */\n+    /*  RBP set by sgx_exit */\n+    /*  RDI contains parameter */\n+    /*  RSI contains parameter */\n+    /*  R8 contains parameter */\n+    /*  R9 contains parameter */\n+    xor %r10,%r10\n+    xor %r11,%r11\n+    /*  R12 ~ R15 set by sgx_exit */\n+/*  extended registers/flags cleared by sgx_exit */\n+/*  exit */\n+    jmp .Lsgx_exit\n+.Lusercall_ret:\n+    movq $0,%gs:tcsls_last_rsp\n+/*  restore callee-saved state, cf. push_callee_saved_registers */\n+    mov %r11,%rsp\n+    ldmxcsr (%rsp)\n+    fldcw 4(%rsp)\n+    add $8, %rsp\n+    pop %rbx\n+    pop %rbp\n+    pop %r12\n+    pop %r13\n+    pop %r14\n+    pop %r15\n+/*  return */\n+    mov %rsi,%rax /*  RAX = return value */\n+    /* NOP: mov %rdx,%rdx */ /*  RDX = return value */\n+    ret\n+\n+/*\n+The following functions need to be defined externally:\n+```\n+// Called by entry code when it needs to panic\n+extern \"C\" fn panic_msg(msg: &'static str) -> ! {\n+    panic!(msg)\n+}\n+\n+// Called once when a TCS is first entered\n+extern \"C\" fn tcs_init(secondary: bool);\n+\n+// Standard TCS entrypoint\n+extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> (u64, u64);\n+```\n+*/\n+\n+.global get_tcs_addr\n+get_tcs_addr:\n+    mov %gs:tcsls_tcs_addr,%rax\n+    ret\n+\n+.global get_tls_ptr\n+get_tls_ptr:\n+    mov %gs:tcsls_tls_ptr,%rax\n+    ret\n+\n+.global set_tls_ptr\n+set_tls_ptr:\n+    mov %rdi,%gs:tcsls_tls_ptr\n+    ret\n+\n+.global take_debug_panic_buf_ptr\n+take_debug_panic_buf_ptr:\n+    xor %rax,%rax\n+    xchg %gs:tcsls_debug_panic_buf_ptr,%rax\n+    ret"}, {"sha": "508f2ff4d4fa5e4b9cb95308555111550cee95b1", "filename": "src/libstd/sys/sgx/abi/mem.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Do not remove inline: will result in relocation failure\n+#[inline(always)]\n+pub unsafe fn rel_ptr<T>(offset: u64) -> *const T {\n+    (image_base() + offset) as *const T\n+}\n+\n+// Do not remove inline: will result in relocation failure\n+#[inline(always)]\n+pub unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n+    (image_base() + offset) as *mut T\n+}\n+\n+extern {\n+    static ENCLAVE_SIZE: usize;\n+}\n+\n+// Do not remove inline: will result in relocation failure\n+// For the same reason we use inline ASM here instead of an extern static to\n+// locate the base\n+#[inline(always)]\n+fn image_base() -> u64 {\n+    let base;\n+    unsafe { asm!(\"lea IMAGE_BASE(%rip),$0\":\"=r\"(base)) };\n+    base\n+}\n+\n+pub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n+    let start=p as u64;\n+    let end=start + (len as u64);\n+    start >= image_base() &&\n+        end <= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n+}\n+\n+pub fn is_user_range(p: *const u8, len: usize) -> bool {\n+    let start=p as u64;\n+    let end=start + (len as u64);\n+    end <= image_base() ||\n+        start >= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n+}"}, {"sha": "069cca3b98e2733951570a0d0e143c8365b4aebf", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::sync::atomic::{AtomicUsize, Ordering};\n+use io::Write;\n+\n+// runtime features\n+mod reloc;\n+mod mem;\n+pub(super) mod panic;\n+\n+// library features\n+pub mod thread;\n+pub mod tls;\n+#[macro_use]\n+pub mod usercalls;\n+\n+global_asm!(concat!(usercalls_asm!(), include_str!(\"entry.S\")));\n+\n+#[no_mangle]\n+unsafe extern \"C\" fn tcs_init(secondary: bool) {\n+    // Be very careful when changing this code: it runs before the binary has been\n+    // relocated. Any indirect accesses to symbols will likely fail.\n+    const UNINIT: usize = 0;\n+    const BUSY: usize = 1;\n+    const DONE: usize = 2;\n+    // Three-state spin-lock\n+    static RELOC_STATE: AtomicUsize = AtomicUsize::new(UNINIT);\n+\n+    if secondary && RELOC_STATE.load(Ordering::Relaxed) != DONE {\n+        panic::panic_msg(\"Entered secondary TCS before main TCS!\")\n+    }\n+\n+    // Try to atomically swap UNINIT with BUSY. The returned state can be:\n+    match RELOC_STATE.compare_and_swap(UNINIT, BUSY, Ordering::Acquire) {\n+        // This thread just obtained the lock and other threads will observe BUSY\n+        UNINIT => {\n+            reloc::relocate_elf_rela();\n+            RELOC_STATE.store(DONE, Ordering::Release);\n+        },\n+        // We need to wait until the initialization is done.\n+        BUSY => while RELOC_STATE.load(Ordering::Acquire) == BUSY  {\n+            ::core::arch::x86_64::_mm_pause()\n+        },\n+        // Initialization is done.\n+        DONE => {},\n+        _ => unreachable!()\n+    }\n+}\n+\n+// FIXME: this item should only exist if this is linked into an executable\n+// (main function exists). If this is a library, the crate author should be\n+// able to specify this\n+#[no_mangle]\n+extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> (u64, u64) {\n+    // FIXME: how to support TLS in library mode?\n+    let tls = Box::new(tls::Tls::new());\n+    let _tls_guard = unsafe { tls.activate() };\n+\n+    if secondary {\n+        super::thread::Thread::entry();\n+\n+        (0, 0)\n+    } else {\n+        extern \"C\" {\n+            fn main(argc: isize, argv: *const *const u8) -> isize;\n+        }\n+\n+        // check entry is being called according to ABI\n+        assert_eq!(p3, 0);\n+        assert_eq!(p4, 0);\n+        assert_eq!(p5, 0);\n+\n+        unsafe {\n+            // The actual types of these arguments are `p1: *const Arg, p2:\n+            // usize`. We can't currently customize the argument list of Rust's\n+            // main function, so we pass these in as the standard pointer-sized\n+            // values in `argc` and `argv`.\n+            let ret = main(p2 as _, p1 as _);\n+            exit_with_code(ret)\n+        }\n+    }\n+}\n+\n+pub(super) fn exit_with_code(code: isize) -> ! {\n+    if code != 0 {\n+        if let Some(mut out) = panic::SgxPanicOutput::new() {\n+            let _ = write!(out, \"Exited with status code {}\", code);\n+        }\n+    }\n+    usercalls::exit(code != 0);\n+}"}, {"sha": "dd9159b9fe23fc87057da63d55fb9a9ea1d42628", "filename": "src/libstd/sys/sgx/abi/panic.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::{self, Write};\n+use slice::from_raw_parts_mut;\n+\n+extern \"C\" {\n+    fn take_debug_panic_buf_ptr() -> *mut u8;\n+    static DEBUG: u8;\n+}\n+\n+pub(crate) struct SgxPanicOutput(Option<&'static mut [u8]>);\n+\n+impl SgxPanicOutput {\n+    pub(crate) fn new() -> Option<Self> {\n+        if unsafe { DEBUG == 0 } {\n+            None\n+        } else {\n+            Some(SgxPanicOutput(None))\n+        }\n+    }\n+\n+    fn init(&mut self) -> &mut &'static mut [u8] {\n+        self.0.get_or_insert_with(|| unsafe {\n+            let ptr = take_debug_panic_buf_ptr();\n+            if ptr.is_null() {\n+                &mut []\n+            } else {\n+                from_raw_parts_mut(ptr, 1024)\n+            }\n+        })\n+    }\n+}\n+\n+impl Write for SgxPanicOutput {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.init().write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.init().flush()\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn panic_msg(msg: &str) -> ! {\n+    let _ = SgxPanicOutput::new().map(|mut out| out.write(msg.as_bytes()));\n+    unsafe { panic_exit(); }\n+}\n+\n+extern \"C\" { pub fn panic_exit() -> !; }"}, {"sha": "2d5e14d6ad1fc475884a3a89fc986467bcdd74ce", "filename": "src/libstd/sys/sgx/abi/reloc.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use slice::from_raw_parts;\n+use super::mem;\n+\n+const R_X86_64_RELATIVE: u32 = 8;\n+\n+#[repr(packed)]\n+struct Rela<T> {\n+    offset: T,\n+    info: T,\n+    addend: T,\n+}\n+\n+pub fn relocate_elf_rela() {\n+    extern {\n+        static RELA: u64;\n+        static RELACOUNT: usize;\n+    }\n+\n+    if unsafe { RELACOUNT } == 0 { return }  // unsafe ok: link-time constant\n+\n+    let relas = unsafe {\n+        from_raw_parts::<Rela<u64>>(mem::rel_ptr(RELA), RELACOUNT)  // unsafe ok: link-time constant\n+    };\n+    for rela in relas {\n+        if rela.info != (/*0 << 32 |*/ R_X86_64_RELATIVE as u64) {\n+            panic!(\"Invalid relocation\");\n+        }\n+        unsafe { *mem::rel_ptr_mut::<*const ()>(rela.offset) = mem::rel_ptr(rela.addend) };\n+    }\n+}"}, {"sha": "4640b812fea84a17a812c04a27cceba93ddaa508", "filename": "src/libstd/sys/sgx/abi/thread.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fortanix_sgx_abi::Tcs;\n+\n+/// Get the ID for the current thread. The ID is guaranteed to be unique among\n+/// all currently running threads in the enclave, and it is guaranteed to be\n+/// constant for the lifetime of the thread. More specifically for SGX, there\n+/// is a one-to-one correspondence of the ID to the address of the TCS.\n+pub fn current() -> Tcs {\n+    extern \"C\" { fn get_tcs_addr() -> Tcs; }\n+    unsafe { get_tcs_addr() }\n+}"}, {"sha": "ab7822182a579f905b1fdd66f82dc53c59ddc4b2", "filename": "src/libstd/sys/sgx/abi/tls.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,246 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use ptr;\n+use mem;\n+use cell::Cell;\n+use num::NonZeroUsize;\n+use self::sync_bitset::*;\n+\n+#[cfg(target_pointer_width=\"64\")]\n+const USIZE_BITS: usize = 64;\n+const TLS_KEYS: usize = 128; // Same as POSIX minimum\n+const TLS_KEYS_BITSET_SIZE: usize = (TLS_KEYS + (USIZE_BITS - 1)) / USIZE_BITS;\n+\n+static TLS_KEY_IN_USE: SyncBitset = SYNC_BITSET_INIT;\n+macro_rules! dup {\n+    ((* $($exp:tt)*) $($val:tt)*) => (dup!( ($($exp)*) $($val)* $($val)* ));\n+    (() $($val:tt)*) => ([$($val),*])\n+}\n+static TLS_DESTRUCTOR: [AtomicUsize; TLS_KEYS] = dup!((* * * * * * *) ATOMIC_USIZE_INIT);\n+\n+extern \"C\" {\n+    fn get_tls_ptr() -> *const u8;\n+    fn set_tls_ptr(tls: *const u8);\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct Key(NonZeroUsize);\n+\n+impl Key {\n+    fn to_index(self) -> usize {\n+        self.0.get() - 1\n+    }\n+\n+    fn from_index(index: usize) -> Self {\n+        Key(NonZeroUsize::new(index + 1).unwrap())\n+    }\n+\n+    pub fn as_usize(self) -> usize {\n+        self.0.get()\n+    }\n+\n+    pub fn from_usize(index: usize) -> Self {\n+        Key(NonZeroUsize::new(index).unwrap())\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct Tls {\n+    data: [Cell<*mut u8>; TLS_KEYS]\n+}\n+\n+pub struct ActiveTls<'a> {\n+    tls: &'a Tls\n+}\n+\n+impl<'a> Drop for ActiveTls<'a> {\n+    fn drop(&mut self) {\n+        let value_with_destructor = |key: usize| {\n+            let ptr = TLS_DESTRUCTOR[key].load(Ordering::Relaxed);\n+            unsafe { mem::transmute::<_,Option<unsafe extern fn(*mut u8)>>(ptr) }\n+                .map(|dtor| (&self.tls.data[key], dtor))\n+        };\n+\n+        let mut any_non_null_dtor = true;\n+        while any_non_null_dtor {\n+            any_non_null_dtor = false;\n+            for (value, dtor) in TLS_KEY_IN_USE.iter().filter_map(&value_with_destructor) {\n+                let value = value.replace(ptr::null_mut());\n+                if value != ptr::null_mut() {\n+                    any_non_null_dtor = true;\n+                    unsafe { dtor(value) }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Tls {\n+    pub fn new() -> Tls {\n+        Tls { data: dup!((* * * * * * *) (Cell::new(ptr::null_mut()))) }\n+    }\n+\n+    pub unsafe fn activate(&self) -> ActiveTls {\n+        set_tls_ptr(self as *const Tls as _);\n+        ActiveTls { tls: self }\n+    }\n+\n+    #[allow(unused)]\n+    pub unsafe fn activate_persistent(self: Box<Self>) {\n+        set_tls_ptr((&*self) as *const Tls as _);\n+        mem::forget(self);\n+    }\n+\n+    unsafe fn current<'a>() -> &'a Tls {\n+        &*(get_tls_ptr() as *const Tls)\n+    }\n+\n+    pub fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+        let index = TLS_KEY_IN_USE.set().expect(\"TLS limit exceeded\");\n+        TLS_DESTRUCTOR[index].store(dtor.map_or(0, |f| f as usize), Ordering::Relaxed);\n+        Key::from_index(index)\n+    }\n+\n+    pub fn set(key: Key, value: *mut u8) {\n+        let index = key.to_index();\n+        assert!(TLS_KEY_IN_USE.get(index));\n+        unsafe { Self::current() }.data[index].set(value);\n+    }\n+\n+    pub fn get(key: Key) -> *mut u8 {\n+        let index = key.to_index();\n+        assert!(TLS_KEY_IN_USE.get(index));\n+        unsafe { Self::current() }.data[index].get()\n+    }\n+\n+    pub fn destroy(key: Key) {\n+        TLS_KEY_IN_USE.clear(key.to_index());\n+    }\n+}\n+\n+mod sync_bitset {\n+    use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use iter::{Enumerate, Peekable};\n+    use slice::Iter;\n+    use super::{TLS_KEYS_BITSET_SIZE, USIZE_BITS};\n+\n+    /// A bitset that can be used synchronously.\n+    pub(super) struct SyncBitset([AtomicUsize; TLS_KEYS_BITSET_SIZE]);\n+\n+    pub(super) const SYNC_BITSET_INIT: SyncBitset =\n+        SyncBitset([ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT]);\n+\n+    impl SyncBitset {\n+        pub fn get(&self, index: usize) -> bool {\n+            let (hi, lo) = Self::split(index);\n+            (self.0[hi].load(Ordering::Relaxed) & lo) != 0\n+        }\n+\n+        /// Not atomic.\n+        pub fn iter(&self) -> SyncBitsetIter {\n+            SyncBitsetIter {\n+                iter: self.0.iter().enumerate().peekable(),\n+                elem_idx: 0,\n+            }\n+        }\n+\n+        pub fn clear(&self, index: usize) {\n+            let (hi, lo) = Self::split(index);\n+            self.0[hi].fetch_and(!lo, Ordering::Relaxed);\n+        }\n+\n+        /// Set any unset bit. Not atomic. Returns `None` if all bits were\n+        /// observed to be set.\n+        pub fn set(&self) -> Option<usize> {\n+            'elems: for (idx, elem) in self.0.iter().enumerate() {\n+                let mut current = elem.load(Ordering::Relaxed);\n+                loop {\n+                    if 0 == !current {\n+                        continue 'elems;\n+                    }\n+                    let trailing_ones = (!current).trailing_zeros() as usize;\n+                    match elem.compare_exchange(\n+                        current,\n+                        current | (1 << trailing_ones),\n+                        Ordering::AcqRel,\n+                        Ordering::Relaxed\n+                    ) {\n+                        Ok(_) => return Some(idx * USIZE_BITS + trailing_ones),\n+                        Err(previous) => current = previous,\n+                    }\n+                }\n+            }\n+            None\n+        }\n+\n+        fn split(index: usize) -> (usize, usize) {\n+            (index / USIZE_BITS, 1 << (index % USIZE_BITS))\n+        }\n+    }\n+\n+    pub(super) struct SyncBitsetIter<'a> {\n+        iter: Peekable<Enumerate<Iter<'a, AtomicUsize>>>,\n+        elem_idx: usize,\n+    }\n+\n+    impl<'a> Iterator for SyncBitsetIter<'a> {\n+        type Item = usize;\n+\n+        fn next(&mut self) -> Option<usize> {\n+            self.iter.peek().cloned().and_then(|(idx, elem)| {\n+                let elem = elem.load(Ordering::Relaxed);\n+                let low_mask = (1 << self.elem_idx) - 1;\n+                let next = elem & !low_mask;\n+                let next_idx = next.trailing_zeros() as usize;\n+                self.elem_idx = next_idx + 1;\n+                if self.elem_idx >= 64 {\n+                    self.elem_idx = 0;\n+                    self.iter.next();\n+                }\n+                match next_idx {\n+                    64 => self.next(),\n+                    _ => Some(idx * USIZE_BITS + next_idx),\n+                }\n+            })\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use super::*;\n+\n+        fn test_data(bitset: [usize; 2], bit_indices: &[usize]) {\n+            let set = SyncBitset([AtomicUsize::new(bitset[0]), AtomicUsize::new(bitset[1])]);\n+            assert_eq!(set.iter().collect::<Vec<_>>(), bit_indices);\n+            for &i in bit_indices {\n+                assert!(set.get(i));\n+            }\n+        }\n+\n+        #[test]\n+        fn iter() {\n+            test_data([0b0110_1001, 0], &[0, 3, 5, 6]);\n+            test_data([0x8000_0000_0000_0000, 0x8000_0000_0000_0001], &[63, 64, 127]);\n+            test_data([0, 0], &[]);\n+        }\n+\n+        #[test]\n+        fn set_get_clear() {\n+            let set = SYNC_BITSET_INIT;\n+            let key = set.set().unwrap();\n+            assert!(set.get(key));\n+            set.clear(key);\n+            assert!(!set.get(key));\n+        }\n+    }\n+}"}, {"sha": "64968a9970c487d0dc143b97fba1b9516bfc7ef6", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,404 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+use ptr;\n+use mem;\n+use cell::UnsafeCell;\n+use slice;\n+use ops::{Deref, DerefMut, Index, IndexMut, CoerceUnsized};\n+use slice::SliceIndex;\n+\n+use fortanix_sgx_abi::*;\n+use super::super::mem::is_user_range;\n+\n+/// A type that can be safely read from or written to userspace.\n+///\n+/// Non-exhaustive list of specific requirements for reading and writing:\n+/// * **Type is `Copy`** (and therefore also not `Drop`). Copies will be\n+///   created when copying from/to userspace. Destructors will not be called.\n+/// * **No references or Rust-style owned pointers** (`Vec`, `Arc`, etc.). When\n+///   reading from userspace, references into enclave memory must not be\n+///   created. Also, only enclave memory is considered managed by the Rust\n+///   compiler's static analysis. When reading from userspace, there can be no\n+///   guarantee that the value correctly adheres to the expectations of the\n+///   type. When writing to userspace, memory addresses of data in enclave\n+///   memory must not be leaked for confidentiality reasons. `User` and\n+///   `UserRef` are also not allowed for the same reasons.\n+/// * **No fat pointers.** When reading from userspace, the size or vtable\n+///   pointer could be automatically interpreted and used by the code. When\n+///   writing to userspace, memory addresses of data in enclave memory (such\n+///   as vtable pointers) must not be leaked for confidentiality reasons.\n+///\n+/// Non-exhaustive list of specific requirements for reading from userspace:\n+/// * Any bit pattern is valid for this type (no `enum`s). There can be no\n+///   guarantee that the value correctly adheres to the expectations of the\n+///   type, so any value must be valid for this type.\n+///\n+/// Non-exhaustive list of specific requirements for writing to userspace:\n+/// * No pointers to enclave memory. Memory addresses of data in enclave memory\n+///   must not be leaked for confidentiality reasons.\n+/// * No internal padding. Padding might contain previously-initialized secret\n+///   data stored at that memory location and must not be leaked for\n+///   confidentiality reasons.\n+pub unsafe trait UserSafeSized: Copy + Sized {}\n+\n+unsafe impl UserSafeSized for u8 {}\n+unsafe impl<T> UserSafeSized for FifoDescriptor<T> {}\n+unsafe impl UserSafeSized for ByteBuffer {}\n+unsafe impl UserSafeSized for Usercall {}\n+unsafe impl UserSafeSized for Return {}\n+unsafe impl<T: UserSafeSized> UserSafeSized for [T; 2] {}\n+\n+/// A type that can be represented in memory as one or more `UserSafeSized`s.\n+pub unsafe trait UserSafe {\n+    unsafe fn align_of() -> usize;\n+\n+    /// NB. This takes a size, not a length!\n+    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self;\n+\n+    /// NB. This takes a size, not a length!\n+    unsafe fn from_raw_sized(ptr: *const u8, size: usize) -> *const Self {\n+        let ret = Self::from_raw_sized_unchecked(ptr, size);\n+        Self::check_ptr(ret);\n+        ret\n+    }\n+\n+    unsafe fn check_ptr(ptr: *const Self) {\n+        let is_aligned = |p| -> bool {\n+            0 == (p as usize) & (Self::align_of() - 1)\n+        };\n+\n+        assert!(is_aligned(ptr as *const u8));\n+        assert!(is_user_range(ptr as _, mem::size_of_val(&*ptr)));\n+        assert!(!ptr.is_null());\n+    }\n+}\n+\n+unsafe impl<T: UserSafeSized> UserSafe for T {\n+    unsafe fn align_of() -> usize {\n+        mem::align_of::<T>()\n+    }\n+\n+    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self {\n+        assert_eq!(size, mem::size_of::<T>());\n+        ptr as _\n+    }\n+}\n+\n+unsafe impl<T: UserSafeSized> UserSafe for [T] {\n+    unsafe fn align_of() -> usize {\n+        mem::align_of::<T>()\n+    }\n+\n+    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self {\n+        let elem_size = mem::size_of::<T>();\n+        assert_eq!(size % elem_size, 0);\n+        let len = size / elem_size;\n+        slice::from_raw_parts(ptr as _, len)\n+    }\n+}\n+\n+/// A reference to some type in userspace memory. `&UserRef<T>` is equivalent\n+/// to `&T` in enclave memory. Access to the memory is only allowed by copying\n+/// to avoid TOCTTOU issues. After copying, code should make sure to completely\n+/// check the value before use.\n+pub struct UserRef<T: ?Sized>(UnsafeCell<T>);\n+/// An owned type in userspace memory. `User<T>` is equivalent to `Box<T>` in\n+/// enclave memory. Access to the memory is only allowed by copying to avoid\n+/// TOCTTOU issues. The user memory will be freed when the value is dropped.\n+/// After copying, code should make sure to completely check the value before\n+/// use.\n+pub struct User<T: UserSafe + ?Sized>(*mut UserRef<T>);\n+\n+impl<T: ?Sized> User<T> where T: UserSafe {\n+    // This function returns memory that is practically uninitialized, but is\n+    // not considered \"unspecified\" or \"undefined\" for purposes of an\n+    // optimizing compiler. This is achieved by returning a pointer from\n+    // from outside as obtained by `super::alloc`.\n+    fn new_uninit_bytes(size: usize) -> Self {\n+        unsafe {\n+            let ptr = super::alloc(size, T::align_of()).expect(\"User memory allocation failed\");\n+            User(T::from_raw_sized(ptr as _, size) as _)\n+        }\n+    }\n+\n+    pub fn new_from_enclave(val: &T) -> Self {\n+        unsafe {\n+            let ret = Self::new_uninit_bytes(mem::size_of_val(val));\n+            ptr::copy(\n+                val as *const T as *const u8,\n+                ret.0 as *mut T as *mut u8,\n+                mem::size_of_val(val)\n+            );\n+            ret\n+        }\n+    }\n+\n+    /// Create an owned `User<T>` from a raw pointer. The pointer should be\n+    /// freeable with the `free` usercall and the alignment of `T`.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n+        T::check_ptr(ptr);\n+        User(ptr as _)\n+    }\n+\n+    /// Convert this value into a raw pointer. The value will no longer be\n+    /// automatically freed.\n+    pub fn into_raw(self) -> *mut T {\n+        let ret = self.0;\n+        mem::forget(self);\n+        ret as _\n+    }\n+}\n+\n+impl<T> User<T> where T: UserSafe {\n+    pub fn uninitialized() -> Self {\n+        Self::new_uninit_bytes(mem::size_of::<T>())\n+    }\n+}\n+\n+impl<T> User<[T]> where [T]: UserSafe {\n+    pub fn uninitialized(n: usize) -> Self {\n+        Self::new_uninit_bytes(n * mem::size_of::<T>())\n+    }\n+\n+    /// Create an owned `User<[T]>` from a raw thin pointer and a slice length.\n+    /// The pointer should be freeable with the `free` usercall and the\n+    /// alignment of `T`.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self {\n+        User(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as _)\n+    }\n+}\n+\n+impl<T: ?Sized> UserRef<T> where T: UserSafe {\n+    /// Create a `&UserRef<[T]>` from a raw pointer.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_ptr<'a>(ptr: *const T) -> &'a Self {\n+        T::check_ptr(ptr);\n+        &*(ptr as *const Self)\n+    }\n+\n+    /// Create a `&mut UserRef<[T]>` from a raw pointer.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_mut_ptr<'a>(ptr: *mut T) -> &'a mut Self {\n+        T::check_ptr(ptr);\n+        &mut*(ptr as *mut Self)\n+    }\n+\n+    /// # Panics\n+    /// This function panics if the destination doesn't have the same size as\n+    /// the source. This can happen for dynamically-sized types such as slices.\n+    pub fn copy_from_enclave(&mut self, val: &T) {\n+        unsafe {\n+            assert_eq!(mem::size_of_val(val), mem::size_of_val( &*self.0.get() ));\n+            ptr::copy(\n+                val as *const T as *const u8,\n+                self.0.get() as *mut T as *mut u8,\n+                mem::size_of_val(val)\n+            );\n+        }\n+    }\n+\n+    /// # Panics\n+    /// This function panics if the destination doesn't have the same size as\n+    /// the source. This can happen for dynamically-sized types such as slices.\n+    pub fn copy_to_enclave(&self, dest: &mut T) {\n+        unsafe {\n+            assert_eq!(mem::size_of_val(dest), mem::size_of_val( &*self.0.get() ));\n+            ptr::copy(\n+                self.0.get() as *const T as *const u8,\n+                dest as *mut T as *mut u8,\n+                mem::size_of_val(dest)\n+            );\n+        }\n+    }\n+\n+    pub fn as_raw_ptr(&self) -> *const T {\n+        self as *const _ as _\n+    }\n+\n+    pub fn as_raw_mut_ptr(&mut self) -> *mut T {\n+        self as *mut _ as _\n+    }\n+}\n+\n+impl<T> UserRef<T> where T: UserSafe {\n+    pub fn to_enclave(&self) -> T {\n+        unsafe { ptr::read(self.0.get()) }\n+    }\n+}\n+\n+impl<T> UserRef<[T]> where [T]: UserSafe {\n+    /// Create a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_raw_parts<'a>(ptr: *const T, len: usize) -> &'a Self {\n+        &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as *const Self)\n+    }\n+\n+    /// Create a `&mut UserRef<[T]>` from a raw thin pointer and a slice length.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n+        &mut*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as *mut Self)\n+    }\n+\n+    pub fn as_ptr(&self) -> *const T {\n+        self.0.get() as _\n+    }\n+\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        self.0.get() as _\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        unsafe { (*self.0.get()).len() }\n+    }\n+\n+    pub fn copy_to_enclave_vec(&self, dest: &mut Vec<T>) {\n+        unsafe {\n+            if let Some(missing) = self.len().checked_sub(dest.capacity()) {\n+                dest.reserve(missing)\n+            }\n+            dest.set_len(self.len());\n+            self.copy_to_enclave(&mut dest[..]);\n+        }\n+    }\n+\n+    pub fn to_enclave(&self) -> Vec<T> {\n+        let mut ret = Vec::with_capacity(self.len());\n+        self.copy_to_enclave_vec(&mut ret);\n+        ret\n+    }\n+\n+    pub fn iter(&self) -> Iter<T>\n+        where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n+    {\n+        unsafe {\n+            Iter((&*self.as_raw_ptr()).iter())\n+        }\n+    }\n+\n+    pub fn iter_mut(&mut self) -> IterMut<T>\n+        where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n+    {\n+        unsafe {\n+            IterMut((&mut*self.as_raw_mut_ptr()).iter_mut())\n+        }\n+    }\n+}\n+\n+pub struct Iter<'a, T: 'a + UserSafe>(slice::Iter<'a, T>);\n+\n+impl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n+    type Item = &'a UserRef<T>;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        unsafe {\n+            self.0.next().map(|e| UserRef::from_ptr(e))\n+        }\n+    }\n+}\n+\n+pub struct IterMut<'a, T: 'a + UserSafe>(slice::IterMut<'a, T>);\n+\n+impl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut UserRef<T>;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        unsafe {\n+            self.0.next().map(|e| UserRef::from_mut_ptr(e))\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized> Deref for User<T> where T: UserSafe {\n+    type Target = UserRef<T>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        unsafe { &*self.0 }\n+    }\n+}\n+\n+impl<T: ?Sized> DerefMut for User<T> where T: UserSafe {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        unsafe { &mut*self.0 }\n+    }\n+}\n+\n+impl<T: ?Sized> Drop for User<T> where T: UserSafe {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let ptr = (*self.0).0.get();\n+            super::free(ptr as _, mem::size_of_val(&mut*ptr), T::align_of());\n+        }\n+    }\n+}\n+\n+impl<T: CoerceUnsized<U>, U> CoerceUnsized<UserRef<U>> for UserRef<T> {}\n+\n+impl<T, I: SliceIndex<[T]>> Index<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n+    type Output = UserRef<I::Output>;\n+\n+    #[inline]\n+    fn index(&self, index: I) -> &UserRef<I::Output> {\n+        unsafe {\n+            UserRef::from_ptr(index.index(&*self.as_raw_ptr()))\n+        }\n+    }\n+}\n+\n+impl<T, I: SliceIndex<[T]>> IndexMut<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n+    #[inline]\n+    fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n+        unsafe {\n+            UserRef::from_mut_ptr(index.index_mut(&mut*self.as_raw_mut_ptr()))\n+        }\n+    }\n+}"}, {"sha": "2bc32c9fefbb73a933bbaf180be5be0f4d377883", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,197 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use fortanix_sgx_abi::*;\n+\n+use io::{Error as IoError, Result as IoResult};\n+use time::Duration;\n+\n+pub mod alloc;\n+#[macro_use]\n+mod raw;\n+\n+pub(crate) fn copy_user_buffer(buf: &alloc::UserRef<ByteBuffer>) -> Vec<u8> {\n+    unsafe {\n+        let buf = buf.to_enclave();\n+        alloc::User::from_raw_parts(buf.data as _, buf.len).to_enclave()\n+    }\n+}\n+\n+pub fn read(fd: Fd, buf: &mut [u8]) -> IoResult<usize> {\n+    unsafe {\n+        let mut userbuf = alloc::User::<[u8]>::uninitialized(buf.len());\n+        let len = raw::read(fd, userbuf.as_mut_ptr(), userbuf.len()).from_sgx_result()?;\n+        userbuf[..len].copy_to_enclave(&mut buf[..len]);\n+        Ok(len)\n+    }\n+}\n+\n+pub fn read_alloc(fd: Fd) -> IoResult<Vec<u8>> {\n+    unsafe {\n+        let mut userbuf = alloc::User::<ByteBuffer>::uninitialized();\n+        raw::read_alloc(fd, userbuf.as_raw_mut_ptr()).from_sgx_result()?;\n+        Ok(copy_user_buffer(&userbuf))\n+    }\n+}\n+\n+pub fn write(fd: Fd, buf: &[u8]) -> IoResult<usize> {\n+    unsafe {\n+        let userbuf = alloc::User::new_from_enclave(buf);\n+        raw::write(fd, userbuf.as_ptr(), userbuf.len()).from_sgx_result()\n+    }\n+}\n+\n+pub fn flush(fd: Fd) -> IoResult<()> {\n+    unsafe { raw::flush(fd).from_sgx_result() }\n+}\n+\n+pub fn close(fd: Fd) {\n+    unsafe { raw::close(fd) }\n+}\n+\n+fn string_from_bytebuffer(buf: &alloc::UserRef<ByteBuffer>, usercall: &str, arg: &str) -> String {\n+    String::from_utf8(copy_user_buffer(buf))\n+        .unwrap_or_else(|_| panic!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n+}\n+\n+pub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n+    unsafe {\n+        let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n+        let mut local = alloc::User::<ByteBuffer>::uninitialized();\n+        let fd = raw::bind_stream(\n+            addr_user.as_ptr(),\n+            addr_user.len(),\n+            local.as_raw_mut_ptr()\n+        ).from_sgx_result()?;\n+        let local = string_from_bytebuffer(&local, \"bind_stream\", \"local_addr\");\n+        Ok((fd, local))\n+    }\n+}\n+\n+pub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n+    unsafe {\n+        let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n+        let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n+                                                               // without forcing coercion?\n+        let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n+        let fd = raw::accept_stream(\n+            fd,\n+            local.as_raw_mut_ptr(),\n+            peer.as_raw_mut_ptr()\n+        ).from_sgx_result()?;\n+        let local = string_from_bytebuffer(&local, \"accept_stream\", \"local_addr\");\n+        let peer = string_from_bytebuffer(&peer, \"accept_stream\", \"peer_addr\");\n+        Ok((fd, local, peer))\n+    }\n+}\n+\n+pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n+    unsafe {\n+        let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n+        let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n+        let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n+                                                               // without forcing coercion?\n+        let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n+        let fd = raw::connect_stream(\n+            addr_user.as_ptr(),\n+            addr_user.len(),\n+            local.as_raw_mut_ptr(),\n+            peer.as_raw_mut_ptr()\n+        ).from_sgx_result()?;\n+        let local = string_from_bytebuffer(&local, \"connect_stream\", \"local_addr\");\n+        let peer = string_from_bytebuffer(&peer, \"connect_stream\", \"peer_addr\");\n+        Ok((fd, local, peer))\n+    }\n+}\n+\n+pub fn launch_thread() -> IoResult<()> {\n+    unsafe { raw::launch_thread().from_sgx_result() }\n+}\n+\n+pub fn exit(panic: bool) -> ! {\n+    unsafe { raw::exit(panic) }\n+}\n+\n+pub fn wait(event_mask: u64, timeout: u64) -> IoResult<u64> {\n+    unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n+}\n+\n+pub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {\n+    unsafe { raw::send(event_set, tcs).from_sgx_result() }\n+}\n+\n+pub fn insecure_time() -> Duration {\n+    let t = unsafe { raw::insecure_time() };\n+    Duration::new(t / 1_000_000_000, (t % 1_000_000_000) as _)\n+}\n+\n+pub fn alloc(size: usize, alignment: usize) -> IoResult<*mut u8> {\n+    unsafe { raw::alloc(size, alignment).from_sgx_result() }\n+}\n+\n+pub use self::raw::free;\n+\n+fn check_os_error(err: Result) -> i32 {\n+    // FIXME: not sure how to make sure all variants of Error are covered\n+    if err == Error::NotFound as _ ||\n+       err == Error::PermissionDenied as _ ||\n+       err == Error::ConnectionRefused as _ ||\n+       err == Error::ConnectionReset as _ ||\n+       err == Error::ConnectionAborted as _ ||\n+       err == Error::NotConnected as _ ||\n+       err == Error::AddrInUse as _ ||\n+       err == Error::AddrNotAvailable as _ ||\n+       err == Error::BrokenPipe as _ ||\n+       err == Error::AlreadyExists as _ ||\n+       err == Error::WouldBlock as _ ||\n+       err == Error::InvalidInput as _ ||\n+       err == Error::InvalidData as _ ||\n+       err == Error::TimedOut as _ ||\n+       err == Error::WriteZero as _ ||\n+       err == Error::Interrupted as _ ||\n+       err == Error::Other as _ ||\n+       err == Error::UnexpectedEof as _ ||\n+       ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&err)\n+    {\n+        err\n+    } else {\n+        panic!(\"Usercall: returned invalid error value {}\", err)\n+    }\n+}\n+\n+trait FromSgxResult {\n+    type Return;\n+\n+    fn from_sgx_result(self) -> IoResult<Self::Return>;\n+}\n+\n+impl<T> FromSgxResult for (Result, T) {\n+    type Return = T;\n+\n+    fn from_sgx_result(self) -> IoResult<Self::Return> {\n+        if self.0 == RESULT_SUCCESS {\n+            Ok(self.1)\n+        } else {\n+            Err(IoError::from_raw_os_error(check_os_error(self.0)))\n+        }\n+    }\n+}\n+\n+impl FromSgxResult for Result {\n+    type Return = ();\n+\n+    fn from_sgx_result(self) -> IoResult<Self::Return> {\n+        if self == RESULT_SUCCESS {\n+            Ok(())\n+        } else {\n+            Err(IoError::from_raw_os_error(check_os_error(self)))\n+        }\n+    }\n+}"}, {"sha": "a28d41c1b7458e83d6a3ce48813af91101eaf974", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+use fortanix_sgx_abi::*;\n+\n+use ptr::NonNull;\n+\n+#[repr(C)]\n+struct UsercallReturn(u64, u64);\n+\n+extern \"C\" {\n+    fn usercall(nr: u64, p1: u64, p2: u64, _ignore: u64, p3: u64, p4: u64) -> UsercallReturn;\n+}\n+\n+unsafe fn do_usercall(nr: u64, p1: u64, p2: u64, p3: u64, p4: u64) -> (u64, u64) {\n+    if nr==0 { panic!(\"Invalid usercall number {}\",nr) }\n+    let UsercallReturn(a, b) = usercall(nr,p1,p2,0,p3,p4);\n+    (a, b)\n+}\n+\n+type Register = u64;\n+\n+trait RegisterArgument {\n+    fn from_register(Register) -> Self;\n+    fn into_register(self) -> Register;\n+}\n+\n+trait ReturnValue {\n+    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self;\n+}\n+\n+macro_rules! define_usercalls {\n+    // Using `$r:tt` because `$r:ty` doesn't match ! in `clobber_diverging`\n+    ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:tt)*; )*) => {\n+        #[repr(C)]\n+        #[allow(non_camel_case_types)]\n+        enum Usercalls {\n+            __enclave_usercalls_invalid,\n+            $($f,)*\n+        }\n+\n+        $(enclave_usercalls_internal_define_usercalls!(def fn $f($($n: $t),*) $(-> $r)*);)*\n+    };\n+}\n+\n+macro_rules! define_usercalls_asm {\n+    ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:ty)*; )*) => {\n+        macro_rules! usercalls_asm {\n+            () => {\n+                concat!(\n+                    \".equ usercall_nr_LAST, 0\\n\",\n+                    $(\n+                    \".equ usercall_nr_\", stringify!($f), \", usercall_nr_LAST+1\\n\",\n+                    \".equ usercall_nr_LAST, usercall_nr_\", stringify!($f), \"\\n\"\n+                    ),*\n+                )\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! define_ra {\n+    (< $i:ident > $t:ty) => {\n+        impl<$i> RegisterArgument for $t {\n+            fn from_register(a: Register) -> Self {\n+                a as _\n+            }\n+            fn into_register(self) -> Register {\n+                self as _\n+            }\n+        }\n+    };\n+    ($i:ty as $t:ty) => {\n+        impl RegisterArgument for $t {\n+            fn from_register(a: Register) -> Self {\n+                a as $i as _\n+            }\n+            fn into_register(self) -> Register {\n+                self as $i as _\n+            }\n+        }\n+    };\n+    ($t:ty) => {\n+        impl RegisterArgument for $t {\n+            fn from_register(a: Register) -> Self {\n+                a as _\n+            }\n+            fn into_register(self) -> Register {\n+                self as _\n+            }\n+        }\n+    };\n+}\n+\n+define_ra!(Register);\n+define_ra!(i64);\n+define_ra!(u32);\n+define_ra!(u32 as i32);\n+define_ra!(u16);\n+define_ra!(u16 as i16);\n+define_ra!(u8);\n+define_ra!(u8 as i8);\n+define_ra!(usize);\n+define_ra!(usize as isize);\n+define_ra!(<T> *const T);\n+define_ra!(<T> *mut T);\n+\n+impl RegisterArgument for bool {\n+    fn from_register(a: Register) -> bool {\n+        if a != 0 {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+    fn into_register(self) -> Register {\n+        self as _\n+    }\n+}\n+\n+impl<T: RegisterArgument> RegisterArgument for Option<NonNull<T>> {\n+    fn from_register(a: Register) -> Option<NonNull<T>> {\n+        NonNull::new(a as _)\n+    }\n+    fn into_register(self) -> Register {\n+        self.map_or(0 as _, NonNull::as_ptr) as _\n+    }\n+}\n+\n+impl ReturnValue for ! {\n+    fn from_registers(call: &'static str, _regs: (Register, Register)) -> Self {\n+        panic!(\"Usercall {}: did not expect to be re-entered\", call);\n+    }\n+}\n+\n+impl ReturnValue for () {\n+    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self {\n+        assert_eq!(regs.0, 0, \"Usercall {}: expected {} return value to be 0\", call, \"1st\");\n+        assert_eq!(regs.1, 0, \"Usercall {}: expected {} return value to be 0\", call, \"2nd\");\n+        ()\n+    }\n+}\n+\n+impl<T: RegisterArgument> ReturnValue for T {\n+    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self {\n+        assert_eq!(regs.1, 0, \"Usercall {}: expected {} return value to be 0\", call, \"2nd\");\n+        T::from_register(regs.0)\n+    }\n+}\n+\n+impl<T: RegisterArgument, U: RegisterArgument> ReturnValue for (T, U) {\n+    fn from_registers(_call: &'static str, regs: (Register, Register)) -> Self {\n+        (\n+            T::from_register(regs.0),\n+            U::from_register(regs.1)\n+        )\n+    }\n+}\n+\n+macro_rules! enclave_usercalls_internal_define_usercalls {\n+    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty,\n+                     $n3:ident: $t3:ty, $n4:ident: $t4:ty) -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                RegisterArgument::into_register($n1),\n+                RegisterArgument::into_register($n2),\n+                RegisterArgument::into_register($n3),\n+                RegisterArgument::into_register($n4),\n+            ))\n+        }\n+    );\n+    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty, $n3:ident: $t3:ty) -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                RegisterArgument::into_register($n1),\n+                RegisterArgument::into_register($n2),\n+                RegisterArgument::into_register($n3),\n+                0\n+            ))\n+        }\n+    );\n+    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty) -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                RegisterArgument::into_register($n1),\n+                RegisterArgument::into_register($n2),\n+                0,0\n+            ))\n+        }\n+    );\n+    (def fn $f:ident($n1:ident: $t1:ty) -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f($n1: $t1) -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                RegisterArgument::into_register($n1),\n+                0,0,0\n+            ))\n+        }\n+    );\n+    (def fn $f:ident() -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f() -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                0,0,0,0\n+            ))\n+        }\n+    );\n+    (def fn $f:ident($($n:ident: $t:ty),*)) => (\n+        enclave_usercalls_internal_define_usercalls!(def fn $f($($n: $t),*) -> ());\n+    );\n+}\n+\n+invoke_with_usercalls!(define_usercalls);\n+invoke_with_usercalls!(define_usercalls_asm);"}, {"sha": "83c20ace89bcef1259b208067bae296196aac974", "filename": "src/libstd/sys/sgx/alloc.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate dlmalloc;\n+\n+use alloc::{GlobalAlloc, Layout, System};\n+\n+use super::waitqueue::SpinMutex;\n+\n+// Using a SpinMutex because we never want to exit the enclave waiting for the\n+// allocator.\n+static DLMALLOC: SpinMutex<dlmalloc::Dlmalloc> = SpinMutex::new(dlmalloc::DLMALLOC_INIT);\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        DLMALLOC.lock().malloc(layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        DLMALLOC.lock().calloc(layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        DLMALLOC.lock().free(ptr, layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        DLMALLOC.lock().realloc(ptr, layout.size(), layout.align(), new_size)\n+    }\n+}"}, {"sha": "8fb35d7ef98bd30974b43341488ecdcf4c72853a", "filename": "src/libstd/sys/sgx/args.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+use super::abi::usercalls::{copy_user_buffer, alloc, ByteBuffer};\n+use sync::atomic::{AtomicUsize, Ordering};\n+use sys::os_str::Buf;\n+use sys_common::FromInner;\n+use slice;\n+\n+static ARGS: AtomicUsize = AtomicUsize::new(0);\n+type ArgsStore = Vec<OsString>;\n+\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+    if argc != 0 {\n+        let args = alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _);\n+        let args = args.iter()\n+            .map( |a| OsString::from_inner(Buf { inner: copy_user_buffer(a) }) )\n+            .collect::<ArgsStore>();\n+        ARGS.store(Box::into_raw(Box::new(args)) as _, Ordering::Relaxed);\n+    }\n+}\n+\n+pub unsafe fn cleanup() {\n+    let args = ARGS.swap(0, Ordering::Relaxed);\n+    if args != 0 {\n+        drop(Box::<ArgsStore>::from_raw(args as _))\n+    }\n+}\n+\n+pub fn args() -> Args {\n+    let args = unsafe { (ARGS.load(Ordering::Relaxed) as *const ArgsStore).as_ref() };\n+    if let Some(args) = args {\n+        Args(args.iter())\n+    } else {\n+        Args([].iter())\n+    }\n+}\n+\n+pub struct Args(slice::Iter<'static, OsString>);\n+\n+impl Args {\n+    pub fn inner_debug(&self) -> &[OsString] {\n+        self.0.as_slice()\n+    }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        self.0.next().cloned()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.0.next_back().cloned()\n+    }\n+}"}, {"sha": "ca4a7c9561cf79d1962f031544f6bc6c88909bb4", "filename": "src/libstd/sys/sgx/backtrace.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fbacktrace.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::unsupported;\n+use sys_common::backtrace::Frame;\n+\n+pub struct BacktraceContext;\n+\n+pub fn unwind_backtrace(_frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    unsupported()\n+}\n+\n+pub fn resolve_symname<F>(_frame: Frame,\n+                          _callback: F,\n+                          _: &BacktraceContext) -> io::Result<()>\n+    where F: FnOnce(Option<&str>) -> io::Result<()>\n+{\n+    unsupported()\n+}\n+\n+pub fn foreach_symbol_fileline<F>(_: Frame,\n+                                  _: F,\n+                                  _: &BacktraceContext) -> io::Result<bool>\n+    where F: FnMut(&[u8], u32) -> io::Result<()>\n+{\n+    unsupported()\n+}"}, {"sha": "0c1300f61f86ca4384e5ce18c876181ad73f3a1e", "filename": "src/libstd/sys/sgx/cmath.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(not(test))]\n+\n+// These symbols are all defined in `compiler-builtins`\n+extern {\n+    pub fn acos(n: f64) -> f64;\n+    pub fn acosf(n: f32) -> f32;\n+    pub fn asin(n: f64) -> f64;\n+    pub fn asinf(n: f32) -> f32;\n+    pub fn atan(n: f64) -> f64;\n+    pub fn atan2(a: f64, b: f64) -> f64;\n+    pub fn atan2f(a: f32, b: f32) -> f32;\n+    pub fn atanf(n: f32) -> f32;\n+    pub fn cbrt(n: f64) -> f64;\n+    pub fn cbrtf(n: f32) -> f32;\n+    pub fn cosh(n: f64) -> f64;\n+    pub fn coshf(n: f32) -> f32;\n+    pub fn expm1(n: f64) -> f64;\n+    pub fn expm1f(n: f32) -> f32;\n+    pub fn fdim(a: f64, b: f64) -> f64;\n+    pub fn fdimf(a: f32, b: f32) -> f32;\n+    pub fn hypot(x: f64, y: f64) -> f64;\n+    pub fn hypotf(x: f32, y: f32) -> f32;\n+    pub fn log1p(n: f64) -> f64;\n+    pub fn log1pf(n: f32) -> f32;\n+    pub fn sinh(n: f64) -> f64;\n+    pub fn sinhf(n: f32) -> f32;\n+    pub fn tan(n: f64) -> f64;\n+    pub fn tanf(n: f32) -> f32;\n+    pub fn tanh(n: f64) -> f64;\n+    pub fn tanhf(n: f32) -> f32;\n+}"}, {"sha": "d3e8165f3dfe7d818437d810308f2d5d36a6ca1f", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sys::mutex::Mutex;\n+use time::Duration;\n+\n+use super::waitqueue::{WaitVariable, WaitQueue, SpinMutex};\n+\n+pub struct Condvar {\n+    inner: SpinMutex<WaitVariable<()>>,\n+}\n+\n+impl Condvar {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+    pub const fn new() -> Condvar {\n+        Condvar { inner: SpinMutex::new(WaitVariable::new(())) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n+\n+    #[inline]\n+    pub unsafe fn notify_one(&self) {\n+        let _ = WaitQueue::notify_one(self.inner.lock());\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_all(&self) {\n+        let _ = WaitQueue::notify_all(self.inner.lock());\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        let guard = self.inner.lock();\n+        mutex.unlock();\n+        WaitQueue::wait(guard);\n+        mutex.lock()\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        panic!(\"timeout not supported in SGX\");\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {}\n+}"}, {"sha": "146ce02754b10af1263b3236c55fc0dcf662a418", "filename": "src/libstd/sys/sgx/env.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fenv.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod os {\n+    pub const FAMILY: &'static str = \"\";\n+    pub const OS: &'static str = \"\";\n+    pub const DLL_PREFIX: &'static str = \"\";\n+    pub const DLL_SUFFIX: &'static str = \".sgxs\";\n+    pub const DLL_EXTENSION: &'static str = \"sgxs\";\n+    pub const EXE_SUFFIX: &'static str = \".sgxs\";\n+    pub const EXE_EXTENSION: &'static str = \"sgxs\";\n+}"}, {"sha": "31c4199c6cda1138b442517c06fb1d49f35914f7", "filename": "src/libstd/sys/sgx/fd.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fortanix_sgx_abi::Fd;\n+\n+use io;\n+use mem;\n+use sys_common::AsInner;\n+use super::abi::usercalls;\n+\n+#[derive(Debug)]\n+pub struct FileDesc {\n+    fd: Fd,\n+}\n+\n+impl FileDesc {\n+    pub fn new(fd: Fd) -> FileDesc {\n+        FileDesc { fd: fd }\n+    }\n+\n+    pub fn raw(&self) -> Fd { self.fd }\n+\n+    /// Extracts the actual filedescriptor without closing it.\n+    pub fn into_raw(self) -> Fd {\n+        let fd = self.fd;\n+        mem::forget(self);\n+        fd\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        usercalls::read(self.fd, buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        usercalls::write(self.fd, buf)\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        usercalls::flush(self.fd)\n+    }\n+}\n+\n+impl AsInner<Fd> for FileDesc {\n+    fn as_inner(&self) -> &Fd { &self.fd }\n+}\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        usercalls::close(self.fd)\n+    }\n+}"}, {"sha": "1dcea3e8eac97972020dc6d97f1cbce80fb9bf15", "filename": "src/libstd/sys/sgx/fs.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,304 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+use fmt;\n+use hash::{Hash, Hasher};\n+use io::{self, SeekFrom};\n+use path::{Path, PathBuf};\n+use sys::time::SystemTime;\n+use sys::{unsupported, Void};\n+\n+pub struct File(Void);\n+\n+pub struct FileAttr(Void);\n+\n+pub struct ReadDir(Void);\n+\n+pub struct DirEntry(Void);\n+\n+#[derive(Clone, Debug)]\n+pub struct OpenOptions { }\n+\n+pub struct FilePermissions(Void);\n+\n+pub struct FileType(Void);\n+\n+#[derive(Debug)]\n+pub struct DirBuilder { }\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 {\n+        match self.0 {}\n+    }\n+\n+    pub fn perm(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        match self.0 {}\n+    }\n+\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileAttr {\n+    fn clone(&self) -> FileAttr {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_readonly(&mut self, _readonly: bool) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FilePermissions {\n+    fn clone(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+}\n+\n+impl PartialEq for FilePermissions {\n+    fn eq(&self, _other: &FilePermissions) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FilePermissions {\n+}\n+\n+impl fmt::Debug for FilePermissions {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_file(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_symlink(&self) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileType {\n+    fn clone(&self) -> FileType {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for FileType {}\n+\n+impl PartialEq for FileType {\n+    fn eq(&self, _other: &FileType) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FileType {\n+}\n+\n+impl Hash for FileType {\n+    fn hash<H: Hasher>(&self, _h: &mut H) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for FileType {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        match self.0 {}\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions { }\n+    }\n+\n+    pub fn read(&mut self, _read: bool) { }\n+    pub fn write(&mut self, _write: bool) { }\n+    pub fn append(&mut self, _append: bool) { }\n+    pub fn truncate(&mut self, _truncate: bool) { }\n+    pub fn create(&mut self, _create: bool) { }\n+    pub fn create_new(&mut self, _create_new: bool) { }\n+}\n+\n+impl File {\n+    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {\n+        unsupported()\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder { }\n+    }\n+\n+    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n+        unsupported()\n+    }\n+}\n+\n+impl fmt::Debug for File {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n+    unsupported()\n+}\n+\n+pub fn unlink(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    match perm.0 {}\n+}\n+\n+pub fn rmdir(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {\n+    unsupported()\n+}"}, {"sha": "0998bc5db4c3f97b85052116a641e5a273cefbd1", "filename": "src/libstd/sys/sgx/memchr.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmemchr.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "dd6862e908e06950224afca1451053a8da18f113", "filename": "src/libstd/sys/sgx/mod.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! System bindings for the Fortanix SGX platform\n+//!\n+//! This module contains the facade (aka platform-specific) implementations of\n+//! OS level functionality for Fortanix SGX.\n+\n+use io;\n+use os::raw::c_char;\n+use sync::atomic::{AtomicBool, Ordering};\n+\n+pub mod abi;\n+mod waitqueue;\n+\n+pub mod alloc;\n+pub mod args;\n+#[cfg(feature = \"backtrace\")]\n+pub mod backtrace;\n+pub mod cmath;\n+pub mod condvar;\n+pub mod env;\n+pub mod fd;\n+pub mod fs;\n+pub mod memchr;\n+pub mod mutex;\n+pub mod net;\n+pub mod os;\n+pub mod os_str;\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod rwlock;\n+pub mod stack_overflow;\n+pub mod thread;\n+pub mod thread_local;\n+pub mod time;\n+pub mod stdio;\n+\n+#[cfg(not(test))]\n+pub fn init() {\n+}\n+\n+/// This function is used to implement functionality that simply doesn't exist.\n+/// Programs relying on this functionality will need to deal with the error.\n+pub fn unsupported<T>() -> io::Result<T> {\n+    Err(unsupported_err())\n+}\n+\n+pub fn unsupported_err() -> io::Error {\n+    io::Error::new(io::ErrorKind::Other,\n+                   \"operation not supported on SGX yet\")\n+}\n+\n+/// This function is used to implement various functions that doesn't exist,\n+/// but the lack of which might not be reason for error. If no error is\n+/// returned, the program might very well be able to function normally. This is\n+/// what happens when `SGX_INEFFECTIVE_ERROR` is set to `true`. If it is\n+/// `false`, the behavior is the same as `unsupported`.\n+pub fn sgx_ineffective<T>(v: T) -> io::Result<T> {\n+    static SGX_INEFFECTIVE_ERROR: AtomicBool = AtomicBool::new(false);\n+    if SGX_INEFFECTIVE_ERROR.load(Ordering::Relaxed) {\n+        Err(io::Error::new(io::ErrorKind::Other,\n+                       \"operation can't be trusted to have any effect on SGX\"))\n+    } else {\n+        Ok(v)\n+    }\n+}\n+\n+pub fn decode_error_kind(code: i32) -> io::ErrorKind {\n+    use fortanix_sgx_abi::Error;\n+\n+    // FIXME: not sure how to make sure all variants of Error are covered\n+    if code == Error::NotFound as _ {\n+        io::ErrorKind::NotFound\n+    } else if code == Error::PermissionDenied as _ {\n+        io::ErrorKind::PermissionDenied\n+    } else if code == Error::ConnectionRefused as _ {\n+        io::ErrorKind::ConnectionRefused\n+    } else if code == Error::ConnectionReset as _ {\n+        io::ErrorKind::ConnectionReset\n+    } else if code == Error::ConnectionAborted as _ {\n+        io::ErrorKind::ConnectionAborted\n+    } else if code == Error::NotConnected as _ {\n+        io::ErrorKind::NotConnected\n+    } else if code == Error::AddrInUse as _ {\n+        io::ErrorKind::AddrInUse\n+    } else if code == Error::AddrNotAvailable as _ {\n+        io::ErrorKind::AddrNotAvailable\n+    } else if code == Error::BrokenPipe as _ {\n+        io::ErrorKind::BrokenPipe\n+    } else if code == Error::AlreadyExists as _ {\n+        io::ErrorKind::AlreadyExists\n+    } else if code == Error::WouldBlock as _ {\n+        io::ErrorKind::WouldBlock\n+    } else if code == Error::InvalidInput as _ {\n+        io::ErrorKind::InvalidInput\n+    } else if code == Error::InvalidData as _ {\n+        io::ErrorKind::InvalidData\n+    } else if code == Error::TimedOut as _ {\n+        io::ErrorKind::TimedOut\n+    } else if code == Error::WriteZero as _ {\n+        io::ErrorKind::WriteZero\n+    } else if code == Error::Interrupted as _ {\n+        io::ErrorKind::Interrupted\n+    } else if code == Error::Other as _ {\n+        io::ErrorKind::Other\n+    } else if code == Error::UnexpectedEof as _ {\n+        io::ErrorKind::UnexpectedEof\n+    } else {\n+        io::ErrorKind::Other\n+    }\n+}\n+\n+// This enum is used as the storage for a bunch of types which can't actually\n+// exist.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub enum Void {}\n+\n+pub unsafe fn strlen(mut s: *const c_char) -> usize {\n+    let mut n = 0;\n+    while *s != 0 {\n+        n += 1;\n+        s = s.offset(1);\n+    }\n+    return n\n+}\n+\n+pub unsafe fn abort_internal() -> ! {\n+    abi::panic::panic_exit()\n+}\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    fn rdrand64() -> u64 {\n+        unsafe {\n+            let mut ret: u64 = ::mem::uninitialized();\n+            for _ in 0..10 {\n+                if ::arch::x86_64::_rdrand64_step(&mut ret) == 1 {\n+                    return ret;\n+                }\n+            }\n+            panic!(\"Failed to obtain random data\");\n+        }\n+    }\n+    (rdrand64(), rdrand64())\n+}"}, {"sha": "663361162bc6bbe7d07ae91ae884c129bf28bd2e", "filename": "src/libstd/sys/sgx/mutex.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,152 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fortanix_sgx_abi::Tcs;\n+\n+use super::abi::thread;\n+\n+use super::waitqueue::{WaitVariable, WaitQueue, SpinMutex, NotifiedTcs, try_lock_or_false};\n+\n+pub struct Mutex {\n+    inner: SpinMutex<WaitVariable<bool>>,\n+}\n+\n+// Implementation according to \u201cOperating Systems: Three Easy Pieces\u201d, chapter 28\n+impl Mutex {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+    pub const fn new() -> Mutex {\n+        Mutex { inner: SpinMutex::new(WaitVariable::new(false)) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let mut guard = self.inner.lock();\n+        if *guard.lock_var() {\n+            // Another thread has the lock, wait\n+            WaitQueue::wait(guard)\n+            // Another thread has passed the lock to us\n+        } else {\n+            // We are just now obtaining the lock\n+            *guard.lock_var_mut() = true;\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        let guard = self.inner.lock();\n+        if let Err(mut guard) = WaitQueue::notify_one(guard) {\n+            // No other waiters, unlock\n+            *guard.lock_var_mut() = false;\n+        } else {\n+            // There was a thread waiting, just pass the lock\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let mut guard = try_lock_or_false!(self.inner);\n+        if *guard.lock_var() {\n+            // Another thread has the lock\n+            false\n+        } else {\n+            // We are just now obtaining the lock\n+            *guard.lock_var_mut() = true;\n+            true\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {}\n+}\n+\n+struct ReentrantLock {\n+    owner: Option<Tcs>,\n+    count: usize\n+}\n+\n+pub struct ReentrantMutex {\n+    inner: SpinMutex<WaitVariable<ReentrantLock>>,\n+}\n+\n+impl ReentrantMutex {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+    pub const fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex {\n+            inner: SpinMutex::new(WaitVariable::new(ReentrantLock { owner: None, count: 0 }))\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let mut guard = self.inner.lock();\n+        match guard.lock_var().owner {\n+            Some(tcs) if tcs != thread::current() => {\n+                // Another thread has the lock, wait\n+                WaitQueue::wait(guard);\n+                // Another thread has passed the lock to us\n+            },\n+            _ => {\n+                // We are just now obtaining the lock\n+                guard.lock_var_mut().owner = Some(thread::current());\n+                guard.lock_var_mut().count += 1;\n+            },\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        let mut guard = self.inner.lock();\n+        if guard.lock_var().count > 1 {\n+            guard.lock_var_mut().count -= 1;\n+        } else {\n+            match WaitQueue::notify_one(guard) {\n+                Err(mut guard) => {\n+                    // No other waiters, unlock\n+                    guard.lock_var_mut().count = 0;\n+                    guard.lock_var_mut().owner = None;\n+                },\n+                Ok(mut guard) => {\n+                    // There was a thread waiting, just pass the lock\n+                    if let NotifiedTcs::Single(tcs) = guard.notified_tcs() {\n+                        guard.lock_var_mut().owner = Some(tcs)\n+                    } else {\n+                        unreachable!() // called notify_one\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let mut guard = try_lock_or_false!(self.inner);\n+        match guard.lock_var().owner {\n+            Some(tcs) if tcs != thread::current() => {\n+                // Another thread has the lock\n+                false\n+            },\n+            _ => {\n+                // We are just now obtaining the lock\n+                guard.lock_var_mut().owner = Some(thread::current());\n+                guard.lock_var_mut().count += 1;\n+                true\n+            },\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {}\n+}"}, {"sha": "176d230846dc25b0a8d61ba8c9a7162ac99946bf", "filename": "src/libstd/sys/sgx/net.rs", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,415 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+use io;\n+use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n+use time::Duration;\n+use sys::{unsupported, Void, sgx_ineffective};\n+use sys::fd::FileDesc;\n+use convert::TryFrom;\n+use error;\n+use sync::Arc;\n+\n+use super::abi::usercalls;\n+\n+const DEFAULT_FAKE_TTL: u32 = 64;\n+\n+#[derive(Debug, Clone)]\n+struct Socket {\n+    inner: Arc<FileDesc>,\n+    local_addr: String,\n+}\n+\n+impl Socket {\n+    fn new(fd: usercalls::Fd, local_addr: String) -> Socket {\n+        Socket { inner: Arc::new(FileDesc::new(fd)), local_addr }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct TcpStream {\n+    inner: Socket,\n+    peer_addr: String,\n+}\n+\n+fn io_err_to_addr(result: io::Result<&SocketAddr>) -> io::Result<String> {\n+    match result {\n+        Ok(saddr) => Ok(saddr.to_string()),\n+        // need to downcast twice because io::Error::into_inner doesn't return the original\n+        // value if the conversion fails\n+        Err(e) => if e.get_ref().and_then(|e| e.downcast_ref::<NonIpSockAddr>()).is_some() {\n+            Ok(e.into_inner().unwrap().downcast::<NonIpSockAddr>().unwrap().host)\n+        } else {\n+            Err(e)\n+        }\n+    }\n+}\n+\n+fn addr_to_sockaddr(addr: &str) -> io::Result<SocketAddr> {\n+    // unwrap OK: if an iterator is returned, we're guaranteed to get exactly one entry\n+    addr.to_socket_addrs().map(|mut it| it.next().unwrap())\n+}\n+\n+impl TcpStream {\n+    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+        let addr = io_err_to_addr(addr)?;\n+        let (fd, local_addr, peer_addr) = usercalls::connect_stream(&addr)?;\n+        Ok(TcpStream { inner: Socket::new(fd, local_addr), peer_addr })\n+    }\n+\n+    pub fn connect_timeout(addr: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+        Self::connect(Ok(addr)) // FIXME: ignoring timeout\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        sgx_ineffective(None)\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        sgx_ineffective(None)\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        Ok(0)\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.inner.read(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.inner.inner.write(buf)\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        addr_to_sockaddr(&self.peer_addr)\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        addr_to_sockaddr(&self.inner.local_addr)\n+    }\n+\n+    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpStream> {\n+        Ok(self.clone())\n+    }\n+\n+    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        sgx_ineffective(false)\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        sgx_ineffective(DEFAULT_FAKE_TTL)\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        Ok(None)\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct TcpListener {\n+    inner: Socket,\n+}\n+\n+impl TcpListener {\n+    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+        let addr = io_err_to_addr(addr)?;\n+        let (fd, local_addr) = usercalls::bind_stream(&addr)?;\n+        Ok(TcpListener { inner: Socket::new(fd, local_addr) })\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        addr_to_sockaddr(&self.inner.local_addr)\n+    }\n+\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        let (fd, local_addr, peer_addr) = usercalls::accept_stream(self.inner.inner.raw())?;\n+        let ret_peer = addr_to_sockaddr(&peer_addr).unwrap_or_else(|_| ([0; 4], 0).into());\n+        Ok((TcpStream { inner: Socket::new(fd, local_addr), peer_addr }, ret_peer))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpListener> {\n+        Ok(self.clone())\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        sgx_ineffective(DEFAULT_FAKE_TTL)\n+    }\n+\n+    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        sgx_ineffective(false)\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        Ok(None)\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+}\n+\n+pub struct UdpSocket(Void);\n+\n+impl UdpSocket {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for UdpSocket {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct NonIpSockAddr {\n+    host: String\n+}\n+\n+impl error::Error for NonIpSockAddr {\n+    fn description(&self) -> &str {\n+        \"Failed to convert address to SocketAddr\"\n+    }\n+}\n+\n+impl fmt::Display for NonIpSockAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Failed to convert address to SocketAddr: {}\", self.host)\n+    }\n+}\n+\n+pub struct LookupHost(Void);\n+\n+impl LookupHost {\n+    fn new(host: String) -> io::Result<LookupHost> {\n+        Err(io::Error::new(io::ErrorKind::Other, NonIpSockAddr { host }))\n+    }\n+\n+    pub fn port(&self) -> u16 {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for LookupHost {\n+    type Item = SocketAddr;\n+    fn next(&mut self) -> Option<SocketAddr> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(v: &'a str) -> io::Result<LookupHost> {\n+        LookupHost::new(v.to_owned())\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n+        LookupHost::new(format!(\"{}:{}\", host, port))\n+    }\n+}\n+\n+#[allow(bad_style)]\n+pub mod netc {\n+    pub const AF_INET: u8 = 0;\n+    pub const AF_INET6: u8 = 1;\n+    pub type sa_family_t = u8;\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in_addr {\n+        pub s_addr: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in {\n+        pub sin_family: sa_family_t,\n+        pub sin_port: u16,\n+        pub sin_addr: in_addr,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in6_addr {\n+        pub s6_addr: [u8; 16],\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in6 {\n+        pub sin6_family: sa_family_t,\n+        pub sin6_port: u16,\n+        pub sin6_addr: in6_addr,\n+        pub sin6_flowinfo: u32,\n+        pub sin6_scope_id: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr {\n+    }\n+\n+    pub type socklen_t = usize;\n+}"}, {"sha": "79ebafe73f966eb65d7f13d801a3af67fe2e2617", "filename": "src/libstd/sys/sgx/os.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fortanix_sgx_abi::{Error, RESULT_SUCCESS};\n+\n+use error::Error as StdError;\n+use ffi::{OsString, OsStr};\n+use fmt;\n+use io;\n+use path::{self, PathBuf};\n+use str;\n+use sys::{unsupported, Void, sgx_ineffective, decode_error_kind};\n+use collections::HashMap;\n+use vec;\n+use sync::Mutex;\n+use sync::atomic::{AtomicUsize, Ordering};\n+use sync::Once;\n+\n+pub fn errno() -> i32 {\n+    RESULT_SUCCESS\n+}\n+\n+pub fn error_string(errno: i32) -> String {\n+    if errno == RESULT_SUCCESS {\n+        \"operation succesful\".into()\n+    } else if ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&errno) {\n+        format!(\"user-specified error {:08x}\", errno)\n+    } else {\n+        decode_error_kind(errno).as_str().into()\n+    }\n+}\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn chdir(_: &path::Path) -> io::Result<()> {\n+    sgx_ineffective(())\n+}\n+\n+pub struct SplitPaths<'a>(&'a Void);\n+\n+pub fn split_paths(_unparsed: &OsStr) -> SplitPaths {\n+    panic!(\"unsupported\")\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n+        match *self.0 {}\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+{\n+    Err(JoinPathsError)\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"not supported in SGX yet\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str {\n+        \"not supported in SGX yet\"\n+    }\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+static ENV: AtomicUsize = AtomicUsize::new(0);\n+static ENV_INIT: Once = Once::new();\n+type EnvStore = Mutex<HashMap<OsString, OsString>>;\n+\n+fn get_env_store() -> Option<&'static EnvStore> {\n+    unsafe { (ENV.load(Ordering::Relaxed) as *const EnvStore).as_ref() }\n+}\n+\n+fn create_env_store() -> &'static EnvStore {\n+    ENV_INIT.call_once(|| {\n+        ENV.store(Box::into_raw(Box::new(EnvStore::default())) as _, Ordering::Relaxed)\n+    });\n+    unsafe {\n+        &*(ENV.load(Ordering::Relaxed) as *const EnvStore)\n+    }\n+}\n+\n+pub type Env = vec::IntoIter<(OsString, OsString)>;\n+\n+pub fn env() -> Env {\n+    let clone_to_vec = |map: &HashMap<OsString, OsString>| -> Vec<_> {\n+        map.iter().map(|(k, v)| (k.clone(), v.clone()) ).collect()\n+    };\n+\n+    get_env_store()\n+        .map(|env| clone_to_vec(&env.lock().unwrap()) )\n+        .unwrap_or_default()\n+        .into_iter()\n+}\n+\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n+    Ok(get_env_store().and_then(|s| s.lock().unwrap().get(k).cloned() ))\n+}\n+\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    let (k, v) = (k.to_owned(), v.to_owned());\n+    create_env_store().lock().unwrap().insert(k, v);\n+    Ok(())\n+}\n+\n+pub fn unsetenv(k: &OsStr) -> io::Result<()> {\n+    if let Some(env) = get_env_store() {\n+        env.lock().unwrap().remove(k);\n+    }\n+    Ok(())\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    panic!(\"no filesystem in SGX\")\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    None\n+}\n+\n+pub fn exit(code: i32) -> ! {\n+    super::abi::exit_with_code(code as _)\n+}\n+\n+pub fn getpid() -> u32 {\n+    panic!(\"no pids in SGX\")\n+}"}, {"sha": "9bfb84db209456248adaff64844c3aeb6ea09639", "filename": "src/libstd/sys/sgx/os_str.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fos_str.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The underlying OsString/OsStr implementation on Unix systems: just\n+/// a `Vec<u8>`/`[u8]`.\n+\n+use borrow::Cow;\n+use fmt;\n+use str;\n+use mem;\n+use rc::Rc;\n+use sync::Arc;\n+use sys_common::{AsInner, IntoInner};\n+use sys_common::bytestring::debug_fmt_bytestring;\n+use core::str::lossy::Utf8Lossy;\n+\n+#[derive(Clone, Hash)]\n+pub struct Buf {\n+    pub inner: Vec<u8>\n+}\n+\n+pub struct Slice {\n+    pub inner: [u8]\n+}\n+\n+impl fmt::Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        debug_fmt_bytestring(&self.inner, formatter)\n+    }\n+}\n+\n+impl fmt::Display for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n+    }\n+}\n+\n+impl fmt::Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.as_slice(), formatter)\n+    }\n+}\n+\n+impl fmt::Display for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.as_slice(), formatter)\n+    }\n+}\n+\n+impl IntoInner<Vec<u8>> for Buf {\n+    fn into_inner(self) -> Vec<u8> {\n+        self.inner\n+    }\n+}\n+\n+impl AsInner<[u8]> for Buf {\n+    fn as_inner(&self) -> &[u8] {\n+        &self.inner\n+    }\n+}\n+\n+\n+impl Buf {\n+    pub fn from_string(s: String) -> Buf {\n+        Buf { inner: s.into_bytes() }\n+    }\n+\n+    #[inline]\n+    pub fn with_capacity(capacity: usize) -> Buf {\n+        Buf {\n+            inner: Vec::with_capacity(capacity)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.inner.clear()\n+    }\n+\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.inner.capacity()\n+    }\n+\n+    #[inline]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.inner.reserve(additional)\n+    }\n+\n+    #[inline]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.inner.reserve_exact(additional)\n+    }\n+\n+    #[inline]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.inner.shrink_to_fit()\n+    }\n+\n+    #[inline]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.inner.shrink_to(min_capacity)\n+    }\n+\n+    pub fn as_slice(&self) -> &Slice {\n+        unsafe { mem::transmute(&*self.inner) }\n+    }\n+\n+    pub fn into_string(self) -> Result<String, Buf> {\n+        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() } )\n+    }\n+\n+    pub fn push_slice(&mut self, s: &Slice) {\n+        self.inner.extend_from_slice(&s.inner)\n+    }\n+\n+    #[inline]\n+    pub fn into_box(self) -> Box<Slice> {\n+        unsafe { mem::transmute(self.inner.into_boxed_slice()) }\n+    }\n+\n+    #[inline]\n+    pub fn from_box(boxed: Box<Slice>) -> Buf {\n+        let inner: Box<[u8]> = unsafe { mem::transmute(boxed) };\n+        Buf { inner: inner.into_vec() }\n+    }\n+\n+    #[inline]\n+    pub fn into_arc(&self) -> Arc<Slice> {\n+        self.as_slice().into_arc()\n+    }\n+\n+    #[inline]\n+    pub fn into_rc(&self) -> Rc<Slice> {\n+        self.as_slice().into_rc()\n+    }\n+}\n+\n+impl Slice {\n+    fn from_u8_slice(s: &[u8]) -> &Slice {\n+        unsafe { mem::transmute(s) }\n+    }\n+\n+    pub fn from_str(s: &str) -> &Slice {\n+        Slice::from_u8_slice(s.as_bytes())\n+    }\n+\n+    pub fn to_str(&self) -> Option<&str> {\n+        str::from_utf8(&self.inner).ok()\n+    }\n+\n+    pub fn to_string_lossy(&self) -> Cow<str> {\n+        String::from_utf8_lossy(&self.inner)\n+    }\n+\n+    pub fn to_owned(&self) -> Buf {\n+        Buf { inner: self.inner.to_vec() }\n+    }\n+\n+    #[inline]\n+    pub fn into_box(&self) -> Box<Slice> {\n+        let boxed: Box<[u8]> = self.inner.into();\n+        unsafe { mem::transmute(boxed) }\n+    }\n+\n+    pub fn empty_box() -> Box<Slice> {\n+        let boxed: Box<[u8]> = Default::default();\n+        unsafe { mem::transmute(boxed) }\n+    }\n+\n+    #[inline]\n+    pub fn into_arc(&self) -> Arc<Slice> {\n+        let arc: Arc<[u8]> = Arc::from(&self.inner);\n+        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Slice) }\n+    }\n+\n+    #[inline]\n+    pub fn into_rc(&self) -> Rc<Slice> {\n+        let rc: Rc<[u8]> = Rc::from(&self.inner);\n+        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Slice) }\n+    }\n+}"}, {"sha": "afe0c490426f950150e3e96cfa7295f23e157979", "filename": "src/libstd/sys/sgx/path.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use path::Prefix;\n+use ffi::OsStr;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &'static str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "6c6cbc14a8ab2d7b3cb7306d488bf2dc61e12777", "filename": "src/libstd/sys/sgx/pipe.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fpipe.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::Void;\n+\n+pub struct AnonPipe(Void);\n+\n+impl AnonPipe {\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn read2(p1: AnonPipe,\n+             _v1: &mut Vec<u8>,\n+             _p2: AnonPipe,\n+             _v2: &mut Vec<u8>) -> io::Result<()> {\n+    match p1.0 {}\n+}"}, {"sha": "01a12fba043ca913bf7cae188912c446ba9d91fb", "filename": "src/libstd/sys/sgx/process.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsStr;\n+use fmt;\n+use io;\n+use sys::fs::File;\n+use sys::pipe::AnonPipe;\n+use sys::{unsupported, Void};\n+use sys_common::process::{CommandEnv, DefaultEnvKey};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    env: CommandEnv<DefaultEnvKey>\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+}\n+\n+impl Command {\n+    pub fn new(_program: &OsStr) -> Command {\n+        Command {\n+            env: Default::default()\n+        }\n+    }\n+\n+    pub fn arg(&mut self, _arg: &OsStr) {\n+    }\n+\n+    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+        &mut self.env\n+    }\n+\n+    pub fn cwd(&mut self, _dir: &OsStr) {\n+    }\n+\n+    pub fn stdin(&mut self, _stdin: Stdio) {\n+    }\n+\n+    pub fn stdout(&mut self, _stdout: Stdio) {\n+    }\n+\n+    pub fn stderr(&mut self, _stderr: Stdio) {\n+    }\n+\n+    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n+        -> io::Result<(Process, StdioPipes)> {\n+        unsupported()\n+    }\n+}\n+\n+impl From<AnonPipe> for Stdio {\n+    fn from(pipe: AnonPipe) -> Stdio {\n+        pipe.diverge()\n+    }\n+}\n+\n+impl From<File> for Stdio {\n+    fn from(file: File) -> Stdio {\n+        file.diverge()\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+pub struct ExitStatus(Void);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for ExitStatus {\n+    fn clone(&self) -> ExitStatus {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for ExitStatus {}\n+\n+impl PartialEq for ExitStatus {\n+    fn eq(&self, _other: &ExitStatus) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for ExitStatus {\n+}\n+\n+impl fmt::Debug for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(bool);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(false);\n+    pub const FAILURE: ExitCode = ExitCode(true);\n+\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n+pub struct Process(Void);\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        match self.0 {}\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        match self.0 {}\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        match self.0 {}\n+    }\n+}"}, {"sha": "7b6970b825f93cc71b056e3700acfe886fade64a", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use num::NonZeroUsize;\n+\n+use super::waitqueue::{WaitVariable, WaitQueue, SpinMutex, NotifiedTcs, try_lock_or_false};\n+\n+pub struct RWLock {\n+    readers: SpinMutex<WaitVariable<Option<NonZeroUsize>>>,\n+    writer: SpinMutex<WaitVariable<bool>>,\n+}\n+\n+//unsafe impl Send for RWLock {}\n+//unsafe impl Sync for RWLock {} // FIXME\n+\n+impl RWLock {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            readers: SpinMutex::new(WaitVariable::new(None)),\n+            writer: SpinMutex::new(WaitVariable::new(false))\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        let mut rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        if *wguard.lock_var() || !wguard.queue_empty() {\n+            // Another thread has or is waiting for the write lock, wait\n+            drop(wguard);\n+            WaitQueue::wait(rguard);\n+            // Another thread has passed the lock to us\n+        } else {\n+            // No waiting writers, acquire the read lock\n+            *rguard.lock_var_mut() =\n+                NonZeroUsize::new(rguard.lock_var().map_or(0, |n| n.get()) + 1);\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        let mut rguard = try_lock_or_false!(self.readers);\n+        let wguard = try_lock_or_false!(self.writer);\n+        if *wguard.lock_var() || !wguard.queue_empty() {\n+            // Another thread has or is waiting for the write lock\n+            false\n+        } else {\n+            // No waiting writers, acquire the read lock\n+            *rguard.lock_var_mut() =\n+                NonZeroUsize::new(rguard.lock_var().map_or(0, |n| n.get()) + 1);\n+            true\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        let rguard = self.readers.lock();\n+        let mut wguard = self.writer.lock();\n+        if *wguard.lock_var() || rguard.lock_var().is_some() {\n+            // Another thread has the lock, wait\n+            drop(rguard);\n+            WaitQueue::wait(wguard);\n+            // Another thread has passed the lock to us\n+        } else {\n+            // We are just now obtaining the lock\n+            *wguard.lock_var_mut() = true;\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        let rguard = try_lock_or_false!(self.readers);\n+        let mut wguard = try_lock_or_false!(self.writer);\n+        if *wguard.lock_var() || rguard.lock_var().is_some() {\n+            // Another thread has the lock\n+            false\n+        } else {\n+            // We are just now obtaining the lock\n+            *wguard.lock_var_mut() = true;\n+            true\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        let mut rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        *rguard.lock_var_mut() = NonZeroUsize::new(rguard.lock_var().unwrap().get() - 1);\n+        if rguard.lock_var().is_some() {\n+            // There are other active readers\n+        } else {\n+            if let Ok(mut wguard) = WaitQueue::notify_one(wguard) {\n+                // A writer was waiting, pass the lock\n+                *wguard.lock_var_mut() = true;\n+            } else {\n+                // No writers were waiting, the lock is released\n+                assert!(rguard.queue_empty());\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        let rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        if let Err(mut wguard) = WaitQueue::notify_one(wguard) {\n+            // No writers waiting, release the write lock\n+            *wguard.lock_var_mut() = false;\n+            if let Ok(mut rguard) = WaitQueue::notify_all(rguard) {\n+                // One or more readers were waiting, pass the lock to them\n+                if let NotifiedTcs::All { count } = rguard.notified_tcs() {\n+                    *rguard.lock_var_mut() = Some(count)\n+                } else {\n+                    unreachable!() // called notify_all\n+                }\n+            } else {\n+                // No readers waiting, the lock is released\n+            }\n+        } else {\n+            // There was a thread waiting for write, just pass the lock\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {}\n+}"}, {"sha": "0176b748a87c6f6192d65648755202a8408e24d7", "filename": "src/libstd/sys/sgx/stack_overflow.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Handler;\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        Handler\n+    }\n+}\n+\n+pub unsafe fn init() {\n+}\n+\n+pub unsafe fn cleanup() {\n+}"}, {"sha": "13c9119556929eedc08b62f9bc94bfb7a02a8951", "filename": "src/libstd/sys/sgx/stdio.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fortanix_sgx_abi as abi;\n+\n+use io;\n+use sys::fd::FileDesc;\n+\n+pub struct Stdin(());\n+pub struct Stdout(());\n+pub struct Stderr(());\n+\n+fn with_std_fd<F: FnOnce(&FileDesc) -> R, R>(fd: abi::Fd, f: F) -> R {\n+    let fd = FileDesc::new(fd);\n+    let ret = f(&fd);\n+    fd.into_raw();\n+    ret\n+}\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+\n+    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+        with_std_fd(abi::FD_STDIN, |fd| fd.read(data))\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        with_std_fd(abi::FD_STDOUT, |fd| fd.write(data))\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        with_std_fd(abi::FD_STDOUT, |fd| fd.flush())\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        with_std_fd(abi::FD_STDERR, |fd| fd.write(data))\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        with_std_fd(abi::FD_STDERR, |fd| fd.flush())\n+    }\n+}\n+\n+// FIXME: right now this raw stderr handle is used in a few places because\n+//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n+//        should go away\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Stderr::write(self, data)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Stderr::flush(self)\n+    }\n+}\n+\n+pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n+\n+pub fn is_ebadf(err: &io::Error) -> bool {\n+    // FIXME: Rust normally maps Unix EBADF to `Other`\n+    err.raw_os_error() == Some(abi::Error::BrokenPipe as _)\n+}\n+\n+pub fn panic_output() -> Option<impl io::Write> {\n+    super::abi::panic::SgxPanicOutput::new()\n+}"}, {"sha": "9de12a5e6f154367a005a5c64f52081385efb37b", "filename": "src/libstd/sys/sgx/thread.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use boxed::FnBox;\n+use ffi::CStr;\n+use io;\n+use time::Duration;\n+\n+use super::abi::usercalls;\n+\n+pub struct Thread(task_queue::JoinHandle);\n+\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n+\n+mod task_queue {\n+    use sync::{Mutex, MutexGuard, Once};\n+    use sync::mpsc;\n+    use boxed::FnBox;\n+\n+    pub type JoinHandle = mpsc::Receiver<()>;\n+\n+    pub(super) struct Task {\n+        p: Box<dyn FnBox()>,\n+        done: mpsc::Sender<()>,\n+    }\n+\n+    impl Task {\n+        pub(super) fn new(p: Box<dyn FnBox()>) -> (Task, JoinHandle) {\n+            let (done, recv) = mpsc::channel();\n+            (Task { p, done }, recv)\n+        }\n+\n+        pub(super) fn run(self) {\n+            (self.p)();\n+            let _ = self.done.send(());\n+        }\n+    }\n+\n+    static TASK_QUEUE_INIT: Once = Once::new();\n+    static mut TASK_QUEUE: Option<Mutex<Vec<Task>>> = None;\n+\n+    pub(super) fn lock() -> MutexGuard<'static, Vec<Task>> {\n+        unsafe {\n+            TASK_QUEUE_INIT.call_once(|| TASK_QUEUE = Some(Default::default()) );\n+            TASK_QUEUE.as_ref().unwrap().lock().unwrap()\n+        }\n+    }\n+}\n+\n+impl Thread {\n+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+    pub unsafe fn new(_stack: usize, p: Box<dyn FnBox()>)\n+        -> io::Result<Thread>\n+    {\n+        let mut queue_lock = task_queue::lock();\n+        usercalls::launch_thread()?;\n+        let (task, handle) = task_queue::Task::new(p);\n+        queue_lock.push(task);\n+        Ok(Thread(handle))\n+    }\n+\n+    pub(super) fn entry() {\n+        let mut guard = task_queue::lock();\n+        let task = guard.pop().expect(\"Thread started but no tasks pending\");\n+        drop(guard); // make sure to not hold the task queue lock longer than necessary\n+        task.run()\n+    }\n+\n+    pub fn yield_now() {\n+        assert_eq!(\n+            usercalls::wait(0, usercalls::WAIT_NO).unwrap_err().kind(),\n+            io::ErrorKind::WouldBlock\n+        );\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+        // FIXME: could store this pointer in TLS somewhere\n+    }\n+\n+    pub fn sleep(_dur: Duration) {\n+        panic!(\"can't sleep\"); // FIXME\n+    }\n+\n+    pub fn join(self) {\n+        let _ = self.0.recv();\n+    }\n+}\n+\n+pub mod guard {\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> { None }\n+    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn deinit() {}\n+}"}, {"sha": "3b628bae4fbf639331e50ee2635692ae1cda4ab6", "filename": "src/libstd/sys/sgx/thread_local.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::abi::tls::{Tls, Key as AbiKey};\n+\n+pub type Key = usize;\n+\n+#[inline]\n+pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    Tls::create(dtor).as_usize()\n+}\n+\n+#[inline]\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    Tls::set(AbiKey::from_usize(key), value)\n+}\n+\n+#[inline]\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    Tls::get(AbiKey::from_usize(key))\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(key: Key) {\n+    Tls::destroy(AbiKey::from_usize(key))\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "b01c992768e71dc54e02841d1fef7225dc1609a5", "filename": "src/libstd/sys/sgx/time.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use time::Duration;\n+use super::abi::usercalls;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct Instant(Duration);\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct SystemTime(Duration);\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        Instant(usercalls::insecure_time())\n+    }\n+\n+    pub fn sub_instant(&self, other: &Instant) -> Duration {\n+        self.0 - other.0\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> Instant {\n+        Instant(self.0 + *other)\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> Instant {\n+        Instant(self.0 - *other)\n+    }\n+}\n+\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        SystemTime(usercalls::insecure_time())\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime)\n+                    -> Result<Duration, Duration> {\n+        self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime(self.0 + *other)\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        self.0.checked_add(*other).map(|d| SystemTime(d))\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime(self.0 - *other)\n+    }\n+}"}, {"sha": "ec1135ba30c4ba1184c7d978ccb15ae7c1e9a0a1", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,552 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A simple queue implementation for synchronization primitives.\n+///\n+/// This queue is used to implement condition variable and mutexes.\n+///\n+/// Users of this API are expected to use the `WaitVariable<T>` type. Since\n+/// that type is not `Sync`, it needs to be protected by e.g. a `SpinMutex` to\n+/// allow shared access.\n+///\n+/// Since userspace may send spurious wake-ups, the wakeup event state is\n+/// recorded in the enclave. The wakeup event state is protected by a spinlock.\n+/// The queue and associated wait state are stored in a `WaitVariable`.\n+\n+use ops::{Deref, DerefMut};\n+use num::NonZeroUsize;\n+\n+use fortanix_sgx_abi::{Tcs, EV_UNPARK, WAIT_INDEFINITE};\n+use super::abi::usercalls;\n+use super::abi::thread;\n+\n+use self::unsafe_list::{UnsafeList, UnsafeListEntry};\n+pub use self::spin_mutex::{SpinMutex, SpinMutexGuard, try_lock_or_false};\n+\n+/// An queue entry in a `WaitQueue`.\n+struct WaitEntry {\n+    /// TCS address of the thread that is waiting\n+    tcs: Tcs,\n+    /// Whether this thread has been notified to be awoken\n+    wake: bool\n+}\n+\n+/// Data stored with a `WaitQueue` alongside it. This ensures accesses to the\n+/// queue and the data are synchronized, since the type itself is not `Sync`.\n+///\n+/// Consumers of this API should use a synchronization primitive for shared\n+/// access, such as `SpinMutex`.\n+#[derive(Default)]\n+pub struct WaitVariable<T> {\n+    queue: WaitQueue,\n+    lock: T\n+}\n+\n+impl<T> WaitVariable<T> {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+    pub const fn new(var: T) -> Self {\n+        WaitVariable {\n+            queue: WaitQueue::new(),\n+            lock: var\n+        }\n+    }\n+\n+    pub fn queue_empty(&self) -> bool {\n+        self.queue.is_empty()\n+    }\n+\n+    pub fn lock_var(&self) -> &T {\n+        &self.lock\n+    }\n+\n+    pub fn lock_var_mut(&mut self) -> &mut T {\n+        &mut self.lock\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum NotifiedTcs {\n+    Single(Tcs),\n+    All { count: NonZeroUsize }\n+}\n+\n+/// An RAII guard that will notify a set of target threads as well as unlock\n+/// a mutex on drop.\n+pub struct WaitGuard<'a, T: 'a> {\n+    mutex_guard: Option<SpinMutexGuard<'a, WaitVariable<T>>>,\n+    notified_tcs: NotifiedTcs\n+}\n+\n+/// A queue of threads that are waiting on some synchronization primitive.\n+///\n+/// `UnsafeList` entries are allocated on the waiting thread's stack. This\n+/// avoids any global locking that might happen in the heap allocator. This is\n+/// safe because the waiting thread will not return from that stack frame until\n+/// after it is notified. The notifying thread ensures to clean up any\n+/// references to the list entries before sending the wakeup event.\n+pub struct WaitQueue {\n+    // We use an inner Mutex here to protect the data in the face of spurious\n+    // wakeups.\n+    inner: UnsafeList<SpinMutex<WaitEntry>>,\n+}\n+unsafe impl Send for WaitQueue {}\n+\n+impl Default for WaitQueue {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<'a, T> WaitGuard<'a, T> {\n+    /// Returns which TCSes will be notified when this guard drops.\n+    pub fn notified_tcs(&self) -> NotifiedTcs {\n+        self.notified_tcs\n+    }\n+}\n+\n+impl<'a, T> Deref for WaitGuard<'a, T> {\n+    type Target = SpinMutexGuard<'a, WaitVariable<T>>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.mutex_guard.as_ref().unwrap()\n+    }\n+}\n+\n+impl<'a, T> DerefMut for WaitGuard<'a, T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.mutex_guard.as_mut().unwrap()\n+    }\n+}\n+\n+impl<'a, T> Drop for WaitGuard<'a, T> {\n+    fn drop(&mut self) {\n+        drop(self.mutex_guard.take());\n+        let target_tcs = match self.notified_tcs {\n+            NotifiedTcs::Single(tcs) => Some(tcs),\n+            NotifiedTcs::All { .. } => None\n+        };\n+        usercalls::send(EV_UNPARK, target_tcs).unwrap();\n+    }\n+}\n+\n+impl WaitQueue {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+    pub const fn new() -> Self {\n+        WaitQueue {\n+            inner: UnsafeList::new()\n+        }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n+\n+    /// Add the calling thread to the WaitVariable's wait queue, then wait\n+    /// until a wakeup event.\n+    ///\n+    /// This function does not return until this thread has been awoken.\n+    pub fn wait<T>(mut guard: SpinMutexGuard<WaitVariable<T>>) {\n+        unsafe {\n+            let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n+                tcs: thread::current(),\n+                wake: false\n+            }));\n+            let entry = guard.queue.inner.push(&mut entry);\n+            drop(guard);\n+            while !entry.lock().wake {\n+                assert_eq!(\n+                    usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap() & EV_UNPARK,\n+                    EV_UNPARK\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Either find the next waiter on the wait queue, or return the mutex\n+    /// guard unchanged.\n+    ///\n+    /// If a waiter is found, a `WaitGuard` is returned which will notify the\n+    /// waiter when it is dropped.\n+    pub fn notify_one<T>(mut guard: SpinMutexGuard<WaitVariable<T>>)\n+        -> Result<WaitGuard<T>, SpinMutexGuard<WaitVariable<T>>>\n+    {\n+        unsafe {\n+            if let Some(entry) = guard.queue.inner.pop() {\n+                let mut entry_guard = entry.lock();\n+                let tcs = entry_guard.tcs;\n+                entry_guard.wake = true;\n+                drop(entry);\n+                Ok(WaitGuard {\n+                    mutex_guard: Some(guard),\n+                    notified_tcs: NotifiedTcs::Single(tcs)\n+                })\n+            } else {\n+                Err(guard)\n+            }\n+        }\n+    }\n+\n+    /// Either find any and all waiters on the wait queue, or return the mutex\n+    /// guard unchanged.\n+    ///\n+    /// If at least one waiter is found, a `WaitGuard` is returned which will\n+    /// notify all waiters when it is dropped.\n+    pub fn notify_all<T>(mut guard: SpinMutexGuard<WaitVariable<T>>)\n+        -> Result<WaitGuard<T>, SpinMutexGuard<WaitVariable<T>>>\n+    {\n+        unsafe {\n+            let mut count = 0;\n+            while let Some(entry) = guard.queue.inner.pop() {\n+                count += 1;\n+                let mut entry_guard = entry.lock();\n+                entry_guard.wake = true;\n+            }\n+            if let Some(count) = NonZeroUsize::new(count) {\n+                Ok(WaitGuard {\n+                    mutex_guard: Some(guard),\n+                    notified_tcs: NotifiedTcs::All { count }\n+                })\n+            } else {\n+                Err(guard)\n+            }\n+        }\n+    }\n+}\n+\n+/// A doubly-linked list where callers are in charge of memory allocation\n+/// of the nodes in the list.\n+mod unsafe_list {\n+    use ptr::NonNull;\n+    use mem;\n+\n+    pub struct UnsafeListEntry<T> {\n+        next: NonNull<UnsafeListEntry<T>>,\n+        prev: NonNull<UnsafeListEntry<T>>,\n+        value: Option<T>\n+    }\n+\n+    impl<T> UnsafeListEntry<T> {\n+        fn dummy() -> Self {\n+            UnsafeListEntry {\n+                next: NonNull::dangling(),\n+                prev: NonNull::dangling(),\n+                value: None\n+            }\n+        }\n+\n+        pub fn new(value: T) -> Self {\n+            UnsafeListEntry {\n+                value: Some(value),\n+                ..Self::dummy()\n+            }\n+        }\n+    }\n+\n+    pub struct UnsafeList<T> {\n+        head_tail: NonNull<UnsafeListEntry<T>>,\n+        head_tail_entry: Option<UnsafeListEntry<T>>,\n+    }\n+\n+    impl<T> UnsafeList<T> {\n+        #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+        pub const fn new() -> Self {\n+            unsafe {\n+                UnsafeList {\n+                    head_tail: NonNull::new_unchecked(1 as _),\n+                    head_tail_entry: None\n+                }\n+            }\n+        }\n+\n+        unsafe fn init(&mut self) {\n+            if self.head_tail_entry.is_none() {\n+                self.head_tail_entry = Some(UnsafeListEntry::dummy());\n+                self.head_tail = NonNull::new_unchecked(self.head_tail_entry.as_mut().unwrap());\n+                self.head_tail.as_mut().next = self.head_tail;\n+                self.head_tail.as_mut().prev = self.head_tail;\n+            }\n+        }\n+\n+        pub fn is_empty(&self) -> bool {\n+            unsafe {\n+                if self.head_tail_entry.is_some() {\n+                    let first = self.head_tail.as_ref().next;\n+                    if first == self.head_tail {\n+                        // ,-------> /---------\\ next ---,\n+                        // |         |head_tail|         |\n+                        // `--- prev \\---------/ <-------`\n+                        assert_eq!(self.head_tail.as_ref().prev, first);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                } else {\n+                    true\n+                }\n+            }\n+        }\n+\n+        /// Pushes an entry onto the back of the list.\n+        ///\n+        /// # Safety\n+        ///\n+        /// The entry must remain allocated until the entry is removed from the\n+        /// list AND the caller who popped is done using the entry.\n+        pub unsafe fn push<'a>(&mut self, entry: &'a mut UnsafeListEntry<T>) -> &'a T {\n+            self.init();\n+\n+            // BEFORE:\n+            //     /---------\\ next ---> /---------\\\n+            // ... |prev_tail|           |head_tail| ...\n+            //     \\---------/ <--- prev \\---------/\n+            //\n+            // AFTER:\n+            //     /---------\\ next ---> /-----\\ next ---> /---------\\\n+            // ... |prev_tail|           |entry|           |head_tail| ...\n+            //     \\---------/ <--- prev \\-----/ <--- prev \\---------/\n+            let mut entry = NonNull::new_unchecked(entry);\n+            let mut prev_tail = mem::replace(&mut self.head_tail.as_mut().prev, entry);\n+            entry.as_mut().prev = prev_tail;\n+            entry.as_mut().next = self.head_tail;\n+            prev_tail.as_mut().next = entry;\n+            (*entry.as_ptr()).value.as_ref().unwrap()\n+        }\n+\n+        /// Pops an entry from the front of the list.\n+        ///\n+        /// # Safety\n+        ///\n+        /// The caller must make sure to synchronize ending the borrow of the\n+        /// return value and deallocation of the containing entry.\n+        pub unsafe fn pop<'a>(&mut self) -> Option<&'a T> {\n+            self.init();\n+\n+            if self.is_empty() {\n+                None\n+            } else {\n+                // BEFORE:\n+                //     /---------\\ next ---> /-----\\ next ---> /------\\\n+                // ... |head_tail|           |first|           |second| ...\n+                //     \\---------/ <--- prev \\-----/ <--- prev \\------/\n+                //\n+                // AFTER:\n+                //     /---------\\ next ---> /------\\\n+                // ... |head_tail|           |second| ...\n+                //     \\---------/ <--- prev \\------/\n+                let mut first = self.head_tail.as_mut().next;\n+                let mut second = first.as_mut().next;\n+                self.head_tail.as_mut().next = second;\n+                second.as_mut().prev = self.head_tail;\n+                first.as_mut().next = NonNull::dangling();\n+                first.as_mut().prev = NonNull::dangling();\n+                Some((*first.as_ptr()).value.as_ref().unwrap())\n+            }\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use super::*;\n+        use cell::Cell;\n+\n+        unsafe fn assert_empty<T>(list: &mut UnsafeList<T>) {\n+            assert!(list.pop().is_none(), \"assertion failed: list is not empty\");\n+        }\n+\n+        #[test]\n+        fn init_empty() {\n+            unsafe {\n+                assert_empty(&mut UnsafeList::<i32>::new());\n+            }\n+        }\n+\n+        #[test]\n+        fn push_pop() {\n+            unsafe {\n+                let mut node = UnsafeListEntry::new(1234);\n+                let mut list = UnsafeList::new();\n+                assert_eq!(list.push(&mut node), &1234);\n+                assert_eq!(list.pop().unwrap(), &1234);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n+        #[test]\n+        fn complex_pushes_pops() {\n+            unsafe {\n+                let mut node1 = UnsafeListEntry::new(1234);\n+                let mut node2 = UnsafeListEntry::new(4567);\n+                let mut node3 = UnsafeListEntry::new(9999);\n+                let mut node4 = UnsafeListEntry::new(8642);\n+                let mut list = UnsafeList::new();\n+                list.push(&mut node1);\n+                list.push(&mut node2);\n+                assert_eq!(list.pop().unwrap(), &1234);\n+                list.push(&mut node3);\n+                assert_eq!(list.pop().unwrap(), &4567);\n+                assert_eq!(list.pop().unwrap(), &9999);\n+                assert_empty(&mut list);\n+                list.push(&mut node4);\n+                assert_eq!(list.pop().unwrap(), &8642);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n+        #[test]\n+        fn cell() {\n+            unsafe {\n+                let mut node = UnsafeListEntry::new(Cell::new(0));\n+                let mut list = UnsafeList::new();\n+                let noderef = list.push(&mut node);\n+                assert_eq!(noderef.get(), 0);\n+                list.pop().unwrap().set(1);\n+                assert_empty(&mut list);\n+                assert_eq!(noderef.get(), 1);\n+            }\n+        }\n+    }\n+}\n+\n+/// Trivial spinlock-based implementation of `sync::Mutex`.\n+// FIXME: Perhaps use Intel TSX to avoid locking?\n+mod spin_mutex {\n+    use cell::UnsafeCell;\n+    use sync::atomic::{AtomicBool, Ordering, spin_loop_hint};\n+    use ops::{Deref, DerefMut};\n+\n+    #[derive(Default)]\n+    pub struct SpinMutex<T> {\n+        value: UnsafeCell<T>,\n+        lock: AtomicBool,\n+    }\n+\n+    unsafe impl<T: Send> Send for SpinMutex<T> {}\n+    unsafe impl<T: Send> Sync for SpinMutex<T> {}\n+\n+    pub struct SpinMutexGuard<'a, T: 'a> {\n+        mutex: &'a SpinMutex<T>,\n+    }\n+\n+    impl<'a, T> !Send for SpinMutexGuard<'a, T> {}\n+    unsafe impl<'a, T: Sync> Sync for SpinMutexGuard<'a, T> {}\n+\n+    impl<T> SpinMutex<T> {\n+        pub const fn new(value: T) -> Self {\n+            SpinMutex {\n+                value: UnsafeCell::new(value),\n+                lock: AtomicBool::new(false)\n+            }\n+        }\n+\n+        #[inline(always)]\n+        pub fn lock(&self) -> SpinMutexGuard<T> {\n+            loop {\n+                match self.try_lock() {\n+                    None => while self.lock.load(Ordering::Relaxed) {\n+                        spin_loop_hint()\n+                    },\n+                    Some(guard) => return guard\n+                }\n+            }\n+        }\n+\n+        #[inline(always)]\n+        pub fn try_lock(&self) -> Option<SpinMutexGuard<T>> {\n+            if !self.lock.compare_and_swap(false, true, Ordering::Acquire) {\n+                Some(SpinMutexGuard {\n+                    mutex: self,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    pub macro try_lock_or_false {\n+        ($e:expr) => {\n+            if let Some(v) = $e.try_lock() {\n+                v\n+            } else {\n+                return false\n+            }\n+        }\n+    }\n+\n+    impl<'a, T> Deref for SpinMutexGuard<'a, T> {\n+        type Target = T;\n+\n+        fn deref(&self) -> &T {\n+            unsafe {\n+                &*self.mutex.value.get()\n+            }\n+        }\n+    }\n+\n+    impl<'a, T> DerefMut for SpinMutexGuard<'a, T> {\n+        fn deref_mut(&mut self) -> &mut T {\n+            unsafe {\n+                &mut*self.mutex.value.get()\n+            }\n+        }\n+    }\n+\n+    impl<'a, T> Drop for SpinMutexGuard<'a, T> {\n+        fn drop(&mut self) {\n+            self.mutex.lock.store(false, Ordering::Release)\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        #![allow(deprecated)]\n+\n+        use super::*;\n+        use sync::Arc;\n+        use thread;\n+\n+        #[test]\n+        fn sleep() {\n+            let mutex = Arc::new(SpinMutex::<i32>::default());\n+            let mutex2 = mutex.clone();\n+            let guard = mutex.lock();\n+            let t1 = thread::spawn(move || {\n+                *mutex2.lock() = 1;\n+            });\n+            thread::sleep_ms(50);\n+            assert_eq!(*guard, 0);\n+            drop(guard);\n+            t1.join().unwrap();\n+            assert_eq!(*mutex.lock(), 1);\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use sync::Arc;\n+    use thread;\n+\n+    #[test]\n+    fn queue() {\n+        let wq = Arc::new(SpinMutex::<WaitVariable<()>>::default());\n+        let wq2 = wq.clone();\n+\n+        let locked = wq.lock();\n+\n+        let t1 = thread::spawn(move || {\n+            assert!(WaitQueue::notify_one(wq2.lock()).is_none())\n+        });\n+\n+        WaitQueue::wait(locked);\n+\n+        t1.join().unwrap();\n+    }\n+}"}, {"sha": "bbb0fd45ba3dd5f6ff0346b4f373027c088bf3c7", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -21,7 +21,7 @@ pub mod net {\n     use sys_common::{AsInner, FromInner, IntoInner};\n     use sys::fd::FileDesc;\n     use time::Duration;\n-\n+    use convert::TryFrom;\n \n     pub extern crate libc as netc;\n \n@@ -118,7 +118,7 @@ pub mod net {\n     }\n \n     impl TcpStream {\n-        pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+        pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n             unimpl!();\n         }\n \n@@ -216,7 +216,7 @@ pub mod net {\n     }\n \n     impl TcpListener {\n-        pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n             unimpl!();\n         }\n \n@@ -278,7 +278,7 @@ pub mod net {\n     }\n \n     impl UdpSocket {\n-        pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n             unimpl!();\n         }\n \n@@ -402,7 +402,7 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+        pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n             unimpl!();\n         }\n     }\n@@ -431,11 +431,30 @@ pub mod net {\n         }\n     }\n \n+    impl LookupHost {\n+        pub fn port(&self) -> u16 {\n+            unimpl!();\n+        }\n+    }\n+\n     unsafe impl Sync for LookupHost {}\n     unsafe impl Send for LookupHost {}\n \n-    pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n-        unimpl!();\n+\n+    impl<'a> TryFrom<&'a str> for LookupHost {\n+        type Error = io::Error;\n+\n+        fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+        type Error = io::Error;\n+\n+        fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+            unimpl!();\n+        }\n     }\n }\n "}, {"sha": "63e341abb2c140e56672d0409e702bc8fd6209c4", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -76,6 +76,6 @@ pub fn is_ebadf(err: &io::Error) -> bool {\n \n pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n \n-pub fn stderr_prints_nothing() -> bool {\n-    false\n+pub fn panic_output() -> Option<impl io::Write> {\n+    Stderr::new().ok()\n }"}, {"sha": "4ff060018ae330a5d99f51abc968ed7f934aacbd", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -49,7 +49,8 @@ unsafe fn pthread_attr_setstacksize(_attr: *mut libc::pthread_attr_t,\n }\n \n impl Thread {\n-    pub unsafe fn new<'a>(stack: usize, p: Box<dyn FnBox() + 'a>)\n+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnBox()>)\n                           -> io::Result<Thread> {\n         let p = box p;\n         let mut native: libc::pthread_t = mem::zeroed();"}, {"sha": "d4f8d66ee3e7f6b1fc78fc34df71ef52a88df6af", "filename": "src/libstd/sys/wasm/cmath.rs", "status": "modified", "additions": 14, "deletions": 67, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -8,85 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[inline]\n-pub unsafe fn cbrtf(n: f32) -> f32 {\n-    f64::cbrt(n as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn expm1f(n: f32) -> f32 {\n-    f64::exp_m1(n as f64) as f32\n-}\n-\n-#[inline]\n-#[allow(deprecated)]\n-pub unsafe fn fdimf(a: f32, b: f32) -> f32 {\n-    f64::abs_sub(a as f64, b as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn log1pf(n: f32) -> f32 {\n-    f64::ln_1p(n as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn hypotf(x: f32, y: f32) -> f32 {\n-    f64::hypot(x as f64, y as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn acosf(n: f32) -> f32 {\n-    f64::acos(n as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn asinf(n: f32) -> f32 {\n-    f64::asin(n as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn atan2f(n: f32, b: f32) -> f32 {\n-    f64::atan2(n as f64, b as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn atanf(n: f32) -> f32 {\n-    f64::atan(n as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn coshf(n: f32) -> f32 {\n-    f64::cosh(n as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn sinhf(n: f32) -> f32 {\n-    f64::sinh(n as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn tanf(n: f32) -> f32 {\n-    f64::tan(n as f64) as f32\n-}\n-\n-#[inline]\n-pub unsafe fn tanhf(n: f32) -> f32 {\n-    f64::tanh(n as f64) as f32\n-}\n-\n // These symbols are all defined in `compiler-builtins`\n extern {\n     pub fn acos(n: f64) -> f64;\n+    pub fn acosf(n: f32) -> f32;\n     pub fn asin(n: f64) -> f64;\n+    pub fn asinf(n: f32) -> f32;\n     pub fn atan(n: f64) -> f64;\n     pub fn atan2(a: f64, b: f64) -> f64;\n+    pub fn atan2f(a: f32, b: f32) -> f32;\n+    pub fn atanf(n: f32) -> f32;\n     pub fn cbrt(n: f64) -> f64;\n+    pub fn cbrtf(n: f32) -> f32;\n     pub fn cosh(n: f64) -> f64;\n+    pub fn coshf(n: f32) -> f32;\n     pub fn expm1(n: f64) -> f64;\n+    pub fn expm1f(n: f32) -> f32;\n     pub fn fdim(a: f64, b: f64) -> f64;\n+    pub fn fdimf(a: f32, b: f32) -> f32;\n+    pub fn hypot(x: f64, y: f64) -> f64;\n+    pub fn hypotf(x: f32, y: f32) -> f32;\n     pub fn log1p(n: f64) -> f64;\n+    pub fn log1pf(n: f32) -> f32;\n     pub fn sinh(n: f64) -> f64;\n+    pub fn sinhf(n: f32) -> f32;\n     pub fn tan(n: f64) -> f64;\n+    pub fn tanf(n: f32) -> f32;\n     pub fn tanh(n: f64) -> f64;\n-    pub fn hypot(x: f64, y: f64) -> f64;\n+    pub fn tanhf(n: f32) -> f32;\n }"}, {"sha": "e1c33b09cb420be121e0b323edb84f50cb313e49", "filename": "src/libstd/sys/wasm/net.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -13,11 +13,12 @@ use io;\n use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n use time::Duration;\n use sys::{unsupported, Void};\n+use convert::TryFrom;\n \n pub struct TcpStream(Void);\n \n impl TcpStream {\n-    pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n         unsupported()\n     }\n \n@@ -103,7 +104,7 @@ impl fmt::Debug for TcpStream {\n pub struct TcpListener(Void);\n \n impl TcpListener {\n-    pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n         unsupported()\n     }\n \n@@ -153,7 +154,7 @@ impl fmt::Debug for TcpListener {\n pub struct UdpSocket(Void);\n \n impl UdpSocket {\n-    pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n         unsupported()\n     }\n \n@@ -273,7 +274,7 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n         match self.0 {}\n     }\n }\n@@ -286,15 +287,33 @@ impl fmt::Debug for UdpSocket {\n \n pub struct LookupHost(Void);\n \n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        match self.0 {}\n+    }\n+}\n+\n impl Iterator for LookupHost {\n     type Item = SocketAddr;\n     fn next(&mut self) -> Option<SocketAddr> {\n         match self.0 {}\n     }\n }\n \n-pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n-    unsupported()\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n }\n \n #[allow(nonstandard_style)]"}, {"sha": "e51aba75333b651bcca5fdb213d631b100c5a88a", "filename": "src/libstd/sys/wasm/stdio.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -70,6 +70,10 @@ pub fn is_ebadf(_err: &io::Error) -> bool {\n     true\n }\n \n-pub fn stderr_prints_nothing() -> bool {\n-    !cfg!(feature = \"wasm_syscall\")\n+pub fn panic_output() -> Option<impl io::Write> {\n+    if cfg!(feature = \"wasm_syscall\") {\n+        Stderr::new().ok()\n+    } else {\n+        None\n+    }\n }"}, {"sha": "3d74ffdc14a596befac7ac8a9a862581267a8929", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -19,7 +19,8 @@ pub struct Thread(Void);\n pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n \n impl Thread {\n-    pub unsafe fn new<'a>(_stack: usize, _p: Box<dyn FnBox() + 'a>)\n+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+    pub unsafe fn new(_stack: usize, _p: Box<dyn FnBox()>)\n         -> io::Result<Thread>\n     {\n         unsupported()"}, {"sha": "61e0db87ebe118ef0ea3d50bc0e63acaa8412b8d", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -228,6 +228,6 @@ pub fn is_ebadf(err: &io::Error) -> bool {\n // been seen to be acceptable.\n pub const STDIN_BUF_SIZE: usize = 8 * 1024;\n \n-pub fn stderr_prints_nothing() -> bool {\n-    false\n+pub fn panic_output() -> Option<impl io::Write> {\n+    Stderr::new().ok()\n }"}, {"sha": "1a97dd10ced8d2c284b299b84a8f5c3caa236c17", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -28,7 +28,8 @@ pub struct Thread {\n }\n \n impl Thread {\n-    pub unsafe fn new<'a>(stack: usize, p: Box<dyn FnBox() + 'a>)\n+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnBox()>)\n                           -> io::Result<Thread> {\n         let p = box p;\n "}, {"sha": "16bf0803a8dfee293a0c6e20b45ffb87d908aa90", "filename": "src/libstd/sys_common/condvar.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fcondvar.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -25,6 +25,7 @@ impl Condvar {\n     ///\n     /// Behavior is undefined if the condition variable is moved after it is\n     /// first used with any of the functions below.\n+    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Condvar { Condvar(imp::Condvar::new()) }\n \n     /// Prepares the condition variable for use."}, {"sha": "881794d9f16da4b7ada8f45bddab490fda957f4e", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -57,9 +57,11 @@ pub mod bytestring;\n pub mod process;\n \n cfg_if! {\n-    if #[cfg(any(target_os = \"cloudabi\", target_os = \"l4re\", target_os = \"redox\"))] {\n-        pub use sys::net;\n-    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n+    if #[cfg(any(target_os = \"cloudabi\",\n+                 target_os = \"l4re\",\n+                 target_os = \"redox\",\n+                 all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+                 target_env = \"sgx\"))] {\n         pub use sys::net;\n     } else {\n         pub mod net;"}, {"sha": "87684237638987c805f1c3f7e7baf678a319376c", "filename": "src/libstd/sys_common/mutex.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmutex.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -27,6 +27,7 @@ impl Mutex {\n     /// Also, until `init` is called, behavior is undefined if this\n     /// mutex is ever used reentrantly, i.e., `raw_lock` or `try_lock`\n     /// are called by the thread currently holding the lock.\n+    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n \n     /// Prepare the mutex for use."}, {"sha": "dce2bf71cecab9fea0b43574301ae1e88d71b238", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -20,6 +20,7 @@ use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n use sys::net::netc as c;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n+use convert::{TryFrom, TryInto};\n \n #[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"ios\", target_os = \"macos\",\n@@ -129,6 +130,13 @@ fn to_ipv6mr_interface(value: u32) -> ::libc::c_uint {\n pub struct LookupHost {\n     original: *mut c::addrinfo,\n     cur: *mut c::addrinfo,\n+    port: u16\n+}\n+\n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        self.port\n+    }\n }\n \n impl Iterator for LookupHost {\n@@ -158,17 +166,45 @@ impl Drop for LookupHost {\n     }\n }\n \n-pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n-    init();\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n \n-    let c_host = CString::new(host)?;\n-    let mut hints: c::addrinfo = unsafe { mem::zeroed() };\n-    hints.ai_socktype = c::SOCK_STREAM;\n-    let mut res = ptr::null_mut();\n-    unsafe {\n-        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)).map(|_| {\n-            LookupHost { original: res, cur: res }\n-        })\n+    fn try_from(s: &str) -> io::Result<LookupHost> {\n+        macro_rules! try_opt {\n+            ($e:expr, $msg:expr) => (\n+                match $e {\n+                    Some(r) => r,\n+                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                                      $msg)),\n+                }\n+            )\n+        }\n+\n+        // split the string by ':' and convert the second part to u16\n+        let mut parts_iter = s.rsplitn(2, ':');\n+        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n+\n+        (host, port).try_into()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n+        init();\n+\n+        let c_host = CString::new(host)?;\n+        let mut hints: c::addrinfo = unsafe { mem::zeroed() };\n+        hints.ai_socktype = c::SOCK_STREAM;\n+        let mut res = ptr::null_mut();\n+        unsafe {\n+            cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)).map(|_| {\n+                LookupHost { original: res, cur: res, port }\n+            })\n+        }\n     }\n }\n \n@@ -181,7 +217,9 @@ pub struct TcpStream {\n }\n \n impl TcpStream {\n-    pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> {\n+    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+        let addr = addr?;\n+\n         init();\n \n         let sock = Socket::new(addr, c::SOCK_STREAM)?;\n@@ -317,7 +355,9 @@ pub struct TcpListener {\n }\n \n impl TcpListener {\n-    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> {\n+    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+        let addr = addr?;\n+\n         init();\n \n         let sock = Socket::new(addr, c::SOCK_STREAM)?;\n@@ -418,7 +458,9 @@ pub struct UdpSocket {\n }\n \n impl UdpSocket {\n-    pub fn bind(addr: &SocketAddr) -> io::Result<UdpSocket> {\n+    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n+        let addr = addr?;\n+\n         init();\n \n         let sock = Socket::new(addr, c::SOCK_DGRAM)?;\n@@ -584,8 +626,8 @@ impl UdpSocket {\n         Ok(ret as usize)\n     }\n \n-    pub fn connect(&self, addr: &SocketAddr) -> io::Result<()> {\n-        let (addrp, len) = addr.into_inner();\n+    pub fn connect(&self, addr: io::Result<&SocketAddr>) -> io::Result<()> {\n+        let (addrp, len) = addr?.into_inner();\n         cvt_r(|| unsafe { c::connect(*self.inner.as_inner(), addrp, len) }).map(|_| ())\n     }\n }\n@@ -618,7 +660,7 @@ mod tests {\n     #[test]\n     fn no_lookup_host_duplicates() {\n         let mut addrs = HashMap::new();\n-        let lh = match lookup_host(\"localhost\") {\n+        let lh = match LookupHost::try_from((\"localhost\", 0)) {\n             Ok(lh) => lh,\n             Err(e) => panic!(\"couldn't resolve `localhost': {}\", e)\n         };"}, {"sha": "a430c254d3c585f608b61fa360562f2a3c7cd74d", "filename": "src/libstd/sys_common/rwlock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Frwlock.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -22,6 +22,7 @@ impl RWLock {\n     ///\n     /// Behavior is undefined if the reader-writer lock is moved after it is\n     /// first used with any of the functions below.\n+    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n \n     /// Acquires shared access to the underlying lock, blocking the current"}, {"sha": "fc86a59d17f2e93659bbe6f92fbc9548861b8de7", "filename": "src/libstd/sys_common/util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fsys_common%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Futil.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -10,14 +10,13 @@\n \n use fmt;\n use io::prelude::*;\n-use sys::stdio::{Stderr, stderr_prints_nothing};\n+use sys::stdio::panic_output;\n use thread;\n \n pub fn dumb_print(args: fmt::Arguments) {\n-    if stderr_prints_nothing() {\n-        return\n+    if let Some(mut out) = panic_output() {\n+        let _ = out.write_fmt(args);\n     }\n-    let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }\n \n // Other platforms should use the appropriate platform-specific mechanism for"}, {"sha": "d15b49024121b9d1f618034d3aa93a1215668efe", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -167,10 +167,12 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use any::Any;\n+use boxed::FnBox;\n use cell::UnsafeCell;\n use ffi::{CStr, CString};\n use fmt;\n use io;\n+use mem;\n use panic;\n use panicking;\n use str;\n@@ -452,8 +454,8 @@ impl Builder {\n     /// [`io::Result`]: ../../std/io/type.Result.html\n     /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n     #[unstable(feature = \"thread_spawn_unchecked\", issue = \"55132\")]\n-    pub unsafe fn spawn_unchecked<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n-        F: FnOnce() -> T, F: Send, T: Send\n+    pub unsafe fn spawn_unchecked<'a, F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n+        F: FnOnce() -> T, F: Send + 'a, T: Send + 'a\n     {\n         let Builder { name, stack_size } = self;\n \n@@ -482,7 +484,21 @@ impl Builder {\n         };\n \n         Ok(JoinHandle(JoinInner {\n-            native: Some(imp::Thread::new(stack_size, Box::new(main))?),\n+            // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n+            // through FFI or otherwise used with low-level threading primitives that have no\n+            // notion of or way to enforce lifetimes.\n+            //\n+            // As mentioned in the `Safety` section of this function's documentation, the caller of\n+            // this function needs to guarantee that the passed-in lifetime is sufficiently long\n+            // for the lifetime of the thread.\n+            //\n+            // Similarly, the `sys` implementation must guarantee that no references to the closure\n+            // exist after the thread has terminated, which is signaled by `Thread::join`\n+            // returning.\n+            native: Some(imp::Thread::new(\n+                stack_size,\n+                mem::transmute::<Box<dyn FnBox() + 'a>, Box<dyn FnBox() + 'static>>(Box::new(main))\n+            )?),\n             thread: my_thread,\n             packet: Packet(my_packet),\n         }))"}, {"sha": "b8711a691477bccd63467fadca5f3c237a118efd", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -1018,10 +1018,12 @@ fn use_color(opts: &TestOpts) -> bool {\n     }\n }\n \n-#[cfg(any(target_os = \"cloudabi\", target_os = \"redox\",\n-          all(target_arch = \"wasm32\", not(target_os = \"emscripten\"))))]\n+#[cfg(any(target_os = \"cloudabi\",\n+          target_os = \"redox\",\n+          all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+          target_env = \"sgx\"))]\n fn stdout_isatty() -> bool {\n-    // FIXME: Implement isatty on Redox\n+    // FIXME: Implement isatty on Redox and SGX\n     false\n }\n #[cfg(unix)]\n@@ -1246,7 +1248,7 @@ fn get_concurrency() -> usize {\n         1\n     }\n \n-    #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+    #[cfg(any(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")), target_env = \"sgx\"))]\n     fn num_cpus() -> usize {\n         1\n     }"}, {"sha": "eb53332ab3302f7c394d52e86b7d9ddfc3f037d6", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -26,7 +26,10 @@ mod macros;\n cfg_if! {\n     if #[cfg(target_env = \"msvc\")] {\n         // no extra unwinder support needed\n-    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n+    } else if #[cfg(any(\n+        all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+        target_env = \"sgx\"\n+    ))] {\n         // no unwinder on the system!\n     } else {\n         extern crate libc;"}, {"sha": "9656260888095f44830641ca7bb3da609a793451", "filename": "src/rust-sgx", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-sgx?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1 @@\n+Subproject commit 9656260888095f44830641ca7bb3da609a793451"}, {"sha": "fd81d3db3a79b0a84730e9c0d327de9aa4ed6acf", "filename": "src/rustc/fortanix-sgx-abi_shim/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Frustc%2Ffortanix-sgx-abi_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Frustc%2Ffortanix-sgx-abi_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffortanix-sgx-abi_shim%2FCargo.toml?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"fortanix-sgx-abi\"\n+version = \"0.0.0\"\n+authors = [\"The Rust Project Developers\"]\n+\n+[lib]\n+path = \"../../rust-sgx/fortanix-sgx-abi/src/lib.rs\"\n+test = false\n+bench = false\n+doc = false\n+\n+[dependencies]\n+core = { path = \"../../libcore\" }\n+compiler_builtins = { path = \"../../rustc/compiler_builtins_shim\" }"}, {"sha": "5e628c5120c619a22799187371f057ec41e06f87", "filename": "src/stdsimd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstdsimd?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -1 +1 @@\n-Subproject commit 0309be1ade6bf61066f2c69f77ac3567b7dc31b5\n+Subproject commit 5e628c5120c619a22799187371f057ec41e06f87"}, {"sha": "53db589beaf46cd24f9a9181914130aa3159fa4b", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15a2607863fded7570cacfc7825702dde5a4234c/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a2607863fded7570cacfc7825702dde5a4234c/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=15a2607863fded7570cacfc7825702dde5a4234c", "patch": "@@ -76,6 +76,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/tools/lldb\",\n         \"src/target\",\n         \"src/stdsimd\",\n+        \"src/rust-sgx\",\n         \"target\",\n         \"vendor\",\n     ];"}]}