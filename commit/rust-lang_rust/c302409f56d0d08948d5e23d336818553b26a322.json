{"sha": "c302409f56d0d08948d5e23d336818553b26a322", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMDI0MDlmNTZkMGQwODk0OGQ1ZTIzZDMzNjgxODU1M2IyNmEzMjI=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T15:26:36Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T23:05:35Z"}, "message": "Get rid of ToExpr trait", "tree": {"sha": "450f07cb455ee47e9e7a6da313bc850df75f1a90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/450f07cb455ee47e9e7a6da313bc850df75f1a90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c302409f56d0d08948d5e23d336818553b26a322", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c302409f56d0d08948d5e23d336818553b26a322", "html_url": "https://github.com/rust-lang/rust/commit/c302409f56d0d08948d5e23d336818553b26a322", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c302409f56d0d08948d5e23d336818553b26a322/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "html_url": "https://github.com/rust-lang/rust/commit/755d27a4241d9b2a6fa90118d9d40ae729fe5c68"}], "stats": {"total": 323, "additions": 164, "deletions": 159}, "files": [{"sha": "153f3413f105a459775984a72b041437963976f4", "filename": "src/closures.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c302409f56d0d08948d5e23d336818553b26a322/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c302409f56d0d08948d5e23d336818553b26a322/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=c302409f56d0d08948d5e23d336818553b26a322", "patch": "@@ -13,9 +13,10 @@ use syntax::parse::classify;\n use syntax::source_map::Span;\n use syntax::{ast, ptr};\n \n-use expr::{block_contains_comment, is_simple_block, is_unsafe_block, rewrite_cond, ToExpr};\n+use expr::{block_contains_comment, is_simple_block, is_unsafe_block, rewrite_cond};\n use items::{span_hi_for_arg, span_lo_for_arg};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n+use overflow::OverflowableItem;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use source_map::SpanUtils;\n@@ -358,10 +359,7 @@ pub fn rewrite_last_closure(\n }\n \n /// Returns true if the given vector of arguments has more than one `ast::ExprKind::Closure`.\n-pub fn args_have_many_closure<T>(args: &[&T]) -> bool\n-where\n-    T: ToExpr,\n-{\n+pub fn args_have_many_closure(args: &[OverflowableItem]) -> bool {\n     args.iter()\n         .filter(|arg| {\n             arg.to_expr()"}, {"sha": "102fab346d79f8dfca3a1479b71be6253cc29d56", "filename": "src/expr.rs", "status": "modified", "additions": 12, "deletions": 104, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c302409f56d0d08948d5e23d336818553b26a322/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c302409f56d0d08948d5e23d336818553b26a322/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c302409f56d0d08948d5e23d336818553b26a322", "patch": "@@ -27,17 +27,17 @@ use lists::{\n     definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape,\n     struct_lit_tactic, write_list, ListFormatting, ListItem, Separator,\n };\n-use macros::{rewrite_macro, MacroArg, MacroPosition};\n+use macros::{rewrite_macro, MacroPosition};\n use matches::rewrite_match;\n-use overflow;\n+use overflow::{self, IntoOverflowableItem, OverflowableItem};\n use pairs::{rewrite_all_pairs, rewrite_pair, PairParts};\n-use patterns::{can_be_overflowed_pat, is_short_pattern, TuplePatField};\n+use patterns::is_short_pattern;\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use source_map::{LineRangeUtils, SpanUtils};\n use spanned::Spanned;\n use string::{rewrite_string, StringFormat};\n-use types::{can_be_overflowed_type, rewrite_path, PathContext};\n+use types::{rewrite_path, PathContext};\n use utils::{\n     colon_spaces, contains_skip, count_newlines, first_line_ends_with, first_line_width,\n     inner_attributes, last_line_extendable, last_line_width, mk_sp, outer_attributes,\n@@ -391,18 +391,15 @@ pub fn format_expr(\n         })\n }\n \n-pub fn rewrite_array<'a, T: 'a>(\n+pub fn rewrite_array<'a, T: 'a + IntoOverflowableItem<'a>>(\n     name: &'a str,\n     exprs: impl Iterator<Item = &'a T>,\n     span: Span,\n     context: &'a RewriteContext,\n     shape: Shape,\n     force_separator_tactic: Option<SeparatorTactic>,\n     delim_token: Option<DelimToken>,\n-) -> Option<String>\n-where\n-    T: Rewrite + Spanned + ToExpr,\n-{\n+) -> Option<String> {\n     overflow::rewrite_with_square_brackets(\n         context,\n         name,\n@@ -1263,7 +1260,7 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n }\n \n /// In case special-case style is required, returns an offset from which we start horizontal layout.\n-pub fn maybe_get_args_offset<T: ToExpr>(callee_str: &str, args: &[&T]) -> Option<(bool, usize)> {\n+pub fn maybe_get_args_offset(callee_str: &str, args: &[OverflowableItem]) -> Option<(bool, usize)> {\n     if let Some(&(_, num_args_before)) = SPECIAL_MACRO_WHITELIST\n         .iter()\n         .find(|&&(s, _)| s == callee_str)\n@@ -1358,7 +1355,7 @@ fn is_simple_expr(expr: &ast::Expr) -> bool {\n     }\n }\n \n-pub fn is_every_expr_simple<T: ToExpr>(lists: &[&T]) -> bool {\n+pub fn is_every_expr_simple(lists: &[OverflowableItem]) -> bool {\n     lists\n         .iter()\n         .all(|arg| arg.to_expr().map_or(false, is_simple_expr))\n@@ -1723,16 +1720,13 @@ pub fn rewrite_field(\n     }\n }\n \n-fn rewrite_tuple_in_visual_indent_style<'a, T>(\n+fn rewrite_tuple_in_visual_indent_style<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &RewriteContext,\n     mut items: impl Iterator<Item = &'a T>,\n     span: Span,\n     shape: Shape,\n     is_singleton_tuple: bool,\n-) -> Option<String>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n+) -> Option<String> {\n     // In case of length 1, need a trailing comma\n     debug!(\"rewrite_tuple_in_visual_indent_style {:?}\", shape);\n     if is_singleton_tuple {\n@@ -1774,16 +1768,13 @@ where\n     Some(format!(\"({})\", list_str))\n }\n \n-pub fn rewrite_tuple<'a, T>(\n+pub fn rewrite_tuple<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext,\n     items: impl Iterator<Item = &'a T>,\n     span: Span,\n     shape: Shape,\n     is_singleton_tuple: bool,\n-) -> Option<String>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n+) -> Option<String> {\n     debug!(\"rewrite_tuple {:?}\", shape);\n     if context.use_block_indent() {\n         // We use the same rule as function calls for rewriting tuples.\n@@ -1999,89 +1990,6 @@ fn rewrite_expr_addrof(\n     rewrite_unary_prefix(context, operator_str, expr, shape)\n }\n \n-pub trait ToExpr {\n-    fn to_expr(&self) -> Option<&ast::Expr>;\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool;\n-}\n-\n-impl ToExpr for ast::Expr {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        Some(self)\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        can_be_overflowed_expr(context, self, len)\n-    }\n-}\n-\n-impl ToExpr for ast::Ty {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        can_be_overflowed_type(context, self, len)\n-    }\n-}\n-\n-impl<'a> ToExpr for TuplePatField<'a> {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        can_be_overflowed_pat(context, self, len)\n-    }\n-}\n-\n-impl<'a> ToExpr for ast::StructField {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, _: &RewriteContext, _: usize) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'a> ToExpr for MacroArg {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        match *self {\n-            MacroArg::Expr(ref expr) => Some(expr),\n-            _ => None,\n-        }\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        match *self {\n-            MacroArg::Expr(ref expr) => can_be_overflowed_expr(context, expr, len),\n-            MacroArg::Ty(ref ty) => can_be_overflowed_type(context, ty, len),\n-            MacroArg::Pat(..) => false,\n-            MacroArg::Item(..) => len == 1,\n-        }\n-    }\n-}\n-\n-impl ToExpr for ast::GenericParam {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, _: &RewriteContext, _: usize) -> bool {\n-        false\n-    }\n-}\n-\n-impl<T: ToExpr> ToExpr for ptr::P<T> {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        (**self).to_expr()\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        (**self).can_be_overflowed(context, len)\n-    }\n-}\n-\n pub fn is_method_call(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::MethodCall(..) => true,"}, {"sha": "37d070cfd40e42fb535c2f8e8b1b3b18c8ba92a0", "filename": "src/overflow.rs", "status": "modified", "additions": 147, "deletions": 35, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/c302409f56d0d08948d5e23d336818553b26a322/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c302409f56d0d08948d5e23d336818553b26a322/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=c302409f56d0d08948d5e23d336818553b26a322", "patch": "@@ -9,38 +9,162 @@\n // except according to those terms.\n \n //! Rewrite a list some items with overflow.\n-// FIXME: Replace `ToExpr` with some enum.\n \n use config::lists::*;\n-use syntax::ast;\n use syntax::parse::token::DelimToken;\n use syntax::source_map::Span;\n+use syntax::{ast, ptr};\n \n use closures;\n-use expr::{is_every_expr_simple, is_method_call, is_nested_call, maybe_get_args_offset, ToExpr};\n+use expr::{\n+    can_be_overflowed_expr, is_every_expr_simple, is_method_call, is_nested_call,\n+    maybe_get_args_offset,\n+};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n+use macros::MacroArg;\n+use patterns::{can_be_overflowed_pat, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use source_map::SpanUtils;\n use spanned::Spanned;\n+use types::{can_be_overflowed_type, SegmentParam};\n use utils::{count_newlines, extra_offset, first_line_width, last_line_width, mk_sp};\n \n use std::cmp::min;\n \n+pub enum OverflowableItem<'a> {\n+    Expr(&'a ast::Expr),\n+    GenericParam(&'a ast::GenericParam),\n+    MacroArg(&'a MacroArg),\n+    SegmentParam(&'a SegmentParam<'a>),\n+    StructField(&'a ast::StructField),\n+    TuplePatField(&'a TuplePatField<'a>),\n+    Ty(&'a ast::Ty),\n+}\n+\n+impl<'a> Rewrite for OverflowableItem<'a> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        self.map(|item| item.rewrite(context, shape))\n+    }\n+}\n+\n+impl<'a> Spanned for OverflowableItem<'a> {\n+    fn span(&self) -> Span {\n+        self.map(|item| item.span())\n+    }\n+}\n+\n+impl<'a> OverflowableItem<'a> {\n+    pub fn map<F, T>(&self, f: F) -> T\n+    where\n+        F: Fn(&IntoOverflowableItem<'a>) -> T,\n+    {\n+        match self {\n+            OverflowableItem::Expr(expr) => f(*expr),\n+            OverflowableItem::GenericParam(gp) => f(*gp),\n+            OverflowableItem::MacroArg(macro_arg) => f(*macro_arg),\n+            OverflowableItem::SegmentParam(sp) => f(*sp),\n+            OverflowableItem::StructField(sf) => f(*sf),\n+            OverflowableItem::TuplePatField(pat) => f(*pat),\n+            OverflowableItem::Ty(ty) => f(*ty),\n+        }\n+    }\n+\n+    pub fn to_expr(&self) -> Option<&'a ast::Expr> {\n+        match self {\n+            OverflowableItem::Expr(expr) => Some(expr),\n+            OverflowableItem::MacroArg(macro_arg) => match macro_arg {\n+                MacroArg::Expr(ref expr) => Some(expr),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        match self {\n+            OverflowableItem::Expr(expr) => can_be_overflowed_expr(context, expr, len),\n+            OverflowableItem::MacroArg(macro_arg) => match macro_arg {\n+                MacroArg::Expr(ref expr) => can_be_overflowed_expr(context, expr, len),\n+                MacroArg::Ty(ref ty) => can_be_overflowed_type(context, ty, len),\n+                MacroArg::Pat(..) => false,\n+                MacroArg::Item(..) => len == 1,\n+            },\n+            OverflowableItem::SegmentParam(seg) => match seg {\n+                SegmentParam::Type(ty) => can_be_overflowed_type(context, ty, len),\n+                _ => false,\n+            },\n+            OverflowableItem::TuplePatField(pat) => can_be_overflowed_pat(context, pat, len),\n+            OverflowableItem::Ty(ty) => can_be_overflowed_type(context, ty, len),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+pub trait IntoOverflowableItem<'a>: Rewrite + Spanned {\n+    fn into_overflowable_item(&'a self) -> OverflowableItem<'a>;\n+}\n+\n+impl<'a, T: 'a + IntoOverflowableItem<'a>> IntoOverflowableItem<'a> for ptr::P<T> {\n+    fn into_overflowable_item(&'a self) -> OverflowableItem<'a> {\n+        (**self).into_overflowable_item()\n+    }\n+}\n+\n+macro impl_into_overflowable_item_for_ast_node {\n+    ($($ast_node:ident),*) => {\n+        $(\n+            impl<'a> IntoOverflowableItem<'a> for ast::$ast_node {\n+                fn into_overflowable_item(&'a self) -> OverflowableItem<'a> {\n+                    OverflowableItem::$ast_node(self)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+macro impl_into_overflowable_item_for_rustfmt_types {\n+    ([$($ty:ident),*], [$($ty_with_lifetime:ident),*]) => {\n+        $(\n+            impl<'a> IntoOverflowableItem<'a> for $ty {\n+                fn into_overflowable_item(&'a self) -> OverflowableItem<'a> {\n+                    OverflowableItem::$ty(self)\n+                }\n+            }\n+        )*\n+        $(\n+            impl<'a> IntoOverflowableItem<'a> for $ty_with_lifetime<'a> {\n+                fn into_overflowable_item(&'a self) -> OverflowableItem<'a> {\n+                    OverflowableItem::$ty_with_lifetime(self)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl_into_overflowable_item_for_ast_node!(Expr, GenericParam, StructField, Ty);\n+impl_into_overflowable_item_for_rustfmt_types!([MacroArg], [SegmentParam, TuplePatField]);\n+\n+pub fn into_overflowable_list<'a, T>(\n+    iter: impl Iterator<Item = &'a T>,\n+) -> impl Iterator<Item = OverflowableItem<'a>>\n+where\n+    T: 'a + IntoOverflowableItem<'a>,\n+{\n+    iter.map(|x| IntoOverflowableItem::into_overflowable_item(x))\n+}\n+\n const SHORT_ITEM_THRESHOLD: usize = 10;\n \n-pub fn rewrite_with_parens<'a, 'b, T: 'a>(\n+pub fn rewrite_with_parens<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext,\n     ident: &'a str,\n     items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n     span: Span,\n     item_max_width: usize,\n     force_separator_tactic: Option<SeparatorTactic>,\n-) -> Option<String>\n-where\n-    T: Rewrite + ToExpr + Spanned,\n-{\n+) -> Option<String> {\n     Context::new(\n         context,\n         items,\n@@ -56,16 +180,13 @@ where\n     .rewrite(shape)\n }\n \n-pub fn rewrite_with_angle_brackets<'a, T: 'a>(\n+pub fn rewrite_with_angle_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext,\n     ident: &'a str,\n     items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n     span: Span,\n-) -> Option<String>\n-where\n-    T: Rewrite + ToExpr + Spanned,\n-{\n+) -> Option<String> {\n     Context::new(\n         context,\n         items,\n@@ -81,18 +202,15 @@ where\n     .rewrite(shape)\n }\n \n-pub fn rewrite_with_square_brackets<'a, T: 'a>(\n+pub fn rewrite_with_square_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext,\n     name: &'a str,\n     items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n     span: Span,\n     force_separator_tactic: Option<SeparatorTactic>,\n     delim_token: Option<DelimToken>,\n-) -> Option<String>\n-where\n-    T: Rewrite + ToExpr + Spanned,\n-{\n+) -> Option<String> {\n     let (lhs, rhs) = match delim_token {\n         Some(DelimToken::Paren) => (\"(\", \")\"),\n         Some(DelimToken::Brace) => (\"{\", \"}\"),\n@@ -113,9 +231,9 @@ where\n     .rewrite(shape)\n }\n \n-struct Context<'a, T: 'a> {\n+struct Context<'a> {\n     context: &'a RewriteContext<'a>,\n-    items: Vec<&'a T>,\n+    items: Vec<OverflowableItem<'a>>,\n     ident: &'a str,\n     prefix: &'static str,\n     suffix: &'static str,\n@@ -128,8 +246,8 @@ struct Context<'a, T: 'a> {\n     custom_delims: Option<(&'a str, &'a str)>,\n }\n \n-impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n-    pub fn new(\n+impl<'a> Context<'a> {\n+    pub fn new<T: 'a + IntoOverflowableItem<'a>>(\n         context: &'a RewriteContext,\n         items: impl Iterator<Item = &'a T>,\n         ident: &'a str,\n@@ -140,7 +258,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         item_max_width: usize,\n         force_separator_tactic: Option<SeparatorTactic>,\n         custom_delims: Option<(&'a str, &'a str)>,\n-    ) -> Context<'a, T> {\n+    ) -> Context<'a> {\n         let used_width = extra_offset(ident, shape);\n         // 1 = `()`\n         let one_line_width = shape.width.saturating_sub(used_width + 2);\n@@ -153,7 +271,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         let nested_shape = shape_from_indent_style(context, shape, used_width + 2, used_width + 1);\n         Context {\n             context,\n-            items: items.collect(),\n+            items: into_overflowable_list(items).collect(),\n             ident,\n             one_line_shape,\n             nested_shape,\n@@ -167,7 +285,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         }\n     }\n \n-    fn last_item(&self) -> Option<&&T> {\n+    fn last_item(&self) -> Option<&OverflowableItem> {\n         self.items.last()\n     }\n \n@@ -465,25 +583,19 @@ fn need_block_indent(s: &str, shape: Shape) -> bool {\n     })\n }\n \n-fn can_be_overflowed<'a, T>(context: &RewriteContext, items: &[&T]) -> bool\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n+fn can_be_overflowed<'a>(context: &RewriteContext, items: &[OverflowableItem]) -> bool {\n     items\n         .last()\n         .map_or(false, |x| x.can_be_overflowed(context, items.len()))\n }\n \n /// Returns a shape for the last argument which is going to be overflowed.\n-fn last_item_shape<T>(\n-    lists: &[&T],\n+fn last_item_shape(\n+    lists: &[OverflowableItem],\n     items: &[ListItem],\n     shape: Shape,\n     args_max_width: usize,\n-) -> Option<Shape>\n-where\n-    T: Rewrite + Spanned + ToExpr,\n-{\n+) -> Option<Shape> {\n     let is_nested_call = lists\n         .iter()\n         .next()"}, {"sha": "e7282c13317ed0faecc1d7198fc14fb54545fb74", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c302409f56d0d08948d5e23d336818553b26a322/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c302409f56d0d08948d5e23d336818553b26a322/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=c302409f56d0d08948d5e23d336818553b26a322", "patch": "@@ -17,7 +17,7 @@ use syntax::source_map::{self, BytePos, Span};\n use syntax::symbol::keywords;\n \n use config::{IndentStyle, TypeDensity};\n-use expr::{rewrite_assign_rhs, rewrite_tuple, rewrite_unary_prefix, ToExpr};\n+use expr::{rewrite_assign_rhs, rewrite_tuple, rewrite_unary_prefix};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n use macros::{rewrite_macro, MacroPosition};\n use overflow;\n@@ -141,7 +141,7 @@ where\n }\n \n #[derive(Debug)]\n-enum SegmentParam<'a> {\n+pub enum SegmentParam<'a> {\n     LifeTime(&'a ast::Lifetime),\n     Type(&'a ast::Ty),\n     Binding(&'a ast::TypeBinding),\n@@ -166,19 +166,6 @@ impl<'a> Spanned for SegmentParam<'a> {\n     }\n }\n \n-impl<'a> ToExpr for SegmentParam<'a> {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        match *self {\n-            SegmentParam::Type(ty) => ty.can_be_overflowed(context, len),\n-            _ => false,\n-        }\n-    }\n-}\n-\n impl<'a> Rewrite for SegmentParam<'a> {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match *self {"}]}