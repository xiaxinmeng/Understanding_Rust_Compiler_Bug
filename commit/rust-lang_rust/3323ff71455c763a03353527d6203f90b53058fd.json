{"sha": "3323ff71455c763a03353527d6203f90b53058fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMjNmZjcxNDU1Yzc2M2EwMzM1MzUyN2Q2MjAzZjkwYjUzMDU4ZmQ=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-25T13:47:56Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-15T12:22:40Z"}, "message": "`map_entry` improvements\nSuggest using `or_insert_with` when possible", "tree": {"sha": "59bad15d8d283ea6861d5828e027ced23b0180df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59bad15d8d283ea6861d5828e027ced23b0180df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3323ff71455c763a03353527d6203f90b53058fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmB4MBYACgkQ2lnoZDo37QblGgD/b1g9M48p2Su5VwqY7zkJ2Zjn\nFvw2KsGZXc7/TdBDV00A/35V2ixqXzE945A1fblC3WC+wtOJ1An0cgEJHqzIR/cJ\n=CrhD\n-----END PGP SIGNATURE-----", "payload": "tree 59bad15d8d283ea6861d5828e027ced23b0180df\nparent b63a5b56d6a37029970445ab5cbb77aeb5e19e84\nauthor Jason Newcomb <jsnewcomb@pm.me> 1616680076 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1618489360 -0400\n\n`map_entry` improvements\nSuggest using `or_insert_with` when possible\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3323ff71455c763a03353527d6203f90b53058fd", "html_url": "https://github.com/rust-lang/rust/commit/3323ff71455c763a03353527d6203f90b53058fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3323ff71455c763a03353527d6203f90b53058fd/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "url": "https://api.github.com/repos/rust-lang/rust/commits/b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "html_url": "https://github.com/rust-lang/rust/commit/b63a5b56d6a37029970445ab5cbb77aeb5e19e84"}], "stats": {"total": 469, "additions": 322, "deletions": 147}, "files": [{"sha": "0decb22a4914d328f44023d10334d36e506f6900", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 173, "deletions": 47, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/3323ff71455c763a03353527d6203f90b53058fd/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3323ff71455c763a03353527d6203f90b53058fd/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=3323ff71455c763a03353527d6203f90b53058fd", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::{\n+    can_move_expr_to_closure_no_visit,\n     diagnostics::span_lint_and_sugg,\n     is_expr_final_block_expr, is_expr_used_or_unified, match_def_path, paths, peel_hir_expr_while,\n     source::{reindent_multiline, snippet_indent, snippet_with_applicability, snippet_with_context},\n@@ -7,7 +8,7 @@ use clippy_utils::{\n use rustc_errors::Applicability;\n use rustc_hir::{\n     intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-    Expr, ExprKind, Guard, Local, Stmt, StmtKind, UnOp,\n+    Block, Expr, ExprKind, Guard, HirId, Local, Stmt, StmtKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -78,13 +79,13 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n         let sugg = if let Some(else_expr) = else_expr {\n             // if .. { .. } else { .. }\n             let else_search = match find_insert_calls(cx, &contains_expr, else_expr) {\n-                Some(search) if !(then_search.insertions.is_empty() && search.insertions.is_empty()) => search,\n+                Some(search) if !(then_search.edits.is_empty() && search.edits.is_empty()) => search,\n                 _ => return,\n             };\n \n-            if then_search.insertions.is_empty() || else_search.insertions.is_empty() {\n+            if then_search.edits.is_empty() || else_search.edits.is_empty() {\n                 // if .. { insert } else { .. } or if .. { .. } else { then } of\n-                let (then_str, else_str, entry_kind) = if else_search.insertions.is_empty() {\n+                let (then_str, else_str, entry_kind) = if else_search.edits.is_empty() {\n                     if contains_expr.negated {\n                         (\n                             then_search.snippet_vacant(cx, then_expr.span, &mut app),\n@@ -152,37 +153,48 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n                     indent = indent_str,\n                 )\n             }\n-        } else if then_search.insertions.is_empty() || !contains_expr.negated {\n+        } else if then_search.edits.is_empty() {\n+            // no insertions\n             return;\n         } else {\n             // if .. { insert }\n-            match then_search.as_single_insertion() {\n-                Some(insertion) if !insertion.value.can_have_side_effects() => {\n-                    format!(\n-                        \"{}.entry({}).or_insert({});\",\n-                        map_str,\n-                        key_str,\n-                        snippet_with_context(cx, insertion.value.span, insertion.call.span.ctxt(), \"..\", &mut app).0,\n+            if !then_search.allow_insert_closure {\n+                let (body_str, entry_kind) = if contains_expr.negated {\n+                    (then_search.snippet_vacant(cx, then_expr.span, &mut app), \"Vacant(e)\")\n+                } else {\n+                    (\n+                        then_search.snippet_occupied(cx, then_expr.span, &mut app),\n+                        \"Occupied(mut e)\",\n                     )\n-                },\n-                _ => {\n-                    let (body_str, entry_kind) = if contains_expr.negated {\n-                        (then_search.snippet_vacant(cx, then_expr.span, &mut app), \"Vacant(e)\")\n+                };\n+                format!(\n+                    \"if let {}::{} = {}.entry({}) {}\",\n+                    map_ty.entry_path(),\n+                    entry_kind,\n+                    map_str,\n+                    key_str,\n+                    body_str,\n+                )\n+            } else if let Some(insertion) = then_search.as_single_insertion() {\n+                let value_str = snippet_with_context(cx, insertion.value.span, then_expr.span.ctxt(), \"..\", &mut app).0;\n+                if contains_expr.negated {\n+                    if insertion.value.can_have_side_effects() {\n+                        format!(\"{}.entry({}).or_insert_with(|| {});\", map_str, key_str, value_str)\n                     } else {\n-                        (\n-                            then_search.snippet_occupied(cx, then_expr.span, &mut app),\n-                            \"Occupied(mut e)\",\n-                        )\n-                    };\n-                    format!(\n-                        \"if let {}::{} = {}.entry({}) {}\",\n-                        map_ty.entry_path(),\n-                        entry_kind,\n-                        map_str,\n-                        key_str,\n-                        body_str,\n-                    )\n-                },\n+                        format!(\"{}.entry({}).or_insert({});\", map_str, key_str, value_str)\n+                    }\n+                } else {\n+                    // Todo: if let Some(v) = map.get_mut(k)\n+                    return;\n+                }\n+            } else {\n+                let block_str = then_search.snippet_closure(cx, then_expr.span, &mut app);\n+                if contains_expr.negated {\n+                    format!(\"{}.entry({}).or_insert_with(|| {});\", map_str, key_str, block_str)\n+                } else {\n+                    // Todo: if let Some(v) = map.get_mut(k)\n+                    return;\n+                }\n             }\n         };\n \n@@ -281,6 +293,19 @@ fn try_parse_insert(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Inse\n     }\n }\n \n+/// An edit that will need to be made to move the expression to use the entry api\n+#[derive(Clone, Copy)]\n+enum Edit<'tcx> {\n+    /// A semicolon that needs to be removed. Used to create a closure for `insert_with`.\n+    RemoveSemi(Span),\n+    /// An insertion into the map.\n+    Insertion(Insertion<'tcx>),\n+}\n+impl Edit<'tcx> {\n+    fn as_insertion(self) -> Option<Insertion<'tcx>> {\n+        if let Self::Insertion(i) = self { Some(i) } else { None }\n+    }\n+}\n #[derive(Clone, Copy)]\n struct Insertion<'tcx> {\n     call: &'tcx Expr<'tcx>,\n@@ -303,24 +328,40 @@ struct InsertSearcher<'cx, 'i, 'tcx> {\n     key: &'tcx Expr<'tcx>,\n     /// The context of the top level block. All insert calls must be in the same context.\n     ctxt: SyntaxContext,\n+    /// Whether this expression can be safely moved into a closure.\n+    allow_insert_closure: bool,\n     /// Whether this expression can use the entry api.\n     can_use_entry: bool,\n+    /// Whether this expression is the final expression in this code path. This may be a statement.\n+    in_tail_pos: bool,\n     // A single insert expression has a slightly different suggestion.\n     is_single_insert: bool,\n     is_map_used: bool,\n-    insertions: &'i mut Vec<Insertion<'tcx>>,\n+    edits: &'i mut Vec<Edit<'tcx>>,\n+    loops: Vec<HirId>,\n }\n impl<'tcx> InsertSearcher<'_, '_, 'tcx> {\n     /// Visit the expression as a branch in control flow. Multiple insert calls can be used, but\n     /// only if they are on separate code paths. This will return whether the map was used in the\n     /// given expression.\n     fn visit_cond_arm(&mut self, e: &'tcx Expr<'_>) -> bool {\n         let is_map_used = self.is_map_used;\n+        let in_tail_pos = self.in_tail_pos;\n         self.visit_expr(e);\n         let res = self.is_map_used;\n         self.is_map_used = is_map_used;\n+        self.in_tail_pos = in_tail_pos;\n         res\n     }\n+\n+    /// Visits an expression which is not itself in a tail position, but other sibling expressions\n+    /// may be. e.g. if conditions\n+    fn visit_non_tail_expr(&mut self, e: &'tcx Expr<'_>) {\n+        let in_tail_pos = self.in_tail_pos;\n+        self.in_tail_pos = false;\n+        self.visit_expr(e);\n+        self.in_tail_pos = in_tail_pos;\n+    }\n }\n impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, '_, 'tcx> {\n     type Map = ErasedMap<'tcx>;\n@@ -330,17 +371,63 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, '_, 'tcx> {\n \n     fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         match stmt.kind {\n-            StmtKind::Semi(e) | StmtKind::Expr(e) => self.visit_expr(e),\n+            StmtKind::Semi(e) => {\n+                self.visit_expr(e);\n+\n+                if self.in_tail_pos && self.allow_insert_closure {\n+                    // The spans are used to slice the top level expression into multiple parts. This requires that\n+                    // they all come from the same part of the source code.\n+                    if stmt.span.ctxt() == self.ctxt && e.span.ctxt() == self.ctxt {\n+                        self.edits\n+                            .push(Edit::RemoveSemi(stmt.span.trim_start(e.span).unwrap_or(DUMMY_SP)));\n+                    } else {\n+                        self.allow_insert_closure = false;\n+                    }\n+                }\n+            },\n+            StmtKind::Expr(e) => self.visit_expr(e),\n             StmtKind::Local(Local { init: Some(e), .. }) => {\n+                self.allow_insert_closure &= !self.in_tail_pos;\n+                self.in_tail_pos = false;\n                 self.is_single_insert = false;\n                 self.visit_expr(e);\n             },\n             _ => {\n+                self.allow_insert_closure &= !self.in_tail_pos;\n                 self.is_single_insert = false;\n             },\n         }\n     }\n \n+    fn visit_block(&mut self, block: &'tcx Block<'_>) {\n+        // If the block is in a tail position, then the last expression (possibly a statement) is in the\n+        // tail position. The rest, however, are not.\n+        match (block.stmts, block.expr) {\n+            ([], None) => {\n+                self.allow_insert_closure &= !self.in_tail_pos;\n+            },\n+            ([], Some(expr)) => self.visit_expr(expr),\n+            (stmts, Some(expr)) => {\n+                let in_tail_pos = self.in_tail_pos;\n+                self.in_tail_pos = false;\n+                for stmt in stmts {\n+                    self.visit_stmt(stmt);\n+                }\n+                self.in_tail_pos = in_tail_pos;\n+                self.visit_expr(expr);\n+            },\n+            ([stmts @ .., stmt], None) => {\n+                let in_tail_pos = self.in_tail_pos;\n+                self.in_tail_pos = false;\n+                for stmt in stmts {\n+                    self.visit_stmt(stmt);\n+                }\n+                self.in_tail_pos = in_tail_pos;\n+                self.visit_stmt(stmt);\n+            },\n+        }\n+    }\n+\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if !self.can_use_entry {\n             return;\n@@ -357,15 +444,16 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, '_, 'tcx> {\n                     return;\n                 }\n \n-                self.insertions.push(Insertion {\n+                self.edits.push(Edit::Insertion(Insertion {\n                     call: expr,\n                     value: insert_expr.value,\n-                });\n+                }));\n                 self.is_map_used = true;\n+                self.allow_insert_closure &= self.in_tail_pos;\n \n                 // The value doesn't affect whether there is only a single insert expression.\n                 let is_single_insert = self.is_single_insert;\n-                self.visit_expr(insert_expr.value);\n+                self.visit_non_tail_expr(insert_expr.value);\n                 self.is_single_insert = is_single_insert;\n             },\n             _ if SpanlessEq::new(self.cx).eq_expr(self.map, expr) => {\n@@ -374,39 +462,46 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, '_, 'tcx> {\n             _ => match expr.kind {\n                 ExprKind::If(cond_expr, then_expr, Some(else_expr)) => {\n                     self.is_single_insert = false;\n-                    self.visit_expr(cond_expr);\n+                    self.visit_non_tail_expr(cond_expr);\n                     // Each branch may contain it's own insert expression.\n                     let mut is_map_used = self.visit_cond_arm(then_expr);\n                     is_map_used |= self.visit_cond_arm(else_expr);\n                     self.is_map_used = is_map_used;\n                 },\n                 ExprKind::Match(scrutinee_expr, arms, _) => {\n                     self.is_single_insert = false;\n-                    self.visit_expr(scrutinee_expr);\n+                    self.visit_non_tail_expr(scrutinee_expr);\n                     // Each branch may contain it's own insert expression.\n                     let mut is_map_used = self.is_map_used;\n                     for arm in arms {\n                         if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n-                            self.visit_expr(guard)\n+                            self.visit_non_tail_expr(guard)\n                         }\n                         is_map_used |= self.visit_cond_arm(arm.body);\n                     }\n                     self.is_map_used = is_map_used;\n                 },\n                 ExprKind::Loop(block, ..) => {\n+                    self.loops.push(expr.hir_id);\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n                     // Don't allow insertions inside of a loop.\n-                    let insertions_len = self.insertions.len();\n+                    let edit_len = self.edits.len();\n                     self.visit_block(block);\n-                    if self.insertions.len() != insertions_len {\n+                    if self.edits.len() != edit_len {\n                         self.can_use_entry = false;\n                     }\n+                    self.loops.pop();\n                 },\n                 ExprKind::Block(block, _) => self.visit_block(block),\n                 ExprKind::InlineAsm(_) | ExprKind::LlvmInlineAsm(_) => {\n                     self.can_use_entry = false;\n                 },\n                 _ => {\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n+                    self.allow_insert_closure &= can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops);\n+                    // Sub expressions are no longer in the tail position.\n                     self.is_single_insert = false;\n+                    self.in_tail_pos = false;\n                     walk_expr(self, expr);\n                 },\n             },\n@@ -415,18 +510,19 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, '_, 'tcx> {\n }\n \n struct InsertSearchResults<'tcx> {\n-    insertions: Vec<Insertion<'tcx>>,\n+    edits: Vec<Edit<'tcx>>,\n+    allow_insert_closure: bool,\n     is_single_insert: bool,\n }\n impl InsertSearchResults<'tcx> {\n     fn as_single_insertion(&self) -> Option<Insertion<'tcx>> {\n-        self.is_single_insert.then(|| self.insertions[0])\n+        self.is_single_insert.then(|| self.edits[0].as_insertion().unwrap())\n     }\n \n     fn snippet_occupied(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n         let ctxt = span.ctxt();\n         let mut res = String::new();\n-        for insertion in self.insertions.iter() {\n+        for insertion in self.edits.iter().filter_map(|e| e.as_insertion()) {\n             res.push_str(&snippet_with_applicability(\n                 cx,\n                 span.until(insertion.call.span),\n@@ -451,7 +547,7 @@ impl InsertSearchResults<'tcx> {\n     fn snippet_vacant(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n         let ctxt = span.ctxt();\n         let mut res = String::new();\n-        for insertion in self.insertions.iter() {\n+        for insertion in self.edits.iter().filter_map(|e| e.as_insertion()) {\n             res.push_str(&snippet_with_applicability(\n                 cx,\n                 span.until(insertion.call.span),\n@@ -485,27 +581,57 @@ impl InsertSearchResults<'tcx> {\n         res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n         res\n     }\n+\n+    fn snippet_closure(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n+        let ctxt = span.ctxt();\n+        let mut res = String::new();\n+        for edit in &self.edits {\n+            match *edit {\n+                Edit::Insertion(insertion) => {\n+                    res.push_str(&snippet_with_applicability(\n+                        cx,\n+                        span.until(insertion.call.span),\n+                        \"..\",\n+                        app,\n+                    ));\n+                    res.push_str(&snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0);\n+                    span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n+                },\n+                Edit::RemoveSemi(semi_span) => {\n+                    res.push_str(&snippet_with_applicability(cx, span.until(semi_span), \"..\", app));\n+                    span = span.trim_start(semi_span).unwrap_or(DUMMY_SP);\n+                },\n+            }\n+        }\n+        res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n+        res\n+    }\n }\n fn find_insert_calls(\n     cx: &LateContext<'tcx>,\n     contains_expr: &ContainsExpr<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<InsertSearchResults<'tcx>> {\n-    let mut insertions = Vec::new();\n+    let mut edits = Vec::new();\n     let mut s = InsertSearcher {\n         cx,\n         map: contains_expr.map,\n         key: contains_expr.key,\n         ctxt: expr.span.ctxt(),\n-        insertions: &mut insertions,\n+        edits: &mut edits,\n         is_map_used: false,\n+        allow_insert_closure: true,\n         can_use_entry: true,\n+        in_tail_pos: true,\n         is_single_insert: true,\n+        loops: Vec::new(),\n     };\n     s.visit_expr(expr);\n+    let allow_insert_closure = s.allow_insert_closure;\n     let is_single_insert = s.is_single_insert;\n     s.can_use_entry.then(|| InsertSearchResults {\n-        insertions,\n+        edits,\n+        allow_insert_closure,\n         is_single_insert,\n     })\n }"}, {"sha": "3f8b976fcac0642d4d720e33f7cbbcdc46316d0a", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3323ff71455c763a03353527d6203f90b53058fd/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3323ff71455c763a03353527d6203f90b53058fd/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=3323ff71455c763a03353527d6203f90b53058fd", "patch": "@@ -1,15 +1,13 @@\n use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{can_partially_move_ty, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n-use clippy_utils::{in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs};\n+use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n+use clippy_utils::{can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n-    def::Res,\n-    intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-    Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind, Path, QPath,\n+    Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind, QPath,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -193,51 +191,6 @@ impl LateLintPass<'_> for ManualMap {\n     }\n }\n \n-// Checks if the expression can be moved into a closure as is.\n-fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    struct V<'cx, 'tcx> {\n-        cx: &'cx LateContext<'tcx>,\n-        make_closure: bool,\n-    }\n-    impl Visitor<'tcx> for V<'_, 'tcx> {\n-        type Map = ErasedMap<'tcx>;\n-        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-            NestedVisitorMap::None\n-        }\n-\n-        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-            match e.kind {\n-                ExprKind::Break(..)\n-                | ExprKind::Continue(_)\n-                | ExprKind::Ret(_)\n-                | ExprKind::Yield(..)\n-                | ExprKind::InlineAsm(_)\n-                | ExprKind::LlvmInlineAsm(_) => {\n-                    self.make_closure = false;\n-                },\n-                // Accessing a field of a local value can only be done if the type isn't\n-                // partially moved.\n-                ExprKind::Field(base_expr, _)\n-                    if matches!(\n-                        base_expr.kind,\n-                        ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n-                    ) && can_partially_move_ty(self.cx, self.cx.typeck_results().expr_ty(base_expr)) =>\n-                {\n-                    // TODO: check if the local has been partially moved. Assume it has for now.\n-                    self.make_closure = false;\n-                    return;\n-                }\n-                _ => (),\n-            };\n-            walk_expr(self, e);\n-        }\n-    }\n-\n-    let mut v = V { cx, make_closure: true };\n-    v.visit_expr(expr);\n-    v.make_closure\n-}\n-\n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {"}, {"sha": "5d6c1337be6a2d33df4f3b544e67359e2842ac5e", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3323ff71455c763a03353527d6203f90b53058fd/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3323ff71455c763a03353527d6203f90b53058fd/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=3323ff71455c763a03353527d6203f90b53058fd", "patch": "@@ -60,7 +60,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n@@ -82,7 +82,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::is_recursively_primitive_type;\n+use crate::ty::{can_partially_move_ty, is_recursively_primitive_type};\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -539,6 +539,73 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     None\n }\n \n+/// Checks if the top level expression can be moved into a closure as is.\n+pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n+    match expr.kind {\n+        ExprKind::Break(Destination { target_id: Ok(id), .. }, _)\n+        | ExprKind::Continue(Destination { target_id: Ok(id), .. })\n+            if jump_targets.contains(&id) =>\n+        {\n+            true\n+        },\n+        ExprKind::Break(..)\n+        | ExprKind::Continue(_)\n+        | ExprKind::Ret(_)\n+        | ExprKind::Yield(..)\n+        | ExprKind::InlineAsm(_)\n+        | ExprKind::LlvmInlineAsm(_) => false,\n+        // Accessing a field of a local value can only be done if the type isn't\n+        // partially moved.\n+        ExprKind::Field(base_expr, _)\n+            if matches!(\n+                base_expr.kind,\n+                ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n+            ) && can_partially_move_ty(cx, cx.typeck_results().expr_ty(base_expr)) =>\n+        {\n+            // TODO: check if the local has been partially moved. Assume it has for now.\n+            false\n+        }\n+        _ => true,\n+    }\n+}\n+\n+/// Checks if the expression can be moved into a closure as is.\n+pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        loops: Vec<HirId>,\n+        allow_closure: bool,\n+    }\n+    impl Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if !self.allow_closure {\n+                return;\n+            }\n+            if let ExprKind::Loop(b, ..) = e.kind {\n+                self.loops.push(e.hir_id);\n+                self.visit_block(b);\n+                self.loops.pop();\n+            } else {\n+                self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops);\n+                walk_expr(self, e);\n+            }\n+        }\n+    }\n+\n+    let mut v = V {\n+        cx,\n+        allow_closure: true,\n+        loops: Vec::new(),\n+    };\n+    v.visit_expr(expr);\n+    v.allow_closure\n+}\n+\n /// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`. method/span lists are sorted with the most recent call first.\n pub fn method_calls<'tcx>("}, {"sha": "524f2132797e6a76bcc858eefdd76dc70459e744", "filename": "tests/ui/entry.fixed", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3323ff71455c763a03353527d6203f90b53058fd/tests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3323ff71455c763a03353527d6203f90b53058fd/tests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.fixed?ref=3323ff71455c763a03353527d6203f90b53058fd", "patch": "@@ -15,13 +15,21 @@ fn foo() {}\n fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n     m.entry(k).or_insert(v);\n \n-    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+    m.entry(k).or_insert_with(|| {\n         if true {\n-            e.insert(v);\n+            v\n         } else {\n-            e.insert(v2);\n+            v2\n         }\n-    }\n+    });\n+\n+    m.entry(k).or_insert_with(|| {\n+        if true {\n+            v\n+        } else {\n+            v2\n+        }\n+    });\n \n     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n         if true {\n@@ -32,21 +40,21 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     }\n \n-    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+    m.entry(k).or_insert_with(|| {\n         foo();\n-        e.insert(v);\n-    }\n+        v\n+    });\n \n-    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+    m.entry(k).or_insert_with(|| {\n         match 0 {\n             1 if true => {\n-                e.insert(v);\n+                v\n             },\n             _ => {\n-                e.insert(v2);\n+                v2\n             },\n-        };\n-    }\n+        }\n+    });\n \n     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n         match 0 {\n@@ -60,35 +68,33 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         };\n     }\n \n-    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+    m.entry(k).or_insert_with(|| {\n         foo();\n         match 0 {\n             0 if false => {\n-                e.insert(v);\n+                v\n             },\n             1 => {\n                 foo();\n-                e.insert(v);\n+                v\n             },\n             2 | 3 => {\n                 for _ in 0..2 {\n                     foo();\n                 }\n                 if true {\n-                    e.insert(v);\n+                    v\n                 } else {\n-                    e.insert(v2);\n-                };\n+                    v2\n+                }\n             },\n             _ => {\n-                e.insert(v2);\n+                v2\n             },\n         }\n-    }\n+    });\n \n-    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(m!(k)) {\n-        e.insert(m!(v));\n-    }\n+    m.entry(m!(k)).or_insert_with(|| m!(v));\n }\n \n fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {"}, {"sha": "ff4890eeeb639a9e81bb7fa59d32c5372c22268c", "filename": "tests/ui/entry.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3323ff71455c763a03353527d6203f90b53058fd/tests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3323ff71455c763a03353527d6203f90b53058fd/tests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.rs?ref=3323ff71455c763a03353527d6203f90b53058fd", "patch": "@@ -25,6 +25,14 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     }\n \n+    if !m.contains_key(&k) {\n+        if true {\n+            m.insert(k, v)\n+        } else {\n+            m.insert(k, v2)\n+        };\n+    }\n+\n     if !m.contains_key(&k) {\n         if true {\n             m.insert(k, v);"}, {"sha": "63b5f5a0b2cf76cac3d1dcdcffaf09205f85331f", "filename": "tests/ui/entry.stderr", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3323ff71455c763a03353527d6203f90b53058fd/tests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3323ff71455c763a03353527d6203f90b53058fd/tests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.stderr?ref=3323ff71455c763a03353527d6203f90b53058fd", "patch": "@@ -22,11 +22,11 @@ LL | |     }\n    |\n help: try this\n    |\n-LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |     m.entry(k).or_insert_with(|| {\n LL |         if true {\n-LL |             e.insert(v);\n+LL |             v\n LL |         } else {\n-LL |             e.insert(v2);\n+LL |             v2\n LL |         }\n  ...\n \n@@ -35,6 +35,28 @@ error: usage of `contains_key` followed by `insert` on a `HashMap`\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         if true {\n+LL | |             m.insert(k, v)\n+LL | |         } else {\n+LL | |             m.insert(k, v2)\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     m.entry(k).or_insert_with(|| {\n+LL |         if true {\n+LL |             v\n+LL |         } else {\n+LL |             v2\n+LL |         }\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:36:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         if true {\n LL | |             m.insert(k, v);\n LL | |         } else {\n ...  |\n@@ -53,7 +75,7 @@ LL |             return;\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:37:5\n+  --> $DIR/entry.rs:45:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         foo();\n@@ -63,14 +85,14 @@ LL | |     }\n    |\n help: try this\n    |\n-LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |     m.entry(k).or_insert_with(|| {\n LL |         foo();\n-LL |         e.insert(v);\n-LL |     }\n+LL |         v\n+LL |     });\n    |\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:42:5\n+  --> $DIR/entry.rs:50:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         match 0 {\n@@ -83,16 +105,16 @@ LL | |     }\n    |\n help: try this\n    |\n-LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |     m.entry(k).or_insert_with(|| {\n LL |         match 0 {\n LL |             1 if true => {\n-LL |                 e.insert(v);\n+LL |                 v\n LL |             },\n LL |             _ => {\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:53:5\n+  --> $DIR/entry.rs:61:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         match 0 {\n@@ -114,7 +136,7 @@ LL |             },\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:65:5\n+  --> $DIR/entry.rs:73:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         foo();\n@@ -127,31 +149,24 @@ LL | |     }\n    |\n help: try this\n    |\n-LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |     m.entry(k).or_insert_with(|| {\n LL |         foo();\n LL |         match 0 {\n LL |             0 if false => {\n-LL |                 e.insert(v);\n+LL |                 v\n LL |             },\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:91:5\n+  --> $DIR/entry.rs:99:5\n    |\n LL | /     if !m.contains_key(&m!(k)) {\n LL | |         m.insert(m!(k), m!(v));\n LL | |     }\n-   | |_____^\n-   |\n-help: try this\n-   |\n-LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(m!(k)) {\n-LL |         e.insert(m!(v));\n-LL |     }\n-   |\n+   | |_____^ help: try this: `m.entry(m!(k)).or_insert_with(|| m!(v));`\n \n error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n-  --> $DIR/entry.rs:97:5\n+  --> $DIR/entry.rs:105:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         m.insert(k, v);\n@@ -167,5 +182,5 @@ LL |         foo();\n LL |     }\n    |\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n "}]}