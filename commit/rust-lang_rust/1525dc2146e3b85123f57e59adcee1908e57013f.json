{"sha": "1525dc2146e3b85123f57e59adcee1908e57013f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MjVkYzIxNDZlM2I4NTEyM2Y1N2U1OWFkY2VlMTkwOGU1NzAxM2Y=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-26T19:40:05Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-23T20:35:21Z"}, "message": "rustc: dissuade compiler developers from misusing upvar debuginfo.", "tree": {"sha": "49733b00e4e0192f9fa4b76b2d9d66a75cb496e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49733b00e4e0192f9fa4b76b2d9d66a75cb496e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1525dc2146e3b85123f57e59adcee1908e57013f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1525dc2146e3b85123f57e59adcee1908e57013f", "html_url": "https://github.com/rust-lang/rust/commit/1525dc2146e3b85123f57e59adcee1908e57013f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1525dc2146e3b85123f57e59adcee1908e57013f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6ec968485080a704a4edc1e96c89359bd81550d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ec968485080a704a4edc1e96c89359bd81550d", "html_url": "https://github.com/rust-lang/rust/commit/e6ec968485080a704a4edc1e96c89359bd81550d"}], "stats": {"total": 53, "additions": 29, "deletions": 24}, "files": [{"sha": "bf2a1eaafd664fad79ba942d98cac64b8fcb715c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1525dc2146e3b85123f57e59adcee1908e57013f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1525dc2146e3b85123f57e59adcee1908e57013f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=1525dc2146e3b85123f57e59adcee1908e57013f", "patch": "@@ -146,7 +146,11 @@ pub struct Mir<'tcx> {\n \n     /// Names and capture modes of all the closure upvars, assuming\n     /// the first argument is either the closure or a reference to it.\n-    pub upvar_decls: Vec<UpvarDecl>,\n+    // NOTE(eddyb) This is *strictly* a temporary hack for codegen\n+    // debuginfo generation, and will be removed at some point.\n+    // Do **NOT** use it for anything else, upvar information should not be\n+    // in the MIR, please rely on local crate HIR or other side-channels.\n+    pub __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n \n     /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n     /// `||` expression into `&` or `|` respectively. This is problematic because if we ever stop\n@@ -173,7 +177,7 @@ impl<'tcx> Mir<'tcx> {\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n-        upvar_decls: Vec<UpvarDecl>,\n+        __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n     ) -> Self {\n@@ -197,7 +201,7 @@ impl<'tcx> Mir<'tcx> {\n             local_decls,\n             user_type_annotations,\n             arg_count,\n-            upvar_decls,\n+            __upvar_debuginfo_codegen_only_do_not_use,\n             spread_arg: None,\n             span,\n             cache: cache::Cache::new(),\n@@ -431,7 +435,7 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     local_decls,\n     user_type_annotations,\n     arg_count,\n-    upvar_decls,\n+    __upvar_debuginfo_codegen_only_do_not_use,\n     spread_arg,\n     control_flow_destroyed,\n     span,\n@@ -983,7 +987,7 @@ impl<'tcx> LocalDecl<'tcx> {\n \n /// A closure capture, with its name and mode.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UpvarDecl {\n+pub struct UpvarDebuginfo {\n     pub debug_name: Name,\n \n     /// If true, the capture is behind a reference.\n@@ -3151,7 +3155,7 @@ CloneTypeFoldableAndLiftImpls! {\n     MirPhase,\n     Mutability,\n     SourceInfo,\n-    UpvarDecl,\n+    UpvarDebuginfo,\n     FakeReadCause,\n     RetagKind,\n     SourceScope,\n@@ -3173,7 +3177,7 @@ BraceStructTypeFoldableImpl! {\n         local_decls,\n         user_type_annotations,\n         arg_count,\n-        upvar_decls,\n+        __upvar_debuginfo_codegen_only_do_not_use,\n         spread_arg,\n         control_flow_destroyed,\n         span,"}, {"sha": "621c4e5d4488e77dc49e047220a182bb7d2c6002", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1525dc2146e3b85123f57e59adcee1908e57013f/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1525dc2146e3b85123f57e59adcee1908e57013f/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=1525dc2146e3b85123f57e59adcee1908e57013f", "patch": "@@ -598,9 +598,10 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                 tmp\n             }\n         };\n+        let upvar_debuginfo = &mir.__upvar_debuginfo_codegen_only_do_not_use;\n         arg_scope.map(|scope| {\n             // Is this a regular argument?\n-            if arg_index > 0 || mir.upvar_decls.is_empty() {\n+            if arg_index > 0 || upvar_debuginfo.is_empty() {\n                 // The Rust ABI passes indirect variables using a pointer and a manual copy, so we\n                 // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n                 // byval attribute, for which LLVM always does the deref itself,\n@@ -638,16 +639,16 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             let (def_id, upvar_substs) = match closure_layout.ty.sty {\n                 ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n                 ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-                _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_layout.ty)\n+                _ => bug!(\"upvar debuginfo with non-closure arg0 type `{}`\", closure_layout.ty)\n             };\n             let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n \n             let extra_locals = {\n-                let upvars = mir.upvar_decls\n+                let upvars = upvar_debuginfo\n                     .iter()\n                     .zip(upvar_tys)\n                     .enumerate()\n-                    .map(|(i, (decl, ty))| (i, decl.debug_name, decl.by_ref, ty));\n+                    .map(|(i, (upvar, ty))| (i, upvar.debug_name, upvar.by_ref, ty));\n \n                 let generator_fields = mir.generator_layout.as_ref().map(|generator_layout| {\n                     let (def_id, gen_substs) = match closure_layout.ty.sty {\n@@ -656,7 +657,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                     };\n                     let state_tys = gen_substs.state_tys(def_id, tcx);\n \n-                    let upvar_count = mir.upvar_decls.len();\n+                    let upvar_count = upvar_debuginfo.len();\n                     generator_layout.fields\n                         .iter()\n                         .zip(state_tys)"}, {"sha": "79e1d5daae1942ed92cb515eb1fcd5684da31287", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1525dc2146e3b85123f57e59adcee1908e57013f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1525dc2146e3b85123f57e59adcee1908e57013f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1525dc2146e3b85123f57e59adcee1908e57013f", "patch": "@@ -375,7 +375,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     var_indices: HirIdMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n-    upvar_decls: Vec<UpvarDecl>,\n+    __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n     upvar_mutbls: Vec<Mutability>,\n     unit_temp: Option<Place<'tcx>>,\n \n@@ -631,7 +631,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     // closure and we stored in a map called upvar_list in TypeckTables indexed\n     // with the closure's DefId. Here, we run through that vec of UpvarIds for\n     // the given closure and use the necessary information to create UpvarDecl.\n-    let upvar_decls: Vec<_> = hir_tables\n+    let upvar_debuginfo: Vec<_> = hir_tables\n         .upvar_list\n         .get(&fn_def_id)\n         .into_iter()\n@@ -644,14 +644,14 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 ty::UpvarCapture::ByValue => false,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n-            let mut decl = UpvarDecl {\n+            let mut debuginfo = UpvarDebuginfo {\n                 debug_name: keywords::Invalid.name(),\n                 by_ref,\n             };\n             let mut mutability = Mutability::Not;\n             if let Some(Node::Binding(pat)) = tcx_hir.find(var_node_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n-                    decl.debug_name = ident.name;\n+                    debuginfo.debug_name = ident.name;\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n                         if bm == ty::BindByValue(hir::MutMutable) {\n                             mutability = Mutability::Mut;\n@@ -664,7 +664,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 }\n             }\n             upvar_mutbls.push(mutability);\n-            decl\n+            debuginfo\n         })\n         .collect();\n \n@@ -674,7 +674,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         safety,\n         return_ty,\n         return_ty_span,\n-        upvar_decls,\n+        upvar_debuginfo,\n         upvar_mutbls);\n \n     let call_site_scope = region::Scope {\n@@ -778,7 +778,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n            safety: Safety,\n            return_ty: Ty<'tcx>,\n            return_span: Span,\n-           upvar_decls: Vec<UpvarDecl>,\n+           __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n            upvar_mutbls: Vec<Mutability>)\n            -> Builder<'a, 'gcx, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n@@ -801,7 +801,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 1,\n             ),\n             canonical_user_type_annotations: IndexVec::new(),\n-            upvar_decls,\n+            __upvar_debuginfo_codegen_only_do_not_use,\n             upvar_mutbls,\n             var_indices: Default::default(),\n             unit_temp: None,\n@@ -837,7 +837,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.local_decls,\n             self.canonical_user_type_annotations,\n             self.arg_count,\n-            self.upvar_decls,\n+            self.__upvar_debuginfo_codegen_only_do_not_use,\n             self.fn_span,\n             self.hir.control_flow_destroyed(),\n         )"}, {"sha": "e96a40ad2f036f1be0a4180a45d9773ef8869c66", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1525dc2146e3b85123f57e59adcee1908e57013f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1525dc2146e3b85123f57e59adcee1908e57013f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=1525dc2146e3b85123f57e59adcee1908e57013f", "patch": "@@ -222,10 +222,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         debug!(\"should_inline({:?})\", callsite);\n         let tcx = self.tcx;\n \n-        // Don't inline closures that have captures\n+        // Don't inline closures that have capture debuginfo\n         // FIXME: Handle closures better\n-        if callee_mir.upvar_decls.len() > 0 {\n-            debug!(\"    upvar decls present - not inlining\");\n+        if callee_mir.__upvar_debuginfo_codegen_only_do_not_use.len() > 0 {\n+            debug!(\"    upvar debuginfo present - not inlining\");\n             return false;\n         }\n "}]}