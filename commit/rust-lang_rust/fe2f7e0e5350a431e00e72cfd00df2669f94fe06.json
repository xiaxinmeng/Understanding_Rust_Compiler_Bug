{"sha": "fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMmY3ZTBlNTM1MGE0MzFlMDBlNzJjZmQwMGRmMjY2OWY5NGZlMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-29T06:08:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-29T06:08:50Z"}, "message": "Auto merge of #64886 - Centril:rollup-30dqh8j, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #63492 (Remove redundancy from the implementation of C variadics.)\n - #64589 (Differentiate AArch64 bare-metal targets between hf and non-hf.)\n - #64799 (Fix double panic when printing query stack during an ICE)\n - #64824 (No StableHasherResult everywhere)\n - #64884 (Add pkg-config to dependency list if building for Linux on Linux)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "612c17e3a2c2f7815be281b5be840aec1a50353a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/612c17e3a2c2f7815be281b5be840aec1a50353a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "html_url": "https://github.com/rust-lang/rust/commit/fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bbab7d99dde8620604fb265706dc8bff20345a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bbab7d99dde8620604fb265706dc8bff20345a7", "html_url": "https://github.com/rust-lang/rust/commit/0bbab7d99dde8620604fb265706dc8bff20345a7"}, {"sha": "0d4afa164bd1146eeba957dfe5a784624038bc3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d4afa164bd1146eeba957dfe5a784624038bc3a", "html_url": "https://github.com/rust-lang/rust/commit/0d4afa164bd1146eeba957dfe5a784624038bc3a"}], "stats": {"total": 1470, "additions": 561, "deletions": 909}, "files": [{"sha": "495ee46a9acb31abefff6855544b8b1d5e8a41bc", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -33,6 +33,7 @@ or reading the [rustc guide][rustcguidebuild].\n    * `curl`\n    * `git`\n    * `ssl` which comes in `libssl-dev` or `openssl-devel`\n+   * `pkg-config` if you are on compiling on Linux and targeting Linux\n \n 2. Clone the [source] with `git`:\n "}, {"sha": "05bdd0887f0f6442c7e483d1ec5d9beef470cc42", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -633,9 +633,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n         }\n-        TyKind::CVarArgs(ref lt) => {\n-            visitor.visit_lifetime(lt)\n-        }\n         TyKind::Infer | TyKind::Err => {}\n     }\n }"}, {"sha": "6f51e05881be5ef7e7236cd989a211c4877dab42", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1335,13 +1335,8 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n             }\n-            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now\"),\n-            TyKind::CVarArgs => {\n-                // Create the implicit lifetime of the \"spoofed\" `VaListImpl`.\n-                let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n-                let lt = self.new_implicit_lifetime(span);\n-                hir::TyKind::CVarArgs(lt)\n-            },\n+            TyKind::Mac(_) => bug!(\"`TyKind::Mac` should have been expanded by now\"),\n+            TyKind::CVarArgs => bug!(\"`TyKind::CVarArgs` should have been handled elsewhere\"),\n         };\n \n         hir::Ty {\n@@ -2093,7 +2088,14 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n-        decl.inputs\n+        // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n+        // as they are not explicit in HIR/Ty function signatures.\n+        // (instead, the `c_variadic` flag is set to `true`)\n+        let mut inputs = &decl.inputs[..];\n+        if decl.c_variadic() {\n+            inputs = &inputs[..inputs.len() - 1];\n+        }\n+        inputs\n             .iter()\n             .map(|param| match param.pat.kind {\n                 PatKind::Ident(_, ident, _) => ident,\n@@ -2130,10 +2132,19 @@ impl<'a> LoweringContext<'a> {\n             self.anonymous_lifetime_mode\n         };\n \n+        let c_variadic = decl.c_variadic();\n+\n         // Remember how many lifetimes were already around so that we can\n         // only look at the lifetime parameters introduced by the arguments.\n         let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n-            decl.inputs\n+            // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n+            // as they are not explicit in HIR/Ty function signatures.\n+            // (instead, the `c_variadic` flag is set to `true`)\n+            let mut inputs = &decl.inputs[..];\n+            if c_variadic {\n+                inputs = &inputs[..inputs.len() - 1];\n+            }\n+            inputs\n                 .iter()\n                 .map(|param| {\n                     if let Some((_, ibty)) = &mut in_band_ty_params {\n@@ -2168,7 +2179,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::FnDecl {\n             inputs,\n             output,\n-            c_variadic: decl.c_variadic,\n+            c_variadic,\n             implicit_self: decl.inputs.get(0).map_or(\n                 hir::ImplicitSelfKind::None,\n                 |arg| {"}, {"sha": "2f0a318d5363e5adfb72de176d2b7b3e23a33d90", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -450,7 +450,6 @@ impl LoweringContext<'_> {\n         let ast_decl = FnDecl {\n             inputs: vec![],\n             output,\n-            c_variadic: false\n         };\n         let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n         let body_id = self.lower_fn_body(&ast_decl, |this| {\n@@ -739,7 +738,6 @@ impl LoweringContext<'_> {\n         let outer_decl = FnDecl {\n             inputs: decl.inputs.clone(),\n             output: FunctionRetTy::Default(fn_decl_span),\n-            c_variadic: false,\n         };\n         // We need to lower the declaration outside the new scope, because we\n         // have to conserve the state of being inside a loop condition for the"}, {"sha": "540d456daf3d39b5879669674a08c202e97e6c08", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -17,7 +17,7 @@ use syntax_pos::Span;\n use std::iter::repeat;\n \n use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n /// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n@@ -602,9 +602,7 @@ impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n where\n     T: HashStable<StableHashingContext<'hir>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(self.hash_bodies, |hcx| {\n             self.item_like.hash_stable(hcx, hasher);\n         });"}, {"sha": "4e8b4337cc6dd0d3f23179f9eab612410fbf98cc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -2016,9 +2016,6 @@ pub enum TyKind {\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n     Err,\n-    /// Placeholder for C-variadic arguments. We \"spoof\" the `VaListImpl` created\n-    /// from the variadic arguments. This type is only valid up to typeck.\n-    CVarArgs(Lifetime),\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]"}, {"sha": "6cffaa8a494c4a9bf798b77de0a0538054747a36", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -361,9 +361,6 @@ impl<'a> State<'a> {\n                 self.s.word(\"/*ERROR*/\");\n                 self.pclose();\n             }\n-            hir::TyKind::CVarArgs(_) => {\n-                self.s.word(\"...\");\n-            }\n         }\n         self.end()\n     }"}, {"sha": "8cdcf5202fcda3d9b79869c57f4b1c0d63c3700c", "filename": "src/librustc/hir/ptr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -9,8 +9,7 @@ use std::{slice, vec};\n \n use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n /// An owned smart pointer.\n #[derive(Hash, PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n@@ -133,9 +132,7 @@ impl<T: Decodable> Decodable for P<[T]> {\n impl<CTX, T> HashStable<CTX> for P<T>\n     where T: ?Sized + HashStable<CTX>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "3e6b271b8349754575b72578c7bde5123fd55f59", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::hygiene;\n \n use rustc_data_structures::stable_hasher::{\n-    HashStable, StableHasher, StableHasherResult, ToStableHashKey,\n+    HashStable, StableHasher, ToStableHashKey,\n };\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use smallvec::SmallVec;\n@@ -219,9 +219,7 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {}\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         if hcx.hash_bodies() {\n             hcx.body_resolver.body(*self).hash_stable(hcx, hasher);\n         }\n@@ -230,9 +228,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::HirId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n@@ -263,9 +259,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::HirId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n@@ -298,9 +292,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n     /// codepoint offsets. For the purpose of the hash that's sufficient.\n     /// Also, hashing filenames is expensive so we avoid doing it twice when the\n     /// span starts and ends in the same file, which is almost always the case.\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         const TAG_VALID_SPAN: u8 = 0;\n         const TAG_INVALID_SPAN: u8 = 1;\n         const TAG_EXPANSION: u8 = 0;\n@@ -379,24 +371,18 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for DelimSpan {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.open.hash_stable(hcx, hasher);\n         self.close.hash_stable(hcx, hasher);\n     }\n }\n \n-pub fn hash_stable_trait_impls<'a, W>(\n+pub fn hash_stable_trait_impls<'a>(\n     hcx: &mut StableHashingContext<'a>,\n-    hasher: &mut StableHasher<W>,\n+    hasher: &mut StableHasher,\n     blanket_impls: &[DefId],\n     non_blanket_impls: &FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n-) where\n-    W: StableHasherResult,\n-{\n+) {\n     {\n         let mut blanket_impls: SmallVec<[_; 8]> = blanket_impls\n             .iter()"}, {"sha": "c0255e5b8a48165b585d8c381322ac288bf2cbd6", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 20, "deletions": 60, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -6,19 +6,15 @@ use crate::hir::map::DefPathHash;\n use crate::hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n use crate::ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n \n-use rustc_data_structures::stable_hasher::{\n-    HashStable, ToStableHashKey, StableHasher, StableHasherResult,\n-};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n use smallvec::SmallVec;\n use std::mem;\n use syntax::ast;\n use syntax::attr;\n \n impl<'a> HashStable<StableHashingContext<'a>> for DefId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n@@ -34,9 +30,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for DefId {\n \n impl<'a> HashStable<StableHashingContext<'a>> for LocalDefId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.def_path_hash(self.to_def_id()).hash_stable(hcx, hasher);\n     }\n }\n@@ -52,9 +46,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalDefId {\n \n impl<'a> HashStable<StableHashingContext<'a>> for CrateNum {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.def_path_hash(DefId {\n             krate: *self,\n             index: CRATE_DEF_INDEX\n@@ -92,9 +84,7 @@ for hir::ItemLocalId {\n // in \"DefPath Mode\".\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::ItemId {\n             id\n         } = *self;\n@@ -106,9 +96,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::TraitItemId {\n             hir_id\n         } = * self;\n@@ -120,9 +108,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::ImplItemId {\n             hir_id\n         } = * self;\n@@ -138,9 +124,7 @@ impl_stable_hash_for!(struct ast::Label {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n                 hir_id: _,\n@@ -166,9 +150,7 @@ impl_stable_hash_for!(struct hir::Stmt {\n impl_stable_hash_for_spanned!(ast::Name);\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n                 hir_id: _,\n@@ -192,9 +174,7 @@ impl_stable_hash_for!(struct ast::Ident {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::TraitItem {\n             hir_id: _,\n             ident,\n@@ -216,9 +196,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n \n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::ImplItem {\n             hir_id: _,\n             ident,\n@@ -248,9 +226,7 @@ impl_stable_hash_for!(enum ast::CrateSugar {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             hir::VisibilityKind::Public |\n@@ -273,9 +249,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n impl_stable_hash_for_spanned!(hir::VisibilityKind);\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Mod {\n             inner: ref inner_span,\n             ref item_ids,\n@@ -305,9 +279,7 @@ impl_stable_hash_for_spanned!(hir::Variant);\n \n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Item {\n             ident,\n             ref attrs,\n@@ -328,9 +300,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Body {\n             params,\n             value,\n@@ -359,9 +329,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n \n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.local_def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n@@ -376,17 +344,13 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let hir::TraitCandidate {\n                 def_id,\n@@ -418,17 +382,13 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n }\n \n impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InlineAttr {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n     }\n }\n \n impl<'hir> HashStable<StableHashingContext<'hir>> for attr::OptimizeAttr {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "bdcf9e42ac2a88ae5cbeecb77537af5bed3f7fc4", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -16,14 +16,11 @@ use syntax_pos::SourceFile;\n use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n use smallvec::SmallVec;\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n-                                           StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n \n impl<'a> HashStable<StableHashingContext<'a>> for InternedString {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.with(|s| s.hash_stable(hcx, hasher))\n     }\n }\n@@ -41,9 +38,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n }\n@@ -110,9 +105,7 @@ impl_stable_hash_for!(enum ::syntax::edition::Edition {\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for ::syntax::attr::StabilityLevel {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue, ref is_soft } => {\n@@ -172,9 +165,7 @@ impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         if self.len() == 0 {\n             self.len().hash_stable(hcx, hasher);\n             return\n@@ -197,9 +188,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::Path {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.segments.len().hash_stable(hcx, hasher);\n         for segment in &self.segments {\n             segment.ident.name.hash_stable(hcx, hasher);\n@@ -208,9 +197,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Path {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n         debug_assert!(!self.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name)));\n         debug_assert!(!self.is_sugared_doc);\n@@ -235,9 +222,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenTree {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             tokenstream::TokenTree::Token(ref token) => {\n@@ -256,9 +241,7 @@ for tokenstream::TokenTree {\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenStream {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n@@ -285,9 +268,7 @@ impl_stable_hash_for!(struct token::Lit {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for token::TokenKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             token::Eq |\n@@ -426,9 +407,7 @@ impl_stable_hash_for!(enum ::syntax_pos::FileName {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let SourceFile {\n             name: _, // We hash the smaller name_hash instead of this\n             name_hash,\n@@ -502,11 +481,7 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for feature_gate::Features {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'tcx>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         // Unfortunately we cannot exhaustively list fields here, since the\n         // struct is macro generated.\n         self.declared_lang_features.hash_stable(hcx, hasher);"}, {"sha": "c643baf11254c8178a9edee5d39e41edbc755576", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 15, "deletions": 52, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -3,8 +3,7 @@\n \n use crate::ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n-                                           StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n use std::cell::RefCell;\n use std::mem;\n use crate::middle::region;\n@@ -15,9 +14,7 @@ impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for &'tcx ty::List<T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<(usize, usize), Fingerprint>> =\n                 RefCell::new(Default::default());\n@@ -57,18 +54,14 @@ where\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArg<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.unpack().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             ty::ReErased |\n@@ -112,31 +105,21 @@ for ty::RegionKind {\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::ConstVid<'tcx> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.index.hash_stable(hcx, hasher);\n     }\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for ty::BoundVar {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'tcx>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n@@ -145,20 +128,14 @@ impl<'a, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.skip_binder().hash_stable(hcx, hasher);\n     }\n }\n \n // AllocIds get resolved to whatever they point to (to be stable)\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n@@ -174,11 +151,7 @@ for mir::interpret::Relocations<Tag>\n where\n     Tag: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.len().hash_stable(hcx, hasher);\n         for reloc in self.iter() {\n             reloc.hash_stable(hcx, hasher);\n@@ -201,29 +174,23 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::TyVid {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _hcx: &mut StableHashingContext<'a>,\n-                                          _hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _hcx: &mut StableHashingContext<'a>, _hasher: &mut StableHasher) {\n         // `TyVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a TyVid {:?}.\", *self)\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::IntVid {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _hcx: &mut StableHashingContext<'a>,\n-                                          _hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _hcx: &mut StableHashingContext<'a>, _hasher: &mut StableHasher) {\n         // `IntVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash an IntVid {:?}.\", *self)\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::FloatVid {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _hcx: &mut StableHashingContext<'a>,\n-                                          _hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _hcx: &mut StableHashingContext<'a>, _hasher: &mut StableHasher) {\n         // `FloatVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a FloatVid {:?}.\", *self)\n@@ -234,18 +201,14 @@ impl<'a, T> HashStable<StableHashingContext<'a>> for ty::steal::Steal<T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.borrow().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for crate::middle::privacy::AccessLevels {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let crate::middle::privacy::AccessLevels {\n                 ref map"}, {"sha": "28afe9730a0344659660e1f28d35e3e078af549d", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -8,8 +8,7 @@ use crate::lint::{self, Lint, LintId, Level, LintSource};\n use crate::session::Session;\n use crate::util::nodemap::FxHashMap;\n use errors::{Applicability, DiagnosticBuilder};\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n-                                           StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n@@ -526,9 +525,7 @@ impl LintLevelMap {\n \n impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let LintLevelMap {\n             ref sets,\n             ref id_to_set,\n@@ -567,9 +564,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n \n impl<HCX> HashStable<HCX> for LintId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         self.lint_name_raw().hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "256a08d7e90c34dcaef83589afa345ba8fa9b036", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -97,9 +97,9 @@ macro_rules! impl_stable_hash_for {\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n-            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+            fn hash_stable(&self,\n+                           __ctx: &mut $crate::ich::StableHashingContext<'a>,\n+                           __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n                 use $enum_path::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n \n@@ -128,9 +128,9 @@ macro_rules! impl_stable_hash_for {\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n-            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+            fn hash_stable(&self,\n+                           __ctx: &mut $crate::ich::StableHashingContext<'a>,\n+                           __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n                 let $struct_name {\n                     $(ref $field),*\n                 } = *self;\n@@ -153,9 +153,9 @@ macro_rules! impl_stable_hash_for {\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n-            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+            fn hash_stable(&self,\n+                           __ctx: &mut $crate::ich::StableHashingContext<'a>,\n+                           __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n                 let $struct_name (\n                     $(ref $field),*\n                 ) = *self;\n@@ -173,9 +173,9 @@ macro_rules! impl_stable_hash_for_spanned {\n         impl HashStable<StableHashingContext<'a>> for ::syntax::source_map::Spanned<$T>\n         {\n             #[inline]\n-            fn hash_stable<W: StableHasherResult>(&self,\n-                                                  hcx: &mut StableHashingContext<'a>,\n-                                                  hasher: &mut StableHasher<W>) {\n+            fn hash_stable(&self,\n+                           hcx: &mut StableHashingContext<'a>,\n+                           hasher: &mut StableHasher) {\n                 self.node.hash_stable(hcx, hasher);\n                 self.span.hash_stable(hcx, hasher);\n             }"}, {"sha": "4d14299751c3d177ade6f19f3381fb8092806c04", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,7 +1,6 @@\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::cmp;\n use std::mem;\n use crate::ty::{self, TyCtxt};\n@@ -94,9 +93,7 @@ pub fn metadata_symbol_name(tcx: TyCtxt<'_>) -> String {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ExportedSymbol<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             ExportedSymbol::NonGeneric(def_id) => {"}, {"sha": "05e4d11c3f99004432beed9521899c3f28a843fe", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -17,7 +17,7 @@ use crate::ty::{self, DefIdTree, TyCtxt};\n use crate::ty::query::Providers;\n \n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use syntax::source_map;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -1491,9 +1491,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ScopeTree {\n             root_body,\n             root_parent,"}, {"sha": "31d250fa08215e59503d3326c524a0859a4b21c3", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -764,13 +764,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     });\n                 }\n             }\n-            hir::TyKind::CVarArgs(ref lt) => {\n-                // Resolve the generated lifetime for the C-variadic arguments.\n-                // The lifetime is generated in AST -> HIR lowering.\n-                if lt.name.is_elided() {\n-                    self.resolve_elided_lifetimes(vec![lt])\n-                }\n-            }\n             _ => intravisit::walk_ty(self, ty),\n         }\n     }\n@@ -2378,7 +2371,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             self.visit_lifetime(lifetime);\n                         }\n                     }\n-                    hir::TyKind::CVarArgs(_) => {}\n                     _ => {\n                         intravisit::walk_ty(self, ty);\n                     }"}, {"sha": "d8d3383903d4b5c93843e0db724984ffab573548", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::{RwLock, MappedReadGuard, ReadGuard};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use crate::ich::StableHashingContext;\n use crate::mir::{Body, BasicBlock};\n@@ -24,9 +24,7 @@ impl rustc_serialize::Decodable for Cache {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a>,\n-                                          _: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n         // Do nothing.\n     }\n }"}, {"sha": "5e12c4dfe75a53f0da7022d8ba85a9d20acc3671", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -682,14 +682,10 @@ impl_stable_hash_for!(enum self::MirPhase {\n \n mod binding_form_impl {\n     use crate::ich::StableHashingContext;\n-    use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+    use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n     impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for super::BindingForm<'tcx> {\n-        fn hash_stable<W: StableHasherResult>(\n-            &self,\n-            hcx: &mut StableHashingContext<'a>,\n-            hasher: &mut StableHasher<W>,\n-        ) {\n+        fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n             use super::BindingForm::*;\n             ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n "}, {"sha": "313b2a5d50a305784df2deacd9fdc395c99b42ec", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -8,8 +8,7 @@ use crate::util::nodemap::FxHashMap;\n use crate::ty::print::obsolete::DefPathBasedNames;\n use crate::dep_graph::{WorkProductId, DepNode, WorkProduct, DepConstructor};\n use rustc_data_structures::base_n;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n-                                           StableHasher};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use crate::ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n use crate::session::config::OptLevel;\n use std::fmt;\n@@ -223,9 +222,7 @@ impl<'tcx> MonoItem<'tcx> {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                           hcx: &mut StableHashingContext<'a>,\n-                                           hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n@@ -419,9 +416,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                           hcx: &mut StableHashingContext<'a>,\n-                                           hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let CodegenUnit {\n             ref items,\n             name,"}, {"sha": "eee084b78963cf1cfb27b8425b063ca846001493", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -7,8 +7,7 @@ use crate::traits::query::NoSolution;\n use crate::ty::{self, Ty, TyCtxt};\n \n use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use std::mem;\n \n /// Outlives bounds are relationships between generic parameters,\n@@ -43,9 +42,7 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             OutlivesBound::RegionSubRegion(ref a, ref b) => {"}, {"sha": "43f558d64430e2f94e50c67510da7ae0c4db690f", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -2,8 +2,7 @@ use super::OverlapError;\n \n use crate::hir::def_id::DefId;\n use crate::ich::{self, StableHashingContext};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use crate::traits;\n use crate::ty::{self, TyCtxt, TypeFoldable};\n use crate::ty::fast_reject::{self, SimplifiedType};\n@@ -512,9 +511,7 @@ pub fn ancestors(\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Children {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let Children {\n             ref nonblanket_impls,\n             ref blanket_impls,"}, {"sha": "6c5d9a6dfdf22b73d92408a86c549f0157c61ec2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -50,7 +50,7 @@ use errors::DiagnosticBuilder;\n use arena::SyncDroplessArena;\n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{\n-    HashStable, StableHasher, StableHasherResult, StableVec, hash_stable_hashmap,\n+    HashStable, StableHasher, StableVec, hash_stable_hashmap,\n };\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sharded::ShardedHashMap;\n@@ -705,9 +705,7 @@ impl<'tcx> TypeckTables<'tcx> {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ty::TypeckTables {\n             local_id_root,\n             ref type_dependent_defs,"}, {"sha": "038b54f1f26dd0e57912c8b46d76d4b8a05db408", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,7 +1,6 @@\n use crate::hir::def_id::DefId;\n use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n@@ -158,9 +157,7 @@ impl<'a, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n where\n     D: Copy + Debug + Ord + Eq + Hash + HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             BoolSimplifiedType |"}, {"sha": "6ab4f4c6112f779b23b2da2f8ab331aa48595a02", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 12, "deletions": 68, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -19,13 +19,12 @@ use crate::ty::GeneratorSubsts;\n use crate::ty::subst::Subst;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n pub use rustc_target::abi::*;\n use rustc_target::spec::{HasTargetSpec, abi::Abi as SpecAbi};\n use rustc_target::abi::call::{\n-    ArgAttribute, ArgAttributes, ArgType, Conv, FnType, IgnoreMode, PassMode, Reg, RegKind\n+    ArgAttribute, ArgAttributes, ArgType, Conv, FnType, PassMode, Reg, RegKind\n };\n \n pub trait IntegerExt {\n@@ -2323,9 +2322,7 @@ where\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::Variants::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -2349,9 +2346,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for DiscriminantKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::DiscriminantKind::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -2372,9 +2367,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for DiscriminantKind {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::FieldPlacement::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -2395,19 +2388,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for VariantIdx {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.as_u32().hash_stable(hcx, hasher)\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::Abi::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -2432,9 +2419,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let Scalar { value, ref valid_range } = *self;\n         value.hash_stable(hcx, hasher);\n         valid_range.start().hash_stable(hcx, hasher);\n@@ -2476,29 +2461,19 @@ impl_stable_hash_for!(struct crate::ty::layout::AbiAndPrefAlign {\n });\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for Align {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'tcx>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         self.bytes().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for Size {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'tcx>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         self.bytes().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::LayoutError::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -2722,14 +2697,6 @@ where\n             }\n         };\n \n-        // Store the index of the last argument. This is useful for working with\n-        // C-compatible variadic arguments.\n-        let last_arg_idx = if sig.inputs().is_empty() {\n-            None\n-        } else {\n-            Some(sig.inputs().len() - 1)\n-        };\n-\n         let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n             let is_return = arg_idx.is_none();\n             let mut arg = mk_arg_type(ty, arg_idx);\n@@ -2739,30 +2706,7 @@ where\n                 // The same is true for s390x-unknown-linux-gnu\n                 // and sparc64-unknown-linux-gnu.\n                 if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n-                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n-                }\n-            }\n-\n-            // If this is a C-variadic function, this is not the return value,\n-            // and there is one or more fixed arguments; ensure that the `VaListImpl`\n-            // is ignored as an argument.\n-            if sig.c_variadic {\n-                match (last_arg_idx, arg_idx) {\n-                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n-                        let va_list_did = match cx.tcx().lang_items().va_list() {\n-                            Some(did) => did,\n-                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n-                        };\n-                        match ty.kind {\n-                            ty::Adt(def, _) if def.did == va_list_did => {\n-                                // This is the \"spoofed\" `VaListImpl`. Set the arguments mode\n-                                // so that it will be ignored.\n-                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n-                            }\n-                            _ => (),\n-                        }\n-                    }\n-                    _ => {}\n+                    arg.mode = PassMode::Ignore;\n                 }\n             }\n "}, {"sha": "731aca854a4227a4e7944d1a84fd7f843d0fd7aa", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -52,8 +52,7 @@ use syntax_pos::Span;\n use smallvec;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n \n use crate::hir;\n \n@@ -577,9 +576,7 @@ impl<'tcx> TyS<'tcx> {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ty::TyS {\n             ref kind,\n \n@@ -1633,11 +1630,7 @@ impl<'a, T> HashStable<StableHashingContext<'a>> for Placeholder<T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.universe.hash_stable(hcx, hasher);\n         self.name.hash_stable(hcx, hasher);\n     }\n@@ -1774,9 +1767,7 @@ impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'tcx, T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ParamEnvAnd {\n             ref param_env,\n             ref value\n@@ -2010,9 +2001,7 @@ impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n \n impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<usize, Fingerprint>> = Default::default();\n         }"}, {"sha": "391ea762a083b003f3b71442b9694e2599aeb75b", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -334,13 +334,13 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n     let mut hcx = tcx.create_stable_hashing_context();\n     queries.iter().min_by_key(|v| {\n         let (span, query) = f(v);\n-        let mut stable_hasher = StableHasher::<u64>::new();\n+        let mut stable_hasher = StableHasher::new();\n         query.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n         // Prefer entry points which have valid spans for nicer error messages\n         // We add an integer to the tuple ensuring that entry points\n         // with valid spans are picked first\n         let span_cmp = if span == DUMMY_SP { 1 } else { 0 };\n-        (span_cmp, stable_hasher.finish())\n+        (span_cmp, stable_hasher.finish::<u64>())\n     }).unwrap()\n }\n "}, {"sha": "32858d30b0cc4e4e50bbfdff9d47054fbdc6571a", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -15,6 +15,7 @@ use errors::DiagnosticBuilder;\n use errors::Level;\n use errors::Diagnostic;\n use errors::FatalError;\n+use errors::Handler;\n use rustc_data_structures::fx::{FxHashMap};\n use rustc_data_structures::sync::{Lrc, Lock};\n use rustc_data_structures::sharded::Sharded;\n@@ -321,9 +322,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn try_print_query_stack() {\n+    pub fn try_print_query_stack(handler: &Handler) {\n         eprintln!(\"query stack during panic:\");\n \n+        // Be careful reyling on global state here: this code is called from\n+        // a panic hook, which means that the global `Handler` may be in a weird\n+        // state if it was responsible for triggering the panic.\n         tls::with_context_opt(|icx| {\n             if let Some(icx) = icx {\n                 let mut current_query = icx.query.clone();\n@@ -336,7 +340,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                  query.info.query.name(),\n                                  query.info.query.describe(icx.tcx)));\n                     diag.span = icx.tcx.sess.source_map().def_span(query.info.span).into();\n-                    icx.tcx.sess.diagnostic().force_print_diagnostic(diag);\n+                    handler.force_print_diagnostic(diag);\n \n                     current_query = query.parent.clone();\n                     i += 1;\n@@ -716,7 +720,6 @@ macro_rules! define_queries_inner {\n         use rustc_data_structures::sharded::Sharded;\n         use crate::{\n             rustc_data_structures::stable_hasher::HashStable,\n-            rustc_data_structures::stable_hasher::StableHasherResult,\n             rustc_data_structures::stable_hasher::StableHasher,\n             ich::StableHashingContext\n         };\n@@ -925,9 +928,7 @@ macro_rules! define_queries_inner {\n         }\n \n         impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n-            fn hash_stable<W: StableHasherResult>(&self,\n-                                                hcx: &mut StableHashingContext<'a>,\n-                                                hasher: &mut StableHasher<W>) {\n+            fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n                 mem::discriminant(self).hash_stable(hcx, hasher);\n                 match *self {\n                     $(Query::$name(key) => key.hash_stable(hcx, hasher),)*"}, {"sha": "49ec908231548de6f6b6e123a7814323f6b52304", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -8,8 +8,7 @@ use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ty, TyCtxt};\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n \n /// A trait's definition with type information.\n@@ -194,9 +193,7 @@ pub(super) fn trait_impls_of_provider(\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for TraitImpls {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let TraitImpls {\n             ref blanket_impls,\n             ref non_blanket_impls,"}, {"sha": "ae5cfc4d97b599705da9180c0974d090d26ffbd1", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -264,7 +264,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             val\n         };\n         match self.mode {\n-            PassMode::Ignore(_) => {}\n+            PassMode::Ignore => {}\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n@@ -319,9 +319,7 @@ impl<'tcx> FnTypeLlvmExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         );\n \n         let llreturn_ty = match self.ret.mode {\n-            PassMode::Ignore(IgnoreMode::Zst) => cx.type_void(),\n-            PassMode::Ignore(IgnoreMode::CVarArgs) =>\n-                bug!(\"`va_list` should never be a return type\"),\n+            PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 self.ret.layout.immediate_llvm_type(cx)\n             }\n@@ -339,7 +337,7 @@ impl<'tcx> FnTypeLlvmExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             }\n \n             let llarg_ty = match arg.mode {\n-                PassMode::Ignore(_) => continue,\n+                PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 0, true));\n@@ -408,7 +406,7 @@ impl<'tcx> FnTypeLlvmExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 apply(&ArgAttributes::new(), None);\n             }\n             match arg.mode {\n-                PassMode::Ignore(_) => {}\n+                PassMode::Ignore => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs, None) => apply(attrs, Some(arg.layout.llvm_type(cx))),\n                 PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n@@ -455,7 +453,7 @@ impl<'tcx> FnTypeLlvmExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 apply(&ArgAttributes::new(), None);\n             }\n             match arg.mode {\n-                PassMode::Ignore(_) => {}\n+                PassMode::Ignore => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs, None) => apply(attrs, Some(arg.layout.llvm_type(bx))),\n                 PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {"}, {"sha": "544d6794e2191988524d4267374f7c82b793f671", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -187,15 +187,15 @@ impl TypeMap<'ll, 'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-        let mut hasher = StableHasher::<Fingerprint>::new();\n+        let mut hasher = StableHasher::new();\n         let mut hcx = cx.tcx.create_stable_hashing_context();\n         let type_ = cx.tcx.erase_regions(&type_);\n         hcx.while_hashing_spans(false, |hcx| {\n             hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                 type_.hash_stable(hcx, &mut hasher);\n             });\n         });\n-        let unique_type_id = hasher.finish().to_hex();\n+        let unique_type_id = hasher.finish::<Fingerprint>().to_hex();\n \n         let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));"}, {"sha": "e3aa35ef4eb5e5f5b16925cdf8405b4fb9503950", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -109,14 +109,11 @@ pub enum TypeKind {\n //            for now we content ourselves with providing a no-op HashStable\n //            implementation for CGUs.\n mod temp_stable_hash_impls {\n-    use rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher,\n-                                               HashStable};\n+    use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n     use crate::ModuleCodegen;\n \n     impl<HCX, M> HashStable<HCX> for ModuleCodegen<M> {\n-        fn hash_stable<W: StableHasherResult>(&self,\n-                                              _: &mut HCX,\n-                                              _: &mut StableHasher<W>) {\n+        fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n             // do nothing\n         }\n     }"}, {"sha": "7ebdfbdcdeb2d6340980b1ce1198a1899f484dd4", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,9 +1,10 @@\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnTypeExt};\n use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::PanicInfo;\n-use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n+use rustc_target::abi::call::{ArgType, FnType, PassMode};\n use rustc_target::spec::abi::Abi;\n use crate::base;\n use crate::MemFlags;\n@@ -224,14 +225,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n \n     fn codegen_return_terminator(&mut self, mut bx: Bx) {\n+        // Call `va_end` if this is the definition of a C-variadic function.\n         if self.fn_ty.c_variadic {\n-            match self.va_list_ref {\n-                Some(va_list) => {\n+            // The `VaList` \"spoofed\" argument is just after all the real arguments.\n+            let va_list_arg_idx = self.fn_ty.args.len();\n+            match self.locals[mir::Local::new(1 + va_list_arg_idx)] {\n+                LocalRef::Place(va_list) => {\n                     bx.va_end(va_list.llval);\n                 }\n-                None => {\n-                    bug!(\"C-variadic function must have a `va_list_ref`\");\n-                }\n+                _ => bug!(\"C-variadic function must have a `VaList` place\"),\n             }\n         }\n         if self.fn_ty.ret.layout.abi.is_uninhabited() {\n@@ -242,15 +244,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n         let llval = match self.fn_ty.ret.mode {\n-            PassMode::Ignore(IgnoreMode::Zst) | PassMode::Indirect(..) => {\n+            PassMode::Ignore | PassMode::Indirect(..) => {\n                 bx.ret_void();\n                 return;\n             }\n \n-            PassMode::Ignore(IgnoreMode::CVarArgs) => {\n-                bug!(\"C-variadic arguments should never be the return type\");\n-            }\n-\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 let op =\n                     self.codegen_consume(&mut bx, &mir::Place::return_place().as_ref());\n@@ -502,10 +500,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n \n-        // The \"spoofed\" `VaListImpl` added to a C-variadic functions signature\n-        // should not be included in the `extra_args` calculation.\n-        let extra_args_start_idx = sig.inputs().len() - if sig.c_variadic { 1 } else { 0 };\n-        let extra_args = &args[extra_args_start_idx..];\n+        let extra_args = &args[sig.inputs().len()..];\n         let extra_args = extra_args.iter().map(|op_arg| {\n             let op_ty = op_arg.ty(self.mir, bx.tcx());\n             self.monomorphize(&op_ty)\n@@ -691,26 +686,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             (&args[..], None)\n         };\n \n-        // Useful determining if the current argument is the \"spoofed\" `VaListImpl`\n-        let last_arg_idx = if sig.inputs().is_empty() {\n-            None\n-        } else {\n-            Some(sig.inputs().len() - 1)\n-        };\n         'make_args: for (i, arg) in first_args.iter().enumerate() {\n-            // If this is a C-variadic function the function signature contains\n-            // an \"spoofed\" `VaListImpl`. This argument is ignored, but we need to\n-            // populate it with a dummy operand so that the users real arguments\n-            // are not overwritten.\n-            let i = if sig.c_variadic && last_arg_idx.map(|x| i >= x).unwrap_or(false) {\n-                if i + 1 < fn_ty.args.len() {\n-                    i + 1\n-                } else {\n-                    break 'make_args\n-                }\n-            } else {\n-                i\n-            };\n             let mut op = self.codegen_operand(&mut bx, arg);\n \n             if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {"}, {"sha": "4f3a8bdb540b5d853da642d0424d28e45b697e44", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -2,7 +2,7 @@ use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts, Instance};\n use rustc::ty::layout::{TyLayout, HasTyCtxt, FnTypeExt};\n use rustc::mir::{self, Body};\n use rustc::session::config::DebugInfo;\n-use rustc_target::abi::call::{FnType, PassMode, IgnoreMode};\n+use rustc_target::abi::call::{FnType, PassMode};\n use rustc_target::abi::{Variants, VariantIdx};\n use crate::base;\n use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n@@ -81,10 +81,6 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     /// Debug information for MIR scopes.\n     scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<Bx::DIScope>>,\n-\n-    /// If this function is a C-variadic function, this contains the `PlaceRef` of the\n-    /// \"spoofed\" `VaListImpl`.\n-    va_list_ref: Option<PlaceRef<'tcx, Bx::Value>>,\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -236,18 +232,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         scopes,\n         locals: IndexVec::new(),\n         debug_context,\n-        va_list_ref: None,\n     };\n \n     let memory_locals = analyze::non_ssa_locals(&fx);\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        // FIXME(dlrobertson): This is ugly. Find a better way of getting the `PlaceRef` or\n-        // `LocalRef` from `arg_local_refs`\n-        let mut va_list_ref = None;\n-        let args = arg_local_refs(&mut bx, &fx, &memory_locals, &mut va_list_ref);\n-        fx.va_list_ref = va_list_ref;\n+        let args = arg_local_refs(&mut bx, &fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n@@ -426,7 +417,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     fx: &FunctionCx<'a, 'tcx, Bx>,\n     memory_locals: &BitSet<mir::Local>,\n-    va_list_ref: &mut Option<PlaceRef<'tcx, Bx::Value>>,\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mir = fx.mir;\n     let tcx = fx.cx.tcx();\n@@ -441,15 +431,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         None\n     };\n \n-    // Store the index of the last argument. This is used to\n-    // call va_start on the va_list instead of attempting\n-    // to store_fn_arg.\n-    let last_arg_idx = if fx.fn_ty.args.is_empty() {\n-        None\n-    } else {\n-        Some(fx.fn_ty.args.len() - 1)\n-    };\n-\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n@@ -503,6 +484,31 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             return LocalRef::Place(place);\n         }\n \n+        if fx.fn_ty.c_variadic && arg_index == fx.fn_ty.args.len() {\n+            let arg_ty = fx.monomorphize(&arg_decl.ty);\n+\n+            let va_list = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n+            bx.set_var_name(va_list.llval, name);\n+            bx.va_start(va_list.llval);\n+\n+            arg_scope.map(|scope| {\n+                let variable_access = VariableAccess::DirectVariable {\n+                    alloca: va_list.llval\n+                };\n+                bx.declare_local(\n+                    &fx.debug_context,\n+                    arg_decl.name.unwrap_or(kw::Invalid),\n+                    va_list.layout.ty,\n+                    scope,\n+                    variable_access,\n+                    VariableKind::ArgumentVariable(arg_index + 1),\n+                    DUMMY_SP\n+                );\n+            });\n+\n+            return LocalRef::Place(va_list);\n+        }\n+\n         let arg = &fx.fn_ty.args[idx];\n         idx += 1;\n         if arg.pad.is_some() {\n@@ -515,10 +521,9 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // of putting everything in allocas just so we can use llvm.dbg.declare.\n             let local = |op| LocalRef::Operand(Some(op));\n             match arg.mode {\n-                PassMode::Ignore(IgnoreMode::Zst) => {\n+                PassMode::Ignore => {\n                     return local(OperandRef::new_zst(bx, arg.layout));\n                 }\n-                PassMode::Ignore(IgnoreMode::CVarArgs) => {}\n                 PassMode::Direct(_) => {\n                     let llarg = bx.get_param(llarg_idx);\n                     bx.set_var_name(llarg, &name);\n@@ -568,22 +573,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         } else {\n             let tmp = PlaceRef::alloca(bx, arg.layout);\n             bx.set_var_name(tmp.llval, name);\n-            if fx.fn_ty.c_variadic && last_arg_idx.map(|idx| arg_index == idx).unwrap_or(false) {\n-                let va_list_did = match tcx.lang_items().va_list() {\n-                    Some(did) => did,\n-                    None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n-                };\n-                match arg_decl.ty.kind {\n-                    ty::Adt(def, _) if def.did == va_list_did => {\n-                        // Call `va_start` on the spoofed `VaListImpl`.\n-                        bx.va_start(tmp.llval);\n-                        *va_list_ref = Some(tmp);\n-                    },\n-                    _ => bug!(\"last argument of variadic function is not a `va_list`\")\n-                }\n-            } else {\n-                bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n-            }\n+            bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n             tmp\n         };\n         let upvar_debuginfo = &mir.__upvar_debuginfo_codegen_only_do_not_use;"}, {"sha": "a9866c8c0b28225ea5532493266f4bd04dd46d7b", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -89,7 +89,7 @@ fn get_symbol_hash<'tcx>(\n         def_id, substs\n     );\n \n-    let mut hasher = StableHasher::<u64>::new();\n+    let mut hasher = StableHasher::new();\n     let mut hcx = tcx.create_stable_hashing_context();\n \n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n@@ -132,7 +132,7 @@ fn get_symbol_hash<'tcx>(\n     });\n \n     // 64 bits should be enough to avoid collisions.\n-    hasher.finish()\n+    hasher.finish::<u64>()\n }\n \n // Follow C++ namespace-mangling style, see"}, {"sha": "b43df6045d6aa03b8ab5ffee337766701dcbe2bc", "filename": "src/librustc_data_structures/fingerprint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffingerprint.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -76,7 +76,7 @@ impl ::std::fmt::Display for Fingerprint {\n \n impl stable_hasher::StableHasherResult for Fingerprint {\n     #[inline]\n-    fn finish(hasher: stable_hasher::StableHasher<Self>) -> Self {\n+    fn finish(hasher: stable_hasher::StableHasher) -> Self {\n         let (_0, _1) = hasher.finalize();\n         Fingerprint(_0, _1)\n     }"}, {"sha": "53dff794ff0ae6893c28f40c1455a15cbf523a0a", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 45, "deletions": 113, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,5 +1,4 @@\n use std::hash::{Hash, Hasher, BuildHasher};\n-use std::marker::PhantomData;\n use std::mem;\n use smallvec::SmallVec;\n use crate::sip128::SipHasher128;\n@@ -13,55 +12,53 @@ use crate::bit_set;\n /// To that end we always convert integers to little-endian format before\n /// hashing and the architecture dependent `isize` and `usize` types are\n /// extended to 64 bits if needed.\n-pub struct StableHasher<W> {\n+pub struct StableHasher {\n     state: SipHasher128,\n-    width: PhantomData<W>,\n }\n \n-impl<W: StableHasherResult> ::std::fmt::Debug for StableHasher<W> {\n+impl ::std::fmt::Debug for StableHasher {\n     fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n         write!(f, \"{:?}\", self.state)\n     }\n }\n \n pub trait StableHasherResult: Sized {\n-    fn finish(hasher: StableHasher<Self>) -> Self;\n+    fn finish(hasher: StableHasher) -> Self;\n }\n \n-impl<W: StableHasherResult> StableHasher<W> {\n+impl StableHasher {\n     pub fn new() -> Self {\n         StableHasher {\n             state: SipHasher128::new_with_keys(0, 0),\n-            width: PhantomData,\n         }\n     }\n \n-    pub fn finish(self) -> W {\n+    pub fn finish<W: StableHasherResult>(self) -> W {\n         W::finish(self)\n     }\n }\n \n impl StableHasherResult for u128 {\n-    fn finish(hasher: StableHasher<Self>) -> Self {\n+    fn finish(hasher: StableHasher) -> Self {\n         let (_0, _1) = hasher.finalize();\n         u128::from(_0) | (u128::from(_1) << 64)\n     }\n }\n \n impl StableHasherResult for u64 {\n-    fn finish(hasher: StableHasher<Self>) -> Self {\n+    fn finish(hasher: StableHasher) -> Self {\n         hasher.finalize().0\n     }\n }\n \n-impl<W> StableHasher<W> {\n+impl StableHasher {\n     #[inline]\n     pub fn finalize(self) -> (u64, u64) {\n         self.state.finish128()\n     }\n }\n \n-impl<W> Hasher for StableHasher<W> {\n+impl Hasher for StableHasher {\n     fn finish(&self) -> u64 {\n         panic!(\"use StableHasher::finalize instead\");\n     }\n@@ -165,9 +162,7 @@ impl<W> Hasher for StableHasher<W> {\n ///   `StableHasher` takes care of endianness and `isize`/`usize` platform\n ///   differences.\n pub trait HashStable<CTX> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>);\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher);\n }\n \n /// Implement this for types that can be turned into stable keys like, for\n@@ -185,10 +180,10 @@ macro_rules! impl_stable_hash_via_hash {\n     ($t:ty) => (\n         impl<CTX> $crate::stable_hasher::HashStable<CTX> for $t {\n             #[inline]\n-            fn hash_stable<W: $crate::stable_hasher::StableHasherResult>(\n+            fn hash_stable(\n                 &self,\n                 _: &mut CTX,\n-                hasher: &mut $crate::stable_hasher::StableHasher<W>\n+                hasher: &mut $crate::stable_hasher::StableHasher\n             ) {\n                 ::std::hash::Hash::hash(self, hasher);\n             }\n@@ -215,17 +210,13 @@ impl_stable_hash_via_hash!(char);\n impl_stable_hash_via_hash!(());\n \n impl<CTX> HashStable<CTX> for ::std::num::NonZeroU32 {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.get().hash_stable(ctx, hasher)\n     }\n }\n \n impl<CTX> HashStable<CTX> for f32 {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let val: u32 = unsafe {\n             ::std::mem::transmute(*self)\n         };\n@@ -234,9 +225,7 @@ impl<CTX> HashStable<CTX> for f32 {\n }\n \n impl<CTX> HashStable<CTX> for f64 {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let val: u64 = unsafe {\n             ::std::mem::transmute(*self)\n         };\n@@ -245,26 +234,20 @@ impl<CTX> HashStable<CTX> for f64 {\n }\n \n impl<CTX> HashStable<CTX> for ::std::cmp::Ordering {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (*self as i8).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T1: HashStable<CTX>, CTX> HashStable<CTX> for (T1,) {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let (ref _0,) = *self;\n         _0.hash_stable(ctx, hasher);\n     }\n }\n \n impl<T1: HashStable<CTX>, T2: HashStable<CTX>, CTX> HashStable<CTX> for (T1, T2) {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let (ref _0, ref _1) = *self;\n         _0.hash_stable(ctx, hasher);\n         _1.hash_stable(ctx, hasher);\n@@ -276,9 +259,7 @@ impl<T1, T2, T3, CTX> HashStable<CTX> for (T1, T2, T3)\n            T2: HashStable<CTX>,\n            T3: HashStable<CTX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let (ref _0, ref _1, ref _2) = *self;\n         _0.hash_stable(ctx, hasher);\n         _1.hash_stable(ctx, hasher);\n@@ -292,9 +273,7 @@ impl<T1, T2, T3, T4, CTX> HashStable<CTX> for (T1, T2, T3, T4)\n            T3: HashStable<CTX>,\n            T4: HashStable<CTX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let (ref _0, ref _1, ref _2, ref _3) = *self;\n         _0.hash_stable(ctx, hasher);\n         _1.hash_stable(ctx, hasher);\n@@ -304,9 +283,7 @@ impl<T1, T2, T3, T4, CTX> HashStable<CTX> for (T1, T2, T3, T4)\n }\n \n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for [T] {\n-    default fn hash_stable<W: StableHasherResult>(&self,\n-                                                  ctx: &mut CTX,\n-                                                  hasher: &mut StableHasher<W>) {\n+    default fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash_stable(ctx, hasher);\n         for item in self {\n             item.hash_stable(ctx, hasher);\n@@ -316,9 +293,7 @@ impl<T: HashStable<CTX>, CTX> HashStable<CTX> for [T] {\n \n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (&self[..]).hash_stable(ctx, hasher);\n     }\n }\n@@ -329,9 +304,7 @@ impl<K, V, R, CTX> HashStable<CTX> for indexmap::IndexMap<K, V, R>\n           R: BuildHasher,\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash_stable(ctx, hasher);\n         for kv in self {\n             kv.hash_stable(ctx, hasher);\n@@ -344,9 +317,7 @@ impl<K, R, CTX> HashStable<CTX> for indexmap::IndexSet<K, R>\n           R: BuildHasher,\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash_stable(ctx, hasher);\n         for key in self {\n             key.hash_stable(ctx, hasher);\n@@ -356,45 +327,35 @@ impl<K, R, CTX> HashStable<CTX> for indexmap::IndexSet<K, R>\n \n impl<A, CTX> HashStable<CTX> for SmallVec<[A; 1]> where A: HashStable<CTX> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (&self[..]).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T: ?Sized + HashStable<CTX>, CTX> HashStable<CTX> for Box<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T: ?Sized + HashStable<CTX>, CTX> HashStable<CTX> for ::std::rc::Rc<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T: ?Sized + HashStable<CTX>, CTX> HashStable<CTX> for ::std::sync::Arc<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(ctx, hasher);\n     }\n }\n \n impl<CTX> HashStable<CTX> for str {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash(hasher);\n         self.as_bytes().hash(hasher);\n     }\n@@ -403,9 +364,7 @@ impl<CTX> HashStable<CTX> for str {\n \n impl<CTX> HashStable<CTX> for String {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         (&self[..]).hash_stable(hcx, hasher);\n     }\n }\n@@ -420,9 +379,7 @@ impl<HCX> ToStableHashKey<HCX> for String {\n \n impl<CTX> HashStable<CTX> for bool {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (if *self { 1u8 } else { 0u8 }).hash_stable(ctx, hasher);\n     }\n }\n@@ -432,9 +389,7 @@ impl<T, CTX> HashStable<CTX> for Option<T>\n     where T: HashStable<CTX>\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         if let Some(ref value) = *self {\n             1u8.hash_stable(ctx, hasher);\n             value.hash_stable(ctx, hasher);\n@@ -449,9 +404,7 @@ impl<T1, T2, CTX> HashStable<CTX> for Result<T1, T2>\n           T2: HashStable<CTX>,\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(ctx, hasher);\n         match *self {\n             Ok(ref x) => x.hash_stable(ctx, hasher),\n@@ -464,28 +417,22 @@ impl<'a, T, CTX> HashStable<CTX> for &'a T\n     where T: HashStable<CTX> + ?Sized\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T, CTX> HashStable<CTX> for ::std::mem::Discriminant<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _: &mut CTX, hasher: &mut StableHasher) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n }\n \n impl<I: indexed_vec::Idx, T, CTX> HashStable<CTX> for indexed_vec::IndexVec<I, T>\n     where T: HashStable<CTX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash_stable(ctx, hasher);\n         for v in &self.raw {\n             v.hash_stable(ctx, hasher);\n@@ -496,19 +443,15 @@ impl<I: indexed_vec::Idx, T, CTX> HashStable<CTX> for indexed_vec::IndexVec<I, T\n \n impl<I: indexed_vec::Idx, CTX> HashStable<CTX> for bit_set::BitSet<I>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.words().hash_stable(ctx, hasher);\n     }\n }\n \n impl<R: indexed_vec::Idx, C: indexed_vec::Idx, CTX> HashStable<CTX>\n for bit_set::BitMatrix<R, C>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.words().hash_stable(ctx, hasher);\n     }\n }\n@@ -522,9 +465,7 @@ impl<K, V, R, HCX> HashStable<HCX> for ::std::collections::HashMap<K, V, R>\n           R: BuildHasher,\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         hash_stable_hashmap(hcx, hasher, self, ToStableHashKey::to_stable_hash_key);\n     }\n }\n@@ -533,9 +474,7 @@ impl<K, R, HCX> HashStable<HCX> for ::std::collections::HashSet<K, R>\n     where K: ToStableHashKey<HCX> + Eq + Hash,\n           R: BuildHasher,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         let mut keys: Vec<_> = self.iter()\n                                    .map(|k| k.to_stable_hash_key(hcx))\n                                    .collect();\n@@ -548,9 +487,7 @@ impl<K, V, HCX> HashStable<HCX> for ::std::collections::BTreeMap<K, V>\n     where K: ToStableHashKey<HCX>,\n           V: HashStable<HCX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         let mut entries: Vec<_> = self.iter()\n                                       .map(|(k, v)| (k.to_stable_hash_key(hcx), v))\n                                       .collect();\n@@ -562,9 +499,7 @@ impl<K, V, HCX> HashStable<HCX> for ::std::collections::BTreeMap<K, V>\n impl<K, HCX> HashStable<HCX> for ::std::collections::BTreeSet<K>\n     where K: ToStableHashKey<HCX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         let mut keys: Vec<_> = self.iter()\n                                    .map(|k| k.to_stable_hash_key(hcx))\n                                    .collect();\n@@ -573,17 +508,16 @@ impl<K, HCX> HashStable<HCX> for ::std::collections::BTreeSet<K>\n     }\n }\n \n-pub fn hash_stable_hashmap<HCX, K, V, R, SK, F, W>(\n+pub fn hash_stable_hashmap<HCX, K, V, R, SK, F>(\n     hcx: &mut HCX,\n-    hasher: &mut StableHasher<W>,\n+    hasher: &mut StableHasher,\n     map: &::std::collections::HashMap<K, V, R>,\n     to_stable_hash_key: F)\n     where K: Eq + Hash,\n           V: HashStable<HCX>,\n           R: BuildHasher,\n           SK: HashStable<HCX> + Ord + Clone,\n           F: Fn(&K, &HCX) -> SK,\n-          W: StableHasherResult,\n {\n     let mut entries: Vec<_> = map.iter()\n                                   .map(|(k, v)| (to_stable_hash_key(k, hcx), v))\n@@ -614,9 +548,7 @@ impl<T> ::std::ops::Deref for StableVec<T> {\n impl<T, HCX> HashStable<HCX> for StableVec<T>\n     where T: HashStable<HCX> + ToStableHashKey<HCX>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         let StableVec(ref v) = *self;\n \n         let mut sorted: Vec<_> = v.iter()"}, {"sha": "64042264d794f02d62d22145cf7f3dfd3053ff0d", "filename": "src/librustc_data_structures/svh.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsvh.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -61,11 +61,7 @@ impl Decodable for Svh {\n \n impl<T> stable_hasher::HashStable<T> for Svh {\n     #[inline]\n-    fn hash_stable<W: stable_hasher::StableHasherResult>(\n-        &self,\n-        ctx: &mut T,\n-        hasher: &mut stable_hasher::StableHasher<W>\n-    ) {\n+    fn hash_stable(&self, ctx: &mut T, hasher: &mut stable_hasher::StableHasher) {\n         let Svh {\n             hash\n         } = *self;"}, {"sha": "93a8b7f525fffff540afb00792b30ed6819fc9b7", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,4 +1,4 @@\n-use crate::stable_hasher::{StableHasher, StableHasherResult, HashStable};\n+use crate::stable_hasher::{StableHasher, HashStable};\n \n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n@@ -60,9 +60,7 @@ impl<T> Extend<T> for ThinVec<T> {\n }\n \n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ThinVec<T> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(hcx, hasher)\n     }\n }"}, {"sha": "9c5447f3f5a44a406162267ab8d0aab3de61a038", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,6 +1,6 @@\n use crate::bit_set::BitMatrix;\n use crate::fx::FxHashMap;\n-use crate::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use crate::stable_hasher::{HashStable, StableHasher};\n use crate::sync::Lock;\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use std::fmt::Debug;\n@@ -442,9 +442,7 @@ impl<T> Decodable for TransitiveRelation<T>\n impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n     where T: HashStable<CTX> + Eq + Debug + Clone + Hash\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         // We are assuming here that the relation graph has been built in a\n         // deterministic way and we can just hash it the way it is.\n         let TransitiveRelation {\n@@ -462,9 +460,7 @@ impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n }\n \n impl<CTX> HashStable<CTX> for Edge {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         let Edge {\n             ref source,\n             ref target,\n@@ -476,9 +472,7 @@ impl<CTX> HashStable<CTX> for Edge {\n }\n \n impl<CTX> HashStable<CTX> for Index {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         let Index(idx) = *self;\n         idx.hash_stable(hcx, hasher);\n     }"}, {"sha": "dd088b68a239afe03b107d036168dbe3ca7d29e7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1231,7 +1231,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     let backtrace = env::var_os(\"RUST_BACKTRACE\").map(|x| &x != \"0\").unwrap_or(false);\n \n     if backtrace {\n-        TyCtxt::try_print_query_stack();\n+        TyCtxt::try_print_query_stack(&handler);\n     }\n \n     #[cfg(windows)]"}, {"sha": "e73195fbb8c2da9abc2e88eedccee02c1397a728", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -502,7 +502,7 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n     // into various other hashes quite a bit (symbol hashes, incr. comp. hashes,\n     // debuginfo type IDs, etc), so we don't want it to be too wide. 128 bits\n     // should still be safe enough to avoid collisions in practice.\n-    let mut hasher = StableHasher::<Fingerprint>::new();\n+    let mut hasher = StableHasher::new();\n \n     let mut metadata = session.opts.cg.metadata.clone();\n     // We don't want the crate_disambiguator to dependent on the order\n@@ -528,7 +528,7 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n         .contains(&config::CrateType::Executable);\n     hasher.write(if is_exe { b\"exe\" } else { b\"lib\" });\n \n-    CrateDisambiguator::from(hasher.finish())\n+    CrateDisambiguator::from(hasher.finish::<Fingerprint>())\n }\n \n pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {"}, {"sha": "150719c1dbc0e7e7c11332c91f02c54ff759cc15", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -944,15 +944,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n-        let inputs = if sig.c_variadic {\n-            // Don't include the spoofed `VaListImpl` in the functions list\n-            // of inputs.\n-            &sig.inputs()[..sig.inputs().len() - 1]\n-        } else {\n-            &sig.inputs()[..]\n-        };\n \n-        for (input_ty, input_hir) in inputs.iter().zip(&decl.inputs) {\n+        for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n             self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty);\n         }\n "}, {"sha": "a708f3191dcf84e4bb427a107542e3a0b8992b96", "filename": "src/librustc_macros/src/hash_stable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -76,10 +76,10 @@ pub fn hash_stable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::To\n \n     s.bound_impl(quote!(::rustc_data_structures::stable_hasher::HashStable\n                         <::rustc::ich::StableHashingContext<'__ctx>>), quote!{\n-        fn hash_stable<__W: ::rustc_data_structures::stable_hasher::StableHasherResult>(\n+        fn hash_stable(\n             &self,\n             __hcx: &mut ::rustc::ich::StableHashingContext<'__ctx>,\n-            __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<__W>) {\n+            __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n             #discriminant\n             match *self { #body }\n         }"}, {"sha": "9beeacbe72d80199e5ad0ca202102b465f3f0413", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -368,9 +368,9 @@ impl<'tcx> EncodeContext<'tcx> {\n                         let mut adapted = (**source_file).clone();\n                         adapted.name = Path::new(&working_dir).join(name).into();\n                         adapted.name_hash = {\n-                            let mut hasher: StableHasher<u128> = StableHasher::new();\n+                            let mut hasher: StableHasher = StableHasher::new();\n                             adapted.name.hash(&mut hasher);\n-                            hasher.finish()\n+                            hasher.finish::<u128>()\n                         };\n                         Lrc::new(adapted)\n                     },"}, {"sha": "8b1ba59c6df7eba16396d9246b5afa47566ba5e7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -399,7 +399,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions.unnormalized_input_tys[implicit_inputs + argument_index];\n         if let Some(region_name) = self.give_name_if_we_can_match_hir_ty_from_argument(\n             infcx,\n-            body,\n             mir_def_id,\n             fr,\n             arg_ty,\n@@ -415,7 +414,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_we_can_match_hir_ty_from_argument(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n         mir_def_id: DefId,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n@@ -424,18 +422,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<RegionName> {\n         let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n-        let argument_hir_ty: &hir::Ty = &fn_decl.inputs[argument_index];\n+        let argument_hir_ty: &hir::Ty = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n             // `|x|`... in that case, we can't highlight the type but\n             // must highlight the variable.\n-            hir::TyKind::Infer => self.give_name_if_we_cannot_match_hir_ty(\n-                infcx,\n-                body,\n-                needle_fr,\n-                argument_ty,\n-                renctx,\n-            ),\n+            // NOTE(eddyb) this is handled in/by the sole caller\n+            // (`give_name_if_anonymous_region_appears_in_arguments`).\n+            hir::TyKind::Infer => None,\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n                 infcx.tcx,"}, {"sha": "fa326062fe2c9c20bcaab4de5f2d43fa154efa4a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1726,17 +1726,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         from_hir_call: bool,\n     ) {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n-        // Do not count the `VaListImpl` argument as a \"true\" argument to\n-        // a C-variadic function.\n-        let inputs = if sig.c_variadic {\n-            &sig.inputs()[..sig.inputs().len() - 1]\n-        } else {\n-            &sig.inputs()[..]\n-        };\n-        if args.len() < inputs.len() || (args.len() > inputs.len() && !sig.c_variadic) {\n+        if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.c_variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n-        for (n, (fn_arg, op_arg)) in inputs.iter().zip(args).enumerate() {\n+        for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(body, self.tcx());\n             let category = if from_hir_call {\n                 ConstraintCategory::CallArgument"}, {"sha": "7053bdca25957117829d25331c3901f57ea160c7", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -16,8 +16,9 @@ use either::Either;\n use rustc::hir::def_id::DefId;\n use rustc::hir::{self, BodyOwnerKind, HirId};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc::middle::lang_items;\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n+use rustc::ty::subst::{InternalSubsts, SubstsRef, Subst};\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -425,12 +426,33 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 .replace_late_bound_regions_with_nll_infer_vars(self.mir_def_id, &mut indices);\n         }\n \n+        let (unnormalized_output_ty, mut unnormalized_input_tys) =\n+            inputs_and_output.split_last().unwrap();\n+\n+        // C-variadic fns also have a `VaList` input that's not listed in the signature\n+        // (as it's created inside the body itself, not passed in from outside).\n+        if let DefiningTy::FnDef(def_id, _) = defining_ty {\n+            if self.infcx.tcx.fn_sig(def_id).c_variadic() {\n+                let va_list_did = self.infcx.tcx.require_lang_item(\n+                    lang_items::VaListTypeLangItem,\n+                    Some(self.infcx.tcx.def_span(self.mir_def_id),),\n+                );\n+                let region = self.infcx.tcx.mk_region(ty::ReVar(\n+                    self.infcx.next_nll_region_var(FR).to_region_vid(),\n+                ));\n+                let va_list_ty = self.infcx.tcx.type_of(va_list_did)\n+                    .subst(self.infcx.tcx, &[region.into()]);\n+\n+                unnormalized_input_tys = self.infcx.tcx.mk_type_list(\n+                    unnormalized_input_tys.iter().copied()\n+                        .chain(iter::once(va_list_ty)),\n+                );\n+            }\n+        }\n+\n         let fr_fn_body = self.infcx.next_nll_region_var(FR).to_region_vid();\n         let num_universals = self.infcx.num_region_vars();\n \n-        let (unnormalized_output_ty, unnormalized_input_tys) =\n-            inputs_and_output.split_last().unwrap();\n-\n         debug!(\n             \"build: global regions = {}..{}\",\n             FIRST_GLOBAL_INDEX, first_extern_index"}, {"sha": "17932ae855767bc44fe94001aed3a4b6230bf64c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -7,9 +7,11 @@ use crate::util as mir_util;\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n+use rustc::middle::lang_items;\n use rustc::middle::region;\n use rustc::mir::*;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Subst;\n use rustc::util::nodemap::HirIdMap;\n use rustc_target::spec::PanicStrategy;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -102,9 +104,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n                         let opt_ty_info;\n                         let self_arg;\n                         if let Some(ref fn_decl) = tcx.hir().fn_decl_by_hir_id(owner_id) {\n-                            let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let ty_span = tcx.hir().span(ty_hir_id);\n-                            opt_ty_info = Some(ty_span);\n+                            opt_ty_info = fn_decl.inputs.get(index).map(|ty| ty.span);\n                             self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n                                 match fn_decl.implicit_self {\n                                     hir::ImplicitSelfKind::Imm => Some(ImplicitSelfKind::Imm),\n@@ -121,7 +121,24 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n                             self_arg = None;\n                         }\n \n-                        ArgInfo(fn_sig.inputs()[index], opt_ty_info, Some(&arg), self_arg)\n+                        // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n+                        // (as it's created inside the body itself, not passed in from outside).\n+                        let ty = if fn_sig.c_variadic && index == fn_sig.inputs().len() {\n+                            let va_list_did = tcx.require_lang_item(\n+                                lang_items::VaListTypeLangItem,\n+                                Some(arg.span),\n+                            );\n+                            let region = tcx.mk_region(ty::ReScope(region::Scope {\n+                                id: body.value.hir_id.local_id,\n+                                data: region::ScopeData::CallSite\n+                            }));\n+\n+                            tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n+                        } else {\n+                            fn_sig.inputs()[index]\n+                        };\n+\n+                        ArgInfo(ty, opt_ty_info, Some(&arg), self_arg)\n                     });\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);"}, {"sha": "4c7d0dcb697211d72e0227299793664b2fc1f43d", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -52,9 +52,9 @@ impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, ()> {\n         // Compute stack's hash before copying anything\n         let mut hcx = tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::<u64>::new();\n+        let mut hasher = StableHasher::new();\n         stack.hash_stable(&mut hcx, &mut hasher);\n-        let hash = hasher.finish();\n+        let hash = hasher.finish::<u64>();\n \n         // Check if we know that hash already\n         if self.hashes.is_empty() {\n@@ -428,9 +428,9 @@ impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n         let mut hcx = self.memory.tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::<u64>::new();\n+        let mut hasher = StableHasher::new();\n         self.hash_stable(&mut hcx, &mut hasher);\n-        hasher.finish().hash(state)\n+        hasher.finish::<u64>().hash(state)\n     }\n }\n "}, {"sha": "bc21113527ecfa83b7602319689a882517713c5d", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -23,18 +23,10 @@ mod x86_64;\n mod x86_win64;\n mod wasm32;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum IgnoreMode {\n-    /// C-variadic arguments.\n-    CVarArgs,\n-    /// A zero-sized type.\n-    Zst,\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum PassMode {\n-    /// Ignore the argument (useful for empty structs and C-variadic args).\n-    Ignore(IgnoreMode),\n+    /// Ignore the argument.\n+    Ignore,\n     /// Pass the argument directly.\n     Direct(ArgAttributes),\n     /// Pass a pair's elements directly in two arguments.\n@@ -490,7 +482,7 @@ impl<'a, Ty> ArgType<'a, Ty> {\n \n     pub fn is_ignore(&self) -> bool {\n         match self.mode {\n-            PassMode::Ignore(_) => true,\n+            PassMode::Ignore => true,\n             _ => false\n         }\n     }"}, {"sha": "2e809571ab18b60fc87e40dc08961133f9133366", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -88,7 +88,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>, flavor: Fla\n \n         for arg in &mut fty.args {\n             let attrs = match arg.mode {\n-                PassMode::Ignore(_) |\n+                PassMode::Ignore |\n                 PassMode::Indirect(_, None) => continue,\n                 PassMode::Direct(ref mut attrs) => attrs,\n                 PassMode::Pair(..) |"}, {"sha": "b9549ec2120dd82ff101db59c4ce064871b1d9c5", "filename": "src/librustc_target/spec/aarch64_unknown_none.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_none.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,4 +1,4 @@\n-// Generic AArch64 target for bare-metal code\n+// Generic AArch64 target for bare-metal code - Floating point enabled\n //\n // Can be used in conjunction with the `target-feature` and\n // `target-cpu` compiler flags to opt-in more hardware-specific\n@@ -11,7 +11,7 @@ use super::{LldFlavor, LinkerFlavor, Target, TargetOptions, PanicStrategy};\n pub fn target() -> Result<Target, String> {\n     let opts = TargetOptions {\n         linker: Some(\"rust-lld\".to_owned()),\n-        features: \"+strict-align\".to_string(),\n+        features: \"+strict-align,+neon,+fp-armv8\".to_string(),\n         executables: true,\n         relocation_model: \"static\".to_string(),\n         disable_redzone: true,"}, {"sha": "b91f2af68ecb85c2e08c51725da9af9254a4af97", "filename": "src/librustc_target/spec/aarch64_unknown_none_softfloat.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_none_softfloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_none_softfloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_none_softfloat.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -0,0 +1,37 @@\n+// Generic AArch64 target for bare-metal code - Floating point disabled\n+//\n+// Can be used in conjunction with the `target-feature` and\n+// `target-cpu` compiler flags to opt-in more hardware-specific\n+// features.\n+//\n+// For example, `-C target-cpu=cortex-a53`.\n+\n+use super::{LldFlavor, LinkerFlavor, Target, TargetOptions, PanicStrategy};\n+\n+pub fn target() -> Result<Target, String> {\n+    let opts = TargetOptions {\n+        linker: Some(\"rust-lld\".to_owned()),\n+        features: \"+strict-align,-neon,-fp-armv8\".to_string(),\n+        executables: true,\n+        relocation_model: \"static\".to_string(),\n+        disable_redzone: true,\n+        linker_is_gnu: true,\n+        max_atomic_width: Some(128),\n+        panic_strategy: PanicStrategy::Abort,\n+        abi_blacklist: super::arm_base::abi_blacklist(),\n+        .. Default::default()\n+    };\n+    Ok(Target {\n+        llvm_target: \"aarch64-unknown-none\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        target_os: \"none\".to_string(),\n+        target_env: String::new(),\n+        target_vendor: String::new(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n+        options: opts,\n+    })\n+}"}, {"sha": "25add0cc6a4be2cede092124a1ed10954cbdf989", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -489,6 +489,7 @@ supported_targets! {\n     (\"riscv64gc-unknown-none-elf\", riscv64gc_unknown_none_elf),\n \n     (\"aarch64-unknown-none\", aarch64_unknown_none),\n+    (\"aarch64-unknown-none-softfloat\", aarch64_unknown_none_softfloat),\n \n     (\"x86_64-fortanix-unknown-sgx\", x86_64_fortanix_unknown_sgx),\n "}, {"sha": "fd6744da0606752ba19d17d58e3a5ca548956c68", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -2148,15 +2148,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(None, ast_ty.span)\n             }\n-            hir::TyKind::CVarArgs(lt) => {\n-                let va_list_did = match tcx.lang_items().va_list() {\n-                    Some(did) => did,\n-                    None => span_bug!(ast_ty.span,\n-                                      \"`va_list` lang item required for variadics\"),\n-                };\n-                let region = self.ast_region_to_region(&lt, None);\n-                tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n-            }\n             hir::TyKind::Err => {\n                 tcx.types.err\n             }"}, {"sha": "290b87388ebbe966ea347ffa2562045e1e66146c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -397,27 +397,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .0;\n         let fn_sig = self.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n-        let inputs = if fn_sig.c_variadic {\n-            if fn_sig.inputs().len() > 1 {\n-                &fn_sig.inputs()[..fn_sig.inputs().len() - 1]\n-            } else {\n-                span_bug!(call_expr.span,\n-                          \"C-variadic functions are only valid with one or more fixed arguments\");\n-            }\n-        } else {\n-            &fn_sig.inputs()[..]\n-        };\n         // Call the generic checker.\n         let expected_arg_tys = self.expected_inputs_for_expected_output(\n             call_expr.span,\n             expected,\n             fn_sig.output(),\n-            inputs,\n+            fn_sig.inputs(),\n         );\n         self.check_argument_types(\n             call_expr.span,\n             call_expr,\n-            inputs,\n+            fn_sig.inputs(),\n             &expected_arg_tys[..],\n             arg_exprs,\n             fn_sig.c_variadic,"}, {"sha": "a7832b8c2cf1727217762cf1911bd5939cb6d450", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1132,8 +1132,29 @@ fn check_fn<'a, 'tcx>(\n     let outer_hir_id = fcx.tcx.hir().as_local_hir_id(outer_def_id).unwrap();\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id, }.visit_body(body);\n \n+    // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n+    // (as it's created inside the body itself, not passed in from outside).\n+    let maybe_va_list = if fn_sig.c_variadic {\n+        let va_list_did = fcx.tcx.require_lang_item(\n+            lang_items::VaListTypeLangItem,\n+            Some(body.params.last().unwrap().span),\n+        );\n+        let region = fcx.tcx.mk_region(ty::ReScope(region::Scope {\n+            id: body.value.hir_id.local_id,\n+            data: region::ScopeData::CallSite\n+        }));\n+\n+        Some(fcx.tcx.type_of(va_list_did).subst(fcx.tcx, &[region.into()]))\n+    } else {\n+        None\n+    };\n+\n     // Add formal parameters.\n-    for (param_ty, param) in fn_sig.inputs().iter().zip(&body.params) {\n+    for (param_ty, param) in\n+        fn_sig.inputs().iter().copied()\n+            .chain(maybe_va_list)\n+            .zip(&body.params)\n+    {\n         // Check the pattern.\n         fcx.check_pat_top(&param.pat, param_ty, None);\n "}, {"sha": "b530851b80de7c52983a20169fbbad9177f92fce", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -2032,6 +2032,7 @@ impl Clean<Item> for doctree::Function<'_> {\n pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: FunctionRetTy,\n+    pub c_variadic: bool,\n     pub attrs: Attributes,\n }\n \n@@ -2110,6 +2111,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n         FnDecl {\n             inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n+            c_variadic: self.0.c_variadic,\n             attrs: Attributes::default(),\n         }\n     }\n@@ -2127,6 +2129,7 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n         FnDecl {\n             output: Return(sig.skip_binder().output().clean(cx)),\n             attrs: Attributes::default(),\n+            c_variadic: sig.skip_binder().c_variadic,\n             inputs: Arguments {\n                 values: sig.skip_binder().inputs().iter().map(|t| {\n                     Argument {\n@@ -2545,7 +2548,6 @@ pub enum Type {\n     Slice(Box<Type>),\n     Array(Box<Type>, String),\n     Never,\n-    CVarArgs,\n     RawPointer(Mutability, Box<Type>),\n     BorrowedRef {\n         lifetime: Option<Lifetime>,\n@@ -2583,7 +2585,6 @@ pub enum PrimitiveType {\n     Reference,\n     Fn,\n     Never,\n-    CVarArgs,\n }\n \n #[derive(Clone, Copy, Debug)]\n@@ -2787,7 +2788,6 @@ impl PrimitiveType {\n             Reference => \"reference\",\n             Fn => \"fn\",\n             Never => \"never\",\n-            CVarArgs => \"...\",\n         }\n     }\n \n@@ -3032,7 +3032,6 @@ impl Clean<Type> for hir::Ty {\n             TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyKind::Infer | TyKind::Err => Infer,\n             TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.kind),\n-            TyKind::CVarArgs(_) => CVarArgs,\n         }\n     }\n }\n@@ -3980,7 +3979,6 @@ fn build_deref_target_impls(cx: &DocContext<'_>,\n             Reference => None,\n             Fn => None,\n             Never => None,\n-            CVarArgs => tcx.lang_items().va_list(),\n         };\n         if let Some(did) = did {\n             if !did.is_local() {"}, {"sha": "4cde868201eeffdef8f948d411f446fa90131cb1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -657,7 +657,6 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))\n         }\n         clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n-        clean::CVarArgs => primitive_link(f, PrimitiveType::CVarArgs, \"...\"),\n         clean::RawPointer(m, ref t) => {\n             let m = match m {\n                 clean::Immutable => \"const\",\n@@ -903,12 +902,15 @@ impl clean::BareFunctionDecl {\n impl clean::FnDecl {\n     crate fn print(&self) -> impl fmt::Display + '_ {\n         display_fn(move |f| {\n+        let ellipsis = if self.c_variadic { \", ...\" } else { \"\" };\n             if f.alternate() {\n                 write!(f,\n-                    \"({args:#}){arrow:#}\", args = self.inputs.print(), arrow = self.output.print())\n+                    \"({args:#}{ellipsis}){arrow:#}\",\n+                    args = self.inputs.print(), ellipsis = ellipsis, arrow = self.output.print())\n             } else {\n                 write!(f,\n-                    \"({args}){arrow}\", args = self.inputs.print(), arrow = self.output.print())\n+                    \"({args}{ellipsis}){arrow}\",\n+                    args = self.inputs.print(), ellipsis = ellipsis, arrow = self.output.print())\n             }\n         })\n     }\n@@ -975,7 +977,12 @@ impl Function<'_> {\n                 }\n             }\n \n-            let args_plain = format!(\"({})\", args_plain);\n+            let mut args_plain = format!(\"({})\", args_plain);\n+\n+            if decl.c_variadic {\n+                args.push_str(\",<br> ...\");\n+                args_plain.push_str(\", ...\");\n+            }\n \n             let output = if let hir::IsAsync::Async = asyncness {\n                 Cow::Owned(decl.sugared_async_return_type())"}, {"sha": "bc468c1ad0ebe549ac74b387de36b1c149f5067d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1893,7 +1893,6 @@ impl Param {\n pub struct FnDecl {\n     pub inputs: Vec<Param>,\n     pub output: FunctionRetTy,\n-    pub c_variadic: bool,\n }\n \n impl FnDecl {\n@@ -1903,6 +1902,12 @@ impl FnDecl {\n     pub fn has_self(&self) -> bool {\n         self.inputs.get(0).map(Param::is_self).unwrap_or(false)\n     }\n+    pub fn c_variadic(&self) -> bool {\n+        self.inputs.last().map(|arg| match arg.ty.kind {\n+            TyKind::CVarArgs => true,\n+            _ => false,\n+        }).unwrap_or(false)\n+    }\n }\n \n /// Is the trait definition an auto trait?"}, {"sha": "8c5289671c98e18651f05d0577905239c5b64355", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -562,7 +562,6 @@ impl<'a> ExtCtxt<'a> {\n         P(ast::FnDecl {\n             inputs,\n             output,\n-            c_variadic: false\n         })\n     }\n "}, {"sha": "d7fc74955bbbde1c421c5c1e86226f594df07b97", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -531,7 +531,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             self.check_abi(header.abi, span);\n         }\n \n-        if fn_decl.c_variadic {\n+        if fn_decl.c_variadic() {\n             gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n         }\n \n@@ -564,7 +564,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 if block.is_none() {\n                     self.check_abi(sig.header.abi, ti.span);\n                 }\n-                if sig.decl.c_variadic {\n+                if sig.decl.c_variadic() {\n                     gate_feature_post!(&self, c_variadic, ti.span,\n                                        \"C-variadic functions are unstable\");\n                 }\n@@ -601,7 +601,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         }\n \n         match ii.kind {\n-            ast::ImplItemKind::Method(..) => {}\n+            ast::ImplItemKind::Method(ref sig, _) => {\n+                if sig.decl.c_variadic() {\n+                    gate_feature_post!(&self, c_variadic, ii.span,\n+                                       \"C-variadic functions are unstable\");\n+                }\n+            }\n             ast::ImplItemKind::OpaqueTy(..) => {\n                 gate_feature_post!(\n                     &self,"}, {"sha": "80dfe9e5be0ad60054ac8053220e36153c2cb3c7", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -717,7 +717,7 @@ pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T)\n }\n \n pub fn noop_visit_fn_decl<T: MutVisitor>(decl: &mut P<FnDecl>, vis: &mut T) {\n-    let FnDecl { inputs, output, c_variadic: _ } = decl.deref_mut();\n+    let FnDecl { inputs, output } = decl.deref_mut();\n     inputs.flat_map_in_place(|param| vis.flat_map_param(param));\n     match output {\n         FunctionRetTy::Default(span) => vis.visit_span(span),"}, {"sha": "f22fd5ad703d9e4e7c80680e42f3fd9a374679fb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1194,7 +1194,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_fn_params(&mut self, named_params: bool, allow_c_variadic: bool)\n-                     -> PResult<'a, (Vec<Param> , bool)> {\n+                     -> PResult<'a, Vec<Param>> {\n         let sp = self.token.span;\n         let mut c_variadic = false;\n         let (params, _): (Vec<Option<Param>>, _) = self.parse_paren_comma_seq(|p| {\n@@ -1218,6 +1218,8 @@ impl<'a> Parser<'a> {\n                             let span = p.token.span;\n                             p.span_err(span,\n                                 \"`...` must be the last argument of a C-variadic function\");\n+                            // FIXME(eddyb) this should probably still push `CVarArgs`.\n+                            // Maybe AST validation/HIR lowering should emit the above error?\n                             Ok(None)\n                         } else {\n                             Ok(Some(param))\n@@ -1245,7 +1247,7 @@ impl<'a> Parser<'a> {\n                           \"C-variadic function must be declared with at least one named argument\");\n         }\n \n-        Ok((params, c_variadic))\n+        Ok(params)\n     }\n \n     /// Returns the parsed optional self parameter and whether a self shortcut was used.\n@@ -1414,7 +1416,6 @@ impl<'a> Parser<'a> {\n         Ok(P(FnDecl {\n             inputs: fn_inputs,\n             output: self.parse_ret_ty(true)?,\n-            c_variadic: false\n         }))\n     }\n "}, {"sha": "23674ad589dc570716e65b9225355c265b36672b", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1176,7 +1176,6 @@ impl<'a> Parser<'a> {\n         Ok(P(FnDecl {\n             inputs: inputs_captures,\n             output,\n-            c_variadic: false\n         }))\n     }\n "}, {"sha": "92b19b73e571953751c68f9016ac019bdca0170e", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1292,13 +1292,12 @@ impl<'a> Parser<'a> {\n \n     /// Parses the argument list and result type of a function declaration.\n     fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n-        let (args, c_variadic) = self.parse_fn_params(true, allow_c_variadic)?;\n+        let args = self.parse_fn_params(true, allow_c_variadic)?;\n         let ret_ty = self.parse_ret_ty(true)?;\n \n         Ok(P(FnDecl {\n             inputs: args,\n             output: ret_ty,\n-            c_variadic,\n         }))\n     }\n "}, {"sha": "c52d3733b5e0afd068b852e717c9736f6e8b5ebe", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -292,12 +292,11 @@ impl<'a> Parser<'a> {\n         };\n \n         self.expect_keyword(kw::Fn)?;\n-        let (inputs, c_variadic) = self.parse_fn_params(false, true)?;\n+        let inputs = self.parse_fn_params(false, true)?;\n         let ret_ty = self.parse_ret_ty(false)?;\n         let decl = P(FnDecl {\n             inputs,\n             output: ret_ty,\n-            c_variadic,\n         });\n         Ok(TyKind::BareFn(P(BareFnTy {\n             abi,"}, {"sha": "faa70edbfa29b7249a9c45a28358deb8520c30ef", "filename": "src/libsyntax/print/pprust/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -29,7 +29,6 @@ fn test_fun_to_string() {\n         let decl = ast::FnDecl {\n             inputs: Vec::new(),\n             output: ast::FunctionRetTy::Default(syntax_pos::DUMMY_SP),\n-            c_variadic: false\n         };\n         let generics = ast::Generics::default();\n         assert_eq!("}, {"sha": "7300ce249548b3afccb03f285dfd5ef91ce6e72b", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -33,8 +33,7 @@ use std::{slice, vec};\n \n use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n /// An owned smart pointer.\n #[derive(Hash, PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n@@ -218,9 +217,7 @@ impl<T: Decodable> Decodable for P<[T]> {\n impl<CTX, T> HashStable<CTX> for P<T>\n     where T: ?Sized + HashStable<CTX>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "674f17de618e9e6d517511ce2f582fa5f586b537", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1067,14 +1067,14 @@ impl SourceFile {\n         normalize_newlines(&mut src);\n \n         let src_hash = {\n-            let mut hasher: StableHasher<u128> = StableHasher::new();\n+            let mut hasher: StableHasher = StableHasher::new();\n             hasher.write(src.as_bytes());\n-            hasher.finish()\n+            hasher.finish::<u128>()\n         };\n         let name_hash = {\n-            let mut hasher: StableHasher<u128> = StableHasher::new();\n+            let mut hasher: StableHasher = StableHasher::new();\n             name.hash(&mut hasher);\n-            hasher.finish()\n+            hasher.finish::<u128>()\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n         if end_pos > u32::max_value() as usize {\n@@ -1120,10 +1120,10 @@ impl SourceFile {\n             // Check that no-one else have provided the source while we were getting it\n             if *external_src == ExternalSource::AbsentOk {\n                 if let Some(src) = src {\n-                    let mut hasher: StableHasher<u128> = StableHasher::new();\n+                    let mut hasher: StableHasher = StableHasher::new();\n                     hasher.write(src.as_bytes());\n \n-                    if hasher.finish() == self.src_hash {\n+                    if hasher.finish::<u128>() == self.src_hash {\n                         *external_src = ExternalSource::Present(src);\n                         return true;\n                     }"}, {"sha": "bd8f1775b3d048dcb8ee387f44f2be317c4781d6", "filename": "src/test/rustdoc/variadic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Frustdoc%2Fvariadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Frustdoc%2Fvariadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fvariadic.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,4 +1,4 @@\n extern \"C\" {\n-    // @has variadic/fn.foo.html //pre 'pub unsafe extern \"C\" fn foo(x: i32, _: ...)'\n+    // @has variadic/fn.foo.html //pre 'pub unsafe extern \"C\" fn foo(x: i32, ...)'\n     pub fn foo(x: i32, ...);\n }"}, {"sha": "d4aff73590734dfdbae933e01698eebfb4a034fd", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -114,7 +114,6 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                 let decl = P(FnDecl {\n                     inputs: vec![],\n                     output: FunctionRetTy::Default(DUMMY_SP),\n-                    c_variadic: false,\n                 });\n                 iter_exprs(depth - 1, &mut |e| g(\n                         ExprKind::Closure(CaptureBy::Value,"}, {"sha": "73f72a177bcaaa5b59d9f273991355e3fca26db1", "filename": "src/test/ui/c-variadic/variadic-ffi-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -29,15 +29,15 @@ LL |         let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n    |                                                        ^^^ expected non-variadic fn, found variadic function\n    |\n    = note: expected type `unsafe extern \"C\" fn(isize, u8)`\n-              found type `for<'r> unsafe extern \"C\" fn(isize, u8, std::ffi::VaListImpl<'r>, ...) {foo}`\n+              found type `unsafe extern \"C\" fn(isize, u8, ...) {foo}`\n \n error[E0308]: mismatched types\n   --> $DIR/variadic-ffi-1.rs:20:54\n    |\n LL |         let y: extern \"C\" fn(f: isize, x: u8, ...) = bar;\n    |                                                      ^^^ expected variadic fn, found non-variadic function\n    |\n-   = note: expected type `for<'r> extern \"C\" fn(isize, u8, std::ffi::VaListImpl<'r>, ...)`\n+   = note: expected type `extern \"C\" fn(isize, u8, ...)`\n               found type `extern \"C\" fn(isize, u8) {bar}`\n \n error[E0617]: can't pass `f32` to variadic function"}, {"sha": "8b70b15fa6e50e8e7b8dcbe776908785e1e42d66", "filename": "src/test/ui/c-variadic/variadic-ffi-4.nll.stderr", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,18 +1,30 @@\n-error[E0621]: explicit lifetime required in the type of `ap`\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:8:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n+   |                                     --            -- has type `core::ffi::VaListImpl<'1>`\n+   |                                     |\n+   |                                     lifetime `'f` defined here\n+LL |     ap\n+   |     ^^ function was supposed to return data with lifetime `'1` but it is returning data with lifetime `'f`\n+\n+error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:8:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n-   |                                                       --- help: add explicit lifetime `'f` to the type of `ap`: `core::ffi::VaListImpl<'f>`\n+   |                                     --            -- has type `core::ffi::VaListImpl<'1>`\n+   |                                     |\n+   |                                     lifetime `'f` defined here\n LL |     ap\n-   |     ^^ lifetime `'f` required\n+   |     ^^ returning this value requires that `'1` must outlive `'f`\n \n-error[E0621]: explicit lifetime required in the type of `ap`\n+error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:12:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaListImpl<'static> {\n-   |                                                   --- help: add explicit lifetime `'static` to the type of `ap`: `core::ffi::VaListImpl<'static>`\n+   |                                               -- has type `core::ffi::VaListImpl<'1>`\n LL |     ap\n-   |     ^^ lifetime `'static` required\n+   |     ^^ returning this value requires that `'1` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:16:33\n@@ -44,7 +56,7 @@ LL |     *ap0 = ap1;\n    |     ^^^^ assignment requires that `'2` must outlive `'1`\n \n error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:25:5\n+  --> $DIR/variadic-ffi-4.rs:24:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n    |                                               ---                   ------- has type `core::ffi::VaListImpl<'2>`\n@@ -54,7 +66,7 @@ LL |     ap0 = &mut ap1;\n    |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:25:5\n+  --> $DIR/variadic-ffi-4.rs:24:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n    |                                               ---                   ------- has type `core::ffi::VaListImpl<'2>`\n@@ -64,15 +76,15 @@ LL |     ap0 = &mut ap1;\n    |     ^^^^^^^^^^^^^^ assignment requires that `'2` must outlive `'1`\n \n error[E0384]: cannot assign to immutable argument `ap0`\n-  --> $DIR/variadic-ffi-4.rs:25:5\n+  --> $DIR/variadic-ffi-4.rs:24:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n    |                                               --- help: make this binding mutable: `mut ap0`\n LL |     ap0 = &mut ap1;\n    |     ^^^^^^^^^^^^^^ cannot assign to immutable argument\n \n error[E0597]: `ap1` does not live long enough\n-  --> $DIR/variadic-ffi-4.rs:25:11\n+  --> $DIR/variadic-ffi-4.rs:24:11\n    |\n LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n    |                                                    - let's call the lifetime of this reference `'1`\n@@ -86,7 +98,7 @@ LL | }\n    | - `ap1` dropped here while still borrowed\n \n error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:33:12\n+  --> $DIR/variadic-ffi-4.rs:31:12\n    |\n LL | pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n    |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n@@ -96,7 +108,7 @@ LL |     *ap0 = ap1.clone();\n    |            ^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:33:12\n+  --> $DIR/variadic-ffi-4.rs:31:12\n    |\n LL | pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n    |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n@@ -105,7 +117,7 @@ LL | pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut\n LL |     *ap0 = ap1.clone();\n    |            ^^^^^^^^^^^ argument requires that `'2` must outlive `'1`\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 12 previous errors\n \n-Some errors have detailed explanations: E0384, E0597, E0621.\n+Some errors have detailed explanations: E0384, E0597.\n For more information about an error, try `rustc --explain E0384`."}, {"sha": "a4d658cef16303141a16d677c864d0cad5354827", "filename": "src/test/ui/c-variadic/variadic-ffi-4.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -5,11 +5,11 @@\n use core::ffi::{VaList, VaListImpl};\n \n pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n-    ap //~ ERROR: explicit lifetime required\n+    ap //~ ERROR: mismatched types\n }\n \n pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaListImpl<'static> {\n-    ap //~ ERROR: explicit lifetime required\n+    ap //~ ERROR: mismatched types\n }\n \n pub unsafe extern \"C\" fn no_escape2(_: usize, ap: ...) {\n@@ -18,18 +18,15 @@ pub unsafe extern \"C\" fn no_escape2(_: usize, ap: ...) {\n \n pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n     *ap0 = ap1; //~ ERROR: mismatched types\n-    //~^ ERROR: mismatched types\n }\n \n pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n     ap0 = &mut ap1;\n     //~^ ERROR: a value of type `core::ffi::VaListImpl<'_>` is borrowed for too long\n-    //~^^ ERROR: mismatched types\n-    //~^^^ ERROR: mismatched types\n-    //~^^^^ ERROR: cannot infer an appropriate lifetime\n+    //~| ERROR: mismatched types\n+    //~| ERROR: cannot infer an appropriate lifetime\n }\n \n pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n     *ap0 = ap1.clone(); //~ ERROR: mismatched types\n-    //~^ ERROR: mismatched types\n }"}, {"sha": "b986d0c24350615783699b8fce02bc5dd18bf820", "filename": "src/test/ui/c-variadic/variadic-ffi-4.stderr", "status": "modified", "additions": 68, "deletions": 131, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,18 +1,42 @@\n-error[E0621]: explicit lifetime required in the type of `ap`\n+error[E0308]: mismatched types\n   --> $DIR/variadic-ffi-4.rs:8:5\n    |\n-LL | pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n-   |                                                       --- help: add explicit lifetime `'f` to the type of `ap`: `core::ffi::VaListImpl<'f>`\n LL |     ap\n-   |     ^^ lifetime `'f` required\n+   |     ^^ lifetime mismatch\n+   |\n+   = note: expected type `core::ffi::VaListImpl<'f>`\n+              found type `core::ffi::VaListImpl<'_>`\n+note: the scope of call-site for function at 7:78...\n+  --> $DIR/variadic-ffi-4.rs:7:78\n+   |\n+LL |   pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n+   |  ______________________________________________________________________________^\n+LL | |     ap\n+LL | | }\n+   | |_^\n+note: ...does not necessarily outlive the lifetime 'f as defined on the function body at 7:37\n+  --> $DIR/variadic-ffi-4.rs:7:37\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n+   |                                     ^^\n \n-error[E0621]: explicit lifetime required in the type of `ap`\n+error[E0308]: mismatched types\n   --> $DIR/variadic-ffi-4.rs:12:5\n    |\n-LL | pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaListImpl<'static> {\n-   |                                                   --- help: add explicit lifetime `'static` to the type of `ap`: `core::ffi::VaListImpl<'static>`\n LL |     ap\n-   |     ^^ lifetime `'static` required\n+   |     ^^ lifetime mismatch\n+   |\n+   = note: expected type `core::ffi::VaListImpl<'static>`\n+              found type `core::ffi::VaListImpl<'_>`\n+note: the scope of call-site for function at 11:79...\n+  --> $DIR/variadic-ffi-4.rs:11:79\n+   |\n+LL |   pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaListImpl<'static> {\n+   |  _______________________________________________________________________________^\n+LL | |     ap\n+LL | | }\n+   | |_^\n+   = note: ...does not necessarily outlive the static lifetime\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n   --> $DIR/variadic-ffi-4.rs:16:33\n@@ -47,229 +71,142 @@ LL |     *ap0 = ap1;\n    |\n    = note: expected type `core::ffi::VaListImpl<'_>`\n               found type `core::ffi::VaListImpl<'_>`\n-note: the anonymous lifetime #3 defined on the function body at 19:1...\n-  --> $DIR/variadic-ffi-4.rs:19:1\n+note: the scope of call-site for function at 19:87...\n+  --> $DIR/variadic-ffi-4.rs:19:87\n    |\n-LL | / pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+LL |   pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+   |  _______________________________________________________________________________________^\n LL | |     *ap0 = ap1;\n-LL | |\n LL | | }\n    | |_^\n note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 19:1\n   --> $DIR/variadic-ffi-4.rs:19:1\n    |\n LL | / pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n LL | |     *ap0 = ap1;\n-LL | |\n-LL | | }\n-   | |_^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-4.rs:20:12\n-   |\n-LL |     *ap0 = ap1;\n-   |            ^^^ lifetime mismatch\n-   |\n-   = note: expected type `core::ffi::VaListImpl<'_>`\n-              found type `core::ffi::VaListImpl<'_>`\n-note: the anonymous lifetime #2 defined on the function body at 19:1...\n-  --> $DIR/variadic-ffi-4.rs:19:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     *ap0 = ap1;\n-LL | |\n-LL | | }\n-   | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #3 defined on the function body at 19:1\n-  --> $DIR/variadic-ffi-4.rs:19:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     *ap0 = ap1;\n-LL | |\n LL | | }\n    | |_^\n \n error[E0490]: a value of type `core::ffi::VaListImpl<'_>` is borrowed for too long\n-  --> $DIR/variadic-ffi-4.rs:25:11\n+  --> $DIR/variadic-ffi-4.rs:24:11\n    |\n LL |     ap0 = &mut ap1;\n    |           ^^^^^^^^\n    |\n-note: the type is valid for the anonymous lifetime #1 defined on the function body at 24:1\n-  --> $DIR/variadic-ffi-4.rs:24:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     ap0 = &mut ap1;\n-LL | |\n-LL | |\n-LL | |\n-LL | |\n-LL | | }\n-   | |_^\n-note: but the borrow lasts for the anonymous lifetime #3 defined on the function body at 24:1\n-  --> $DIR/variadic-ffi-4.rs:24:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     ap0 = &mut ap1;\n-LL | |\n-LL | |\n-LL | |\n-LL | |\n-LL | | }\n-   | |_^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-4.rs:25:11\n-   |\n-LL |     ap0 = &mut ap1;\n-   |           ^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected type `&mut core::ffi::VaListImpl<'_>`\n-              found type `&mut core::ffi::VaListImpl<'_>`\n-note: the anonymous lifetime #3 defined on the function body at 24:1...\n-  --> $DIR/variadic-ffi-4.rs:24:1\n+note: the type is valid for the anonymous lifetime #1 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n    |\n LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n LL | |     ap0 = &mut ap1;\n LL | |\n LL | |\n LL | |\n-LL | |\n LL | | }\n    | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 24:1\n-  --> $DIR/variadic-ffi-4.rs:24:1\n+note: but the borrow lasts for the scope of call-site for function at 23:83\n+  --> $DIR/variadic-ffi-4.rs:23:83\n    |\n-LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n+LL |   pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n+   |  ___________________________________________________________________________________^\n LL | |     ap0 = &mut ap1;\n LL | |\n LL | |\n LL | |\n-LL | |\n LL | | }\n    | |_^\n \n error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-4.rs:25:11\n+  --> $DIR/variadic-ffi-4.rs:24:11\n    |\n LL |     ap0 = &mut ap1;\n    |           ^^^^^^^^ lifetime mismatch\n    |\n    = note: expected type `&mut core::ffi::VaListImpl<'_>`\n               found type `&mut core::ffi::VaListImpl<'_>`\n-note: the anonymous lifetime #2 defined on the function body at 24:1...\n-  --> $DIR/variadic-ffi-4.rs:24:1\n+note: the scope of call-site for function at 23:83...\n+  --> $DIR/variadic-ffi-4.rs:23:83\n    |\n-LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n+LL |   pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n+   |  ___________________________________________________________________________________^\n LL | |     ap0 = &mut ap1;\n LL | |\n LL | |\n LL | |\n-LL | |\n LL | | }\n    | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #3 defined on the function body at 24:1\n-  --> $DIR/variadic-ffi-4.rs:24:1\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n    |\n LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n LL | |     ap0 = &mut ap1;\n LL | |\n LL | |\n LL | |\n-LL | |\n LL | | }\n    | |_^\n \n error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n-  --> $DIR/variadic-ffi-4.rs:25:11\n+  --> $DIR/variadic-ffi-4.rs:24:11\n    |\n LL |     ap0 = &mut ap1;\n    |           ^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the anonymous lifetime #3 defined on the function body at 24:1...\n-  --> $DIR/variadic-ffi-4.rs:24:1\n+note: first, the lifetime cannot outlive the scope of call-site for function at 23:83...\n+  --> $DIR/variadic-ffi-4.rs:23:83\n    |\n-LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n+LL |   pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n+   |  ___________________________________________________________________________________^\n LL | |     ap0 = &mut ap1;\n LL | |\n LL | |\n LL | |\n-LL | |\n LL | | }\n    | |_^\n note: ...so that the type `core::ffi::VaListImpl<'_>` is not borrowed for too long\n-  --> $DIR/variadic-ffi-4.rs:25:11\n+  --> $DIR/variadic-ffi-4.rs:24:11\n    |\n LL |     ap0 = &mut ap1;\n    |           ^^^^^^^^\n-note: but, the lifetime must be valid for the anonymous lifetime #1 defined on the function body at 24:1...\n-  --> $DIR/variadic-ffi-4.rs:24:1\n+note: but, the lifetime must be valid for the anonymous lifetime #1 defined on the function body at 23:1...\n+  --> $DIR/variadic-ffi-4.rs:23:1\n    |\n LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n LL | |     ap0 = &mut ap1;\n LL | |\n LL | |\n LL | |\n-LL | |\n LL | | }\n    | |_^\n note: ...so that reference does not outlive borrowed content\n-  --> $DIR/variadic-ffi-4.rs:25:11\n+  --> $DIR/variadic-ffi-4.rs:24:11\n    |\n LL |     ap0 = &mut ap1;\n    |           ^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-4.rs:33:12\n+  --> $DIR/variadic-ffi-4.rs:31:12\n    |\n LL |     *ap0 = ap1.clone();\n    |            ^^^^^^^^^^^ lifetime mismatch\n    |\n    = note: expected type `core::ffi::VaListImpl<'_>`\n               found type `core::ffi::VaListImpl<'_>`\n-note: the anonymous lifetime #3 defined on the function body at 32:1...\n-  --> $DIR/variadic-ffi-4.rs:32:1\n+note: the scope of call-site for function at 30:87...\n+  --> $DIR/variadic-ffi-4.rs:30:87\n    |\n-LL | / pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+LL |   pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+   |  _______________________________________________________________________________________^\n LL | |     *ap0 = ap1.clone();\n-LL | |\n LL | | }\n    | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 32:1\n-  --> $DIR/variadic-ffi-4.rs:32:1\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 30:1\n+  --> $DIR/variadic-ffi-4.rs:30:1\n    |\n LL | / pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n LL | |     *ap0 = ap1.clone();\n-LL | |\n-LL | | }\n-   | |_^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-4.rs:33:12\n-   |\n-LL |     *ap0 = ap1.clone();\n-   |            ^^^^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected type `core::ffi::VaListImpl<'_>`\n-              found type `core::ffi::VaListImpl<'_>`\n-note: the anonymous lifetime #2 defined on the function body at 32:1...\n-  --> $DIR/variadic-ffi-4.rs:32:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     *ap0 = ap1.clone();\n-LL | |\n-LL | | }\n-   | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #3 defined on the function body at 32:1\n-  --> $DIR/variadic-ffi-4.rs:32:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     *ap0 = ap1.clone();\n-LL | |\n LL | | }\n    | |_^\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 8 previous errors\n \n-Some errors have detailed explanations: E0308, E0621.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c832e09ac1118deec04a4dfbdb1afe000be16b34", "filename": "src/test/ui/error-codes/E0617.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Ferror-codes%2FE0617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Ferror-codes%2FE0617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0617.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-linelength\n-\n extern {\n     fn printf(c: *const i8, ...);\n }\n@@ -22,7 +20,7 @@ fn main() {\n         //~^ ERROR can't pass `u16` to variadic function\n         //~| HELP cast the value to `c_uint`\n         printf(::std::ptr::null(), printf);\n-        //~^ ERROR can't pass `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaListImpl<'r>, ...) {printf}` to variadic function\n-        //~| HELP cast the value to `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaListImpl<'r>, ...)`\n+        //~^ ERROR can't pass `unsafe extern \"C\" fn(*const i8, ...) {printf}` to variadic function\n+        //~| HELP cast the value to `unsafe extern \"C\" fn(*const i8, ...)`\n     }\n }"}, {"sha": "7c4df099d0dd144060ec8c54507f24ca7d6c2f14", "filename": "src/test/ui/error-codes/E0617.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Ferror-codes%2FE0617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Ferror-codes%2FE0617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0617.stderr?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -1,42 +1,42 @@\n error[E0617]: can't pass `f32` to variadic function\n-  --> $DIR/E0617.rs:9:36\n+  --> $DIR/E0617.rs:7:36\n    |\n LL |         printf(::std::ptr::null(), 0f32);\n    |                                    ^^^^ help: cast the value to `c_double`: `0f32 as c_double`\n \n error[E0617]: can't pass `i8` to variadic function\n-  --> $DIR/E0617.rs:12:36\n+  --> $DIR/E0617.rs:10:36\n    |\n LL |         printf(::std::ptr::null(), 0i8);\n    |                                    ^^^ help: cast the value to `c_int`: `0i8 as c_int`\n \n error[E0617]: can't pass `i16` to variadic function\n-  --> $DIR/E0617.rs:15:36\n+  --> $DIR/E0617.rs:13:36\n    |\n LL |         printf(::std::ptr::null(), 0i16);\n    |                                    ^^^^ help: cast the value to `c_int`: `0i16 as c_int`\n \n error[E0617]: can't pass `u8` to variadic function\n-  --> $DIR/E0617.rs:18:36\n+  --> $DIR/E0617.rs:16:36\n    |\n LL |         printf(::std::ptr::null(), 0u8);\n    |                                    ^^^ help: cast the value to `c_uint`: `0u8 as c_uint`\n \n error[E0617]: can't pass `u16` to variadic function\n-  --> $DIR/E0617.rs:21:36\n+  --> $DIR/E0617.rs:19:36\n    |\n LL |         printf(::std::ptr::null(), 0u16);\n    |                                    ^^^^ help: cast the value to `c_uint`: `0u16 as c_uint`\n \n-error[E0617]: can't pass `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaListImpl<'r>, ...) {printf}` to variadic function\n-  --> $DIR/E0617.rs:24:36\n+error[E0617]: can't pass `unsafe extern \"C\" fn(*const i8, ...) {printf}` to variadic function\n+  --> $DIR/E0617.rs:22:36\n    |\n LL |         printf(::std::ptr::null(), printf);\n    |                                    ^^^^^^\n-help: cast the value to `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaListImpl<'r>, ...)`\n+help: cast the value to `unsafe extern \"C\" fn(*const i8, ...)`\n    |\n-LL |         printf(::std::ptr::null(), printf as for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaListImpl<'r>, ...));\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         printf(::std::ptr::null(), printf as unsafe extern \"C\" fn(*const i8, ...));\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "a3d966bb0b0356c8f5daaa913c8ede2fd90cb7c0", "filename": "src/test/ui/symbol-names/impl1.legacy.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -46,26 +46,26 @@ error: def-path(bar::<impl foo::Foo>::baz)\n LL |         #[rustc_def_path]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: symbol-name(_ZN198_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17h6f205aef6a8ccc7bE)\n-  --> $DIR/impl1.rs:63:13\n+error: symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17h059bf53000885489E)\n+  --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method::h6f205aef6a8ccc7b)\n-  --> $DIR/impl1.rs:63:13\n+error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method::h059bf53000885489)\n+  --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling-alt(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method)\n-  --> $DIR/impl1.rs:63:13\n+error: demangling-alt(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method)\n+  --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n-  --> $DIR/impl1.rs:70:13\n+error: def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8, ...)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n+  --> $DIR/impl1.rs:68:13\n    |\n LL |             #[rustc_def_path]\n    |             ^^^^^^^^^^^^^^^^^"}, {"sha": "add0d10ea6cb0aed76ee4fdd871b89210dd781da", "filename": "src/test/ui/symbol-names/impl1.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -57,19 +57,17 @@ fn main() {\n         }\n \n         // Test type mangling, by putting them in an `impl` header.\n-        // FIXME(eddyb) test C varargs when `core::ffi::VaListImpl` stops leaking into the signature\n-        // (which is a problem because `core` has an unpredictable hash) - see also #44930.\n-        impl Bar for [&'_ (dyn Foo<Assoc = extern fn(&u8, /*...*/)> + AutoTrait); 3] {\n+        impl Bar for [&'_ (dyn Foo<Assoc = extern fn(&u8, ...)> + AutoTrait); 3] {\n             #[rustc_symbol_name]\n-            //[legacy]~^ ERROR symbol-name(_ZN198_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method\n-            //[legacy]~| ERROR demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method\n-            //[legacy]~| ERROR demangling-alt(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method)\n-             //[v0]~^^^^ ERROR symbol-name(_RNvXNCNvCs4fqI2P2rA04_5impl14mains_0ARDNtB6_3Foop5AssocFG_KCRL0_hEuNtB6_9AutoTraitEL_j3_NtB2_3Bar6method)\n-                //[v0]~| ERROR demangling(<[&dyn impl1[317d481089b8c8fe]::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8)> + impl1[317d481089b8c8fe]::AutoTrait; 3: usize] as impl1[317d481089b8c8fe]::main::{closure#1}::Bar>::method)\n-                //[v0]~| ERROR demangling-alt(<[&dyn impl1::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8)> + impl1::AutoTrait; 3] as impl1::main::{closure#1}::Bar>::method)\n+            //[legacy]~^ ERROR symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method\n+            //[legacy]~| ERROR demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method\n+            //[legacy]~| ERROR demangling-alt(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method)\n+             //[v0]~^^^^ ERROR symbol-name(_RNvXNCNvCs4fqI2P2rA04_5impl14mains_0ARDNtB6_3Foop5AssocFG_KCRL0_hvEuNtB6_9AutoTraitEL_j3_NtB2_3Bar6method)\n+                //[v0]~| ERROR demangling(<[&dyn impl1[317d481089b8c8fe]::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8, ...)> + impl1[317d481089b8c8fe]::AutoTrait; 3: usize] as impl1[317d481089b8c8fe]::main::{closure#1}::Bar>::method)\n+                //[v0]~| ERROR demangling-alt(<[&dyn impl1::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8, ...)> + impl1::AutoTrait; 3] as impl1::main::{closure#1}::Bar>::method)\n             #[rustc_def_path]\n-            //[legacy]~^ ERROR def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n-               //[v0]~^^ ERROR def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n+            //[legacy]~^ ERROR def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8, ...)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n+               //[v0]~^^ ERROR def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8, ...)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n             fn method(&self) {}\n         }\n     };"}, {"sha": "01fe39ddf6cf9310c3f2529bb440088c22d40583", "filename": "src/test/ui/symbol-names/impl1.v0.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.v0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f7e0e5350a431e00e72cfd00df2669f94fe06/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.v0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.v0.stderr?ref=fe2f7e0e5350a431e00e72cfd00df2669f94fe06", "patch": "@@ -46,26 +46,26 @@ error: def-path(bar::<impl foo::Foo>::baz)\n LL |         #[rustc_def_path]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: symbol-name(_RNvXNCNvCs4fqI2P2rA04_5impl14mains_0ARDNtB6_3Foop5AssocFG_KCRL0_hEuNtB6_9AutoTraitEL_j3_NtB2_3Bar6method)\n-  --> $DIR/impl1.rs:63:13\n+error: symbol-name(_RNvXNCNvCs4fqI2P2rA04_5impl14mains_0ARDNtB6_3Foop5AssocFG_KCRL0_hvEuNtB6_9AutoTraitEL_j3_NtB2_3Bar6method)\n+  --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(<[&dyn impl1[317d481089b8c8fe]::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8)> + impl1[317d481089b8c8fe]::AutoTrait; 3: usize] as impl1[317d481089b8c8fe]::main::{closure#1}::Bar>::method)\n-  --> $DIR/impl1.rs:63:13\n+error: demangling(<[&dyn impl1[317d481089b8c8fe]::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8, ...)> + impl1[317d481089b8c8fe]::AutoTrait; 3: usize] as impl1[317d481089b8c8fe]::main::{closure#1}::Bar>::method)\n+  --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling-alt(<[&dyn impl1::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8)> + impl1::AutoTrait; 3] as impl1::main::{closure#1}::Bar>::method)\n-  --> $DIR/impl1.rs:63:13\n+error: demangling-alt(<[&dyn impl1::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8, ...)> + impl1::AutoTrait; 3] as impl1::main::{closure#1}::Bar>::method)\n+  --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n-  --> $DIR/impl1.rs:70:13\n+error: def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8, ...)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n+  --> $DIR/impl1.rs:68:13\n    |\n LL |             #[rustc_def_path]\n    |             ^^^^^^^^^^^^^^^^^"}]}