{"sha": "10b3595ba6a4c658c9dea105488fc562c815e434", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYjM1OTViYTZhNGM2NThjOWRlYTEwNTQ4OGZjNTYyYzgxNWU0MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-20T06:20:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-20T06:20:16Z"}, "message": "Auto merge of #76411 - RalfJung:promote-in-const-fn, r=ecstatic-morse\n\nSome promotion cleanup\n\nBased on top of both https://github.com/rust-lang/rust/pull/75502 and https://github.com/rust-lang/rust/pull/75585, this does some cleanup of the promotion code. The last 2 commits are new.\n\n* Remove the remaining cases where `const fn` is treated different from `fn`. This means no longer promoting ptr-to-int casts, raw ptr operations, and union field accesses in `const fn` -- or anywhere, for that matter. These are all unstable in const-context so this should not break any stable code. Fixes https://github.com/rust-lang/rust/issues/75586.\n* ~~Promote references to statics even outside statics (i.e., in functions) for consistency.~~\n* Promote `&mut []` everywhere, not just in non-`const` functions, for consistency.\n* Explain why we do not promote deref's of statics outside statics. ~~(This is the only remaining direct user of `const_kind`.)~~\n\nThis can only land once the other two PRs land; I am mostly putting this up already because I couldn't wait ;) and to get some feedback from `@rust-lang/wg-const-eval` .", "tree": {"sha": "a046e0f117492c34779ca4293f4c10d4fd66c9f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a046e0f117492c34779ca4293f4c10d4fd66c9f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10b3595ba6a4c658c9dea105488fc562c815e434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10b3595ba6a4c658c9dea105488fc562c815e434", "html_url": "https://github.com/rust-lang/rust/commit/10b3595ba6a4c658c9dea105488fc562c815e434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10b3595ba6a4c658c9dea105488fc562c815e434/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "html_url": "https://github.com/rust-lang/rust/commit/a3bc0e752fad96f537b73f4e9bc805a73d404f7b"}, {"sha": "9216eb825839ecd17d67c2731537e5d6afffc54a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9216eb825839ecd17d67c2731537e5d6afffc54a", "html_url": "https://github.com/rust-lang/rust/commit/9216eb825839ecd17d67c2731537e5d6afffc54a"}], "stats": {"total": 131, "additions": 90, "deletions": 41}, "files": [{"sha": "37202276161c7424e41b26aff9f0d9ba7ae08b65", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/10b3595ba6a4c658c9dea105488fc562c815e434/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b3595ba6a4c658c9dea105488fc562c815e434/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=10b3595ba6a4c658c9dea105488fc562c815e434", "patch": "@@ -297,6 +297,17 @@ impl std::ops::Deref for Validator<'a, 'tcx> {\n struct Unpromotable;\n \n impl<'tcx> Validator<'_, 'tcx> {\n+    /// Determines if this code could be executed at runtime and thus is subject to codegen.\n+    /// That means even unused constants need to be evaluated.\n+    ///\n+    /// `const_kind` should not be used in this file other than through this method!\n+    fn maybe_runtime(&self) -> bool {\n+        match self.const_kind {\n+            None | Some(hir::ConstContext::ConstFn) => true,\n+            Some(hir::ConstContext::Static(_) | hir::ConstContext::Const) => false,\n+        }\n+    }\n+\n     fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n         match candidate {\n             Candidate::Ref(loc) => {\n@@ -363,12 +374,10 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n-                            // is allowed right now, and only in functions.\n+                            // is allowed right now.\n                             if let ty::Array(_, len) = ty.kind() {\n-                                // FIXME(eddyb) the `self.is_non_const_fn` condition\n-                                // seems unnecessary, given that this is merely a ZST.\n                                 match len.try_eval_usize(self.tcx, self.param_env) {\n-                                    Some(0) if self.const_kind.is_none() => {}\n+                                    Some(0) => {}\n                                     _ => return Err(Unpromotable),\n                                 }\n                             } else {\n@@ -495,9 +504,10 @@ impl<'tcx> Validator<'_, 'tcx> {\n         match place {\n             PlaceRef { local, projection: [] } => self.validate_local(local),\n             PlaceRef { local, projection: [proj_base @ .., elem] } => {\n+                // Validate topmost projection, then recurse.\n                 match *elem {\n                     ProjectionElem::Deref => {\n-                        let mut not_promotable = true;\n+                        let mut promotable = false;\n                         // This is a special treatment for cases like *&STATIC where STATIC is a\n                         // global static variable.\n                         // This pattern is generated only when global static variables are directly\n@@ -512,6 +522,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             }) = def_stmt\n                             {\n                                 if let Some(did) = c.check_static_ptr(self.tcx) {\n+                                    // Evaluating a promoted may not read statics except if it got\n+                                    // promoted from a static (this is a CTFE check). So we\n+                                    // can only promote static accesses inside statics.\n                                     if let Some(hir::ConstContext::Static(..)) = self.const_kind {\n                                         // The `is_empty` predicate is introduced to exclude the case\n                                         // where the projection operations are [ .field, * ].\n@@ -524,13 +537,13 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                         if proj_base.is_empty()\n                                             && !self.tcx.is_thread_local_static(did)\n                                         {\n-                                            not_promotable = false;\n+                                            promotable = true;\n                                         }\n                                     }\n                                 }\n                             }\n                         }\n-                        if not_promotable {\n+                        if !promotable {\n                             return Err(Unpromotable);\n                         }\n                     }\n@@ -545,7 +558,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n \n                     ProjectionElem::Field(..) => {\n-                        if self.const_kind.is_none() {\n+                        if self.maybe_runtime() {\n                             let base_ty =\n                                 Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n@@ -573,6 +586,10 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 if let Some(def_id) = c.check_static_ptr(self.tcx) {\n                     // Only allow statics (not consts) to refer to other statics.\n                     // FIXME(eddyb) does this matter at all for promotion?\n+                    // FIXME(RalfJung) it makes little sense to not promote this in `fn`/`const fn`,\n+                    // and in `const` this cannot occur anyway. The only concern is that we might\n+                    // promote even `let x = &STATIC` which would be useless, but this applies to\n+                    // promotion inside statics as well.\n                     let is_static = matches!(self.const_kind, Some(hir::ConstContext::Static(_)));\n                     if !is_static {\n                         return Err(Unpromotable);\n@@ -591,20 +608,20 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n-                        // in normal functions, mark such casts as not promotable\n+                        // ptr-to-int casts are not possible in consts and thus not promotable\n                         return Err(Unpromotable);\n                     }\n                     _ => {}\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n+            Rvalue::BinaryOp(op, ref lhs, _) => {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n                     assert!(\n                         op == BinOp::Eq\n@@ -616,13 +633,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             || op == BinOp::Offset\n                     );\n \n-                    // raw pointer operations are not allowed inside promoteds\n+                    // raw pointer operations are not allowed inside consts and thus not promotable\n                     return Err(Unpromotable);\n                 }\n             }\n \n             Rvalue::NullaryOp(NullOp::Box, _) => return Err(Unpromotable),\n \n+            // FIXME(RalfJung): the rest is *implicitly considered promotable*... that seems dangerous.\n             _ => {}\n         }\n \n@@ -644,8 +662,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::AddressOf(_, place) => {\n-                // Raw reborrows can come from reference to pointer coercions,\n-                // so are allowed.\n+                // We accept `&raw *`, i.e., raw reborrows -- creating a raw pointer is\n+                // no problem, only using it is.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n                     let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind() {\n@@ -664,12 +682,10 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n-                    // is allowed right now, and only in functions.\n+                    // is allowed right now.\n                     if let ty::Array(_, len) = ty.kind() {\n-                        // FIXME(eddyb): We only return `Unpromotable` for `&mut []` inside a\n-                        // const context which seems unnecessary given that this is merely a ZST.\n                         match len.try_eval_usize(self.tcx, self.param_env) {\n-                            Some(0) if self.const_kind.is_none() => {}\n+                            Some(0) => {}\n                             _ => return Err(Unpromotable),\n                         }\n                     } else {\n@@ -734,14 +750,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     ) -> Result<(), Unpromotable> {\n         let fn_ty = callee.ty(self.body, self.tcx);\n \n-        // `const` and `static` use the explicit rules for promotion regardless of the `Candidate`,\n-        // meaning calls to `const fn` can be promoted.\n-        let context_uses_explicit_promotion_rules = matches!(\n-            self.const_kind,\n-            Some(hir::ConstContext::Static(_) | hir::ConstContext::Const)\n-        );\n-\n-        if !self.explicit && !context_uses_explicit_promotion_rules {\n+        if !self.explicit && self.maybe_runtime() {\n             if let ty::FnDef(def_id, _) = *fn_ty.kind() {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`."}, {"sha": "fb57c8bb93458d535413e86fd016733665bd306b", "filename": "src/test/ui/consts/promote-no-mut.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3bc0e752fad96f537b73f4e9bc805a73d404f7b/src%2Ftest%2Fui%2Fconsts%2Fpromote-no-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3bc0e752fad96f537b73f4e9bc805a73d404f7b/src%2Ftest%2Fui%2Fconsts%2Fpromote-no-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote-no-mut.rs?ref=a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "patch": "@@ -1,10 +0,0 @@\n-// ignore-tidy-linelength\n-// We do not promote mutable references.\n-static mut TEST1: Option<&mut [i32]> = Some(&mut [1, 2, 3]); //~ ERROR temporary value dropped while borrowed\n-\n-static mut TEST2: &'static mut [i32] = {\n-    let x = &mut [1,2,3]; //~ ERROR temporary value dropped while borrowed\n-    x\n-};\n-\n-fn main() {}"}, {"sha": "8daac7583773451b9ae8d2340cefc4fea249a4f7", "filename": "src/test/ui/consts/promote-not.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/10b3595ba6a4c658c9dea105488fc562c815e434/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b3595ba6a4c658c9dea105488fc562c815e434/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.rs?ref=10b3595ba6a4c658c9dea105488fc562c815e434", "patch": "@@ -0,0 +1,30 @@\n+// ignore-tidy-linelength\n+// Test various things that we do not want to promote.\n+#![allow(unconditional_panic, const_err)]\n+#![feature(const_fn, const_fn_union)]\n+\n+// We do not promote mutable references.\n+static mut TEST1: Option<&mut [i32]> = Some(&mut [1, 2, 3]); //~ ERROR temporary value dropped while borrowed\n+\n+static mut TEST2: &'static mut [i32] = {\n+    let x = &mut [1,2,3]; //~ ERROR temporary value dropped while borrowed\n+    x\n+};\n+\n+// We do not promote fn calls in `fn`, including `const fn`.\n+pub const fn promote_cal(b: bool) -> i32 {\n+    const fn foo() { [()][42] }\n+\n+    if b {\n+        let _x: &'static () = &foo(); //~ ERROR temporary value dropped while borrowed\n+    }\n+    13\n+}\n+\n+// We do not promote union field accesses in `fn.\n+union U { x: i32, y: i32 }\n+pub const fn promote_union() {\n+    let _x: &'static i32 = &unsafe { U { x: 0 }.x }; //~ ERROR temporary value dropped while borrowed\n+}\n+\n+fn main() {}"}, {"sha": "efe921b601104a60b17d2167b1e7b37b8f70dfbd", "filename": "src/test/ui/consts/promote-not.stderr", "status": "renamed", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/10b3595ba6a4c658c9dea105488fc562c815e434/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10b3595ba6a4c658c9dea105488fc562c815e434/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.stderr?ref=10b3595ba6a4c658c9dea105488fc562c815e434", "patch": "@@ -1,5 +1,5 @@\n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promote-no-mut.rs:3:50\n+  --> $DIR/promote-not.rs:7:50\n    |\n LL | static mut TEST1: Option<&mut [i32]> = Some(&mut [1, 2, 3]);\n    |                                        ----------^^^^^^^^^-\n@@ -9,7 +9,7 @@ LL | static mut TEST1: Option<&mut [i32]> = Some(&mut [1, 2, 3]);\n    |                                        using this value as a static requires that borrow lasts for `'static`\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promote-no-mut.rs:6:18\n+  --> $DIR/promote-not.rs:10:18\n    |\n LL |     let x = &mut [1,2,3];\n    |                  ^^^^^^^ creates a temporary which is freed while still in use\n@@ -18,6 +18,26 @@ LL |     x\n LL | };\n    | - temporary value is freed at the end of this statement\n \n-error: aborting due to 2 previous errors\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/promote-not.rs:19:32\n+   |\n+LL |         let _x: &'static () = &foo();\n+   |                 -----------    ^^^^^ creates a temporary which is freed while still in use\n+   |                 |\n+   |                 type annotation requires that borrow lasts for `'static`\n+LL |     }\n+   |     - temporary value is freed at the end of this statement\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/promote-not.rs:27:29\n+   |\n+LL |     let _x: &'static i32 = &unsafe { U { x: 0 }.x };\n+   |             ------------    ^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+   |             |\n+   |             type annotation requires that borrow lasts for `'static`\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0716`.", "previous_filename": "src/test/ui/consts/promote-no-mut.stderr"}, {"sha": "5f84030a9e96b4d0f68afaca43b23b5bd353dca2", "filename": "src/test/ui/consts/promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b3595ba6a4c658c9dea105488fc562c815e434/src%2Ftest%2Fui%2Fconsts%2Fpromotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b3595ba6a4c658c9dea105488fc562c815e434/src%2Ftest%2Fui%2Fconsts%2Fpromotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromotion.rs?ref=10b3595ba6a4c658c9dea105488fc562c815e434", "patch": "@@ -1,4 +1,4 @@\n-// run-pass\n+// check-pass\n \n // compile-flags: -O\n "}, {"sha": "b9eff469177e6e62acc0a2c98cfc7c270b850c42", "filename": "src/test/ui/statics/static-promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b3595ba6a4c658c9dea105488fc562c815e434/src%2Ftest%2Fui%2Fstatics%2Fstatic-promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b3595ba6a4c658c9dea105488fc562c815e434/src%2Ftest%2Fui%2Fstatics%2Fstatic-promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Fstatic-promotion.rs?ref=10b3595ba6a4c658c9dea105488fc562c815e434", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// run-pass\n \n // Use of global static variables in literal values should be allowed for\n // promotion."}]}