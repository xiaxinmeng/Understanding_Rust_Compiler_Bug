{"sha": "bb9da7a0edc60991e14b7e8c738e5d8ae3661512", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiOWRhN2EwZWRjNjA5OTFlMTRiN2U4YzczOGU1ZDhhZTM2NjE1MTI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-08T20:15:18Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-10T13:27:51Z"}, "message": "BTreeMap: fix gdb introspection of BTreeMap with ZST keys or values", "tree": {"sha": "beac1ed0a9e67f68954ffb680a105717754ae278", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beac1ed0a9e67f68954ffb680a105717754ae278"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb9da7a0edc60991e14b7e8c738e5d8ae3661512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb9da7a0edc60991e14b7e8c738e5d8ae3661512", "html_url": "https://github.com/rust-lang/rust/commit/bb9da7a0edc60991e14b7e8c738e5d8ae3661512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb9da7a0edc60991e14b7e8c738e5d8ae3661512/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efbaa413061c2a6e52f06f00a60ee7830fcf3ea5", "url": "https://api.github.com/repos/rust-lang/rust/commits/efbaa413061c2a6e52f06f00a60ee7830fcf3ea5", "html_url": "https://github.com/rust-lang/rust/commit/efbaa413061c2a6e52f06f00a60ee7830fcf3ea5"}], "stats": {"total": 79, "additions": 43, "deletions": 36}, "files": [{"sha": "b2d343fd7af6a7105198d6120e643457fcd31f2c", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bb9da7a0edc60991e14b7e8c738e5d8ae3661512/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/bb9da7a0edc60991e14b7e8c738e5d8ae3661512/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=bb9da7a0edc60991e14b7e8c738e5d8ae3661512", "patch": "@@ -207,30 +207,46 @@ def children(self):\n         yield \"borrow\", self.borrow\n \n \n-# Yield each key (and optionally value) from a BoxedNode.\n-def children_of_node(boxed_node, height, want_values):\n+# Yields children (in a provider's sense of the word) for a tree headed by a BoxedNode.\n+# In particular, yields each key/value pair in the node and in any child nodes.\n+def children_of_node(boxed_node, height):\n     def cast_to_internal(node):\n-        internal_type_name = str(node.type.target()).replace(\"LeafNode\", \"InternalNode\", 1)\n+        internal_type_name = node.type.target().name.replace(\"LeafNode\", \"InternalNode\", 1)\n         internal_type = lookup_type(internal_type_name)\n         return node.cast(internal_type.pointer())\n \n     node_ptr = unwrap_unique_or_non_null(boxed_node[\"ptr\"])\n-    node_ptr = cast_to_internal(node_ptr) if height > 0 else node_ptr\n-    leaf = node_ptr[\"data\"] if height > 0 else node_ptr.dereference()\n+    leaf = node_ptr.dereference()\n     keys = leaf[\"keys\"]\n-    values = leaf[\"vals\"]\n+    vals = leaf[\"vals\"]\n+    edges = cast_to_internal(node_ptr)[\"edges\"] if height > 0 else None\n     length = int(leaf[\"len\"])\n \n     for i in xrange(0, length + 1):\n         if height > 0:\n-            child_ptr = node_ptr[\"edges\"][i][\"value\"][\"value\"]\n-            for child in children_of_node(child_ptr, height - 1, want_values):\n+            boxed_child_node = edges[i][\"value\"][\"value\"]\n+            for child in children_of_node(boxed_child_node, height - 1):\n                 yield child\n         if i < length:\n-            if want_values:\n-                yield keys[i][\"value\"][\"value\"], values[i][\"value\"][\"value\"]\n-            else:\n-                yield keys[i][\"value\"][\"value\"]\n+            # Avoid \"Cannot perform pointer math on incomplete type\" on zero-sized arrays.\n+            key = keys[i][\"value\"][\"value\"] if keys.type.sizeof > 0 else None\n+            val = vals[i][\"value\"][\"value\"] if vals.type.sizeof > 0 else None\n+            yield key, val\n+\n+\n+# Yields children for a BTreeMap.\n+def children_of_map(map):\n+    if map[\"length\"] > 0:\n+        root = map[\"root\"]\n+        if root.type.name.startswith(\"core::option::Option<\"):\n+            root = root.cast(gdb.lookup_type(root.type.name[21:-1]))\n+        boxed_root_node = root[\"node\"]\n+        height = root[\"height\"]\n+        for i, (key, val) in enumerate(children_of_node(boxed_root_node, height)):\n+            if key is not None:\n+                yield \"key{}\".format(i), key\n+            if val is not None:\n+                yield \"val{}\".format(i), val\n \n \n class StdBTreeSetProvider:\n@@ -242,15 +258,8 @@ def to_string(self):\n \n     def children(self):\n         inner_map = self.valobj[\"map\"]\n-        if inner_map[\"length\"] > 0:\n-            root = inner_map[\"root\"]\n-            if \"core::option::Option<\" in root.type.name:\n-                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n-                root = root.cast(gdb.lookup_type(type_name))\n-\n-            node_ptr = root[\"node\"]\n-            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], False)):\n-                yield \"[{}]\".format(i), child\n+        for child in children_of_map(inner_map):\n+            yield child\n \n     @staticmethod\n     def display_hint():\n@@ -265,16 +274,8 @@ def to_string(self):\n         return \"BTreeMap(size={})\".format(self.valobj[\"length\"])\n \n     def children(self):\n-        if self.valobj[\"length\"] > 0:\n-            root = self.valobj[\"root\"]\n-            if \"core::option::Option<\" in root.type.name:\n-                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n-                root = root.cast(gdb.lookup_type(type_name))\n-\n-            node_ptr = root[\"node\"]\n-            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], True)):\n-                yield \"key{}\".format(i), child[0]\n-                yield \"val{}\".format(i), child[1]\n+        for child in children_of_map(self.valobj):\n+            yield child\n \n     @staticmethod\n     def display_hint():"}, {"sha": "c6d2090759ff2248f226aa495ee3a3c19ccb6263", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb9da7a0edc60991e14b7e8c738e5d8ae3661512/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9da7a0edc60991e14b7e8c738e5d8ae3661512/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=bb9da7a0edc60991e14b7e8c738e5d8ae3661512", "patch": "@@ -34,17 +34,20 @@\n // gdb-check:$6 = BTreeMap(size=15) = {[0] = pretty_std_collections::MyLeafNode (0), [...]}\n // (abbreviated because it's boring but we need enough elements to include internal nodes)\n \n+// gdb-command: print zst_btree_map\n+// gdb-check:$7 = BTreeMap(size=1)\n+\n // gdb-command: print vec_deque\n-// gdb-check:$7 = VecDeque(size=3) = {5, 3, 7}\n+// gdb-check:$8 = VecDeque(size=3) = {5, 3, 7}\n \n // gdb-command: print vec_deque2\n-// gdb-check:$8 = VecDeque(size=7) = {2, 3, 4, 5, 6, 7, 8}\n+// gdb-check:$9 = VecDeque(size=7) = {2, 3, 4, 5, 6, 7, 8}\n \n // gdb-command: print hash_map\n-// gdb-check:$9 = HashMap(size=4) = {[1] = 10, [2] = 20, [3] = 30, [4] = 40}\n+// gdb-check:$10 = HashMap(size=4) = {[1] = 10, [2] = 20, [3] = 30, [4] = 40}\n \n // gdb-command: print hash_set\n-// gdb-check:$10 = HashSet(size=4) = {1, 2, 3, 4}\n+// gdb-check:$11 = HashSet(size=4) = {1, 2, 3, 4}\n \n // === LLDB TESTS ==================================================================================\n \n@@ -69,9 +72,9 @@\n #![allow(unused_variables)]\n use std::collections::BTreeMap;\n use std::collections::BTreeSet;\n-use std::collections::VecDeque;\n use std::collections::HashMap;\n use std::collections::HashSet;\n+use std::collections::VecDeque;\n use std::hash::{BuildHasherDefault, Hasher};\n \n struct MyLeafNode(i32); // helps to ensure we don't blindly replace substring \"LeafNode\"\n@@ -111,6 +114,9 @@ fn main() {\n         nasty_btree_map.insert(i, MyLeafNode(i));\n     }\n \n+    let mut zst_btree_map: BTreeMap<(), ()> = BTreeMap::new();\n+    zst_btree_map.insert((), ());\n+\n     // VecDeque\n     let mut vec_deque = VecDeque::new();\n     vec_deque.push_back(5);"}]}