{"sha": "03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYTkyYjYxZWM4M2M2YmQzN2NiYjc1MjdjZTVkYTY4YjZkMjQ3YTk=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-20T22:30:00Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-24T18:48:13Z"}, "message": "Eliminate the `Pointer` wrapper type", "tree": {"sha": "56a92da8f15a532a4d8bfeab4cc0ab605798bbea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56a92da8f15a532a4d8bfeab4cc0ab605798bbea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "html_url": "https://github.com/rust-lang/rust/commit/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6436de89fe6c3051bc6aecd02fb8601cfd9c0597", "url": "https://api.github.com/repos/rust-lang/rust/commits/6436de89fe6c3051bc6aecd02fb8601cfd9c0597", "html_url": "https://github.com/rust-lang/rust/commit/6436de89fe6c3051bc6aecd02fb8601cfd9c0597"}], "stats": {"total": 181, "additions": 74, "deletions": 107}, "files": [{"sha": "f568bba57b630f233814692ac197abe2b10fecbd", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -473,8 +473,6 @@ impl_stable_hash_for!(enum ::syntax::ast::Mutability {\n     Mutable\n });\n \n-impl_stable_hash_for!(struct mir::interpret::Pointer{primval});\n-\n impl_stable_hash_for!(enum mir::interpret::Scalar {\n     Bytes(b),\n     Ptr(p),"}, {"sha": "5a5aea0f7512a68b47397bc2d114354cd8c4a693", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -10,7 +10,7 @@ mod value;\n \n pub use self::error::{EvalError, EvalResult, EvalErrorKind, AssertMessage};\n \n-pub use self::value::{Scalar, ScalarKind, Value, Pointer, ConstValue};\n+pub use self::value::{Scalar, ScalarKind, Value, ConstValue};\n \n use std::fmt;\n use mir;"}, {"sha": "293fa800902322b982edc7de06615f7e944c590c", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 22, "deletions": 52, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> ConstValue<'tcx> {\n /// operations and fat pointers. This idea was taken from rustc's codegen.\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n pub enum Value {\n-    ByRef(Pointer, Align),\n+    ByRef(Scalar, Align),\n     Scalar(Scalar),\n     ScalarPair(Scalar, Scalar),\n }\n@@ -92,101 +92,71 @@ impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n     }\n }\n \n-/// A wrapper type around `Scalar` that cannot be turned back into a `Scalar` accidentally.\n-/// This type clears up a few APIs where having a `Scalar` argument for something that is\n-/// potentially an integer pointer or a pointer to an allocation was unclear.\n-///\n-/// I (@oli-obk) believe it is less easy to mix up generic primvals and primvals that are just\n-/// the representation of pointers. Also all the sites that convert between primvals and pointers\n-/// are explicit now (and rare!)\n-#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub struct Pointer {\n-    pub primval: Scalar,\n-}\n-\n-impl<'tcx> Pointer {\n-    pub fn null() -> Self {\n-        Scalar::Bytes(0).into()\n-    }\n-    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n-        self.primval.to_ptr()\n-    }\n-    pub fn into_inner_primval(self) -> Scalar {\n-        self.primval\n+impl<'tcx> Scalar {\n+    pub fn ptr_null() -> Self {\n+        Scalar::Bytes(0)\n     }\n \n-    pub fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n-        match self.primval {\n+        match self {\n             Scalar::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(\n-                    Scalar::Bytes(layout.signed_offset(b as u64, i)? as u128),\n-                ))\n+                Ok(Scalar::Bytes(layout.signed_offset(b as u64, i)? as u128))\n             }\n-            Scalar::Ptr(ptr) => ptr.signed_offset(i, layout).map(Pointer::from),\n+            Scalar::Ptr(ptr) => ptr.signed_offset(i, layout).map(Scalar::Ptr),\n             Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n-    pub fn offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n-        match self.primval {\n+        match self {\n             Scalar::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(\n-                    Scalar::Bytes(layout.offset(b as u64, i.bytes())? as u128),\n-                ))\n+                Ok(Scalar::Bytes(layout.offset(b as u64, i.bytes())? as u128))\n             }\n-            Scalar::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n+            Scalar::Ptr(ptr) => ptr.offset(i, layout).map(Scalar::Ptr),\n             Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n-    pub fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n-        match self.primval {\n+        match self {\n             Scalar::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(Scalar::Bytes(\n-                    layout.wrapping_signed_offset(b as u64, i) as u128,\n-                )))\n+                Ok(Scalar::Bytes(layout.wrapping_signed_offset(b as u64, i) as u128))\n             }\n-            Scalar::Ptr(ptr) => Ok(Pointer::from(ptr.wrapping_signed_offset(i, layout))),\n+            Scalar::Ptr(ptr) => Ok(Scalar::Ptr(ptr.wrapping_signed_offset(i, layout))),\n             Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn is_null(self) -> EvalResult<'tcx, bool> {\n-        match self.primval {\n+        match self {\n             Scalar::Bytes(b) => Ok(b == 0),\n             Scalar::Ptr(_) => Ok(false),\n             Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn to_value_with_len(self, len: u64) -> Value {\n-        Value::ScalarPair(self.primval, Scalar::from_u128(len as u128))\n+        Value::ScalarPair(self, Scalar::from_u128(len as u128))\n     }\n \n     pub fn to_value_with_vtable(self, vtable: MemoryPointer) -> Value {\n-        Value::ScalarPair(self.primval, Scalar::Ptr(vtable))\n+        Value::ScalarPair(self, Scalar::Ptr(vtable))\n     }\n \n     pub fn to_value(self) -> Value {\n-        Value::Scalar(self.primval)\n-    }\n-}\n-\n-impl ::std::convert::From<Scalar> for Pointer {\n-    fn from(primval: Scalar) -> Self {\n-        Pointer { primval }\n+        Value::Scalar(self)\n     }\n }\n \n-impl ::std::convert::From<MemoryPointer> for Pointer {\n+impl From<MemoryPointer> for Scalar {\n     fn from(ptr: MemoryPointer) -> Self {\n-        Scalar::Ptr(ptr).into()\n+        Scalar::Ptr(ptr)\n     }\n }\n "}, {"sha": "0b861884f3771ae18083c33af00ac24d5c436b62", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -96,7 +96,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(primval_to_llvm(\n             cx,\n-            Scalar::Ptr(MemoryPointer { alloc_id, offset: Size::from_bytes(ptr_offset) }),\n+            MemoryPointer { alloc_id, offset: Size::from_bytes(ptr_offset) }.into(),\n             &layout::Scalar {\n                 value: layout::Primitive::Pointer,\n                 valid_range: 0..=!0"}, {"sha": "d4b1deddad8c18fe271fb74b68e1b56afc80b855", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -191,7 +191,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);\n                 let ptr = MemoryPointer::zero(id);\n-                ConstValue::Scalar(Scalar::Ptr(ptr))\n+                ConstValue::Scalar(ptr.into())\n             },\n             LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bytes(n as u128)),\n             LitKind::Int(n, _) if neg => {"}, {"sha": "640bb9d10dd07066af6d5e346f8a2a01918dcd64", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -1137,7 +1137,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n             let ptr = MemoryPointer::zero(id);\n-            ConstValue::Scalar(Scalar::Ptr(ptr))\n+            ConstValue::Scalar(ptr.into())\n         },\n         LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bytes(n as u128)),\n         LitKind::Int(n, _) => {"}, {"sha": "050fe5291b89bf70e8aed3d8e6920b5d155fb4c5", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n             TyRawPtr(_) |\n             TyInt(IntTy::Isize) |\n-            TyUint(UintTy::Usize) => Ok(Scalar::Ptr(ptr)),\n+            TyUint(UintTy::Usize) => Ok(ptr.into()),\n             TyInt(_) | TyUint(_) => err!(ReadPointerAsBytes),\n             _ => err!(Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }"}, {"sha": "729e900492a4e5150d4087bd195daeecdd100c72", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -12,7 +12,7 @@ use syntax::codemap::DUMMY_SP;\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Value, Pointer, Scalar, AllocId, Allocation, ConstValue,\n+    Value, Scalar, AllocId, Allocation, ConstValue,\n };\n use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra, Memory, MemoryKind};\n \n@@ -65,7 +65,7 @@ pub fn eval_promoted<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> Option<(Value, Pointer, Ty<'tcx>)> {\n+) -> Option<(Value, Scalar, Ty<'tcx>)> {\n     ecx.with_fresh_body(|ecx| {\n         let res = eval_body_using_ecx(ecx, cid, Some(mir), param_env);\n         match res {\n@@ -82,7 +82,7 @@ pub fn eval_body<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> Option<(Value, Pointer, Ty<'tcx>)> {\n+) -> Option<(Value, Scalar, Ty<'tcx>)> {\n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, param_env);\n     match res {\n         Ok(val) => Some(val),\n@@ -111,7 +111,7 @@ pub fn value_to_const_value<'tcx>(\n             Value::Scalar(val) => Ok(ConstValue::Scalar(val)),\n             Value::ScalarPair(a, b) => Ok(ConstValue::ScalarPair(a, b)),\n             Value::ByRef(ptr, align) => {\n-                let ptr = ptr.primval.to_ptr().unwrap();\n+                let ptr = ptr.to_ptr().unwrap();\n                 let alloc = ecx.memory.get(ptr.alloc_id)?;\n                 assert!(alloc.align.abi() >= align.abi());\n                 assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= layout.size.bytes());\n@@ -136,7 +136,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n+) -> (EvalResult<'tcx, (Value, Scalar, Ty<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n     debug!(\"eval_body_and_ecx: {:?}, {:?}\", cid, param_env);\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n@@ -152,7 +152,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)> {\n+) -> EvalResult<'tcx, (Value, Scalar, Ty<'tcx>)> {\n     debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let mut mir = match mir {\n@@ -471,8 +471,7 @@ pub fn const_variant_index<'a, 'tcx>(\n     let (ptr, align) = match value {\n         Value::ScalarPair(..) | Value::Scalar(_) => {\n             let layout = ecx.layout_of(ty)?;\n-            let ptr = ecx.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))?;\n-            let ptr: Pointer = ptr.into();\n+            let ptr = ecx.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))?.into();\n             ecx.write_value_to_ptr(value, ptr, layout.align, ty)?;\n             (ptr, layout.align)\n         },"}, {"sha": "938f0ce918ec362d8fb401b1be843dc16ea828cc", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -14,7 +14,7 @@ use rustc::middle::const_val::FrameInfo;\n use syntax::codemap::{self, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n-    GlobalId, Value, Pointer, Scalar, ScalarKind,\n+    GlobalId, Value, Scalar, ScalarKind,\n     EvalError, EvalResult, EvalErrorKind, MemoryPointer, ConstValue,\n };\n use std::mem;\n@@ -596,7 +596,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 // FIXME: speed up repeat filling\n                 for i in 0..length {\n-                    let elem_dest = dest.offset(elem_size * i as u64, &self)?;\n+                    let elem_dest = dest.ptr_offset(elem_size * i as u64, &self)?;\n                     self.write_value_to_ptr(value, elem_dest, dest_align, elem_ty)?;\n                 }\n             }\n@@ -729,7 +729,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                 ).ok_or_else(|| EvalErrorKind::TypeckError.into());\n                                 let fn_ptr = self.memory.create_fn_alloc(instance?);\n                                 let valty = ValTy {\n-                                    value: Value::Scalar(Scalar::Ptr(fn_ptr)),\n+                                    value: Value::Scalar(fn_ptr.into()),\n                                     ty: dest_ty,\n                                 };\n                                 self.write_value(valty, dest)?;\n@@ -765,7 +765,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                 );\n                                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                                 let valty = ValTy {\n-                                    value: Value::Scalar(Scalar::Ptr(fn_ptr)),\n+                                    value: Value::Scalar(fn_ptr.into()),\n                                     ty: dest_ty,\n                                 };\n                                 self.write_value(valty, dest)?;\n@@ -1104,7 +1104,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub fn write_ptr(&mut self, dest: Place, val: Pointer, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n+    pub fn write_ptr(&mut self, dest: Place, val: Scalar, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         let valty = ValTy {\n             value: val.to_value(),\n             ty: dest_ty,\n@@ -1201,7 +1201,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n-        dest: Pointer,\n+        dest: Scalar,\n         dest_align: Align,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n@@ -1231,7 +1231,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n                 let a_ptr = dest;\n                 let b_offset = a_size.abi_align(b.align(&self));\n-                let b_ptr = dest.offset(b_offset, &self)?.into();\n+                let b_ptr = dest.ptr_offset(b_offset, &self)?.into();\n                 // TODO: What about signedess?\n                 self.memory.write_primval(a_ptr, dest_align, a_val, a_size, false)?;\n                 self.memory.write_primval(b_ptr, dest_align, b_val, b_size, false)\n@@ -1319,7 +1319,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub fn read_value(&self, ptr: Pointer, align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn read_value(&self, ptr: Scalar, align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, align, ty)? {\n             Ok(val)\n         } else {\n@@ -1334,7 +1334,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         let ptr_size = self.memory.pointer_size();\n-        let p: Pointer = self.memory.read_ptr_sized(ptr, ptr_align)?.into();\n+        let p: Scalar = self.memory.read_ptr_sized(ptr, ptr_align)?.into();\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n@@ -1414,7 +1414,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(val)\n     }\n \n-    pub fn try_read_value(&self, ptr: Pointer, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn try_read_value(&self, ptr: Scalar, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         let layout = self.layout_of(ty)?;\n         self.memory.check_align(ptr, ptr_align)?;\n \n@@ -1614,7 +1614,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         }\n                     }\n                     Ok(Value::ByRef(ptr, align)) => {\n-                        match ptr.into_inner_primval() {\n+                        match ptr {\n                             Scalar::Ptr(ptr) => {\n                                 write!(msg, \" by align({}) ref:\", align.abi()).unwrap();\n                                 allocs.push(ptr.alloc_id);\n@@ -1643,7 +1643,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 self.memory.dump_allocs(allocs);\n             }\n             Place::Ptr { ptr, align, .. } => {\n-                match ptr.into_inner_primval() {\n+                match ptr {\n                     Scalar::Ptr(ptr) => {\n                         trace!(\"by align({}) ref:\", align.abi());\n                         self.memory.dump_alloc(ptr.alloc_id);"}, {"sha": "2df722127bf834ef57f37a74c58e93dd69ab21fa", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -10,7 +10,7 @@ use syntax::ast::Mutability;\n use rustc::middle::const_val::{ConstVal, ErrKind};\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, Value, Pointer,\n+use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, Value,\n                             EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n \n@@ -228,9 +228,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Check that the pointer is aligned AND non-NULL.\n-    pub fn check_align(&self, ptr: Pointer, required_align: Align) -> EvalResult<'tcx> {\n+    pub fn check_align(&self, ptr: Scalar, required_align: Align) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n-        let (offset, alloc_align) = match ptr.into_inner_primval() {\n+        let (offset, alloc_align) = match ptr {\n             Scalar::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n                 (ptr.offset.bytes(), alloc.align)\n@@ -594,9 +594,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn copy(\n         &mut self,\n-        src: Pointer,\n+        src: Scalar,\n         src_align: Align,\n-        dest: Pointer,\n+        dest: Scalar,\n         dest_align: Align,\n         size: Size,\n         nonoverlapping: bool,\n@@ -671,7 +671,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn read_bytes(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_bytes(&self, ptr: Scalar, size: Size) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         self.check_align(ptr, align)?;\n@@ -681,7 +681,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.get_bytes(ptr.to_ptr()?, size, align)\n     }\n \n-    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n+    pub fn write_bytes(&mut self, ptr: Scalar, src: &[u8]) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         self.check_align(ptr, align)?;\n@@ -693,7 +693,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: Size) -> EvalResult<'tcx> {\n+    pub fn write_repeat(&mut self, ptr: Scalar, val: u8, count: Size) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         self.check_align(ptr, align)?;\n@@ -726,7 +726,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => return Ok(Scalar::Ptr(MemoryPointer::new(alloc_id, Size::from_bytes(bytes as u64)))),\n+                Some(&alloc_id) => return Ok(MemoryPointer::new(alloc_id, Size::from_bytes(bytes as u64)).into()),\n                 None => {},\n             }\n         }\n@@ -738,7 +738,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.read_primval(ptr, ptr_align, self.pointer_size())\n     }\n \n-    pub fn write_primval(&mut self, ptr: Pointer, ptr_align: Align, val: Scalar, size: Size, signed: bool) -> EvalResult<'tcx> {\n+    pub fn write_primval(&mut self, ptr: Scalar, ptr_align: Align, val: Scalar, size: Size, signed: bool) -> EvalResult<'tcx> {\n         let endianness = self.endianness();\n \n         let bytes = match val {\n@@ -896,7 +896,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: Pointer,\n+        ptr: Scalar,\n         size: Size,\n         new_state: bool,\n     ) -> EvalResult<'tcx> {\n@@ -927,7 +927,7 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn into_ptr(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         Ok(match value {\n             Value::ByRef(ptr, align) => {\n                 self.memory().read_ptr_sized(ptr.to_ptr()?, align)?\n@@ -940,13 +940,13 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn into_ptr_vtable_pair(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n+    ) -> EvalResult<'tcx, (Scalar, MemoryPointer)> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n                 let mem = self.memory();\n                 let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n                 let vtable = mem.read_ptr_sized(\n-                    ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n                 )?.to_ptr()?;\n                 Ok((ptr, vtable))\n@@ -962,13 +962,13 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn into_slice(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, (Pointer, u64)> {\n+    ) -> EvalResult<'tcx, (Scalar, u64)> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n                 let mem = self.memory();\n                 let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n                 let len = mem.read_ptr_sized(\n-                    ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n                 )?.to_bytes()? as u64;\n                 Ok((ptr, len))"}, {"sha": "7db53a2f59a282ce8e66172f2024a7151d3e8289", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer, MemoryPointer};\n+use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, MemoryPointer};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n \n@@ -14,7 +14,7 @@ pub enum Place {\n         /// A place may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n-        ptr: Pointer,\n+        ptr: Scalar,\n         align: Align,\n         extra: PlaceExtra,\n     },\n@@ -38,7 +38,7 @@ impl<'tcx> Place {\n         Self::from_primval_ptr(Scalar::Undef.into(), Align::from_bytes(1, 1).unwrap())\n     }\n \n-    pub fn from_primval_ptr(ptr: Pointer, align: Align) -> Self {\n+    pub fn from_primval_ptr(ptr: Scalar, align: Align) -> Self {\n         Place::Ptr {\n             ptr,\n             align,\n@@ -50,15 +50,15 @@ impl<'tcx> Place {\n         Self::from_primval_ptr(ptr.into(), align)\n     }\n \n-    pub fn to_ptr_align_extra(self) -> (Pointer, Align, PlaceExtra) {\n+    pub fn to_ptr_align_extra(self) -> (Scalar, Align, PlaceExtra) {\n         match self {\n             Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n \n-    pub fn to_ptr_align(self) -> (Pointer, Align) {\n+    pub fn to_ptr_align(self) -> (Scalar, Align) {\n         let (ptr, align, _extra) = self.to_ptr_align_extra();\n         (ptr, align)\n     }\n@@ -272,7 +272,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             _ => offset,\n         };\n \n-        let ptr = base_ptr.offset(offset, &self)?;\n+        let ptr = base_ptr.ptr_offset(offset, &self)?;\n         let align = base_align.min(base_layout.align).min(field.align);\n         let extra = if !field.is_unsized() {\n             PlaceExtra::None\n@@ -332,7 +332,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             n,\n             len\n         );\n-        let ptr = base_ptr.offset(elem_size * n, &*self)?;\n+        let ptr = base_ptr.ptr_offset(elem_size * n, &*self)?;\n         Ok(Place::Ptr {\n             ptr,\n             align,\n@@ -410,7 +410,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     u64::from(offset)\n                 };\n \n-                let ptr = base_ptr.offset(elem_size * index, &self)?;\n+                let ptr = base_ptr.ptr_offset(elem_size * index, &self)?;\n                 Ok(Place::Ptr { ptr, align, extra: PlaceExtra::None })\n             }\n \n@@ -422,7 +422,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n                 let elem_size = self.layout_of(elem_ty)?.size;\n                 assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.offset(elem_size * u64::from(from), &self)?;\n+                let ptr = base_ptr.ptr_offset(elem_size * u64::from(from), &self)?;\n                 // sublicing arrays produces arrays\n                 let extra = if self.type_is_sized(base_ty) {\n                     PlaceExtra::None"}, {"sha": "2009d638a3fa1b3cb4018d505146ee00bb913c1f", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -342,7 +342,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                         for (i, arg_local) in arg_locals.enumerate() {\n                                             let field = layout.field(&self, i)?;\n                                             let offset = layout.fields.offset(i);\n-                                            let arg = Value::ByRef(ptr.offset(offset, &self)?,\n+                                            let arg = Value::ByRef(ptr.ptr_offset(offset, &self)?,\n                                                                    align.min(field.align));\n                                             let dest =\n                                                 self.eval_place(&mir::Place::Local(arg_local))?;"}, {"sha": "41dbffca78e31db681c26c808062dedbca372cad", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, Scalar::Ptr(drop))?;\n+        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, drop.into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n         self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bytes(size as u128))?;\n@@ -47,7 +47,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, Scalar::Ptr(fn_ptr))?;\n+                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, fn_ptr.into())?;\n             }\n         }\n "}]}