{"sha": "22b875770543ec1fe93cfb35fd07c692db5675e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyYjg3NTc3MDU0M2VjMWZlOTNjZmIzNWZkMDdjNjkyZGI1Njc1ZTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-08T01:53:14Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-10T19:48:42Z"}, "message": "rustc: Make shape-based compare glue never called for comparison operators.\n\nOnly called for string patterns.", "tree": {"sha": "62004747db05cf0fb7d82b85133210c67e2c7bb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62004747db05cf0fb7d82b85133210c67e2c7bb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22b875770543ec1fe93cfb35fd07c692db5675e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22b875770543ec1fe93cfb35fd07c692db5675e2", "html_url": "https://github.com/rust-lang/rust/commit/22b875770543ec1fe93cfb35fd07c692db5675e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22b875770543ec1fe93cfb35fd07c692db5675e2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a15c50f6c3cec5320ef91f000142af0367890a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a15c50f6c3cec5320ef91f000142af0367890a4", "html_url": "https://github.com/rust-lang/rust/commit/9a15c50f6c3cec5320ef91f000142af0367890a4"}], "stats": {"total": 404, "additions": 322, "deletions": 82}, "files": [{"sha": "1e05965925c947c6a7c0734dfb872c92409ad39f", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -179,7 +179,7 @@ pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: IA) -> A {\n     }\n }\n \n-pure fn max<A:Copy,IA:BaseIter<A>>(self: IA) -> A {\n+pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           Some(a_) if a_ > b => {"}, {"sha": "66ef6e001b75e0a1c2b2e0a7ab3cb59946670c4f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -769,28 +769,17 @@ pure fn lt(a: &str, b: &str) -> bool {\n \n /// Bytewise less than or equal\n pure fn le(a: &str, b: &str) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    let mut end = uint::min(a_len, b_len);\n-\n-    let mut i = 0;\n-    while i < end {\n-        let (c_a, c_b) = (a[i], b[i]);\n-        if c_a < c_b { return true; }\n-        if c_a > c_b { return false; }\n-        i += 1;\n-    }\n-\n-    return a_len <= b_len;\n+    !lt(b, a)\n }\n \n /// Bytewise greater than or equal\n pure fn ge(a: &str, b: &str) -> bool {\n-    !lt(b, a)\n+    !lt(a, b)\n }\n \n /// Bytewise greater than\n pure fn gt(a: &str, b: &str) -> bool {\n-    !le(b, a)\n+    !le(a, b)\n }\n \n impl &str: Eq {"}, {"sha": "ced39ef067b9908e60cf21ae4ff97471f815bafa", "filename": "src/libcore/task.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -158,6 +158,46 @@ enum SchedMode {\n     PlatformThread\n }\n \n+impl SchedMode : cmp::Eq {\n+    pure fn eq(&&other: SchedMode) -> bool {\n+        match self {\n+            SingleThreaded => {\n+                match other {\n+                    SingleThreaded => true,\n+                    _ => false\n+                }\n+            }\n+            ThreadPerCore => {\n+                match other {\n+                    ThreadPerCore => true,\n+                    _ => false\n+                }\n+            }\n+            ThreadPerTask => {\n+                match other {\n+                    ThreadPerTask => true,\n+                    _ => false\n+                }\n+            }\n+            ManualThreads(e0a) => {\n+                match other {\n+                    ManualThreads(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            PlatformThread => {\n+                match other {\n+                    PlatformThread => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(&&other: SchedMode) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n /**\n  * Scheduler configuration options\n  *"}, {"sha": "de6f2ea3e90897c9e6d64e59f7b72793e6fc1b29", "filename": "src/libstd/json.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -3,11 +3,12 @@\n \n //! json serialization\n \n-use core::cmp::Eq;\n+use core::cmp::{Eq, Ord};\n use result::{Result, Ok, Err};\n use io::WriterUtil;\n use map::hashmap;\n use map::map;\n+use sort::Sort;\n \n export Json;\n export Error;\n@@ -603,6 +604,75 @@ pure fn eq(value0: Json, value1: Json) -> bool {\n     }\n }\n \n+/// Test if two json values are less than one another\n+pure fn lt(value0: Json, value1: Json) -> bool {\n+    match value0 {\n+        Num(f0) => {\n+            match value1 {\n+                Num(f1) => f0 < f1,\n+                String(_) | Boolean(_) | List(_) | Dict(_) | Null => true\n+            }\n+        }\n+\n+        String(s0) => {\n+            match value1 {\n+                Num(_) => false,\n+                String(s1) => s0 < s1,\n+                Boolean(_) | List(_) | Dict(_) | Null => true\n+            }\n+        }\n+\n+        Boolean(b0) => {\n+            match value1 {\n+                Num(_) | String(_) => false,\n+                Boolean(b1) => b0 < b1,\n+                List(_) | Dict(_) | Null => true\n+            }\n+        }\n+\n+        List(l0) => {\n+            match value1 {\n+                Num(_) | String(_) | Boolean(_) => false,\n+                List(l1) => l0 < l1,\n+                Dict(_) | Null => true\n+            }\n+        }\n+\n+        Dict(d0) => {\n+            match value1 {\n+                Num(_) | String(_) | Boolean(_) | List(_) => false,\n+                Dict(d1) => {\n+                    unchecked {\n+                        let (d0_flat, d1_flat) = {\n+                            let d0_flat = dvec::DVec();\n+                            for d0.each |k, v| { d0_flat.push((k, v)); }\n+                            let d0_flat = dvec::unwrap(d0_flat);\n+                            d0_flat.qsort();\n+\n+                            let mut d1_flat = dvec::DVec();\n+                            for d1.each |k, v| { d1_flat.push((k, v)); }\n+                            let d1_flat = dvec::unwrap(d1_flat);\n+                            d1_flat.qsort();\n+\n+                            (d0_flat, d1_flat)\n+                        };\n+\n+                        d0_flat < d1_flat\n+                    }\n+                }\n+                Null => true\n+            }\n+        }\n+\n+        Null => {\n+            match value1 {\n+                Num(_) | String(_) | Boolean(_) | List(_) | Dict(_) => false,\n+                Null => true\n+            }\n+        }\n+    }\n+}\n+\n impl Error : Eq {\n     pure fn eq(&&other: Error) -> bool {\n         self.line == other.line &&\n@@ -617,6 +687,13 @@ impl Json : Eq {\n     pure fn ne(&&other: Json) -> bool { !self.eq(other) }\n }\n \n+impl Json : Ord {\n+    pure fn lt(&&other: Json) -> bool { lt(self, other) }\n+    pure fn le(&&other: Json) -> bool { !other.lt(self) }\n+    pure fn ge(&&other: Json) -> bool { !self.lt(other) }\n+    pure fn gt(&&other: Json) -> bool { other.lt(self)  }\n+}\n+\n trait ToJson { fn to_json() -> Json; }\n \n impl Json: ToJson {"}, {"sha": "364576aae332ddad7dda0bd134ad232a612f9ab2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -405,6 +405,13 @@ enum proto {\n     proto_block,   // fn&\n }\n \n+impl proto : cmp::Eq {\n+    pure fn eq(&&other: proto) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+    pure fn ne(&&other: proto) -> bool { !self.eq(other) }\n+}\n+\n #[auto_serialize]\n enum vstore {\n     // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n@@ -454,7 +461,49 @@ impl binop : cmp::Eq {\n enum unop {\n     box(mutability),\n     uniq(mutability),\n-    deref, not, neg\n+    deref,\n+    not,\n+    neg\n+}\n+\n+impl unop : cmp::Eq {\n+    pure fn eq(&&other: unop) -> bool {\n+        match self {\n+            box(e0a) => {\n+                match other {\n+                    box(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            uniq(e0a) => {\n+                match other {\n+                    uniq(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            deref => {\n+                match other {\n+                    deref => true,\n+                    _ => false\n+                }\n+            }\n+            not => {\n+                match other {\n+                    not => true,\n+                    _ => false\n+                }\n+            }\n+            neg => {\n+                match other {\n+                    neg => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(&&other: unop) -> bool {\n+        !self.eq(other)\n+    }\n }\n \n // Generally, after typeck you can get the inferred value"}, {"sha": "a12233765ca90a8be74d243954be69976f219d13", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -337,6 +337,13 @@ enum inline_attr {\n     ia_never,\n }\n \n+impl inline_attr : cmp::Eq {\n+    pure fn eq(&&other: inline_attr) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+    pure fn ne(&&other: inline_attr) -> bool { !self.eq(other) }\n+}\n+\n /// True if something like #[inline] is found in the list of attrs.\n fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]"}, {"sha": "cb470aee7f36ec914fd4e45789283bbb4051402a", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -143,7 +143,7 @@ struct protocol_ {\n     fn get_state_by_id(id: uint) -> state { self.states[id] }\n \n     fn has_state(name: ~str) -> bool {\n-        self.states.find(|i| i.name == name) != None\n+        self.states.find(|i| i.name == name).is_some()\n     }\n \n     fn filename() -> ~str {"}, {"sha": "c6ddc449b206039993d2f65692b9d13888267418", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -68,7 +68,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n         match elt.node {\n           expr_mac(m) => match m.node {\n             ast::mac_ellipsis => {\n-                if res != None {\n+                if res.is_some() {\n                     cx.span_fatal(m.span, ~\"only one ellipsis allowed\");\n                 }\n                 res =\n@@ -449,7 +449,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                 }\n               }\n               {pre: pre, rep: None, post: post} => {\n-                if post != ~[] {\n+                if post.len() > 0 {\n                     cx.bug(~\"elts_to_ell provided an invalid result\");\n                 }\n                 p_t_s_r_length(cx, vec::len(pre), false, s, b);"}, {"sha": "7fcf7a032dc0189ec7593c4564df76acc80ff8cf", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -17,6 +17,15 @@ enum cmnt_style {\n     blank_line, // Just a manual blank line \"\\n\\n\", for layout\n }\n \n+impl cmnt_style : cmp::Eq {\n+    pure fn eq(&&other: cmnt_style) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+    pure fn ne(&&other: cmnt_style) -> bool {\n+        (self as uint) != (other as uint)\n+    }\n+}\n+\n type cmnt = {style: cmnt_style, lines: ~[~str], pos: uint};\n \n fn is_doc_comment(s: ~str) -> bool {"}, {"sha": "46faa67114e3ded9369b263f23bd7a8174852efc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -1616,10 +1616,13 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n     pclose(s);\n \n     maybe_print_comment(s, decl.output.span.lo);\n-    if decl.output.node != ast::ty_nil {\n-        space_if_not_bol(s);\n-        word_space(s, ~\"->\");\n-        print_type(s, decl.output);\n+    match decl.output.node {\n+        ast::ty_nil => {}\n+        _ => {\n+            space_if_not_bol(s);\n+            word_space(s, ~\"->\");\n+            print_type(s, decl.output);\n+        }\n     }\n }\n \n@@ -1628,11 +1631,16 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n     word(s.s, ~\"|\");\n     print_fn_args(s, decl, cap_items, None);\n     word(s.s, ~\"|\");\n-    if decl.output.node != ast::ty_infer {\n-        space_if_not_bol(s);\n-        word_space(s, ~\"->\");\n-        print_type(s, decl.output);\n+\n+    match decl.output.node {\n+        ast::ty_infer => {}\n+        _ => {\n+            space_if_not_bol(s);\n+            word_space(s, ~\"->\");\n+            print_type(s, decl.output);\n+        }\n     }\n+\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n@@ -1829,14 +1837,19 @@ fn print_ty_fn(s: ps, opt_proto: Option<ast::proto>, purity: ast::purity,\n     pclose(s);\n \n     maybe_print_comment(s, decl.output.span.lo);\n-    if decl.output.node != ast::ty_nil {\n-        space_if_not_bol(s);\n-        ibox(s, indent_unit);\n-        word_space(s, ~\"->\");\n-        if decl.cf == ast::noreturn { word_nbsp(s, ~\"!\"); }\n-        else { print_type(s, decl.output); }\n-        end(s);\n+\n+    match decl.output.node {\n+        ast::ty_nil => {}\n+        _ => {\n+            space_if_not_bol(s);\n+            ibox(s, indent_unit);\n+            word_space(s, ~\"->\");\n+            if decl.cf == ast::noreturn { word_nbsp(s, ~\"!\"); }\n+            else { print_type(s, decl.output); }\n+            end(s);\n+        }\n     }\n+\n     end(s);\n }\n "}, {"sha": "2d4f988c0076d524136e326ec4db3ddaf6332344", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -79,6 +79,13 @@ enum assignment_type {\n     at_mutbl_ref,\n }\n \n+impl assignment_type : cmp::Eq {\n+    pure fn eq(&&other: assignment_type) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+    pure fn ne(&&other: assignment_type) -> bool { !self.eq(other) }\n+}\n+\n impl assignment_type {\n     fn checked_by_liveness() -> bool {\n         // the liveness pass guarantees that immutable local variables"}, {"sha": "b85b10e50e81bf8c5fe84a64b2f7fa0838be3a0e", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -210,6 +210,15 @@ enum ResolveResult<T> {\n     Success(T)      // Successfully resolved the import.\n }\n \n+impl<T> ResolveResult<T> {\n+    fn failed() -> bool {\n+        match self { Failed => true, _ => false }\n+    }\n+    fn indeterminate() -> bool {\n+        match self { Indeterminate => true, _ => false }\n+    }\n+}\n+\n enum TypeParameters/& {\n     NoTypeParameters,               //< No type parameters.\n     HasTypeParameters(&~[ty_param], //< Type parameters.\n@@ -558,9 +567,14 @@ struct NameBindings {\n \n     fn defined_in_namespace(namespace: Namespace) -> bool {\n         match namespace {\n-            ModuleNS    => return self.module_def != NoModuleDef,\n-            TypeNS      => return self.type_def != None,\n-            ValueNS     => return self.value_def != None\n+            ModuleNS => {\n+                match self.module_def {\n+                    NoModuleDef => false,\n+                    _ => true\n+                }\n+            }\n+            TypeNS   => return self.type_def.is_some(),\n+            ValueNS  => return self.value_def.is_some()\n         }\n     }\n \n@@ -1788,7 +1802,7 @@ struct Resolver {\n         // processing imports here. (See the loop in\n         // resolve_imports_for_module.)\n \n-        if resolution_result != Indeterminate {\n+        if !resolution_result.indeterminate() {\n             match *import_directive.subclass {\n                 GlobImport => {\n                     assert module_.glob_count >= 1u;"}, {"sha": "0fe4f3cd9170db584fa2e6fee7946e1e3dcd15f9", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -1117,12 +1117,21 @@ fn trans_eager_binop(bcx: block,\n             AShr(bcx, lhs, rhs)\n         } else { LShr(bcx, lhs, rhs) }\n       }\n+      ast::eq | ast::ne | ast::lt | ast::ge | ast::le | ast::gt => {\n+        if ty::type_is_bot(rhs_t) {\n+            C_bool(false)\n+        } else {\n+            if !ty::type_is_scalar(rhs_t) {\n+                bcx.tcx().sess.span_bug(binop_expr.span,\n+                                        ~\"non-scalar comparison\");\n+            }\n+            let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n+            bcx = cmpr.bcx;\n+            cmpr.val\n+        }\n+      }\n       _ => {\n-        let cmpr = base::trans_compare(bcx, op,\n-                                       lhs, lhs_t,\n-                                       rhs, rhs_t);\n-        bcx = cmpr.bcx;\n-        cmpr.val\n+        bcx.tcx().sess.span_bug(binop_expr.span, ~\"unexpected binop\");\n       }\n     };\n "}, {"sha": "cdbaf6e5ee245d1b980259458894a1dc972c0466", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -516,12 +516,14 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n                             ranges[i].align.bounded &&\n                             ranges[j].size.bounded &&\n                             ranges[j].align.bounded {\n-                            if ranges[i].size >= ranges[j].size &&\n-                                ranges[i].align >= ranges[j].align {\n+                            if ranges[i].size.min >= ranges[j].size.min &&\n+                                ranges[i].align.min >= ranges[j].align.min {\n                                 // Throw out j.\n                                 candidates[j] = false;\n-                            } else if ranges[j].size >= ranges[i].size &&\n-                                ranges[j].align >= ranges[j].align {\n+                            } else if ranges[j].size.min >=\n+                                    ranges[i].size.min &&\n+                                ranges[j].align.min >=\n+                                    ranges[j].align.min {\n                                 // Throw out i.\n                                 candidates[i] = false;\n                             }"}, {"sha": "b8d610e7a15361576201c384c8a36ed850d2ab41", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -3081,8 +3081,8 @@ fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n \n // Maintains a little union-set tree for inferred modes.  `canon()` returns\n // the current head value for `m0`.\n-fn canon<T:Copy>(tbl: hashmap<ast::node_id, ast::inferable<T>>,\n-                 +m0: ast::inferable<T>) -> ast::inferable<T> {\n+fn canon<T:Copy cmp::Eq>(tbl: hashmap<ast::node_id, ast::inferable<T>>,\n+                         +m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n       ast::infer(id) => match tbl.find(id) {\n         None => m0,"}, {"sha": "677a7a444f0ffa7dffd95b91085a29331880d405", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -1132,7 +1132,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n             let result_t = match op {\n               ast::eq | ast::lt | ast::le | ast::ne | ast::ge |\n-              ast::gt => ty::mk_bool(fcx.ccx.tcx),\n+              ast::gt => {\n+                if !ty::type_is_scalar(lhs_t) {\n+                    fcx.ccx.tcx.sess.span_bug(expr.span,\n+                                              ~\"non-scalar compare\");\n+                }\n+                ty::mk_bool(fcx.ccx.tcx)\n+              }\n               _ => lhs_t\n             };\n             fcx.write_ty(expr.id, result_t);\n@@ -1410,23 +1416,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let typ = check_lit(fcx, lit);\n         fcx.write_ty(id, typ);\n       }\n-\n-      // Something of a hack: special rules for comparison operators that\n-      // simply unify LHS and RHS.  This helps with inference as LHS and RHS\n-      // do not need to be \"resolvable\".  Some tests, particularly those with\n-      // complicated trait requirements, fail without this---I think this code\n-      // can be removed if we improve trait resolution to be more eager when\n-      // possible.\n-      ast::expr_binary(ast::ne, lhs, rhs) |\n-      ast::expr_binary(ast::le, lhs, rhs) |\n-      ast::expr_binary(ast::gt, lhs, rhs) |\n-      ast::expr_binary(ast::ge, lhs, rhs) => {\n-        let tcx = fcx.ccx.tcx;\n-        let tvar = fcx.infcx().next_ty_var();\n-        bot |= check_expr_with(fcx, lhs, tvar);\n-        bot |= check_expr_with(fcx, rhs, tvar);\n-        fcx.write_ty(id, ty::mk_bool(tcx));\n-      }\n       ast::expr_binary(op, lhs, rhs) => {\n         bot |= check_binop(fcx, expr, op, lhs, rhs);\n       }\n@@ -1806,7 +1795,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_rec(fields, base) => {\n         option::iter(base, |b| { check_expr(fcx, b, expected); });\n-        let expected = if expected == None && base != None {\n+        let expected = if expected.is_none() && base.is_some() {\n             Some(fcx.expr_ty(base.get()))\n         } else { expected };\n         let flds = unpack_expected(fcx, expected, |sty|"}, {"sha": "500a4d5b419f8ef5007b65e953ef112452bd7e20", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -20,7 +20,7 @@ struct node<V:Copy, T:Copy> {\n }\n \n impl infer_ctxt {\n-    fn get<V:Copy vid, T:Copy>(\n+    fn get<V:Copy vid Eq, T:Copy>(\n         vb: &vals_and_bindings<V, T>, vid: V) -> node<V, T> {\n \n         let vid_u = vid.to_uint();\n@@ -377,4 +377,4 @@ impl infer_ctxt {\n     }\n \n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "c1d9a10a106b236252dc7b799f678027c7292aa1", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -14,22 +14,22 @@ fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str {\n       return (xx as float) * 100f / (yy as float);\n    }\n \n-   pure fn le_by_val<TT: Copy, UU: Copy>(kv0: &(TT,UU),\n-                                         kv1: &(TT,UU)) -> bool {\n+   pure fn le_by_val<TT: Copy Ord, UU: Copy Ord>(kv0: &(TT,UU),\n+                                                 kv1: &(TT,UU)) -> bool {\n       let (_, v0) = *kv0;\n       let (_, v1) = *kv1;\n       return v0 >= v1;\n    }\n \n-   pure fn le_by_key<TT: Copy, UU: Copy>(kv0: &(TT,UU),\n-                                         kv1: &(TT,UU)) -> bool {\n+   pure fn le_by_key<TT: Copy Ord, UU: Copy Ord>(kv0: &(TT,UU),\n+                                                 kv1: &(TT,UU)) -> bool {\n       let (k0, _) = *kv0;\n       let (k1, _) = *kv1;\n       return k0 <= k1;\n    }\n \n    // sort by key, then by value\n-   fn sortKV<TT: Copy, UU: Copy>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n+   fn sortKV<TT: Copy Ord, UU: Copy Ord>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n       return sort::merge_sort(le_by_val, sort::merge_sort(le_by_key, orig));\n    }\n "}, {"sha": "29504d477a127ec925c795a88f6b2211b765a9fe", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -46,7 +46,7 @@ fn main() {\n         error!(\"selecting\");\n         let (i, m, _) = select(~[left, right]);\n         error!(\"selected %?\", i);\n-        if m != None {\n+        if m.is_some() {\n             assert i == 1;\n         }\n     });"}, {"sha": "269cbf0363bbd403d540d8723eb1d5175c22818e", "filename": "src/test/run-pass/structured-compare-recursive.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a15c50f6c3cec5320ef91f000142af0367890a4/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a15c50f6c3cec5320ef91f000142af0367890a4/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs?ref=9a15c50f6c3cec5320ef91f000142af0367890a4", "patch": "@@ -1,5 +0,0 @@\n-\n-\n-enum taggy { foo(@taggy), bar, }\n-\n-fn main() { assert (bar <= bar); }"}, {"sha": "6d6e2ad09d0a3b1ee2fc30db14b19203c652c04e", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -4,6 +4,26 @@\n // -*- rust -*-\n enum colour { red(int, int), green, }\n \n+impl colour : cmp::Eq {\n+    pure fn eq(&&other: colour) -> bool {\n+        match self {\n+            red(a0, b0) => {\n+                match other {\n+                    red(a1, b1) => a0 == a1 && b0 == b1,\n+                    green => false,\n+                }\n+            }\n+            green => {\n+                match other {\n+                    red(*) => false,\n+                    green => true\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(&&other: colour) -> bool { !self.eq(other) }\n+}\n+\n fn f() { let x = red(1, 2); let y = green; assert (x != y); }\n \n fn main() { f(); }"}, {"sha": "9400840dd8ef66ea718cb9e641978df13096cfd5", "filename": "src/test/run-pass/while-prelude-drop.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b875770543ec1fe93cfb35fd07c692db5675e2/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs?ref=22b875770543ec1fe93cfb35fd07c692db5675e2", "patch": "@@ -1,6 +1,26 @@\n \n enum t { a, b(~str), }\n \n+impl t : cmp::Eq {\n+    pure fn eq(&&other: t) -> bool {\n+        match self {\n+            a => {\n+                match other {\n+                    a => true,\n+                    b(_) => false\n+                }\n+            }\n+            b(s0) => {\n+                match other {\n+                    a => false,\n+                    b(s1) => s0 == s1\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(&&other: t) -> bool { !self.eq(other) }\n+}\n+\n fn make(i: int) -> t {\n     if i > 10 { return a; }\n     let mut s = ~\"hello\";"}]}