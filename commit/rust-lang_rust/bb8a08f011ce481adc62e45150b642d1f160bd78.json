{"sha": "bb8a08f011ce481adc62e45150b642d1f160bd78", "node_id": "C_kwDOAAsO6NoAKGJiOGEwOGYwMTFjZTQ4MWFkYzYyZTQ1MTUwYjY0MmQxZjE2MGJkNzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-27T00:38:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-27T00:38:06Z"}, "message": "Auto merge of #101064 - compiler-errors:rollup-fwm5m5f, r=compiler-errors\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #100724 (Migrate ast lowering to session diagnostic)\n - #100735 (Migrate `rustc_ty_utils` to `SessionDiagnostic`)\n - #100738 (Diagnostics migr const eval)\n - #100744 (Migrate rustc_mir_dataflow to diagnostic structs)\n - #100776 (Migrate `rustc_lint` errors to `SessionDiagnostic`)\n - #100817 (sugg: suggest the usage of boolean value when there is a typo in the keyword)\n - #100836 (Migrate `rustc_attr` crate diagnostics)\n - #100890 (Migrate rustc_driver to SessionDiagnostic)\n - #100900 (on `region_errors.rs`)\n\nFailed merges:\n\n - #100831 (Migrate `symbol_mangling` module to new diagnostics structs)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "df99bf6d92dc38fcaf9136c447825c4eb244a881", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df99bf6d92dc38fcaf9136c447825c4eb244a881"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb8a08f011ce481adc62e45150b642d1f160bd78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8a08f011ce481adc62e45150b642d1f160bd78", "html_url": "https://github.com/rust-lang/rust/commit/bb8a08f011ce481adc62e45150b642d1f160bd78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb8a08f011ce481adc62e45150b642d1f160bd78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "html_url": "https://github.com/rust-lang/rust/commit/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2"}, {"sha": "96ceadde76e204a269252b1252b916278ecc4ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/96ceadde76e204a269252b1252b916278ecc4ea7", "html_url": "https://github.com/rust-lang/rust/commit/96ceadde76e204a269252b1252b916278ecc4ea7"}], "stats": {"total": 3372, "additions": 2445, "deletions": 927}, "files": [{"sha": "2ea32a8012030b6a8a7b0eada81193850001723c", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -3574,6 +3574,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_query_system\",\n  \"rustc_session\",\n@@ -3819,6 +3820,7 @@ dependencies = [\n  \"rustc_interface\",\n  \"rustc_lint\",\n  \"rustc_log\",\n+ \"rustc_macros\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_parse\",\n@@ -4212,11 +4214,14 @@ dependencies = [\n  \"regex\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n+ \"rustc_errors\",\n  \"rustc_graphviz\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n@@ -4600,6 +4605,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "474aff2e2aac06fabc947ac8c733fa227c732e65", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -15,6 +15,7 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_middle = { path = \"../rustc_middle\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "0dba9da63da2a03d0d18c3ccfe2697d5b672252e", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 74, "deletions": 105, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -1,11 +1,17 @@\n use crate::{ImplTraitContext, ImplTraitPosition, ParamMode, ResolverAstLoweringExt};\n \n+use super::errors::{\n+    AbiSpecifiedMultipleTimes, AttSyntaxOnlyX86, ClobberAbiNotSupported,\n+    InlineAsmUnsupportedTarget, InvalidAbiClobberAbi, InvalidAsmTemplateModifierConst,\n+    InvalidAsmTemplateModifierRegClass, InvalidAsmTemplateModifierRegClassSub,\n+    InvalidAsmTemplateModifierSym, InvalidRegister, InvalidRegisterClass, RegisterClassOnlyClobber,\n+    RegisterConflict,\n+};\n use super::LoweringContext;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::definitions::DefPathData;\n@@ -26,13 +32,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let asm_arch =\n             if self.tcx.sess.opts.actually_rustdoc { None } else { self.tcx.sess.asm_arch };\n         if asm_arch.is_none() && !self.tcx.sess.opts.actually_rustdoc {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                sp,\n-                E0472,\n-                \"inline assembly is unsupported on this target\"\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(InlineAsmUnsupportedTarget { span: sp });\n         }\n         if let Some(asm_arch) = asm_arch {\n             // Inline assembly is currently only stable for these architectures.\n@@ -59,10 +59,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n             && !self.tcx.sess.opts.actually_rustdoc\n         {\n-            self.tcx\n-                .sess\n-                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n-                .emit();\n+            self.tcx.sess.emit_err(AttSyntaxOnlyX86 { span: sp });\n         }\n         if asm.options.contains(InlineAsmOptions::MAY_UNWIND) && !self.tcx.features().asm_unwind {\n             feature_err(\n@@ -82,51 +79,37 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n                             Some((prev_name, prev_sp)) => {\n-                                let mut err = self.tcx.sess.struct_span_err(\n-                                    *abi_span,\n-                                    &format!(\"`{}` ABI specified multiple times\", prev_name),\n-                                );\n-                                err.span_label(*prev_sp, \"previously specified here\");\n-\n                                 // Multiple different abi names may actually be the same ABI\n                                 // If the specified ABIs are not the same name, alert the user that they resolve to the same ABI\n                                 let source_map = self.tcx.sess.source_map();\n-                                if source_map.span_to_snippet(*prev_sp)\n-                                    != source_map.span_to_snippet(*abi_span)\n-                                {\n-                                    err.note(\"these ABIs are equivalent on the current target\");\n-                                }\n+                                let equivalent = (source_map.span_to_snippet(*prev_sp)\n+                                    != source_map.span_to_snippet(*abi_span))\n+                                .then_some(());\n \n-                                err.emit();\n+                                self.tcx.sess.emit_err(AbiSpecifiedMultipleTimes {\n+                                    abi_span: *abi_span,\n+                                    prev_name: *prev_name,\n+                                    prev_span: *prev_sp,\n+                                    equivalent,\n+                                });\n                             }\n                             None => {\n-                                clobber_abis.insert(abi, (abi_name, *abi_span));\n+                                clobber_abis.insert(abi, (*abi_name, *abi_span));\n                             }\n                         }\n                     }\n                     Err(&[]) => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                *abi_span,\n-                                \"`clobber_abi` is not supported on this target\",\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(ClobberAbiNotSupported { abi_span: *abi_span });\n                     }\n                     Err(supported_abis) => {\n-                        let mut err = self\n-                            .tcx\n-                            .sess\n-                            .struct_span_err(*abi_span, \"invalid ABI for `clobber_abi`\");\n                         let mut abis = format!(\"`{}`\", supported_abis[0]);\n                         for m in &supported_abis[1..] {\n                             let _ = write!(abis, \", `{}`\", m);\n                         }\n-                        err.note(&format!(\n-                            \"the following ABIs are supported on this target: {}\",\n-                            abis\n-                        ));\n-                        err.emit();\n+                        self.tcx.sess.emit_err(InvalidAbiClobberAbi {\n+                            abi_span: *abi_span,\n+                            supported_abis: abis,\n+                        });\n                     }\n                 }\n             }\n@@ -141,24 +124,28 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .iter()\n             .map(|(op, op_sp)| {\n                 let lower_reg = |reg| match reg {\n-                    InlineAsmRegOrRegClass::Reg(s) => {\n+                    InlineAsmRegOrRegClass::Reg(reg) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmReg::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register `{}`: {}\", s, e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n+                            asm::InlineAsmReg::parse(asm_arch, reg).unwrap_or_else(|error| {\n+                                sess.emit_err(InvalidRegister { op_span: *op_sp, reg, error });\n                                 asm::InlineAsmReg::Err\n                             })\n                         } else {\n                             asm::InlineAsmReg::Err\n                         })\n                     }\n-                    InlineAsmRegOrRegClass::RegClass(s) => {\n+                    InlineAsmRegOrRegClass::RegClass(reg_class) => {\n                         asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register class `{}`: {}\", s, e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n-                                asm::InlineAsmRegClass::Err\n-                            })\n+                            asm::InlineAsmRegClass::parse(asm_arch, reg_class).unwrap_or_else(\n+                                |error| {\n+                                    sess.emit_err(InvalidRegisterClass {\n+                                        op_span: *op_sp,\n+                                        reg_class,\n+                                        error,\n+                                    });\n+                                    asm::InlineAsmRegClass::Err\n+                                },\n+                            )\n                         } else {\n                             asm::InlineAsmRegClass::Err\n                         })\n@@ -282,50 +269,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n                         if !valid_modifiers.contains(&modifier) {\n-                            let mut err = sess.struct_span_err(\n-                                placeholder_span,\n-                                \"invalid asm template modifier for this register class\",\n-                            );\n-                            err.span_label(placeholder_span, \"template modifier\");\n-                            err.span_label(op_sp, \"argument\");\n-                            if !valid_modifiers.is_empty() {\n+                            let sub = if !valid_modifiers.is_empty() {\n                                 let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n                                 for m in &valid_modifiers[1..] {\n                                     let _ = write!(mods, \", `{}`\", m);\n                                 }\n-                                err.note(&format!(\n-                                    \"the `{}` register class supports \\\n-                                     the following template modifiers: {}\",\n-                                    class.name(),\n-                                    mods\n-                                ));\n+                                InvalidAsmTemplateModifierRegClassSub::SupportModifier {\n+                                    class_name: class.name(),\n+                                    modifiers: mods,\n+                                }\n                             } else {\n-                                err.note(&format!(\n-                                    \"the `{}` register class does not support template modifiers\",\n-                                    class.name()\n-                                ));\n-                            }\n-                            err.emit();\n+                                InvalidAsmTemplateModifierRegClassSub::DoesNotSupportModifier {\n+                                    class_name: class.name(),\n+                                }\n+                            };\n+                            sess.emit_err(InvalidAsmTemplateModifierRegClass {\n+                                placeholder_span,\n+                                op_span: op_sp,\n+                                sub,\n+                            });\n                         }\n                     }\n                     hir::InlineAsmOperand::Const { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierConst {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `const` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                     hir::InlineAsmOperand::SymFn { .. }\n                     | hir::InlineAsmOperand::SymStatic { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierSym {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `sym` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                 }\n             }\n@@ -346,12 +322,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // require that the operand name an explicit register, not a\n                 // register class.\n                 if reg_class.is_clobber_only(asm_arch.unwrap()) && !op.is_clobber() {\n-                    let msg = format!(\n-                        \"register class `{}` can only be used as a clobber, \\\n-                             not as an input or output\",\n-                        reg_class.name()\n-                    );\n-                    sess.struct_span_err(op_sp, &msg).emit();\n+                    sess.emit_err(RegisterClassOnlyClobber {\n+                        op_span: op_sp,\n+                        reg_class_name: reg_class.name(),\n+                    });\n                     continue;\n                 }\n \n@@ -391,16 +365,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                         unreachable!();\n                                     };\n \n-                                    let msg = format!(\n-                                        \"register `{}` conflicts with register `{}`\",\n-                                        reg.name(),\n-                                        reg2.name()\n-                                    );\n-                                    let mut err = sess.struct_span_err(op_sp, &msg);\n-                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n-                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n-\n-                                    match (op, op2) {\n+                                    let in_out = match (op, op2) {\n                                         (\n                                             hir::InlineAsmOperand::In { .. },\n                                             hir::InlineAsmOperand::Out { late, .. },\n@@ -411,14 +376,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                         ) => {\n                                             assert!(!*late);\n                                             let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                            let msg = \"use `lateout` instead of \\\n-                                                       `out` to avoid conflict\";\n-                                            err.span_help(out_op_sp, msg);\n-                                        }\n-                                        _ => {}\n-                                    }\n+                                            Some(out_op_sp)\n+                                        },\n+                                        _ => None,\n+                                    };\n \n-                                    err.emit();\n+                                    sess.emit_err(RegisterConflict {\n+                                        op_span1: op_sp,\n+                                        op_span2: op_sp2,\n+                                        reg1_name: reg.name(),\n+                                        reg2_name: reg2.name(),\n+                                        in_out\n+                                    });\n                                 }\n                                 Entry::Vacant(v) => {\n                                     if r == reg {"}, {"sha": "59f1b7180e4f4c5eb02c551ebb143208c9990642", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,329 @@\n+use rustc_errors::{fluent, AddSubdiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay};\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::generic_type_with_parentheses, code = \"E0214\")]\n+pub struct GenericTypeWithParentheses {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<UseAngleBrackets>,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct UseAngleBrackets {\n+    pub open_param: Span,\n+    pub close_param: Span,\n+}\n+\n+impl AddSubdiagnostic for UseAngleBrackets {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        diag.multipart_suggestion(\n+            fluent::ast_lowering::use_angle_brackets,\n+            vec![(self.open_param, String::from(\"<\")), (self.close_param, String::from(\">\"))],\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[help]\n+#[diag(ast_lowering::invalid_abi, code = \"E0703\")]\n+pub struct InvalidAbi {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub abi: Symbol,\n+    pub valid_abis: String,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::assoc_ty_parentheses)]\n+pub struct AssocTyParentheses {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: AssocTyParenthesesSub,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub enum AssocTyParenthesesSub {\n+    Empty { parentheses_span: Span },\n+    NotEmpty { open_param: Span, close_param: Span },\n+}\n+\n+impl AddSubdiagnostic for AssocTyParenthesesSub {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        match self {\n+            Self::Empty { parentheses_span } => diag.multipart_suggestion(\n+                fluent::ast_lowering::remove_parentheses,\n+                vec![(parentheses_span, String::new())],\n+                Applicability::MaybeIncorrect,\n+            ),\n+            Self::NotEmpty { open_param, close_param } => diag.multipart_suggestion(\n+                fluent::ast_lowering::use_angle_brackets,\n+                vec![(open_param, String::from(\"<\")), (close_param, String::from(\">\"))],\n+                Applicability::MaybeIncorrect,\n+            ),\n+        };\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_lowering::misplaced_impl_trait, code = \"E0562\")]\n+pub struct MisplacedImplTrait<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub position: DiagnosticArgFromDisplay<'a>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::rustc_box_attribute_error)]\n+pub struct RustcBoxAttributeError {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::underscore_expr_lhs_assign)]\n+pub struct UnderscoreExprLhsAssign {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::base_expression_double_dot)]\n+pub struct BaseExpressionDoubleDot {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::await_only_in_async_fn_and_blocks, code = \"E0728\")]\n+pub struct AwaitOnlyInAsyncFnAndBlocks {\n+    #[primary_span]\n+    #[label]\n+    pub dot_await_span: Span,\n+    #[label(ast_lowering::this_not_async)]\n+    pub item_span: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::generator_too_many_parameters, code = \"E0628\")]\n+pub struct GeneratorTooManyParameters {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::closure_cannot_be_static, code = \"E0697\")]\n+pub struct ClosureCannotBeStatic {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[help]\n+#[diag(ast_lowering::async_non_move_closure_not_supported, code = \"E0708\")]\n+pub struct AsyncNonMoveClosureNotSupported {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::functional_record_update_destructuring_assignment)]\n+pub struct FunctionalRecordUpdateDestructuringAssignemnt {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::async_generators_not_supported, code = \"E0727\")]\n+pub struct AsyncGeneratorsNotSupported {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::inline_asm_unsupported_target, code = \"E0472\")]\n+pub struct InlineAsmUnsupportedTarget {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::att_syntax_only_x86)]\n+pub struct AttSyntaxOnlyX86 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::abi_specified_multiple_times)]\n+pub struct AbiSpecifiedMultipleTimes {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub prev_name: Symbol,\n+    #[label]\n+    pub prev_span: Span,\n+    #[note]\n+    pub equivalent: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::clobber_abi_not_supported)]\n+pub struct ClobberAbiNotSupported {\n+    #[primary_span]\n+    pub abi_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[note]\n+#[diag(ast_lowering::invalid_abi_clobber_abi)]\n+pub struct InvalidAbiClobberAbi {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub supported_abis: String,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_register)]\n+pub struct InvalidRegister<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg: Symbol,\n+    pub error: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_register_class)]\n+pub struct InvalidRegisterClass<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg_class: Symbol,\n+    pub error: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_lowering::invalid_asm_template_modifier_reg_class)]\n+pub struct InvalidAsmTemplateModifierRegClass {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+    #[subdiagnostic]\n+    pub sub: InvalidAsmTemplateModifierRegClassSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum InvalidAsmTemplateModifierRegClassSub {\n+    #[note(ast_lowering::support_modifiers)]\n+    SupportModifier { class_name: Symbol, modifiers: String },\n+    #[note(ast_lowering::does_not_support_modifiers)]\n+    DoesNotSupportModifier { class_name: Symbol },\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_asm_template_modifier_const)]\n+pub struct InvalidAsmTemplateModifierConst {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_asm_template_modifier_sym)]\n+pub struct InvalidAsmTemplateModifierSym {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::register_class_only_clobber)]\n+pub struct RegisterClassOnlyClobber {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg_class_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::register_conflict)]\n+pub struct RegisterConflict<'a> {\n+    #[primary_span]\n+    #[label(ast_lowering::register1)]\n+    pub op_span1: Span,\n+    #[label(ast_lowering::register2)]\n+    pub op_span2: Span,\n+    pub reg1_name: &'a str,\n+    pub reg2_name: &'a str,\n+    #[help]\n+    pub in_out: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[help]\n+#[diag(ast_lowering::sub_tuple_binding)]\n+pub struct SubTupleBinding<'a> {\n+    #[primary_span]\n+    #[label]\n+    #[suggestion_verbose(\n+        ast_lowering::sub_tuple_binding_suggestion,\n+        code = \"..\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub ident_name: Symbol,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::extra_double_dot)]\n+pub struct ExtraDoubleDot<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(ast_lowering::previously_used_here)]\n+    pub prev_span: Span,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[note]\n+#[diag(ast_lowering::misplaced_double_dot)]\n+pub struct MisplacedDoubleDot {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::misplaced_relax_trait_bound)]\n+pub struct MisplacedRelaxTraitBound {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::not_supported_for_lifetime_binder_async_closure)]\n+pub struct NotSupportedForLifetimeBinderAsyncClosure {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::arbitrary_expression_in_pattern)]\n+pub struct ArbitraryExpressionInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "61f8c0216f1cf91c2f6d7ef65e4c6667bbde5a0e", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 20, "deletions": 80, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -1,3 +1,9 @@\n+use super::errors::{\n+    AsyncGeneratorsNotSupported, AsyncNonMoveClosureNotSupported, AwaitOnlyInAsyncFnAndBlocks,\n+    BaseExpressionDoubleDot, ClosureCannotBeStatic, FunctionalRecordUpdateDestructuringAssignemnt,\n+    GeneratorTooManyParameters, NotSupportedForLifetimeBinderAsyncClosure, RustcBoxAttributeError,\n+    UnderscoreExprLhsAssign,\n+};\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n use crate::{FnDeclKind, ImplTraitPosition};\n@@ -6,7 +12,6 @@ use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n use rustc_ast::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n@@ -45,13 +50,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             let hir_id = self.lower_node_id(e.id);\n                             return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n                         } else {\n-                            self.tcx.sess\n-                                .struct_span_err(\n-                                    e.span,\n-                                    \"#[rustc_box] requires precisely one argument \\\n-                                    and no other attributes are allowed\",\n-                                )\n-                                .emit();\n+                            self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n                             hir::ExprKind::Err\n                         }\n                     } else if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n@@ -211,13 +210,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n                 }\n                 ExprKind::Underscore => {\n-                    self.tcx\n-                        .sess.struct_span_err(\n-                            e.span,\n-                            \"in expressions, `_` can only be used on the left-hand side of an assignment\",\n-                        )\n-                        .span_label(e.span, \"`_` not allowed here\")\n-                        .emit();\n+                    self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n                     hir::ExprKind::Err\n                 }\n                 ExprKind::Path(ref qself, ref path) => {\n@@ -249,11 +242,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(*sp, \"base expression required after `..`\")\n-                                .span_label(*sp, \"add a base expression here\")\n-                                .emit();\n+                            self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n                             Some(&*self.arena.alloc(self.expr_err(*sp)))\n                         }\n                         StructRest::None => None,\n@@ -662,17 +651,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Async(_)) => {}\n             Some(hir::GeneratorKind::Gen) | None => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n+                self.tcx.sess.emit_err(AwaitOnlyInAsyncFnAndBlocks {\n                     dot_await_span,\n-                    E0728,\n-                    \"`await` is only allowed inside `async` functions and blocks\"\n-                );\n-                err.span_label(dot_await_span, \"only allowed inside `async` functions and blocks\");\n-                if let Some(item_sp) = self.current_item {\n-                    err.span_label(item_sp, \"this is not `async`\");\n-                }\n-                err.emit();\n+                    item_span: self.current_item,\n+                });\n             }\n         }\n         let span = self.mark_span_with_reason(DesugaringKind::Await, dot_await_span, None);\n@@ -892,13 +874,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match generator_kind {\n             Some(hir::GeneratorKind::Gen) => {\n                 if decl.inputs.len() > 1 {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        fn_decl_span,\n-                        E0628,\n-                        \"too many parameters for a generator (expected 0 or 1 parameters)\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(GeneratorTooManyParameters { fn_decl_span });\n                 }\n                 Some(movability)\n             }\n@@ -907,13 +883,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             None => {\n                 if movability == Movability::Static {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        fn_decl_span,\n-                        E0697,\n-                        \"closures cannot be static\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(ClosureCannotBeStatic { fn_decl_span });\n                 }\n                 None\n             }\n@@ -946,10 +916,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         fn_decl_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         if let &ClosureBinder::For { span, .. } = binder {\n-            self.tcx.sess.span_err(\n-                span,\n-                \"`for<...>` binders on `async` closures are not currently supported\",\n-            );\n+            self.tcx.sess.emit_err(NotSupportedForLifetimeBinderAsyncClosure { span });\n         }\n \n         let (binder_clause, generic_params) = self.lower_closure_binder(binder);\n@@ -960,17 +927,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let body = self.with_new_scopes(|this| {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n             if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n-                struct_span_err!(\n-                    this.tcx.sess,\n-                    fn_decl_span,\n-                    E0708,\n-                    \"`async` non-`move` closures with parameters are not currently supported\",\n-                )\n-                .help(\n-                    \"consider using `let` statements to manually capture \\\n-                    variables by reference before entering an `async move` closure\",\n-                )\n-                .emit();\n+                this.tcx.sess.emit_err(AsyncNonMoveClosureNotSupported { fn_decl_span });\n             }\n \n             // Transform `async |x: u8| -> X { ... }` into\n@@ -1210,20 +1167,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                e.span,\n-                                \"functional record updates are not allowed in destructuring \\\n-                                    assignments\",\n-                            )\n-                            .span_suggestion(\n-                                e.span,\n-                                \"consider removing the trailing pattern\",\n-                                \"\",\n-                                rustc_errors::Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(FunctionalRecordUpdateDestructuringAssignemnt {\n+                            span: e.span,\n+                        });\n                         true\n                     }\n                     StructRest::Rest(_) => true,\n@@ -1420,13 +1366,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Gen) => {}\n             Some(hir::GeneratorKind::Async(_)) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0727,\n-                    \"`async` generators are not yet supported\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(AsyncGeneratorsNotSupported { span });\n             }\n             None => self.generator_kind = Some(hir::GeneratorKind::Gen),\n         }"}, {"sha": "fd338ffc0c5e8b64c9ca0469cc25cb766070e671", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -1,3 +1,4 @@\n+use super::errors::{InvalidAbi, MisplacedRelaxTraitBound};\n use super::ResolverAstLoweringExt;\n use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n use super::{FnDeclKind, LoweringContext, ParamMode};\n@@ -7,7 +8,6 @@ use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -1260,10 +1260,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn error_on_invalid_abi(&self, abi: StrLit) {\n-        struct_span_err!(self.tcx.sess, abi.span, E0703, \"invalid ABI: found `{}`\", abi.symbol)\n-            .span_label(abi.span, \"invalid ABI\")\n-            .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n-            .emit();\n+        self.tcx.sess.emit_err(InvalidAbi {\n+            span: abi.span,\n+            abi: abi.symbol,\n+            valid_abis: abi::all_names().join(\", \"),\n+        });\n     }\n \n     fn lower_asyncness(&mut self, a: Async) -> hir::IsAsync {\n@@ -1338,11 +1339,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 let is_param = *is_param.get_or_insert_with(compute_is_param);\n                 if !is_param {\n-                    self.diagnostic().span_err(\n-                        bound.span(),\n-                        \"`?Trait` bounds are only permitted at the \\\n-                        point where a type parameter is declared\",\n-                    );\n+                    self.tcx.sess.emit_err(MisplacedRelaxTraitBound { span: bound.span() });\n                 }\n             }\n         }"}, {"sha": "becb67d116546993df6ab13ea21db8e870529b79", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -39,6 +39,8 @@\n #[macro_use]\n extern crate tracing;\n \n+use crate::errors::{AssocTyParentheses, AssocTyParenthesesSub, MisplacedImplTrait};\n+\n use rustc_ast::ptr::P;\n use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n@@ -49,7 +51,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, Applicability, Handler, StashKey};\n+use rustc_errors::{DiagnosticArgFromDisplay, Handler, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -75,6 +77,7 @@ macro_rules! arena_vec {\n \n mod asm;\n mod block;\n+mod errors;\n mod expr;\n mod index;\n mod item;\n@@ -1070,19 +1073,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn emit_bad_parenthesized_trait_in_assoc_ty(&self, data: &ParenthesizedArgs) {\n-        let mut err = self.tcx.sess.struct_span_err(\n-            data.span,\n-            \"parenthesized generic arguments cannot be used in associated type constraints\",\n-        );\n         // Suggest removing empty parentheses: \"Trait()\" -> \"Trait\"\n-        if data.inputs.is_empty() {\n+        let sub = if data.inputs.is_empty() {\n             let parentheses_span =\n                 data.inputs_span.shrink_to_lo().to(data.inputs_span.shrink_to_hi());\n-            err.multipart_suggestion(\n-                \"remove these parentheses\",\n-                vec![(parentheses_span, String::new())],\n-                Applicability::MaybeIncorrect,\n-            );\n+            AssocTyParenthesesSub::Empty { parentheses_span }\n         }\n         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n         else {\n@@ -1096,13 +1091,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // End of last argument to end of parameters\n             let close_param =\n                 data.inputs.last().unwrap().span.shrink_to_hi().to(data.inputs_span.shrink_to_hi());\n-            err.multipart_suggestion(\n-                &format!(\"use angle brackets instead\",),\n-                vec![(open_param, String::from(\"<\")), (close_param, String::from(\">\"))],\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-        err.emit();\n+            AssocTyParenthesesSub::NotEmpty { open_param, close_param }\n+        };\n+        self.tcx.sess.emit_err(AssocTyParentheses { span: data.span, sub });\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n@@ -1341,14 +1332,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         path\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            t.span,\n-                            E0562,\n-                            \"`impl Trait` only allowed in function and inherent method return types, not in {}\",\n-                            position\n-                        );\n-                        err.emit();\n+                        self.tcx.sess.emit_err(MisplacedImplTrait {\n+                            span: t.span,\n+                            position: DiagnosticArgFromDisplay(&position),\n+                        });\n                         hir::TyKind::Err\n                     }\n                 }"}, {"sha": "1efa19a3a828655d22f7721cb4357d3cb5a308ff", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -1,11 +1,13 @@\n+use super::errors::{\n+    ArbitraryExpressionInPattern, ExtraDoubleDot, MisplacedDoubleDot, SubTupleBinding,\n+};\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n use crate::ImplTraitPosition;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_span::symbol::Ident;\n@@ -134,20 +136,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // This is not allowed as a sub-tuple pattern\n                 PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n                     let sp = pat.span;\n-                    self.diagnostic()\n-                        .struct_span_err(\n-                            sp,\n-                            &format!(\"`{} @` is not allowed in a {}\", ident.name, ctx),\n-                        )\n-                        .span_label(sp, \"this is only allowed in slice patterns\")\n-                        .help(\"remove this and bind each tuple field independently\")\n-                        .span_suggestion_verbose(\n-                            sp,\n-                            &format!(\"if you don't need to use the contents of {}, discard the tuple's remaining fields\", ident),\n-                            \"..\",\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(SubTupleBinding {\n+                        span: sp,\n+                        ident_name: ident.name,\n+                        ident,\n+                        ctx,\n+                    });\n                 }\n                 _ => {}\n             }\n@@ -296,19 +290,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n     pub(crate) fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n-        self.diagnostic()\n-            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n-            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n-            .span_label(prev_sp, \"previously used here\")\n-            .emit();\n+        self.tcx.sess.emit_err(ExtraDoubleDot { span: sp, prev_span: prev_sp, ctx });\n     }\n \n     /// Used to ban the `..` pattern in places it shouldn't be semantically.\n     fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n-        self.diagnostic()\n-            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n-            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n-            .emit();\n+        self.tcx.sess.emit_err(MisplacedDoubleDot { span: sp });\n \n         // We're not in a list context so `..` can be reasonably treated\n         // as `_` because it should always be valid and roughly matches the\n@@ -345,8 +332,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {\n-                self.diagnostic()\n-                    .span_err(expr.span, \"arbitrary expressions aren't allowed in patterns\");\n+                self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n                 return self.arena.alloc(self.expr_err(expr.span));\n             }\n         }"}, {"sha": "5874d08a94fe06bac55a516e8abef538f386aa58", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -1,11 +1,11 @@\n use crate::ImplTraitPosition;\n \n+use super::errors::{GenericTypeWithParentheses, UseAngleBrackets};\n use super::ResolverAstLoweringExt;\n use super::{GenericArgsCtor, LifetimeRes, ParenthesizedGenericArgs};\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n \n use rustc_ast::{self as ast, *};\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, PartialRes, Res};\n use rustc_hir::GenericArg;\n@@ -185,18 +185,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::PathSegment<'hir> {\n         debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n-            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n             match **generic_args {\n                 GenericArgs::AngleBracketed(ref data) => {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Err => {\n-                        let mut err = struct_span_err!(self.tcx.sess, data.span, E0214, \"{}\", msg);\n-                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n                         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n-                        if !data.inputs.is_empty() {\n+                        let sub = if !data.inputs.is_empty() {\n                             // Start of the span to the 1st character of 1st argument\n                             let open_param = data.inputs_span.shrink_to_lo().to(data\n                                 .inputs\n@@ -212,16 +209,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 .span\n                                 .shrink_to_hi()\n                                 .to(data.inputs_span.shrink_to_hi());\n-                            err.multipart_suggestion(\n-                                &format!(\"use angle brackets instead\",),\n-                                vec![\n-                                    (open_param, String::from(\"<\")),\n-                                    (close_param, String::from(\">\")),\n-                                ],\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        err.emit();\n+\n+                            Some(UseAngleBrackets { open_param, close_param })\n+                        } else {\n+                            None\n+                        };\n+                        self.tcx.sess.emit_err(GenericTypeWithParentheses { span: data.span, sub });\n                         (\n                             self.lower_angle_bracketed_parameter_data(\n                                 &data.as_angle_bracketed_args(),"}, {"sha": "65edab78ce74ece4c3b2cb1098b7db250851346b", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 113, "deletions": 217, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -3,7 +3,6 @@\n use rustc_ast as ast;\n use rustc_ast::{Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n use rustc_session::lint::builtin::UNEXPECTED_CFGS;\n@@ -14,6 +13,8 @@ use rustc_span::hygiene::Transparency;\n use rustc_span::{symbol::sym, symbol::Symbol, Span};\n use std::num::NonZeroU32;\n \n+use crate::session_diagnostics::{self, IncorrectReprFormatGenericCause};\n+\n pub fn is_builtin_attr(attr: &Attribute) -> bool {\n     attr.is_doc_comment() || attr.ident().filter(|ident| is_builtin_attr_name(ident.name)).is_some()\n }\n@@ -25,46 +26,38 @@ enum AttrError {\n     NonIdentFeature,\n     MissingFeature,\n     MultipleStabilityLevels,\n-    UnsupportedLiteral(&'static str, /* is_bytestr */ bool),\n+    UnsupportedLiteral(UnsupportedLiteralReason, /* is_bytestr */ bool),\n+}\n+\n+pub(crate) enum UnsupportedLiteralReason {\n+    Generic,\n+    CfgString,\n+    DeprecatedString,\n+    DeprecatedKvPair,\n }\n \n fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n-    let diag = &sess.span_diagnostic;\n     match error {\n         AttrError::MultipleItem(item) => {\n-            struct_span_err!(diag, span, E0538, \"multiple '{}' items\", item).emit();\n+            sess.emit_err(session_diagnostics::MultipleItem { span, item });\n         }\n         AttrError::UnknownMetaItem(item, expected) => {\n-            let expected = expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n-            struct_span_err!(diag, span, E0541, \"unknown meta item '{}'\", item)\n-                .span_label(span, format!(\"expected one of {}\", expected.join(\", \")))\n-                .emit();\n+            sess.emit_err(session_diagnostics::UnknownMetaItem { span, item, expected });\n         }\n         AttrError::MissingSince => {\n-            struct_span_err!(diag, span, E0542, \"missing 'since'\").emit();\n+            sess.emit_err(session_diagnostics::MissingSince { span });\n         }\n         AttrError::NonIdentFeature => {\n-            struct_span_err!(diag, span, E0546, \"'feature' is not an identifier\").emit();\n+            sess.emit_err(session_diagnostics::NonIdentFeature { span });\n         }\n         AttrError::MissingFeature => {\n-            struct_span_err!(diag, span, E0546, \"missing 'feature'\").emit();\n+            sess.emit_err(session_diagnostics::MissingFeature { span });\n         }\n         AttrError::MultipleStabilityLevels => {\n-            struct_span_err!(diag, span, E0544, \"multiple stability levels\").emit();\n+            sess.emit_err(session_diagnostics::MultipleStabilityLevels { span });\n         }\n-        AttrError::UnsupportedLiteral(msg, is_bytestr) => {\n-            let mut err = struct_span_err!(diag, span, E0565, \"{}\", msg);\n-            if is_bytestr {\n-                if let Ok(lint_str) = sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider removing the prefix\",\n-                        &lint_str[1..],\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n-            err.emit();\n+        AttrError::UnsupportedLiteral(reason, is_bytestr) => {\n+            sess.emit_err(session_diagnostics::UnsupportedLiteral { span, reason, is_bytestr });\n         }\n     }\n }\n@@ -243,8 +236,6 @@ where\n     let mut promotable = false;\n     let mut allowed_through_unstable_modules = false;\n \n-    let diagnostic = &sess.parse_sess.span_diagnostic;\n-\n     'outer: for attr in attrs_iter {\n         if ![\n             sym::rustc_const_unstable,\n@@ -284,7 +275,7 @@ where\n                     *item = Some(v);\n                     true\n                 } else {\n-                    struct_span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\").emit();\n+                    sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n                     false\n                 }\n             };\n@@ -326,7 +317,7 @@ where\n                             handle_errors(\n                                 &sess.parse_sess,\n                                 meta.span(),\n-                                AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n                             );\n                             continue 'outer;\n                         };\n@@ -350,39 +341,28 @@ where\n                                 // is a name/value pair string literal.\n                                 issue_num = match issue.unwrap().as_str() {\n                                     \"none\" => None,\n-                                    issue => {\n-                                        let emit_diag = |msg: &str| {\n-                                            struct_span_err!(\n-                                                diagnostic,\n-                                                mi.span,\n-                                                E0545,\n-                                                \"`issue` must be a non-zero numeric string \\\n-                                                or \\\"none\\\"\",\n-                                            )\n-                                            .span_label(mi.name_value_literal_span().unwrap(), msg)\n-                                            .emit();\n-                                        };\n-                                        match issue.parse() {\n-                                            Ok(0) => {\n-                                                emit_diag(\n-                                                    \"`issue` must not be \\\"0\\\", \\\n-                                                    use \\\"none\\\" instead\",\n-                                                );\n-                                                continue 'outer;\n-                                            }\n-                                            Ok(num) => NonZeroU32::new(num),\n-                                            Err(err) => {\n-                                                emit_diag(&err.to_string());\n-                                                continue 'outer;\n-                                            }\n+                                    issue => match issue.parse::<NonZeroU32>() {\n+                                        Ok(num) => Some(num),\n+                                        Err(err) => {\n+                                            sess.emit_err(\n+                                                session_diagnostics::InvalidIssueString {\n+                                                    span: mi.span,\n+                                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n+                                                        mi.name_value_literal_span().unwrap(),\n+                                                        err.kind(),\n+                                                    ),\n+                                                },\n+                                            );\n+                                            continue 'outer;\n                                         }\n-                                    }\n+                                    },\n                                 };\n                             }\n                             sym::soft => {\n                                 if !mi.is_word() {\n-                                    let msg = \"`soft` should not have any arguments\";\n-                                    sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n+                                    sess.emit_err(session_diagnostics::SoftNoArgs {\n+                                        span: mi.span,\n+                                    });\n                                 }\n                                 is_soft = true;\n                             }\n@@ -440,8 +420,7 @@ where\n                             continue;\n                         }\n                         _ => {\n-                            struct_span_err!(diagnostic, attr.span, E0547, \"missing 'issue'\")\n-                                .emit();\n+                            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n                             continue;\n                         }\n                     }\n@@ -494,7 +473,10 @@ where\n                                 handle_errors(\n                                     &sess.parse_sess,\n                                     lit.span,\n-                                    AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                                    AttrError::UnsupportedLiteral(\n+                                        UnsupportedLiteralReason::Generic,\n+                                        false,\n+                                    ),\n                                 );\n                                 continue 'outer;\n                             }\n@@ -533,14 +515,7 @@ where\n         if let Some((ref mut stab, _)) = const_stab {\n             stab.promotable = promotable;\n         } else {\n-            struct_span_err!(\n-                diagnostic,\n-                item_sp,\n-                E0717,\n-                \"`rustc_promotable` attribute must be paired with either a `rustc_const_unstable` \\\n-                or a `rustc_const_stable` attribute\"\n-            )\n-            .emit();\n+            sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp });\n         }\n     }\n \n@@ -555,13 +530,7 @@ where\n         {\n             *allowed_through_unstable_modules = true;\n         } else {\n-            struct_span_err!(\n-                diagnostic,\n-                item_sp,\n-                E0789,\n-                \"`rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\"\n-            )\n-            .emit();\n+            sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n         }\n     }\n \n@@ -675,25 +644,18 @@ pub fn eval_condition(\n                     NestedMetaItem::Literal(Lit { span, .. })\n                     | NestedMetaItem::MetaItem(MetaItem { span, .. }),\n                 ] => {\n-                    sess.span_diagnostic\n-                        .struct_span_err(*span, \"expected a version literal\")\n-                        .emit();\n+                    sess.emit_err(session_diagnostics::ExpectedVersionLiteral { span: *span });\n                     return false;\n                 }\n                 [..] => {\n-                    sess.span_diagnostic\n-                        .struct_span_err(cfg.span, \"expected single version literal\")\n-                        .emit();\n+                    sess.emit_err(session_diagnostics::ExpectedSingleVersionLiteral {\n+                        span: cfg.span,\n+                    });\n                     return false;\n                 }\n             };\n             let Some(min_version) = parse_version(min_version.as_str(), false) else {\n-                sess.span_diagnostic\n-                    .struct_span_warn(\n-                        *span,\n-                        \"unknown version literal format, assuming it refers to a future version\",\n-                    )\n-                    .emit();\n+                sess.emit_warning(session_diagnostics::UnknownVersionLiteral { span: *span });\n                 return false;\n             };\n             let rustc_version = parse_version(env!(\"CFG_RELEASE\"), true).unwrap();\n@@ -711,7 +673,7 @@ pub fn eval_condition(\n                     handle_errors(\n                         sess,\n                         mi.span(),\n-                        AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                        AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n                     );\n                     return false;\n                 }\n@@ -736,13 +698,9 @@ pub fn eval_condition(\n                     }),\n                 sym::not => {\n                     if mis.len() != 1 {\n-                        struct_span_err!(\n-                            sess.span_diagnostic,\n-                            cfg.span,\n-                            E0536,\n-                            \"expected 1 cfg-pattern\"\n-                        )\n-                        .emit();\n+                        sess.emit_err(session_diagnostics::ExpectedOneCfgPattern {\n+                            span: cfg.span,\n+                        });\n                         return false;\n                     }\n \n@@ -768,29 +726,24 @@ pub fn eval_condition(\n                     })\n                 }\n                 _ => {\n-                    struct_span_err!(\n-                        sess.span_diagnostic,\n-                        cfg.span,\n-                        E0537,\n-                        \"invalid predicate `{}`\",\n-                        pprust::path_to_string(&cfg.path)\n-                    )\n-                    .emit();\n+                    sess.emit_err(session_diagnostics::InvalidPredicate {\n+                        span: cfg.span,\n+                        predicate: pprust::path_to_string(&cfg.path),\n+                    });\n                     false\n                 }\n             }\n         }\n         ast::MetaItemKind::Word | MetaItemKind::NameValue(..) if cfg.path.segments.len() != 1 => {\n-            sess.span_diagnostic\n-                .span_err(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n+            sess.emit_err(session_diagnostics::CfgPredicateIdentifier { span: cfg.path.span });\n             true\n         }\n         MetaItemKind::NameValue(ref lit) if !lit.kind.is_str() => {\n             handle_errors(\n                 sess,\n                 lit.span,\n                 AttrError::UnsupportedLiteral(\n-                    \"literal in `cfg` predicate value must be a string\",\n+                    UnsupportedLiteralReason::CfgString,\n                     lit.kind.is_bytestr(),\n                 ),\n             );\n@@ -834,7 +787,6 @@ where\n     I: Iterator<Item = &'a Attribute>,\n {\n     let mut depr: Option<(Deprecation, Span)> = None;\n-    let diagnostic = &sess.parse_sess.span_diagnostic;\n     let is_rustc = sess.features_untracked().staged_api;\n \n     'outer: for attr in attrs_iter {\n@@ -870,14 +822,14 @@ where\n                                 &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n-                                    \"literal in `deprecated` \\\n-                                    value must be a string\",\n+                                    UnsupportedLiteralReason::DeprecatedString,\n                                     lit.kind.is_bytestr(),\n                                 ),\n                             );\n                         } else {\n-                            struct_span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\")\n-                                .emit();\n+                            sess.emit_err(session_diagnostics::IncorrectMetaItem2 {\n+                                span: meta.span,\n+                            });\n                         }\n \n                         false\n@@ -899,14 +851,11 @@ where\n                             }\n                             sym::suggestion => {\n                                 if !sess.features_untracked().deprecated_suggestion {\n-                                    let mut diag = sess.struct_span_err(\n-                                        mi.span,\n-                                        \"suggestions on deprecated items are unstable\",\n-                                    );\n-                                    if sess.is_nightly_build() {\n-                                        diag.help(\"add `#![feature(deprecated_suggestion)]` to the crate root\");\n-                                    }\n-                                    diag.note(\"see #94785 for more details\").emit();\n+                                    sess.emit_err(session_diagnostics::DeprecatedItemSuggestion {\n+                                        span: mi.span,\n+                                        is_nightly: sess.is_nightly_build().then_some(()),\n+                                        details: (),\n+                                    });\n                                 }\n \n                                 if !get(mi, &mut suggestion) {\n@@ -934,7 +883,7 @@ where\n                                 &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n-                                    \"item in `deprecated` must be a key/value pair\",\n+                                    UnsupportedLiteralReason::DeprecatedKvPair,\n                                     false,\n                                 ),\n                             );\n@@ -952,7 +901,7 @@ where\n             }\n \n             if note.is_none() {\n-                struct_span_err!(diagnostic, attr.span, E0543, \"missing 'note'\").emit();\n+                sess.emit_err(session_diagnostics::MissingNote { span: attr.span });\n                 continue;\n             }\n         }\n@@ -1022,19 +971,9 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     sym::simd => Some(ReprSimd),\n                     sym::transparent => Some(ReprTransparent),\n                     sym::align => {\n-                        let mut err = struct_span_err!(\n-                            diagnostic,\n-                            item.span(),\n-                            E0589,\n-                            \"invalid `repr(align)` attribute: `align` needs an argument\"\n-                        );\n-                        err.span_suggestion(\n-                            item.span(),\n-                            \"supply an argument here\",\n-                            \"align(...)\",\n-                            Applicability::HasPlaceholders,\n-                        );\n-                        err.emit();\n+                        sess.emit_err(session_diagnostics::InvalidReprAlignNeedArg {\n+                            span: item.span(),\n+                        });\n                         recognised = true;\n                         None\n                     }\n@@ -1063,109 +1002,66 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     || int_type_of_word(name).is_some()\n                 {\n                     recognised = true;\n-                    struct_span_err!(\n-                                diagnostic,\n-                                item.span(),\n-                                E0552,\n-                                \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n-                                name.to_ident_string(),\n-                            ).emit();\n+                    sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                        span: item.span(),\n+                        name: name.to_ident_string(),\n+                    });\n                 }\n                 if let Some(literal_error) = literal_error {\n-                    struct_span_err!(\n-                        diagnostic,\n-                        item.span(),\n-                        E0589,\n-                        \"invalid `repr({})` attribute: {}\",\n-                        name.to_ident_string(),\n-                        literal_error\n-                    )\n-                    .emit();\n+                    sess.emit_err(session_diagnostics::InvalidReprGeneric {\n+                        span: item.span(),\n+                        repr_arg: name.to_ident_string(),\n+                        error_part: literal_error,\n+                    });\n                 }\n             } else if let Some(meta_item) = item.meta_item() {\n                 if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n                     if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n                         let name = meta_item.name_or_empty().to_ident_string();\n                         recognised = true;\n-                        let mut err = struct_span_err!(\n-                            diagnostic,\n-                            item.span(),\n-                            E0693,\n-                            \"incorrect `repr({})` attribute format\",\n-                            name,\n-                        );\n-                        match value.kind {\n-                            ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n-                                err.span_suggestion(\n-                                    item.span(),\n-                                    \"use parentheses instead\",\n-                                    format!(\"{}({})\", name, int),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            ast::LitKind::Str(s, _) => {\n-                                err.span_suggestion(\n-                                    item.span(),\n-                                    \"use parentheses instead\",\n-                                    format!(\"{}({})\", name, s),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            _ => {}\n-                        }\n-                        err.emit();\n+                        sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n+                            span: item.span(),\n+                            repr_arg: &name,\n+                            cause: IncorrectReprFormatGenericCause::from_lit_kind(\n+                                item.span(),\n+                                &value.kind,\n+                                &name,\n+                            ),\n+                        });\n                     } else {\n                         if matches!(\n                             meta_item.name_or_empty(),\n                             sym::C | sym::simd | sym::transparent\n                         ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n                         {\n                             recognised = true;\n-                            struct_span_err!(\n-                                diagnostic,\n-                                meta_item.span,\n-                                E0552,\n-                                \"invalid representation hint: `{}` does not take a value\",\n-                                meta_item.name_or_empty().to_ident_string(),\n-                            )\n-                            .emit();\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n                         }\n                     }\n                 } else if let MetaItemKind::List(_) = meta_item.kind {\n                     if meta_item.has_name(sym::align) {\n                         recognised = true;\n-                        struct_span_err!(\n-                            diagnostic,\n-                            meta_item.span,\n-                            E0693,\n-                            \"incorrect `repr(align)` attribute format: \\\n-                                 `align` takes exactly one argument in parentheses\"\n-                        )\n-                        .emit();\n+                        sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n+                            span: meta_item.span,\n+                        });\n                     } else if meta_item.has_name(sym::packed) {\n                         recognised = true;\n-                        struct_span_err!(\n-                            diagnostic,\n-                            meta_item.span,\n-                            E0552,\n-                            \"incorrect `repr(packed)` attribute format: \\\n-                                 `packed` takes exactly one parenthesized argument, \\\n-                                 or no parentheses at all\"\n-                        )\n-                        .emit();\n+                        sess.emit_err(session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n+                            span: meta_item.span,\n+                        });\n                     } else if matches!(\n                         meta_item.name_or_empty(),\n                         sym::C | sym::simd | sym::transparent\n                     ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n                     {\n                         recognised = true;\n-                        struct_span_err!(\n-                                diagnostic,\n-                                meta_item.span,\n-                                E0552,\n-                                \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n-                                meta_item.name_or_empty().to_ident_string(),\n-                            ).emit();\n+                        sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                            span: meta_item.span,\n+                            name: meta_item.name_or_empty().to_ident_string(),\n+                        });\n                     }\n                 }\n             }\n@@ -1262,10 +1158,10 @@ fn allow_unstable<'a>(\n     let list = attrs\n         .filter_map(move |attr| {\n             attr.meta_item_list().or_else(|| {\n-                sess.diagnostic().span_err(\n-                    attr.span,\n-                    &format!(\"`{}` expects a list of feature names\", symbol.to_ident_string()),\n-                );\n+                sess.emit_err(session_diagnostics::ExpectsFeatureList {\n+                    span: attr.span,\n+                    name: symbol.to_ident_string(),\n+                });\n                 None\n             })\n         })\n@@ -1274,10 +1170,10 @@ fn allow_unstable<'a>(\n     list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {\n-            sess.diagnostic().span_err(\n-                it.span(),\n-                &format!(\"`{}` expects feature names\", symbol.to_ident_string()),\n-            );\n+            sess.emit_err(session_diagnostics::ExpectsFeatures {\n+                span: it.span(),\n+                name: symbol.to_ident_string(),\n+            });\n         }\n         name\n     })"}, {"sha": "3a43f1aad02d63c40262b5c2f38640014669ef74", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -5,11 +5,14 @@\n //! to this crate.\n \n #![feature(let_else)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_macros;\n \n mod builtin;\n+mod session_diagnostics;\n \n pub use builtin::*;\n pub use IntType::*;"}, {"sha": "a75e7409fba18ce9b1b6eb6fa9418095bc6d91da", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,397 @@\n+use std::num::IntErrorKind;\n+\n+use rustc_ast as ast;\n+use rustc_errors::{error_code, fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_macros::SessionDiagnostic;\n+use rustc_session::{parse::ParseSess, SessionDiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+use crate::UnsupportedLiteralReason;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expected_one_cfg_pattern, code = \"E0536\")]\n+pub(crate) struct ExpectedOneCfgPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_predicate, code = \"E0537\")]\n+pub(crate) struct InvalidPredicate {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub predicate: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::multiple_item, code = \"E0538\")]\n+pub(crate) struct MultipleItem {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub item: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_meta_item, code = \"E0539\")]\n+pub(crate) struct IncorrectMetaItem {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+// Error code: E0541\n+pub(crate) struct UnknownMetaItem<'a> {\n+    pub span: Span,\n+    pub item: String,\n+    pub expected: &'a [&'a str],\n+}\n+\n+// Manual implementation to be able to format `expected` items correctly.\n+impl<'a> SessionDiagnostic<'a> for UnknownMetaItem<'_> {\n+    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let expected = self.expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n+        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+            self.span,\n+            fluent::attr::unknown_meta_item,\n+            error_code!(E0541),\n+        );\n+        diag.set_arg(\"item\", self.item);\n+        diag.set_arg(\"expected\", expected.join(\", \"));\n+        diag.span_label(self.span, fluent::attr::label);\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_since, code = \"E0542\")]\n+pub(crate) struct MissingSince {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_note, code = \"E0543\")]\n+pub(crate) struct MissingNote {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::multiple_stability_levels, code = \"E0544\")]\n+pub(crate) struct MultipleStabilityLevels {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_issue_string, code = \"E0545\")]\n+pub(crate) struct InvalidIssueString {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    #[subdiagnostic]\n+    pub cause: Option<InvalidIssueStringCause>,\n+}\n+\n+// The error kinds of `IntErrorKind` are duplicated here in order to allow the messages to be\n+// translatable.\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum InvalidIssueStringCause {\n+    #[label(attr::must_not_be_zero)]\n+    MustNotBeZero {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::empty)]\n+    Empty {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::invalid_digit)]\n+    InvalidDigit {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::pos_overflow)]\n+    PosOverflow {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::neg_overflow)]\n+    NegOverflow {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+impl InvalidIssueStringCause {\n+    pub fn from_int_error_kind(span: Span, kind: &IntErrorKind) -> Option<Self> {\n+        match kind {\n+            IntErrorKind::Empty => Some(Self::Empty { span }),\n+            IntErrorKind::InvalidDigit => Some(Self::InvalidDigit { span }),\n+            IntErrorKind::PosOverflow => Some(Self::PosOverflow { span }),\n+            IntErrorKind::NegOverflow => Some(Self::NegOverflow { span }),\n+            IntErrorKind::Zero => Some(Self::MustNotBeZero { span }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_feature, code = \"E0546\")]\n+pub(crate) struct MissingFeature {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::non_ident_feature, code = \"E0546\")]\n+pub(crate) struct NonIdentFeature {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_issue, code = \"E0547\")]\n+pub(crate) struct MissingIssue {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+// FIXME: This diagnostic is identical to `IncorrectMetaItem`, barring the error code. Consider\n+// changing this to `IncorrectMetaItem`. See #51489.\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_meta_item, code = \"E0551\")]\n+pub(crate) struct IncorrectMetaItem2 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+// FIXME: Why is this the same error code as `InvalidReprHintNoParen` and `InvalidReprHintNoValue`?\n+// It is more similar to `IncorrectReprFormatGeneric`.\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_repr_format_packed_one_or_zero_arg, code = \"E0552\")]\n+pub(crate) struct IncorrectReprFormatPackedOneOrZeroArg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_hint_no_paren, code = \"E0552\")]\n+pub(crate) struct InvalidReprHintNoParen {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_hint_no_value, code = \"E0552\")]\n+pub(crate) struct InvalidReprHintNoValue {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+// Error code: E0565\n+pub(crate) struct UnsupportedLiteral {\n+    pub span: Span,\n+    pub reason: UnsupportedLiteralReason,\n+    pub is_bytestr: bool,\n+}\n+\n+impl<'a> SessionDiagnostic<'a> for UnsupportedLiteral {\n+    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+            self.span,\n+            match self.reason {\n+                UnsupportedLiteralReason::Generic => fluent::attr::unsupported_literal_generic,\n+                UnsupportedLiteralReason::CfgString => fluent::attr::unsupported_literal_cfg_string,\n+                UnsupportedLiteralReason::DeprecatedString => {\n+                    fluent::attr::unsupported_literal_deprecated_string\n+                }\n+                UnsupportedLiteralReason::DeprecatedKvPair => {\n+                    fluent::attr::unsupported_literal_deprecated_kv_pair\n+                }\n+            },\n+            error_code!(E0565),\n+        );\n+        if self.is_bytestr {\n+            if let Ok(lint_str) = sess.source_map().span_to_snippet(self.span) {\n+                diag.span_suggestion(\n+                    self.span,\n+                    fluent::attr::unsupported_literal_suggestion,\n+                    &lint_str[1..],\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_align_need_arg, code = \"E0589\")]\n+pub(crate) struct InvalidReprAlignNeedArg {\n+    #[primary_span]\n+    #[suggestion(code = \"align(...)\", applicability = \"has-placeholders\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_generic, code = \"E0589\")]\n+pub(crate) struct InvalidReprGeneric<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub repr_arg: String,\n+    pub error_part: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_repr_format_align_one_arg, code = \"E0693\")]\n+pub(crate) struct IncorrectReprFormatAlignOneArg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_repr_format_generic, code = \"E0693\")]\n+pub(crate) struct IncorrectReprFormatGeneric<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub repr_arg: &'a str,\n+\n+    #[subdiagnostic]\n+    pub cause: Option<IncorrectReprFormatGenericCause<'a>>,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n+    #[suggestion(attr::suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n+    Int {\n+        #[primary_span]\n+        span: Span,\n+\n+        #[skip_arg]\n+        name: &'a str,\n+\n+        #[skip_arg]\n+        int: u128,\n+    },\n+\n+    #[suggestion(\n+        attr::suggestion,\n+        code = \"{name}({symbol})\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Symbol {\n+        #[primary_span]\n+        span: Span,\n+\n+        #[skip_arg]\n+        name: &'a str,\n+\n+        #[skip_arg]\n+        symbol: Symbol,\n+    },\n+}\n+\n+impl<'a> IncorrectReprFormatGenericCause<'a> {\n+    pub fn from_lit_kind(span: Span, kind: &ast::LitKind, name: &'a str) -> Option<Self> {\n+        match kind {\n+            ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                Some(Self::Int { span, name, int: *int })\n+            }\n+            ast::LitKind::Str(symbol, _) => Some(Self::Symbol { span, name, symbol: *symbol }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::rustc_promotable_pairing, code = \"E0717\")]\n+pub(crate) struct RustcPromotablePairing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::rustc_allowed_unstable_pairing, code = \"E0789\")]\n+pub(crate) struct RustcAllowedUnstablePairing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::cfg_predicate_identifier)]\n+pub(crate) struct CfgPredicateIdentifier {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::deprecated_item_suggestion)]\n+pub(crate) struct DeprecatedItemSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    #[help]\n+    pub is_nightly: Option<()>,\n+\n+    #[note]\n+    pub details: (),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expected_single_version_literal)]\n+pub(crate) struct ExpectedSingleVersionLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expected_version_literal)]\n+pub(crate) struct ExpectedVersionLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expects_feature_list)]\n+pub(crate) struct ExpectsFeatureList {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expects_features)]\n+pub(crate) struct ExpectsFeatures {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::soft_no_args)]\n+pub(crate) struct SoftNoArgs {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::unknown_version_literal)]\n+pub(crate) struct UnknownVersionLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "00fdf331ca60ce8c270a3ce98ec6a41d35baafa6", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 41, "deletions": 52, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! Error reporting machinery for lifetime errors.\n \n use rustc_data_structures::fx::FxHashSet;\n@@ -23,7 +25,10 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n \n use crate::borrowck_errors;\n-use crate::session_diagnostics::GenericDoesNotLiveLongEnough;\n+use crate::session_diagnostics::{\n+    FnMutError, FnMutReturnTypeErr, GenericDoesNotLiveLongEnough, LifetimeOutliveErr,\n+    LifetimeReturnCategoryErr, RequireStaticErr, VarHereDenote,\n+};\n \n use super::{OutlivesSuggestionBuilder, RegionName};\n use crate::region_infer::BlameConstraint;\n@@ -488,32 +493,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n-        let mut diag = self\n-            .infcx\n-            .tcx\n-            .sess\n-            .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n-\n         let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         if let ty::Opaque(def_id, _) = *output_ty.kind() {\n             output_ty = self.infcx.tcx.type_of(def_id)\n         };\n \n         debug!(\"report_fnmut_error: output_ty={:?}\", output_ty);\n \n-        let message = match output_ty.kind() {\n-            ty::Closure(_, _) => {\n-                \"returns a closure that contains a reference to a captured variable, which then \\\n-                 escapes the closure body\"\n-            }\n-            ty::Adt(def, _) if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did()) => {\n-                \"returns an `async` block that contains a reference to a captured variable, which then \\\n-                 escapes the closure body\"\n-            }\n-            _ => \"returns a reference to a captured variable which escapes the closure body\",\n+        let err = FnMutError {\n+            span: *span,\n+            ty_err: match output_ty.kind() {\n+                ty::Closure(_, _) => FnMutReturnTypeErr::ReturnClosure { span: *span },\n+                ty::Adt(def, _)\n+                    if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did()) =>\n+                {\n+                    FnMutReturnTypeErr::ReturnAsyncBlock { span: *span }\n+                }\n+                _ => FnMutReturnTypeErr::ReturnRef { span: *span },\n+            },\n         };\n \n-        diag.span_label(*span, message);\n+        let mut diag = self.infcx.tcx.sess.create_err(err);\n \n         if let ReturnConstraint::ClosureUpvar(upvar_field) = kind {\n             let def_id = match self.regioncx.universal_regions().defining_ty {\n@@ -532,20 +532,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let upvars_map = self.infcx.tcx.upvars_mentioned(def_id).unwrap();\n                 let upvar_def_span = self.infcx.tcx.hir().span(def_hir);\n                 let upvar_span = upvars_map.get(&def_hir).unwrap().span;\n-                diag.span_label(upvar_def_span, \"variable defined here\");\n-                diag.span_label(upvar_span, \"variable captured here\");\n+                diag.subdiagnostic(VarHereDenote::Defined { span: upvar_def_span });\n+                diag.subdiagnostic(VarHereDenote::Captured { span: upvar_span });\n             }\n         }\n \n         if let Some(fr_span) = self.give_region_a_name(*outlived_fr).unwrap().span() {\n-            diag.span_label(fr_span, \"inferred to be a `FnMut` closure\");\n+            diag.subdiagnostic(VarHereDenote::FnMutInferred { span: fr_span });\n         }\n \n-        diag.note(\n-            \"`FnMut` closures only have access to their captured variables while they are \\\n-             executing...\",\n-        );\n-        diag.note(\"...therefore, they cannot allow references to captured variables to escape\");\n         self.suggest_move_on_borrowing_closure(&mut diag);\n \n         diag\n@@ -681,39 +676,33 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             ..\n         } = errci;\n \n-        let mut diag =\n-            self.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n-\n         let (_, mir_def_name) =\n             self.infcx.tcx.article_and_description(self.mir_def_id().to_def_id());\n \n+        let err = LifetimeOutliveErr { span: *span };\n+        let mut diag = self.infcx.tcx.sess.create_err(err);\n+\n         let fr_name = self.give_region_a_name(*fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n         let outlived_fr_name = self.give_region_a_name(*outlived_fr).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n-        match (category, outlived_fr_is_local, fr_is_local) {\n-            (ConstraintCategory::Return(_), true, _) => {\n-                diag.span_label(\n-                    *span,\n-                    format!(\n-                        \"{mir_def_name} was supposed to return data with lifetime `{outlived_fr_name}` but it is returning \\\n-                         data with lifetime `{fr_name}`\",\n-                    ),\n-                );\n-            }\n-            _ => {\n-                diag.span_label(\n-                    *span,\n-                    format!(\n-                        \"{}requires that `{}` must outlive `{}`\",\n-                        category.description(),\n-                        fr_name,\n-                        outlived_fr_name,\n-                    ),\n-                );\n-            }\n-        }\n+        let err_category = match (category, outlived_fr_is_local, fr_is_local) {\n+            (ConstraintCategory::Return(_), true, _) => LifetimeReturnCategoryErr::WrongReturn {\n+                span: *span,\n+                mir_def_name,\n+                outlived_fr_name,\n+                fr_name: &fr_name,\n+            },\n+            _ => LifetimeReturnCategoryErr::ShortReturn {\n+                span: *span,\n+                category_desc: category.description(),\n+                free_region_name: &fr_name,\n+                outlived_fr_name,\n+            },\n+        };\n+\n+        diag.subdiagnostic(err_category);\n \n         self.add_static_impl_trait_suggestion(&mut diag, *fr, fr_name, *outlived_fr);\n         self.suggest_adding_lifetime_params(&mut diag, *fr, *outlived_fr);\n@@ -862,7 +851,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ident.span,\n                     \"calling this method introduces the `impl`'s 'static` requirement\",\n                 );\n-                err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n+                err.subdiagnostic(RequireStaticErr::UsedImpl { multi_span });\n                 err.span_suggestion_verbose(\n                     span.shrink_to_hi(),\n                     \"consider relaxing the implicit `'static` requirement\","}, {"sha": "0f8afb038f455c8393b671a4a05ff97976d81916", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -18,7 +18,7 @@ extern crate tracing;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n@@ -50,6 +50,8 @@ use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult, MoveData, MoveE\n use rustc_mir_dataflow::Analysis;\n use rustc_mir_dataflow::MoveDataParamEnv;\n \n+use crate::session_diagnostics::VarNeedNotMut;\n+\n use self::diagnostics::{AccessKind, RegionName};\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n@@ -424,17 +426,9 @@ fn do_mir_borrowck<'a, 'tcx>(\n             continue;\n         }\n \n-        tcx.struct_span_lint_hir(UNUSED_MUT, lint_root, span, |lint| {\n-            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n-            lint.build(\"variable does not need to be mutable\")\n-                .span_suggestion_short(\n-                    mut_span,\n-                    \"remove this `mut`\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n-        })\n+        let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n+\n+        tcx.emit_spanned_lint(UNUSED_MUT, lint_root, span, VarNeedNotMut { span: mut_span })\n     }\n \n     let tainted_by_errors = mbcx.emit_errors();"}, {"sha": "127cb4e408372e800e9ef7380f04c8ee59cf9e8d", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -16,6 +16,8 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n \n+use crate::session_diagnostics::ConstNotUsedTraitAlias;\n+\n use super::RegionInferenceContext;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -639,17 +641,10 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     Some(GenericArgKind::Const(c1)) => c1,\n                     Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n                     None => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"const parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ct\n-                                ),\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(ConstNotUsedTraitAlias {\n+                            ct: ct.to_string(),\n+                            span: self.span,\n+                        });\n \n                         self.tcx().const_error(ct.ty())\n                     }"}, {"sha": "5d750c6ca8c7beac7cd32767ab2bbb35d76ce3b4", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -1,7 +1,10 @@\n-use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_errors::{IntoDiagnosticArg, MultiSpan};\n+use rustc_macros::{LintDiagnostic, SessionDiagnostic, SessionSubdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n \n+use crate::diagnostics::RegionName;\n+\n #[derive(SessionDiagnostic)]\n #[diag(borrowck::move_unsized, code = \"E0161\")]\n pub(crate) struct MoveUnsized<'tcx> {\n@@ -42,3 +45,115 @@ pub(crate) struct GenericDoesNotLiveLongEnough {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[diag(borrowck::var_does_not_need_mut)]\n+pub(crate) struct VarNeedNotMut {\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(borrowck::const_not_used_in_type_alias)]\n+pub(crate) struct ConstNotUsedTraitAlias {\n+    pub ct: String,\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(borrowck::var_cannot_escape_closure)]\n+#[note]\n+#[note(borrowck::cannot_escape)]\n+pub(crate) struct FnMutError {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub ty_err: FnMutReturnTypeErr,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum VarHereDenote {\n+    #[label(borrowck::var_here_captured)]\n+    Captured {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(borrowck::var_here_defined)]\n+    Defined {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(borrowck::closure_inferred_mut)]\n+    FnMutInferred {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum FnMutReturnTypeErr {\n+    #[label(borrowck::returned_closure_escaped)]\n+    ReturnClosure {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(borrowck::returned_async_block_escaped)]\n+    ReturnAsyncBlock {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(borrowck::returned_ref_escaped)]\n+    ReturnRef {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(borrowck::lifetime_constraints_error)]\n+pub(crate) struct LifetimeOutliveErr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum LifetimeReturnCategoryErr<'a> {\n+    #[label(borrowck::returned_lifetime_wrong)]\n+    WrongReturn {\n+        #[primary_span]\n+        span: Span,\n+        mir_def_name: &'a str,\n+        outlived_fr_name: RegionName,\n+        fr_name: &'a RegionName,\n+    },\n+    #[label(borrowck::returned_lifetime_short)]\n+    ShortReturn {\n+        #[primary_span]\n+        span: Span,\n+        category_desc: &'static str,\n+        free_region_name: &'a RegionName,\n+        outlived_fr_name: RegionName,\n+    },\n+}\n+\n+impl IntoDiagnosticArg for &RegionName {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        format!(\"{}\", self).into_diagnostic_arg()\n+    }\n+}\n+\n+impl IntoDiagnosticArg for RegionName {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        format!(\"{}\", self).into_diagnostic_arg()\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum RequireStaticErr {\n+    #[note(borrowck::used_impl_require_static)]\n+    UsedImpl {\n+        #[primary_span]\n+        multi_span: MultiSpan,\n+    },\n+}"}, {"sha": "0faf51b062b4ce81f684c936da6a9ab68d3a94ef", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -168,6 +168,13 @@ pub struct CodegenResults {\n     pub crate_info: CrateInfo,\n }\n \n+pub enum CodegenErrors<'a> {\n+    WrongFileType,\n+    EmptyVersionNumber,\n+    EncodingVersionMismatch { version_array: String, rlink_version: u32 },\n+    RustcVersionMismatch { rustc_version: String, current_version: &'a str },\n+}\n+\n pub fn provide(providers: &mut Providers) {\n     crate::back::symbol_export::provide(providers);\n     crate::base::provide(providers);\n@@ -212,30 +219,34 @@ impl CodegenResults {\n         encoder.finish()\n     }\n \n-    pub fn deserialize_rlink(data: Vec<u8>) -> Result<Self, String> {\n+    pub fn deserialize_rlink<'a>(data: Vec<u8>) -> Result<Self, CodegenErrors<'a>> {\n         // The Decodable machinery is not used here because it panics if the input data is invalid\n         // and because its internal representation may change.\n         if !data.starts_with(RLINK_MAGIC) {\n-            return Err(\"The input does not look like a .rlink file\".to_string());\n+            return Err(CodegenErrors::WrongFileType);\n         }\n         let data = &data[RLINK_MAGIC.len()..];\n         if data.len() < 4 {\n-            return Err(\"The input does not contain version number\".to_string());\n+            return Err(CodegenErrors::EmptyVersionNumber);\n         }\n \n         let mut version_array: [u8; 4] = Default::default();\n         version_array.copy_from_slice(&data[..4]);\n         if u32::from_be_bytes(version_array) != RLINK_VERSION {\n-            return Err(\".rlink file was produced with encoding version {version_array}, but the current version is {RLINK_VERSION}\".to_string());\n+            return Err(CodegenErrors::EncodingVersionMismatch {\n+                version_array: String::from_utf8_lossy(&version_array).to_string(),\n+                rlink_version: RLINK_VERSION,\n+            });\n         }\n \n         let mut decoder = MemDecoder::new(&data[4..], 0);\n         let rustc_version = decoder.read_str();\n         let current_version = RUSTC_VERSION.unwrap();\n         if rustc_version != current_version {\n-            return Err(format!(\n-                \".rlink file was produced by rustc version {rustc_version}, but the current version is {current_version}.\"\n-            ));\n+            return Err(CodegenErrors::RustcVersionMismatch {\n+                rustc_version: rustc_version.to_string(),\n+                current_version,\n+            });\n         }\n \n         let codegen_results = CodegenResults::decode(&mut decoder);"}, {"sha": "d9c4ae4d53f91d3946fce0f16368aaf45f5f86d0", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -1,16 +1,16 @@\n // Not in interpret to make sure we do not use private implementation details\n \n+use crate::errors::MaxNumNodesInConstErr;\n+use crate::interpret::{\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n+    Scalar,\n+};\n use rustc_hir::Mutability;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{EvalToValTreeResult, GlobalId};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n \n-use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n-    Scalar,\n-};\n-\n mod error;\n mod eval_queries;\n mod fn_queries;\n@@ -72,12 +72,17 @@ pub(crate) fn eval_to_valtree<'tcx>(\n         Ok(valtree) => Ok(Some(valtree)),\n         Err(err) => {\n             let did = cid.instance.def_id();\n-            let s = cid.display(tcx);\n+            let global_const_id = cid.display(tcx);\n             match err {\n                 ValTreeCreationError::NodesOverflow => {\n-                    let msg = format!(\"maximum number of nodes exceeded in constant {}\", &s);\n+                    let msg = format!(\n+                        \"maximum number of nodes exceeded in constant {}\",\n+                        &global_const_id\n+                    );\n                     let mut diag = match tcx.hir().span_if_local(did) {\n-                        Some(span) => tcx.sess.struct_span_err(span, &msg),\n+                        Some(span) => {\n+                            tcx.sess.create_err(MaxNumNodesInConstErr { span, global_const_id })\n+                        }\n                         None => tcx.sess.struct_err(&msg),\n                     };\n                     diag.emit();"}, {"sha": "c3547cb3abdf3ff2fefa5205545281ebb6087bb4", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -87,3 +87,110 @@ pub(crate) struct TransientMutBorrowErrRaw {\n     pub span: Span,\n     pub kind: ConstContext,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::max_num_nodes_in_const)]\n+pub(crate) struct MaxNumNodesInConstErr {\n+    #[primary_span]\n+    pub span: Span,\n+    pub global_const_id: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_fn_pointer_call)]\n+pub(crate) struct UnallowedFnPointerCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unstable_const_fn)]\n+pub(crate) struct UnstableConstFn {\n+    #[primary_span]\n+    pub span: Span,\n+    pub def_path: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_mutable_refs, code = \"E0764\")]\n+pub(crate) struct UnallowedMutableRefs {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_mutable_refs_raw, code = \"E0764\")]\n+pub(crate) struct UnallowedMutableRefsRaw {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::non_const_fmt_macro_call, code = \"E0015\")]\n+pub(crate) struct NonConstFmtMacroCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::non_const_fn_call, code = \"E0015\")]\n+pub(crate) struct NonConstFnCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub def_path_str: String,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_op_in_const_context)]\n+pub(crate) struct UnallowedOpInConstContext {\n+    #[primary_span]\n+    pub span: Span,\n+    pub msg: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_heap_allocations, code = \"E0010\")]\n+pub(crate) struct UnallowedHeapAllocations {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_inline_asm, code = \"E0015\")]\n+pub(crate) struct UnallowedInlineAsm {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::interior_mutable_data_refer, code = \"E0492\")]\n+pub(crate) struct InteriorMutableDataRefer {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[help]\n+    pub opt_help: Option<()>,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::interior_mutability_borrow)]\n+pub(crate) struct InteriorMutabilityBorrow {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "5fb4bf638b342648d8648926c4aaeba2872e0a07", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 51, "deletions": 105, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -24,8 +24,11 @@ use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n use crate::errors::{\n-    MutDerefErr, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n-    TransientMutBorrowErr, TransientMutBorrowErrRaw,\n+    InteriorMutabilityBorrow, InteriorMutableDataRefer, MutDerefErr, NonConstFmtMacroCall,\n+    NonConstFnCall, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n+    TransientMutBorrowErr, TransientMutBorrowErrRaw, UnallowedFnPointerCall,\n+    UnallowedHeapAllocations, UnallowedInlineAsm, UnallowedMutableRefs, UnallowedMutableRefsRaw,\n+    UnallowedOpInConstContext, UnstableConstFn,\n };\n use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n@@ -97,10 +100,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.struct_span_err(\n-            span,\n-            &format!(\"function pointer calls are not allowed in {}s\", ccx.const_kind()),\n-        )\n+        ccx.tcx.sess.create_err(UnallowedFnPointerCall { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -308,22 +308,13 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 err\n             }\n             _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => {\n-                struct_span_err!(\n-                    ccx.tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot call non-const formatting macro in {}s\",\n-                    ccx.const_kind(),\n-                )\n+                ccx.tcx.sess.create_err(NonConstFmtMacroCall { span, kind: ccx.const_kind() })\n             }\n-            _ => struct_span_err!(\n-                ccx.tcx.sess,\n+            _ => ccx.tcx.sess.create_err(NonConstFnCall {\n                 span,\n-                E0015,\n-                \"cannot call non-const fn `{}` in {}s\",\n-                ccx.tcx.def_path_str_with_substs(callee, substs),\n-                ccx.const_kind(),\n-            ),\n+                def_path_str: ccx.tcx.def_path_str_with_substs(callee, substs),\n+                kind: ccx.const_kind(),\n+            }),\n         };\n \n         err.note(&format!(\n@@ -354,10 +345,10 @@ impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let FnCallUnstable(def_id, feature) = *self;\n \n-        let mut err = ccx.tcx.sess.struct_span_err(\n-            span,\n-            &format!(\"`{}` is not yet stable as a const fn\", ccx.tcx.def_path_str(def_id)),\n-        );\n+        let mut err = ccx\n+            .tcx\n+            .sess\n+            .create_err(UnstableConstFn { span, def_path: ccx.tcx.def_path_str(def_id) });\n \n         if ccx.is_const_stable_const_fn() {\n             err.help(\"const-stable functions can only call other const-stable functions\");\n@@ -392,9 +383,12 @@ impl<'tcx> NonConstOp<'tcx> for Generator {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n-            feature_err(&ccx.tcx.sess.parse_sess, sym::const_async_blocks, span, &msg)\n+            ccx.tcx.sess.create_feature_err(\n+                UnallowedOpInConstContext { span, msg },\n+                sym::const_async_blocks,\n+            )\n         } else {\n-            ccx.tcx.sess.struct_span_err(span, &msg)\n+            ccx.tcx.sess.create_err(UnallowedOpInConstContext { span, msg })\n         }\n     }\n }\n@@ -407,23 +401,11 @@ impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n+        ccx.tcx.sess.create_err(UnallowedHeapAllocations {\n             span,\n-            E0010,\n-            \"allocations are not allowed in {}s\",\n-            ccx.const_kind()\n-        );\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", ccx.const_kind()));\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"The value of statics and constants must be known at compile time, \\\n-                 and they live for the entire lifetime of a program. Creating a boxed \\\n-                 value allocates memory on the heap at runtime, and therefore cannot \\\n-                 be done at compile time.\",\n-            );\n-        }\n-        err\n+            kind: ccx.const_kind(),\n+            teach: ccx.tcx.sess.teach(&error_code!(E0010)).then_some(()),\n+        })\n     }\n }\n \n@@ -435,13 +417,7 @@ impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0015,\n-            \"inline assembly is not allowed in {}s\",\n-            ccx.const_kind()\n-        )\n+        ccx.tcx.sess.create_err(UnallowedInlineAsm { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -487,12 +463,7 @@ impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        feature_err(\n-            &ccx.tcx.sess.parse_sess,\n-            sym::const_refs_to_cell,\n-            span,\n-            \"cannot borrow here, since the borrowed element may contain interior mutability\",\n-        )\n+        ccx.tcx.sess.create_feature_err(InteriorMutabilityBorrow { span }, sym::const_refs_to_cell)\n     }\n }\n \n@@ -507,32 +478,22 @@ impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0492,\n-            \"{}s cannot refer to interior mutable data\",\n-            ccx.const_kind(),\n-        );\n-        err.span_label(\n-            span,\n-            \"this borrow of an interior mutable value may end up in the final value\",\n-        );\n+        // FIXME: Maybe a more elegant solution to this if else case\n         if let hir::ConstContext::Static(_) = ccx.const_kind() {\n-            err.help(\n-                \"to fix this, the value can be extracted to a separate \\\n-                `static` item and then referenced\",\n-            );\n-        }\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"A constant containing interior mutable data behind a reference can allow you\n-                 to modify that data. This would make multiple uses of a constant to be able to\n-                 see different values and allow circumventing the `Send` and `Sync` requirements\n-                 for shared mutable data, which is unsound.\",\n-            );\n+            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+                span,\n+                opt_help: Some(()),\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n+            })\n+        } else {\n+            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+                span,\n+                opt_help: None,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n+            })\n         }\n-        err\n     }\n }\n \n@@ -558,33 +519,18 @@ impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let raw = match self.0 {\n-            hir::BorrowKind::Raw => \"raw \",\n-            hir::BorrowKind::Ref => \"\",\n-        };\n-\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0764,\n-            \"{}mutable references are not allowed in the final value of {}s\",\n-            raw,\n-            ccx.const_kind(),\n-        );\n-\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"References in statics and constants may only refer \\\n-                      to immutable values.\\n\\n\\\n-                      Statics are shared everywhere, and if they refer to \\\n-                      mutable data one might violate memory safety since \\\n-                      holding multiple mutable references to shared data \\\n-                      is not allowed.\\n\\n\\\n-                      If you really want global mutable state, try using \\\n-                      static mut or a global UnsafeCell.\",\n-            );\n+        match self.0 {\n+            hir::BorrowKind::Raw => ccx.tcx.sess.create_err(UnallowedMutableRefsRaw {\n+                span,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n+            }),\n+            hir::BorrowKind::Ref => ccx.tcx.sess.create_err(UnallowedMutableRefs {\n+                span,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n+            }),\n         }\n-        err\n     }\n }\n "}, {"sha": "4570c1448337eec7b661868deb0d81d64f219916", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -19,6 +19,7 @@ rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }"}, {"sha": "a193d5db6916a08af8eaf61d186d86210a13c998", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -9,14 +9,16 @@\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate tracing;\n \n pub extern crate rustc_plugin_impl as plugin;\n \n use rustc_ast as ast;\n-use rustc_codegen_ssa::{traits::CodegenBackend, CodegenResults};\n+use rustc_codegen_ssa::{traits::CodegenBackend, CodegenErrors, CodegenResults};\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n@@ -56,6 +58,12 @@ use std::time::Instant;\n \n pub mod args;\n pub mod pretty;\n+mod session_diagnostics;\n+\n+use crate::session_diagnostics::{\n+    RLinkEmptyVersionNumber, RLinkEncodingVersionMismatch, RLinkRustcVersionMismatch,\n+    RLinkWrongFileType, RlinkNotAFile, RlinkUnableToRead,\n+};\n \n /// Exit status code used for successful compilation and help output.\n pub const EXIT_SUCCESS: i32 = 0;\n@@ -581,18 +589,35 @@ pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Comp\n             sess.init_crate_types(collect_crate_types(sess, &[]));\n             let outputs = compiler.build_output_filenames(sess, &[]);\n             let rlink_data = fs::read(file).unwrap_or_else(|err| {\n-                sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n+                sess.emit_fatal(RlinkUnableToRead { err });\n             });\n             let codegen_results = match CodegenResults::deserialize_rlink(rlink_data) {\n                 Ok(codegen) => codegen,\n-                Err(error) => {\n-                    sess.fatal(&format!(\"Could not deserialize .rlink file: {error}\"));\n+                Err(err) => {\n+                    match err {\n+                        CodegenErrors::WrongFileType => sess.emit_fatal(RLinkWrongFileType),\n+                        CodegenErrors::EmptyVersionNumber => {\n+                            sess.emit_fatal(RLinkEmptyVersionNumber)\n+                        }\n+                        CodegenErrors::EncodingVersionMismatch { version_array, rlink_version } => {\n+                            sess.emit_fatal(RLinkEncodingVersionMismatch {\n+                                version_array,\n+                                rlink_version,\n+                            })\n+                        }\n+                        CodegenErrors::RustcVersionMismatch { rustc_version, current_version } => {\n+                            sess.emit_fatal(RLinkRustcVersionMismatch {\n+                                rustc_version,\n+                                current_version,\n+                            })\n+                        }\n+                    };\n                 }\n             };\n             let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n             abort_on_err(result, sess);\n         } else {\n-            sess.fatal(\"rlink must be a file\")\n+            sess.emit_fatal(RlinkNotAFile {})\n         }\n         Compilation::Stop\n     } else {"}, {"sha": "fe64d0fca9b20c58771ce834bdb5c28a594e3912", "filename": "compiler/rustc_driver/src/session_diagnostics.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,33 @@\n+use rustc_macros::SessionDiagnostic;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_unable_to_read)]\n+pub(crate) struct RlinkUnableToRead {\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_wrong_file_type)]\n+pub(crate) struct RLinkWrongFileType;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_empty_version_number)]\n+pub(crate) struct RLinkEmptyVersionNumber;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_encoding_version_mismatch)]\n+pub(crate) struct RLinkEncodingVersionMismatch {\n+    pub version_array: String,\n+    pub rlink_version: u32,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_rustc_version_mismatch)]\n+pub(crate) struct RLinkRustcVersionMismatch<'a> {\n+    pub rustc_version: String,\n+    pub current_version: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_no_a_file)]\n+pub(crate) struct RlinkNotAFile;"}, {"sha": "dcb1e2b08306fe65b23864db9ab851ba9ee1bb65", "filename": "compiler/rustc_error_messages/locales/en-US/ast_lowering.ftl", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,131 @@\n+ast_lowering_generic_type_with_parentheses =\n+    parenthesized type parameters may only be used with a `Fn` trait\n+    .label = only `Fn` traits may use parentheses\n+\n+ast_lowering_use_angle_brackets = use angle brackets instead\n+\n+ast_lowering_invalid_abi =\n+    invalid ABI: found `{$abi}`\n+    .label = invalid ABI\n+    .help = valid ABIs: {$valid_abis}\n+\n+ast_lowering_assoc_ty_parentheses =\n+    parenthesized generic arguments cannot be used in associated type constraints\n+\n+ast_lowering_remove_parentheses = remove these parentheses\n+\n+ast_lowering_misplaced_impl_trait =\n+    `impl Trait` only allowed in function and inherent method return types, not in {$position}\n+\n+ast_lowering_rustc_box_attribute_error =\n+    #[rustc_box] requires precisely one argument and no other attributes are allowed\n+\n+ast_lowering_underscore_expr_lhs_assign =\n+    in expressions, `_` can only be used on the left-hand side of an assignment\n+    .label = `_` not allowed here\n+\n+ast_lowering_base_expression_double_dot =\n+    base expression required after `..`\n+    .label = add a base expression here\n+\n+ast_lowering_await_only_in_async_fn_and_blocks =\n+    `await` is only allowed inside `async` functions and blocks\n+    .label = only allowed inside `async` functions and blocks\n+\n+ast_lowering_this_not_async = this is not `async`\n+\n+ast_lowering_generator_too_many_parameters =\n+    too many parameters for a generator (expected 0 or 1 parameters)\n+\n+ast_lowering_closure_cannot_be_static = closures cannot be static\n+\n+ast_lowering_async_non_move_closure_not_supported =\n+    `async` non-`move` closures with parameters are not currently supported\n+    .help = consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n+\n+ast_lowering_functional_record_update_destructuring_assignment =\n+    functional record updates are not allowed in destructuring assignments\n+    .suggestion = consider removing the trailing pattern\n+\n+ast_lowering_async_generators_not_supported =\n+    `async` generators are not yet supported\n+\n+ast_lowering_inline_asm_unsupported_target =\n+    inline assembly is unsupported on this target\n+\n+ast_lowering_att_syntax_only_x86 =\n+    the `att_syntax` option is only supported on x86\n+\n+ast_lowering_abi_specified_multiple_times =\n+    `{$prev_name}` ABI specified multiple times\n+    .label = previously specified here\n+    .note = these ABIs are equivalent on the current target\n+\n+ast_lowering_clobber_abi_not_supported =\n+    `clobber_abi` is not supported on this target\n+\n+ast_lowering_invalid_abi_clobber_abi =\n+    invalid ABI for `clobber_abi`\n+    .note = the following ABIs are supported on this target: {$supported_abis}\n+\n+ast_lowering_invalid_register =\n+    invalid register `{$reg}`: {$error}\n+\n+ast_lowering_invalid_register_class =\n+    invalid register class `{$reg_class}`: {$error}\n+\n+ast_lowering_invalid_asm_template_modifier_reg_class =\n+    invalid asm template modifier for this register class\n+\n+ast_lowering_argument = argument\n+\n+ast_lowering_template_modifier = template modifier\n+\n+ast_lowering_support_modifiers =\n+    the `{$class_name}` register class supports the following template modifiers: {$modifiers}\n+\n+ast_lowering_does_not_support_modifiers =\n+    the `{$class_name}` register class does not support template modifiers\n+\n+ast_lowering_invalid_asm_template_modifier_const =\n+    asm template modifiers are not allowed for `const` arguments\n+\n+ast_lowering_invalid_asm_template_modifier_sym =\n+    asm template modifiers are not allowed for `sym` arguments\n+\n+ast_lowering_register_class_only_clobber =\n+    register class `{$reg_class_name}` can only be used as a clobber, not as an input or output\n+\n+ast_lowering_register_conflict =\n+    register `{$reg1_name}` conflicts with register `{$reg2_name}`\n+    .help = use `lateout` instead of `out` to avoid conflict\n+\n+ast_lowering_register1 = register `{$reg1_name}`\n+\n+ast_lowering_register2 = register `{$reg2_name}`\n+\n+ast_lowering_sub_tuple_binding =\n+    `{$ident_name} @` is not allowed in a {$ctx}\n+    .label = this is only allowed in slice patterns\n+    .help = remove this and bind each tuple field independently\n+\n+ast_lowering_sub_tuple_binding_suggestion = if you don't need to use the contents of {$ident}, discard the tuple's remaining fields\n+\n+ast_lowering_extra_double_dot =\n+    `..` can only be used once per {$ctx} pattern\n+    .label = can only be used once per {$ctx} pattern\n+\n+ast_lowering_previously_used_here = previously used here\n+\n+ast_lowering_misplaced_double_dot =\n+    `..` patterns are not allowed here\n+    .note = only allowed in tuple, tuple struct, and slice patterns\n+\n+ast_lowering_misplaced_relax_trait_bound =\n+    `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+ast_lowering_not_supported_for_lifetime_binder_async_closure =\n+    `for<...>` binders on `async` closures are not currently supported\n+\n+ast_lowering_arbitrary_expression_in_pattern =\n+    arbitrary expressions aren't allowed in patterns"}, {"sha": "a7f8c993d4225316129e515ef4e2a84bbe872137", "filename": "compiler/rustc_error_messages/locales/en-US/attr.ftl", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fattr.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fattr.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fattr.ftl?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,107 @@\n+attr_expected_one_cfg_pattern =\n+    expected 1 cfg-pattern\n+\n+attr_invalid_predicate =\n+    invalid predicate `{$predicate}`\n+\n+attr_multiple_item =\n+    multiple '{$item}' items\n+\n+attr_incorrect_meta_item =\n+    incorrect meta item\n+\n+attr_unknown_meta_item =\n+    unknown meta item '{$item}'\n+    .label = expected one of {$expected}\n+\n+attr_missing_since =\n+    missing 'since'\n+\n+attr_missing_note =\n+    missing 'note'\n+\n+attr_multiple_stability_levels =\n+    multiple stability levels\n+\n+attr_invalid_issue_string =\n+    `issue` must be a non-zero numeric string or \"none\"\n+    .must_not_be_zero = `issue` must not be \"0\", use \"none\" instead\n+    .empty = cannot parse integer from empty string\n+    .invalid_digit = invalid digit found in string\n+    .pos_overflow = number too large to fit in target type\n+    .neg_overflow = number too small to fit in target type\n+\n+attr_missing_feature =\n+    missing 'feature'\n+\n+attr_non_ident_feature =\n+    'feature' is not an identifier\n+\n+attr_missing_issue =\n+    missing 'issue'\n+\n+attr_incorrect_repr_format_packed_one_or_zero_arg =\n+    incorrect `repr(packed)` attribute format: `packed` takes exactly one parenthesized argument, or no parentheses at all\n+\n+attr_invalid_repr_hint_no_paren =\n+    invalid representation hint: `{$name}` does not take a parenthesized argument list\n+\n+attr_invalid_repr_hint_no_value =\n+    invalid representation hint: `{$name}` does not take a value\n+\n+attr_unsupported_literal_generic =\n+    unsupported literal\n+attr_unsupported_literal_cfg_string =\n+    literal in `cfg` predicate value must be a string\n+attr_unsupported_literal_deprecated_string =\n+    literal in `deprecated` value must be a string\n+attr_unsupported_literal_deprecated_kv_pair =\n+    item in `deprecated` must be a key/value pair\n+attr_unsupported_literal_suggestion =\n+    consider removing the prefix\n+\n+attr_invalid_repr_align_need_arg =\n+    invalid `repr(align)` attribute: `align` needs an argument\n+    .suggestion = supply an argument here\n+\n+attr_invalid_repr_generic =\n+    invalid `repr({$repr_arg})` attribute: {$error_part}\n+\n+attr_incorrect_repr_format_align_one_arg =\n+    incorrect `repr(align)` attribute format: `align` takes exactly one argument in parentheses\n+\n+attr_incorrect_repr_format_generic =\n+    incorrect `repr({$repr_arg})` attribute format\n+    .suggestion = use parentheses instead\n+\n+attr_rustc_promotable_pairing =\n+    `rustc_promotable` attribute must be paired with either a `rustc_const_unstable` or a `rustc_const_stable` attribute\n+\n+attr_rustc_allowed_unstable_pairing =\n+    `rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\n+\n+attr_cfg_predicate_identifier =\n+    `cfg` predicate key must be an identifier\n+\n+attr_deprecated_item_suggestion =\n+    suggestions on deprecated items are unstable\n+    .help = add `#![feature(deprecated_suggestion)]` to the crate root\n+    .note = see #94785 for more details\n+\n+attr_expected_single_version_literal =\n+    expected single version literal\n+\n+attr_expected_version_literal =\n+    expected a version literal\n+\n+attr_expects_feature_list =\n+    `{$name}` expects a list of feature names\n+\n+attr_expects_features =\n+    `{$name}` expects feature names\n+\n+attr_soft_no_args =\n+    `soft` should not have any arguments\n+\n+attr_unknown_version_literal =\n+    unknown version literal format, assuming it refers to a future version"}, {"sha": "67f2156f32e509eb78fb18267f48330d5fae2356", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -16,3 +16,45 @@ borrowck_higher_ranked_subtype_error =\n \n borrowck_generic_does_not_live_long_enough =\n     `{$kind}` does not live long enough\n+\n+borrowck_move_borrowed =\n+    cannot move out of `{$desc}` beacause it is borrowed\n+\n+borrowck_var_does_not_need_mut =\n+    variable does not need to be mutable\n+    .suggestion = remove this `mut`\n+\n+borrowck_const_not_used_in_type_alias =\n+    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+\n+borrowck_var_cannot_escape_closure =\n+    captured variable cannot escape `FnMut` closure body\n+    .note = `FnMut` closures only have access to their captured variables while they are executing...\n+    .cannot_escape = ...therefore, they cannot allow references to captured variables to escape\n+\n+borrowck_var_here_defined = variable defined here\n+\n+borrowck_var_here_captured = variable captured here\n+\n+borrowck_closure_inferred_mut =  inferred to be a `FnMut` closure\n+\n+borrowck_returned_closure_escaped =\n+    returns a closure that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_async_block_escaped =\n+    returns an `async` block that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_ref_escaped =\n+    returns a reference to a captured variable which escapes the closure body\n+\n+borrowck_lifetime_constraints_error =\n+    lifetime may not live long enough\n+\n+borrowck_returned_lifetime_wrong =\n+    {$mir_def_name} was supposed to return data with lifetime `{$outlived_fr_name}` but it is returning data with lifetime `{$fr_name}`\n+\n+borrowck_returned_lifetime_short =\n+    {$category_desc}requires that `{$free_region_name}` must outlive `{$outlived_fr_name}`\n+\n+borrowck_used_impl_require_static =\n+    the used `impl` has a `'static` requirement"}, {"sha": "33bb116d6fa23f01c513d1b34b0d7e8ed9007070", "filename": "compiler/rustc_error_messages/locales/en-US/const_eval.ftl", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -29,3 +29,55 @@ const_eval_mut_deref =\n const_eval_transient_mut_borrow = mutable references are not allowed in {$kind}s\n \n const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {$kind}s\n+\n+const_eval_max_num_nodes_in_const = maximum number of nodes exceeded in constant {$global_const_id}\n+\n+const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {$kind}s\n+\n+const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n+\n+const_eval_unallowed_mutable_refs =\n+    mutable references are not allowed in the final value of {$kind}s\n+    .teach_note =\n+        References in statics and constants may only refer to immutable values.\\n\\n\n+        Statics are shared everywhere, and if they refer to mutable data one might violate memory\n+        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        If you really want global mutable state, try using static mut or a global UnsafeCell.\n+\n+const_eval_unallowed_mutable_refs_raw =\n+    raw mutable references are not allowed in the final value of {$kind}s\n+    .teach_note =\n+        References in statics and constants may only refer to immutable values.\\n\\n\n+        Statics are shared everywhere, and if they refer to mutable data one might violate memory\n+        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        If you really want global mutable state, try using static mut or a global UnsafeCell.\n+\n+const_eval_non_const_fmt_macro_call =\n+    cannot call non-const formatting macro in {$kind}s\n+\n+const_eval_non_const_fn_call =\n+    cannot call non-const fn `{$def_path_str}` in {$kind}s\n+\n+const_eval_unallowed_op_in_const_context =\n+    {$msg}\n+\n+const_eval_unallowed_heap_allocations =\n+    allocations are not allowed in {$kind}s\n+    .label = allocation not allowed in {$kind}s\n+    .teach_note =\n+        The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.\n+\n+const_eval_unallowed_inline_asm =\n+    inline assembly is not allowed in {$kind}s\n+\n+const_eval_interior_mutable_data_refer =\n+    {$kind}s cannot refer to interior mutable data\n+    .label = this borrow of an interior mutable value may end up in the final value\n+    .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n+    .teach_note =\n+        A constant containing interior mutable data behind a reference can allow you to modify that data.\n+        This would make multiple uses of a constant to be able to see different values and allow circumventing\n+        the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n+\n+const_eval_interior_mutability_borrow =\n+    cannot borrow here, since the borrowed element may contain interior mutability"}, {"sha": "73f084cf3290bf7d1d8e7a0af03b4a35410aafa4", "filename": "compiler/rustc_error_messages/locales/en-US/driver.ftl", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,11 @@\n+driver_rlink_unable_to_read = failed to read rlink file: `{$err}`\n+\n+driver_rlink_wrong_file_type = The input does not look like a .rlink file\n+\n+driver_rlink_empty_version_number = The input does not contain version number\n+\n+driver_rlink_encoding_version_mismatch = .rlink file was produced with encoding version `{$version_array}`, but the current version is `{$rlink_version}`\n+\n+driver_rlink_rustc_version_mismatch = .rlink file was produced by rustc version `{$rustc_version}`, but the current version is `{$current_version}`\n+\n+driver_rlink_no_a_file = rlink must be a file"}, {"sha": "27ad3e453660188727a674a59593a4cf71d39397", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -393,3 +393,37 @@ lint_builtin_deref_nullptr = dereferencing a null pointer\n     .label = this code causes undefined behavior when executed\n \n lint_builtin_asm_labels = avoid using named labels in inline assembly\n+\n+lint_overruled_attribute = {$lint_level}({$lint_source}) incompatible with previous forbid\n+    .label = overruled by previous forbid\n+\n+lint_default_source = `forbid` lint level is the default for {$id}\n+\n+lint_node_source = `forbid` level set here\n+    .note = {$reason}\n+\n+lint_command_line_source = `forbid` lint level was set on command line\n+\n+lint_malformed_attribute = malformed lint attribute input\n+\n+lint_bad_attribute_argument = bad attribute argument\n+\n+lint_reason_must_be_string_literal = reason must be a string literal\n+\n+lint_reason_must_come_last = reason in lint attribute must come last\n+\n+lint_unknown_tool_in_scoped_lint = unknown tool name `{$tool_name}` found in scoped lint: `{$tool_name}::{$lint_name}`\n+    .help = add `#![register_tool({$tool_name})]` to the crate root\n+\n+lint_unsupported_group = `{$lint_group}` lint group is not supported with \u00b4--force-warn\u00b4\n+\n+lint_requested_level = requested on the command line with `{$level} {$lint_name}`\n+\n+lint_check_name_unknown = unknown lint: `{$lint_name}`\n+    .help = did you mean: `{$suggestion}`\n+\n+lint_check_name_unknown_tool = unknown lint tool: `{$tool_name}`\n+\n+lint_check_name_warning = {$msg}\n+\n+lint_check_name_deprecated = lint name `{$lint_name}` is deprecated and does not have an effect anymore. Use: {$new_name}"}, {"sha": "988541525088367d86439fb99cbecf25753c2466", "filename": "compiler/rustc_error_messages/locales/en-US/mir_dataflow.ftl", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_dataflow.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_dataflow.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_dataflow.ftl?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,29 @@\n+mir_dataflow_path_must_end_in_filename =\n+    path must end in a filename\n+\n+mir_dataflow_unknown_formatter =\n+    unknown formatter\n+\n+mir_dataflow_duplicate_values_for =\n+    duplicate values for `{$name}`\n+\n+mir_dataflow_requires_an_argument =\n+    `{$name}` requires an argument\n+\n+mir_dataflow_stop_after_dataflow_ended_compilation =\n+    stop_after_dataflow ended compilation\n+\n+mir_dataflow_peek_must_be_place_or_ref_place =\n+    rustc_peek: argument expression must be either `place` or `&place`\n+\n+mir_dataflow_peek_must_be_not_temporary =\n+    dataflow::sanity_check cannot feed a non-temp to rustc_peek\n+\n+mir_dataflow_peek_bit_not_set =\n+    rustc_peek: bit not set\n+\n+mir_dataflow_peek_argument_not_a_local =\n+    rustc_peek: argument was not a local\n+\n+mir_dataflow_peek_argument_untracked =\n+    rustc_peek: argument untracked"}, {"sha": "1040ee1c97d814b8a04c97bcb2a88fcfa68c30c6", "filename": "compiler/rustc_error_messages/locales/en-US/ty_utils.ftl", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fty_utils.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fty_utils.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fty_utils.ftl?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,47 @@\n+ty_utils_needs_drop_overflow = overflow while checking whether `{$query_ty}` requires drop\n+\n+ty_utils_generic_constant_too_complex = overly complex generic constant\n+    .help = consider moving this anonymous constant into a `const` function\n+    .maybe_supported = this operation may be supported in the future\n+\n+ty_utils_borrow_not_supported = borrowing is not supported in generic constants\n+\n+ty_utils_address_and_deref_not_supported = dereferencing or taking the address is not supported in generic constants\n+\n+ty_utils_array_not_supported = array construction is not supported in generic constants\n+\n+ty_utils_block_not_supported = blocks are not supported in generic constant\n+\n+ty_utils_never_to_any_not_supported = converting nevers to any is not supported in generic constant\n+\n+ty_utils_tuple_not_supported = tuple construction is not supported in generic constants\n+\n+ty_utils_index_not_supported = indexing is not supported in generic constant\n+\n+ty_utils_field_not_supported = field access is not supported in generic constant\n+\n+ty_utils_const_block_not_supported = const blocks are not supported in generic constant\n+\n+ty_utils_adt_not_supported = struct/enum construction is not supported in generic constants\n+\n+ty_utils_pointer_not_supported = pointer casts are not allowed in generic constants\n+\n+ty_utils_yield_not_supported = generator control flow is not allowed in generic constants\n+\n+ty_utils_loop_not_supported = loops and loop control flow are not supported in generic constants\n+\n+ty_utils_box_not_supported = allocations are not allowed in generic constants\n+\n+ty_utils_binary_not_supported = unsupported binary operation in generic constants\n+\n+ty_utils_logical_op_not_supported = unsupported operation in generic constants, short-circuiting operations would imply control flow\n+\n+ty_utils_assign_not_supported = assignment is not supported in generic constants\n+\n+ty_utils_closure_and_return_not_supported = closures and function keywords are not supported in generic constants\n+\n+ty_utils_control_flow_not_supported = control flow is not supported in generic constants\n+\n+ty_utils_inline_asm_not_supported = assembly is not supported in generic constants\n+\n+ty_utils_operation_not_supported = unsupported operation in generic constant"}, {"sha": "b18d1f553e49969dc769fe1aa9db0eda4ab81b12", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -32,10 +32,13 @@ pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n fluent_messages! {\n+    ast_lowering => \"../locales/en-US/ast_lowering.ftl\",\n     ast_passes => \"../locales/en-US/ast_passes.ftl\",\n+    attr => \"../locales/en-US/attr.ftl\",\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\",\n+    driver => \"../locales/en-US/driver.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n     interface => \"../locales/en-US/interface.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n@@ -44,7 +47,9 @@ fluent_messages! {\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n     save_analysis => \"../locales/en-US/save_analysis.ftl\",\n+    ty_utils => \"../locales/en-US/ty_utils.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n+    mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n }\n \n pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};"}, {"sha": "af7ef96e485b5c9af313ecc990ef878fed14b239", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -21,6 +21,7 @@\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n use crate::{\n+    errors::BuiltinEllpisisInclusiveRangePatterns,\n     types::{transparent_newtype_field, CItemKind},\n     EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n@@ -1760,18 +1761,11 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                     None => format!(\"&(..={})\", end),\n                 };\n                 if join.edition() >= Edition::Edition2021 {\n-                    let mut err = cx.sess().struct_span_err_with_code(\n-                        pat.span,\n-                        msg,\n-                        rustc_errors::error_code!(E0783),\n-                    );\n-                    err.span_suggestion(\n-                        pat.span,\n-                        suggestion,\n+                    cx.sess().emit_err(BuiltinEllpisisInclusiveRangePatterns {\n+                        span: pat.span,\n+                        suggestion: pat.span,\n                         replace,\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                    });\n                 } else {\n                     cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, |lint| {\n                         lint.build(msg)\n@@ -1787,18 +1781,11 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n             } else {\n                 let replace = \"..=\";\n                 if join.edition() >= Edition::Edition2021 {\n-                    let mut err = cx.sess().struct_span_err_with_code(\n-                        pat.span,\n-                        msg,\n-                        rustc_errors::error_code!(E0783),\n-                    );\n-                    err.span_suggestion_short(\n-                        join,\n-                        suggestion,\n-                        replace,\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                    cx.sess().emit_err(BuiltinEllpisisInclusiveRangePatterns {\n+                        span: pat.span,\n+                        suggestion: join,\n+                        replace: replace.to_string(),\n+                    });\n                 } else {\n                     cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, |lint| {\n                         lint.build(msg)"}, {"sha": "002bba4759be820ace8e656cd52a36f9fe52edca", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 35, "deletions": 58, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -16,12 +16,16 @@\n \n use self::TargetLint::*;\n \n+use crate::errors::{\n+    CheckNameDeprecated, CheckNameUnknown, CheckNameUnknownTool, CheckNameWarning, RequestedLevel,\n+    UnsupportedGroup,\n+};\n use crate::levels::LintLevelsBuilder;\n use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n use rustc_ast::util::unicode::TEXT_FLOW_CONTROL_CHARS;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n-use rustc_errors::{add_elided_lifetime_in_path_suggestion, struct_span_err};\n+use rustc_errors::add_elided_lifetime_in_path_suggestion;\n use rustc_errors::{\n     Applicability, DecorateLint, LintDiagnosticBuilder, MultiSpan, SuggestionStyle,\n };\n@@ -39,7 +43,7 @@ use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintI\n use rustc_session::Session;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::{BytePos, Span, DUMMY_SP};\n+use rustc_span::{BytePos, Span};\n use rustc_target::abi;\n use tracing::debug;\n \n@@ -326,68 +330,41 @@ impl LintStore {\n     ) {\n         let (tool_name, lint_name_only) = parse_lint_and_tool_name(lint_name);\n         if lint_name_only == crate::WARNINGS.name_lower() && matches!(level, Level::ForceWarn(_)) {\n-            struct_span_err!(\n-                sess,\n-                DUMMY_SP,\n-                E0602,\n-                \"`{}` lint group is not supported with \u00b4--force-warn\u00b4\",\n-                crate::WARNINGS.name_lower()\n-            )\n-            .emit();\n+            sess.emit_err(UnsupportedGroup { lint_group: crate::WARNINGS.name_lower() });\n             return;\n         }\n-        let db = match self.check_lint_name(lint_name_only, tool_name, registered_tools) {\n-            CheckLintNameResult::Ok(_) => None,\n-            CheckLintNameResult::Warning(ref msg, _) => Some(sess.struct_warn(msg)),\n+        let lint_name = lint_name.to_string();\n+        match self.check_lint_name(lint_name_only, tool_name, registered_tools) {\n+            CheckLintNameResult::Warning(msg, _) => {\n+                sess.emit_warning(CheckNameWarning {\n+                    msg,\n+                    sub: RequestedLevel { level, lint_name },\n+                });\n+            }\n             CheckLintNameResult::NoLint(suggestion) => {\n-                let mut err =\n-                    struct_span_err!(sess, DUMMY_SP, E0602, \"unknown lint: `{}`\", lint_name);\n-\n-                if let Some(suggestion) = suggestion {\n-                    err.help(&format!(\"did you mean: `{}`\", suggestion));\n+                sess.emit_err(CheckNameUnknown {\n+                    lint_name: lint_name.clone(),\n+                    suggestion,\n+                    sub: RequestedLevel { level, lint_name },\n+                });\n+            }\n+            CheckLintNameResult::Tool(result) => {\n+                if let Err((Some(_), new_name)) = result {\n+                    sess.emit_warning(CheckNameDeprecated {\n+                        lint_name: lint_name.clone(),\n+                        new_name,\n+                        sub: RequestedLevel { level, lint_name },\n+                    });\n                 }\n-\n-                Some(err.forget_guarantee())\n             }\n-            CheckLintNameResult::Tool(result) => match result {\n-                Err((Some(_), new_name)) => Some(sess.struct_warn(&format!(\n-                    \"lint name `{}` is deprecated \\\n-                     and does not have an effect anymore. \\\n-                     Use: {}\",\n-                    lint_name, new_name\n-                ))),\n-                _ => None,\n-            },\n-            CheckLintNameResult::NoTool => Some(\n-                struct_span_err!(\n-                    sess,\n-                    DUMMY_SP,\n-                    E0602,\n-                    \"unknown lint tool: `{}`\",\n-                    tool_name.unwrap()\n-                )\n-                .forget_guarantee(),\n-            ),\n+            CheckLintNameResult::NoTool => {\n+                sess.emit_err(CheckNameUnknownTool {\n+                    tool_name: tool_name.unwrap(),\n+                    sub: RequestedLevel { level, lint_name },\n+                });\n+            }\n+            _ => {}\n         };\n-\n-        if let Some(mut db) = db {\n-            let msg = format!(\n-                \"requested on the command line with `{} {}`\",\n-                match level {\n-                    Level::Allow => \"-A\",\n-                    Level::Warn => \"-W\",\n-                    Level::ForceWarn(_) => \"--force-warn\",\n-                    Level::Deny => \"-D\",\n-                    Level::Forbid => \"-F\",\n-                    Level::Expect(_) => {\n-                        unreachable!(\"lints with the level of `expect` should not run this code\");\n-                    }\n-                },\n-                lint_name\n-            );\n-            db.note(&msg);\n-            db.emit();\n-        }\n     }\n \n     /// True if this symbol represents a lint group name."}, {"sha": "606d8bda8aafe6c7548731caaacdb9d75ca1c44c", "filename": "compiler/rustc_lint/src/errors.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,162 @@\n+use rustc_errors::{fluent, AddSubdiagnostic, ErrorGuaranteed};\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_session::{lint::Level, parse::ParseSess, SessionDiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(lint::overruled_attribute, code = \"E0453\")]\n+pub struct OverruledAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub overruled: Span,\n+    pub lint_level: String,\n+    pub lint_source: Symbol,\n+    #[subdiagnostic]\n+    pub sub: OverruledAttributeSub,\n+}\n+//\n+pub enum OverruledAttributeSub {\n+    DefaultSource { id: String },\n+    NodeSource { span: Span, reason: Option<Symbol> },\n+    CommandLineSource,\n+}\n+\n+impl AddSubdiagnostic for OverruledAttributeSub {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            OverruledAttributeSub::DefaultSource { id } => {\n+                diag.note(fluent::lint::default_source);\n+                diag.set_arg(\"id\", id);\n+            }\n+            OverruledAttributeSub::NodeSource { span, reason } => {\n+                diag.span_label(span, fluent::lint::node_source);\n+                if let Some(rationale) = reason {\n+                    diag.note(rationale.as_str());\n+                }\n+            }\n+            OverruledAttributeSub::CommandLineSource => {\n+                diag.note(fluent::lint::command_line_source);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(lint::malformed_attribute, code = \"E0452\")]\n+pub struct MalformedAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: MalformedAttributeSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum MalformedAttributeSub {\n+    #[label(lint::bad_attribute_argument)]\n+    BadAttributeArgument(#[primary_span] Span),\n+    #[label(lint::reason_must_be_string_literal)]\n+    ReasonMustBeStringLiteral(#[primary_span] Span),\n+    #[label(lint::reason_must_come_last)]\n+    ReasonMustComeLast(#[primary_span] Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(lint::unknown_tool_in_scoped_lint, code = \"E0710\")]\n+pub struct UnknownToolInScopedLint {\n+    #[primary_span]\n+    pub span: Option<Span>,\n+    pub tool_name: Symbol,\n+    pub lint_name: String,\n+    #[help]\n+    pub is_nightly_build: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(lint::builtin_ellipsis_inclusive_range_patterns, code = \"E0783\")]\n+pub struct BuiltinEllpisisInclusiveRangePatterns {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion_short(code = \"{replace}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub replace: String,\n+}\n+\n+pub struct RequestedLevel {\n+    pub level: Level,\n+    pub lint_name: String,\n+}\n+\n+impl AddSubdiagnostic for RequestedLevel {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        diag.note(fluent::lint::requested_level);\n+        diag.set_arg(\n+            \"level\",\n+            match self.level {\n+                Level::Allow => \"-A\",\n+                Level::Warn => \"-W\",\n+                Level::ForceWarn(_) => \"--force-warn\",\n+                Level::Deny => \"-D\",\n+                Level::Forbid => \"-F\",\n+                Level::Expect(_) => {\n+                    unreachable!(\"lints with the level of `expect` should not run this code\");\n+                }\n+            },\n+        );\n+        diag.set_arg(\"lint_name\", self.lint_name);\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(lint::unsupported_group, code = \"E0602\")]\n+pub struct UnsupportedGroup {\n+    pub lint_group: String,\n+}\n+\n+pub struct CheckNameUnknown {\n+    pub lint_name: String,\n+    pub suggestion: Option<Symbol>,\n+    pub sub: RequestedLevel,\n+}\n+\n+impl SessionDiagnostic<'_> for CheckNameUnknown {\n+    fn into_diagnostic(\n+        self,\n+        sess: &ParseSess,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(fluent::lint::check_name_unknown);\n+        diag.code(rustc_errors::error_code!(E0602));\n+        if let Some(suggestion) = self.suggestion {\n+            diag.help(fluent::lint::help);\n+            diag.set_arg(\"suggestion\", suggestion);\n+        }\n+        diag.set_arg(\"lint_name\", self.lint_name);\n+        diag.subdiagnostic(self.sub);\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(lint::check_name_unknown_tool, code = \"E0602\")]\n+pub struct CheckNameUnknownTool {\n+    pub tool_name: Symbol,\n+    #[subdiagnostic]\n+    pub sub: RequestedLevel,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(lint::check_name_warning)]\n+pub struct CheckNameWarning {\n+    pub msg: String,\n+    #[subdiagnostic]\n+    pub sub: RequestedLevel,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(lint::check_name_deprecated)]\n+pub struct CheckNameDeprecated {\n+    pub lint_name: String,\n+    pub new_name: String,\n+    #[subdiagnostic]\n+    pub sub: RequestedLevel,\n+}"}, {"sha": "89409b58f88b90af3d5762e537c33ac986f7c131", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 55, "deletions": 43, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -3,7 +3,7 @@ use crate::late::unerased_lint_store;\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, LintDiagnosticBuilder, MultiSpan};\n+use rustc_errors::{Applicability, Diagnostic, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::{intravisit, HirId};\n use rustc_middle::hir::nested_filter;\n@@ -23,6 +23,11 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use tracing::debug;\n \n+use crate::errors::{\n+    MalformedAttribute, MalformedAttributeSub, OverruledAttribute, OverruledAttributeSub,\n+    UnknownToolInScopedLint,\n+};\n+\n fn lint_levels(tcx: TyCtxt<'_>, (): ()) -> LintLevelMap {\n     let store = unerased_lint_store(tcx);\n     let levels =\n@@ -186,16 +191,26 @@ impl<'s> LintLevelsBuilder<'s> {\n                     }\n                 };\n                 if !fcw_warning {\n-                    let mut diag_builder = struct_span_err!(\n-                        self.sess,\n-                        src.span(),\n-                        E0453,\n-                        \"{}({}) incompatible with previous forbid\",\n-                        level.as_str(),\n-                        src.name(),\n-                    );\n-                    decorate_diag(&mut diag_builder);\n-                    diag_builder.emit();\n+                    self.sess.emit_err(OverruledAttribute {\n+                        span: src.span(),\n+                        overruled: src.span(),\n+                        lint_level: level.as_str().to_string(),\n+                        lint_source: src.name(),\n+                        sub: match old_src {\n+                            LintLevelSource::Default => {\n+                                OverruledAttributeSub::DefaultSource { id: id.to_string() }\n+                            }\n+                            LintLevelSource::Node(_, forbid_source_span, reason) => {\n+                                OverruledAttributeSub::NodeSource {\n+                                    span: forbid_source_span,\n+                                    reason,\n+                                }\n+                            }\n+                            LintLevelSource::CommandLine(_, _) => {\n+                                OverruledAttributeSub::CommandLineSource\n+                            }\n+                        },\n+                    });\n                 } else {\n                     self.struct_lint(\n                         FORBIDDEN_LINT_GROUPS,\n@@ -266,7 +281,6 @@ impl<'s> LintLevelsBuilder<'s> {\n         self.cur = self.sets.list.push(LintSet { specs: FxHashMap::default(), parent: prev });\n \n         let sess = self.sess;\n-        let bad_attr = |span| struct_span_err!(sess, span, E0452, \"malformed lint attribute input\");\n         for (attr_index, attr) in attrs.iter().enumerate() {\n             if attr.has_name(sym::automatically_derived) {\n                 self.current_specs_mut().insert(\n@@ -317,20 +331,27 @@ impl<'s> LintLevelsBuilder<'s> {\n                                 }\n                                 reason = Some(rationale);\n                             } else {\n-                                bad_attr(name_value.span)\n-                                    .span_label(name_value.span, \"reason must be a string literal\")\n-                                    .emit();\n+                                sess.emit_err(MalformedAttribute {\n+                                    span: name_value.span,\n+                                    sub: MalformedAttributeSub::ReasonMustBeStringLiteral(\n+                                        name_value.span,\n+                                    ),\n+                                });\n                             }\n                             // found reason, reslice meta list to exclude it\n                             metas.pop().unwrap();\n                         } else {\n-                            bad_attr(item.span)\n-                                .span_label(item.span, \"bad attribute argument\")\n-                                .emit();\n+                            sess.emit_err(MalformedAttribute {\n+                                span: item.span,\n+                                sub: MalformedAttributeSub::BadAttributeArgument(item.span),\n+                            });\n                         }\n                     }\n                     ast::MetaItemKind::List(_) => {\n-                        bad_attr(item.span).span_label(item.span, \"bad attribute argument\").emit();\n+                        sess.emit_err(MalformedAttribute {\n+                            span: item.span,\n+                            sub: MalformedAttributeSub::BadAttributeArgument(item.span),\n+                        });\n                     }\n                 }\n             }\n@@ -348,20 +369,21 @@ impl<'s> LintLevelsBuilder<'s> {\n                 let meta_item = match li {\n                     ast::NestedMetaItem::MetaItem(meta_item) if meta_item.is_word() => meta_item,\n                     _ => {\n-                        let mut err = bad_attr(sp);\n-                        let mut add_label = true;\n                         if let Some(item) = li.meta_item() {\n                             if let ast::MetaItemKind::NameValue(_) = item.kind {\n                                 if item.path == sym::reason {\n-                                    err.span_label(sp, \"reason in lint attribute must come last\");\n-                                    add_label = false;\n+                                    sess.emit_err(MalformedAttribute {\n+                                        span: sp,\n+                                        sub: MalformedAttributeSub::ReasonMustComeLast(sp),\n+                                    });\n+                                    continue;\n                                 }\n                             }\n                         }\n-                        if add_label {\n-                            err.span_label(sp, \"bad attribute argument\");\n-                        }\n-                        err.emit();\n+                        sess.emit_err(MalformedAttribute {\n+                            span: sp,\n+                            sub: MalformedAttributeSub::BadAttributeArgument(sp),\n+                        });\n                         continue;\n                     }\n                 };\n@@ -485,22 +507,12 @@ impl<'s> LintLevelsBuilder<'s> {\n                     }\n \n                     &CheckLintNameResult::NoTool => {\n-                        let mut err = struct_span_err!(\n-                            sess,\n-                            tool_ident.map_or(DUMMY_SP, |ident| ident.span),\n-                            E0710,\n-                            \"unknown tool name `{}` found in scoped lint: `{}::{}`\",\n-                            tool_name.unwrap(),\n-                            tool_name.unwrap(),\n-                            pprust::path_to_string(&meta_item.path),\n-                        );\n-                        if sess.is_nightly_build() {\n-                            err.help(&format!(\n-                                \"add `#![register_tool({})]` to the crate root\",\n-                                tool_name.unwrap()\n-                            ));\n-                        }\n-                        err.emit();\n+                        sess.emit_err(UnknownToolInScopedLint {\n+                            span: tool_ident.map(|ident| ident.span),\n+                            tool_name: tool_name.unwrap(),\n+                            lint_name: pprust::path_to_string(&meta_item.path),\n+                            is_nightly_build: sess.is_nightly_build().then_some(()),\n+                        });\n                         continue;\n                     }\n "}, {"sha": "f34e062fd12a9791acf87b5e571a6e2dd958c643", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -47,6 +47,7 @@ pub mod builtin;\n mod context;\n mod early;\n mod enum_intrinsics_non_enums;\n+mod errors;\n mod expect;\n pub mod hidden_unicode_codepoints;\n mod internal;"}, {"sha": "385e9ba748fb9eeb6af6ad2bdaa2873118cb4e00", "filename": "compiler/rustc_mir_dataflow/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2FCargo.toml?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -13,10 +13,13 @@ smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n tracing = \"0.1\"\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "cc14257876c5c86c6304fd53e04847a69f385b42", "filename": "compiler/rustc_mir_dataflow/src/errors.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Ferrors.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,71 @@\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::{Span, Symbol};\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::path_must_end_in_filename)]\n+pub(crate) struct PathMustEndInFilename {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::unknown_formatter)]\n+pub(crate) struct UnknownFormatter {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::duplicate_values_for)]\n+pub(crate) struct DuplicateValuesFor {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::requires_an_argument)]\n+pub(crate) struct RequiresAnArgument {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::stop_after_dataflow_ended_compilation)]\n+pub(crate) struct StopAfterDataFlowEndedCompilation;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::peek_must_be_place_or_ref_place)]\n+pub(crate) struct PeekMustBePlaceOrRefPlace {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::peek_must_be_not_temporary)]\n+pub(crate) struct PeekMustBeNotTemporary {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::peek_bit_not_set)]\n+pub(crate) struct PeekBitNotSet {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::peek_argument_not_a_local)]\n+pub(crate) struct PeekArgumentNotALocal {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(mir_dataflow::peek_argument_untracked)]\n+pub(crate) struct PeekArgumentUntracked {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "112204c7599beb232fd34c27e60cb81dfa8858bf", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -1,5 +1,8 @@\n //! A solver for dataflow problems.\n \n+use crate::errors::{\n+    DuplicateValuesFor, PathMustEndInFilename, RequiresAnArgument, UnknownFormatter,\n+};\n use crate::framework::BitSetExt;\n \n use std::ffi::OsString;\n@@ -347,7 +350,7 @@ impl RustcMirAttrs {\n                     match path.file_name() {\n                         Some(_) => Ok(path),\n                         None => {\n-                            tcx.sess.span_err(attr.span(), \"path must end in a filename\");\n+                            tcx.sess.emit_err(PathMustEndInFilename { span: attr.span() });\n                             Err(())\n                         }\n                     }\n@@ -356,7 +359,7 @@ impl RustcMirAttrs {\n                 Self::set_field(&mut ret.formatter, tcx, &attr, |s| match s {\n                     sym::gen_kill | sym::two_phase => Ok(s),\n                     _ => {\n-                        tcx.sess.span_err(attr.span(), \"unknown formatter\");\n+                        tcx.sess.emit_err(UnknownFormatter { span: attr.span() });\n                         Err(())\n                     }\n                 })\n@@ -377,8 +380,7 @@ impl RustcMirAttrs {\n         mapper: impl FnOnce(Symbol) -> Result<T, ()>,\n     ) -> Result<(), ()> {\n         if field.is_some() {\n-            tcx.sess\n-                .span_err(attr.span(), &format!(\"duplicate values for `{}`\", attr.name_or_empty()));\n+            tcx.sess.emit_err(DuplicateValuesFor { span: attr.span(), name: attr.name_or_empty() });\n \n             return Err(());\n         }\n@@ -387,8 +389,7 @@ impl RustcMirAttrs {\n             *field = Some(mapper(s)?);\n             Ok(())\n         } else {\n-            tcx.sess\n-                .span_err(attr.span(), &format!(\"`{}` requires an argument\", attr.name_or_empty()));\n+            tcx.sess.emit_err(RequiresAnArgument { span: attr.span(), name: attr.name_or_empty() });\n             Err(())\n         }\n     }"}, {"sha": "62b712f7b8dbd32155e00ad4d2e9d94700c425c6", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -7,6 +7,8 @@\n #![feature(stmt_expr_attributes)]\n #![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate tracing;\n@@ -33,6 +35,7 @@ use self::move_paths::MoveData;\n \n pub mod drop_flag_effects;\n pub mod elaborate_drops;\n+mod errors;\n mod framework;\n pub mod impls;\n pub mod move_paths;"}, {"sha": "5fb7cb6584beb159a82602718380201e25fbf85a", "filename": "compiler/rustc_mir_dataflow/src/rustc_peek.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -6,6 +6,10 @@ use rustc_middle::mir::MirPass;\n use rustc_middle::mir::{self, Body, Local, Location};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n+use crate::errors::{\n+    PeekArgumentNotALocal, PeekArgumentUntracked, PeekBitNotSet, PeekMustBeNotTemporary,\n+    PeekMustBePlaceOrRefPlace, StopAfterDataFlowEndedCompilation,\n+};\n use crate::framework::BitSetExt;\n use crate::impls::{\n     DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeLiveLocals, MaybeUninitializedPlaces,\n@@ -64,7 +68,7 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         }\n \n         if has_rustc_mir_with(tcx, def_id, sym::stop_after_dataflow).is_some() {\n-            tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n+            tcx.sess.emit_fatal(StopAfterDataFlowEndedCompilation);\n         }\n     }\n }\n@@ -133,9 +137,7 @@ pub fn sanity_check_via_rustc_peek<'tcx, A>(\n             }\n \n             _ => {\n-                let msg = \"rustc_peek: argument expression \\\n-                           must be either `place` or `&place`\";\n-                tcx.sess.span_err(call.span, msg);\n+                tcx.sess.emit_err(PeekMustBePlaceOrRefPlace { span: call.span });\n             }\n         }\n     }\n@@ -204,18 +206,12 @@ impl PeekCall {\n                         if let Some(local) = place.as_local() {\n                             local\n                         } else {\n-                            tcx.sess.diagnostic().span_err(\n-                                span,\n-                                \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\",\n-                            );\n+                            tcx.sess.emit_err(PeekMustBeNotTemporary { span });\n                             return None;\n                         }\n                     }\n                     _ => {\n-                        tcx.sess.diagnostic().span_err(\n-                            span,\n-                            \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\",\n-                        );\n+                        tcx.sess.emit_err(PeekMustBeNotTemporary { span });\n                         return None;\n                     }\n                 };\n@@ -255,12 +251,12 @@ where\n                 let bit_state = flow_state.contains(peek_mpi);\n                 debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\", call.arg, place, bit_state);\n                 if !bit_state {\n-                    tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n+                    tcx.sess.emit_err(PeekBitNotSet { span: call.span });\n                 }\n             }\n \n             LookupResult::Parent(..) => {\n-                tcx.sess.span_err(call.span, \"rustc_peek: argument untracked\");\n+                tcx.sess.emit_err(PeekArgumentUntracked { span: call.span });\n             }\n         }\n     }\n@@ -276,12 +272,12 @@ impl<'tcx> RustcPeekAt<'tcx> for MaybeLiveLocals {\n     ) {\n         info!(?place, \"peek_at\");\n         let Some(local) = place.as_local() else {\n-            tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n+            tcx.sess.emit_err(PeekArgumentNotALocal { span: call.span });\n             return;\n         };\n \n         if !flow_state.contains(local) {\n-            tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n+            tcx.sess.emit_err(PeekBitNotSet { span: call.span });\n         }\n     }\n }"}, {"sha": "b08d2b376a6806a190a9a7e60f8af3709ed34026", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -250,13 +250,30 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 .map_or_else(String::new, |res| format!(\"{} \", res.descr()));\n                 (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)), None)\n             };\n+\n+            let (fallback_label, suggestion) = if path_str == \"async\"\n+                && expected.starts_with(\"struct\")\n+            {\n+                (\"`async` blocks are only allowed in Rust 2018 or later\".to_string(), suggestion)\n+            } else {\n+                // check if we are in situation of typo like `True` instead of `true`.\n+                let override_suggestion =\n+                    if [\"true\", \"false\"].contains(&item_str.to_string().to_lowercase().as_str()) {\n+                        let item_typo = item_str.to_string().to_lowercase();\n+                        Some((\n+                            item_span,\n+                            \"you may want to use a bool value instead\",\n+                            format!(\"{}\", item_typo),\n+                        ))\n+                    } else {\n+                        suggestion\n+                    };\n+                (format!(\"not found in {mod_str}\"), override_suggestion)\n+            };\n+\n             BaseError {\n                 msg: format!(\"cannot find {expected} `{item_str}` in {mod_prefix}{mod_str}\"),\n-                fallback_label: if path_str == \"async\" && expected.starts_with(\"struct\") {\n-                    \"`async` blocks are only allowed in Rust 2018 or later\".to_string()\n-                } else {\n-                    format!(\"not found in {mod_str}\")\n-                },\n+                fallback_label,\n                 span: item_span,\n                 span_label: None,\n                 could_be_expr: false,"}, {"sha": "ec5e5170d359494fbeae05002849ef132dd91c1d", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -20,8 +20,8 @@ use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n use rustc_errors::{\n-    fallback_fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage, EmissionGuarantee,\n-    ErrorGuaranteed, FluentBundle, LazyFallbackBundle, MultiSpan,\n+    error_code, fallback_fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n+    EmissionGuarantee, ErrorGuaranteed, FluentBundle, LazyFallbackBundle, MultiSpan,\n };\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n@@ -467,6 +467,9 @@ impl Session {\n         feature: Symbol,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut err = self.parse_sess.create_err(err);\n+        if err.code.is_none() {\n+            err.code = std::option::Option::Some(error_code!(E0658));\n+        }\n         add_feature_diagnostics(&mut err, &self.parse_sess, feature);\n         err\n     }"}, {"sha": "52fbd3ae047732c18b504514e4c210baec942559", "filename": "compiler/rustc_ty_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2FCargo.toml?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -10,6 +10,7 @@ rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_infer = { path = \"../rustc_infer\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "16c4d429129a9d499ba5c8524943ba6f520d899e", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 83, "deletions": 90, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -11,6 +11,8 @@ use rustc_target::abi::VariantIdx;\n \n use std::iter;\n \n+use crate::errors::{GenericConstantTooComplex, GenericConstantTooComplexSub};\n+\n /// Destructures array, ADT or tuple constants into the constants\n /// of their fields.\n pub(crate) fn destructure_const<'tcx>(\n@@ -93,26 +95,25 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         self.body.exprs[self.body_id].span\n     }\n \n-    fn error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n-        let reported = self\n-            .tcx\n-            .sess\n-            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n-            .span_label(span, msg)\n-            .help(\"consider moving this anonymous constant into a `const` function\")\n-            .emit();\n+    fn error(&mut self, sub: GenericConstantTooComplexSub) -> Result<!, ErrorGuaranteed> {\n+        let reported = self.tcx.sess.emit_err(GenericConstantTooComplex {\n+            span: self.root_span(),\n+            maybe_supported: None,\n+            sub,\n+        });\n \n         Err(reported)\n     }\n-    fn maybe_supported_error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n-        let reported = self\n-            .tcx\n-            .sess\n-            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n-            .span_label(span, msg)\n-            .help(\"consider moving this anonymous constant into a `const` function\")\n-            .note(\"this operation may be supported in the future\")\n-            .emit();\n+\n+    fn maybe_supported_error(\n+        &mut self,\n+        sub: GenericConstantTooComplexSub,\n+    ) -> Result<!, ErrorGuaranteed> {\n+        let reported = self.tcx.sess.emit_err(GenericConstantTooComplex {\n+            span: self.root_span(),\n+            maybe_supported: Some(()),\n+            sub,\n+        });\n \n         Err(reported)\n     }\n@@ -243,22 +244,23 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n             &ExprKind::PlaceTypeAscription { source, .. }\n             | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n-            &ExprKind::Literal { lit, neg} => {\n+            &ExprKind::Literal { lit, neg } => {\n                 let sp = node.span;\n-                let constant =\n-                    match self.tcx.at(sp).lit_to_const(LitToConstInput { lit: &lit.node, ty: node.ty, neg }) {\n-                        Ok(c) => c,\n-                        Err(LitToConstError::Reported) => {\n-                            self.tcx.const_error(node.ty)\n-                        }\n-                        Err(LitToConstError::TypeError) => {\n-                            bug!(\"encountered type error in lit_to_const\")\n-                        }\n-                    };\n+                let constant = match self.tcx.at(sp).lit_to_const(LitToConstInput {\n+                    lit: &lit.node,\n+                    ty: node.ty,\n+                    neg,\n+                }) {\n+                    Ok(c) => c,\n+                    Err(LitToConstError::Reported) => self.tcx.const_error(node.ty),\n+                    Err(LitToConstError::TypeError) => {\n+                        bug!(\"encountered type error in lit_to_const\")\n+                    }\n+                };\n \n                 self.nodes.push(Node::Leaf(constant))\n             }\n-            &ExprKind::NonHirLiteral { lit , user_ty: _} => {\n+            &ExprKind::NonHirLiteral { lit, user_ty: _ } => {\n                 let val = ty::ValTree::from_scalar_int(lit);\n                 self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n             }\n@@ -269,19 +271,17 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n                 let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);\n \n-                let constant = self.tcx.mk_const(ty::ConstS {\n-                                kind: ty::ConstKind::Unevaluated(uneval),\n-                                ty: node.ty,\n-                            });\n+                let constant = self\n+                    .tcx\n+                    .mk_const(ty::ConstS { kind: ty::ConstKind::Unevaluated(uneval), ty: node.ty });\n \n                 self.nodes.push(Node::Leaf(constant))\n             }\n \n-            ExprKind::ConstParam {param, ..} => {\n-                let const_param = self.tcx.mk_const(ty::ConstS {\n-                        kind: ty::ConstKind::Param(*param),\n-                        ty: node.ty,\n-                    });\n+            ExprKind::ConstParam { param, .. } => {\n+                let const_param = self\n+                    .tcx\n+                    .mk_const(ty::ConstS { kind: ty::ConstKind::Param(*param), ty: node.ty });\n                 self.nodes.push(Node::Leaf(const_param))\n             }\n \n@@ -312,13 +312,13 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             // }\n             // ```\n             ExprKind::Block { block } => {\n-                if let thir::Block { stmts: box [], expr: Some(e), .. } = &self.body.blocks[*block] {\n+                if let thir::Block { stmts: box [], expr: Some(e), .. } = &self.body.blocks[*block]\n+                {\n                     self.recurse_build(*e)?\n                 } else {\n-                    self.maybe_supported_error(\n+                    self.maybe_supported_error(GenericConstantTooComplexSub::BlockNotSupported(\n                         node.span,\n-                        \"blocks are not supported in generic constant\",\n-                    )?\n+                    ))?\n                 }\n             }\n             // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n@@ -332,7 +332,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let arg = self.recurse_build(source)?;\n                 self.nodes.push(Node::Cast(CastKind::As, arg, node.ty))\n             }\n-            ExprKind::Borrow{ arg, ..} => {\n+            ExprKind::Borrow { arg, .. } => {\n                 let arg_node = &self.body.exprs[*arg];\n \n                 // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n@@ -341,84 +341,77 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 if let ExprKind::Deref { arg } = arg_node.kind {\n                     self.recurse_build(arg)?\n                 } else {\n-                    self.maybe_supported_error(\n+                    self.maybe_supported_error(GenericConstantTooComplexSub::BorrowNotSupported(\n                         node.span,\n-                        \"borrowing is not supported in generic constants\",\n-                    )?\n+                    ))?\n                 }\n             }\n             // FIXME(generic_const_exprs): We may want to support these.\n-            ExprKind::AddressOf { .. } | ExprKind::Deref {..}=> self.maybe_supported_error(\n-                node.span,\n-                \"dereferencing or taking the address is not supported in generic constants\",\n+            ExprKind::AddressOf { .. } | ExprKind::Deref { .. } => self.maybe_supported_error(\n+                GenericConstantTooComplexSub::AddressAndDerefNotSupported(node.span),\n             )?,\n-            ExprKind::Repeat { .. } | ExprKind::Array { .. } =>  self.maybe_supported_error(\n-                node.span,\n-                \"array construction is not supported in generic constants\",\n+            ExprKind::Repeat { .. } | ExprKind::Array { .. } => self.maybe_supported_error(\n+                GenericConstantTooComplexSub::ArrayNotSupported(node.span),\n             )?,\n             ExprKind::NeverToAny { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"converting nevers to any is not supported in generic constant\",\n+                GenericConstantTooComplexSub::NeverToAnyNotSupported(node.span),\n             )?,\n             ExprKind::Tuple { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"tuple construction is not supported in generic constants\",\n+                GenericConstantTooComplexSub::TupleNotSupported(node.span),\n             )?,\n             ExprKind::Index { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"indexing is not supported in generic constant\",\n+                GenericConstantTooComplexSub::IndexNotSupported(node.span),\n             )?,\n             ExprKind::Field { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"field access is not supported in generic constant\",\n+                GenericConstantTooComplexSub::FieldNotSupported(node.span),\n             )?,\n             ExprKind::ConstBlock { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"const blocks are not supported in generic constant\",\n-            )?,\n-            ExprKind::Adt(_) => self.maybe_supported_error(\n-                node.span,\n-                \"struct/enum construction is not supported in generic constants\",\n+                GenericConstantTooComplexSub::ConstBlockNotSupported(node.span),\n             )?,\n+            ExprKind::Adt(_) => self\n+                .maybe_supported_error(GenericConstantTooComplexSub::AdtNotSupported(node.span))?,\n             // dont know if this is correct\n-            ExprKind::Pointer { .. } =>\n-                self.error(node.span, \"pointer casts are not allowed in generic constants\")?,\n-            ExprKind::Yield { .. } =>\n-                self.error(node.span, \"generator control flow is not allowed in generic constants\")?,\n-            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => self\n-                .error(\n-                    node.span,\n-                    \"loops and loop control flow are not supported in generic constants\",\n-                )?,\n-            ExprKind::Box { .. } =>\n-                self.error(node.span, \"allocations are not allowed in generic constants\")?,\n+            ExprKind::Pointer { .. } => {\n+                self.error(GenericConstantTooComplexSub::PointerNotSupported(node.span))?\n+            }\n+            ExprKind::Yield { .. } => {\n+                self.error(GenericConstantTooComplexSub::YieldNotSupported(node.span))?\n+            }\n+            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => {\n+                self.error(GenericConstantTooComplexSub::LoopNotSupported(node.span))?\n+            }\n+            ExprKind::Box { .. } => {\n+                self.error(GenericConstantTooComplexSub::BoxNotSupported(node.span))?\n+            }\n \n             ExprKind::Unary { .. } => unreachable!(),\n             // we handle valid unary/binary ops above\n-            ExprKind::Binary { .. } =>\n-                self.error(node.span, \"unsupported binary operation in generic constants\")?,\n-            ExprKind::LogicalOp { .. } =>\n-                self.error(node.span, \"unsupported operation in generic constants, short-circuiting operations would imply control flow\")?,\n+            ExprKind::Binary { .. } => {\n+                self.error(GenericConstantTooComplexSub::BinaryNotSupported(node.span))?\n+            }\n+            ExprKind::LogicalOp { .. } => {\n+                self.error(GenericConstantTooComplexSub::LogicalOpNotSupported(node.span))?\n+            }\n             ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n-                self.error(node.span, \"assignment is not supported in generic constants\")?\n+                self.error(GenericConstantTooComplexSub::AssignNotSupported(node.span))?\n+            }\n+            ExprKind::Closure { .. } | ExprKind::Return { .. } => {\n+                self.error(GenericConstantTooComplexSub::ClosureAndReturnNotSupported(node.span))?\n             }\n-            ExprKind::Closure { .. } | ExprKind::Return { .. } => self.error(\n-                node.span,\n-                \"closures and function keywords are not supported in generic constants\",\n-            )?,\n             // let expressions imply control flow\n-            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } =>\n-                self.error(node.span, \"control flow is not supported in generic constants\")?,\n+            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } => {\n+                self.error(GenericConstantTooComplexSub::ControlFlowNotSupported(node.span))?\n+            }\n             ExprKind::InlineAsm { .. } => {\n-                self.error(node.span, \"assembly is not supported in generic constants\")?\n+                self.error(GenericConstantTooComplexSub::InlineAsmNotSupported(node.span))?\n             }\n \n             // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n             ExprKind::VarRef { .. }\n             | ExprKind::UpvarRef { .. }\n             | ExprKind::StaticRef { .. }\n             | ExprKind::ThreadLocalRef(_) => {\n-                self.error(node.span, \"unsupported operation in generic constant\")?\n+                self.error(GenericConstantTooComplexSub::OperationNotSupported(node.span))?\n             }\n         })\n     }"}, {"sha": "3a8ef96c991f2b24e5e37c602cdd8ce57cf3814f", "filename": "compiler/rustc_ty_utils/src/errors.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,69 @@\n+//! Errors emitted by ty_utils\n+\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_middle::ty::Ty;\n+use rustc_span::Span;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ty_utils::needs_drop_overflow)]\n+pub struct NeedsDropOverflow<'tcx> {\n+    pub query_ty: Ty<'tcx>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ty_utils::generic_constant_too_complex)]\n+#[help]\n+pub struct GenericConstantTooComplex {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note(ty_utils::maybe_supported)]\n+    pub maybe_supported: Option<()>,\n+    #[subdiagnostic]\n+    pub sub: GenericConstantTooComplexSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum GenericConstantTooComplexSub {\n+    #[label(ty_utils::borrow_not_supported)]\n+    BorrowNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::address_and_deref_not_supported)]\n+    AddressAndDerefNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::array_not_supported)]\n+    ArrayNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::block_not_supported)]\n+    BlockNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::never_to_any_not_supported)]\n+    NeverToAnyNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::tuple_not_supported)]\n+    TupleNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::index_not_supported)]\n+    IndexNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::field_not_supported)]\n+    FieldNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::const_block_not_supported)]\n+    ConstBlockNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::adt_not_supported)]\n+    AdtNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::pointer_not_supported)]\n+    PointerNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::yield_not_supported)]\n+    YieldNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::loop_not_supported)]\n+    LoopNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::box_not_supported)]\n+    BoxNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::binary_not_supported)]\n+    BinaryNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::logical_op_not_supported)]\n+    LogicalOpNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::assign_not_supported)]\n+    AssignNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::closure_and_return_not_supported)]\n+    ClosureAndReturnNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::control_flow_not_supported)]\n+    ControlFlowNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::inline_asm_not_supported)]\n+    InlineAsmNotSupported(#[primary_span] Span),\n+    #[label(ty_utils::operation_not_supported)]\n+    OperationNotSupported(#[primary_span] Span),\n+}"}, {"sha": "6931b15b1ba5735f5b41e09f4ba5133a7f12063d", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -10,6 +10,8 @@\n #![feature(never_type)]\n #![feature(box_patterns)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;\n@@ -21,6 +23,7 @@ use rustc_middle::ty::query::Providers;\n mod assoc;\n mod common_traits;\n mod consts;\n+mod errors;\n mod implied_bounds;\n pub mod instance;\n mod needs_drop;"}, {"sha": "ab5a3d8ae48923d903a0bbe741834d37800375e6", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -9,6 +9,8 @@ use rustc_middle::ty::{self, EarlyBinder, Ty, TyCtxt};\n use rustc_session::Limit;\n use rustc_span::{sym, DUMMY_SP};\n \n+use crate::errors::NeedsDropOverflow;\n+\n type NeedsDropResult<T> = Result<T, AlwaysRequiresDrop>;\n \n fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n@@ -90,10 +92,7 @@ where\n             if !self.recursion_limit.value_within_limit(level) {\n                 // Not having a `Span` isn't great. But there's hopefully some other\n                 // recursion limit error as well.\n-                tcx.sess.span_err(\n-                    DUMMY_SP,\n-                    &format!(\"overflow while checking whether `{}` requires drop\", self.query_ty),\n-                );\n+                tcx.sess.emit_err(NeedsDropOverflow { query_ty: self.query_ty });\n                 return Some(Err(AlwaysRequiresDrop));\n             }\n "}, {"sha": "deab0fb05b76b4cbe2e5ab4c7e41410b436e50f0", "filename": "src/test/ui/suggestions/bool_typo_err_suggest.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/src%2Ftest%2Fui%2Fsuggestions%2Fbool_typo_err_suggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/src%2Ftest%2Fui%2Fsuggestions%2Fbool_typo_err_suggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fbool_typo_err_suggest.rs?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,12 @@\n+// Suggest the boolean value instead of emit a generic error that the value\n+// True is not in the scope.\n+\n+fn main() {\n+    let x = True;\n+    //~^ ERROR cannot find value `True` in this scope\n+    //~| HELP you may want to use a bool value instead\n+\n+    let y = False;\n+    //~^ ERROR cannot find value `False` in this scope\n+    //~| HELP you may want to use a bool value instead\n+}"}, {"sha": "52bde07ca07701e0f786a40f604fff1cb5a7b484", "filename": "src/test/ui/suggestions/bool_typo_err_suggest.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bb8a08f011ce481adc62e45150b642d1f160bd78/src%2Ftest%2Fui%2Fsuggestions%2Fbool_typo_err_suggest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb8a08f011ce481adc62e45150b642d1f160bd78/src%2Ftest%2Fui%2Fsuggestions%2Fbool_typo_err_suggest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fbool_typo_err_suggest.stderr?ref=bb8a08f011ce481adc62e45150b642d1f160bd78", "patch": "@@ -0,0 +1,25 @@\n+error[E0425]: cannot find value `True` in this scope\n+  --> $DIR/bool_typo_err_suggest.rs:5:13\n+   |\n+LL |     let x = True;\n+   |             ^^^^ not found in this scope\n+   |\n+help: you may want to use a bool value instead\n+   |\n+LL |     let x = true;\n+   |             ~~~~\n+\n+error[E0425]: cannot find value `False` in this scope\n+  --> $DIR/bool_typo_err_suggest.rs:9:13\n+   |\n+LL |     let y = False;\n+   |             ^^^^^ not found in this scope\n+   |\n+help: you may want to use a bool value instead\n+   |\n+LL |     let y = false;\n+   |             ~~~~~\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}]}