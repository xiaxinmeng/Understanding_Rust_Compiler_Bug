{"sha": "ad9b1ed9c286d26666b7892145c5cae7f98488bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOWIxZWQ5YzI4NmQyNjY2NmI3ODkyMTQ1YzVjYWU3Zjk4NDg4YmM=", "commit": {"author": {"name": "Garrett Berg", "email": "googberg@gmail.com", "date": "2017-10-02T07:08:13Z"}, "committer": {"name": "Garrett Berg", "email": "googberg@gmail.com", "date": "2017-10-04T13:20:59Z"}, "message": "groundwork for #45009: rustc_dirty/clean enhancements", "tree": {"sha": "3990145e4bce033e11173ccbb7590920ff2075b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3990145e4bce033e11173ccbb7590920ff2075b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad9b1ed9c286d26666b7892145c5cae7f98488bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9b1ed9c286d26666b7892145c5cae7f98488bc", "html_url": "https://github.com/rust-lang/rust/commit/ad9b1ed9c286d26666b7892145c5cae7f98488bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad9b1ed9c286d26666b7892145c5cae7f98488bc/comments", "author": {"login": "vitiral", "id": 5587659, "node_id": "MDQ6VXNlcjU1ODc2NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/5587659?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vitiral", "html_url": "https://github.com/vitiral", "followers_url": "https://api.github.com/users/vitiral/followers", "following_url": "https://api.github.com/users/vitiral/following{/other_user}", "gists_url": "https://api.github.com/users/vitiral/gists{/gist_id}", "starred_url": "https://api.github.com/users/vitiral/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vitiral/subscriptions", "organizations_url": "https://api.github.com/users/vitiral/orgs", "repos_url": "https://api.github.com/users/vitiral/repos", "events_url": "https://api.github.com/users/vitiral/events{/privacy}", "received_events_url": "https://api.github.com/users/vitiral/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vitiral", "id": 5587659, "node_id": "MDQ6VXNlcjU1ODc2NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/5587659?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vitiral", "html_url": "https://github.com/vitiral", "followers_url": "https://api.github.com/users/vitiral/followers", "following_url": "https://api.github.com/users/vitiral/following{/other_user}", "gists_url": "https://api.github.com/users/vitiral/gists{/gist_id}", "starred_url": "https://api.github.com/users/vitiral/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vitiral/subscriptions", "organizations_url": "https://api.github.com/users/vitiral/orgs", "repos_url": "https://api.github.com/users/vitiral/repos", "events_url": "https://api.github.com/users/vitiral/events{/privacy}", "received_events_url": "https://api.github.com/users/vitiral/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51cd06170eccf91a2d93018e939473a8db18da92", "url": "https://api.github.com/repos/rust-lang/rust/commits/51cd06170eccf91a2d93018e939473a8db18da92", "html_url": "https://github.com/rust-lang/rust/commit/51cd06170eccf91a2d93018e939473a8db18da92"}], "stats": {"total": 76, "additions": 64, "deletions": 12}, "files": [{"sha": "eef99b0eb286ac9160afc1c9531ef4ffe21078b7", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad9b1ed9c286d26666b7892145c5cae7f98488bc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9b1ed9c286d26666b7892145c5cae7f98488bc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=ad9b1ed9c286d26666b7892145c5cae7f98488bc", "patch": "@@ -339,6 +339,25 @@ macro_rules! define_dep_nodes {\n                     Ok(DepNode::new_no_params(kind))\n                 }\n             }\n+\n+            /// Used in testing\n+            pub fn has_label_string(label: &str) -> bool {\n+                match label {\n+                    $(\n+                        stringify!($variant) => true,\n+                    )*\n+                    _ => false,\n+                }\n+            }\n+        }\n+\n+        /// Contains variant => str representations for constructing\n+        /// DepNode groups for tests.\n+        #[allow(dead_code, non_upper_case_globals)]\n+        pub mod label_strs {\n+           $(\n+                pub const $variant: &'static str = stringify!($variant);\n+            )*\n         }\n     );\n }"}, {"sha": "186759d6219e982b4a54804ba9e083bd3e854dbd", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ad9b1ed9c286d26666b7892145c5cae7f98488bc/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9b1ed9c286d26666b7892145c5cae7f98488bc/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=ad9b1ed9c286d26666b7892145c5cae7f98488bc", "patch": "@@ -39,6 +39,8 @@\n //! previous revision to compare things to.\n //!\n \n+use std::collections::HashSet;\n+use std::vec::Vec;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -54,6 +56,8 @@ use rustc::ty::TyCtxt;\n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n+type Labels = HashSet<String>;\n+\n pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.sess.features.borrow().rustc_attrs {\n@@ -87,23 +91,46 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-    fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode {\n-        let def_path_hash = self.tcx.def_path_hash(def_id);\n+    fn labels(&self, attr: &Attribute) -> Labels {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, &item);\n-                match DepNode::from_label_string(&value.as_str(), def_path_hash) {\n-                    Ok(dep_node) => return dep_node,\n-                    Err(()) => {\n-                        self.tcx.sess.span_fatal(\n-                            item.span,\n-                            &format!(\"dep-node label `{}` not recognized\", value));\n-                    }\n+                return self.resolve_labels(&item, value.as_str().as_ref());\n+            }\n+        }\n+        self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n+    }\n+\n+    fn resolve_labels(&self, item: &NestedMetaItem, value: &str) -> Labels {\n+        let mut out: Labels = HashSet::new();\n+        for label in value.split(',') {\n+            let label = label.trim();\n+            if DepNode::has_label_string(label) {\n+                if out.contains(label) {\n+                    self.tcx.sess.span_fatal(\n+                        item.span,\n+                        &format!(\"dep-node label `{}` is repeated\", label));\n                 }\n+                out.insert(label.to_string());\n+            } else {\n+                self.tcx.sess.span_fatal(\n+                    item.span,\n+                    &format!(\"dep-node label `{}` not recognized\", label));\n             }\n         }\n+        out\n+    }\n \n-        self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n+    fn dep_nodes(&self, labels: &Labels, def_id: DefId) -> Vec<DepNode> {\n+        let mut out = Vec::with_capacity(labels.len());\n+        let def_path_hash = self.tcx.def_path_hash(def_id);\n+        for label in labels.iter() {\n+            match DepNode::from_label_string(label, def_path_hash) {\n+                Ok(dep_node) => out.push(dep_node),\n+                Err(()) => unreachable!(),\n+            }\n+        }\n+        out\n     }\n \n     fn dep_node_str(&self, dep_node: &DepNode) -> String {\n@@ -150,12 +177,18 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n             if attr.check_name(ATTR_DIRTY) {\n                 if check_config(self.tcx, attr) {\n                     self.checked_attrs.insert(attr.id);\n-                    self.assert_dirty(item_span, self.dep_node(attr, def_id));\n+                    let labels = self.labels(attr);\n+                    for dep_node in self.dep_nodes(&labels, def_id) {\n+                        self.assert_dirty(item_span, dep_node);\n+                    }\n                 }\n             } else if attr.check_name(ATTR_CLEAN) {\n                 if check_config(self.tcx, attr) {\n                     self.checked_attrs.insert(attr.id);\n-                    self.assert_clean(item_span, self.dep_node(attr, def_id));\n+                    let labels = self.labels(attr);\n+                    for dep_node in self.dep_nodes(&labels, def_id) {\n+                        self.assert_clean(item_span, dep_node);\n+                    }\n                 }\n             }\n         }"}]}