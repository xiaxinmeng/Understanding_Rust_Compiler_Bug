{"sha": "8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NzFjMTdiNzZhMWUwYWIzNmNlMmJiNTEwMDhiNTNmNTk2ZTViM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-28T22:13:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-28T22:13:42Z"}, "message": "Auto merge of #24781 - bluss:vec-drain-range, r=alexcrichton\n\nImplement Vec::drain(\\<range type\\>) from rust-lang/rfcs#574, tracking issue #23055.\r\n\r\nThis is a big step forward for vector usability. This is an introduction of an API for removing a range of *m* consecutive elements from a vector, as efficently as possible.\r\n\r\nNew features:\r\n\r\n- Introduce trait `std::collections::range::RangeArgument` implemented by all four built-in range types.\r\n- Change `Vec::drain()` to use `Vec::drain<R: RangeArgument>(R)`\r\n\r\nImplementation notes:\r\n\r\n- Use @Gankro's idea for memory safety: Use `set_len` on the source vector when creating the iterator, to make sure that the part of the vector that will be modified is unreachable. Fix up things in Drain's destructor \u2014 but even if it doesn't run, we don't expose any moved-out-from slots of the vector.\r\n- This `.drain<R>(R)` very close to how it is specified in the RFC.\r\n- Introduced as unstable\r\n- Drain reuses the slice iterator \u2014 copying and pasting the same iterator pointer arithmetic again felt very bad\r\n- The `usize` index as a range argument in the RFC is not included. The ranges trait would have to change to accomodate it.\r\n\r\nPlease help me with:\r\n\r\n- Name and location of the new ranges trait.\r\n- Design of the ranges trait\r\n- Understanding Niko's comments about variance (Note: for a long time I was using a straight up &mut Vec in the iterator, but I changed this to permit reusing the slice iterator).\r\n\r\nPrevious PR and discussion: #23071", "tree": {"sha": "5c1266423c1dd3e9a7728303a96b42636402e9e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c1266423c1dd3e9a7728303a96b42636402e9e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "html_url": "https://github.com/rust-lang/rust/commit/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cadc67e8fd942e0a3896ed0d5375444b221e60d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cadc67e8fd942e0a3896ed0d5375444b221e60d7", "html_url": "https://github.com/rust-lang/rust/commit/cadc67e8fd942e0a3896ed0d5375444b221e60d7"}, {"sha": "b475fc7d6aa1cafa91790c273908fddfb669a82e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b475fc7d6aa1cafa91790c273908fddfb669a82e", "html_url": "https://github.com/rust-lang/rust/commit/b475fc7d6aa1cafa91790c273908fddfb669a82e"}], "stats": {"total": 259, "additions": 174, "deletions": 85}, "files": [{"sha": "af7112a5cb4e30147c7a3228eb3832c3d89c4e80", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "patch": "@@ -546,7 +546,7 @@ impl<T: Ord> BinaryHeap<T> {\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n-        Drain { iter: self.data.drain() }\n+        Drain { iter: self.data.drain(..) }\n     }\n \n     /// Drops all items from the binary heap."}, {"sha": "ae2ad7751aab764b31780c6d59a8a1af75202fe1", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "patch": "@@ -42,7 +42,8 @@\n #![feature(slice_patterns)]\n #![feature(debug_builders)]\n #![feature(utf8_error)]\n-#![cfg_attr(test, feature(rand, rustc_private, test, hash, collections))]\n+#![cfg_attr(test, feature(rand, rustc_private, test, hash, collections,\n+                          collections_drain, collections_range))]\n #![cfg_attr(test, allow(deprecated))] // rand\n \n #![feature(no_std)]\n@@ -82,6 +83,7 @@ pub mod borrow;\n pub mod enum_set;\n pub mod fmt;\n pub mod linked_list;\n+pub mod range;\n pub mod slice;\n pub mod str;\n pub mod string;"}, {"sha": "6ab143998d299f5222057e8372b58a083ad916be", "filename": "src/libcollections/range.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![unstable(feature = \"collections_range\", reason = \"was just added\")]\n+\n+//! Range syntax.\n+\n+use core::option::Option::{self, None, Some};\n+use core::ops::{RangeFull, Range, RangeTo, RangeFrom};\n+\n+/// **RangeArgument** is implemented by Rust's built-in range types, produced\n+/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n+pub trait RangeArgument<T> {\n+    /// Start index (inclusive)\n+    ///\n+    /// Return start value if present, else `None`.\n+    fn start(&self) -> Option<&T> { None }\n+\n+    /// End index (exclusive)\n+    ///\n+    /// Return end value if present, else `None`.\n+    fn end(&self) -> Option<&T> { None }\n+}\n+\n+\n+impl<T> RangeArgument<T> for RangeFull {}\n+\n+impl<T> RangeArgument<T> for RangeFrom<T> {\n+    fn start(&self) -> Option<&T> { Some(&self.start) }\n+}\n+\n+impl<T> RangeArgument<T> for RangeTo<T> {\n+    fn end(&self) -> Option<&T> { Some(&self.end) }\n+}\n+\n+impl<T> RangeArgument<T> for Range<T> {\n+    fn start(&self) -> Option<&T> { Some(&self.start) }\n+    fn end(&self) -> Option<&T> { Some(&self.end) }\n+}"}, {"sha": "f42c48681a92652cbc7e52add6732b34822a5d9d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 87, "deletions": 78, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "patch": "@@ -69,6 +69,8 @@ use core::usize;\n \n use borrow::{Cow, IntoCow};\n \n+use super::range::RangeArgument;\n+\n // FIXME- fix places which assume the max vector allowed has memory usize::MAX.\n static MAX_MEMORY_SIZE: usize = isize::MAX as usize;\n \n@@ -714,36 +716,61 @@ impl<T> Vec<T> {\n         unsafe { other.set_len(0); }\n     }\n \n-    /// Creates a draining iterator that clears the `Vec` and iterates over\n-    /// the removed items from start to end.\n+    /// Create a draining iterator that removes the specified range in the vector\n+    /// and yields the removed items from start to end. The element range is\n+    /// removed even if the iterator is not consumed until the end.\n+    ///\n+    /// Note: It is unspecified how many elements are removed from the vector,\n+    /// if the `Drain` value is leaked.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n-    /// let mut v = vec![\"a\".to_string(), \"b\".to_string()];\n-    /// for s in v.drain() {\n-    ///     // s has type String, not &String\n-    ///     println!(\"{}\", s);\n-    /// }\n-    /// assert!(v.is_empty());\n+    /// # #![feature(collections_drain, collections_range)]\n+    ///\n+    /// // Draining using `..` clears the whole vector.\n+    /// let mut v = vec![1, 2, 3];\n+    /// let u: Vec<_> = v.drain(..).collect();\n+    /// assert_eq!(v, &[]);\n+    /// assert_eq!(u, &[1, 2, 3]);\n     /// ```\n-    #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn drain(&mut self) -> Drain<T> {\n+    #[unstable(feature = \"collections_drain\",\n+               reason = \"recently added, matches RFC\")]\n+    pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n+        // Memory safety\n+        //\n+        // When the Drain is first created, it shortens the length of\n+        // the source vector to make sure no uninitalized or moved-from elements\n+        // are accessible at all if the Drain's destructor never gets to run.\n+        //\n+        // Drain will ptr::read out the values to remove.\n+        // When finished, remaining tail of the vec is copied back to cover\n+        // the hole, and the vector length is restored to the new length.\n+        //\n+        let len = self.len();\n+        let start = *range.start().unwrap_or(&0);\n+        let end = *range.end().unwrap_or(&len);\n+        assert!(start <= end);\n+        assert!(end <= len);\n+\n         unsafe {\n-            let begin = *self.ptr as *const T;\n-            let end = if mem::size_of::<T>() == 0 {\n-                (*self.ptr as usize + self.len()) as *const T\n-            } else {\n-                (*self.ptr).offset(self.len() as isize) as *const T\n-            };\n-            self.set_len(0);\n+            // set self.vec length's to start, to be safe in case Drain is leaked\n+            self.set_len(start);\n+            // Use the borrow in the IterMut to indicate borrowing behavior of the\n+            // whole Drain iterator (like &mut T).\n+            let range_slice = slice::from_raw_parts_mut(\n+                                        self.as_mut_ptr().offset(start as isize),\n+                                        end - start);\n             Drain {\n-                ptr: begin,\n-                end: end,\n-                marker: PhantomData,\n+                tail_start: end,\n+                tail_len: len - end,\n+                iter: range_slice.iter_mut(),\n+                vec: self as *mut _,\n             }\n         }\n     }\n@@ -1795,14 +1822,16 @@ impl<T> Drop for IntoIter<T> {\n     }\n }\n \n-/// An iterator that drains a vector.\n-#[unsafe_no_drop_flag]\n-#[unstable(feature = \"collections\",\n-           reason = \"recently added as part of collections reform 2\")]\n-pub struct Drain<'a, T:'a> {\n-    ptr: *const T,\n-    end: *const T,\n-    marker: PhantomData<&'a T>,\n+/// A draining iterator for `Vec<T>`.\n+#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+pub struct Drain<'a, T: 'a> {\n+    /// Index of tail to preserve\n+    tail_start: usize,\n+    /// Length of tail\n+    tail_len: usize,\n+    /// Current remaining range to remove\n+    iter: slice::IterMut<'a, T>,\n+    vec: *mut Vec<T>,\n }\n \n unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n@@ -1814,76 +1843,56 @@ impl<'a, T> Iterator for Drain<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            if self.ptr == self.end {\n-                None\n-            } else {\n-                if mem::size_of::<T>() == 0 {\n-                    // purposefully don't use 'ptr.offset' because for\n-                    // vectors with 0-size elements this would return the\n-                    // same pointer.\n-                    self.ptr = mem::transmute(self.ptr as usize + 1);\n-\n-                    // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n-                } else {\n-                    let old = self.ptr;\n-                    self.ptr = self.ptr.offset(1);\n-\n-                    Some(ptr::read(old))\n-                }\n+        self.iter.next().map(|elt|\n+            unsafe {\n+                ptr::read(elt as *const _)\n             }\n-        }\n+        )\n     }\n \n-    #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let diff = (self.end as usize) - (self.ptr as usize);\n-        let size = mem::size_of::<T>();\n-        let exact = diff / (if size == 0 {1} else {size});\n-        (exact, Some(exact))\n+        self.iter.size_hint()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        unsafe {\n-            if self.end == self.ptr {\n-                None\n-            } else {\n-                if mem::size_of::<T>() == 0 {\n-                    // See above for why 'ptr.offset' isn't used\n-                    self.end = mem::transmute(self.end as usize - 1);\n-\n-                    // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n-                } else {\n-                    self.end = self.end.offset(-1);\n-\n-                    Some(ptr::read(self.end))\n-                }\n+        self.iter.next_back().map(|elt|\n+            unsafe {\n+                ptr::read(elt as *const _)\n             }\n-        }\n+        )\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n-\n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n-        // self.ptr == self.end == mem::POST_DROP_USIZE if drop has already been called,\n-        // so we can use #[unsafe_no_drop_flag].\n+        // exhaust self first\n+        while let Some(_) = self.next() { }\n \n-        // destroy the remaining elements\n-        for _x in self.by_ref() {}\n+        if self.tail_len > 0 {\n+            unsafe {\n+                let source_vec = &mut *self.vec;\n+                // memmove back untouched tail, update to new length\n+                let start = source_vec.len();\n+                let tail = self.tail_start;\n+                let src = source_vec.as_ptr().offset(tail as isize);\n+                let dst = source_vec.as_mut_ptr().offset(start as isize);\n+                ptr::copy(src, dst, self.tail_len);\n+                source_vec.set_len(start + self.tail_len);\n+            }\n+        }\n     }\n }\n \n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Conversion from &[T] to &Vec<T>\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "6ff819fc87cdbd0c3d702a608f786b4e63c1e43c", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "patch": "@@ -418,7 +418,7 @@ impl<V> VecMap<V> {\n         }\n         let filter: fn((usize, Option<V>)) -> Option<(usize, V)> = filter; // coerce to fn ptr\n \n-        Drain { iter: self.v.drain().enumerate().filter_map(filter) }\n+        Drain { iter: self.v.drain(..).enumerate().filter_map(filter) }\n     }\n \n     /// Returns the number of elements in the map."}, {"sha": "935cfb762c2444d83cbaab94dbb224b8d613550a", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "patch": "@@ -10,6 +10,7 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n+#![feature(collections_drain)]\n #![feature(core)]\n #![feature(hash)]\n #![feature(rand)]"}, {"sha": "7d3b156a7cc4db3b69a43674bf813be860830cb3", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "patch": "@@ -460,7 +460,7 @@ fn test_move_items_zero_sized() {\n fn test_drain_items() {\n     let mut vec = vec![1, 2, 3];\n     let mut vec2 = vec![];\n-    for i in vec.drain() {\n+    for i in vec.drain(..) {\n         vec2.push(i);\n     }\n     assert_eq!(vec, []);\n@@ -471,7 +471,7 @@ fn test_drain_items() {\n fn test_drain_items_reverse() {\n     let mut vec = vec![1, 2, 3];\n     let mut vec2 = vec![];\n-    for i in vec.drain().rev() {\n+    for i in vec.drain(..).rev() {\n         vec2.push(i);\n     }\n     assert_eq!(vec, []);\n@@ -482,13 +482,43 @@ fn test_drain_items_reverse() {\n fn test_drain_items_zero_sized() {\n     let mut vec = vec![(), (), ()];\n     let mut vec2 = vec![];\n-    for i in vec.drain() {\n+    for i in vec.drain(..) {\n         vec2.push(i);\n     }\n     assert_eq!(vec, []);\n     assert_eq!(vec2, [(), (), ()]);\n }\n \n+#[test]\n+#[should_panic]\n+fn test_drain_out_of_bounds() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    v.drain(5..6);\n+}\n+\n+#[test]\n+fn test_drain_range() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    for _ in v.drain(4..) {\n+    }\n+    assert_eq!(v, &[1, 2, 3, 4]);\n+\n+    let mut v: Vec<_> = (1..6).map(|x| x.to_string()).collect();\n+    for _ in v.drain(1..4) {\n+    }\n+    assert_eq!(v, &[1.to_string(), 5.to_string()]);\n+\n+    let mut v: Vec<_> = (1..6).map(|x| x.to_string()).collect();\n+    for _ in v.drain(1..4).rev() {\n+    }\n+    assert_eq!(v, &[1.to_string(), 5.to_string()]);\n+\n+    let mut v: Vec<_> = vec![(); 5];\n+    for _ in v.drain(1..4).rev() {\n+    }\n+    assert_eq!(v, &[(), ()]);\n+}\n+\n #[test]\n fn test_into_boxed_slice() {\n     let xs = vec![1, 2, 3];"}, {"sha": "d7877bff0cb91ae095c720f26e4ebde039eadb4f", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8871c17b76a1e0ab36ce2bb51008b53f596e5b3c/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=8871c17b76a1e0ab36ce2bb51008b53f596e5b3c", "patch": "@@ -12,6 +12,7 @@\n \n #![allow(unused_mut)]\n #![feature(collections)]\n+#![feature(collections_drain)]\n \n extern crate collections;\n \n@@ -96,5 +97,6 @@ fn main() {\n \n     all_sync_send!(VecMap::<usize>::new(), iter, iter_mut, drain, into_iter, keys, values);\n \n-    all_sync_send!(Vec::<usize>::new(), into_iter, drain);\n+    all_sync_send!(Vec::<usize>::new(), into_iter);\n+    is_sync_send!(Vec::<usize>::new(), drain(..));\n }"}]}