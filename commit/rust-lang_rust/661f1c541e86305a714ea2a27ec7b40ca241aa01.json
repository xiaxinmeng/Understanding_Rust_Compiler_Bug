{"sha": "661f1c541e86305a714ea2a27ec7b40ca241aa01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MWYxYzU0MWU4NjMwNWE3MTRlYTJhMjdlYzdiNDBjYTI0MWFhMDE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-25T22:48:00Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-25T22:48:00Z"}, "message": "Trans nomenclature tidy-up: upcall vs. native vs. extern.", "tree": {"sha": "f6a87a5c08b43cdb27d03c0dab57940153ecc5fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6a87a5c08b43cdb27d03c0dab57940153ecc5fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/661f1c541e86305a714ea2a27ec7b40ca241aa01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/661f1c541e86305a714ea2a27ec7b40ca241aa01", "html_url": "https://github.com/rust-lang/rust/commit/661f1c541e86305a714ea2a27ec7b40ca241aa01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/661f1c541e86305a714ea2a27ec7b40ca241aa01/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2427509e2d53897b7c7797d5948773b63aed3df", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2427509e2d53897b7c7797d5948773b63aed3df", "html_url": "https://github.com/rust-lang/rust/commit/b2427509e2d53897b7c7797d5948773b63aed3df"}], "stats": {"total": 132, "additions": 76, "deletions": 56}, "files": [{"sha": "95958814bc390122d7b2ee7738988f0dc2c7fe82", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/661f1c541e86305a714ea2a27ec7b40ca241aa01/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661f1c541e86305a714ea2a27ec7b40ca241aa01/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=661f1c541e86305a714ea2a27ec7b40ca241aa01", "patch": "@@ -58,7 +58,7 @@ const int closure_elt_ty_params = 3;\n \n const int worst_case_glue_call_args = 7;\n \n-const int n_upcall_glues = 7;\n+const int n_native_glues = 7;\n \n const int abi_x86_rustboot_cdecl = 1;\n const int abi_x86_rustc_fastcall = 2;\n@@ -75,11 +75,11 @@ fn vec_append_glue_name() -> str {\n     ret \"rust_vec_append_glue\";\n }\n \n-fn upcall_glue_name(int n, bool pass_task) -> str {\n+fn native_glue_name(int n, bool pass_task) -> str {\n     if (pass_task) {\n-        ret \"rust_upcall_rust_\" + util.common.istr(n);\n+        ret \"rust_native_rust_\" + util.common.istr(n);\n     }\n-    ret \"rust_upcall_cdecl_\" + util.common.istr(n);\n+    ret \"rust_native_cdecl_\" + util.common.istr(n);\n }\n \n fn activate_glue_name() -> str {"}, {"sha": "e35af621e31bdef06658ebbd306d828c4d8d269f", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/661f1c541e86305a714ea2a27ec7b40ca241aa01/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661f1c541e86305a714ea2a27ec7b40ca241aa01/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=661f1c541e86305a714ea2a27ec7b40ca241aa01", "patch": "@@ -90,7 +90,7 @@ fn rust_activate_glue() -> vec[str] {\n          *      start doing whatever the first instruction says. Probably\n          *      saving registers and starting to establish a frame. Harmless\n          *      stuff, doesn't look at task->rust_sp again except when it\n-         *      clobbers it during a later upcall.\n+         *      clobbers it during a later native call.\n          *\n          *\n          *   2. We are resuming a task that was descheduled by the yield glue\n@@ -100,8 +100,9 @@ fn rust_activate_glue() -> vec[str] {\n          *              \"esp <- task->rust_sp\"\n          *\n          *      this is the first instruction we 'ret' to after this glue,\n-         *      because it is the first instruction following *any* upcall,\n-         *      and the task we are activating was descheduled mid-upcall.\n+         *      because it is the first instruction following *any* native\n+         *      call, and the task we are activating was descheduled\n+         *      mid-native-call.\n          *\n          *      Unfortunately for us, we have already restored esp from\n          *      task->rust_sp and are about to eat the 5 words off the top of\n@@ -132,7 +133,7 @@ fn rust_activate_glue() -> vec[str] {\n \n         /*\n          * In most cases, the function we're returning to (activating)\n-         * will have saved any caller-saves before it yielded via upcalling,\n+         * will have saved any caller-saves before it yielded via native call,\n          * so no work to do here. With one exception: when we're initially\n          * activating, the task needs to be in the fastcall 2nd parameter\n          * expected by the rust main function. That's edx.\n@@ -145,14 +146,14 @@ fn rust_activate_glue() -> vec[str] {\n \n /* More glue code, this time the 'bottom half' of yielding.\n  *\n- * We arrived here because an upcall decided to deschedule the\n- * running task. So the upcall's return address got patched to the\n+ * We arrived here because an native call decided to deschedule the\n+ * running task. So the native call's return address got patched to the\n  * first instruction of this glue code.\n  *\n- * When the upcall does 'ret' it will come here, and its esp will be\n+ * When the native call does 'ret' it will come here, and its esp will be\n  * pointing to the last argument pushed on the C stack before making\n- * the upcall: the 0th argument to the upcall, which is always the\n- * task ptr performing the upcall. That's where we take over.\n+ * the native call: the 0th argument to the native call, which is always\n+ * the task ptr performing the native call. That's where we take over.\n  *\n  * Our goal is to complete the descheduling\n  *\n@@ -179,7 +180,7 @@ fn rust_yield_glue() -> vec[str] {\n         + vec(\"ret\");\n }\n \n-fn upcall_glue(int n_args, bool pass_task) -> vec[str] {\n+fn native_glue(int n_args, bool pass_task) -> vec[str] {\n \n     /*\n      * 0, 4, 8, 12 are callee-saves\n@@ -242,11 +243,11 @@ fn decl_glue(int align, str prefix, str name, vec[str] insns) -> str {\n }\n \n \n-fn decl_upcall_glue(int align, str prefix, bool pass_task, uint n) -> str {\n+fn decl_native_glue(int align, str prefix, bool pass_task, uint n) -> str {\n     let int i = n as int;\n     ret decl_glue(align, prefix,\n-                  abi.upcall_glue_name(i, pass_task),\n-                  upcall_glue(i, pass_task));\n+                  abi.native_glue_name(i, pass_task),\n+                  native_glue(i, pass_task));\n }\n \n fn get_symbol_prefix() -> str {\n@@ -272,10 +273,10 @@ fn get_module_asm() -> str {\n                       abi.yield_glue_name(),\n                       rust_yield_glue()))\n \n-        + _vec.init_fn[str](bind decl_upcall_glue(align, prefix, true, _),\n-                            (abi.n_upcall_glues + 1) as uint)\n-        + _vec.init_fn[str](bind decl_upcall_glue(align, prefix, false, _),\n-                            (abi.n_upcall_glues + 1) as uint);\n+        + _vec.init_fn[str](bind decl_native_glue(align, prefix, true, _),\n+                            (abi.n_native_glues + 1) as uint)\n+        + _vec.init_fn[str](bind decl_native_glue(align, prefix, false, _),\n+                            (abi.n_native_glues + 1) as uint);\n \n \n     ret _str.connect(glues, \"\\n\\n\");"}, {"sha": "fa389c730731b9da54490cf9e7d60fba9e8e2482", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/661f1c541e86305a714ea2a27ec7b40ca241aa01/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661f1c541e86305a714ea2a27ec7b40ca241aa01/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=661f1c541e86305a714ea2a27ec7b40ca241aa01", "patch": "@@ -53,8 +53,8 @@ state obj namegen(mutable int i) {\n type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef yield_glue,\n                     ValueRef exit_task_glue,\n-                    vec[ValueRef] upcall_glues_rust,\n-                    vec[ValueRef] upcall_glues_cdecl,\n+                    vec[ValueRef] native_glues_rust,\n+                    vec[ValueRef] native_glues_cdecl,\n                     ValueRef no_op_type_glue,\n                     ValueRef memcpy_glue,\n                     ValueRef bzero_glue,\n@@ -64,12 +64,31 @@ type tydesc_info = rec(ValueRef tydesc,\n                        ValueRef take_glue,\n                        ValueRef drop_glue);\n \n+/*\n+ * A note on nomenclature of linking: \"upcall\", \"extern\" and \"native\".\n+ *\n+ * An \"extern\" is an LLVM symbol we wind up emitting an undefined external\n+ * reference to. This means \"we don't have the thing in this compilation unit,\n+ * please make sure you link it in at runtime\". This could be a reference to\n+ * C code found in a C library, or rust code found in a rust crate.\n+ *\n+ * A \"native\" is a combination of an extern that references C code, plus a\n+ * glue-code stub that \"looks like\" a rust function, emitted here, plus a\n+ * generic N-ary bit of asm glue (found over in back/x86.rs) that performs a\n+ * control transfer into C from rust. Natives may be normal C library code.\n+ *\n+ * An upcall is a native call generated by the compiler (not corresponding to\n+ * any user-written call in the code) into librustrt, to perform some helper\n+ * task such as bringing a task to life, allocating memory, etc.\n+ *\n+ */\n+\n state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n                             target_data td,\n                             type_names tn,\n                             ValueRef crate_ptr,\n-                            hashmap[str, ValueRef] upcalls,\n+                            hashmap[str, ValueRef] externs,\n                             hashmap[str, ValueRef] intrinsics,\n                             hashmap[str, ValueRef] item_names,\n                             hashmap[ast.def_id, ValueRef] item_ids,\n@@ -852,14 +871,14 @@ fn decl_glue(ModuleRef llmod, type_names tn, str s) -> ValueRef {\n     ret decl_cdecl_fn(llmod, s, T_fn(vec(T_taskptr(tn)), T_void()));\n }\n \n-fn decl_upcall_glue(ModuleRef llmod, type_names tn,\n+fn decl_native_glue(ModuleRef llmod, type_names tn,\n                     bool pass_task, uint _n) -> ValueRef {\n     // It doesn't actually matter what type we come up with here, at the\n-    // moment, as we cast the upcall function pointers to int before passing\n-    // them to the indirect upcall-invocation glue.  But eventually we'd like\n+    // moment, as we cast the native function pointers to int before passing\n+    // them to the indirect native-invocation glue.  But eventually we'd like\n     // to call them directly, once we have a calling convention worked out.\n     let int n = _n as int;\n-    let str s = abi.upcall_glue_name(n, pass_task);\n+    let str s = abi.native_glue_name(n, pass_task);\n     let vec[TypeRef] args = vec(T_int()); // callee\n     if (!pass_task) {\n         args += vec(T_int()); // taskptr, will not be passed\n@@ -869,42 +888,42 @@ fn decl_upcall_glue(ModuleRef llmod, type_names tn,\n     ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n }\n \n-fn get_upcall(&hashmap[str, ValueRef] upcalls,\n+fn get_extern(&hashmap[str, ValueRef] externs,\n               ModuleRef llmod, str name, int n_args) -> ValueRef {\n-    if (upcalls.contains_key(name)) {\n-        ret upcalls.get(name);\n+    if (externs.contains_key(name)) {\n+        ret externs.get(name);\n     }\n     auto inputs = _vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n     auto f = decl_cdecl_fn(llmod, name, T_fn(inputs, output));\n-    upcalls.insert(name, f);\n+    externs.insert(name, f);\n     ret f;\n }\n \n fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n     auto cxx = cx.fcx.ccx;\n     auto lltaskptr = cx.build.PtrToInt(cx.fcx.lltaskptr, T_int());\n     auto args2 = vec(lltaskptr) + args;\n-    auto t = trans_upcall2(cx.build, cxx.glues, lltaskptr,\n-                           cxx.upcalls, cxx.tn, cxx.llmod, name, true, args2);\n+    auto t = trans_native(cx.build, cxx.glues, lltaskptr,\n+                          cxx.externs, cxx.tn, cxx.llmod, name, true, args2);\n     ret res(cx, t);\n }\n \n-fn trans_upcall2(builder b, @glue_fns glues, ValueRef lltaskptr,\n-                 &hashmap[str, ValueRef] upcalls,\n-                 type_names tn, ModuleRef llmod, str name,\n-                 bool pass_task, vec[ValueRef] args) -> ValueRef {\n+fn trans_native(builder b, @glue_fns glues, ValueRef lltaskptr,\n+                &hashmap[str, ValueRef] externs,\n+                type_names tn, ModuleRef llmod, str name,\n+                bool pass_task, vec[ValueRef] args) -> ValueRef {\n     let int n = (_vec.len[ValueRef](args) as int);\n-    let ValueRef llupcall = get_upcall(upcalls, llmod, name, n);\n-    llupcall = llvm.LLVMConstPointerCast(llupcall, T_int());\n+    let ValueRef llnative = get_extern(externs, llmod, name, n);\n+    llnative = llvm.LLVMConstPointerCast(llnative, T_int());\n \n     let ValueRef llglue;\n     if (pass_task) {\n-        llglue = glues.upcall_glues_rust.(n);\n+        llglue = glues.native_glues_rust.(n);\n     } else {\n-        llglue = glues.upcall_glues_cdecl.(n);\n+        llglue = glues.native_glues_cdecl.(n);\n     }\n-    let vec[ValueRef] call_args = vec(llupcall);\n+    let vec[ValueRef] call_args = vec(llnative);\n \n     if (!pass_task) {\n         call_args += vec(lltaskptr);\n@@ -5771,8 +5790,8 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n         arg_n += 1u;\n     }\n \n-    auto r = trans_upcall2(bcx.build, cx.glues, lltaskptr, cx.upcalls, cx.tn,\n-                           cx.llmod, name, pass_task, call_args);\n+    auto r = trans_native(bcx.build, cx.glues, lltaskptr, cx.externs, cx.tn,\n+                          cx.llmod, name, pass_task, call_args);\n     auto rptr = bcx.build.BitCast(fcx.llretptr, T_ptr(T_i32()));\n     bcx.build.Store(r, rptr);\n     bcx.build.RetVoid();\n@@ -5967,7 +5986,7 @@ fn i2p(ValueRef v, TypeRef t) -> ValueRef {\n }\n \n fn trans_exit_task_glue(@glue_fns glues,\n-                        &hashmap[str, ValueRef] upcalls,\n+                        &hashmap[str, ValueRef] externs,\n                         type_names tn, ModuleRef llmod) {\n     let vec[TypeRef] T_args = vec();\n     let vec[ValueRef] V_args = vec();\n@@ -5979,8 +5998,8 @@ fn trans_exit_task_glue(@glue_fns glues,\n     auto build = new_builder(entrybb);\n     auto tptr = build.PtrToInt(lltaskptr, T_int());\n     auto V_args2 = vec(tptr) + V_args;\n-    trans_upcall2(build, glues, lltaskptr,\n-                  upcalls, tn, llmod, \"upcall_exit\", true, V_args2);\n+    trans_native(build, glues, lltaskptr,\n+                 externs, tn, llmod, \"upcall_exit\", true, V_args2);\n     build.RetVoid();\n }\n \n@@ -6415,7 +6434,7 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n              yield_glue = decl_glue(llmod, tn, abi.yield_glue_name()),\n              /*\n               * Note: the signature passed to decl_cdecl_fn here looks unusual\n-              * because it is. It corresponds neither to an upcall signature\n+              * because it is. It corresponds neither to a native signature\n               * nor a normal rust-ABI signature. In fact it is a fake\n               * signature, that exists solely to acquire the task pointer as\n               * an argument to the upcall. It so happens that the runtime sets\n@@ -6430,14 +6449,14 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n                                                      T_taskptr(tn)),\n                                                  T_void())),\n \n-             upcall_glues_rust =\n-             _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, tn, true,\n+             native_glues_rust =\n+             _vec.init_fn[ValueRef](bind decl_native_glue(llmod, tn, true,\n                                                           _),\n-                                    abi.n_upcall_glues + 1 as uint),\n-             upcall_glues_cdecl =\n-             _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, tn, false,\n+                                    abi.n_native_glues + 1 as uint),\n+             native_glues_cdecl =\n+             _vec.init_fn[ValueRef](bind decl_native_glue(llmod, tn, false,\n                                                           _),\n-                                    abi.n_upcall_glues + 1 as uint),\n+                                    abi.n_native_glues + 1 as uint),\n              no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n              memcpy_glue = decl_memcpy_glue(llmod),\n              bzero_glue = decl_bzero_glue(llmod),\n@@ -6503,7 +6522,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    td = td,\n                    tn = tn,\n                    crate_ptr = crate_ptr,\n-                   upcalls = new_str_hash[ValueRef](),\n+                   externs = new_str_hash[ValueRef](),\n                    intrinsics = intrinsics,\n                    item_names = new_str_hash[ValueRef](),\n                    item_ids = new_def_hash[ValueRef](),"}]}