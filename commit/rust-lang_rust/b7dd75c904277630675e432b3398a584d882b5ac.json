{"sha": "b7dd75c904277630675e432b3398a584d882b5ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZGQ3NWM5MDQyNzc2MzA2NzVlNDMyYjMzOThhNTg0ZDg4MmI1YWM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-18T22:33:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-19T21:56:28Z"}, "message": "Handle nested items correctly in typestate_check\n\nSummary says it all. Actually, only nested objects and functions\nare handled, but that's better than before. The fold that I was using\nbefore to traverse a crate wasn't working correctly, because annotations\nhave to reflect the number of local variables of the nearest enclosing\nfunction (in turn, because annotations are represented as bit vectors).\nThe fold was traversing the AST in the wrong order, first filling in\nthe annotations correctly, but then re-traversing them with the bit\nvector length for any outer nested functions, and so on.\n\nRemedying this required writing a lot of tedious boilerplate code\nbecause I scrapped the idea of using a fold altogether.\n\nI also made typestate_check handle unary, field, alt, and fail.\n\nAlso, some miscellaneous changes:\n* added annotations to blocks in typeck\n* fix pprust so it can handle spawn\n* added more logging functions in util.common\n* fixed _vec.or\n* added maybe and from_maybe in option\n* removed fold_block field from ast_fold, since it was never used", "tree": {"sha": "fcc27a73698613ad6378a42e9cd28a809761b6e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcc27a73698613ad6378a42e9cd28a809761b6e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7dd75c904277630675e432b3398a584d882b5ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7dd75c904277630675e432b3398a584d882b5ac", "html_url": "https://github.com/rust-lang/rust/commit/b7dd75c904277630675e432b3398a584d882b5ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7dd75c904277630675e432b3398a584d882b5ac/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d9cf15d0b5c89f3e71d1679b0698f3884e5a5d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9cf15d0b5c89f3e71d1679b0698f3884e5a5d2", "html_url": "https://github.com/rust-lang/rust/commit/3d9cf15d0b5c89f3e71d1679b0698f3884e5a5d2"}], "stats": {"total": 932, "additions": 833, "deletions": 99}, "files": [{"sha": "2561764073477df02334c521d31bb327b1cabe81", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=b7dd75c904277630675e432b3398a584d882b5ac", "patch": "@@ -291,8 +291,6 @@ type ast_fold[ENV] =\n      (fn(&ENV e, ann a) -> ann)                   fold_ann,\n \n      // Additional nodes.\n-     (fn(&ENV e, &span sp,\n-         &ast.block_) -> block)                   fold_block,\n \n      (fn(&ENV e, &fn_decl decl,\n          ast.proto proto,\n@@ -1716,7 +1714,6 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n \n          fold_ann = bind identity_fold_ann[ENV](_,_),\n \n-         fold_block = bind identity_fold_block[ENV](_,_,_),\n          fold_fn = bind identity_fold_fn[ENV](_,_,_,_),\n          fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_),\n          fold_mod = bind identity_fold_mod[ENV](_,_),"}, {"sha": "95ed4c2fd3a7d5b8bf9cfbf6e30b99c4e34641fa", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b7dd75c904277630675e432b3398a584d882b5ac", "patch": "@@ -1469,7 +1469,8 @@ mod Pushdown {\n             }\n             case (none[@ast.expr]) {\n                 Demand.simple(fcx, bloc.span, expected, plain_ty(ty.ty_nil));\n-                ret bloc;\n+                ret fold.respan[ast.block_](bloc.span,\n+                      rec(a = boring_ann() with bloc.node));\n             }\n         }\n     }"}, {"sha": "3e67cf2e109bf593069f61e9a3d6f5be6f14dca9", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 748, "deletions": 90, "changes": 838, "blob_url": "https://github.com/rust-lang/rust/blob/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=b7dd75c904277630675e432b3398a584d882b5ac", "patch": "@@ -1,12 +1,16 @@\n import front.ast;\n import front.ast.ann;\n+import front.ast.method;\n import front.ast.ty;\n import front.ast.mutability;\n import front.ast.item;\n import front.ast.block;\n import front.ast.block_;\n import front.ast.block_index_entry;\n+import front.ast.mod_index_entry;\n+import front.ast.obj_field;\n import front.ast.decl;\n+import front.ast.arm;\n import front.ast.stmt;\n import front.ast.stmt_;\n import front.ast.stmt_decl;\n@@ -17,6 +21,7 @@ import front.ast.decl_item;\n import front.ast.ident;\n import front.ast.def_id;\n import front.ast.ann;\n+import front.ast.field;\n import front.ast.expr;\n import front.ast.expr_call;\n import front.ast.expr_vec;\n@@ -29,11 +34,33 @@ import front.ast.expr_block;\n import front.ast.expr_rec;\n import front.ast.expr_if;\n import front.ast.expr_binary;\n+import front.ast.expr_unary;\n import front.ast.expr_assign;\n+import front.ast.expr_assign_op;\n import front.ast.expr_while;\n+import front.ast.expr_do_while;\n+import front.ast.expr_alt;\n import front.ast.expr_lit;\n import front.ast.expr_ret;\n+import front.ast.expr_self_method;\n+import front.ast.expr_bind;\n+import front.ast.expr_spawn;\n+import front.ast.expr_ext;\n+import front.ast.expr_fail;\n+import front.ast.expr_break;\n+import front.ast.expr_cont;\n+import front.ast.expr_send;\n+import front.ast.expr_recv;\n+import front.ast.expr_put;\n+import front.ast.expr_port;\n+import front.ast.expr_chan;\n+import front.ast.expr_be;\n+import front.ast.expr_check_expr;\n+import front.ast.expr_cast;\n+import front.ast.expr_for;\n+import front.ast.expr_for_each;\n import front.ast.path;\n+import front.ast.elt;\n import front.ast.crate_directive;\n import front.ast.fn_decl;\n import front.ast._obj;\n@@ -59,6 +86,7 @@ import front.ast.crate;\n import front.ast.mod_index_entry;\n import front.ast.mie_item;\n import front.ast.item_fn;\n+import front.ast.item_obj;\n import front.ast.def_local;\n \n import middle.fold;\n@@ -73,6 +101,8 @@ import util.common.uistr;\n import util.common.elt_exprs;\n import util.common.field_exprs;\n import util.common.log_expr;\n+import util.common.log_stmt;\n+import util.common.log_block;\n import util.typestate_ann;\n import util.typestate_ann.ts_ann;\n import util.typestate_ann.empty_pre_post;\n@@ -102,6 +132,7 @@ import util.typestate_ann.empty_ann;\n import util.typestate_ann.extend_prestate;\n import util.typestate_ann.extend_poststate;\n import util.typestate_ann.intersect;\n+import util.typestate_ann.pp_clone;\n \n import middle.ty;\n import middle.ty.ann_to_type;\n@@ -124,11 +155,13 @@ import std._vec.pop;\n import std._vec.push;\n import std._vec.slice;\n import std._vec.unzip;\n+import std._vec.plus_option;\n import std.option;\n import std.option.t;\n import std.option.some;\n import std.option.none;\n import std.option.from_maybe;\n+import std.option.maybe;\n import std.option.is_none;\n import std.option.get;\n import std.map.hashmap;\n@@ -151,24 +184,6 @@ import util.typestate_ann.require_and_preserve;\n \n /**** debugging junk  ****/\n \n-fn log_stmt(stmt st) -> () {\n-  let str_writer s = string_writer();\n-  auto out_ = mkstate(s.get_writer(), 80u);\n-  auto out = @rec(s=out_,\n-                  comments=option.none[vec[front.lexer.cmnt]],\n-                  mutable cur_cmnt=0u);\n-  alt (st.node) {\n-    case (ast.stmt_decl(?decl,_)) {\n-      print_decl(out, decl);\n-    }\n-    case (ast.stmt_expr(?ex,_)) {\n-      print_expr(out, ex);\n-    }\n-    case (_) { /* do nothing */ }\n-  }\n-  log(s.get_str());\n-}\n-\n fn log_bitv(fn_info enclosing, bitv.t v) {\n   auto s = \"\";\n \n@@ -222,12 +237,16 @@ fn print_idents(vec[ident] idents) -> () {\n type var_info     = tup(uint, ident);\n type fn_info      = std.map.hashmap[def_id, var_info];\n /* mapping from function name to fn_info map */\n-type _fn_info_map = std.map.hashmap[def_id, fn_info];\n+type fn_info_map = std.map.hashmap[def_id, fn_info];\n  \n fn bit_num(def_id v, fn_info m) -> uint {\n   check (m.contains_key(v));\n   ret m.get(v)._0;\n }\n+fn get_fn_info(fn_info_map fm, def_id did) -> fn_info {\n+    check (fm.contains_key(did));\n+    ret fm.get(did);\n+}\n \n fn var_is_local(def_id v, fn_info m) -> bool {\n   ret (m.contains_key(v));\n@@ -254,6 +273,7 @@ fn find_locals(_fn f) -> vec[tup(ident,def_id)] {\n }\n \n fn add_var(def_id v, ident nm, uint next, fn_info tbl) -> uint {\n+    log(nm + \" |-> \" + util.common.uistr(next));\n   tbl.insert(v, tup(next,nm));\n   ret (next + 1u);\n }\n@@ -277,23 +297,42 @@ fn mk_fn_info(_fn f) -> fn_info {\n   ret res;\n }\n \n-/* extends mk_fn_info to an item, side-effecting the map fi from\n+/* extends mk_fn_info to a function item, side-effecting the map fi from \n    function IDs to fn_info maps */\n-fn mk_fn_info_item_fn(&_fn_info_map fi, &span sp, ident i, &ast._fn f,\n+fn mk_fn_info_item_fn(&fn_info_map fi, &span sp, ident i, &ast._fn f,\n                  vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n   fi.insert(id, mk_fn_info(f));\n+  log(i + \" has \" + uistr(num_locals(mk_fn_info(f))) + \" local vars\");\n   ret @respan(sp, item_fn(i, f, ty_params, id, a));\n }\n \n+/* extends mk_fn_info to an obj item, side-effecting the map fi from \n+   function IDs to fn_info maps */\n+fn mk_fn_info_item_obj(&fn_info_map fi, &span sp, ident i, &ast._obj o,\n+     vec[ast.ty_param] ty_params, ast.obj_def_ids odid, ann a) -> @item {\n+    auto all_methods = _vec.clone[@method](o.methods);\n+    plus_option[@method](all_methods, o.dtor);\n+    for (@method m in all_methods) {\n+        /* FIXME: also need to pass in fields so we can say\n+           they're initialized? */\n+        fi.insert(m.node.id, mk_fn_info(m.node.meth));\n+        log(m.node.ident + \" has \" +\n+            uistr(num_locals(mk_fn_info(m.node.meth))) + \" local vars\");\n+    }\n+    ret @respan(sp, item_obj(i, o, ty_params, odid, a));\n+}\n+\n /* initializes the global fn_info_map (mapping each function ID, including\n    nested locally defined functions, onto a mapping from local variable name\n    to bit number) */\n-fn mk_f_to_fn_info(@ast.crate c) -> _fn_info_map {\n+fn mk_f_to_fn_info(@ast.crate c) -> fn_info_map {\n   auto res = new_def_hash[fn_info]();\n \n-  auto fld = fold.new_identity_fold[_fn_info_map]();\n-  fld = @rec(fold_item_fn = bind mk_fn_info_item_fn(_,_,_,_,_,_,_) with *fld);\n-  fold.fold_crate[_fn_info_map](res, fld, c);\n+  auto fld = fold.new_identity_fold[fn_info_map]();\n+  fld = @rec(fold_item_fn  = bind mk_fn_info_item_fn(_,_,_,_,_,_,_),\n+             fold_item_obj = bind mk_fn_info_item_obj(_,_,_,_,_,_,_)\n+               with *fld);\n+  fold.fold_crate[fn_info_map](res, fld, c);\n \n   ret res;\n }\n@@ -438,6 +477,10 @@ fn ann_to_ts_ann_fail_more(ann a) -> @ts_ann {\n   }\n }\n \n+fn ann_to_poststate(ann a) -> poststate {\n+    ret (ann_to_ts_ann_fail_more(a)).states.poststate;\n+}\n+\n fn stmt_to_ann(&stmt s) -> option.t[@ts_ann] {\n   alt (s.node) {\n     case (stmt_decl(_,?a)) {\n@@ -452,13 +495,6 @@ fn stmt_to_ann(&stmt s) -> option.t[@ts_ann] {\n   }\n }\n \n-/*\n-/* fails if no annotation */\n-fn stmt_pp(&stmt s) -> pre_and_post {\n-  ret (stmt_ann(s)).conditions;\n-}\n-*/\n-\n /* fails if e has no annotation */\n fn expr_states(&expr e) -> pre_and_post_state {\n   alt (expr_ann(e)) {\n@@ -501,6 +537,18 @@ fn expr_pp(&expr e) -> pre_and_post {\n   }\n }\n \n+fn stmt_pp(&stmt s) -> pre_and_post {\n+    alt (stmt_to_ann(s)) {\n+        case (none[@ts_ann]) {\n+            log \"stmt_pp: the impossible happened (no annotation)\";\n+            fail;\n+        }\n+        case (some[@ts_ann](?p)) {\n+            ret p.conditions;\n+        }\n+    }\n+}\n+\n /* fails if b has no annotation */\n /* FIXME: factor out code in the following two functions (block_ts_ann) */\n fn block_pp(&block b) -> pre_and_post {\n@@ -624,18 +672,19 @@ fn with_pp(ann a, pre_and_post p) -> ann {\n // precondition shouldn't include x.\n fn seq_preconds(uint num_vars, vec[pre_and_post] pps) -> precond {\n   let uint sz = len[pre_and_post](pps);\n-  check(sz >= 1u);\n-  auto first   = pps.(0);\n-\n-  if (sz > 1u) {\n+ \n+  if (sz >= 1u) {\n+    auto first   = pps.(0);\n     check (pps_len(first) == num_vars);\n     let precond rest = seq_preconds(num_vars,\n                          slice[pre_and_post](pps, 1u, sz));\n     difference(rest, first.postcondition);\n     union(first.precondition, rest);\n+    ret first.precondition;\n+  }\n+  else {\n+      ret true_precond(num_vars);\n   }\n-\n-  ret (first.precondition);\n }\n \n /* works on either postconds or preconds\n@@ -681,18 +730,48 @@ fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n /******* AST-traversing code ********/\n \n fn find_pre_post_mod(&_mod m) -> _mod {\n-  ret m; /* FIXME */\n+    log(\"implement find_pre_post_mod!\");\n+    fail;\n+}\n+\n+fn find_pre_post_state_mod(&_mod m) -> bool {\n+    log(\"implement find_pre_post_state_mod!\");\n+    fail;\n }\n \n fn find_pre_post_native_mod(&native_mod m) -> native_mod {\n-  ret m; /* FIXME */\n+    log(\"implement find_pre_post_native_mod\");\n+    fail;\n+}\n+\n+fn find_pre_post_state_native_mod(&native_mod m) -> bool {\n+    log(\"implement find_pre_post_state_native_mod!\");\n+    fail;\n }\n  \n-fn find_pre_post_obj(_obj o) -> _obj {\n-  ret o; /* FIXME */\n+fn find_pre_post_obj(&fn_info_map fm, _obj o) -> () {\n+    fn do_a_method(fn_info_map fm, &@method m) -> () {\n+        check(fm.contains_key(m.node.id));\n+        find_pre_post_fn(fm, fm.get(m.node.id), m.node.meth);\n+    }\n+    auto f = bind do_a_method(fm,_);\n+    _vec.map[@method, ()](f, o.methods);\n+    option.map[@method, ()](f, o.dtor);\n }\n \n-fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> () {\n+fn find_pre_post_state_obj(fn_info_map fm, _obj o) -> bool {\n+    fn do_a_method(fn_info_map fm, &@method m) -> bool {\n+        check(fm.contains_key(m.node.id));\n+        ret find_pre_post_state_fn(fm, fm.get(m.node.id), m.node.meth);\n+    }\n+    auto f = bind do_a_method(fm,_);\n+    auto flags = _vec.map[@method, bool](f, o.methods);\n+    auto changed = _vec.or(flags);\n+    changed = changed || maybe[@method, bool](false, f, o.dtor);\n+    ret changed;\n+}\n+\n+fn find_pre_post_item(fn_info_map fm, fn_info enclosing, &item i) -> () {\n   alt (i.node) {\n     case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n         find_pre_post_expr(fm, enclosing, *e);\n@@ -714,7 +793,7 @@ fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> () {\n       ret;\n     }\n     case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n-      find_pre_post_obj(o);\n+        find_pre_post_obj(fm, o);\n     }\n   }\n }\n@@ -723,9 +802,9 @@ fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> () {\n    sets the precondition in a to be the result of combining\n    the preconditions for <args>, and the postcondition in a to \n    be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(&_fn_info_map fm, &fn_info enclosing,\n+fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n                        &vec[@expr] args, ann a) {\n-    fn do_one(_fn_info_map fm, fn_info enclosing,\n+    fn do_one(fn_info_map fm, fn_info enclosing,\n               &@expr e) -> () {\n         find_pre_post_expr(fm, enclosing, *e);\n     }\n@@ -747,16 +826,21 @@ fn find_pre_post_exprs(&_fn_info_map fm, &fn_info enclosing,\n }\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(&_fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n+fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n     auto num_local_vars = num_locals(enclosing);\n \n-    fn do_rand_(_fn_info_map fm, fn_info enclosing, &@expr e) -> () {\n+    fn do_rand_(fn_info_map fm, fn_info enclosing, &@expr e) -> () {\n         find_pre_post_expr(fm, enclosing, *e);\n     }\n     fn pp_one(&@expr e) -> pre_and_post {\n         be expr_pp(*e);\n     }\n \n+    /*    log(\"find_pre_post_expr (num_locals =\" +\n+             uistr(num_local_vars) + \"):\");\n+          log_expr(e);\n+    */\n+\n     alt(e.node) {\n         case(expr_call(?operator, ?operands, ?a)) {\n             auto args = _vec.clone[@expr](operands);\n@@ -866,6 +950,10 @@ fn find_pre_post_expr(&_fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n              FIXME */\n             find_pre_post_exprs(fm, enclosing, vec(l, r), a);\n         }\n+        case (expr_unary(_,?operand,?a)) {\n+            find_pre_post_expr(fm, enclosing, *operand);\n+            set_pre_and_post(a, expr_pp(*operand));\n+        }\n         case (expr_while(?test, ?body, ?a)) {\n             find_pre_post_expr(fm, enclosing, *test);\n             find_pre_post_block(fm, enclosing, body);\n@@ -881,8 +969,41 @@ fn find_pre_post_expr(&_fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n         case (expr_index(?e, ?sub, ?a)) {\n             find_pre_post_exprs(fm, enclosing, vec(e, sub), a);\n         }\n+        case (expr_alt(?e, ?alts, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *e);\n+            fn do_an_alt(fn_info_map fm, fn_info enc, &arm an_alt)\n+                -> pre_and_post {\n+                find_pre_post_block(fm, enc, an_alt.block);\n+                ret block_pp(an_alt.block);\n+            }\n+            auto f = bind do_an_alt(fm, enclosing, _);\n+            auto alt_pps = _vec.map[arm, pre_and_post](f, alts);\n+            fn combine_pp(pre_and_post antec, \n+                          uint num_local_vars, &pre_and_post pp,\n+                          &pre_and_post next) -> pre_and_post {\n+                union(pp.precondition, seq_preconds(num_local_vars,\n+                                         vec(antec, next)));\n+                intersect(pp.postcondition, next.postcondition);\n+                ret pp;\n+            }\n+            auto e_pp1 = expr_pp(*e);\n+            auto e_pp  = pp_clone(e_pp1);\n+            auto g = bind combine_pp(e_pp, num_local_vars, _, _);\n+            set_pre_and_post(a, _vec.foldl[pre_and_post, pre_and_post]\n+                             (g, e_pp, alt_pps));\n+        }\n+        case (expr_field(?operator, _, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *operator);\n+            set_pre_and_post(a, expr_pp(*operator));\n+        }\n+        case (expr_fail(?a)) {\n+            set_pre_and_post(a,\n+               rec(precondition=empty_prestate(num_local_vars),\n+                   postcondition=true_postcond(num_local_vars)));\n+        }\n         case(_) {\n             log(\"this sort of expr isn't implemented!\");\n+            log_expr(e);\n             fail;\n         }\n     }\n@@ -902,7 +1023,7 @@ fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n   ret set_in_poststate(i, (ann_to_ts_ann_fail_more(a)).states);\n }\n \n-fn find_pre_post_stmt(_fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n+fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n     -> () {\n   auto num_local_vars = num_locals(enclosing);\n   alt(s.node) {\n@@ -941,27 +1062,49 @@ fn find_pre_post_stmt(_fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n   }\n }\n \n-fn find_pre_post_block(&_fn_info_map fm, &fn_info enclosing, block b)\n+fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     -> () {\n-    fn do_one_(_fn_info_map fm, fn_info i, &@stmt s) -> () {\n+    fn do_one_(fn_info_map fm, fn_info i, &@stmt s) -> () {\n         find_pre_post_stmt(fm, i, *s);\n     }\n     auto do_one = bind do_one_(fm, enclosing, _);\n     \n     _vec.map[@stmt, ()](do_one, b.node.stmts);\n-    fn do_inner_(_fn_info_map fm, fn_info i, &@expr e) -> () {\n+    fn do_inner_(fn_info_map fm, fn_info i, &@expr e) -> () {\n         find_pre_post_expr(fm, i, *e);\n     }\n     auto do_inner = bind do_inner_(fm, enclosing, _);\n     option.map[@expr, ()](do_inner, b.node.expr);\n-    /* FIXME needs to set up the ann for b!!!!!!!!!!! */\n+\n+    let vec[pre_and_post] pps = vec();\n+\n+    fn get_pp_stmt(&@stmt s) -> pre_and_post {\n+        ret stmt_pp(*s);\n+    }\n+    auto f = get_pp_stmt;\n+    pps += _vec.map[@stmt, pre_and_post](f, b.node.stmts);\n+    fn get_pp_expr(&@expr e) -> pre_and_post {\n+        ret expr_pp(*e);\n+    }\n+    auto g = get_pp_expr;\n+    plus_option[pre_and_post](pps,\n+       option.map[@expr, pre_and_post](g, b.node.expr));\n+    auto block_precond  = seq_preconds(num_locals(enclosing), pps);\n+    auto h = get_post;\n+    auto postconds =  _vec.map[pre_and_post, postcond](h, pps);\n+    /* A block may be empty, so this next line ensures that the postconds\n+       vector is non-empty. */\n+    _vec.push[postcond](postconds, block_precond);\n+    auto block_postcond = union_postconds(postconds);\n+    set_pre_and_post(b.node.a, rec(precondition=block_precond,\n+                                   postcondition=block_postcond));\n }\n \n-fn find_pre_post_fn(&_fn_info_map fm, &fn_info fi, &_fn f) -> () {\n+fn find_pre_post_fn(&fn_info_map fm, &fn_info fi, &_fn f) -> () {\n     find_pre_post_block(fm, fi, f.body);\n }\n \n-fn check_item_fn(&_fn_info_map fm, &span sp, ident i, &ast._fn f,\n+fn check_item_fn(&fn_info_map fm, &span sp, ident i, &ast._fn f,\n                  vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n \n   check (fm.contains_key(id));\n@@ -970,10 +1113,33 @@ fn check_item_fn(&_fn_info_map fm, &span sp, ident i, &ast._fn f,\n   ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n \n-/* FIXME */\n-fn find_pre_post_state_item(_fn_info_map fm, @item i) -> bool {\n-  log(\"Implement find_pre_post_item!\");\n-  fail;\n+fn find_pre_post_state_item(fn_info_map fm, fn_info enclosing, @item i)\n+   -> bool {\n+ alt (i.node) {\n+    case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n+        ret find_pre_post_state_expr(fm, enclosing,\n+              empty_prestate(num_locals(enclosing)), e);\n+    }\n+    case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n+      check (fm.contains_key(di));\n+      ret find_pre_post_state_fn(fm, fm.get(di), f);\n+    }\n+    case (ast.item_mod(?id, ?m, ?di)) {\n+      ret find_pre_post_state_mod(m);\n+    }\n+    case (ast.item_native_mod(?id, ?nm, ?di)) {\n+      ret find_pre_post_state_native_mod(nm);\n+    }\n+    case (ast.item_ty(_,_,_,_,_)) {\n+      ret false;\n+    }\n+    case (ast.item_tag(_,_,_,_,_)) {\n+      ret false;\n+    }\n+    case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n+        ret find_pre_post_state_obj(fm, o);\n+    }\n+  }\n }\n \n fn set_prestate_ann(ann a, prestate pre) -> bool {\n@@ -1034,6 +1200,11 @@ fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n         case (ann_type(_,_,?ts_a)) {\n             check (! is_none[@ts_ann](ts_a));\n             auto t = *get[@ts_ann](ts_a);\n+            /*  log(\"set_pre_and_post, old =\");\n+            log_pp(t.conditions);\n+            log(\"new =\");\n+            log_pp(pp);\n+            */\n             set_precondition(t, pp.precondition);\n             set_postcondition(t, pp.postcondition);\n         }\n@@ -1044,7 +1215,7 @@ fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n     }\n }\n \n-fn seq_states(&_fn_info_map fm, &fn_info enclosing,\n+fn seq_states(&fn_info_map fm, &fn_info enclosing,\n     prestate pres, vec[@expr] exprs) -> tup(bool, poststate) {\n   auto changed = false;\n   auto post = pres;\n@@ -1057,7 +1228,7 @@ fn seq_states(&_fn_info_map fm, &fn_info enclosing,\n   ret tup(changed, post);\n }\n \n-fn find_pre_post_state_exprs(&_fn_info_map fm,\n+fn find_pre_post_state_exprs(&fn_info_map fm,\n                              &fn_info enclosing,\n                              &prestate pres,\n                              &ann a, &vec[@expr] es) -> bool {\n@@ -1075,7 +1246,7 @@ fn pure_exp(&ann a, &prestate p) -> bool {\n   ret changed;\n }\n \n-fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n+fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, &@expr e) -> bool {\n   auto changed = false;\n   auto num_local_vars = num_locals(enclosing);\n@@ -1224,6 +1395,39 @@ fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n         changed = extend_poststate_ann(a, expr_poststate(*sub));\n         ret changed;\n     }\n+    case (expr_alt(?e, ?alts, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed; \n+        changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n+        auto e_post = expr_poststate(*e);\n+        auto a_post = ann_to_poststate(a);\n+        for (arm an_alt in alts) {\n+            changed = find_pre_post_state_block(fm, enclosing, e_post,\n+                        an_alt.block) || changed;\n+            changed = intersect(a_post, block_poststate(an_alt.block))\n+               || changed;\n+        }\n+        ret changed;\n+    }\n+    case (expr_field(?e,_,?a)) {\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n+        ret changed;\n+    }\n+    case (expr_unary(_,?operand,?a)) {\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, operand)\n+          || changed;\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*operand))\n+          || changed;\n+        ret changed;\n+    }\n+    case (expr_fail(?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = set_poststate_ann(a, true_postcond(num_local_vars))\n+          || changed;\n+        ret changed;\n+    }\n     case (_) {\n       log(\"find_pre_post_state_expr: implement this case!\");\n       fail;\n@@ -1232,7 +1436,7 @@ fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n \n }\n \n-fn find_pre_post_state_stmt(&_fn_info_map fm, &fn_info enclosing,\n+fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, @stmt s) -> bool {\n   auto changed = false;\n   auto stmt_ann_ = stmt_to_ann(*s);\n@@ -1285,7 +1489,7 @@ fn find_pre_post_state_stmt(&_fn_info_map fm, &fn_info enclosing,\n           }\n         }\n         case (ast.decl_item(?an_item)) {\n-          be find_pre_post_state_item(fm, an_item);\n+            be find_pre_post_state_item(fm, enclosing, an_item);\n         }\n       }\n     }\n@@ -1314,7 +1518,7 @@ fn find_pre_post_state_stmt(&_fn_info_map fm, &fn_info enclosing,\n \n /* Updates the pre- and post-states of statements in the block,\n    returns a boolean flag saying whether any pre- or poststates changed */\n-fn find_pre_post_state_block(&_fn_info_map fm, &fn_info enclosing,\n+fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n                              &prestate pres0, block b)\n   -> bool {\n \n@@ -1332,24 +1536,31 @@ fn find_pre_post_state_block(&_fn_info_map fm, &fn_info enclosing,\n     pres = stmt_poststate(*s, num_local_vars);\n   }\n \n+  auto post = pres;\n+\n   alt (b.node.expr) {\n     case (none[@expr]) {}\n     case (some[@expr](?e)) {\n       changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n+      post = expr_poststate(*e);\n     }\n   }\n+  set_prestate_ann(b.node.a, pres0);\n+  set_poststate_ann(b.node.a, post);\n   ret changed;\n }\n \n-fn find_pre_post_state_fn(&_fn_info_map f_info, &fn_info fi, &ast._fn f)\n+fn find_pre_post_state_fn(&fn_info_map f_info, &fn_info fi, &ast._fn f)\n   -> bool {\n+    /* FIXME: where do we set args as being initialized?\n+       What about for methods? */\n     auto num_local_vars = num_locals(fi);\n     ret find_pre_post_state_block(f_info, fi,\n                                   empty_prestate(num_local_vars), f.body);\n }\n \n-fn fixed_point_states(_fn_info_map fm, fn_info f_info,\n-                      fn (&_fn_info_map, &fn_info, &ast._fn) -> bool f,\n+fn fixed_point_states(fn_info_map fm, fn_info f_info,\n+                      fn (&fn_info_map, &fn_info, &ast._fn) -> bool f,\n                       &ast._fn start) -> () {\n \n   auto changed = f(fm, f_info, start);\n@@ -1368,7 +1579,7 @@ fn check_states_expr(fn_info enclosing, &expr e) -> () {\n   let prestate pres   = expr_prestate(e);\n \n   if (!implies(pres, prec)) {\n-      log(\"check_states_stmt: unsatisfied precondition for \");\n+      log(\"check_states_expr: unsatisfied precondition for \");\n       log_expr(e);\n       log(\"Precondition: \");\n       log_bitv(enclosing, prec);\n@@ -1424,26 +1635,48 @@ fn check_states_against_conditions(fn_info enclosing, &ast._fn f) -> () {\n   \n }\n \n-fn check_item_fn_state(&_fn_info_map f_info_map, &span sp, ident i,\n-                       &ast._fn f, vec[ast.ty_param] ty_params, def_id id,\n-                       ann a) -> @item {\n-\n-  /* Look up the var-to-bit-num map for this function */\n-  check(f_info_map.contains_key(id));\n-  auto f_info = f_info_map.get(id);\n-\n+fn check_fn_states(&fn_info_map f_info_map, &fn_info f_info, &ast._fn f)\n+    -> () {\n   /* Compute the pre- and post-states for this function */\n   auto g = find_pre_post_state_fn;\n   fixed_point_states(f_info_map, f_info, g, f);\n \n   /* Now compare each expr's pre-state to its precondition\n      and post-state to its postcondition */\n   check_states_against_conditions(f_info, f);\n+}\n+\n+fn check_item_fn_state(&fn_info_map f_info_map, &span sp, ident i,\n+                       &ast._fn f, vec[ast.ty_param] ty_params, def_id id,\n+                       ann a) -> @item {\n+\n+  /* Look up the var-to-bit-num map for this function */\n+  check(f_info_map.contains_key(id));\n+  auto f_info = f_info_map.get(id);\n+\n+  check_fn_states(f_info_map, f_info, f);\n \n   /* Rebuild the same function */\n   ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n \n+fn check_method_states(&fn_info_map f_info_map, @method m) -> () {\n+    check (f_info_map.contains_key(m.node.id));\n+    auto f_info = f_info_map.get(m.node.id);\n+    check_fn_states(f_info_map, f_info, m.node.meth);\n+}\n+\n+fn check_obj_state(&fn_info_map f_info_map, vec[obj_field] fields,\n+                  vec[@method] methods, option.t[@method] dtor) -> ast._obj {\n+    fn one(fn_info_map fm, &@method m) -> () {\n+        ret check_method_states(fm, m);\n+    }\n+    auto f = bind one(f_info_map,_);\n+    _vec.map[@method, ()](f, methods);\n+    option.map[@method, ()](f, dtor);\n+    ret rec(fields=fields, methods=methods, dtor=dtor);\n+}\n+\n fn init_ann(&fn_info fi, ann a) -> ann {\n     alt (a) {\n         case (ann_none) {\n@@ -1456,42 +1689,467 @@ fn init_ann(&fn_info fi, ann a) -> ann {\n     }\n }\n \n-fn item_fn_anns(&_fn_info_map fm, &span sp, ident i, &ast._fn f,\n+fn init_blank_ann(&() ignore, ann a) -> ann {\n+    alt (a) {\n+        case (ann_none) {\n+            log(\"init_ann: shouldn't see ann_none\");\n+            fail;\n+        }\n+        case (ann_type(?t,?ps,_)) {\n+            ret ann_type(t, ps, some[@ts_ann](@empty_ann(0u)));\n+        }\n+    }\n+}\n+\n+fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n+    log(\"init_block:\");\n+    log_block(respan(sp, b));\n+    alt(b.a) {\n+        case (ann_none) {\n+            log(\"init_ann: shouldn't see ann_none\");\n+            fail;\n+        }\n+        case (ann_type(?t,?ps,_)) {\n+            auto fld0 = fold.new_identity_fold[fn_info]();\n+\n+            fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n+            ret fold.fold_block[fn_info](fi, fld0, respan(sp, b)); \n+        }\n+    }\n+    \n+}\n+\n+fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &ast._fn f,\n                 vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n \n     check(fm.contains_key(id));\n     auto f_info = fm.get(id);\n \n+    log(i + \" has \" + uistr(num_locals(f_info)) + \" local vars\");\n+\n     auto fld0 = fold.new_identity_fold[fn_info]();\n \n-    fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n+    fld0 = @rec(fold_ann = bind init_ann(_,_) \n+                //   fold_block = bind init_block(_,_,_)\n+                    with *fld0);\n \n     ret fold.fold_item[fn_info]\n            (f_info, fld0, @respan(sp, item_fn(i, f, ty_params, id, a))); \n }\n \n-fn check_crate(@ast.crate crate) -> @ast.crate {\n+/* This is painstakingly written as an explicit recursion b/c the\n+   standard ast.fold doesn't traverse in the correct order:\n+   consider\n+   fn foo() {\n+      fn bar() {\n+        auto x = 5;\n+        log(x);\n+      }\n+   }\n+   With fold, first bar() would be processed and its subexps would\n+   correctly be annotated with length-1 bit vectors.\n+   But then, the process would be repeated with (fn bar()...) as\n+   a subexp of foo, which has 0 local variables -- so then\n+   the body of bar() would be incorrectly annotated with length-0 bit\n+   vectors. */\n+fn annotate_exprs(&fn_info_map fm, &vec[@expr] es) -> vec[@expr] {\n+    fn one(fn_info_map fm, &@expr e) -> @expr {\n+        ret annotate_expr(fm, e);\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec.map[@expr, @expr](f, es);\n+}\n+fn annotate_elts(&fn_info_map fm, &vec[elt] es) -> vec[elt] {\n+    fn one(fn_info_map fm, &elt e) -> elt {\n+        ret rec(mut=e.mut,\n+                expr=annotate_expr(fm, e.expr));\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec.map[elt, elt](f, es);\n+}\n+fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n+    fn one(fn_info_map fm, &field f) -> field {\n+        ret rec(mut=f.mut,\n+                 ident=f.ident,\n+                 expr=annotate_expr(fm, f.expr));\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec.map[field, field](f, fs);\n+}\n+fn annotate_option_exp(&fn_info_map fm, &option.t[@expr] o)\n+  -> option.t[@expr] {\n+    fn one(fn_info_map fm, &@expr e) -> @expr {\n+        ret annotate_expr(fm, e);\n+    }\n+    auto f = bind one(fm,_);\n+    ret option.map[@expr, @expr](f, o);\n+}\n+fn annotate_option_exprs(&fn_info_map fm, &vec[option.t[@expr]] es)\n+  -> vec[option.t[@expr]] {\n+    fn one(fn_info_map fm, &option.t[@expr] o) -> option.t[@expr] {\n+        ret annotate_option_exp(fm, o);\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec.map[option.t[@expr], option.t[@expr]](f, es);\n+}\n+fn annotate_decl(&fn_info_map fm, &@decl d) -> @decl {\n+    auto d1 = d.node;\n+    alt (d.node) {\n+        case (decl_local(?l)) {\n+            alt(l.init) {\n+                case (some[initializer](?init)) {\n+                    let option.t[initializer] an_i =\n+                        some[initializer]\n+                          (rec(expr=annotate_expr(fm, init.expr)\n+                                 with init));\n+                    let @local new_l = @rec(init=an_i with *l);\n+                    d1 = decl_local(new_l);\n+                }\n+                case (_) { /* do nothing */ }\n+            }\n+        }\n+        case (decl_item(?item)) {\n+            d1 = decl_item(annotate_item(fm, item));\n+        }\n+    }\n+    ret @respan(d.span, d1);\n+}\n+fn annotate_alts(&fn_info_map fm, &vec[arm] alts) -> vec[arm] {\n+    fn one(fn_info_map fm, &arm a) -> arm {\n+        ret rec(pat=a.pat,\n+                 block=annotate_block(fm, a.block),\n+                 index=a.index);\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec.map[arm, arm](f, alts);\n \n+}\n+fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n+    auto e1 = e.node;\n+    alt (e.node) {\n+        case (expr_vec(?es, ?m, ?a)) {\n+            e1 = expr_vec(annotate_exprs(fm, es), m, a);\n+        }\n+        case (expr_tup(?es, ?a)) {\n+            e1 = expr_tup(annotate_elts(fm, es), a);\n+        }\n+        case (expr_rec(?fs, ?maybe_e, ?a)) {\n+            e1 = expr_rec(annotate_fields(fm, fs),\n+                          annotate_option_exp(fm, maybe_e), a);\n+        }\n+        case (expr_call(?e, ?es, ?a)) {\n+            e1 = expr_call(annotate_expr(fm, e),\n+                          annotate_exprs(fm, es), a);\n+        }\n+        case (expr_self_method(_,_)) {\n+            // no change\n+        }\n+        case (expr_bind(?e, ?maybe_es, ?a)) {\n+            e1 = expr_bind(annotate_expr(fm, e),\n+                           annotate_option_exprs(fm, maybe_es),\n+                           a);\n+        }\n+        case (expr_spawn(?s, ?maybe_s, ?e, ?es, ?a)) {\n+            e1 = expr_spawn(s, maybe_s, annotate_expr(fm, e),\n+                            annotate_exprs(fm, es), a);\n+        }\n+        case (expr_binary(?bop, ?w, ?x, ?a)) {\n+            e1 = expr_binary(bop, annotate_expr(fm, w),\n+                             annotate_expr(fm, x), a);\n+        }\n+        case (expr_unary(?uop, ?w, ?a)) {\n+            e1 = expr_unary(uop, annotate_expr(fm, w), a);\n+        }\n+        case (expr_lit(_,_)) {\n+            /* no change */\n+        }\n+        case (expr_cast(?e,?t,?a)) {\n+            e1 = expr_cast(annotate_expr(fm, e), t, a);\n+        }\n+        case (expr_if(?e, ?b, ?maybe_e, ?a)) {\n+            e1 = expr_if(annotate_expr(fm, e),\n+                         annotate_block(fm, b),\n+                         annotate_option_exp(fm, maybe_e), a);\n+        }\n+        case (expr_while(?e, ?b, ?a)) {\n+            e1 = expr_while(annotate_expr(fm, e),\n+                            annotate_block(fm, b), a);\n+        }\n+        case (expr_for(?d, ?e, ?b, ?a)) {\n+            e1 = expr_for(annotate_decl(fm, d),\n+                          annotate_expr(fm, e),\n+                          annotate_block(fm, b), a);\n+        }\n+        case (expr_for_each(?d, ?e, ?b, ?a)) {\n+            e1 = expr_for_each(annotate_decl(fm, d),\n+                          annotate_expr(fm, e),\n+                          annotate_block(fm, b), a);\n+        }\n+        case (expr_do_while(?b, ?e, ?a)) {\n+            e1 = expr_do_while(annotate_block(fm, b),\n+                               annotate_expr(fm, e), a);\n+        }\n+        case (expr_alt(?e, ?alts, ?a)) {\n+            e1 = expr_alt(annotate_expr(fm, e),\n+                          annotate_alts(fm, alts), a);\n+        }\n+        case (expr_block(?b, ?a)) {\n+            e1 = expr_block(annotate_block(fm, b), a);\n+        }\n+        case (expr_assign(?l, ?r, ?a)) {\n+            e1 = expr_assign(annotate_expr(fm, l), annotate_expr(fm, r), a);\n+        }\n+        case (expr_assign_op(?bop, ?l, ?r, ?a)) {\n+            e1 = expr_assign_op(bop,\n+               annotate_expr(fm, l), annotate_expr(fm, r), a);\n+        }\n+        case (expr_send(?l, ?r, ?a)) {\n+            e1 = expr_send(annotate_expr(fm, l),\n+                           annotate_expr(fm, r), a);\n+        }\n+        case (expr_recv(?l, ?r, ?a)) {\n+           e1 = expr_recv(annotate_expr(fm, l),\n+                           annotate_expr(fm, r), a);\n+        }\n+        case (expr_field(?e, ?i, ?a)) {\n+            e1 = expr_field(annotate_expr(fm, e),\n+                            i, a);\n+        }\n+        case (expr_index(?e, ?sub, ?a)) {\n+            e1 = expr_index(annotate_expr(fm, e),\n+                            annotate_expr(fm, sub), a);\n+        }\n+        case (expr_path(_,_,_)) {\n+            /* no change */\n+        }\n+        case (expr_ext(?p, ?es, ?e_opt, ?e, ?a)) {\n+            e1 = expr_ext(p, annotate_exprs(fm, es),\n+                          annotate_option_exp(fm, e_opt),\n+                          annotate_expr(fm, e), a);\n+        }\n+        /* no change, next 3 cases */\n+        case (expr_fail(_)) { }\n+        case (expr_break(_)) { }\n+        case (expr_cont(_)) { }\n+        case (expr_ret(?maybe_e, ?a)) {\n+            e1 = expr_ret(annotate_option_exp(fm, maybe_e), a);\n+        }\n+        case (expr_put(?maybe_e, ?a)) {\n+            e1 = expr_put(annotate_option_exp(fm, maybe_e), a);\n+        }\n+        case (expr_be(?e, ?a)) {\n+            e1 = expr_be(annotate_expr(fm, e), a);\n+        }\n+        case (expr_log(?n, ?e, ?a)) {\n+            e1 = expr_log(n, annotate_expr(fm, e), a);\n+        }\n+        case (expr_check_expr(?e, ?a)) {\n+            e1 = expr_check_expr(annotate_expr(fm, e), a);\n+        }\n+        case (expr_port(_)) { /* no change */ }\n+        case (expr_chan(?e, ?a)) {\n+            e1 = expr_chan(annotate_expr(fm, e), a);\n+        }\n+    }\n+    ret @respan(e.span, e1);\n+}\n+\n+fn annotate_stmt(&fn_info_map fm, &@stmt s) -> @stmt {\n+    alt (s.node) {\n+        case (stmt_decl(?d, ?a)) {\n+            ret @respan(s.span, stmt_decl(annotate_decl(fm, d), a));\n+        }\n+        case (stmt_expr(?e, ?a)) {\n+            ret @respan(s.span, stmt_expr(annotate_expr(fm, e), a));\n+        }\n+    }\n+}\n+fn annotate_block(&fn_info_map fm, &block b) -> block {\n+    let vec[@stmt] new_stmts = vec();\n+    auto new_index = new_str_hash[block_index_entry]();\n+\n+    for (@stmt s in b.node.stmts) {\n+        auto new_s = annotate_stmt(fm, s);\n+        _vec.push[@stmt](new_stmts, new_s);\n+        ast.index_stmt(new_index, new_s);\n+    }\n+    fn ann_e(fn_info_map fm, &@expr e) -> @expr {\n+        ret annotate_expr(fm, e);\n+    }\n+    auto f = bind ann_e(fm,_);\n+\n+    auto new_e = option.map[@expr, @expr](f, b.node.expr);\n+\n+    ret respan(b.span,\n+          rec(stmts=new_stmts, expr=new_e, index=new_index with b.node));\n+}\n+fn annotate_fn(&fn_info_map fm, &ast._fn f) -> ast._fn {\n+    // subexps have *already* been annotated based on\n+    // f's number-of-locals\n+    ret rec(body=annotate_block(fm, f.body) with f);\n+}\n+fn annotate_mod(&fn_info_map fm, &ast._mod m) -> ast._mod {\n+    let vec[@item] new_items = vec();\n+    auto new_index = new_str_hash[mod_index_entry]();\n+\n+    for (@item i in m.items) {\n+        auto new_i = annotate_item(fm, i);\n+        _vec.push[@item](new_items, new_i);\n+        ast.index_item(new_index, new_i);\n+    }\n+    ret rec(items=new_items, index=new_index with m);\n+}\n+fn annotate_native_mod(&fn_info_map fm, &ast.native_mod m)\n+       -> ast.native_mod {\n+    log(\"implement annotate_native_mod!\");\n+    fail;\n+}\n+fn annotate_method(&fn_info_map fm, &@method m) -> @method {\n+    auto f_info = get_fn_info(fm, m.node.id);\n+    auto fld0 = fold.new_identity_fold[fn_info]();\n+    fld0 = @rec(fold_ann = bind init_ann(_,_) \n+                with *fld0);\n+    auto outer = fold.fold_method[fn_info](f_info, fld0, m);\n+    auto new_fn = annotate_fn(fm, outer.node.meth);\n+    ret @respan(m.span,\n+                rec(meth=new_fn with m.node));\n+}\n+\n+fn annotate_obj(&fn_info_map fm, &ast._obj o) -> ast._obj {\n+    fn one(fn_info_map fm, &@method m) -> @method {\n+        ret annotate_method(fm, m);\n+    }\n+    auto f = bind one(fm,_);\n+    auto new_methods = _vec.map[@method, @method](f, o.methods);\n+    auto new_dtor    = option.map[@method, @method](f, o.dtor);\n+    ret rec(methods=new_methods, dtor=new_dtor with o);\n+}\n+\n+ \n+// Only annotates the components of the item recursively.\n+fn annotate_item_inner(&fn_info_map fm, &@ast.item item) -> @ast.item {\n+    alt (item.node) {\n+        /* FIXME can't skip this case -- exprs contain blocks contain stmts,\n+         which contain decls */\n+        case (ast.item_const(_,_,_,_,_)) {\n+            // this has already been annotated by annotate_item\n+            ret item;\n+        }\n+        case (ast.item_fn(?ident, ?ff, ?tps, ?id, ?ann)) {\n+            ret @respan(item.span,\n+                       ast.item_fn(ident, annotate_fn(fm, ff), tps, id, ann));\n+        }\n+        case (ast.item_mod(?ident, ?mm, ?id)) {\n+            ret @respan(item.span,\n+                       ast.item_mod(ident, annotate_mod(fm, mm), id));\n+        }\n+        case (ast.item_native_mod(?ident, ?mm, ?id)) {\n+            ret @respan(item.span,\n+                  ast.item_native_mod(ident, \n+                    annotate_native_mod(fm, mm), id));\n+        }\n+        case (ast.item_ty(_,_,_,_,_)) {\n+            ret item;\n+        }\n+        case (ast.item_tag(_,_,_,_,_)) {\n+            ret item;\n+        }\n+        case (ast.item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n+            ret @respan(item.span,\n+              ast.item_obj(ident, annotate_obj(fm, ob), tps, odid, ann));\n+        }\n+    } \n+}\n+\n+fn annotate_item(&fn_info_map fm, &@ast.item item) -> @ast.item {\n+    // Using a fold, recursively set all anns in this item\n+    // to be blank.\n+    // *Then*, call annotate_item recursively to do the right\n+    // thing for any nested items inside this one.\n+    \n+    alt (item.node) {\n+        case (ast.item_const(_,_,_,_,_)) {\n+            auto fld0 = fold.new_identity_fold[()]();\n+            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n+                        with *fld0);\n+            ret fold.fold_item[()]((), fld0, item);\n+        }\n+        case (ast.item_fn(?i,?ff,?tps,?id,?ann)) {\n+            auto f_info = get_fn_info(fm, id);\n+            auto fld0 = fold.new_identity_fold[fn_info]();\n+            fld0 = @rec(fold_ann = bind init_ann(_,_) \n+                        with *fld0);\n+            auto outer = fold.fold_item[fn_info](f_info, fld0, item);\n+            // now recurse into any nested items\n+            ret annotate_item_inner(fm, outer);\n+         }\n+        case (ast.item_mod(?i, ?mm, ?id)) {\n+            auto fld0 = fold.new_identity_fold[()]();\n+            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n+                        with *fld0);\n+            auto outer = fold.fold_item[()]((), fld0, item);\n+            ret annotate_item_inner(fm, outer);\n+        }\n+        case (ast.item_ty(_,_,_,_,_)) {\n+            ret item;\n+        }\n+        case (ast.item_tag(_,_,_,_,_)) {\n+            ret item;\n+        }\n+        case (ast.item_obj(?i,?ob,?tps,?odid,?ann)) {\n+            auto fld0 = fold.new_identity_fold[()]();\n+            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n+                        with *fld0);\n+            auto outer = fold.fold_item[()]((), fld0, item);\n+            ret annotate_item_inner(fm, outer);\n+        }\n+    }\n+}\n+\n+fn annotate_module(&fn_info_map fm, &ast._mod module) -> ast._mod {\n+    let vec[@item] new_items = vec();\n+    auto new_index = new_str_hash[ast.mod_index_entry]();\n+\n+    for (@item i in module.items) {\n+        auto new_item = annotate_item(fm, i);\n+        _vec.push[@item](new_items, new_item);\n+        ast.index_item(new_index, new_item);\n+    }\n+\n+    ret rec(items = new_items, index = new_index with module);\n+}\n+\n+fn annotate_crate(&fn_info_map fm, &@ast.crate crate) -> @ast.crate {\n+    ret @respan(crate.span,\n+               rec(module = annotate_module(fm, crate.node.module)\n+                   with crate.node));\n+}\n+\n+fn check_crate(@ast.crate crate) -> @ast.crate {\n   /* Build the global map from function id to var-to-bit-num-map */\n-  auto fn_info_map = mk_f_to_fn_info(crate);\n+  auto fm = mk_f_to_fn_info(crate);\n   \n   /* Add a blank ts_ann to every statement (and expression) */\n-  auto fld0 = fold.new_identity_fold[_fn_info_map]();\n-  fld0 = @rec(fold_item_fn = bind item_fn_anns(_,_,_,_,_,_,_) with *fld0);\n-  auto with_anns = fold.fold_crate[_fn_info_map](fn_info_map, fld0, crate);\n+  /*\n+  auto fld0 = fold.new_identity_fold[fn_info_map]();\n+  fld0 = @rec(fold_item_fn = bind item_fn_anns(_,_,_,_,_,_,_)\n+              with *fld0);\n+  */\n+  auto with_anns = annotate_crate(fm, crate);\n   \n   /* Compute the pre and postcondition for every subexpression */\n-  auto fld = fold.new_identity_fold[_fn_info_map]();\n+  auto fld = fold.new_identity_fold[fn_info_map]();\n   fld = @rec(fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_) with *fld);\n-  auto with_pre_postconditions = fold.fold_crate[_fn_info_map]\n-    (fn_info_map, fld, with_anns);\n+  auto with_pre_postconditions = fold.fold_crate[fn_info_map]\n+    (fm, fld, with_anns);\n \n-  auto fld1 = fold.new_identity_fold[_fn_info_map]();\n+  auto fld1 = fold.new_identity_fold[fn_info_map]();\n \n-  fld1 = @rec(fold_item_fn = bind check_item_fn_state(_,_,_,_,_,_,_)\n+  fld1 = @rec(fold_item_fn = bind check_item_fn_state(_,_,_,_,_,_,_),\n+              fold_obj     = bind check_obj_state(_,_,_,_)\n               with *fld1);\n \n-  ret fold.fold_crate[_fn_info_map](fn_info_map, fld1,\n+  ret fold.fold_crate[fn_info_map](fm, fld1,\n                                     with_pre_postconditions);\n }\n "}, {"sha": "e49ed34e948b1e9daf059139b4ff734596274105", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=b7dd75c904277630675e432b3398a584d882b5ac", "patch": "@@ -475,6 +475,13 @@ fn print_expr(ps s, &@ast.expr expr) {\n             commasep[option.t[@ast.expr]](s, args, f);\n             pclose(s);\n         }\n+    case (ast.expr_spawn(_,_,?e,?es,_)) {\n+          wrd1(s, \"spawn\");\n+          print_expr(s, e);\n+          popen(s);\n+          commasep_exprs(s, es);\n+          pclose(s);\n+        }\n         case (ast.expr_binary(?op,?lhs,?rhs,_)) {\n             auto prec = operator_prec(op);\n             print_maybe_parens(s, lhs, prec);\n@@ -1018,3 +1025,13 @@ fn print_comment(ps s, lexer.cmnt_ cmnt) {\n         }\n     }\n }\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "af000cb6d0aadbf302f9e541614d672cc5b9f780", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=b7dd75c904277630675e432b3398a584d882b5ac", "patch": "@@ -137,6 +137,35 @@ fn log_block(&ast.block b) -> () {\n   log(s.get_str());\n }\n \n+fn log_ann(&ast.ann a) -> () {\n+    alt (a) {\n+        case (ast.ann_none) {\n+            log(\"ann_none\");\n+        }\n+        case (ast.ann_type(_,_,_)) {\n+            log(\"ann_type\");\n+        }\n+    }\n+}\n+\n+fn log_stmt(ast.stmt st) -> () {\n+  let str_writer s = string_writer();\n+  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out = @rec(s=out_,\n+                  comments=none[vec[front.lexer.cmnt]],\n+                  mutable cur_cmnt=0u);\n+  alt (st.node) {\n+    case (ast.stmt_decl(?decl,_)) {\n+      print_decl(out, decl);\n+    }\n+    case (ast.stmt_expr(?ex,_)) {\n+      print_expr(out, ex);\n+    }\n+    case (_) { /* do nothing */ }\n+  }\n+  log(s.get_str());\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "9ad6e01e8dd2744f12bfb7bf4988032fc52a2f59", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dd75c904277630675e432b3398a584d882b5ac/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=b7dd75c904277630675e432b3398a584d882b5ac", "patch": "@@ -147,6 +147,11 @@ fn ann_prestate(&ts_ann a) -> prestate {\n   ret a.states.prestate;\n }\n \n+fn pp_clone(&pre_and_post p) -> pre_and_post {\n+  ret rec(precondition=bitv.clone(p.precondition),\n+          postcondition=bitv.clone(p.postcondition));\n+}\n+\n // returns true if a implies b\n // that is, returns true except if for some bits c and d,\n // c = 1 and d = 0\n@@ -155,3 +160,14 @@ fn implies(bitv.t a, bitv.t b) -> bool {\n   bitv.difference(tmp, a);\n   ret bitv.is_false(tmp);\n }\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "cc8fabcaf1606e0f045c2eeca2a8d4c0d474e01d", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7dd75c904277630675e432b3398a584d882b5ac/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dd75c904277630675e432b3398a584d882b5ac/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=b7dd75c904277630675e432b3398a584d882b5ac", "patch": "@@ -266,7 +266,7 @@ fn unzip[T, U](&vec[tup(T, U)] v) -> tup(vec[T], vec[U]) {\n \n fn or(&vec[bool] v) -> bool {\n     auto f = orb;\n-    be _vec.foldl[bool, bool](f, false, v);\n+    ret _vec.foldl[bool, bool](f, false, v);\n }\n \n fn clone[T](&vec[T] v) -> vec[T] {"}, {"sha": "e214c77487f78a9c376d6fa0eeea3375ea97f9f0", "filename": "src/lib/option.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b7dd75c904277630675e432b3398a584d882b5ac/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dd75c904277630675e432b3398a584d882b5ac/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=b7dd75c904277630675e432b3398a584d882b5ac", "patch": "@@ -39,12 +39,16 @@ fn is_none[T](&t[T] opt) -> bool {\n }\n \n fn from_maybe[T](&T def, &t[T] opt) -> T {\n-    alt(opt) {\n-        case (none[T])     { ret def; }\n-        case (some[T](?t)) { ret t; }\n-    }\n+    auto f = bind util.id[T](_);\n+    ret maybe[T, T](def, f, opt);\n }\n \n+fn maybe[T, U](&U def, fn(&T) -> U f, &t[T] opt) -> U {\n+    alt (opt) {\n+        case (none[T]) { ret def; }\n+        case (some[T](?t)) { ret f(t); }\n+    }\n+}\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "be2f1727a6ffc2c6302fec29b5075bffd9bb51c8", "filename": "src/test/compile-fail/use-uninit-dtor.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b7dd75c904277630675e432b3398a584d882b5ac/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dd75c904277630675e432b3398a584d882b5ac/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs?ref=b7dd75c904277630675e432b3398a584d882b5ac", "patch": "@@ -0,0 +1,12 @@\n+// xfail-stage0\n+// error-pattern:Unsatisfied precondition\n+\n+fn main() {\n+ state obj foo(int x) {\n+        drop {\n+          let int baz;\n+          log(baz);\n+        }\n+ }\n+ fail;\n+}"}]}