{"sha": "912c1fc81c844fcffecbae638a4adb629a68cbfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMmMxZmM4MWM4NDRmY2ZmZWNiYWU2MzhhNGFkYjYyOWE2OGNiZmI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-23T21:17:44Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-23T21:22:10Z"}, "message": "Fix busted iter/put code. Un-XFAIL foreach-box-drop.rs.", "tree": {"sha": "c3d80c2ed430fc104d8cb0bc030ba5ccc58f1969", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3d80c2ed430fc104d8cb0bc030ba5ccc58f1969"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/912c1fc81c844fcffecbae638a4adb629a68cbfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/912c1fc81c844fcffecbae638a4adb629a68cbfb", "html_url": "https://github.com/rust-lang/rust/commit/912c1fc81c844fcffecbae638a4adb629a68cbfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/912c1fc81c844fcffecbae638a4adb629a68cbfb/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b298fa3e86fe76f1902fda096a7eeeff4c48937", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b298fa3e86fe76f1902fda096a7eeeff4c48937", "html_url": "https://github.com/rust-lang/rust/commit/2b298fa3e86fe76f1902fda096a7eeeff4c48937"}], "stats": {"total": 191, "additions": 94, "deletions": 97}, "files": [{"sha": "f49011230048f6b6f898fafc2565b0ce04f4035a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 94, "deletions": 95, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/912c1fc81c844fcffecbae638a4adb629a68cbfb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/912c1fc81c844fcffecbae638a4adb629a68cbfb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=912c1fc81c844fcffecbae638a4adb629a68cbfb", "patch": "@@ -641,7 +641,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n         atys +=\n             vec(T_fn_pair(cx.tn,\n                           type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n-                                          vec(rec(mode=ast.val, ty=output)),\n+                                          vec(rec(mode=ast.alias, ty=output)),\n                                           ty.mk_nil(cx.tystore), 0u)));\n     }\n \n@@ -3553,17 +3553,15 @@ fn trans_for_each(@block_ctxt cx,\n     // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n     // and pass it in as a first class fn-arg to the iterator.\n \n-    auto iter_body_llty = type_of_fn_full(lcx.ccx, ast.proto_fn,\n-                                          none[TypeRef],\n-                                          vec(rec(mode=ast.val, ty=decl_ty)),\n-                                          ty.mk_nil(lcx.ccx.tystore), 0u);\n+    auto iter_body_llty =\n+        type_of_fn_full(lcx.ccx, ast.proto_fn,\n+                        none[TypeRef],\n+                        vec(rec(mode=ast.alias, ty=decl_ty)),\n+                        ty.mk_nil(lcx.ccx.tystore), 0u);\n \n     let ValueRef lliterbody = decl_internal_fastcall_fn(lcx.ccx.llmod,\n                                                        s, iter_body_llty);\n \n-    // FIXME: handle ty params properly.\n-    let vec[ast.ty_param] ty_params = vec();\n-\n     auto fcx = new_fn_ctxt(lcx, lliterbody);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n@@ -3601,12 +3599,8 @@ fn trans_for_each(@block_ctxt cx,\n         i += 1u;\n     }\n \n-    // Treat the loop variable as an upvar as well. We copy it to an alloca\n-    // as usual.\n-    auto lllvar = llvm.LLVMGetParam(fcx.llfn, 3u);\n-    auto lllvarptr = alloca(bcx, val_ty(lllvar));\n-    bcx.build.Store(lllvar, lllvarptr);\n-    fcx.llupvars.insert(decl_id, lllvarptr);\n+    // Add an upvar for the loop variable alias.\n+    fcx.llupvars.insert(decl_id, llvm.LLVMGetParam(fcx.llfn, 3u));\n \n     auto r = trans_block(bcx, body);\n \n@@ -4570,6 +4564,68 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n     }\n }\n \n+fn trans_arg_expr(@block_ctxt cx,\n+                  ty.arg arg,\n+                  TypeRef lldestty0,\n+                  @ast.expr e) -> result {\n+\n+    auto val;\n+    auto bcx = cx;\n+    auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n+\n+    if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+        auto re = trans_expr(bcx, e);\n+        val = re.val;\n+        bcx = re.bcx;\n+    } else if (arg.mode == ast.alias) {\n+        let lval_result lv;\n+        if (ty.is_lval(e)) {\n+            lv = trans_lval(bcx, e);\n+        } else {\n+            auto r = trans_expr(bcx, e);\n+            if (type_is_immediate(cx.fcx.lcx.ccx, e_ty)) {\n+                lv = lval_val(r.bcx, r.val);\n+            } else {\n+                lv = lval_mem(r.bcx, r.val);\n+            }\n+        }\n+        bcx = lv.res.bcx;\n+\n+        if (lv.is_mem) {\n+            val = lv.res.val;\n+        } else {\n+            // Non-mem but we're trying to alias; synthesize an\n+            // alloca, spill to it and pass its address.\n+            val = do_spill(lv.res.bcx, lv.res.val);\n+        }\n+    } else {\n+        auto re = trans_expr(bcx, e);\n+        val = re.val;\n+        bcx = re.bcx;\n+    }\n+\n+    if (ty.count_ty_params(cx.fcx.lcx.ccx.tystore, arg.ty) > 0u) {\n+        auto lldestty = lldestty0;\n+        if (arg.mode == ast.val) {\n+            // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n+            if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+                lldestty = T_ptr(lldestty);\n+            }\n+        }\n+        val = bcx.build.PointerCast(val, lldestty);\n+    }\n+\n+    if (arg.mode == ast.val) {\n+        // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n+        if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+            // Until here we've been treating structures by pointer;\n+            // we are now passing it as an arg, so need to load it.\n+            val = bcx.build.Load(val);\n+        }\n+    }\n+    ret res(bcx, val);\n+}\n+\n // NB: must keep 4 fns in sync:\n //\n //  - type_of_fn_full\n@@ -4660,68 +4716,9 @@ fn trans_args(@block_ctxt cx,\n \n     auto i = 0u;\n     for (@ast.expr e in es) {\n-        auto mode = args.(i).mode;\n-\n-        auto val;\n-        if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore,\n-                                  ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n-            auto re = trans_expr(bcx, e);\n-            val = re.val;\n-            bcx = re.bcx;\n-        } else if (mode == ast.alias) {\n-            let lval_result lv;\n-            if (ty.is_lval(e)) {\n-                lv = trans_lval(bcx, e);\n-            } else {\n-                auto r = trans_expr(bcx, e);\n-                if (type_is_immediate(cx.fcx.lcx.ccx,\n-                                      ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n-                                                 e))) {\n-                    lv = lval_val(r.bcx, r.val);\n-                } else {\n-                    lv = lval_mem(r.bcx, r.val);\n-                }\n-            }\n-            bcx = lv.res.bcx;\n-\n-            if (lv.is_mem) {\n-                val = lv.res.val;\n-            } else {\n-                // Non-mem but we're trying to alias; synthesize an\n-                // alloca, spill to it and pass its address.\n-                val = do_spill(lv.res.bcx, lv.res.val);\n-            }\n-\n-        } else {\n-            auto re = trans_expr(bcx, e);\n-            val = re.val;\n-            bcx = re.bcx;\n-        }\n-\n-        if (ty.count_ty_params(cx.fcx.lcx.ccx.tystore, args.(i).ty) > 0u) {\n-            auto lldestty = arg_tys.(i);\n-            if (mode == ast.val) {\n-                // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n-                if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore,\n-                        ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n-                    lldestty = T_ptr(lldestty);\n-                }\n-            }\n-\n-            val = bcx.build.PointerCast(val, lldestty);\n-        }\n-\n-        if (mode == ast.val) {\n-            // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n-            if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore,\n-                    ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n-                // Until here we've been treating structures by pointer;\n-                // we are now passing it as an arg, so need to load it.\n-                val = bcx.build.Load(val);\n-            }\n-        }\n-\n-        llargs += vec(val);\n+        auto r = trans_arg_expr(bcx, args.(i), arg_tys.(i), e);\n+        bcx = r.bcx;\n+        llargs += vec(r.val);\n         i += 1u;\n     }\n \n@@ -4797,15 +4794,23 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n     bcx.build.FastCall(faddr, llargs);\n     auto retval = C_nil();\n \n-    if (!ty.type_is_nil(cx.fcx.lcx.ccx.tystore, ret_ty)) {\n-        retval = load_if_immediate(bcx, llretslot, ret_ty);\n-        // Retval doesn't correspond to anything really tangible in the frame,\n-        // but it's a ref all the same, so we put a note here to drop it when\n-        // we're done in this scope.\n-        find_scope_cx(cx).cleanups +=\n-            vec(clean(bind drop_ty(_, retval, ret_ty)));\n+    alt (lliterbody) {\n+        case (none[ValueRef]) {\n+            if (!ty.type_is_nil(cx.fcx.lcx.ccx.tystore, ret_ty)) {\n+                retval = load_if_immediate(bcx, llretslot, ret_ty);\n+                // Retval doesn't correspond to anything really tangible in\n+                // the frame, but it's a ref all the same, so we put a note\n+                // here to drop it when we're done in this scope.\n+                find_scope_cx(cx).cleanups +=\n+                    vec(clean(bind drop_ty(_, retval, ret_ty)));\n+            }\n+        }\n+        case (some[ValueRef](_)) {\n+            // If there was an lliterbody, it means we were calling an\n+            // iter, and we are *not* the party using its 'output' value,\n+            // we should ignore llretslot.\n+        }\n     }\n-\n     ret res(bcx, retval);\n }\n \n@@ -5296,18 +5301,12 @@ fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n     alt (e) {\n         case (none[@ast.expr]) { }\n         case (some[@ast.expr](?x)) {\n-            auto r = trans_expr(bcx, x);\n-\n-            auto llarg = r.val;\n+            auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, x);\n+            auto arg = rec(mode=ast.alias, ty=e_ty);\n+            auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx, vec(arg));\n+            auto r = trans_arg_expr(bcx, arg, arg_tys.(0), x);\n             bcx = r.bcx;\n-            if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore,\n-                    ty.expr_ty(cx.fcx.lcx.ccx.tystore, x))) {\n-                // Until here we've been treating structures by pointer; we\n-                // are now passing it as an arg, so need to load it.\n-                llarg = bcx.build.Load(llarg);\n-            }\n-\n-            llargs += vec(llarg);\n+            llargs += vec(r.val);\n         }\n     }\n "}, {"sha": "50fc181630d05bfcae8c605e7a701e50034223e3", "filename": "src/test/run-pass/foreach-box-drop.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/912c1fc81c844fcffecbae638a4adb629a68cbfb/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/912c1fc81c844fcffecbae638a4adb629a68cbfb/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs?ref=912c1fc81c844fcffecbae638a4adb629a68cbfb", "patch": "@@ -1,5 +1,3 @@\n-// xfail-stage0\n-\n obj ob[K](K k) {\n   iter foo() -> @tup(K) {\n     put @tup(k);"}]}