{"sha": "5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNjNhMjZkMzBjMWZjYmRlZTkzOWM5M2NjMTlhNDFjYzVkYmNhZjg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T07:55:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-25T00:17:46Z"}, "message": "test: Update all tests with the sync changes", "tree": {"sha": "cd27c095559478991ca8b967a57f52a4d22cfb65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd27c095559478991ca8b967a57f52a4d22cfb65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "html_url": "https://github.com/rust-lang/rust/commit/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eff025797a6dc58dad724e8523223d07025ac697", "url": "https://api.github.com/repos/rust-lang/rust/commits/eff025797a6dc58dad724e8523223d07025ac697", "html_url": "https://github.com/rust-lang/rust/commit/eff025797a6dc58dad724e8523223d07025ac697"}], "stats": {"total": 404, "additions": 80, "deletions": 324}, "files": [{"sha": "2ffa4529f0882cc8a280603068f8ba7b9ad6d442", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -359,7 +359,7 @@ fn main() {\n \n         spawn(proc() {\n             let local_arc : Arc<~[f64]> = rx.recv();\n-            let task_numbers = local_arc.get();\n+            let task_numbers = &*local_arc;\n             println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n         });\n     }\n@@ -411,7 +411,7 @@ Each task recovers the underlying data by\n # let (tx, rx) = channel();\n # tx.send(numbers_arc.clone());\n # let local_arc : Arc<~[f64]> = rx.recv();\n-let task_numbers = local_arc.get();\n+let task_numbers = &*local_arc;\n # }\n ~~~\n "}, {"sha": "acf6446a191f1ad7dc2166c9420d8c8c990d7e79", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -208,8 +208,8 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         let loc = loc.unwrap();\n \n         local_data::get(cache_key, |cache| {\n-            let cache = cache.unwrap().get();\n-            let abs_root = root(cache, loc.as_slice());\n+            let cache = cache.unwrap();\n+            let abs_root = root(&**cache, loc.as_slice());\n             let rel_root = match path.segments.get(0).name.as_slice() {\n                 \"self\" => Some(~\"./\"),\n                 _ => None,\n@@ -241,7 +241,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                 }\n             }\n \n-            match info(cache) {\n+            match info(&**cache) {\n                 // This is a documented path, link to it!\n                 Some((ref fqp, shortty)) if abs_root.is_some() => {\n                     let mut url = abs_root.unwrap();\n@@ -301,7 +301,7 @@ impl fmt::Show for clean::Type {\n         match *self {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 local_data::get(cache_key, |cache| {\n-                    let m = cache.unwrap().get();\n+                    let m = cache.unwrap();\n                     f.buf.write(m.typarams.get(&id).as_bytes())\n                 })\n             }"}, {"sha": "d2a34bc4e4a0de358644549945451982cf33bbd8", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -1265,7 +1265,7 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     }\n \n     local_data::get(cache_key, |cache| {\n-        let cache = cache.unwrap().get();\n+        let cache = cache.unwrap();\n         match cache.implementors.find(&it.id) {\n             Some(implementors) => {\n                 try!(write!(w, \"\n@@ -1496,7 +1496,7 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n \n fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n     local_data::get(cache_key, |cache| {\n-        let c = cache.unwrap().get();\n+        let c = cache.unwrap();\n         match c.impls.find(&it.id) {\n             Some(v) => {\n                 let mut non_trait = v.iter().filter(|p| {\n@@ -1576,7 +1576,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n             Some(id) => id,\n         };\n         try!(local_data::get(cache_key, |cache| {\n-            let cache = cache.unwrap().get();\n+            let cache = cache.unwrap();\n             match cache.traits.find(&trait_id) {\n                 Some(t) => {\n                     let name = meth.name.clone();\n@@ -1606,7 +1606,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n         None => {}\n         Some(id) => {\n             try!(local_data::get(cache_key, |cache| {\n-                let cache = cache.unwrap().get();\n+                let cache = cache.unwrap();\n                 match cache.traits.find(&id) {\n                     Some(t) => {\n                         for method in t.methods.iter() {"}, {"sha": "9c0328d4b11d0de3406ab290425e6f8f649cfd4b", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -26,7 +26,7 @@ extern crate sync;\n use serialize::json;\n use serialize::json::ToJson;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n-use sync::{Arc,RWArc};\n+use sync::{Arc, RWLock};\n use collections::TreeMap;\n use std::str;\n use std::io;\n@@ -225,7 +225,7 @@ pub type FreshnessMap = TreeMap<~str,extern fn(&str,&str)->bool>;\n \n #[deriving(Clone)]\n pub struct Context {\n-    db: RWArc<Database>,\n+    db: Arc<RWLock<Database>>,\n     priv cfg: Arc<json::Object>,\n     /// Map from kinds (source, exe, url, etc.) to a freshness function.\n     /// The freshness function takes a name (e.g. file path) and value\n@@ -269,12 +269,12 @@ fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n \n impl Context {\n \n-    pub fn new(db: RWArc<Database>,\n+    pub fn new(db: Arc<RWLock<Database>>,\n                cfg: Arc<json::Object>) -> Context {\n         Context::new_with_freshness(db, cfg, Arc::new(TreeMap::new()))\n     }\n \n-    pub fn new_with_freshness(db: RWArc<Database>,\n+    pub fn new_with_freshness(db: Arc<RWLock<Database>>,\n                               cfg: Arc<json::Object>,\n                               freshness: Arc<FreshnessMap>) -> Context {\n         Context {\n@@ -364,7 +364,7 @@ impl<'a> Prep<'a> {\n     fn is_fresh(&self, cat: &str, kind: &str,\n                 name: &str, val: &str) -> bool {\n         let k = kind.to_owned();\n-        let f = self.ctxt.freshness.get().find(&k);\n+        let f = self.ctxt.freshness.deref().find(&k);\n         debug!(\"freshness for: {}/{}/{}/{}\", cat, kind, name, val)\n         let fresh = match f {\n             None => fail!(\"missing freshness-function for '{}'\", kind),\n@@ -406,9 +406,10 @@ impl<'a> Prep<'a> {\n \n         debug!(\"exec_work: looking up {} and {:?}\", self.fn_name,\n                self.declared_inputs);\n-        let cached = self.ctxt.db.read(|db| {\n-            db.prepare(self.fn_name, &self.declared_inputs)\n-        });\n+        let cached = {\n+            let db = self.ctxt.db.deref().read();\n+            db.deref().prepare(self.fn_name, &self.declared_inputs)\n+        };\n \n         match cached {\n             Some((ref disc_in, ref disc_out, ref res))\n@@ -460,13 +461,12 @@ impl<'a, T:Send +\n             WorkFromTask(prep, port) => {\n                 let (exe, v) = port.recv();\n                 let s = json_encode(&v);\n-                prep.ctxt.db.write(|db| {\n-                    db.cache(prep.fn_name,\n-                             &prep.declared_inputs,\n-                             &exe.discovered_inputs,\n-                             &exe.discovered_outputs,\n-                             s)\n-                });\n+                let mut db = prep.ctxt.db.deref().write();\n+                db.deref_mut().cache(prep.fn_name,\n+                                     &prep.declared_inputs,\n+                                     &exe.discovered_inputs,\n+                                     &exe.discovered_outputs,\n+                                     s);\n                 v\n             }\n         }\n@@ -496,7 +496,7 @@ fn test() {\n \n     let db_path = make_path(~\"db.json\");\n \n-    let cx = Context::new(RWArc::new(Database::new(db_path)),\n+    let cx = Context::new(Arc::new(RWLock::new(Database::new(db_path))),\n                           Arc::new(TreeMap::new()));\n \n     let s = cx.with_prep(\"test1\", |prep| {"}, {"sha": "b24dc588babf6cc6046e4523ba0253085cca4a4c", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -18,36 +18,28 @@\n extern crate sync;\n extern crate time;\n \n-use sync::Arc;\n-use sync::MutexArc;\n-use sync::Future;\n+use sync::{Arc, Future, Mutex};\n use std::os;\n use std::uint;\n \n // A poor man's pipe.\n-type pipe = MutexArc<Vec<uint> >;\n+type pipe = Arc<Mutex<Vec<uint>>>;\n \n fn send(p: &pipe, msg: uint) {\n-    unsafe {\n-        p.access_cond(|state, cond| {\n-            state.push(msg);\n-            cond.signal();\n-        })\n-    }\n+    let mut arr = p.lock();\n+    arr.push(msg);\n+    arr.cond.signal();\n }\n fn recv(p: &pipe) -> uint {\n-    unsafe {\n-        p.access_cond(|state, cond| {\n-            while state.is_empty() {\n-                cond.wait();\n-            }\n-            state.pop().unwrap()\n-        })\n+    let mut arr = p.lock();\n+    while arr.is_empty() {\n+        arr.cond.wait();\n     }\n+    arr.pop().unwrap()\n }\n \n fn init() -> (pipe,pipe) {\n-    let m = MutexArc::new(Vec::new());\n+    let m = Arc::new(Mutex::new(Vec::new()));\n     ((&m).clone(), m)\n }\n "}, {"sha": "8e4a34384e8095144c13de9c3644daa5423f5abe", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -18,31 +18,29 @@\n extern crate sync;\n extern crate time;\n \n-use sync::RWArc;\n+use sync::{RWLock, Arc};\n use sync::Future;\n use std::os;\n use std::uint;\n \n // A poor man's pipe.\n-type pipe = RWArc<Vec<uint> >;\n+type pipe = Arc<RWLock<Vec<uint>>>;\n \n fn send(p: &pipe, msg: uint) {\n-    p.write_cond(|state, cond| {\n-        state.push(msg);\n-        cond.signal();\n-    })\n+    let mut arr = p.write();\n+    arr.push(msg);\n+    arr.cond.signal();\n }\n fn recv(p: &pipe) -> uint {\n-    p.write_cond(|state, cond| {\n-        while state.is_empty() {\n-            cond.wait();\n-        }\n-        state.pop().unwrap()\n-    })\n+    let mut arr = p.write();\n+    while arr.is_empty() {\n+        arr.cond.wait();\n+    }\n+    arr.pop().unwrap()\n }\n \n fn init() -> (pipe,pipe) {\n-    let x = RWArc::new(Vec::new());\n+    let x = Arc::new(RWLock::new(Vec::new()));\n     ((&x).clone(), x)\n }\n "}, {"sha": "939f8eaab68c4f210d1e8da5a59e238e7178a075", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -14,7 +14,8 @@ use std::from_str::FromStr;\n use std::iter::count;\n use std::cmp::min;\n use std::os;\n-use sync::RWArc;\n+use std::slice::from_elem;\n+use sync::{Arc, RWLock};\n \n fn A(i: uint, j: uint) -> f64 {\n     ((i + j) * (i + j + 1) / 2 + i + 1) as f64\n@@ -28,17 +29,16 @@ fn dot(v: &[f64], u: &[f64]) -> f64 {\n     sum\n }\n \n-fn mult(v: RWArc<Vec<f64>>,\n-        out: RWArc<Vec<f64>>,\n+fn mult(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>,\n         f: fn(&Vec<f64>, uint) -> f64) {\n-    // We launch in different tasks the work to be done.  To finish\n+    // We lanch in different tasks the work to be done.  To finish\n     // this fuction, we need to wait for the completion of every\n     // tasks.  To do that, we give to each tasks a wait_chan that we\n     // drop at the end of the work.  At the end of this function, we\n     // wait until the channel hang up.\n     let (tx, rx) = channel();\n \n-    let len = out.read(|out| out.len());\n+    let len = out.read().len();\n     let chunk = len / 100 + 1;\n     for chk in count(0, chunk) {\n         if chk >= len {break;}\n@@ -47,8 +47,8 @@ fn mult(v: RWArc<Vec<f64>>,\n         let out = out.clone();\n         spawn(proc() {\n             for i in range(chk, min(len, chk + chunk)) {\n-                let val = v.read(|v| f(v, i));\n-                out.write(|out| *out.get_mut(i) = val);\n+                let val = f(&*v.read(), i);\n+                *out.write().get_mut(i) = val;\n             }\n             drop(tx)\n         });\n@@ -67,7 +67,7 @@ fn mult_Av_impl(v: &Vec<f64> , i: uint) -> f64 {\n     sum\n }\n \n-fn mult_Av(v: RWArc<Vec<f64> >, out: RWArc<Vec<f64> >) {\n+fn mult_Av(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>) {\n     mult(v, out, mult_Av_impl);\n }\n \n@@ -79,11 +79,12 @@ fn mult_Atv_impl(v: &Vec<f64> , i: uint) -> f64 {\n     sum\n }\n \n-fn mult_Atv(v: RWArc<Vec<f64> >, out: RWArc<Vec<f64> >) {\n+fn mult_Atv(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>) {\n     mult(v, out, mult_Atv_impl);\n }\n \n-fn mult_AtAv(v: RWArc<Vec<f64> >, out: RWArc<Vec<f64> >, tmp: RWArc<Vec<f64> >) {\n+fn mult_AtAv(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>,\n+             tmp: Arc<RWLock<Vec<f64>>>) {\n     mult_Av(v, tmp.clone());\n     mult_Atv(tmp, out);\n }\n@@ -97,16 +98,16 @@ fn main() {\n     } else {\n         FromStr::from_str(args[1]).unwrap()\n     };\n-    let u = RWArc::new(Vec::from_elem(n, 1.));\n-    let v = RWArc::new(Vec::from_elem(n, 1.));\n-    let tmp = RWArc::new(Vec::from_elem(n, 1.));\n+    let u = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n+    let v = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n+    let tmp = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n     for _ in range(0, 10) {\n         mult_AtAv(u.clone(), v.clone(), tmp.clone());\n         mult_AtAv(v.clone(), u.clone(), tmp.clone());\n     }\n \n-    u.read(|u| v.read(|v| {\n-        println!(\"{:.9f}\",\n-                 (dot(u.as_slice(), v.as_slice()) / dot(v.as_slice(), v.as_slice())).sqrt());\n-    }))\n+    let u = u.read();\n+    let v = v.read();\n+    println!(\"{:.9f}\", (dot(u.as_slice(), v.as_slice()) /\n+                        dot(v.as_slice(), v.as_slice())).sqrt());\n }"}, {"sha": "151f4940d5702937dbed732b640c89ba0993252c", "filename": "src/test/compile-fail/arc-cant-nest-rw-arc-3177.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-cant-nest-rw-arc-3177.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-cant-nest-rw-arc-3177.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-cant-nest-rw-arc-3177.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate sync;\n-use sync::RWArc;\n-\n-fn main() {\n-    let arc1  = RWArc::new(true);\n-    let _arc2 = RWArc::new(arc1); //~ ERROR instantiating a type parameter with an incompatible type\n-}"}, {"sha": "71d42d46e7c5f4409cfdcef5b76561610c8fb0f1", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of return value does not outlive the function call\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None;\n-    x.write_cond(|_one, cond| y = Some(cond));\n-    y.unwrap().wait();\n-}"}, {"sha": "1787cd5d0b46c47b0ed0668ffad3e3908882c4ea", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        y = Some(x.downgrade(write_mode));\n-        //~^ ERROR cannot infer\n-    });\n-    y.unwrap();\n-    // Adding this line causes a method unification failure instead\n-    // (&option::unwrap(y)).read(|state| { assert!(*state == 1); })\n-}"}, {"sha": "cccca050696a34682891a1c28887debcfb44788c", "filename": "src/test/compile-fail/arc-rw-state-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None; //~ ERROR lifetime of variable does not enclose its declaration\n-    x.write(|one| y = Some(one));\n-    *y.unwrap() = 2;\n-    //~^ ERROR lifetime of return value does not outlive the function call\n-    //~^^ ERROR dereference of reference outside its lifetime\n-}"}, {"sha": "a08cb055020a531dfc8d3321a2b33dc886f794c7", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        (&write_mode).write_cond(|_one, cond| {\n-            y = Some(cond);\n-        })\n-    });\n-    y.unwrap().wait();\n-}"}, {"sha": "8f93d672b90161fd77e0aeedfc5d62f794532887", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| y = Some(write_mode));\n-    y.unwrap();\n-    // Adding this line causes a method unification failure instead\n-    // (&option::unwrap(y)).write(|state| { assert!(*state == 1); })\n-}"}, {"sha": "0ba4db4f211c249a2fa22e0f67cb92e54984bfe8", "filename": "src/test/compile-fail/functional-struct-update-noncopyable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-noncopyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-noncopyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-noncopyable.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -17,7 +17,7 @@ use sync::Arc;\n struct A { y: Arc<int>, x: Arc<int> }\n \n impl Drop for A {\n-    fn drop(&mut self) { println!(\"x={:?}\", self.x.get()); }\n+    fn drop(&mut self) { println!(\"x={}\", *self.x); }\n }\n fn main() {\n     let a = A { y: Arc::new(1), x: Arc::new(2) };"}, {"sha": "7e71b6fdf28d27833556fad33d63674ab63de131", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -20,11 +20,10 @@ fn main() {\n     let arc_v = Arc::new(v);\n \n     task::spawn(proc() {\n-        let v = arc_v.get();\n-        assert_eq!(*v.get(3), 4);\n+        assert_eq!(*arc_v.get(3), 4);\n     });\n \n-    assert_eq!(*(arc_v.get()).get(2), 3);\n+    assert_eq!(*arc_v.get(2), 3);\n \n-    println!(\"{:?}\", arc_v);\n+    println!(\"{}\", *arc_v);\n }"}, {"sha": "83e0ae0218cc60297451e26b702a6384ecbbae58", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -18,11 +18,10 @@ fn main() {\n     let arc_v = Arc::new(v);\n \n     task::spawn(proc() {\n-        let v = arc_v.get();\n-        assert_eq!(*v.get(3), 4);\n+        assert_eq!(*arc_v.get(3), 4);\n     });\n \n-    assert_eq!(*(arc_v.get()).get(2), 3); //~ ERROR use of moved value: `arc_v`\n+    assert_eq!(*arc_v.get(2), 3); //~ ERROR use of moved value: `arc_v`\n \n-    println!(\"{:?}\", arc_v); //~ ERROR use of moved value: `arc_v`\n+    println!(\"{}\", *arc_v); //~ ERROR use of moved value: `arc_v`\n }"}, {"sha": "c9ee105fe7b93b01f1ef55f399d5116ce59a7fc9", "filename": "src/test/compile-fail/once-cant-call-twice-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -23,7 +23,7 @@ fn foo(blk: proc()) {\n fn main() {\n     let x = Arc::new(true);\n     foo(proc() {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x);\n     });\n }"}, {"sha": "a81ddf06ac86e28b6e00486f3dae9b1fc06ff212", "filename": "src/test/compile-fail/once-cant-call-twice-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -23,7 +23,7 @@ fn foo(blk: once ||) {\n fn main() {\n     let x = Arc::new(true);\n     foo(|| {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x);\n     })\n }"}, {"sha": "8f3f9cf74dbad2d51b1a2a5679f82468a549aebe", "filename": "src/test/compile-fail/once-cant-move-out-of-non-once-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -22,7 +22,7 @@ fn foo(blk: ||) {\n fn main() {\n     let x = Arc::new(true);\n     foo(|| {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x); //~ ERROR cannot move out of captured outer variable\n     })\n }"}, {"sha": "4ba1c5c7cfeec458e2525486c38b70a23ec43e41", "filename": "src/test/compile-fail/sync-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::Mutex;\n-\n-fn main() {\n-    let m = ~sync::Mutex::new();\n-    let mut cond = None;\n-    m.lock_cond(|c| {\n-        cond = Some(c);\n-    });\n-    cond.unwrap().signal();\n-}"}, {"sha": "697858f40da6084b761f1005317c464de2d26e56", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of method receiver does not outlive the method call\n-extern crate sync;\n-use sync::RWLock;\n-fn main() {\n-    let x = ~RWLock::new();\n-    let mut y = None;\n-    x.write_cond(|cond| {\n-        y = Some(cond);\n-    });\n-    y.unwrap().wait();\n-}"}, {"sha": "30ed0912f6a8a9242b1f683ae1e6687fc7a7b8cf", "filename": "src/test/compile-fail/sync-rwlock-read-mode-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: cannot infer\n-extern crate sync;\n-use sync::RWLock;\n-fn main() {\n-    let x = ~RWLock::new();\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        y = Some(x.downgrade(write_mode));\n-    })\n-    // Adding this line causes a method unification failure instead\n-    // (&option::unwrap(y)).read(proc() { });\n-}"}, {"sha": "09b4e34ea8c135b99608252e93a5dd1aaf5cfd82", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::RWLock;\n-fn main() {\n-    let x = ~RWLock::new();\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        (&write_mode).write_cond(|cond| {\n-            y = Some(cond);\n-        })\n-    });\n-    y.unwrap().wait();\n-}"}, {"sha": "0fca360d0ce3d76bf48c122b3cb8158e1e931392", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff025797a6dc58dad724e8523223d07025ac697/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=eff025797a6dc58dad724e8523223d07025ac697", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::RWLock;\n-fn main() {\n-    let x = ~RWLock::new();\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        y = Some(write_mode);\n-    });\n-    // Adding this line causes a method unification failure instead\n-    // (&option::unwrap(y)).write(proc() { })\n-}"}, {"sha": "d27cce4dd368c1ef7cef7d2dc9a9fc6b5dd34474", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -23,7 +23,7 @@ fn foo(blk: proc()) {\n pub fn main() {\n     let x = Arc::new(true);\n     foo(proc() {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x);\n     });\n }"}, {"sha": "f14827c7245f423d4f837c281a47831ee1fd0ba3", "filename": "src/test/run-pass/once-move-out-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -23,7 +23,7 @@ fn foo(blk: once ||) {\n pub fn main() {\n     let x = Arc::new(true);\n     foo(|| {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x);\n     })\n }"}, {"sha": "3deb0b7527d9f1d52d44a9bdf40cb683a9fff994", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=5163a26d30c1fcbdee939c93cc19a41cc5dbcaf8", "patch": "@@ -85,20 +85,20 @@ pub fn main() {\n \n fn check_legs(arc: Arc<Vec<~Pet:Share+Send>>) {\n     let mut legs = 0;\n-    for pet in arc.get().iter() {\n+    for pet in arc.iter() {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n fn check_names(arc: Arc<Vec<~Pet:Share+Send>>) {\n-    for pet in arc.get().iter() {\n+    for pet in arc.iter() {\n         pet.name(|name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         })\n     }\n }\n fn check_pedigree(arc: Arc<Vec<~Pet:Share+Send>>) {\n-    for pet in arc.get().iter() {\n+    for pet in arc.iter() {\n         assert!(pet.of_good_pedigree());\n     }\n }"}]}