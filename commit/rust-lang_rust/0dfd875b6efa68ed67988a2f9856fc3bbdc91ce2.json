{"sha": "0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZmQ4NzViNmVmYTY4ZWQ2Nzk4OGEyZjk4NTZmYzNiYmRjOTFjZTI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-11-23T22:23:48Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-11-23T22:53:47Z"}, "message": "rustfmt libcollections", "tree": {"sha": "4cbbfc1e2246c63f75e0d1f0e48d99153504b7b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cbbfc1e2246c63f75e0d1f0e48d99153504b7b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "html_url": "https://github.com/rust-lang/rust/commit/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f1a1e6595cb9472927cd91d523982047832aa7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f1a1e6595cb9472927cd91d523982047832aa7a", "html_url": "https://github.com/rust-lang/rust/commit/1f1a1e6595cb9472927cd91d523982047832aa7a"}], "stats": {"total": 2408, "additions": 1426, "deletions": 982}, "files": [{"sha": "b643794f8a2565e4cdcfd32611372f4a681fb242", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 66, "deletions": 28, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -151,7 +151,7 @@\n #![allow(missing_docs)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::iter::{FromIterator};\n+use core::iter::FromIterator;\n use core::mem::swap;\n use core::ptr;\n use core::fmt;\n@@ -186,7 +186,9 @@ impl<T: Clone> Clone for BinaryHeap<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n-    fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n+    fn default() -> BinaryHeap<T> {\n+        BinaryHeap::new()\n+    }\n }\n \n #[stable(feature = \"binaryheap_debug\", since = \"1.4.0\")]\n@@ -207,7 +209,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n+    pub fn new() -> BinaryHeap<T> {\n+        BinaryHeap { data: vec![] }\n+    }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n     /// This preallocates enough memory for `capacity` elements,\n@@ -296,7 +300,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize { self.data.capacity() }\n+    pub fn capacity(&self) -> usize {\n+        self.data.capacity()\n+    }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n@@ -419,11 +425,13 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         match self.data.get_mut(0) {\n             None => return item,\n-            Some(top) => if *top > item {\n-                swap(&mut item, top);\n-            } else {\n-                return item;\n-            },\n+            Some(top) => {\n+                if *top > item {\n+                    swap(&mut item, top);\n+                } else {\n+                    return item;\n+                }\n+            }\n         }\n \n         self.sift_down(0);\n@@ -522,7 +530,9 @@ impl<T: Ord> BinaryHeap<T> {\n \n             while hole.pos() > start {\n                 let parent = (hole.pos() - 1) / 2;\n-                if hole.element() <= hole.get(parent) { break; }\n+                if hole.element() <= hole.get(parent) {\n+                    break;\n+                }\n                 hole.move_to(parent);\n             }\n         }\n@@ -541,7 +551,9 @@ impl<T: Ord> BinaryHeap<T> {\n                     child = right;\n                 }\n                 // if we are already in order, stop.\n-                if hole.element() >= hole.get(child) { break; }\n+                if hole.element() >= hole.get(child) {\n+                    break;\n+                }\n                 hole.move_to(child);\n                 child = 2 * hole.pos() + 1;\n             }\n@@ -555,11 +567,15 @@ impl<T: Ord> BinaryHeap<T> {\n \n     /// Returns the length of the binary heap.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.data.len() }\n+    pub fn len(&self) -> usize {\n+        self.data.len()\n+    }\n \n     /// Checks if the binary heap is empty.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Clears the binary heap, returning an iterator over the removed elements.\n     ///\n@@ -575,7 +591,9 @@ impl<T: Ord> BinaryHeap<T> {\n \n     /// Drops all items from the binary heap.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) { self.drain(); }\n+    pub fn clear(&mut self) {\n+        self.drain();\n+    }\n }\n \n /// Hole represents a hole in a slice i.e. an index without valid value\n@@ -603,7 +621,9 @@ impl<'a, T> Hole<'a, T> {\n     }\n \n     #[inline(always)]\n-    fn pos(&self) -> usize { self.pos }\n+    fn pos(&self) -> usize {\n+        self.pos\n+    }\n \n     /// Return a reference to the element removed\n     #[inline(always)]\n@@ -647,7 +667,7 @@ impl<'a, T> Drop for Hole<'a, T> {\n \n /// `BinaryHeap` iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter <'a, T: 'a> {\n+pub struct Iter<'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n }\n \n@@ -664,16 +684,22 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        self.iter.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -690,16 +716,22 @@ impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -716,16 +748,22 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -753,7 +791,7 @@ impl<T> From<BinaryHeap<T>> for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> BinaryHeap<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BinaryHeap<T> {\n         BinaryHeap::from(iter.into_iter().collect::<Vec<_>>())\n     }\n }\n@@ -796,7 +834,7 @@ impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iterable: I) {\n         let iter = iterable.into_iter();\n         let (lower, _) = iter.size_hint();\n \n@@ -810,7 +848,7 @@ impl<T: Ord> Extend<T> for BinaryHeap<T> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }"}, {"sha": "bfd4c2e96b587acc7a41513c18e7fd8706878e3c", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -28,7 +28,10 @@ use self::Cow::*;\n pub use core::borrow::{Borrow, BorrowMut};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n+impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B>\n+    where B: ToOwned,\n+          <B as ToOwned>::Owned: 'a\n+{\n     fn borrow(&self) -> &B {\n         &**self\n     }\n@@ -53,7 +56,9 @@ pub trait ToOwned {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ToOwned for T where T: Clone {\n     type Owned = T;\n-    fn to_owned(&self) -> T { self.clone() }\n+    fn to_owned(&self) -> T {\n+        self.clone()\n+    }\n }\n \n /// A clone-on-write smart pointer.\n@@ -85,14 +90,16 @@ impl<T> ToOwned for T where T: Clone {\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Cow<'a, B: ?Sized + 'a> where B: ToOwned {\n+pub enum Cow<'a, B: ?Sized + 'a>\n+    where B: ToOwned\n+{\n     /// Borrowed data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Borrowed(&'a B),\n \n     /// Owned data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Owned(<B as ToOwned>::Owned)\n+    Owned(<B as ToOwned>::Owned),\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -103,7 +110,7 @@ impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n             Owned(ref o) => {\n                 let b: &B = o.borrow();\n                 Owned(b.to_owned())\n-            },\n+            }\n         }\n     }\n }\n@@ -131,7 +138,7 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n                 *self = Owned(borrowed.to_owned());\n                 self.to_mut()\n             }\n-            Owned(ref mut owned) => owned\n+            Owned(ref mut owned) => owned,\n         }\n     }\n \n@@ -154,7 +161,7 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n     pub fn into_owned(self) -> <B as ToOwned>::Owned {\n         match self {\n             Borrowed(borrowed) => borrowed.to_owned(),\n-            Owned(owned) => owned\n+            Owned(owned) => owned,\n         }\n     }\n }\n@@ -166,7 +173,7 @@ impl<'a, B: ?Sized> Deref for Cow<'a, B> where B: ToOwned {\n     fn deref(&self) -> &B {\n         match *self {\n             Borrowed(borrowed) => borrowed,\n-            Owned(ref owned) => owned.borrow()\n+            Owned(ref owned) => owned.borrow(),\n         }\n     }\n }\n@@ -183,8 +190,9 @@ impl<'a, B: ?Sized> Ord for Cow<'a, B> where B: Ord + ToOwned {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n-    B: PartialEq<C> + ToOwned, C: ToOwned,\n+impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B>\n+    where B: PartialEq<C> + ToOwned,\n+          C: ToOwned\n {\n     #[inline]\n     fn eq(&self, other: &Cow<'b, C>) -> bool {\n@@ -193,18 +201,17 @@ impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where B: PartialOrd + ToOwned,\n-{\n+impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where B: PartialOrd + ToOwned {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n-    B: fmt::Debug + ToOwned,\n-    <B as ToOwned>::Owned: fmt::Debug,\n+impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B>\n+    where B: fmt::Debug + ToOwned,\n+          <B as ToOwned>::Owned: fmt::Debug\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -215,9 +222,9 @@ impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n-    B: fmt::Display + ToOwned,\n-    <B as ToOwned>::Owned: fmt::Display,\n+impl<'a, B: ?Sized> fmt::Display for Cow<'a, B>\n+    where B: fmt::Display + ToOwned,\n+          <B as ToOwned>::Owned: fmt::Display\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -228,8 +235,7 @@ impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n-{\n+impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         Hash::hash(&**self, state)\n@@ -245,7 +251,7 @@ pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n+impl<'a, B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B> {\n         self\n     }"}, {"sha": "0091beb9ca6d563c3a27029d50c76be88a9722b9", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 258, "deletions": 157, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -84,46 +84,46 @@ struct AbsIter<T> {\n /// An iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<Traversal<'a, K, V>>\n+    inner: AbsIter<Traversal<'a, K, V>>,\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<MutTraversal<'a, K, V>>\n+    inner: AbsIter<MutTraversal<'a, K, V>>,\n }\n \n /// An owning iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    inner: AbsIter<MoveTraversal<K, V>>\n+    inner: AbsIter<MoveTraversal<K, V>>,\n }\n \n /// An iterator over a BTreeMap's keys.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>,\n }\n \n /// An iterator over a BTreeMap's values.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>,\n }\n \n /// An iterator over a sub-range of BTreeMap's entries.\n pub struct Range<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<Traversal<'a, K, V>>\n+    inner: AbsIter<Traversal<'a, K, V>>,\n }\n \n /// A mutable iterator over a sub-range of BTreeMap's entries.\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<MutTraversal<'a, K, V>>\n+    inner: AbsIter<MutTraversal<'a, K, V>>,\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Entry<'a, K:'a, V:'a> {\n+pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant Entry\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Vacant(VacantEntry<'a, K, V>),\n@@ -135,14 +135,14 @@ pub enum Entry<'a, K:'a, V:'a> {\n \n /// A vacant Entry.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VacantEntry<'a, K:'a, V:'a> {\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n /// An occupied Entry.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct OccupiedEntry<'a, K:'a, V:'a> {\n+pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n \n@@ -151,7 +151,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn new() -> BTreeMap<K, V> {\n-        //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n+        // FIXME(Gankro): Tune this as a function of size_of<K/V>?\n         BTreeMap::with_b(6)\n     }\n \n@@ -189,7 +189,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n-        for _ in mem::replace(self, BTreeMap::with_b(b)) {};\n+        for _ in mem::replace(self, BTreeMap::with_b(b)) {}\n     }\n \n     // Searching in a B-Tree is pretty straightforward.\n@@ -216,16 +216,21 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: Ord {\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         let mut cur_node = &self.root;\n         loop {\n             match Node::search(cur_node, key) {\n                 Found(handle) => return Some(handle.into_kv().1),\n-                GoDown(handle) => match handle.force() {\n-                    Leaf(_) => return None,\n-                    Internal(internal_handle) => {\n-                        cur_node = internal_handle.into_edge();\n-                        continue;\n+                GoDown(handle) => {\n+                    match handle.force() {\n+                        Leaf(_) => return None,\n+                        Internal(internal_handle) => {\n+                            cur_node = internal_handle.into_edge();\n+                            continue;\n+                        }\n                     }\n                 }\n             }\n@@ -248,7 +253,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where K: Borrow<Q>, Q: Ord {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         self.get(key).is_some()\n     }\n \n@@ -271,18 +279,23 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where K: Borrow<Q>, Q: Ord {\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n             let cur_node = temp_node;\n             match Node::search(cur_node, key) {\n                 Found(handle) => return Some(handle.into_kv_mut().1),\n-                GoDown(handle) => match handle.force() {\n-                    Leaf(_) => return None,\n-                    Internal(internal_handle) => {\n-                        temp_node = internal_handle.into_edge_mut();\n-                        continue;\n+                GoDown(handle) => {\n+                    match handle.force() {\n+                        Leaf(_) => return None,\n+                        Internal(internal_handle) => {\n+                            temp_node = internal_handle.into_edge_mut();\n+                            continue;\n+                        }\n                     }\n                 }\n             }\n@@ -366,7 +379,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                         // Perfect match, swap the values and return the old one\n                         mem::swap(handle.val_mut(), &mut value);\n                         Finished(Some(value))\n-                    },\n+                    }\n                     GoDown(handle) => {\n                         // We need to keep searching, try to get the search stack\n                         // to go down further\n@@ -448,7 +461,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where K: Borrow<Q>, Q: Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -457,20 +473,20 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                     Found(handle) => {\n                         // Perfect match. Terminate the stack here, and remove the entry\n                         Finished(Some(pusher.seal(handle).remove()))\n-                    },\n+                    }\n                     GoDown(handle) => {\n                         // We need to keep searching, try to go down the next edge\n                         match handle.force() {\n                             // We're at a leaf; the key isn't in here\n                             Leaf(_) => Finished(None),\n-                            Internal(internal_handle) => Continue(pusher.push(internal_handle))\n+                            Internal(internal_handle) => Continue(pusher.push(internal_handle)),\n                         }\n                     }\n                 }\n             });\n             match result {\n                 Finished(ret) => return ret.map(|(_, v)| v),\n-                Continue(new_stack) => stack = new_stack\n+                Continue(new_stack) => stack = new_stack,\n             }\n         }\n     }\n@@ -505,7 +521,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n             inner: AbsIter {\n                 traversals: lca,\n                 size: len,\n-            }\n+            },\n         }\n     }\n }\n@@ -534,7 +550,7 @@ impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n /// return from a closure\n enum Continuation<A, B> {\n     Continue(A),\n-    Finished(B)\n+    Finished(B),\n }\n \n /// The stack module provides a safe interface for constructing and manipulating a stack of ptrs\n@@ -549,8 +565,7 @@ mod stack {\n     use super::super::node::handle;\n     use vec::Vec;\n \n-    struct InvariantLifetime<'id>(\n-        marker::PhantomData<::core::cell::Cell<&'id ()>>);\n+    struct InvariantLifetime<'id>(marker::PhantomData<::core::cell::Cell<&'id ()>>);\n \n     impl<'id> InvariantLifetime<'id> {\n         fn new() -> InvariantLifetime<'id> {\n@@ -585,7 +600,7 @@ mod stack {\n     type Stack<K, V> = Vec<StackItem<K, V>>;\n \n     /// A `PartialSearchStack` handles the construction of a search stack.\n-    pub struct PartialSearchStack<'a, K:'a, V:'a> {\n+    pub struct PartialSearchStack<'a, K: 'a, V: 'a> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n         next: *mut Node<K, V>,\n@@ -594,7 +609,7 @@ mod stack {\n     /// A `SearchStack` represents a full path to an element or an edge of interest. It provides\n     /// methods depending on the type of what the path points to for removing an element, inserting\n     /// a new element, and manipulating to element at the top of the stack.\n-    pub struct SearchStack<'a, K:'a, V:'a, Type, NodeType> {\n+    pub struct SearchStack<'a, K: 'a, V: 'a, Type, NodeType> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n         top: node::Handle<*mut Node<K, V>, Type, NodeType>,\n@@ -603,7 +618,7 @@ mod stack {\n     /// A `PartialSearchStack` that doesn't hold a reference to the next node, and is just\n     /// just waiting for a `Handle` to that next node to be pushed. See `PartialSearchStack::with`\n     /// for more details.\n-    pub struct Pusher<'id, 'a, K:'a, V:'a> {\n+    pub struct Pusher<'id, 'a, K: 'a, V: 'a> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n         _marker: InvariantLifetime<'id>,\n@@ -656,9 +671,8 @@ mod stack {\n         /// Pushes the requested child of the stack's current top on top of the stack. If the child\n         /// exists, then a new PartialSearchStack is yielded. Otherwise, a VacantSearchStack is\n         /// yielded.\n-        pub fn push(mut self, mut edge: node::Handle<IdRef<'id, Node<K, V>>,\n-                                                     handle::Edge,\n-                                                     handle::Internal>)\n+        pub fn push(mut self,\n+                    mut edge: node::Handle<IdRef<'id, Node<K, V>>, handle::Edge, handle::Internal>)\n                     -> PartialSearchStack<'a, K, V> {\n             self.stack.push(edge.as_raw());\n             PartialSearchStack {\n@@ -669,9 +683,11 @@ mod stack {\n         }\n \n         /// Converts the PartialSearchStack into a SearchStack.\n-        pub fn seal<Type, NodeType>\n-                   (self, mut handle: node::Handle<IdRef<'id, Node<K, V>>, Type, NodeType>)\n-                    -> SearchStack<'a, K, V, Type, NodeType> {\n+        pub fn seal<Type, NodeType>(self,\n+                                    mut handle: node::Handle<IdRef<'id, Node<K, V>>,\n+                                                             Type,\n+                                                             NodeType>)\n+                                    -> SearchStack<'a, K, V, Type, NodeType> {\n             SearchStack {\n                 map: self.map,\n                 stack: self.stack,\n@@ -694,9 +710,7 @@ mod stack {\n         /// Converts the stack into a mutable reference to the value it points to, with a lifetime\n         /// tied to the original tree.\n         pub fn into_top(mut self) -> &'a mut V {\n-            unsafe {\n-                &mut *(self.top.from_raw_mut().val_mut() as *mut V)\n-            }\n+            unsafe { &mut *(self.top.from_raw_mut().val_mut() as *mut V) }\n         }\n     }\n \n@@ -778,13 +792,13 @@ mod stack {\n                         return SearchStack {\n                             map: self.map,\n                             stack: self.stack,\n-                            top: leaf_handle.as_raw()\n-                        }\n+                            top: leaf_handle.as_raw(),\n+                        };\n                     }\n                     Internal(mut internal_handle) => {\n                         let mut right_handle = internal_handle.right_edge();\n \n-                        //We're not a proper leaf stack, let's get to work.\n+                        // We're not a proper leaf stack, let's get to work.\n                         self.stack.push(right_handle.as_raw());\n \n                         let mut temp_node = right_handle.edge_mut();\n@@ -800,9 +814,9 @@ mod stack {\n                                     return SearchStack {\n                                         map: self.map,\n                                         stack: self.stack,\n-                                        top: handle.as_raw()\n-                                    }\n-                                },\n+                                        top: handle.as_raw(),\n+                                    };\n+                                }\n                                 Internal(kv_handle) => {\n                                     // This node is internal, go deeper\n                                     let mut handle = kv_handle.into_left_edge();\n@@ -830,7 +844,8 @@ mod stack {\n                 self.map.length += 1;\n \n                 // Insert the key and value into the leaf at the top of the stack\n-                let (mut insertion, inserted_ptr) = self.top.from_raw_mut()\n+                let (mut insertion, inserted_ptr) = self.top\n+                                                        .from_raw_mut()\n                                                         .insert_as_leaf(key, val);\n \n                 loop {\n@@ -840,24 +855,29 @@ mod stack {\n                             // inserting now.\n                             return &mut *inserted_ptr;\n                         }\n-                        Split(key, val, right) => match self.stack.pop() {\n-                            // The last insertion triggered a split, so get the next element on the\n-                            // stack to recursively insert the split node into.\n-                            None => {\n-                                // The stack was empty; we've split the root, and need to make a\n-                                // a new one. This is done in-place because we can't move the\n-                                // root out of a reference to the tree.\n-                                Node::make_internal_root(&mut self.map.root, self.map.b,\n-                                                         key, val, right);\n-\n-                                self.map.depth += 1;\n-                                return &mut *inserted_ptr;\n-                            }\n-                            Some(mut handle) => {\n-                                // The stack wasn't empty, do the insertion and recurse\n-                                insertion = handle.from_raw_mut()\n-                                                  .insert_as_internal(key, val, right);\n-                                continue;\n+                        Split(key, val, right) => {\n+                            match self.stack.pop() {\n+                                // The last insertion triggered a split, so get the next element on\n+                                // the stack to recursively insert the split node into.\n+                                None => {\n+                                    // The stack was empty; we've split the root, and need to make a\n+                                    // a new one. This is done in-place because we can't move the\n+                                    // root out of a reference to the tree.\n+                                    Node::make_internal_root(&mut self.map.root,\n+                                                             self.map.b,\n+                                                             key,\n+                                                             val,\n+                                                             right);\n+\n+                                    self.map.depth += 1;\n+                                    return &mut *inserted_ptr;\n+                                }\n+                                Some(mut handle) => {\n+                                    // The stack wasn't empty, do the insertion and recurse\n+                                    insertion = handle.from_raw_mut()\n+                                                      .insert_as_internal(key, val, right);\n+                                    continue;\n+                                }\n                             }\n                         }\n                     }\n@@ -869,7 +889,7 @@ mod stack {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n-    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n         map.extend(iter);\n         map\n@@ -879,7 +899,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n-    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -888,7 +908,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n-    fn extend<I: IntoIterator<Item=(&'a K, &'a V)>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n }\n@@ -912,8 +932,7 @@ impl<K: Ord, V> Default for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other).all(|(a, b)| a == b)\n+        self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a == b)\n     }\n }\n \n@@ -945,7 +964,8 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n-    where K: Borrow<Q>, Q: Ord\n+    where K: Borrow<Q>,\n+          Q: Ord\n {\n     type Output = V;\n \n@@ -987,8 +1007,8 @@ enum StackOp<T> {\n     Push(T),\n     Pop,\n }\n-impl<K, V, E, T> Iterator for AbsIter<T> where\n-    T: DoubleEndedIterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n+impl<K, V, E, T> Iterator for AbsIter<T>\n+    where T: DoubleEndedIterator<Item = TraversalItem<K, V, E>> + Traverse<E>\n {\n     type Item = (K, V);\n \n@@ -1002,23 +1022,29 @@ impl<K, V, E, T> Iterator for AbsIter<T> where\n             let op = match self.traversals.back_mut() {\n                 None => return None,\n                 // The queue wasn't empty, so continue along the node in its head\n-                Some(iter) => match iter.next() {\n-                    // The head is empty, so Pop it off and continue the process\n-                    None => Pop,\n-                    // The head yielded an edge, so make that the new head\n-                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                    // The head yielded an entry, so yield that\n-                    Some(Elem(kv)) => {\n-                        self.size -= 1;\n-                        return Some(kv)\n+                Some(iter) => {\n+                    match iter.next() {\n+                        // The head is empty, so Pop it off and continue the process\n+                        None => Pop,\n+                        // The head yielded an edge, so make that the new head\n+                        Some(Edge(next)) => Push(Traverse::traverse(next)),\n+                        // The head yielded an entry, so yield that\n+                        Some(Elem(kv)) => {\n+                            self.size -= 1;\n+                            return Some(kv);\n+                        }\n                     }\n                 }\n             };\n \n             // Handle any operation as necessary, without a conflicting borrow of the queue\n             match op {\n-                Push(item) => { self.traversals.push_back(item); },\n-                Pop => { self.traversals.pop_back(); },\n+                Push(item) => {\n+                    self.traversals.push_back(item);\n+                }\n+                Pop => {\n+                    self.traversals.pop_back();\n+                }\n             }\n         }\n     }\n@@ -1028,46 +1054,60 @@ impl<K, V, E, T> Iterator for AbsIter<T> where\n     }\n }\n \n-impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n-    T: DoubleEndedIterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n+impl<K, V, E, T> DoubleEndedIterator for AbsIter<T>\n+    where T: DoubleEndedIterator<Item = TraversalItem<K, V, E>> + Traverse<E>\n {\n     // next_back is totally symmetric to next\n     #[inline]\n     fn next_back(&mut self) -> Option<(K, V)> {\n         loop {\n             let op = match self.traversals.front_mut() {\n                 None => return None,\n-                Some(iter) => match iter.next_back() {\n-                    None => Pop,\n-                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                    Some(Elem(kv)) => {\n-                        self.size -= 1;\n-                        return Some(kv)\n+                Some(iter) => {\n+                    match iter.next_back() {\n+                        None => Pop,\n+                        Some(Edge(next)) => Push(Traverse::traverse(next)),\n+                        Some(Elem(kv)) => {\n+                            self.size -= 1;\n+                            return Some(kv);\n+                        }\n                     }\n                 }\n             };\n \n             match op {\n-                Push(item) => { self.traversals.push_front(item); },\n-                Pop => { self.traversals.pop_front(); }\n+                Push(item) => {\n+                    self.traversals.push_front(item);\n+                }\n+                Pop => {\n+                    self.traversals.pop_front();\n+                }\n             }\n         }\n     }\n }\n \n impl<'a, K, V> Clone for Iter<'a, K, V> {\n-    fn clone(&self) -> Iter<'a, K, V> { Iter { inner: self.inner.clone() } }\n+    fn clone(&self) -> Iter<'a, K, V> {\n+        Iter { inner: self.inner.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n-    fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n@@ -1076,12 +1116,18 @@ impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n@@ -1090,70 +1136,102 @@ impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n-    fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n-    fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(K, V)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {}\n \n impl<'a, K, V> Clone for Keys<'a, K, V> {\n-    fn clone(&self) -> Keys<'a, K, V> { Keys { inner: self.inner.clone() } }\n+    fn clone(&self) -> Keys<'a, K, V> {\n+        Keys { inner: self.inner.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n-    fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(&'a K)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}\n \n \n impl<'a, K, V> Clone for Values<'a, K, V> {\n-    fn clone(&self) -> Values<'a, K, V> { Values { inner: self.inner.clone() } }\n+    fn clone(&self) -> Values<'a, K, V> {\n+        Values { inner: self.inner.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n-    fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(&'a V)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a V)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n impl<'a, K, V> Clone for Range<'a, K, V> {\n-    fn clone(&self) -> Range<'a, K, V> { Range { inner: self.inner.clone() } }\n+    fn clone(&self) -> Range<'a, K, V> {\n+        Range { inner: self.inner.clone() }\n+    }\n }\n impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n-    fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next()\n+    }\n }\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next_back()\n+    }\n }\n \n impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next()\n+    }\n }\n impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next_back()\n+    }\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n@@ -1251,7 +1329,7 @@ impl<K, V> BTreeMap<K, V> {\n             inner: AbsIter {\n                 traversals: lca,\n                 size: len,\n-            }\n+            },\n         }\n     }\n \n@@ -1283,7 +1361,7 @@ impl<K, V> BTreeMap<K, V> {\n             inner: AbsIter {\n                 traversals: lca,\n                 size: len,\n-            }\n+            },\n         }\n     }\n \n@@ -1303,7 +1381,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        fn first<A, B>((a, _): (A, B)) -> A {\n+            a\n+        }\n         let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n \n         Keys { inner: self.iter().map(first) }\n@@ -1325,7 +1405,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        fn second<A, B>((_, b): (A, B)) -> B { b }\n+        fn second<A, B>((_, b): (A, B)) -> B {\n+            b\n+        }\n         let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n \n         Values { inner: self.iter().map(second) }\n@@ -1344,7 +1426,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.length }\n+    pub fn len(&self) -> usize {\n+        self.length\n+    }\n \n     /// Returns true if the map contains no elements.\n     ///\n@@ -1359,7 +1443,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n }\n \n macro_rules! range_impl {\n@@ -1518,12 +1604,20 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27787\")]\n-    pub fn range<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&self, min: Bound<&Min>,\n+    pub fn range<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&self,\n+                                                               min: Bound<&Min>,\n                                                                max: Bound<&Max>)\n-        -> Range<K, V> where\n-        K: Borrow<Min> + Borrow<Max>,\n+                                                               -> Range<K, V>\n+        where K: Borrow<Min> + Borrow<Max>\n     {\n-        range_impl!(&self.root, min, max, as_slices_internal, iter, Range, edges, [])\n+        range_impl!(&self.root,\n+                    min,\n+                    max,\n+                    as_slices_internal,\n+                    iter,\n+                    Range,\n+                    edges,\n+                    [])\n     }\n \n     /// Constructs a mutable double-ended iterator over a sub-range of elements in the map, starting\n@@ -1552,13 +1646,20 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27787\")]\n-    pub fn range_mut<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&mut self, min: Bound<&Min>,\n+    pub fn range_mut<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&mut self,\n+                                                                   min: Bound<&Min>,\n                                                                    max: Bound<&Max>)\n-        -> RangeMut<K, V> where\n-        K: Borrow<Min> + Borrow<Max>,\n+                                                                   -> RangeMut<K, V>\n+        where K: Borrow<Min> + Borrow<Max>\n     {\n-        range_impl!(&mut self.root, min, max, as_slices_internal_mut, iter_mut, RangeMut,\n-                                                                      edges_mut, [mut])\n+        range_impl!(&mut self.root,\n+                    min,\n+                    max,\n+                    as_slices_internal_mut,\n+                    iter_mut,\n+                    RangeMut,\n+                    edges_mut,\n+                    [mut])\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n@@ -1586,23 +1687,18 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 match Node::search(node, &key) {\n                     Found(handle) => {\n                         // Perfect match\n-                        Finished(Occupied(OccupiedEntry {\n-                            stack: pusher.seal(handle)\n-                        }))\n-                    },\n+                        Finished(Occupied(OccupiedEntry { stack: pusher.seal(handle) }))\n+                    }\n                     GoDown(handle) => {\n                         match handle.force() {\n                             Leaf(leaf_handle) => {\n                                 Finished(Vacant(VacantEntry {\n                                     stack: pusher.seal(leaf_handle),\n                                     key: key,\n                                 }))\n-                            },\n+                            }\n                             Internal(internal_handle) => {\n-                                Continue((\n-                                    pusher.push(internal_handle),\n-                                    key\n-                                ))\n+                                Continue((pusher.push(internal_handle), key))\n                             }\n                         }\n                     }\n@@ -1619,19 +1715,24 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()> where K: Borrow<Q> + Ord, Q: Ord {\n+impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n+    where K: Borrow<Q> + Ord,\n+          Q: Ord\n+{\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n         let mut cur_node = &self.root;\n         loop {\n             match Node::search(cur_node, key) {\n                 Found(handle) => return Some(handle.into_kv().0),\n-                GoDown(handle) => match handle.force() {\n-                    Leaf(_) => return None,\n-                    Internal(internal_handle) => {\n-                        cur_node = internal_handle.into_edge();\n-                        continue;\n+                GoDown(handle) => {\n+                    match handle.force() {\n+                        Leaf(_) => return None,\n+                        Internal(internal_handle) => {\n+                            cur_node = internal_handle.into_edge();\n+                            continue;\n+                        }\n                     }\n                 }\n             }\n@@ -1648,20 +1749,20 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()> where K: Borrow<Q> + Or\n                     Found(handle) => {\n                         // Perfect match. Terminate the stack here, and remove the entry\n                         Finished(Some(pusher.seal(handle).remove()))\n-                    },\n+                    }\n                     GoDown(handle) => {\n                         // We need to keep searching, try to go down the next edge\n                         match handle.force() {\n                             // We're at a leaf; the key isn't in here\n                             Leaf(_) => Finished(None),\n-                            Internal(internal_handle) => Continue(pusher.push(internal_handle))\n+                            Internal(internal_handle) => Continue(pusher.push(internal_handle)),\n                         }\n                     }\n                 }\n             });\n             match result {\n                 Finished(ret) => return ret.map(|(k, _)| k),\n-                Continue(new_stack) => stack = new_stack\n+                Continue(new_stack) => stack = new_stack,\n             }\n         }\n     }\n@@ -1677,7 +1778,7 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()> where K: Borrow<Q> + Or\n                     Found(mut handle) => {\n                         mem::swap(handle.key_mut(), &mut key);\n                         Finished(Some(key))\n-                    },\n+                    }\n                     GoDown(handle) => {\n                         match handle.force() {\n                             Leaf(leaf_handle) => {"}, {"sha": "26479b3f559b94a9f94733c0edeb36fb0734b279", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 165, "deletions": 168, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -122,7 +122,8 @@ fn test_rounding() {\n // from the start of a mallocated array.\n #[inline]\n fn calculate_offsets(keys_size: usize,\n-                     vals_size: usize, vals_align: usize,\n+                     vals_size: usize,\n+                     vals_align: usize,\n                      edges_align: usize)\n                      -> (usize, usize) {\n     let vals_offset = round_up_to_next(keys_size, vals_align);\n@@ -136,13 +137,14 @@ fn calculate_offsets(keys_size: usize,\n // Returns a tuple of (minimum required alignment, array_size),\n // from the start of a mallocated array.\n #[inline]\n-fn calculate_allocation(keys_size: usize, keys_align: usize,\n-                        vals_size: usize, vals_align: usize,\n-                        edges_size: usize, edges_align: usize)\n+fn calculate_allocation(keys_size: usize,\n+                        keys_align: usize,\n+                        vals_size: usize,\n+                        vals_align: usize,\n+                        edges_size: usize,\n+                        edges_align: usize)\n                         -> (usize, usize) {\n-    let (_, edges_offset) = calculate_offsets(keys_size,\n-                                              vals_size, vals_align,\n-                                                         edges_align);\n+    let (_, edges_offset) = calculate_offsets(keys_size, vals_size, vals_align, edges_align);\n     let end_of_edges = edges_offset + edges_size;\n \n     let min_align = cmp::max(keys_align, cmp::max(vals_align, edges_align));\n@@ -171,14 +173,16 @@ fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize,\n             (0, 1)\n         }\n     } else {\n-        ((capacity + 1) * mem::size_of::<Node<K, V>>(), mem::align_of::<Node<K, V>>())\n+        ((capacity + 1) * mem::size_of::<Node<K, V>>(),\n+         mem::align_of::<Node<K, V>>())\n     };\n \n-    calculate_allocation(\n-            keys_size, keys_align,\n-            vals_size, vals_align,\n-            edges_size, edges_align\n-    )\n+    calculate_allocation(keys_size,\n+                         keys_align,\n+                         vals_size,\n+                         vals_align,\n+                         edges_size,\n+                         edges_align)\n }\n \n fn calculate_offsets_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n@@ -191,11 +195,7 @@ fn calculate_offsets_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, us\n         mem::align_of::<Node<K, V>>()\n     };\n \n-    calculate_offsets(\n-            keys_size,\n-            vals_size, vals_align,\n-                       edges_align\n-    )\n+    calculate_offsets(keys_size, vals_size, vals_align, edges_align)\n }\n \n /// An iterator over a slice that owns the elements of the slice but not the allocation.\n@@ -285,8 +285,7 @@ impl<K, V> Drop for Node<K, V> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         if self.keys.is_null() ||\n-            (unsafe { self.keys.get() as *const K as usize == mem::POST_DROP_USIZE })\n-        {\n+           (unsafe { self.keys.get() as *const K as usize == mem::POST_DROP_USIZE }) {\n             // Since we have #[unsafe_no_drop_flag], we have to watch\n             // out for the sentinel value being stored in self.keys. (Using\n             // null is technically a violation of the `Unique`\n@@ -314,7 +313,9 @@ impl<K, V> Node<K, V> {\n         let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, false);\n \n         let buffer = heap::allocate(size, alignment);\n-        if buffer.is_null() { ::alloc::oom(); }\n+        if buffer.is_null() {\n+            ::alloc::oom();\n+        }\n \n         let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n \n@@ -332,7 +333,9 @@ impl<K, V> Node<K, V> {\n         let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, true);\n \n         let buffer = unsafe { heap::allocate(size, alignment) };\n-        if buffer.is_null() { ::alloc::oom(); }\n+        if buffer.is_null() {\n+            ::alloc::oom();\n+        }\n \n         let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n \n@@ -346,25 +349,25 @@ impl<K, V> Node<K, V> {\n     }\n \n     unsafe fn destroy(&mut self) {\n-        let (alignment, size) =\n-                calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n+        let (alignment, size) = calculate_allocation_generic::<K, V>(self.capacity(),\n+                                                                     self.is_leaf());\n         heap::deallocate(*self.keys as *mut u8, size, alignment);\n     }\n \n     #[inline]\n     pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n-        unsafe {(\n-            slice::from_raw_parts(*self.keys, self.len()),\n-            slice::from_raw_parts(*self.vals, self.len()),\n-        )}\n+        unsafe {\n+            (slice::from_raw_parts(*self.keys, self.len()),\n+             slice::from_raw_parts(*self.vals, self.len()))\n+        }\n     }\n \n     #[inline]\n     pub fn as_slices_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V]) {\n-        unsafe {(\n-            slice::from_raw_parts_mut(*self.keys, self.len()),\n-            slice::from_raw_parts_mut(*self.vals, self.len()),\n-        )}\n+        unsafe {\n+            (slice::from_raw_parts_mut(*self.keys, self.len()),\n+             slice::from_raw_parts_mut(*self.vals, self.len()))\n+        }\n     }\n \n     #[inline]\n@@ -376,8 +379,8 @@ impl<K, V> Node<K, V> {\n         } else {\n             unsafe {\n                 let data = match self.edges {\n-                    None => heap::EMPTY as *const Node<K,V>,\n-                    Some(ref p) => **p as *const Node<K,V>,\n+                    None => heap::EMPTY as *const Node<K, V>,\n+                    Some(ref p) => **p as *const Node<K, V>,\n                 };\n                 slice::from_raw_parts(data, self.len() + 1)\n             }\n@@ -403,8 +406,8 @@ impl<K, V> Node<K, V> {\n         } else {\n             unsafe {\n                 let data = match self.edges {\n-                    None => heap::EMPTY as *mut Node<K,V>,\n-                    Some(ref mut p) => **p as *mut Node<K,V>,\n+                    None => heap::EMPTY as *mut Node<K, V>,\n+                    Some(ref mut p) => **p as *mut Node<K, V>,\n                 };\n                 slice::from_raw_parts_mut(data, len + 1)\n             }\n@@ -573,29 +576,49 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Q: ?Sized, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n-                  -> SearchResult<NodeRef> where K: Borrow<Q>, Q: Ord {\n+    pub fn search<Q: ?Sized, NodeRef: Deref<Target = Node<K, V>>>(node: NodeRef,\n+                                                                  key: &Q)\n+                                                                  -> SearchResult<NodeRef>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for usizes.\n         match node.as_slices_internal().search_linear(key) {\n-            (index, true) => Found(Handle { node: node, index: index, marker: PhantomData }),\n-            (index, false) => GoDown(Handle { node: node, index: index, marker: PhantomData }),\n+            (index, true) => {\n+                Found(Handle {\n+                    node: node,\n+                    index: index,\n+                    marker: PhantomData,\n+                })\n+            }\n+            (index, false) => {\n+                GoDown(Handle {\n+                    node: node,\n+                    index: index,\n+                    marker: PhantomData,\n+                })\n+            }\n         }\n     }\n }\n \n // Public interface\n-impl <K, V> Node<K, V> {\n+impl<K, V> Node<K, V> {\n     /// Make a leaf root from scratch\n     pub fn make_leaf_root(b: usize) -> Node<K, V> {\n         Node::new_leaf(capacity_from_b(b))\n     }\n \n     /// Make an internal root and swap it with an old root\n-    pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: usize, key: K, value: V,\n-            right: Node<K,V>) {\n-        let node = mem::replace(left_and_out, unsafe { Node::new_internal(capacity_from_b(b)) });\n+    pub fn make_internal_root(left_and_out: &mut Node<K, V>,\n+                              b: usize,\n+                              key: K,\n+                              value: V,\n+                              right: Node<K, V>) {\n+        let node = mem::replace(left_and_out,\n+                                unsafe { Node::new_internal(capacity_from_b(b)) });\n         left_and_out._len = 1;\n         unsafe {\n             ptr::write(left_and_out.keys_mut().get_unchecked_mut(0), key);\n@@ -611,7 +634,9 @@ impl <K, V> Node<K, V> {\n     }\n \n     /// Does the node not contain any key-value pairs\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// How many key-value pairs the node can fit\n     pub fn capacity(&self) -> usize {\n@@ -634,7 +659,7 @@ impl <K, V> Node<K, V> {\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+impl<K, V, NodeRef: Deref<Target = Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n     /// Returns a reference to the node that contains the pointed-to edge or key/value pair. This\n     /// is very different from `edge` and `edge_mut` because those return children of the node\n     /// returned by `node`.\n@@ -643,8 +668,8 @@ impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type, NodeType> Handle<NodeRef, Ty\n     }\n }\n \n-impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Converts a handle into one that stores the same information using a raw pointer. This can\n     /// be useful in conjunction with `from_raw` when the type system is insufficient for\n@@ -687,9 +712,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, handle::Edge, handle::Internal> {\n     /// returned pointer has a larger lifetime than what would be returned by `edge` or `edge_mut`,\n     /// making it more suitable for moving down a chain of nodes.\n     pub fn into_edge(self) -> &'a Node<K, V> {\n-        unsafe {\n-            self.node.edges().get_unchecked(self.index)\n-        }\n+        unsafe { self.node.edges().get_unchecked(self.index) }\n     }\n }\n \n@@ -698,13 +721,11 @@ impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal\n     /// because the returned pointer has a larger lifetime than what would be returned by\n     /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n     pub fn into_edge_mut(self) -> &'a mut Node<K, V> {\n-        unsafe {\n-            self.node.edges_mut().get_unchecked_mut(self.index)\n-        }\n+        unsafe { self.node.edges_mut().get_unchecked_mut(self.index) }\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Target=Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n+impl<K, V, NodeRef: Deref<Target = Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n     // This doesn't exist because there are no uses for it,\n     // but is fine to add, analogous to edge_mut.\n     //\n@@ -715,10 +736,12 @@ impl<K, V, NodeRef: Deref<Target=Node<K, V>>> Handle<NodeRef, handle::Edge, hand\n \n pub enum ForceResult<NodeRef, Type> {\n     Leaf(Handle<NodeRef, Type, handle::Leaf>),\n-    Internal(Handle<NodeRef, Type, handle::Internal>)\n+    Internal(Handle<NodeRef, Type, handle::Internal>),\n }\n \n-impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafOrInternal> {\n+impl<K, V, NodeRef: Deref<Target = Node<K, V>>, Type>\n+    Handle<NodeRef, Type, handle::LeafOrInternal>\n+{\n     /// Figure out whether this handle is pointing to something in a leaf node or to something in\n     /// an internal node, clarifying the type according to the result.\n     pub fn force(self) -> ForceResult<NodeRef, Type> {\n@@ -737,16 +760,15 @@ impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type> Handle<NodeRef, Type, handle\n         }\n     }\n }\n-impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Tries to insert this key-value pair at the given index in this leaf node\n     /// If the node is full, we have to split it.\n     ///\n     /// Returns a *mut V to the inserted value, because the caller may want this when\n     /// they're done mutating the tree, but we don't want to borrow anything for now.\n-    pub fn insert_as_leaf(mut self, key: K, value: V) ->\n-            (InsertionResult<K, V>, *mut V) {\n+    pub fn insert_as_leaf(mut self, key: K, value: V) -> (InsertionResult<K, V>, *mut V) {\n         if !self.node.is_full() {\n             // The element can fit, just insert it\n             (Fit, unsafe { self.node.insert_kv(self.index, key, value) as *mut _ })\n@@ -771,21 +793,22 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf> where\n     }\n }\n \n-impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n     /// confused with `node`, which references the parent node of what is returned here.\n     pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n-        unsafe {\n-            self.node.edges_mut().get_unchecked_mut(self.index)\n-        }\n+        unsafe { self.node.edges_mut().get_unchecked_mut(self.index) }\n     }\n \n     /// Tries to insert this key-value pair at the given index in this internal node\n     /// If the node is full, we have to split it.\n-    pub fn insert_as_internal(mut self, key: K, value: V, right: Node<K, V>)\n-            -> InsertionResult<K, V> {\n+    pub fn insert_as_internal(mut self,\n+                              key: K,\n+                              value: V,\n+                              right: Node<K, V>)\n+                              -> InsertionResult<K, V> {\n         if !self.node.is_full() {\n             // The element can fit, just insert it\n             unsafe {\n@@ -856,8 +879,8 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal> where\n     }\n }\n \n-impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n     /// This is unsafe because the handle might point to the first edge in the node, which has no\n@@ -889,10 +912,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, handle::KV, NodeType> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n         let (keys, vals) = self.node.as_slices();\n         unsafe {\n-            (\n-                keys.get_unchecked(self.index),\n-                vals.get_unchecked(self.index)\n-            )\n+            (keys.get_unchecked(self.index),\n+             vals.get_unchecked(self.index))\n         }\n     }\n }\n@@ -904,10 +925,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n     pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n         let (keys, vals) = self.node.as_slices_mut();\n         unsafe {\n-            (\n-                keys.get_unchecked_mut(self.index),\n-                vals.get_unchecked_mut(self.index)\n-            )\n+            (keys.get_unchecked_mut(self.index),\n+             vals.get_unchecked_mut(self.index))\n         }\n     }\n \n@@ -923,8 +942,10 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef: Deref<Target=Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n-                                                                         NodeType> {\n+\n+impl<'a, K: 'a, V: 'a, NodeRef: Deref<Target = Node<K, V>> + 'a, NodeType> Handle<NodeRef,\n+                                                                                  handle::KV,\n+                                                                                  NodeType> {\n     // These are fine to include, but are currently unneeded.\n     //\n     // /// Returns a reference to the key pointed-to by this handle. This doesn't return a\n@@ -942,8 +963,8 @@ impl<'a, K: 'a, V: 'a, NodeRef: Deref<Target=Node<K, V>> + 'a, NodeType> Handle<\n     // }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n-    NodeRef: 'a + Deref<Target=Node<K, V>> + DerefMut,\n+impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType>\n+    where NodeRef: 'a + Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Returns a mutable reference to the key pointed-to by this handle. This doesn't return a\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n@@ -960,8 +981,8 @@ impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType>\n     }\n }\n \n-impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Gets the handle pointing to the edge immediately to the left of the key/value pair pointed\n     /// to by this handle.\n@@ -984,8 +1005,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n     }\n }\n \n-impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Removes the key/value pair at the handle's location.\n     ///\n@@ -997,8 +1018,8 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf> where\n     }\n }\n \n-impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut\n+impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n@@ -1071,7 +1092,8 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal> where\n         let right = self.node.remove_edge(self.index + 1);\n \n         // Give left right's stuff.\n-        self.left_edge().edge_mut()\n+        self.left_edge()\n+            .edge_mut()\n             .absorb(key, val, right);\n     }\n }\n@@ -1082,8 +1104,9 @@ impl<K, V> Node<K, V> {\n     /// # Panics (in debug build)\n     ///\n     /// Panics if the given index is out of bounds.\n-    pub fn kv_handle(&mut self, index: usize) -> Handle<&mut Node<K, V>, handle::KV,\n-                                                       handle::LeafOrInternal> {\n+    pub fn kv_handle(&mut self,\n+                     index: usize)\n+                     -> Handle<&mut Node<K, V>, handle::KV, handle::LeafOrInternal> {\n         // Necessary for correctness, but in a private module\n         debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n         Handle {\n@@ -1111,7 +1134,7 @@ impl<K, V> Node<K, V> {\n \n                     ptr: Unique::new(*self.keys as *mut u8),\n                     capacity: self.capacity(),\n-                    is_leaf: self.is_leaf()\n+                    is_leaf: self.is_leaf(),\n                 },\n                 head_is_edge: true,\n                 tail_is_edge: true,\n@@ -1160,16 +1183,12 @@ impl<K, V> Node<K, V> {\n     // This must be followed by insert_edge on an internal node.\n     #[inline]\n     unsafe fn insert_kv(&mut self, index: usize, key: K, val: V) -> &mut V {\n-        ptr::copy(\n-            self.keys().as_ptr().offset(index as isize),\n-            self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n-            self.len() - index\n-        );\n-        ptr::copy(\n-            self.vals().as_ptr().offset(index as isize),\n-            self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n-            self.len() - index\n-        );\n+        ptr::copy(self.keys().as_ptr().offset(index as isize),\n+                  self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n+                  self.len() - index);\n+        ptr::copy(self.vals().as_ptr().offset(index as isize),\n+                  self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n+                  self.len() - index);\n \n         ptr::write(self.keys_mut().get_unchecked_mut(index), key);\n         ptr::write(self.vals_mut().get_unchecked_mut(index), val);\n@@ -1182,11 +1201,9 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to insert_kv.\n     #[inline]\n     unsafe fn insert_edge(&mut self, index: usize, edge: Node<K, V>) {\n-        ptr::copy(\n-            self.edges().as_ptr().offset(index as isize),\n-            self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n-            self.len() - index\n-        );\n+        ptr::copy(self.edges().as_ptr().offset(index as isize),\n+                  self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n+                  self.len() - index);\n         ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n     }\n \n@@ -1215,16 +1232,12 @@ impl<K, V> Node<K, V> {\n         let key = ptr::read(self.keys().get_unchecked(index));\n         let val = ptr::read(self.vals().get_unchecked(index));\n \n-        ptr::copy(\n-            self.keys().as_ptr().offset(index as isize + 1),\n-            self.keys_mut().as_mut_ptr().offset(index as isize),\n-            self.len() - index - 1\n-        );\n-        ptr::copy(\n-            self.vals().as_ptr().offset(index as isize + 1),\n-            self.vals_mut().as_mut_ptr().offset(index as isize),\n-            self.len() - index - 1\n-        );\n+        ptr::copy(self.keys().as_ptr().offset(index as isize + 1),\n+                  self.keys_mut().as_mut_ptr().offset(index as isize),\n+                  self.len() - index - 1);\n+        ptr::copy(self.vals().as_ptr().offset(index as isize + 1),\n+                  self.vals_mut().as_mut_ptr().offset(index as isize),\n+                  self.len() - index - 1);\n \n         self._len -= 1;\n \n@@ -1236,12 +1249,10 @@ impl<K, V> Node<K, V> {\n     unsafe fn remove_edge(&mut self, index: usize) -> Node<K, V> {\n         let edge = ptr::read(self.edges().get_unchecked(index));\n \n-        ptr::copy(\n-            self.edges().as_ptr().offset(index as isize + 1),\n-            self.edges_mut().as_mut_ptr().offset(index as isize),\n-            // index can be == len+1, so do the +1 first to avoid underflow.\n-            (self.len() + 1) - index\n-        );\n+        ptr::copy(self.edges().as_ptr().offset(index as isize + 1),\n+                  self.edges_mut().as_mut_ptr().offset(index as isize),\n+                  // index can be == len+1, so do the +1 first to avoid underflow.\n+                  (self.len() + 1) - index);\n \n         edge\n     }\n@@ -1264,22 +1275,16 @@ impl<K, V> Node<K, V> {\n         unsafe {\n             right._len = self.len() / 2;\n             let right_offset = self.len() - right.len();\n-            ptr::copy_nonoverlapping(\n-                self.keys().as_ptr().offset(right_offset as isize),\n-                right.keys_mut().as_mut_ptr(),\n-                right.len()\n-            );\n-            ptr::copy_nonoverlapping(\n-                self.vals().as_ptr().offset(right_offset as isize),\n-                right.vals_mut().as_mut_ptr(),\n-                right.len()\n-            );\n+            ptr::copy_nonoverlapping(self.keys().as_ptr().offset(right_offset as isize),\n+                                     right.keys_mut().as_mut_ptr(),\n+                                     right.len());\n+            ptr::copy_nonoverlapping(self.vals().as_ptr().offset(right_offset as isize),\n+                                     right.vals_mut().as_mut_ptr(),\n+                                     right.len());\n             if !self.is_leaf() {\n-                ptr::copy_nonoverlapping(\n-                    self.edges().as_ptr().offset(right_offset as isize),\n-                    right.edges_mut().as_mut_ptr(),\n-                    right.len() + 1\n-                );\n+                ptr::copy_nonoverlapping(self.edges().as_ptr().offset(right_offset as isize),\n+                                         right.edges_mut().as_mut_ptr(),\n+                                         right.len() + 1);\n             }\n \n             let key = ptr::read(self.keys().get_unchecked(right_offset - 1));\n@@ -1305,22 +1310,18 @@ impl<K, V> Node<K, V> {\n             ptr::write(self.keys_mut().get_unchecked_mut(old_len), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n-            ptr::copy_nonoverlapping(\n-                right.keys().as_ptr(),\n-                self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n-                right.len()\n-            );\n-            ptr::copy_nonoverlapping(\n-                right.vals().as_ptr(),\n-                self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n-                right.len()\n-            );\n+            ptr::copy_nonoverlapping(right.keys().as_ptr(),\n+                                     self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n+                                     right.len());\n+            ptr::copy_nonoverlapping(right.vals().as_ptr(),\n+                                     self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n+                                     right.len());\n             if !self.is_leaf() {\n-                ptr::copy_nonoverlapping(\n-                    right.edges().as_ptr(),\n-                    self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n-                    right.len() + 1\n-                );\n+                ptr::copy_nonoverlapping(right.edges().as_ptr(),\n+                                         self.edges_mut()\n+                                             .as_mut_ptr()\n+                                             .offset(old_len as isize + 1),\n+                                         right.len() + 1);\n             }\n \n             right.destroy();\n@@ -1382,7 +1383,7 @@ struct MoveTraversalImpl<K, V> {\n     // For deallocation when we are done iterating.\n     ptr: Unique<u8>,\n     capacity: usize,\n-    is_leaf: bool\n+    is_leaf: bool,\n }\n \n unsafe impl<K: Sync, V: Sync> Sync for MoveTraversalImpl<K, V> {}\n@@ -1395,14 +1396,14 @@ impl<K, V> TraversalImpl for MoveTraversalImpl<K, V> {\n     fn next_kv(&mut self) -> Option<(K, V)> {\n         match (self.keys.next(), self.vals.next()) {\n             (Some(k), Some(v)) => Some((k, v)),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n     fn next_kv_back(&mut self) -> Option<(K, V)> {\n         match (self.keys.next_back(), self.vals.next_back()) {\n             (Some(k), Some(v)) => Some((k, v)),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n@@ -1428,8 +1429,7 @@ impl<K, V> Drop for MoveTraversalImpl<K, V> {\n         for _ in self.vals.by_ref() {}\n         for _ in self.edges.by_ref() {}\n \n-        let (alignment, size) =\n-                calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);\n+        let (alignment, size) = calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);\n         unsafe { heap::deallocate(*self.ptr, size, alignment) };\n     }\n }\n@@ -1467,27 +1467,24 @@ pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;\n \n \n impl<K, V, E, Impl> Iterator for AbsTraversal<Impl>\n-        where Impl: TraversalImpl<Item=(K, V), Edge=E> {\n+    where Impl: TraversalImpl<Item = (K, V), Edge = E>\n+{\n     type Item = TraversalItem<K, V, E>;\n \n     fn next(&mut self) -> Option<TraversalItem<K, V, E>> {\n-        self.next_edge_item().map(Edge).or_else(||\n-            self.next_kv_item().map(Elem)\n-        )\n+        self.next_edge_item().map(Edge).or_else(|| self.next_kv_item().map(Elem))\n     }\n }\n \n impl<K, V, E, Impl> DoubleEndedIterator for AbsTraversal<Impl>\n-        where Impl: TraversalImpl<Item=(K, V), Edge=E> {\n+    where Impl: TraversalImpl<Item = (K, V), Edge = E>\n+{\n     fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n-        self.next_edge_item_back().map(Edge).or_else(||\n-            self.next_kv_item_back().map(Elem)\n-        )\n+        self.next_edge_item_back().map(Edge).or_else(|| self.next_kv_item_back().map(Elem))\n     }\n }\n \n-impl<K, V, E, Impl> AbsTraversal<Impl>\n-        where Impl: TraversalImpl<Item=(K, V), Edge=E> {\n+impl<K, V, E, Impl> AbsTraversal<Impl> where Impl: TraversalImpl<Item = (K, V), Edge = E> {\n     /// Advances the iterator and returns the item if it's an edge. Returns None\n     /// and does nothing if the first item is not an edge.\n     pub fn next_edge_item(&mut self) -> Option<E> {"}, {"sha": "6f3fadb7f0c99c11c5ebf951bc85cb88b38f04d8", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 143, "deletions": 61, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -34,51 +34,51 @@ use Bound;\n /// normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n #[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BTreeSet<T>{\n+pub struct BTreeSet<T> {\n     map: BTreeMap<T, ()>,\n }\n \n /// An iterator over a BTreeSet's items.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    iter: Keys<'a, T, ()>\n+    iter: Keys<'a, T, ()>,\n }\n \n /// An owning iterator over a BTreeSet's items.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    iter: Map<::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n+    iter: Map<::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>,\n }\n \n /// An iterator over a sub-range of BTreeSet's items.\n pub struct Range<'a, T: 'a> {\n-    iter: Map<::btree_map::Range<'a, T, ()>, fn((&'a T, &'a ())) -> &'a T>\n+    iter: Map<::btree_map::Range<'a, T, ()>, fn((&'a T, &'a ())) -> &'a T>,\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Difference<'a, T:'a> {\n+pub struct Difference<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a, T:'a> {\n+pub struct SymmetricDifference<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Intersection<'a, T:'a> {\n+pub struct Intersection<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a, T:'a> {\n+pub struct Union<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n@@ -161,12 +161,15 @@ impl<T: Ord> BTreeSet<T> {\n     #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27787\")]\n-    pub fn range<'a, Min: ?Sized + Ord = T, Max: ?Sized + Ord = T>(&'a self, min: Bound<&Min>,\n+    pub fn range<'a, Min: ?Sized + Ord = T, Max: ?Sized + Ord = T>(&'a self,\n+                                                                   min: Bound<&Min>,\n                                                                    max: Bound<&Max>)\n-        -> Range<'a, T> where\n-        T: Borrow<Min> + Borrow<Max>,\n+                                                                   -> Range<'a, T>\n+        where T: Borrow<Min> + Borrow<Max>\n     {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        fn first<A, B>((a, _): (A, B)) -> A {\n+            a\n+        }\n         let first: fn((&'a T, &'a ())) -> &'a T = first; // coerce to fn pointer\n \n         Range { iter: self.map.range(min, max).map(first) }\n@@ -194,7 +197,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n-        Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n+        Difference {\n+            a: self.iter().peekable(),\n+            b: other.iter().peekable(),\n+        }\n     }\n \n     /// Visits the values representing the symmetric difference, in ascending order.\n@@ -216,9 +222,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(sym_diff, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> SymmetricDifference<'a, T> {\n-        SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn symmetric_difference<'a>(&'a self,\n+                                    other: &'a BTreeSet<T>)\n+                                    -> SymmetricDifference<'a, T> {\n+        SymmetricDifference {\n+            a: self.iter().peekable(),\n+            b: other.iter().peekable(),\n+        }\n     }\n \n     /// Visits the values representing the intersection, in ascending order.\n@@ -240,9 +250,11 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(intersection, [2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> Intersection<'a, T> {\n-        Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n+        Intersection {\n+            a: self.iter().peekable(),\n+            b: other.iter().peekable(),\n+        }\n     }\n \n     /// Visits the values representing the union, in ascending order.\n@@ -263,7 +275,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n-        Union{a: self.iter().peekable(), b: other.iter().peekable()}\n+        Union {\n+            a: self.iter().peekable(),\n+            b: other.iter().peekable(),\n+        }\n     }\n \n     /// Returns the number of elements in the set.\n@@ -279,7 +294,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.map.len() }\n+    pub fn len(&self) -> usize {\n+        self.map.len()\n+    }\n \n     /// Returns true if the set contains no elements.\n     ///\n@@ -294,7 +311,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Clears the set, removing all values.\n     ///\n@@ -329,7 +348,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where T: Borrow<Q>, Q: Ord {\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n+        where T: Borrow<Q>,\n+              Q: Ord\n+    {\n         self.map.contains_key(value)\n     }\n \n@@ -339,7 +361,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// but the ordering on the borrowed form *must* match the\n     /// ordering on the value type.\n     #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n-    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T> where T: Borrow<Q>, Q: Ord {\n+    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n+        where T: Borrow<Q>,\n+              Q: Ord\n+    {\n         Recover::get(&self.map, value)\n     }\n \n@@ -482,7 +507,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where T: Borrow<Q>, Q: Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n+        where T: Borrow<Q>,\n+              Q: Ord\n+    {\n         self.map.remove(value).is_some()\n     }\n \n@@ -492,14 +520,17 @@ impl<T: Ord> BTreeSet<T> {\n     /// but the ordering on the borrowed form *must* match the\n     /// ordering on the value type.\n     #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n-    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T> where T: Borrow<Q>, Q: Ord {\n+    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n+        where T: Borrow<Q>,\n+              Q: Ord\n+    {\n         Recover::take(&mut self.map, value)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> BTreeSet<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n         set.extend(iter);\n         set\n@@ -524,7 +555,9 @@ impl<T> IntoIterator for BTreeSet<T> {\n     /// assert_eq!(v, [1, 2, 3, 4]);\n     /// ```\n     fn into_iter(self) -> IntoIter<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        fn first<A, B>((a, _): (A, B)) -> A {\n+            a\n+        }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n \n         IntoIter { iter: self.map.into_iter().map(first) }\n@@ -544,7 +577,7 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n-    fn extend<Iter: IntoIterator<Item=T>>(&mut self, iter: Iter) {\n+    fn extend<Iter: IntoIterator<Item = T>>(&mut self, iter: Iter) {\n         for elem in iter {\n             self.insert(elem);\n         }\n@@ -553,7 +586,7 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n@@ -665,18 +698,26 @@ impl<T: Debug> Debug for BTreeSet<T> {\n }\n \n impl<'a, T> Clone for Iter<'a, T> {\n-    fn clone(&self) -> Iter<'a, T> { Iter { iter: self.iter.clone() } }\n+    fn clone(&self) -> Iter<'a, T> {\n+        Iter { iter: self.iter.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n-    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        self.iter.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n@@ -686,42 +727,56 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n-    fn next(&mut self) -> Option<T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n \n impl<'a, T> Clone for Range<'a, T> {\n-    fn clone(&self) -> Range<'a, T> { Range { iter: self.iter.clone() } }\n+    fn clone(&self) -> Range<'a, T> {\n+        Range { iter: self.iter.clone() }\n+    }\n }\n impl<'a, T> Iterator for Range<'a, T> {\n     type Item = &'a T;\n \n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n }\n impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n-    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        self.iter.next_back()\n+    }\n }\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n-                        short: Ordering, long: Ordering) -> Ordering {\n+fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n     match (x, y) {\n-        (None    , _       ) => short,\n-        (_       , None    ) => long,\n+        (None, _) => short,\n+        (_, None) => long,\n         (Some(x1), Some(y1)) => x1.cmp(y1),\n     }\n }\n \n impl<'a, T> Clone for Difference<'a, T> {\n     fn clone(&self) -> Difference<'a, T> {\n-        Difference { a: self.a.clone(), b: self.b.clone() }\n+        Difference {\n+            a: self.a.clone(),\n+            b: self.b.clone(),\n+        }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -731,17 +786,25 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n-                Greater => { self.b.next(); }\n+                Less => return self.a.next(),\n+                Equal => {\n+                    self.a.next();\n+                    self.b.next();\n+                }\n+                Greater => {\n+                    self.b.next();\n+                }\n             }\n         }\n     }\n }\n \n impl<'a, T> Clone for SymmetricDifference<'a, T> {\n     fn clone(&self) -> SymmetricDifference<'a, T> {\n-        SymmetricDifference { a: self.a.clone(), b: self.b.clone() }\n+        SymmetricDifference {\n+            a: self.a.clone(),\n+            b: self.b.clone(),\n+        }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -751,8 +814,11 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n+                Less => return self.a.next(),\n+                Equal => {\n+                    self.a.next();\n+                    self.b.next();\n+                }\n                 Greater => return self.b.next(),\n             }\n         }\n@@ -761,7 +827,10 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n \n impl<'a, T> Clone for Intersection<'a, T> {\n     fn clone(&self) -> Intersection<'a, T> {\n-        Intersection { a: self.a.clone(), b: self.b.clone() }\n+        Intersection {\n+            a: self.a.clone(),\n+            b: self.b.clone(),\n+        }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -771,23 +840,33 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n-                (None    , _       ) => None,\n-                (_       , None    ) => None,\n+                (None, _) => None,\n+                (_, None) => None,\n                 (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n             };\n             match o_cmp {\n-                None          => return None,\n-                Some(Less)    => { self.a.next(); }\n-                Some(Equal)   => { self.b.next(); return self.a.next() }\n-                Some(Greater) => { self.b.next(); }\n+                None => return None,\n+                Some(Less) => {\n+                    self.a.next();\n+                }\n+                Some(Equal) => {\n+                    self.b.next();\n+                    return self.a.next();\n+                }\n+                Some(Greater) => {\n+                    self.b.next();\n+                }\n             }\n         }\n     }\n }\n \n impl<'a, T> Clone for Union<'a, T> {\n     fn clone(&self) -> Union<'a, T> {\n-        Union { a: self.a.clone(), b: self.b.clone() }\n+        Union {\n+            a: self.a.clone(),\n+            b: self.b.clone(),\n+        }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -797,8 +876,11 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.b.next(); return self.a.next() }\n+                Less => return self.a.next(),\n+                Equal => {\n+                    self.b.next();\n+                    return self.a.next();\n+                }\n                 Greater => return self.b.next(),\n             }\n         }"}, {"sha": "717c1d13af4bd1152c66d036833af68c8a8b346c", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -20,7 +20,7 @@\n \n use core::marker;\n use core::fmt;\n-use core::iter::{FromIterator};\n+use core::iter::FromIterator;\n use core::ops::{Sub, BitOr, BitAnd, BitXor};\n \n // FIXME(contentions): implement union family of methods? (general design may be\n@@ -43,11 +43,13 @@ pub struct EnumSet<E> {\n impl<E> Copy for EnumSet<E> {}\n \n impl<E> Clone for EnumSet<E> {\n-    fn clone(&self) -> EnumSet<E> { *self }\n+    fn clone(&self) -> EnumSet<E> {\n+        *self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n+impl<E: CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt.debug_set().entries(self).finish()\n     }\n@@ -79,18 +81,22 @@ pub trait CLike {\n     fn from_usize(usize) -> Self;\n }\n \n-fn bit<E:CLike>(e: &E) -> usize {\n+fn bit<E: CLike>(e: &E) -> usize {\n     use core::usize;\n     let value = e.to_usize();\n     assert!(value < usize::BITS,\n-            \"EnumSet only supports up to {} variants.\", usize::BITS - 1);\n+            \"EnumSet only supports up to {} variants.\",\n+            usize::BITS - 1);\n     1 << value\n }\n \n-impl<E:CLike> EnumSet<E> {\n+impl<E: CLike> EnumSet<E> {\n     /// Returns an empty `EnumSet`.\n     pub fn new() -> EnumSet<E> {\n-        EnumSet {bits: 0, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: 0,\n+            marker: marker::PhantomData,\n+        }\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n@@ -124,14 +130,18 @@ impl<E:CLike> EnumSet<E> {\n \n     /// Returns the union of both `EnumSets`.\n     pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits,\n-                 marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits | e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n \n     /// Returns the intersection of both `EnumSets`.\n     pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits,\n-                 marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits & e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n@@ -159,35 +169,47 @@ impl<E:CLike> EnumSet<E> {\n     }\n }\n \n-impl<E:CLike> Sub for EnumSet<E> {\n+impl<E: CLike> Sub for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & !e.bits, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits & !e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n-impl<E:CLike> BitOr for EnumSet<E> {\n+impl<E: CLike> BitOr for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits | e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n-impl<E:CLike> BitAnd for EnumSet<E> {\n+impl<E: CLike> BitAnd for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits & e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n-impl<E:CLike> BitXor for EnumSet<E> {\n+impl<E: CLike> BitXor for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits ^ e.bits, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits ^ e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n@@ -209,13 +231,17 @@ impl<E> Clone for Iter<E> {\n     }\n }\n \n-impl<E:CLike> Iter<E> {\n+impl<E: CLike> Iter<E> {\n     fn new(bits: usize) -> Iter<E> {\n-        Iter { index: 0, bits: bits, marker: marker::PhantomData }\n+        Iter {\n+            index: 0,\n+            bits: bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n-impl<E:CLike> Iterator for Iter<E> {\n+impl<E: CLike> Iterator for Iter<E> {\n     type Item = E;\n \n     fn next(&mut self) -> Option<E> {\n@@ -239,16 +265,17 @@ impl<E:CLike> Iterator for Iter<E> {\n     }\n }\n \n-impl<E:CLike> FromIterator<E> for EnumSet<E> {\n-    fn from_iter<I: IntoIterator<Item=E>>(iter: I) -> EnumSet<E> {\n+impl<E: CLike> FromIterator<E> for EnumSet<E> {\n+    fn from_iter<I: IntoIterator<Item = E>>(iter: I) -> EnumSet<E> {\n         let mut ret = EnumSet::new();\n         ret.extend(iter);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n+impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike\n+{\n     type Item = E;\n     type IntoIter = Iter<E>;\n \n@@ -257,8 +284,8 @@ impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n     }\n }\n \n-impl<E:CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item=E>>(&mut self, iter: I) {\n+impl<E: CLike> Extend<E> for EnumSet<E> {\n+    fn extend<I: IntoIterator<Item = E>>(&mut self, iter: I) {\n         for element in iter {\n             self.insert(element);\n         }\n@@ -267,7 +294,7 @@ impl<E:CLike> Extend<E> for EnumSet<E> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, E: 'a + CLike + Copy> Extend<&'a E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item=&'a E>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a E>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }"}, {"sha": "39370768ce5697347973790940b9748c9ee20286", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -74,8 +74,11 @@\n extern crate rustc_unicode;\n extern crate alloc;\n \n-#[cfg(test)] #[macro_use] extern crate std;\n-#[cfg(test)] extern crate test;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate std;\n+#[cfg(test)]\n+extern crate test;\n \n pub use binary_heap::BinaryHeap;\n pub use btree_map::BTreeMap;"}, {"sha": "631857f8e3c56e472d7cf6e706f04ad9631c4a45", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 75, "deletions": 54, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -44,8 +44,8 @@ struct Rawlink<T> {\n }\n \n impl<T> Copy for Rawlink<T> {}\n-unsafe impl<T:Send> Send for Rawlink<T> {}\n-unsafe impl<T:Sync> Sync for Rawlink<T> {}\n+unsafe impl<T: Send> Send for Rawlink<T> {}\n+unsafe impl<T: Sync> Sync for Rawlink<T> {}\n \n struct Node<T> {\n     next: Link<T>,\n@@ -55,7 +55,7 @@ struct Node<T> {\n \n /// An iterator over references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, T:'a> {\n+pub struct Iter<'a, T: 'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: usize,\n@@ -75,7 +75,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n \n /// An iterator over mutable references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, T:'a> {\n+pub struct IterMut<'a, T: 'a> {\n     list: &'a mut LinkedList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n@@ -86,19 +86,19 @@ pub struct IterMut<'a, T:'a> {\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    list: LinkedList<T>\n+    list: LinkedList<T>,\n }\n \n /// Rawlink is a type like Option<T> but for holding a raw pointer\n impl<T> Rawlink<T> {\n     /// Like Option::None for Rawlink\n     fn none() -> Rawlink<T> {\n-        Rawlink{p: ptr::null_mut()}\n+        Rawlink { p: ptr::null_mut() }\n     }\n \n     /// Like Option::Some for Rawlink\n     fn some(n: &mut T) -> Rawlink<T> {\n-        Rawlink{p: n}\n+        Rawlink { p: n }\n     }\n \n     /// Convert the `Rawlink` into an Option value\n@@ -139,13 +139,17 @@ impl<'a, T> From<&'a mut Link<T>> for Rawlink<Node<T>> {\n impl<T> Clone for Rawlink<T> {\n     #[inline]\n     fn clone(&self) -> Rawlink<T> {\n-        Rawlink{p: self.p}\n+        Rawlink { p: self.p }\n     }\n }\n \n impl<T> Node<T> {\n     fn new(v: T) -> Node<T> {\n-        Node{value: v, next: None, prev: Rawlink::none()}\n+        Node {\n+            value: v,\n+            next: None,\n+            prev: Rawlink::none(),\n+        }\n     }\n \n     /// Update the `prev` link on `next`, then set self's next pointer.\n@@ -192,7 +196,7 @@ impl<T> LinkedList<T> {\n             self.length -= 1;\n             match front_node.next.take() {\n                 Some(node) => self.list_head = link_no_prev(node),\n-                None => self.list_tail = Rawlink::none()\n+                None => self.list_tail = Rawlink::none(),\n             }\n             front_node\n         })\n@@ -220,7 +224,7 @@ impl<T> LinkedList<T> {\n                 self.list_tail = tail.prev;\n                 match tail.prev.resolve_mut() {\n                     None => self.list_head.take(),\n-                    Some(tail_prev) => tail_prev.next.take()\n+                    Some(tail_prev) => tail_prev.next.take(),\n                 }\n             })\n         }\n@@ -230,15 +234,21 @@ impl<T> LinkedList<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for LinkedList<T> {\n     #[inline]\n-    fn default() -> LinkedList<T> { LinkedList::new() }\n+    fn default() -> LinkedList<T> {\n+        LinkedList::new()\n+    }\n }\n \n impl<T> LinkedList<T> {\n     /// Creates an empty `LinkedList`.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> LinkedList<T> {\n-        LinkedList{list_head: None, list_tail: Rawlink::none(), length: 0}\n+        LinkedList {\n+            list_head: None,\n+            list_tail: Rawlink::none(),\n+            length: 0,\n+        }\n     }\n \n     /// Moves all elements from `other` to the end of the list.\n@@ -274,7 +284,7 @@ impl<T> LinkedList<T> {\n                 self.length = other.length;\n                 self.list_head = other.list_head.take();\n                 self.list_tail = other.list_tail.take();\n-            },\n+            }\n             Some(tail) => {\n                 // Carefully empty `other`.\n                 let o_tail = other.list_tail.take();\n@@ -296,7 +306,11 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n-        Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n+        Iter {\n+            nelem: self.len(),\n+            head: &self.list_head,\n+            tail: self.list_tail,\n+        }\n     }\n \n     /// Provides a forward iterator with mutable references.\n@@ -307,7 +321,7 @@ impl<T> LinkedList<T> {\n             nelem: self.len(),\n             head: Rawlink::from(&mut self.list_head),\n             tail: self.list_tail,\n-            list: self\n+            list: self,\n         }\n     }\n \n@@ -452,9 +466,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        unsafe {\n-            self.list_tail.resolve().map(|tail| &tail.value)\n-        }\n+        unsafe { self.list_tail.resolve().map(|tail| &tail.value) }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -481,9 +493,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        unsafe {\n-            self.list_tail.resolve_mut().map(|tail| &mut tail.value)\n-        }\n+        unsafe { self.list_tail.resolve_mut().map(|tail| &mut tail.value) }\n     }\n \n     /// Adds an element first in the list.\n@@ -532,7 +542,7 @@ impl<T> LinkedList<T> {\n     ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n-        self.pop_front_node().map(|box Node{value, ..}| value)\n+        self.pop_front_node().map(|box Node { value, .. }| value)\n     }\n \n     /// Appends an element to the back of a list\n@@ -568,7 +578,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n-        self.pop_back_node().map(|box Node{value, ..}| value)\n+        self.pop_back_node().map(|box Node { value, .. }| value)\n     }\n \n     /// Splits the list into two at the given index. Returns everything after the given index,\n@@ -617,7 +627,7 @@ impl<T> LinkedList<T> {\n                 iter.next();\n             }\n             iter.head\n-        }  else {\n+        } else {\n             // better off starting from the end\n             let mut iter = self.iter_mut();\n             for _ in 0..len - 1 - (at - 1) {\n@@ -641,7 +651,7 @@ impl<T> LinkedList<T> {\n         let second_part = LinkedList {\n             list_head: second_part_head,\n             list_tail: self.list_tail,\n-            length: len - at\n+            length: len - at,\n         };\n \n         // Fix the tail ptr of the first part\n@@ -760,7 +770,9 @@ impl<'a, A> IterMut<'a, A> {\n         //\n         // The inserted node will not appear in further iteration.\n         match unsafe { self.head.resolve_mut() } {\n-            None => { self.list.push_back_node(ins_node); }\n+            None => {\n+                self.list.push_back_node(ins_node);\n+            }\n             Some(node) => {\n                 let prev_node = match unsafe { node.prev.resolve_mut() } {\n                     None => return self.list.push_front_node(ins_node),\n@@ -830,11 +842,9 @@ impl<'a, A> IterMut<'a, A> {\n                issue = \"27794\")]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n-            return None\n-        }\n-        unsafe {\n-            self.head.resolve_mut().map(|head| &mut head.value)\n+            return None;\n         }\n+        unsafe { self.head.resolve_mut().map(|head| &mut head.value) }\n     }\n }\n \n@@ -843,7 +853,9 @@ impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.list.pop_front() }\n+    fn next(&mut self) -> Option<A> {\n+        self.list.pop_front()\n+    }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -854,15 +866,17 @@ impl<A> Iterator for IntoIter<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n+    fn next_back(&mut self) -> Option<A> {\n+        self.list.pop_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for LinkedList<A> {\n-    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> LinkedList<A> {\n+    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> LinkedList<A> {\n         let mut ret = LinkedList::new();\n         ret.extend(iter);\n         ret\n@@ -877,7 +891,7 @@ impl<T> IntoIterator for LinkedList<T> {\n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n     fn into_iter(self) -> IntoIter<T> {\n-        IntoIter{list: self}\n+        IntoIter { list: self }\n     }\n }\n \n@@ -903,28 +917,28 @@ impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for LinkedList<A> {\n-    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T) {\n-        for elt in iter { self.push_back(elt); }\n+    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n+        for elt in iter {\n+            self.push_back(elt);\n+        }\n     }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for LinkedList<A> {\n     fn eq(&self, other: &LinkedList<A>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().eq(other.iter())\n+        self.len() == other.len() && self.iter().eq(other.iter())\n     }\n \n     fn ne(&self, other: &LinkedList<A>) -> bool {\n-        self.len() != other.len() ||\n-            self.iter().ne(other.iter())\n+        self.len() != other.len() || self.iter().ne(other.iter())\n     }\n }\n \n@@ -974,7 +988,7 @@ impl<A: Hash> Hash for LinkedList<A> {\n mod tests {\n     use std::clone::Clone;\n     use std::iter::{Iterator, IntoIterator, Extend};\n-    use std::option::Option::{Some, None, self};\n+    use std::option::Option::{self, Some, None};\n     use std::__rand::{thread_rng, Rng};\n     use std::thread;\n     use std::vec::Vec;\n@@ -991,13 +1005,16 @@ mod tests {\n         let mut last_ptr: Option<&Node<T>> = None;\n         let mut node_ptr: &Node<T>;\n         match list.list_head {\n-            None => { assert_eq!(0, list.length); return }\n+            None => {\n+                assert_eq!(0, list.length);\n+                return;\n+            }\n             Some(ref node) => node_ptr = &**node,\n         }\n         loop {\n             match unsafe { (last_ptr, node_ptr.prev.resolve()) } {\n-                (None   , None      ) => {}\n-                (None   , _         ) => panic!(\"prev link for list_head\"),\n+                (None, None) => {}\n+                (None, _) => panic!(\"prev link for list_head\"),\n                 (Some(p), Some(pptr)) => {\n                     assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n                 }\n@@ -1054,8 +1071,8 @@ mod tests {\n         }\n \n         // Non-empty to non-empty\n-        let v = vec![1,2,3,4,5];\n-        let u = vec![9,8,1,2,3,4,5];\n+        let v = vec![1, 2, 3, 4, 5];\n+        let u = vec![9, 8, 1, 2, 3, 4, 5];\n         let mut m = list_from(&v);\n         let mut n = list_from(&u);\n         m.append(&mut n);\n@@ -1077,7 +1094,7 @@ mod tests {\n \n     #[test]\n     fn test_insert_prev() {\n-        let mut m = list_from(&[0,2,4,6,8]);\n+        let mut m = list_from(&[0, 2, 4, 6, 8]);\n         let len = m.len();\n         {\n             let mut it = m.iter_mut();\n@@ -1099,17 +1116,21 @@ mod tests {\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(),\n+                   [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n     }\n \n     #[test]\n     fn test_send() {\n-        let n = list_from(&[1,2,3]);\n+        let n = list_from(&[1, 2, 3]);\n         thread::spawn(move || {\n             check_links(&n);\n-            let a: &[_] = &[&1,&2,&3];\n+            let a: &[_] = &[&1, &2, &3];\n             assert_eq!(a, &n.iter().collect::<Vec<_>>()[..]);\n-        }).join().ok().unwrap();\n+        })\n+            .join()\n+            .ok()\n+            .unwrap();\n     }\n \n     #[test]\n@@ -1179,7 +1200,7 @@ mod tests {\n                         v.remove(0);\n                     }\n                 }\n-                2 | 4 =>  {\n+                2 | 4 => {\n                     m.push_front(-i);\n                     v.insert(0, -i);\n                 }"}, {"sha": "c70aa67366b342edd2fca8a398b86a483306ed45", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -22,26 +22,38 @@ pub trait RangeArgument<T> {\n     /// Start index (inclusive)\n     ///\n     /// Return start value if present, else `None`.\n-    fn start(&self) -> Option<&T> { None }\n+    fn start(&self) -> Option<&T> {\n+        None\n+    }\n \n     /// End index (exclusive)\n     ///\n     /// Return end value if present, else `None`.\n-    fn end(&self) -> Option<&T> { None }\n+    fn end(&self) -> Option<&T> {\n+        None\n+    }\n }\n \n \n impl<T> RangeArgument<T> for RangeFull {}\n \n impl<T> RangeArgument<T> for RangeFrom<T> {\n-    fn start(&self) -> Option<&T> { Some(&self.start) }\n+    fn start(&self) -> Option<&T> {\n+        Some(&self.start)\n+    }\n }\n \n impl<T> RangeArgument<T> for RangeTo<T> {\n-    fn end(&self) -> Option<&T> { Some(&self.end) }\n+    fn end(&self) -> Option<&T> {\n+        Some(&self.end)\n+    }\n }\n \n impl<T> RangeArgument<T> for Range<T> {\n-    fn start(&self) -> Option<&T> { Some(&self.start) }\n-    fn end(&self) -> Option<&T> { Some(&self.end) }\n+    fn start(&self) -> Option<&T> {\n+        Some(&self.start)\n+    }\n+    fn end(&self) -> Option<&T> {\n+        Some(&self.end)\n+    }\n }"}, {"sha": "0e615402b46d205543850d5d105cb00b8bc63158", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -156,7 +156,9 @@ mod hack {\n     }\n \n     #[inline]\n-    pub fn to_vec<T>(s: &[T]) -> Vec<T> where T: Clone {\n+    pub fn to_vec<T>(s: &[T]) -> Vec<T>\n+        where T: Clone\n+    {\n         let mut vector = Vec::with_capacity(s.len());\n         vector.push_all(s);\n         vector\n@@ -535,15 +537,19 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn split<F>(&self, pred: F) -> Split<T, F> where F: FnMut(&T) -> bool {\n+    pub fn split<F>(&self, pred: F) -> Split<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::split(self, pred)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F> where F: FnMut(&T) -> bool {\n+    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::split_mut(self, pred)\n     }\n \n@@ -567,7 +573,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F> where F: FnMut(&T) -> bool {\n+    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::splitn(self, n, pred)\n     }\n \n@@ -580,7 +588,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n-                         where F: FnMut(&T) -> bool {\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::splitn_mut(self, n, pred)\n     }\n \n@@ -605,7 +614,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F> where F: FnMut(&T) -> bool {\n+    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::rsplitn(self, n, pred)\n     }\n \n@@ -618,8 +629,9 @@ impl<T> [T] {\n     /// slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<T, F>\n-                      where F: FnMut(&T) -> bool {\n+    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::rsplitn_mut(self, n, pred)\n     }\n \n@@ -633,7 +645,9 @@ impl<T> [T] {\n     /// assert!(!v.contains(&50));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains(&self, x: &T) -> bool where T: PartialEq {\n+    pub fn contains(&self, x: &T) -> bool\n+        where T: PartialEq\n+    {\n         core_slice::SliceExt::contains(self, x)\n     }\n \n@@ -649,7 +663,9 @@ impl<T> [T] {\n     /// assert!(!v.starts_with(&[10, 50]));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+    pub fn starts_with(&self, needle: &[T]) -> bool\n+        where T: PartialEq\n+    {\n         core_slice::SliceExt::starts_with(self, needle)\n     }\n \n@@ -665,7 +681,9 @@ impl<T> [T] {\n     /// assert!(!v.ends_with(&[50, 30]));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+    pub fn ends_with(&self, needle: &[T]) -> bool\n+        where T: PartialEq\n+    {\n         core_slice::SliceExt::ends_with(self, needle)\n     }\n \n@@ -692,7 +710,9 @@ impl<T> [T] {\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n+        where T: Ord\n+    {\n         core_slice::SliceExt::binary_search(self, x)\n     }\n \n@@ -729,7 +749,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where F: FnMut(&T) -> Ordering {\n+    pub fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>\n+        where F: FnMut(&T) -> Ordering\n+    {\n         core_slice::SliceExt::binary_search_by(self, f)\n     }\n \n@@ -749,7 +771,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sort(&mut self) where T: Ord {\n+    pub fn sort(&mut self)\n+        where T: Ord\n+    {\n         self.sort_by(|a, b| a.cmp(b))\n     }\n \n@@ -772,7 +796,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n+    pub fn sort_by<F>(&mut self, compare: F)\n+        where F: FnMut(&T, &T) -> Ordering\n+    {\n         merge_sort(self, compare)\n     }\n \n@@ -796,14 +822,18 @@ impl<T> [T] {\n     /// assert!(dst == [3, 4, 5]);\n     /// ```\n     #[unstable(feature = \"clone_from_slice\", issue = \"27750\")]\n-    pub fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n+    pub fn clone_from_slice(&mut self, src: &[T]) -> usize\n+        where T: Clone\n+    {\n         core_slice::SliceExt::clone_from_slice(self, src)\n     }\n \n     /// Copies `self` into a new `Vec`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn to_vec(&self) -> Vec<T> where T: Clone {\n+    pub fn to_vec(&self) -> Vec<T>\n+        where T: Clone\n+    {\n         // NB see hack module in this file\n         hack::to_vec(self)\n     }\n@@ -886,7 +916,11 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self {\n-            if first { first = false } else { result.push(sep.clone()) }\n+            if first {\n+                first = false\n+            } else {\n+                result.push(sep.clone())\n+            }\n             result.push_all(v.borrow())\n         }\n         result\n@@ -903,33 +937,43 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Borrow<[T]> for Vec<T> {\n-    fn borrow(&self) -> &[T] { &self[..] }\n+    fn borrow(&self) -> &[T] {\n+        &self[..]\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> BorrowMut<[T]> for Vec<T> {\n-    fn borrow_mut(&mut self) -> &mut [T] { &mut self[..] }\n+    fn borrow_mut(&mut self) -> &mut [T] {\n+        &mut self[..]\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> ToOwned for [T] {\n     type Owned = Vec<T>;\n     #[cfg(not(test))]\n-    fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+    fn to_owned(&self) -> Vec<T> {\n+        self.to_vec()\n+    }\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec`, which is required for this method\n     // definition, is not available. Since we don't require this method for testing purposes, I'll\n     // just stub it\n     // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n-    fn to_owned(&self) -> Vec<T> { panic!(\"not available with cfg(test)\") }\n+    fn to_owned(&self) -> Vec<T> {\n+        panic!(\"not available with cfg(test)\")\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n // Sorting\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+fn insertion_sort<T, F>(v: &mut [T], mut compare: F)\n+    where F: FnMut(&T, &T) -> Ordering\n+{\n     let len = v.len() as isize;\n     let buf_v = v.as_mut_ptr();\n \n@@ -945,8 +989,7 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n             // rather than <=, to maintain stability.\n \n             // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n-            while j > 0 &&\n-                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n+            while j > 0 && compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n                 j -= 1;\n             }\n \n@@ -959,17 +1002,17 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n \n             if i != j {\n                 let tmp = ptr::read(read_ptr);\n-                ptr::copy(&*buf_v.offset(j),\n-                          buf_v.offset(j + 1),\n-                          (i - j) as usize);\n+                ptr::copy(&*buf_v.offset(j), buf_v.offset(j + 1), (i - j) as usize);\n                 ptr::copy_nonoverlapping(&tmp, buf_v.offset(j), 1);\n                 mem::forget(tmp);\n             }\n         }\n     }\n }\n \n-fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n+    where F: FnMut(&T, &T) -> Ordering\n+{\n     // warning: this wildly uses unsafe.\n     const BASE_INSERTION: usize = 32;\n     const LARGE_INSERTION: usize = 16;\n@@ -998,7 +1041,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     let mut working_space = Vec::with_capacity(2 * len);\n     // these both are buffers of length `len`.\n     let mut buf_dat = working_space.as_mut_ptr();\n-    let mut buf_tmp = unsafe {buf_dat.offset(len as isize)};\n+    let mut buf_tmp = unsafe { buf_dat.offset(len as isize) };\n \n     // length `len`.\n     let buf_v = v.as_ptr();\n@@ -1010,7 +1053,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     // We could hardcode the sorting comparisons here, and we could\n     // manipulate/step the pointers themselves, rather than repeatedly\n     // .offset-ing.\n-    for start in (0.. len).step_by(insertion) {\n+    for start in (0..len).step_by(insertion) {\n         // start <= i < len;\n         for i in start..cmp::min(start + insertion, len) {\n             // j satisfies: start <= j <= i;\n@@ -1024,8 +1067,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n \n                 // start <= j - 1 < len, so .offset(j - 1) is in\n                 // bounds.\n-                while j > start as isize &&\n-                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n+                while j > start as isize && compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n                     j -= 1;\n                 }\n \n@@ -1035,9 +1077,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // j + 1 could be `len` (for the last `i`), but in\n                 // that case, `i == j` so we don't copy. The\n                 // `.offset(j)` is always in bounds.\n-                ptr::copy(&*buf_dat.offset(j),\n-                          buf_dat.offset(j + 1),\n-                          i - j as usize);\n+                ptr::copy(&*buf_dat.offset(j), buf_dat.offset(j + 1), i - j as usize);\n                 ptr::copy_nonoverlapping(read_ptr, buf_dat.offset(j), 1);\n             }\n         }"}, {"sha": "72a148fa2f496a4a83b18a17fc9e81275bfcfa95", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -57,7 +57,7 @@ pub use core::str::{from_utf8, Chars, CharIndices, Bytes};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::{from_utf8_unchecked, ParseBoolError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use rustc_unicode::str::{SplitWhitespace};\n+pub use rustc_unicode::str::SplitWhitespace;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::pattern;\n \n@@ -95,8 +95,8 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n \n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1)\n-            + self.iter().map(|s| s.borrow().len()).sum::<usize>();\n+        let len = sep.len() * (self.len() - 1) +\n+                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n@@ -122,18 +122,22 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n #[derive(Clone)]\n #[unstable(feature = \"str_utf16\", issue = \"27714\")]\n pub struct Utf16Units<'a> {\n-    encoder: Utf16Encoder<Chars<'a>>\n+    encoder: Utf16Encoder<Chars<'a>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Utf16Units<'a> {\n     type Item = u16;\n \n     #[inline]\n-    fn next(&mut self) -> Option<u16> { self.encoder.next() }\n+    fn next(&mut self) -> Option<u16> {\n+        self.encoder.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.encoder.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.encoder.size_hint()\n+    }\n }\n \n // Return the initial codepoint accumulator for the first byte.\n@@ -151,16 +155,16 @@ macro_rules! utf8_acc_cont_byte {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<str> for String {\n     #[inline]\n-    fn borrow(&self) -> &str { &self[..] }\n+    fn borrow(&self) -> &str {\n+        &self[..]\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for str {\n     type Owned = String;\n     fn to_owned(&self) -> String {\n-        unsafe {\n-            String::from_utf8_unchecked(self.as_bytes().to_owned())\n-        }\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n     }\n }\n \n@@ -1450,13 +1454,16 @@ impl str {\n             // See http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n             // for the definition of `Final_Sigma`.\n             debug_assert!('\u03a3'.len_utf8() == 2);\n-            let is_word_final =\n-                case_ignoreable_then_cased(from[..i].chars().rev()) &&\n-                !case_ignoreable_then_cased(from[i + 2..].chars());\n-            to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n+            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n+                                !case_ignoreable_then_cased(from[i + 2..].chars());\n+            to.push_str(if is_word_final {\n+                \"\u03c2\"\n+            } else {\n+                \"\u03c3\"\n+            });\n         }\n \n-        fn case_ignoreable_then_cased<I: Iterator<Item=char>>(iter: I) -> bool {\n+        fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n             use rustc_unicode::derived_property::{Cased, Case_Ignorable};\n             match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n                 Some(c) => Cased(c),"}, {"sha": "7934ebd443960c1573ec86081563818a8472ecee", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -61,9 +61,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> String {\n-        String {\n-            vec: Vec::new(),\n-        }\n+        String { vec: Vec::new() }\n     }\n \n     /// Creates a new string buffer with the given capacity.\n@@ -92,9 +90,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> String {\n-        String {\n-            vec: Vec::with_capacity(capacity),\n-        }\n+        String { vec: Vec::with_capacity(capacity) }\n     }\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n@@ -167,7 +163,12 @@ impl String {\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n         match str::from_utf8(&vec) {\n             Ok(..) => Ok(String { vec: vec }),\n-            Err(e) => Err(FromUtf8Error { bytes: vec, error: e })\n+            Err(e) => {\n+                Err(FromUtf8Error {\n+                    bytes: vec,\n+                    error: e,\n+                })\n+            }\n         }\n     }\n \n@@ -240,9 +241,7 @@ impl String {\n         let mut res = String::with_capacity(total);\n \n         if i > 0 {\n-            unsafe {\n-                res.as_mut_vec().push_all(&v[..i])\n-            };\n+            unsafe { res.as_mut_vec().push_all(&v[..i]) };\n         }\n \n         // subseqidx is the index of the first byte of the subsequence we're\n@@ -280,10 +279,10 @@ impl String {\n                     }\n                     3 => {\n                         match (byte, safe_get(v, i, total)) {\n-                            (0xE0         , 0xA0 ... 0xBF) => (),\n-                            (0xE1 ... 0xEC, 0x80 ... 0xBF) => (),\n-                            (0xED         , 0x80 ... 0x9F) => (),\n-                            (0xEE ... 0xEF, 0x80 ... 0xBF) => (),\n+                            (0xE0, 0xA0...0xBF) => (),\n+                            (0xE1...0xEC, 0x80...0xBF) => (),\n+                            (0xED, 0x80...0x9F) => (),\n+                            (0xEE...0xEF, 0x80...0xBF) => (),\n                             _ => {\n                                 error!();\n                                 continue;\n@@ -298,9 +297,9 @@ impl String {\n                     }\n                     4 => {\n                         match (byte, safe_get(v, i, total)) {\n-                            (0xF0         , 0x90 ... 0xBF) => (),\n-                            (0xF1 ... 0xF3, 0x80 ... 0xBF) => (),\n-                            (0xF4         , 0x80 ... 0x8F) => (),\n+                            (0xF0, 0x90...0xBF) => (),\n+                            (0xF1...0xF3, 0x80...0xBF) => (),\n+                            (0xF4, 0x80...0x8F) => (),\n                             _ => {\n                                 error!();\n                                 continue;\n@@ -326,9 +325,7 @@ impl String {\n             }\n         }\n         if subseqidx < total {\n-            unsafe {\n-                res.as_mut_vec().push_all(&v[subseqidx..total])\n-            };\n+            unsafe { res.as_mut_vec().push_all(&v[subseqidx..total]) };\n         }\n         Cow::Owned(res)\n     }\n@@ -388,9 +385,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n-        String {\n-            vec: Vec::from_raw_parts(buf, length, capacity),\n-        }\n+        String { vec: Vec::from_raw_parts(buf, length, capacity) }\n     }\n \n     /// Converts a vector of bytes to a `String` without checking that the\n@@ -567,10 +562,10 @@ impl String {\n                 unsafe {\n                     // Attempt to not use an intermediate buffer by just pushing bytes\n                     // directly onto this string.\n-                    let slice = slice::from_raw_parts_mut (\n-                        self.vec.as_mut_ptr().offset(cur_len as isize),\n-                        ch_len\n-                    );\n+                    let slice = slice::from_raw_parts_mut(self.vec\n+                                                              .as_mut_ptr()\n+                                                              .offset(cur_len as isize),\n+                                                          ch_len);\n                     let used = ch.encode_utf8(slice).unwrap_or(0);\n                     self.vec.set_len(cur_len + used);\n                 }\n@@ -630,7 +625,7 @@ impl String {\n     pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n-            return None\n+            return None;\n         }\n \n         let ch = self.char_at_reverse(len);\n@@ -742,7 +737,9 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.vec.len() }\n+    pub fn len(&self) -> usize {\n+        self.vec.len()\n+    }\n \n     /// Returns true if the string contains no bytes\n     ///\n@@ -756,7 +753,9 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Truncates the string, returning it to 0 length.\n     ///\n@@ -802,7 +801,9 @@ impl String {\n     #[unstable(feature = \"drain\",\n                reason = \"recently added, matches RFC\",\n                issue = \"27711\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain where R: RangeArgument<usize> {\n+    pub fn drain<R>(&mut self, range: R) -> Drain\n+        where R: RangeArgument<usize>\n+    {\n         // Memory safety\n         //\n         // The String version of Drain does not have the memory safety issues\n@@ -852,11 +853,15 @@ impl FromUtf8Error {\n     /// Consumes this error, returning the bytes that were attempted to make a\n     /// `String` with.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n+    pub fn into_bytes(self) -> Vec<u8> {\n+        self.bytes\n+    }\n \n     /// Access the underlying UTF8-error that was the cause of this error.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn utf8_error(&self) -> Utf8Error { self.error }\n+    pub fn utf8_error(&self) -> Utf8Error {\n+        self.error\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -886,7 +891,7 @@ impl Clone for String {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n-    fn from_iter<I: IntoIterator<Item=char>>(iterable: I) -> String {\n+    fn from_iter<I: IntoIterator<Item = char>>(iterable: I) -> String {\n         let mut buf = String::new();\n         buf.extend(iterable);\n         buf\n@@ -895,7 +900,7 @@ impl FromIterator<char> for String {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n-    fn from_iter<I: IntoIterator<Item=&'a str>>(iterable: I) -> String {\n+    fn from_iter<I: IntoIterator<Item = &'a str>>(iterable: I) -> String {\n         let mut buf = String::new();\n         buf.extend(iterable);\n         buf\n@@ -904,7 +909,7 @@ impl<'a> FromIterator<&'a str> for String {\n \n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl FromIterator<String> for String {\n-    fn from_iter<I: IntoIterator<Item=String>>(iterable: I) -> String {\n+    fn from_iter<I: IntoIterator<Item = String>>(iterable: I) -> String {\n         let mut buf = String::new();\n         buf.extend(iterable);\n         buf\n@@ -913,7 +918,7 @@ impl FromIterator<String> for String {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<char> for String {\n-    fn extend<I: IntoIterator<Item=char>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = char>>(&mut self, iterable: I) {\n         let iterator = iterable.into_iter();\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n@@ -925,14 +930,14 @@ impl Extend<char> for String {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a> Extend<&'a char> for String {\n-    fn extend<I: IntoIterator<Item=&'a char>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iterable: I) {\n         self.extend(iterable.into_iter().cloned());\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Extend<&'a str> for String {\n-    fn extend<I: IntoIterator<Item=&'a str>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iterable: I) {\n         for s in iterable {\n             self.push_str(s)\n         }\n@@ -941,7 +946,7 @@ impl<'a> Extend<&'a str> for String {\n \n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl Extend<String> for String {\n-    fn extend<I: IntoIterator<Item=String>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = String>>(&mut self, iterable: I) {\n         for s in iterable {\n             self.push_str(&s)\n         }\n@@ -973,9 +978,13 @@ impl<'a, 'b> Pattern<'a> for &'b String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for String {\n     #[inline]\n-    fn eq(&self, other: &String) -> bool { PartialEq::eq(&self[..], &other[..]) }\n+    fn eq(&self, other: &String) -> bool {\n+        PartialEq::eq(&self[..], &other[..])\n+    }\n     #[inline]\n-    fn ne(&self, other: &String) -> bool { PartialEq::ne(&self[..], &other[..]) }\n+    fn ne(&self, other: &String) -> bool {\n+        PartialEq::ne(&self[..], &other[..])\n+    }\n }\n \n macro_rules! impl_eq {"}, {"sha": "8c1f98bbd07c5232fe486e40696aa61e517547c5", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 71, "deletions": 57, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -248,7 +248,10 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Vec<T> {\n-        Vec { buf: RawVec::new(), len: 0 }\n+        Vec {\n+            buf: RawVec::new(),\n+            len: 0,\n+        }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -280,7 +283,10 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> Vec<T> {\n-        Vec { buf: RawVec::with_capacity(capacity), len: 0 }\n+        Vec {\n+            buf: RawVec::with_capacity(capacity),\n+            len: 0,\n+        }\n     }\n \n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n@@ -329,8 +335,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize,\n-                                 capacity: usize) -> Vec<T> {\n+    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Vec<T> {\n         Vec {\n             buf: RawVec::from_raw_parts(ptr, capacity),\n             len: length,\n@@ -547,9 +552,12 @@ impl<T> Vec<T> {\n         assert!(index <= len);\n \n         // space for the new element\n-        if len == self.buf.cap() { self.buf.double(); }\n+        if len == self.buf.cap() {\n+            self.buf.double();\n+        }\n \n-        unsafe { // infallible\n+        unsafe {\n+            // infallible\n             // The spot to put the new value\n             {\n                 let p = self.as_mut_ptr().offset(index as isize);\n@@ -582,7 +590,8 @@ impl<T> Vec<T> {\n     pub fn remove(&mut self, index: usize) -> T {\n         let len = self.len();\n         assert!(index < len);\n-        unsafe { // infallible\n+        unsafe {\n+            // infallible\n             let ret;\n             {\n                 // the place we are taking from.\n@@ -613,7 +622,9 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, [2, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n+    pub fn retain<F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> bool\n+    {\n         let len = self.len();\n         let mut del = 0;\n         {\n@@ -623,7 +634,7 @@ impl<T> Vec<T> {\n                 if !f(&v[i]) {\n                     del += 1;\n                 } else if del > 0 {\n-                    v.swap(i-del, i);\n+                    v.swap(i - del, i);\n                 }\n             }\n         }\n@@ -650,7 +661,9 @@ impl<T> Vec<T> {\n     pub fn push(&mut self, value: T) {\n         // This will panic or abort if we would allocate > isize::MAX bytes\n         // or if the length increment would overflow for zero-sized types.\n-        if self.len == self.buf.cap() { self.buf.double(); }\n+        if self.len == self.buf.cap() {\n+            self.buf.double();\n+        }\n         unsafe {\n             let end = self.as_mut_ptr().offset(self.len as isize);\n             ptr::write(end, value);\n@@ -702,14 +715,13 @@ impl<T> Vec<T> {\n         self.reserve(other.len());\n         let len = self.len();\n         unsafe {\n-            ptr::copy_nonoverlapping(\n-                other.as_ptr(),\n-                self.get_unchecked_mut(len),\n-                other.len());\n+            ptr::copy_nonoverlapping(other.as_ptr(), self.get_unchecked_mut(len), other.len());\n         }\n \n         self.len += other.len();\n-        unsafe { other.set_len(0); }\n+        unsafe {\n+            other.set_len(0);\n+        }\n     }\n \n     /// Create a draining iterator that removes the specified range in the vector\n@@ -738,7 +750,9 @@ impl<T> Vec<T> {\n     #[unstable(feature = \"drain\",\n                reason = \"recently added, matches RFC\",\n                issue = \"27711\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n+    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n+        where R: RangeArgument<usize>\n+    {\n         // Memory safety\n         //\n         // When the Drain is first created, it shortens the length of\n@@ -760,9 +774,8 @@ impl<T> Vec<T> {\n             self.set_len(start);\n             // Use the borrow in the IterMut to indicate borrowing behavior of the\n             // whole Drain iterator (like &mut T).\n-            let range_slice = slice::from_raw_parts_mut(\n-                                        self.as_mut_ptr().offset(start as isize),\n-                                        end - start);\n+            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().offset(start as isize),\n+                                                        end - start);\n             Drain {\n                 tail_start: end,\n                 tail_len: len - end,\n@@ -799,7 +812,9 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.len }\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n \n     /// Returns `true` if the vector contains no elements.\n     ///\n@@ -813,7 +828,9 @@ impl<T> Vec<T> {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Splits the collection into two at the given index.\n     ///\n@@ -847,14 +864,12 @@ impl<T> Vec<T> {\n             self.set_len(at);\n             other.set_len(other_len);\n \n-            ptr::copy_nonoverlapping(\n-                self.as_ptr().offset(at as isize),\n-                other.as_mut_ptr(),\n-                other.len());\n+            ptr::copy_nonoverlapping(self.as_ptr().offset(at as isize),\n+                                     other.as_mut_ptr(),\n+                                     other.len());\n         }\n         other\n     }\n-\n }\n \n impl<T: Clone> Vec<T> {\n@@ -937,9 +952,7 @@ impl<T: Clone> Vec<T> {\n             // similarly fast) when T is Copy. LLVM is easily confused, so any\n             // extra operations during the loop can prevent this optimisation.\n             unsafe {\n-                ptr::write(\n-                    self.get_unchecked_mut(len),\n-                    other.get_unchecked(i).clone());\n+                ptr::write(self.get_unchecked_mut(len), other.get_unchecked(i).clone());\n                 self.set_len(len + 1);\n             }\n         }\n@@ -1021,7 +1034,9 @@ impl<T: PartialEq> Vec<T> {\n             // Duplicate, advance r. End of vec. Truncate to w.\n \n             let ln = self.len();\n-            if ln <= 1 { return; }\n+            if ln <= 1 {\n+                return;\n+            }\n \n             // Avoid bounds checks by using raw pointers.\n             let p = self.as_mut_ptr();\n@@ -1063,9 +1078,11 @@ pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T:Clone> Clone for Vec<T> {\n+impl<T: Clone> Clone for Vec<T> {\n     #[cfg(not(test))]\n-    fn clone(&self) -> Vec<T> { <[T]>::to_vec(&**self) }\n+    fn clone(&self) -> Vec<T> {\n+        <[T]>::to_vec(&**self)\n+    }\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n     // required for this method definition, is not available. Instead use the\n@@ -1158,31 +1175,27 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n-\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n-\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n-\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n-\n     #[inline]\n     fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n         self\n@@ -1216,7 +1229,7 @@ impl<T> ops::DerefMut for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n-    fn from_iter<I: IntoIterator<Item=T>>(iterable: I) -> Vec<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iterable: I) -> Vec<T> {\n         // Unroll the first iteration, as the vector is going to be\n         // expanded on this iteration in every case when the iterable is not\n         // empty, but the loop in extend_desugared() is not going to see the\n@@ -1271,7 +1284,11 @@ impl<T> IntoIterator for Vec<T> {\n             };\n             let buf = ptr::read(&self.buf);\n             mem::forget(self);\n-            IntoIter { _buf: buf, ptr: begin, end: end }\n+            IntoIter {\n+                _buf: buf,\n+                ptr: begin,\n+                end: end,\n+            }\n         }\n     }\n }\n@@ -1299,13 +1316,13 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iterable: I) {\n         self.extend_desugared(iterable.into_iter())\n     }\n }\n \n impl<T> Vec<T> {\n-    fn extend_desugared<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n+    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n         // This function should be the moral equivalent of:\n         //\n         //      for item in iterator {\n@@ -1328,7 +1345,7 @@ impl<T> Vec<T> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n@@ -1466,7 +1483,7 @@ impl<'a> From<&'a str> for Vec<u8> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n-    fn from_iter<I: IntoIterator<Item=T>>(it: I) -> Cow<'a, [T]> {\n+    fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n         Cow::Owned(FromIterator::from_iter(it))\n     }\n }\n@@ -1494,13 +1511,13 @@ impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n pub struct IntoIter<T> {\n     _buf: RawVec<T>,\n     ptr: *const T,\n-    end: *const T\n+    end: *const T,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for IntoIter<T> { }\n+unsafe impl<T: Send> Send for IntoIter<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for IntoIter<T> { }\n+unsafe impl<T: Sync> Sync for IntoIter<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n@@ -1534,7 +1551,12 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let diff = (self.end as usize) - (self.ptr as usize);\n         let size = mem::size_of::<T>();\n-        let exact = diff / (if size == 0 {1} else {size});\n+        let exact = diff /\n+                    (if size == 0 {\n+                         1\n+                     } else {\n+                         size\n+                     });\n         (exact, Some(exact))\n     }\n \n@@ -1605,11 +1627,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt|\n-            unsafe {\n-                ptr::read(elt as *const _)\n-            }\n-        )\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -1621,19 +1639,15 @@ impl<'a, T> Iterator for Drain<'a, T> {\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt|\n-            unsafe {\n-                ptr::read(elt as *const _)\n-            }\n-        )\n+        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         // exhaust self first\n-        while let Some(_) = self.next() { }\n+        while let Some(_) = self.next() {}\n \n         if self.tail_len > 0 {\n             unsafe {"}, {"sha": "10b732534c6baf93e998653f471430a23040c052", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 394, "deletions": 307, "changes": 701, "blob_url": "https://github.com/rust-lang/rust/blob/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "patch": "@@ -52,7 +52,6 @@ pub struct VecDeque<T> {\n     // to where data should be written.\n     // If tail == head the buffer is empty. The length of the ringbuffer\n     // is defined as the distance between the two.\n-\n     tail: usize,\n     head: usize,\n     buf: RawVec<T>,\n@@ -77,7 +76,9 @@ impl<T> Drop for VecDeque<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for VecDeque<T> {\n     #[inline]\n-    fn default() -> VecDeque<T> { VecDeque::new() }\n+    fn default() -> VecDeque<T> {\n+        VecDeque::new()\n+    }\n }\n \n impl<T> VecDeque<T> {\n@@ -124,12 +125,16 @@ impl<T> VecDeque<T> {\n \n     /// Returns true if and only if the buffer is at capacity\n     #[inline]\n-    fn is_full(&self) -> bool { self.cap() - self.len() == 1 }\n+    fn is_full(&self) -> bool {\n+        self.cap() - self.len() == 1\n+    }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index.\n     #[inline]\n-    fn wrap_index(&self, idx: usize) -> usize { wrap_index(idx, self.cap()) }\n+    fn wrap_index(&self, idx: usize) -> usize {\n+        wrap_index(idx, self.cap())\n+    }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index + addend.\n@@ -148,40 +153,65 @@ impl<T> VecDeque<T> {\n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n-        debug_assert!(dst + len <= self.cap(), \"cpy dst={} src={} len={} cap={}\", dst, src, len,\n+        debug_assert!(dst + len <= self.cap(),\n+                      \"cpy dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n                       self.cap());\n-        debug_assert!(src + len <= self.cap(), \"cpy dst={} src={} len={} cap={}\", dst, src, len,\n+        debug_assert!(src + len <= self.cap(),\n+                      \"cpy dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n                       self.cap());\n-        ptr::copy(\n-            self.ptr().offset(src as isize),\n-            self.ptr().offset(dst as isize),\n-            len);\n+        ptr::copy(self.ptr().offset(src as isize),\n+                  self.ptr().offset(dst as isize),\n+                  len);\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy_nonoverlapping(&self, dst: usize, src: usize, len: usize) {\n-        debug_assert!(dst + len <= self.cap(), \"cno dst={} src={} len={} cap={}\", dst, src, len,\n+        debug_assert!(dst + len <= self.cap(),\n+                      \"cno dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n                       self.cap());\n-        debug_assert!(src + len <= self.cap(), \"cno dst={} src={} len={} cap={}\", dst, src, len,\n+        debug_assert!(src + len <= self.cap(),\n+                      \"cno dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n                       self.cap());\n-        ptr::copy_nonoverlapping(\n-            self.ptr().offset(src as isize),\n-            self.ptr().offset(dst as isize),\n-            len);\n+        ptr::copy_nonoverlapping(self.ptr().offset(src as isize),\n+                                 self.ptr().offset(dst as isize),\n+                                 len);\n     }\n \n     /// Copies a potentially wrapping block of memory len long from src to dest.\n     /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n     /// most one continuous overlapping region between src and dest).\n     unsafe fn wrap_copy(&self, dst: usize, src: usize, len: usize) {\n         #[allow(dead_code)]\n-        fn diff(a: usize, b: usize) -> usize {if a <= b {b - a} else {a - b}}\n-        debug_assert!(cmp::min(diff(dst, src),\n-                               self.cap() - diff(dst, src)) + len <= self.cap(),\n-                      \"wrc dst={} src={} len={} cap={}\", dst, src, len, self.cap());\n+        fn diff(a: usize, b: usize) -> usize {\n+            if a <= b {\n+                b - a\n+            } else {\n+                a - b\n+            }\n+        }\n+        debug_assert!(cmp::min(diff(dst, src), self.cap() - diff(dst, src)) + len <= self.cap(),\n+                      \"wrc dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n+                      self.cap());\n \n-        if src == dst || len == 0 { return }\n+        if src == dst || len == 0 {\n+            return;\n+        }\n \n         let dst_after_src = self.wrap_sub(dst, src) < len;\n \n@@ -304,13 +334,16 @@ impl<T> VecDeque<T> {\n         //              H                 T\n         // C [o o o o o . . . . . . . . . o o ]\n \n-        if self.tail <= self.head { // A\n+        if self.tail <= self.head {\n+            // A\n             // Nop\n-        } else if self.head < old_cap - self.tail { // B\n+        } else if self.head < old_cap - self.tail {\n+            // B\n             self.copy_nonoverlapping(old_cap, 0, self.head);\n             self.head += old_cap;\n             debug_assert!(self.head > self.tail);\n-        } else { // C\n+        } else {\n+            // C\n             let new_tail = new_cap - (old_cap - self.tail);\n             self.copy_nonoverlapping(new_tail, self.tail, old_cap - self.tail);\n             self.tail = new_tail;\n@@ -419,7 +452,8 @@ impl<T> VecDeque<T> {\n         let ri = self.wrap_add(self.tail, i);\n         let rj = self.wrap_add(self.tail, j);\n         unsafe {\n-            ptr::swap(self.ptr().offset(ri as isize), self.ptr().offset(rj as isize))\n+            ptr::swap(self.ptr().offset(ri as isize),\n+                      self.ptr().offset(rj as isize))\n         }\n     }\n \n@@ -436,7 +470,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize { self.cap() - 1 }\n+    pub fn capacity(&self) -> usize {\n+        self.cap() - 1\n+    }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `VecDeque`. Does nothing if the capacity is already sufficient.\n@@ -483,14 +519,15 @@ impl<T> VecDeque<T> {\n     pub fn reserve(&mut self, additional: usize) {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n-        let new_cap = used_cap\n-            .checked_add(additional)\n-            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .expect(\"capacity overflow\");\n+        let new_cap = used_cap.checked_add(additional)\n+                              .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n+                              .expect(\"capacity overflow\");\n \n         if new_cap > self.capacity() {\n             self.buf.reserve_exact(used_cap, new_cap - used_cap);\n-            unsafe { self.handle_cap_increase(old_cap); }\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n         }\n     }\n \n@@ -619,7 +656,7 @@ impl<T> VecDeque<T> {\n         Iter {\n             tail: self.tail,\n             head: self.head,\n-            ring: unsafe { self.buffer_as_slice() }\n+            ring: unsafe { self.buffer_as_slice() },\n         }\n     }\n \n@@ -681,7 +718,7 @@ impl<T> VecDeque<T> {\n \n             if contiguous {\n                 let (empty, buf) = buf.split_at_mut(0);\n-                (&mut buf[tail .. head], empty)\n+                (&mut buf[tail..head], empty)\n             } else {\n                 let (mid, right) = buf.split_at_mut(tail);\n                 let (left, _) = mid.split_at_mut(head);\n@@ -704,7 +741,9 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { count(self.tail, self.head, self.cap()) }\n+    pub fn len(&self) -> usize {\n+        count(self.tail, self.head, self.cap())\n+    }\n \n     /// Returns true if the buffer contains no elements\n     ///\n@@ -719,7 +758,9 @@ impl<T> VecDeque<T> {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Create a draining iterator that removes the specified range in the\n     /// `VecDeque` and yields the removed items from start to end. The element\n@@ -751,7 +792,9 @@ impl<T> VecDeque<T> {\n     #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27711\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n+    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n+        where R: RangeArgument<usize>\n+    {\n         // Memory safety\n         //\n         // When the Drain is first created, the source deque is shortened to\n@@ -839,7 +882,11 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        if !self.is_empty() { Some(&self[0]) } else { None }\n+        if !self.is_empty() {\n+            Some(&self[0])\n+        } else {\n+            None\n+        }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the\n@@ -863,7 +910,11 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        if !self.is_empty() { Some(&mut self[0]) } else { None }\n+        if !self.is_empty() {\n+            Some(&mut self[0])\n+        } else {\n+            None\n+        }\n     }\n \n     /// Provides a reference to the back element, or `None` if the sequence is\n@@ -883,7 +934,11 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n+        if !self.is_empty() {\n+            Some(&self[self.len() - 1])\n+        } else {\n+            None\n+        }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n@@ -908,7 +963,11 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n-        if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n+        if !self.is_empty() {\n+            Some(&mut self[len - 1])\n+        } else {\n+            None\n+        }\n     }\n \n     /// Removes the first element and returns it, or `None` if the sequence is\n@@ -955,13 +1014,17 @@ impl<T> VecDeque<T> {\n         if self.is_full() {\n             let old_cap = self.cap();\n             self.buf.double();\n-            unsafe { self.handle_cap_increase(old_cap); }\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n             debug_assert!(!self.is_full());\n         }\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n-        unsafe { self.buffer_write(tail, value); }\n+        unsafe {\n+            self.buffer_write(tail, value);\n+        }\n     }\n \n     /// Appends an element to the back of a buffer\n@@ -981,7 +1044,9 @@ impl<T> VecDeque<T> {\n         if self.is_full() {\n             let old_cap = self.cap();\n             self.buf.double();\n-            unsafe { self.handle_cap_increase(old_cap); }\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n             debug_assert!(!self.is_full());\n         }\n \n@@ -1130,7 +1195,9 @@ impl<T> VecDeque<T> {\n         if self.is_full() {\n             let old_cap = self.cap();\n             self.buf.double();\n-            unsafe { self.handle_cap_increase(old_cap); }\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n             debug_assert!(!self.is_full());\n         }\n \n@@ -1163,7 +1230,9 @@ impl<T> VecDeque<T> {\n \n         let contiguous = self.is_contiguous();\n \n-        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n+        match (contiguous,\n+               distance_to_tail <= distance_to_head,\n+               idx >= self.tail) {\n             (true, true, _) if index == 0 => {\n                 // push_front\n                 //\n@@ -1176,134 +1245,148 @@ impl<T> VecDeque<T> {\n                 //\n \n                 self.tail = self.wrap_sub(self.tail, 1);\n-            },\n-            (true, true, _) => unsafe {\n-                // contiguous, insert closer to tail:\n-                //\n-                //             T   I         H\n-                //      [. . . o o A o o o o . . . . . .]\n-                //\n-                //           T               H\n-                //      [. . o o I A o o o o . . . . . .]\n-                //           M M\n-                //\n-                // contiguous, insert closer to tail and tail is 0:\n-                //\n-                //\n-                //       T   I         H\n-                //      [o o A o o o o . . . . . . . . .]\n-                //\n-                //                       H             T\n-                //      [o I A o o o o o . . . . . . . o]\n-                //       M                             M\n-\n-                let new_tail = self.wrap_sub(self.tail, 1);\n-\n-                self.copy(new_tail, self.tail, 1);\n-                // Already moved the tail, so we only copy `index - 1` elements.\n-                self.copy(self.tail, self.tail + 1, index - 1);\n-\n-                self.tail = new_tail;\n-            },\n-            (true, false, _) => unsafe {\n-                //  contiguous, insert closer to head:\n-                //\n-                //             T       I     H\n-                //      [. . . o o o o A o o . . . . . .]\n-                //\n-                //             T               H\n-                //      [. . . o o o o I A o o . . . . .]\n-                //                       M M M\n-\n-                self.copy(idx + 1, idx, self.head - idx);\n-                self.head = self.wrap_add(self.head, 1);\n-            },\n-            (false, true, true) => unsafe {\n-                // discontiguous, insert closer to tail, tail section:\n-                //\n-                //                   H         T   I\n-                //      [o o o o o o . . . . . o o A o o]\n-                //\n-                //                   H       T\n-                //      [o o o o o o . . . . o o I A o o]\n-                //                           M M\n-\n-                self.copy(self.tail - 1, self.tail, index);\n-                self.tail -= 1;\n-            },\n-            (false, false, true) => unsafe {\n-                // discontiguous, insert closer to head, tail section:\n-                //\n-                //           H             T         I\n-                //      [o o . . . . . . . o o o o o A o]\n-                //\n-                //             H           T\n-                //      [o o o . . . . . . o o o o o I A]\n-                //       M M M                         M\n-\n-                // copy elements up to new head\n-                self.copy(1, 0, self.head);\n-\n-                // copy last element into empty spot at bottom of buffer\n-                self.copy(0, self.cap() - 1, 1);\n-\n-                // move elements from idx to end forward not including ^ element\n-                self.copy(idx + 1, idx, self.cap() - 1 - idx);\n+            }\n+            (true, true, _) => {\n+                unsafe {\n+                    // contiguous, insert closer to tail:\n+                    //\n+                    //             T   I         H\n+                    //      [. . . o o A o o o o . . . . . .]\n+                    //\n+                    //           T               H\n+                    //      [. . o o I A o o o o . . . . . .]\n+                    //           M M\n+                    //\n+                    // contiguous, insert closer to tail and tail is 0:\n+                    //\n+                    //\n+                    //       T   I         H\n+                    //      [o o A o o o o . . . . . . . . .]\n+                    //\n+                    //                       H             T\n+                    //      [o I A o o o o o . . . . . . . o]\n+                    //       M                             M\n+\n+                    let new_tail = self.wrap_sub(self.tail, 1);\n+\n+                    self.copy(new_tail, self.tail, 1);\n+                    // Already moved the tail, so we only copy `index - 1` elements.\n+                    self.copy(self.tail, self.tail + 1, index - 1);\n+\n+                    self.tail = new_tail;\n+                }\n+            }\n+            (true, false, _) => {\n+                unsafe {\n+                    //  contiguous, insert closer to head:\n+                    //\n+                    //             T       I     H\n+                    //      [. . . o o o o A o o . . . . . .]\n+                    //\n+                    //             T               H\n+                    //      [. . . o o o o I A o o . . . . .]\n+                    //                       M M M\n+\n+                    self.copy(idx + 1, idx, self.head - idx);\n+                    self.head = self.wrap_add(self.head, 1);\n+                }\n+            }\n+            (false, true, true) => {\n+                unsafe {\n+                    // discontiguous, insert closer to tail, tail section:\n+                    //\n+                    //                   H         T   I\n+                    //      [o o o o o o . . . . . o o A o o]\n+                    //\n+                    //                   H       T\n+                    //      [o o o o o o . . . . o o I A o o]\n+                    //                           M M\n+\n+                    self.copy(self.tail - 1, self.tail, index);\n+                    self.tail -= 1;\n+                }\n+            }\n+            (false, false, true) => {\n+                unsafe {\n+                    // discontiguous, insert closer to head, tail section:\n+                    //\n+                    //           H             T         I\n+                    //      [o o . . . . . . . o o o o o A o]\n+                    //\n+                    //             H           T\n+                    //      [o o o . . . . . . o o o o o I A]\n+                    //       M M M                         M\n \n-                self.head += 1;\n-            },\n-            (false, true, false) if idx == 0 => unsafe {\n-                // discontiguous, insert is closer to tail, head section,\n-                // and is at index zero in the internal buffer:\n-                //\n-                //       I                   H     T\n-                //      [A o o o o o o o o o . . . o o o]\n-                //\n-                //                           H   T\n-                //      [A o o o o o o o o o . . o o o I]\n-                //                               M M M\n+                    // copy elements up to new head\n+                    self.copy(1, 0, self.head);\n \n-                // copy elements up to new tail\n-                self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n+                    // copy last element into empty spot at bottom of buffer\n+                    self.copy(0, self.cap() - 1, 1);\n \n-                // copy last element into empty spot at bottom of buffer\n-                self.copy(self.cap() - 1, 0, 1);\n+                    // move elements from idx to end forward not including ^ element\n+                    self.copy(idx + 1, idx, self.cap() - 1 - idx);\n \n-                self.tail -= 1;\n-            },\n-            (false, true, false) => unsafe {\n-                // discontiguous, insert closer to tail, head section:\n-                //\n-                //             I             H     T\n-                //      [o o o A o o o o o o . . . o o o]\n-                //\n-                //                           H   T\n-                //      [o o I A o o o o o o . . o o o o]\n-                //       M M                     M M M M\n-\n-                // copy elements up to new tail\n-                self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n-\n-                // copy last element into empty spot at bottom of buffer\n-                self.copy(self.cap() - 1, 0, 1);\n+                    self.head += 1;\n+                }\n+            }\n+            (false, true, false) if idx == 0 => {\n+                unsafe {\n+                    // discontiguous, insert is closer to tail, head section,\n+                    // and is at index zero in the internal buffer:\n+                    //\n+                    //       I                   H     T\n+                    //      [A o o o o o o o o o . . . o o o]\n+                    //\n+                    //                           H   T\n+                    //      [A o o o o o o o o o . . o o o I]\n+                    //                               M M M\n+\n+                    // copy elements up to new tail\n+                    self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n+\n+                    // copy last element into empty spot at bottom of buffer\n+                    self.copy(self.cap() - 1, 0, 1);\n \n-                // move elements from idx-1 to end forward not including ^ element\n-                self.copy(0, 1, idx - 1);\n+                    self.tail -= 1;\n+                }\n+            }\n+            (false, true, false) => {\n+                unsafe {\n+                    // discontiguous, insert closer to tail, head section:\n+                    //\n+                    //             I             H     T\n+                    //      [o o o A o o o o o o . . . o o o]\n+                    //\n+                    //                           H   T\n+                    //      [o o I A o o o o o o . . o o o o]\n+                    //       M M                     M M M M\n+\n+                    // copy elements up to new tail\n+                    self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n+\n+                    // copy last element into empty spot at bottom of buffer\n+                    self.copy(self.cap() - 1, 0, 1);\n \n-                self.tail -= 1;\n-            },\n-            (false, false, false) => unsafe {\n-                // discontiguous, insert closer to head, head section:\n-                //\n-                //               I     H           T\n-                //      [o o o o A o o . . . . . . o o o]\n-                //\n-                //                     H           T\n-                //      [o o o o I A o o . . . . . o o o]\n-                //                 M M M\n+                    // move elements from idx-1 to end forward not including ^ element\n+                    self.copy(0, 1, idx - 1);\n \n-                self.copy(idx + 1, idx, self.head - idx);\n-                self.head += 1;\n+                    self.tail -= 1;\n+                }\n+            }\n+            (false, false, false) => {\n+                unsafe {\n+                    // discontiguous, insert closer to head, head section:\n+                    //\n+                    //               I     H           T\n+                    //      [o o o o A o o . . . . . . o o o]\n+                    //\n+                    //                     H           T\n+                    //      [o o o o I A o o . . . . . o o o]\n+                    //                 M M M\n+\n+                    self.copy(idx + 1, idx, self.head - idx);\n+                    self.head += 1;\n+                }\n             }\n         }\n \n@@ -1357,121 +1440,133 @@ impl<T> VecDeque<T> {\n \n         let idx = self.wrap_add(self.tail, index);\n \n-        let elem = unsafe {\n-            Some(self.buffer_read(idx))\n-        };\n+        let elem = unsafe { Some(self.buffer_read(idx)) };\n \n         let distance_to_tail = index;\n         let distance_to_head = self.len() - index;\n \n         let contiguous = self.is_contiguous();\n \n-        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n-            (true, true, _) => unsafe {\n-                // contiguous, remove closer to tail:\n-                //\n-                //             T   R         H\n-                //      [. . . o o x o o o o . . . . . .]\n-                //\n-                //               T           H\n-                //      [. . . . o o o o o o . . . . . .]\n-                //               M M\n-\n-                self.copy(self.tail + 1, self.tail, index);\n-                self.tail += 1;\n-            },\n-            (true, false, _) => unsafe {\n-                // contiguous, remove closer to head:\n-                //\n-                //             T       R     H\n-                //      [. . . o o o o x o o . . . . . .]\n-                //\n-                //             T           H\n-                //      [. . . o o o o o o . . . . . . .]\n-                //                     M M\n-\n-                self.copy(idx, idx + 1, self.head - idx - 1);\n-                self.head -= 1;\n-            },\n-            (false, true, true) => unsafe {\n-                // discontiguous, remove closer to tail, tail section:\n-                //\n-                //                   H         T   R\n-                //      [o o o o o o . . . . . o o x o o]\n-                //\n-                //                   H           T\n-                //      [o o o o o o . . . . . . o o o o]\n-                //                               M M\n-\n-                self.copy(self.tail + 1, self.tail, index);\n-                self.tail = self.wrap_add(self.tail, 1);\n-            },\n-            (false, false, false) => unsafe {\n-                // discontiguous, remove closer to head, head section:\n-                //\n-                //               R     H           T\n-                //      [o o o o x o o . . . . . . o o o]\n-                //\n-                //                   H             T\n-                //      [o o o o o o . . . . . . . o o o]\n-                //               M M\n-\n-                self.copy(idx, idx + 1, self.head - idx - 1);\n-                self.head -= 1;\n-            },\n-            (false, false, true) => unsafe {\n-                // discontiguous, remove closer to head, tail section:\n-                //\n-                //             H           T         R\n-                //      [o o o . . . . . . o o o o o x o]\n-                //\n-                //           H             T\n-                //      [o o . . . . . . . o o o o o o o]\n-                //       M M                         M M\n-                //\n-                // or quasi-discontiguous, remove next to head, tail section:\n-                //\n-                //       H                 T         R\n-                //      [. . . . . . . . . o o o o o x o]\n-                //\n-                //                         T           H\n-                //      [. . . . . . . . . o o o o o o .]\n-                //                                   M\n-\n-                // draw in elements in the tail section\n-                self.copy(idx, idx + 1, self.cap() - idx - 1);\n-\n-                // Prevents underflow.\n-                if self.head != 0 {\n-                    // copy first element into empty spot\n-                    self.copy(self.cap() - 1, 0, 1);\n-\n-                    // move elements in the head section backwards\n-                    self.copy(0, 1, self.head - 1);\n+        match (contiguous,\n+               distance_to_tail <= distance_to_head,\n+               idx >= self.tail) {\n+            (true, true, _) => {\n+                unsafe {\n+                    // contiguous, remove closer to tail:\n+                    //\n+                    //             T   R         H\n+                    //      [. . . o o x o o o o . . . . . .]\n+                    //\n+                    //               T           H\n+                    //      [. . . . o o o o o o . . . . . .]\n+                    //               M M\n+\n+                    self.copy(self.tail + 1, self.tail, index);\n+                    self.tail += 1;\n+                }\n+            }\n+            (true, false, _) => {\n+                unsafe {\n+                    // contiguous, remove closer to head:\n+                    //\n+                    //             T       R     H\n+                    //      [. . . o o o o x o o . . . . . .]\n+                    //\n+                    //             T           H\n+                    //      [. . . o o o o o o . . . . . . .]\n+                    //                     M M\n+\n+                    self.copy(idx, idx + 1, self.head - idx - 1);\n+                    self.head -= 1;\n+                }\n+            }\n+            (false, true, true) => {\n+                unsafe {\n+                    // discontiguous, remove closer to tail, tail section:\n+                    //\n+                    //                   H         T   R\n+                    //      [o o o o o o . . . . . o o x o o]\n+                    //\n+                    //                   H           T\n+                    //      [o o o o o o . . . . . . o o o o]\n+                    //                               M M\n+\n+                    self.copy(self.tail + 1, self.tail, index);\n+                    self.tail = self.wrap_add(self.tail, 1);\n+                }\n+            }\n+            (false, false, false) => {\n+                unsafe {\n+                    // discontiguous, remove closer to head, head section:\n+                    //\n+                    //               R     H           T\n+                    //      [o o o o x o o . . . . . . o o o]\n+                    //\n+                    //                   H             T\n+                    //      [o o o o o o . . . . . . . o o o]\n+                    //               M M\n+\n+                    self.copy(idx, idx + 1, self.head - idx - 1);\n+                    self.head -= 1;\n                 }\n+            }\n+            (false, false, true) => {\n+                unsafe {\n+                    // discontiguous, remove closer to head, tail section:\n+                    //\n+                    //             H           T         R\n+                    //      [o o o . . . . . . o o o o o x o]\n+                    //\n+                    //           H             T\n+                    //      [o o . . . . . . . o o o o o o o]\n+                    //       M M                         M M\n+                    //\n+                    // or quasi-discontiguous, remove next to head, tail section:\n+                    //\n+                    //       H                 T         R\n+                    //      [. . . . . . . . . o o o o o x o]\n+                    //\n+                    //                         T           H\n+                    //      [. . . . . . . . . o o o o o o .]\n+                    //                                   M\n+\n+                    // draw in elements in the tail section\n+                    self.copy(idx, idx + 1, self.cap() - idx - 1);\n+\n+                    // Prevents underflow.\n+                    if self.head != 0 {\n+                        // copy first element into empty spot\n+                        self.copy(self.cap() - 1, 0, 1);\n+\n+                        // move elements in the head section backwards\n+                        self.copy(0, 1, self.head - 1);\n+                    }\n \n-                self.head = self.wrap_sub(self.head, 1);\n-            },\n-            (false, true, false) => unsafe {\n-                // discontiguous, remove closer to tail, head section:\n-                //\n-                //           R               H     T\n-                //      [o o x o o o o o o o . . . o o o]\n-                //\n-                //                           H       T\n-                //      [o o o o o o o o o o . . . . o o]\n-                //       M M M                       M M\n+                    self.head = self.wrap_sub(self.head, 1);\n+                }\n+            }\n+            (false, true, false) => {\n+                unsafe {\n+                    // discontiguous, remove closer to tail, head section:\n+                    //\n+                    //           R               H     T\n+                    //      [o o x o o o o o o o . . . o o o]\n+                    //\n+                    //                           H       T\n+                    //      [o o o o o o o o o o . . . . o o]\n+                    //       M M M                       M M\n \n-                // draw in elements up to idx\n-                self.copy(1, 0, idx);\n+                    // draw in elements up to idx\n+                    self.copy(1, 0, idx);\n \n-                // copy last element into empty spot\n-                self.copy(0, self.cap() - 1, 1);\n+                    // copy last element into empty spot\n+                    self.copy(0, self.cap() - 1, 1);\n \n-                // move elements from tail to end forward, excluding the last one\n-                self.copy(self.tail + 1, self.tail, self.cap() - self.tail - 1);\n+                    // move elements from tail to end forward, excluding the last one\n+                    self.copy(self.tail + 1, self.tail, self.cap() - self.tail - 1);\n \n-                self.tail = self.wrap_add(self.tail, 1);\n+                    self.tail = self.wrap_add(self.tail, 1);\n+                }\n             }\n         }\n \n@@ -1587,14 +1682,16 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(&v[..], &[2, 4]);\n     /// ```\n     #[stable(feature = \"vec_deque_retain\", since = \"1.4.0\")]\n-    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n+    pub fn retain<F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> bool\n+    {\n         let len = self.len();\n         let mut del = 0;\n         for i in 0..len {\n             if !f(&self[i]) {\n                 del += 1;\n             } else if del > 0 {\n-                self.swap(i-del, i);\n+                self.swap(i - del, i);\n             }\n         }\n         if del > 0 {\n@@ -1655,10 +1752,10 @@ fn count(tail: usize, head: usize, size: usize) -> usize {\n \n /// `VecDeque` iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, T:'a> {\n+pub struct Iter<'a, T: 'a> {\n     ring: &'a [T],\n     tail: usize,\n-    head: usize\n+    head: usize,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1668,7 +1765,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n         Iter {\n             ring: self.ring,\n             tail: self.tail,\n-            head: self.head\n+            head: self.head,\n         }\n     }\n }\n@@ -1711,7 +1808,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n /// `VecDeque` mutable iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, T:'a> {\n+pub struct IterMut<'a, T: 'a> {\n     ring: &'a mut [T],\n     tail: usize,\n     head: usize,\n@@ -1845,13 +1942,15 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n             (_, 0) => {\n                 source_deque.head = drain_tail;\n             }\n-            _ => unsafe {\n-                if tail_len <= head_len {\n-                    source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n-                    source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n-                } else {\n-                    source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n-                    source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+            _ => {\n+                unsafe {\n+                    if tail_len <= head_len {\n+                        source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n+                        source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                    } else {\n+                        source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n+                        source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+                    }\n                 }\n             }\n         }\n@@ -1864,11 +1963,7 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt|\n-            unsafe {\n-                ptr::read(elt)\n-            }\n-        )\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt) })\n     }\n \n     #[inline]\n@@ -1881,11 +1976,7 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt|\n-            unsafe {\n-                ptr::read(elt)\n-            }\n-        )\n+        self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n     }\n }\n \n@@ -1895,8 +1986,7 @@ impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for VecDeque<A> {\n     fn eq(&self, other: &VecDeque<A>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other).all(|(a, b)| a.eq(b))\n+        self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a.eq(b))\n     }\n }\n \n@@ -1948,7 +2038,7 @@ impl<A> IndexMut<usize> for VecDeque<A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for VecDeque<A> {\n-    fn from_iter<T: IntoIterator<Item=A>>(iterable: T) -> VecDeque<A> {\n+    fn from_iter<T: IntoIterator<Item = A>>(iterable: T) -> VecDeque<A> {\n         let iterator = iterable.into_iter();\n         let (lower, _) = iterator.size_hint();\n         let mut deq = VecDeque::with_capacity(lower);\n@@ -1965,9 +2055,7 @@ impl<T> IntoIterator for VecDeque<T> {\n     /// Consumes the list into a front-to-back iterator yielding elements by\n     /// value.\n     fn into_iter(self) -> IntoIter<T> {\n-        IntoIter {\n-            inner: self,\n-        }\n+        IntoIter { inner: self }\n     }\n }\n \n@@ -1993,7 +2081,7 @@ impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for VecDeque<A> {\n-    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n         for elt in iter {\n             self.push_back(elt);\n         }\n@@ -2002,7 +2090,7 @@ impl<A> Extend<A> for VecDeque<A> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n@@ -2049,7 +2137,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq= VecDeque::<i32>::with_capacity(101);\n+        let mut deq = VecDeque::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -2204,10 +2292,8 @@ mod tests {\n                         }\n \n                         // Check that we drain the correct values\n-                        let drained: VecDeque<_> =\n-                            tester.drain(drain_start..drain_end).collect();\n-                        let drained_expected: VecDeque<_> =\n-                            (drain_start..drain_end).collect();\n+                        let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n+                        let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n                         assert_eq!(drained, drained_expected);\n \n                         // We shouldn't have changed the capacity or made the\n@@ -2217,8 +2303,9 @@ mod tests {\n                         assert!(tester.head < tester.cap());\n \n                         // We should see the correct values in the VecDeque\n-                        let expected: VecDeque<_> =\n-                            (0..drain_start).chain(drain_end..len).collect();\n+                        let expected: VecDeque<_> = (0..drain_start)\n+                                                        .chain(drain_end..len)\n+                                                        .collect();\n                         assert_eq!(expected, tester);\n                     }\n                 }"}]}