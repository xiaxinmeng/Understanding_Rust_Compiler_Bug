{"sha": "76530664e7f01091e0d820eb49bf59db1f06115c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NTMwNjY0ZTdmMDEwOTFlMGQ4MjBlYjQ5YmY1OWRiMWYwNjExNWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-13T18:34:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-13T18:34:32Z"}, "message": "Merge #9255\n\n9255: internal: remove DiagnosticWithFix infra r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9700c178acb48fcc029f4120169f00a94d7308f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9700c178acb48fcc029f4120169f00a94d7308f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76530664e7f01091e0d820eb49bf59db1f06115c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgxk+4CRBK7hj4Ov3rIwAANIIIAJoDcccQKEXbZEsiE6CE1AN+\n7ST31LdM4AQUhDdYMOTicvvMGuDyWEwxMExVo+ONd3CqfU7E1ux+kqaoujCQsgaS\nbPVn3SYmBP7gVdQlkHcphZ/sMuyyNyuhMxP9iuiH6wt2UcD6p6NSE9W5Ur6a4Ddi\nG14AfVzO4l/yC706Rka0DEnMiq7RtfDRGdMLgVdAwdgR19K+EBargHc/FREihdpo\nlHimacYsoGvmpaFqIelFbl/gSo3Rx//6kDR39UXNJ45ZH28h0e+qRsaypG2K+27i\nYFheeEgPtx01smYd5yOg+tzqMyt5rRYJ1IB9LeZ5tK7o1p4CuLt4bZ//Wul+o4s=\n=4v4C\n-----END PGP SIGNATURE-----\n", "payload": "tree 9700c178acb48fcc029f4120169f00a94d7308f0\nparent 2ad78924621420cb323efdeb3d875ca3f47d940f\nparent 3478897f86cc1b3e3f83e9d4e7cedff41721fb04\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623609272 +0000\ncommitter GitHub <noreply@github.com> 1623609272 +0000\n\nMerge #9255\n\n9255: internal: remove DiagnosticWithFix infra r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76530664e7f01091e0d820eb49bf59db1f06115c", "html_url": "https://github.com/rust-lang/rust/commit/76530664e7f01091e0d820eb49bf59db1f06115c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76530664e7f01091e0d820eb49bf59db1f06115c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ad78924621420cb323efdeb3d875ca3f47d940f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad78924621420cb323efdeb3d875ca3f47d940f", "html_url": "https://github.com/rust-lang/rust/commit/2ad78924621420cb323efdeb3d875ca3f47d940f"}, {"sha": "3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "url": "https://api.github.com/repos/rust-lang/rust/commits/3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "html_url": "https://github.com/rust-lang/rust/commit/3478897f86cc1b3e3f83e9d4e7cedff41721fb04"}], "stats": {"total": 1507, "additions": 713, "deletions": 794}, "files": [{"sha": "c2d608eb53c23837a6ae7a5e69266f7a6564ede5", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=76530664e7f01091e0d820eb49bf59db1f06115c", "patch": "@@ -34,6 +34,7 @@ macro_rules! diagnostics {\n diagnostics![\n     BreakOutsideOfLoop,\n     InactiveCode,\n+    IncorrectCase,\n     MacroError,\n     MismatchedArgCount,\n     MissingFields,\n@@ -195,31 +196,3 @@ impl Diagnostic for InternalBailedOut {\n }\n \n pub use hir_ty::diagnostics::IncorrectCase;\n-\n-impl Diagnostic for IncorrectCase {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"incorrect-ident-case\")\n-    }\n-\n-    fn message(&self) -> String {\n-        format!(\n-            \"{} `{}` should have {} name, e.g. `{}`\",\n-            self.ident_type,\n-            self.ident_text,\n-            self.expected_case.to_string(),\n-            self.suggested_text\n-        )\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.ident.clone().into())\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-\n-    fn is_experimental(&self) -> bool {\n-        true\n-    }\n-}"}, {"sha": "fc147ade395ab5c3e3015ddbfc305a15e9d062fc", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=76530664e7f01091e0d820eb49bf59db1f06115c", "patch": "@@ -86,8 +86,8 @@ use crate::{\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, InternalBailedOut, MacroError,\n-        MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InternalBailedOut,\n+        MacroError, MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n         MissingUnsafe, NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n         UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n         UnresolvedModule, UnresolvedProcMacro,\n@@ -340,7 +340,7 @@ impl ModuleDef {\n         }\n     }\n \n-    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n+    pub fn diagnostics(self, db: &dyn HirDatabase) -> Vec<AnyDiagnostic> {\n         let id = match self {\n             ModuleDef::Adt(it) => match it {\n                 Adt::Struct(it) => it.id.into(),\n@@ -353,17 +353,19 @@ impl ModuleDef {\n             ModuleDef::Module(it) => it.id.into(),\n             ModuleDef::Const(it) => it.id.into(),\n             ModuleDef::Static(it) => it.id.into(),\n-            _ => return,\n+            _ => return Vec::new(),\n         };\n \n         let module = match self.module(db) {\n             Some(it) => it,\n-            None => return,\n+            None => return Vec::new(),\n         };\n \n+        let mut acc = Vec::new();\n         for diag in hir_ty::diagnostics::validate_module_item(db, module.id.krate(), id) {\n-            sink.push(diag)\n+            acc.push(diag.into())\n         }\n+        acc\n     }\n }\n \n@@ -624,7 +626,7 @@ impl Module {\n                         acc.extend(m.diagnostics(db, sink, internal_diagnostics))\n                     }\n                 }\n-                _ => decl.diagnostics(db, sink),\n+                _ => acc.extend(decl.diagnostics(db)),\n             }\n         }\n \n@@ -1234,7 +1236,7 @@ impl Function {\n         }\n \n         for diag in hir_ty::diagnostics::validate_module_item(db, krate, self.id.into()) {\n-            sink.push(diag)\n+            acc.push(diag.into())\n         }\n         acc\n     }"}, {"sha": "6339c9687cd8f753d93cb9dda492eff75f1005c2", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=76530664e7f01091e0d820eb49bf59db1f06115c", "patch": "@@ -84,9 +84,6 @@ impl fmt::Display for IdentType {\n     }\n }\n \n-// Diagnostic: incorrect-ident-case\n-//\n-// This diagnostic is triggered if an item name doesn't follow https://doc.rust-lang.org/1.0.0/style/style/naming/README.html[Rust naming convention].\n #[derive(Debug)]\n pub struct IncorrectCase {\n     pub file: HirFileId,"}, {"sha": "7978c1fc225b8bd1bfec4dfc5fbf71fd676704be", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 24, "deletions": 506, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=76530664e7f01091e0d820eb49bf59db1f06115c", "patch": "@@ -6,6 +6,7 @@\n \n mod break_outside_of_loop;\n mod inactive_code;\n+mod incorrect_case;\n mod macro_error;\n mod mismatched_arg_count;\n mod missing_fields;\n@@ -15,20 +16,19 @@ mod no_such_field;\n mod remove_this_semicolon;\n mod replace_filter_map_next_with_find_map;\n mod unimplemented_builtin_macro;\n+mod unlinked_file;\n mod unresolved_extern_crate;\n mod unresolved_import;\n mod unresolved_macro_call;\n mod unresolved_module;\n mod unresolved_proc_macro;\n \n-mod fixes;\n mod field_shorthand;\n-mod unlinked_file;\n \n use std::cell::RefCell;\n \n use hir::{\n-    diagnostics::{AnyDiagnostic, Diagnostic as _, DiagnosticCode, DiagnosticSinkBuilder},\n+    diagnostics::{AnyDiagnostic, DiagnosticCode, DiagnosticSinkBuilder},\n     Semantics,\n };\n use ide_assists::AssistResolveStrategy;\n@@ -37,15 +37,13 @@ use itertools::Itertools;\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, AstNode},\n-    SyntaxNode, SyntaxNodePtr, TextRange, TextSize,\n+    SyntaxNode, TextRange,\n };\n use text_edit::TextEdit;\n use unlinked_file::UnlinkedFile;\n \n use crate::{Assist, AssistId, AssistKind, FileId, Label, SourceChange};\n \n-use self::fixes::DiagnosticWithFixes;\n-\n #[derive(Debug)]\n pub struct Diagnostic {\n     // pub name: Option<String>,\n@@ -135,7 +133,6 @@ pub struct DiagnosticsConfig {\n struct DiagnosticsContext<'a> {\n     config: &'a DiagnosticsConfig,\n     sema: Semantics<'a, RootDatabase>,\n-    #[allow(unused)]\n     resolve: &'a AssistResolveStrategy,\n }\n \n@@ -165,22 +162,6 @@ pub(crate) fn diagnostics(\n     }\n     let res = RefCell::new(res);\n     let sink_builder = DiagnosticSinkBuilder::new()\n-        .on::<hir::diagnostics::IncorrectCase, _>(|d| {\n-            res.borrow_mut().push(warning_with_fix(d, &sema, resolve));\n-        })\n-        .on::<UnlinkedFile, _>(|d| {\n-            // Limit diagnostic to the first few characters in the file. This matches how VS Code\n-            // renders it with the full span, but on other editors, and is less invasive.\n-            let range = sema.diagnostics_display_range(d.display_source()).range;\n-            let range = range.intersect(TextRange::up_to(TextSize::of(\"...\"))).unwrap_or(range);\n-\n-            // Override severity and mark as unused.\n-            res.borrow_mut().push(\n-                Diagnostic::hint(range, d.message())\n-                    .with_fixes(d.fixes(&sema, resolve))\n-                    .with_code(Some(d.code())),\n-            );\n-        })\n         // Only collect experimental diagnostics when they're enabled.\n         .filter(|diag| !(diag.is_experimental() && config.disable_experimental))\n         .filter(|diag| !config.disabled.contains(diag.code().as_str()));\n@@ -200,22 +181,27 @@ pub(crate) fn diagnostics(\n \n     let mut diags = Vec::new();\n     let internal_diagnostics = cfg!(test);\n-    match sema.to_module_def(file_id) {\n-        Some(m) => diags = m.diagnostics(db, &mut sink, internal_diagnostics),\n-        None => {\n-            sink.push(UnlinkedFile { file_id, node: SyntaxNodePtr::new(parse.tree().syntax()) });\n-        }\n+    let module = sema.to_module_def(file_id);\n+    if let Some(m) = module {\n+        diags = m.diagnostics(db, &mut sink, internal_diagnostics)\n     }\n \n     drop(sink);\n \n     let mut res = res.into_inner();\n \n     let ctx = DiagnosticsContext { config, sema, resolve };\n+    if module.is_none() {\n+        let d = UnlinkedFile { file: file_id };\n+        let d = unlinked_file::unlinked_file(&ctx, &d);\n+        res.push(d)\n+    }\n+\n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n             AnyDiagnostic::BreakOutsideOfLoop(d) => break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n+            AnyDiagnostic::IncorrectCase(d) => incorrect_case::incorrect_case(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n@@ -236,30 +222,24 @@ pub(crate) fn diagnostics(\n                 None => continue,\n             }\n         };\n+        res.push(d)\n+    }\n+\n+    res.retain(|d| {\n         if let Some(code) = d.code {\n             if ctx.config.disabled.contains(code.as_str()) {\n-                continue;\n+                return false;\n             }\n         }\n         if ctx.config.disable_experimental && d.experimental {\n-            continue;\n+            return false;\n         }\n-        res.push(d)\n-    }\n+        true\n+    });\n \n     res\n }\n \n-fn warning_with_fix<D: DiagnosticWithFixes>(\n-    d: &D,\n-    sema: &Semantics<RootDatabase>,\n-    resolve: &AssistResolveStrategy,\n-) -> Diagnostic {\n-    Diagnostic::hint(sema.diagnostics_display_range(d.display_source()).range, d.message())\n-        .with_fixes(d.fixes(sema, resolve))\n-        .with_code(Some(d.code()))\n-}\n-\n fn check_unnecessary_braces_in_use_statement(\n     acc: &mut Vec<Diagnostic>,\n     file_id: FileId,\n@@ -390,8 +370,9 @@ mod tests {\n             file_position.offset\n         );\n     }\n+\n     /// Checks that there's a diagnostic *without* fix at `$0`.\n-    fn check_no_fix(ra_fixture: &str) {\n+    pub(crate) fn check_no_fix(ra_fixture: &str) {\n         let (analysis, file_position) = fixture::position(ra_fixture);\n         let diagnostic = analysis\n             .diagnostics(\n@@ -535,142 +516,6 @@ mod a {\n         assert!(!diagnostics.is_empty());\n     }\n \n-    #[test]\n-    fn unlinked_file_prepend_first_item() {\n-        cov_mark::check!(unlinked_file_prepend_before_first_item);\n-        // Only tests the first one for `pub mod` since the rest are the same\n-        check_fixes(\n-            r#\"\n-//- /main.rs\n-fn f() {}\n-//- /foo.rs\n-$0\n-\"#,\n-            vec![\n-                r#\"\n-mod foo;\n-\n-fn f() {}\n-\"#,\n-                r#\"\n-pub mod foo;\n-\n-fn f() {}\n-\"#,\n-            ],\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_append_mod() {\n-        cov_mark::check!(unlinked_file_append_to_existing_mods);\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-//! Comment on top\n-\n-mod preexisting;\n-\n-mod preexisting2;\n-\n-struct S;\n-\n-mod preexisting_bottom;)\n-//- /foo.rs\n-$0\n-\"#,\n-            r#\"\n-//! Comment on top\n-\n-mod preexisting;\n-\n-mod preexisting2;\n-mod foo;\n-\n-struct S;\n-\n-mod preexisting_bottom;)\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_insert_in_empty_file() {\n-        cov_mark::check!(unlinked_file_empty_file);\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-//- /foo.rs\n-$0\n-\"#,\n-            r#\"\n-mod foo;\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_old_style_modrs() {\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-mod submod;\n-//- /submod/mod.rs\n-// in mod.rs\n-//- /submod/foo.rs\n-$0\n-\"#,\n-            r#\"\n-// in mod.rs\n-mod foo;\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_new_style_mod() {\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-mod submod;\n-//- /submod.rs\n-//- /submod/foo.rs\n-$0\n-\"#,\n-            r#\"\n-mod foo;\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_with_cfg_off() {\n-        cov_mark::check!(unlinked_file_skip_fix_when_mod_already_exists);\n-        check_no_fix(\n-            r#\"\n-//- /main.rs\n-#[cfg(never)]\n-mod foo;\n-\n-//- /foo.rs\n-$0\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_with_cfg_on() {\n-        check_diagnostics(\n-            r#\"\n-//- /main.rs\n-#[cfg(not(never))]\n-mod foo;\n-\n-//- /foo.rs\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn import_extern_crate_clash_with_inner_item() {\n         // This is more of a resolver test, but doesn't really work with the hir_def testsuite.\n@@ -1607,330 +1452,3 @@ fn main() {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod decl_check_tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n-\n-    #[test]\n-    fn incorrect_function_name() {\n-        check_diagnostics(\n-            r#\"\n-fn NonSnakeCaseName() {}\n-// ^^^^^^^^^^^^^^^^ Function `NonSnakeCaseName` should have snake_case name, e.g. `non_snake_case_name`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_function_params() {\n-        check_diagnostics(\n-            r#\"\n-fn foo(SomeParam: u8) {}\n-    // ^^^^^^^^^ Parameter `SomeParam` should have snake_case name, e.g. `some_param`\n-\n-fn foo2(ok_param: &str, CAPS_PARAM: u8) {}\n-                     // ^^^^^^^^^^ Parameter `CAPS_PARAM` should have snake_case name, e.g. `caps_param`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_variable_names() {\n-        check_diagnostics(\n-            r#\"\n-fn foo() {\n-    let SOME_VALUE = 10;\n-     // ^^^^^^^^^^ Variable `SOME_VALUE` should have snake_case name, e.g. `some_value`\n-    let AnotherValue = 20;\n-     // ^^^^^^^^^^^^ Variable `AnotherValue` should have snake_case name, e.g. `another_value`\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_struct_names() {\n-        check_diagnostics(\n-            r#\"\n-struct non_camel_case_name {}\n-    // ^^^^^^^^^^^^^^^^^^^ Structure `non_camel_case_name` should have CamelCase name, e.g. `NonCamelCaseName`\n-\n-struct SCREAMING_CASE {}\n-    // ^^^^^^^^^^^^^^ Structure `SCREAMING_CASE` should have CamelCase name, e.g. `ScreamingCase`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_diagnostic_for_camel_cased_acronyms_in_struct_name() {\n-        check_diagnostics(\n-            r#\"\n-struct AABB {}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_struct_field() {\n-        check_diagnostics(\n-            r#\"\n-struct SomeStruct { SomeField: u8 }\n-                 // ^^^^^^^^^ Field `SomeField` should have snake_case name, e.g. `some_field`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_enum_names() {\n-        check_diagnostics(\n-            r#\"\n-enum some_enum { Val(u8) }\n-  // ^^^^^^^^^ Enum `some_enum` should have CamelCase name, e.g. `SomeEnum`\n-\n-enum SOME_ENUM {}\n-  // ^^^^^^^^^ Enum `SOME_ENUM` should have CamelCase name, e.g. `SomeEnum`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_diagnostic_for_camel_cased_acronyms_in_enum_name() {\n-        check_diagnostics(\n-            r#\"\n-enum AABB {}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_enum_variant_name() {\n-        check_diagnostics(\n-            r#\"\n-enum SomeEnum { SOME_VARIANT(u8) }\n-             // ^^^^^^^^^^^^ Variant `SOME_VARIANT` should have CamelCase name, e.g. `SomeVariant`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_const_name() {\n-        check_diagnostics(\n-            r#\"\n-const some_weird_const: u8 = 10;\n-   // ^^^^^^^^^^^^^^^^ Constant `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_static_name() {\n-        check_diagnostics(\n-            r#\"\n-static some_weird_const: u8 = 10;\n-    // ^^^^^^^^^^^^^^^^ Static variable `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fn_inside_impl_struct() {\n-        check_diagnostics(\n-            r#\"\n-struct someStruct;\n-    // ^^^^^^^^^^ Structure `someStruct` should have CamelCase name, e.g. `SomeStruct`\n-\n-impl someStruct {\n-    fn SomeFunc(&self) {\n-    // ^^^^^^^^ Function `SomeFunc` should have snake_case name, e.g. `some_func`\n-        let WHY_VAR_IS_CAPS = 10;\n-         // ^^^^^^^^^^^^^^^ Variable `WHY_VAR_IS_CAPS` should have snake_case name, e.g. `why_var_is_caps`\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_diagnostic_for_enum_varinats() {\n-        check_diagnostics(\n-            r#\"\n-enum Option { Some, None }\n-\n-fn main() {\n-    match Option::None {\n-        None => (),\n-        Some => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn non_let_bind() {\n-        check_diagnostics(\n-            r#\"\n-enum Option { Some, None }\n-\n-fn main() {\n-    match Option::None {\n-        SOME_VAR @ None => (),\n-     // ^^^^^^^^ Variable `SOME_VAR` should have snake_case name, e.g. `some_var`\n-        Some => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn allow_attributes() {\n-        check_diagnostics(\n-            r#\"\n-#[allow(non_snake_case)]\n-fn NonSnakeCaseName(SOME_VAR: u8) -> u8{\n-    // cov_flags generated output from elsewhere in this file\n-    extern \"C\" {\n-        #[no_mangle]\n-        static lower_case: u8;\n-    }\n-\n-    let OtherVar = SOME_VAR + 1;\n-    OtherVar\n-}\n-\n-#[allow(nonstandard_style)]\n-mod CheckNonstandardStyle {\n-    fn HiImABadFnName() {}\n-}\n-\n-#[allow(bad_style)]\n-mod CheckBadStyle {\n-    fn HiImABadFnName() {}\n-}\n-\n-mod F {\n-    #![allow(non_snake_case)]\n-    fn CheckItWorksWithModAttr(BAD_NAME_HI: u8) {}\n-}\n-\n-#[allow(non_snake_case, non_camel_case_types)]\n-pub struct some_type {\n-    SOME_FIELD: u8,\n-    SomeField: u16,\n-}\n-\n-#[allow(non_upper_case_globals)]\n-pub const some_const: u8 = 10;\n-\n-#[allow(non_upper_case_globals)]\n-pub static SomeStatic: u8 = 10;\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn allow_attributes_crate_attr() {\n-        check_diagnostics(\n-            r#\"\n-#![allow(non_snake_case)]\n-\n-mod F {\n-    fn CheckItWorksWithCrateAttr(BAD_NAME_HI: u8) {}\n-}\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn bug_trait_inside_fn() {\n-        // FIXME:\n-        // This is broken, and in fact, should not even be looked at by this\n-        // lint in the first place. There's weird stuff going on in the\n-        // collection phase.\n-        // It's currently being brought in by:\n-        // * validate_func on `a` recursing into modules\n-        // * then it finds the trait and then the function while iterating\n-        //   through modules\n-        // * then validate_func is called on Dirty\n-        // * ... which then proceeds to look at some unknown module taking no\n-        //   attrs from either the impl or the fn a, and then finally to the root\n-        //   module\n-        //\n-        // It should find the attribute on the trait, but it *doesn't even see\n-        // the trait* as far as I can tell.\n-\n-        check_diagnostics(\n-            r#\"\n-trait T { fn a(); }\n-struct U {}\n-impl T for U {\n-    fn a() {\n-        // this comes out of bitflags, mostly\n-        #[allow(non_snake_case)]\n-        trait __BitFlags {\n-            const HiImAlsoBad: u8 = 2;\n-            #[inline]\n-            fn Dirty(&self) -> bool {\n-                false\n-            }\n-        }\n-\n-    }\n-}\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn bug_traits_arent_checked() {\n-        // FIXME: Traits and functions in traits aren't currently checked by\n-        // r-a, even though rustc will complain about them.\n-        check_diagnostics(\n-            r#\"\n-trait BAD_TRAIT {\n-    // ^^^^^^^^^ Trait `BAD_TRAIT` should have CamelCase name, e.g. `BadTrait`\n-    fn BAD_FUNCTION();\n-    // ^^^^^^^^^^^^ Function `BAD_FUNCTION` should have snake_case name, e.g. `bad_function`\n-    fn BadFunction();\n-    // ^^^^^^^^^^^^ Function `BadFunction` should have snake_case name, e.g. `bad_function`\n-}\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn ignores_extern_items() {\n-        cov_mark::check!(extern_func_incorrect_case_ignored);\n-        cov_mark::check!(extern_static_incorrect_case_ignored);\n-        check_diagnostics(\n-            r#\"\n-extern {\n-    fn NonSnakeCaseName(SOME_VAR: u8) -> u8;\n-    pub static SomeStatic: u8 = 10;\n-}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn infinite_loop_inner_items() {\n-        check_diagnostics(\n-            r#\"\n-fn qualify() {\n-    mod foo {\n-        use super::*;\n-    }\n-}\n-            \"#,\n-        )\n-    }\n-\n-    #[test] // Issue #8809.\n-    fn parenthesized_parameter() {\n-        check_diagnostics(r#\"fn f((O): _) {}\"#)\n-    }\n-}"}, {"sha": "e4bd90c3fc396e365de0825bc8d32bd6ef7ce46f", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -1,25 +0,0 @@\n-//! Provides a way to attach fixes to the diagnostics.\n-//! The same module also has all curret custom fixes for the diagnostics implemented.\n-mod change_case;\n-\n-use hir::{diagnostics::Diagnostic, Semantics};\n-use ide_assists::AssistResolveStrategy;\n-use ide_db::RootDatabase;\n-\n-use crate::Assist;\n-\n-/// A [Diagnostic] that potentially has some fixes available.\n-///\n-/// [Diagnostic]: hir::diagnostics::Diagnostic\n-pub(crate) trait DiagnosticWithFixes: Diagnostic {\n-    /// `resolve` determines if the diagnostic should fill in the `edit` field\n-    /// of the assist.\n-    ///\n-    /// If `resolve` is false, the edit will be computed later, on demand, and\n-    /// can be omitted.\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>>;\n-}"}, {"sha": "db1a37cd6fe1cb79409ada381bcb2750c884d6bf", "filename": "crates/ide/src/diagnostics/fixes/change_case.rs", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fchange_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fchange_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fchange_case.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -1,155 +0,0 @@\n-use hir::{db::AstDatabase, diagnostics::IncorrectCase, InFile, Semantics};\n-use ide_assists::{Assist, AssistResolveStrategy};\n-use ide_db::{base_db::FilePosition, RootDatabase};\n-use syntax::AstNode;\n-\n-use crate::{\n-    diagnostics::{unresolved_fix, DiagnosticWithFixes},\n-    references::rename::rename_with_semantics,\n-};\n-\n-impl DiagnosticWithFixes for IncorrectCase {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let name_node = self.ident.to_node(&root);\n-\n-        let name_node = InFile::new(self.file, name_node.syntax());\n-        let frange = name_node.original_file_range(sema.db);\n-        let file_position = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n-\n-        let label = format!(\"Rename to {}\", self.suggested_text);\n-        let mut res = unresolved_fix(\"change_case\", &label, frange.range);\n-        if resolve.should_resolve(&res.id) {\n-            let source_change = rename_with_semantics(sema, file_position, &self.suggested_text);\n-            res.source_change = Some(source_change.ok().unwrap_or_default());\n-        }\n-\n-        Some(vec![res])\n-    }\n-}\n-\n-#[cfg(test)]\n-mod change_case {\n-    use crate::{\n-        diagnostics::tests::{check_diagnostics, check_fix},\n-        fixture, AssistResolveStrategy, DiagnosticsConfig,\n-    };\n-\n-    #[test]\n-    fn test_rename_incorrect_case() {\n-        check_fix(\n-            r#\"\n-pub struct test_struct$0 { one: i32 }\n-\n-pub fn some_fn(val: test_struct) -> test_struct {\n-    test_struct { one: val.one + 1 }\n-}\n-\"#,\n-            r#\"\n-pub struct TestStruct { one: i32 }\n-\n-pub fn some_fn(val: TestStruct) -> TestStruct {\n-    TestStruct { one: val.one + 1 }\n-}\n-\"#,\n-        );\n-\n-        check_fix(\n-            r#\"\n-pub fn some_fn(NonSnakeCase$0: u8) -> u8 {\n-    NonSnakeCase\n-}\n-\"#,\n-            r#\"\n-pub fn some_fn(non_snake_case: u8) -> u8 {\n-    non_snake_case\n-}\n-\"#,\n-        );\n-\n-        check_fix(\n-            r#\"\n-pub fn SomeFn$0(val: u8) -> u8 {\n-    if val != 0 { SomeFn(val - 1) } else { val }\n-}\n-\"#,\n-            r#\"\n-pub fn some_fn(val: u8) -> u8 {\n-    if val != 0 { some_fn(val - 1) } else { val }\n-}\n-\"#,\n-        );\n-\n-        check_fix(\n-            r#\"\n-fn some_fn() {\n-    let whatAWeird_Formatting$0 = 10;\n-    another_func(whatAWeird_Formatting);\n-}\n-\"#,\n-            r#\"\n-fn some_fn() {\n-    let what_a_weird_formatting = 10;\n-    another_func(what_a_weird_formatting);\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_uppercase_const_no_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-fn foo() {\n-    const ANOTHER_ITEM$0: &str = \"some_item\";\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_rename_incorrect_case_struct_method() {\n-        check_fix(\n-            r#\"\n-pub struct TestStruct;\n-\n-impl TestStruct {\n-    pub fn SomeFn$0() -> TestStruct {\n-        TestStruct\n-    }\n-}\n-\"#,\n-            r#\"\n-pub struct TestStruct;\n-\n-impl TestStruct {\n-    pub fn some_fn() -> TestStruct {\n-        TestStruct\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_single_incorrect_case_diagnostic_in_function_name_issue_6970() {\n-        let input = r#\"fn FOO$0() {}\"#;\n-        let expected = r#\"fn foo() {}\"#;\n-\n-        let (analysis, file_position) = fixture::position(input);\n-        let diagnostics = analysis\n-            .diagnostics(\n-                &DiagnosticsConfig::default(),\n-                AssistResolveStrategy::All,\n-                file_position.file_id,\n-            )\n-            .unwrap();\n-        assert_eq!(diagnostics.len(), 1);\n-\n-        check_fix(input, expected);\n-    }\n-}"}, {"sha": "83239440042a2347cda9490839912239a45b13f7", "filename": "crates/ide/src/diagnostics/incorrect_case.rs", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fide%2Fsrc%2Fdiagnostics%2Fincorrect_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fide%2Fsrc%2Fdiagnostics%2Fincorrect_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fincorrect_case.rs?ref=76530664e7f01091e0d820eb49bf59db1f06115c", "patch": "@@ -0,0 +1,488 @@\n+use hir::{db::AstDatabase, InFile};\n+use ide_assists::Assist;\n+use ide_db::base_db::FilePosition;\n+use syntax::AstNode;\n+\n+use crate::{\n+    diagnostics::{unresolved_fix, Diagnostic, DiagnosticsContext},\n+    references::rename::rename_with_semantics,\n+    Severity,\n+};\n+\n+// Diagnostic: incorrect-ident-case\n+//\n+// This diagnostic is triggered if an item name doesn't follow https://doc.rust-lang.org/1.0.0/style/style/naming/README.html[Rust naming convention].\n+pub(super) fn incorrect_case(ctx: &DiagnosticsContext<'_>, d: &hir::IncorrectCase) -> Diagnostic {\n+    Diagnostic::new(\n+        \"incorrect-ident-case\",\n+        format!(\n+            \"{} `{}` should have {} name, e.g. `{}`\",\n+            d.ident_type, d.ident_text, d.expected_case, d.suggested_text\n+        ),\n+        ctx.sema.diagnostics_display_range(InFile::new(d.file, d.ident.clone().into())).range,\n+    )\n+    .severity(Severity::WeakWarning)\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::IncorrectCase) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(d.file)?;\n+    let name_node = d.ident.to_node(&root);\n+\n+    let name_node = InFile::new(d.file, name_node.syntax());\n+    let frange = name_node.original_file_range(ctx.sema.db);\n+    let file_position = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n+\n+    let label = format!(\"Rename to {}\", d.suggested_text);\n+    let mut res = unresolved_fix(\"change_case\", &label, frange.range);\n+    if ctx.resolve.should_resolve(&res.id) {\n+        let source_change = rename_with_semantics(&ctx.sema, file_position, &d.suggested_text);\n+        res.source_change = Some(source_change.ok().unwrap_or_default());\n+    }\n+\n+    Some(vec![res])\n+}\n+\n+#[cfg(test)]\n+mod change_case {\n+    use crate::{\n+        diagnostics::tests::{check_diagnostics, check_fix},\n+        fixture, AssistResolveStrategy, DiagnosticsConfig,\n+    };\n+\n+    #[test]\n+    fn test_rename_incorrect_case() {\n+        check_fix(\n+            r#\"\n+pub struct test_struct$0 { one: i32 }\n+\n+pub fn some_fn(val: test_struct) -> test_struct {\n+    test_struct { one: val.one + 1 }\n+}\n+\"#,\n+            r#\"\n+pub struct TestStruct { one: i32 }\n+\n+pub fn some_fn(val: TestStruct) -> TestStruct {\n+    TestStruct { one: val.one + 1 }\n+}\n+\"#,\n+        );\n+\n+        check_fix(\n+            r#\"\n+pub fn some_fn(NonSnakeCase$0: u8) -> u8 {\n+    NonSnakeCase\n+}\n+\"#,\n+            r#\"\n+pub fn some_fn(non_snake_case: u8) -> u8 {\n+    non_snake_case\n+}\n+\"#,\n+        );\n+\n+        check_fix(\n+            r#\"\n+pub fn SomeFn$0(val: u8) -> u8 {\n+    if val != 0 { SomeFn(val - 1) } else { val }\n+}\n+\"#,\n+            r#\"\n+pub fn some_fn(val: u8) -> u8 {\n+    if val != 0 { some_fn(val - 1) } else { val }\n+}\n+\"#,\n+        );\n+\n+        check_fix(\n+            r#\"\n+fn some_fn() {\n+    let whatAWeird_Formatting$0 = 10;\n+    another_func(whatAWeird_Formatting);\n+}\n+\"#,\n+            r#\"\n+fn some_fn() {\n+    let what_a_weird_formatting = 10;\n+    another_func(what_a_weird_formatting);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_uppercase_const_no_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    const ANOTHER_ITEM$0: &str = \"some_item\";\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_incorrect_case_struct_method() {\n+        check_fix(\n+            r#\"\n+pub struct TestStruct;\n+\n+impl TestStruct {\n+    pub fn SomeFn$0() -> TestStruct {\n+        TestStruct\n+    }\n+}\n+\"#,\n+            r#\"\n+pub struct TestStruct;\n+\n+impl TestStruct {\n+    pub fn some_fn() -> TestStruct {\n+        TestStruct\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_single_incorrect_case_diagnostic_in_function_name_issue_6970() {\n+        let input = r#\"fn FOO$0() {}\"#;\n+        let expected = r#\"fn foo() {}\"#;\n+\n+        let (analysis, file_position) = fixture::position(input);\n+        let diagnostics = analysis\n+            .diagnostics(\n+                &DiagnosticsConfig::default(),\n+                AssistResolveStrategy::All,\n+                file_position.file_id,\n+            )\n+            .unwrap();\n+        assert_eq!(diagnostics.len(), 1);\n+\n+        check_fix(input, expected);\n+    }\n+\n+    #[test]\n+    fn incorrect_function_name() {\n+        check_diagnostics(\n+            r#\"\n+fn NonSnakeCaseName() {}\n+// ^^^^^^^^^^^^^^^^ Function `NonSnakeCaseName` should have snake_case name, e.g. `non_snake_case_name`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_function_params() {\n+        check_diagnostics(\n+            r#\"\n+fn foo(SomeParam: u8) {}\n+    // ^^^^^^^^^ Parameter `SomeParam` should have snake_case name, e.g. `some_param`\n+\n+fn foo2(ok_param: &str, CAPS_PARAM: u8) {}\n+                     // ^^^^^^^^^^ Parameter `CAPS_PARAM` should have snake_case name, e.g. `caps_param`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_variable_names() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let SOME_VALUE = 10;\n+     // ^^^^^^^^^^ Variable `SOME_VALUE` should have snake_case name, e.g. `some_value`\n+    let AnotherValue = 20;\n+     // ^^^^^^^^^^^^ Variable `AnotherValue` should have snake_case name, e.g. `another_value`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_struct_names() {\n+        check_diagnostics(\n+            r#\"\n+struct non_camel_case_name {}\n+    // ^^^^^^^^^^^^^^^^^^^ Structure `non_camel_case_name` should have CamelCase name, e.g. `NonCamelCaseName`\n+\n+struct SCREAMING_CASE {}\n+    // ^^^^^^^^^^^^^^ Structure `SCREAMING_CASE` should have CamelCase name, e.g. `ScreamingCase`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_camel_cased_acronyms_in_struct_name() {\n+        check_diagnostics(\n+            r#\"\n+struct AABB {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_struct_field() {\n+        check_diagnostics(\n+            r#\"\n+struct SomeStruct { SomeField: u8 }\n+                 // ^^^^^^^^^ Field `SomeField` should have snake_case name, e.g. `some_field`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_enum_names() {\n+        check_diagnostics(\n+            r#\"\n+enum some_enum { Val(u8) }\n+  // ^^^^^^^^^ Enum `some_enum` should have CamelCase name, e.g. `SomeEnum`\n+\n+enum SOME_ENUM {}\n+  // ^^^^^^^^^ Enum `SOME_ENUM` should have CamelCase name, e.g. `SomeEnum`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_camel_cased_acronyms_in_enum_name() {\n+        check_diagnostics(\n+            r#\"\n+enum AABB {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_enum_variant_name() {\n+        check_diagnostics(\n+            r#\"\n+enum SomeEnum { SOME_VARIANT(u8) }\n+             // ^^^^^^^^^^^^ Variant `SOME_VARIANT` should have CamelCase name, e.g. `SomeVariant`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_const_name() {\n+        check_diagnostics(\n+            r#\"\n+const some_weird_const: u8 = 10;\n+   // ^^^^^^^^^^^^^^^^ Constant `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_static_name() {\n+        check_diagnostics(\n+            r#\"\n+static some_weird_const: u8 = 10;\n+    // ^^^^^^^^^^^^^^^^ Static variable `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fn_inside_impl_struct() {\n+        check_diagnostics(\n+            r#\"\n+struct someStruct;\n+    // ^^^^^^^^^^ Structure `someStruct` should have CamelCase name, e.g. `SomeStruct`\n+\n+impl someStruct {\n+    fn SomeFunc(&self) {\n+    // ^^^^^^^^ Function `SomeFunc` should have snake_case name, e.g. `some_func`\n+        let WHY_VAR_IS_CAPS = 10;\n+         // ^^^^^^^^^^^^^^^ Variable `WHY_VAR_IS_CAPS` should have snake_case name, e.g. `why_var_is_caps`\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_enum_varinats() {\n+        check_diagnostics(\n+            r#\"\n+enum Option { Some, None }\n+\n+fn main() {\n+    match Option::None {\n+        None => (),\n+        Some => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_let_bind() {\n+        check_diagnostics(\n+            r#\"\n+enum Option { Some, None }\n+\n+fn main() {\n+    match Option::None {\n+        SOME_VAR @ None => (),\n+     // ^^^^^^^^ Variable `SOME_VAR` should have snake_case name, e.g. `some_var`\n+        Some => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn allow_attributes_crate_attr() {\n+        check_diagnostics(\n+            r#\"\n+#![allow(non_snake_case)]\n+\n+mod F {\n+    fn CheckItWorksWithCrateAttr(BAD_NAME_HI: u8) {}\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn bug_trait_inside_fn() {\n+        // FIXME:\n+        // This is broken, and in fact, should not even be looked at by this\n+        // lint in the first place. There's weird stuff going on in the\n+        // collection phase.\n+        // It's currently being brought in by:\n+        // * validate_func on `a` recursing into modules\n+        // * then it finds the trait and then the function while iterating\n+        //   through modules\n+        // * then validate_func is called on Dirty\n+        // * ... which then proceeds to look at some unknown module taking no\n+        //   attrs from either the impl or the fn a, and then finally to the root\n+        //   module\n+        //\n+        // It should find the attribute on the trait, but it *doesn't even see\n+        // the trait* as far as I can tell.\n+\n+        check_diagnostics(\n+            r#\"\n+trait T { fn a(); }\n+struct U {}\n+impl T for U {\n+    fn a() {\n+        // this comes out of bitflags, mostly\n+        #[allow(non_snake_case)]\n+        trait __BitFlags {\n+            const HiImAlsoBad: u8 = 2;\n+            #[inline]\n+            fn Dirty(&self) -> bool {\n+                false\n+            }\n+        }\n+\n+    }\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn infinite_loop_inner_items() {\n+        check_diagnostics(\n+            r#\"\n+fn qualify() {\n+    mod foo {\n+        use super::*;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test] // Issue #8809.\n+    fn parenthesized_parameter() {\n+        check_diagnostics(r#\"fn f((O): _) {}\"#)\n+    }\n+\n+    #[test]\n+    fn ignores_extern_items() {\n+        cov_mark::check!(extern_func_incorrect_case_ignored);\n+        cov_mark::check!(extern_static_incorrect_case_ignored);\n+        check_diagnostics(\n+            r#\"\n+extern {\n+    fn NonSnakeCaseName(SOME_VAR: u8) -> u8;\n+    pub static SomeStatic: u8 = 10;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn bug_traits_arent_checked() {\n+        // FIXME: Traits and functions in traits aren't currently checked by\n+        // r-a, even though rustc will complain about them.\n+        check_diagnostics(\n+            r#\"\n+trait BAD_TRAIT {\n+    // ^^^^^^^^^ Trait `BAD_TRAIT` should have CamelCase name, e.g. `BadTrait`\n+    fn BAD_FUNCTION();\n+    // ^^^^^^^^^^^^ Function `BAD_FUNCTION` should have snake_case name, e.g. `bad_function`\n+    fn BadFunction();\n+    // ^^^^^^^^^^^^ Function `BadFunction` should have snake_case name, e.g. `bad_function`\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn allow_attributes() {\n+        check_diagnostics(\n+            r#\"\n+#[allow(non_snake_case)]\n+fn NonSnakeCaseName(SOME_VAR: u8) -> u8{\n+    // cov_flags generated output from elsewhere in this file\n+    extern \"C\" {\n+        #[no_mangle]\n+        static lower_case: u8;\n+    }\n+\n+    let OtherVar = SOME_VAR + 1;\n+    OtherVar\n+}\n+\n+#[allow(nonstandard_style)]\n+mod CheckNonstandardStyle {\n+    fn HiImABadFnName() {}\n+}\n+\n+#[allow(bad_style)]\n+mod CheckBadStyle {\n+    fn HiImABadFnName() {}\n+}\n+\n+mod F {\n+    #![allow(non_snake_case)]\n+    fn CheckItWorksWithModAttr(BAD_NAME_HI: u8) {}\n+}\n+\n+#[allow(non_snake_case, non_camel_case_types)]\n+pub struct some_type {\n+    SOME_FIELD: u8,\n+    SomeField: u16,\n+}\n+\n+#[allow(non_upper_case_globals)]\n+pub const some_const: u8 = 10;\n+\n+#[allow(non_upper_case_globals)]\n+pub static SomeStatic: u8 = 10;\n+    \"#,\n+        );\n+    }\n+}"}, {"sha": "a5b2e339978c13aa1ae334bf85a791d36f529e51", "filename": "crates/ide/src/diagnostics/unlinked_file.rs", "status": "modified", "additions": 190, "deletions": 69, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76530664e7f01091e0d820eb49bf59db1f06115c/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs?ref=76530664e7f01091e0d820eb49bf59db1f06115c", "patch": "@@ -1,104 +1,84 @@\n //! Diagnostic emitted for files that aren't part of any crate.\n \n-use hir::{\n-    db::DefDatabase,\n-    diagnostics::{Diagnostic, DiagnosticCode},\n-    InFile,\n-};\n-use ide_assists::AssistResolveStrategy;\n+use hir::db::DefDatabase;\n use ide_db::{\n     base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n     source_change::SourceChange,\n     RootDatabase,\n };\n use syntax::{\n     ast::{self, ModuleItemOwner, NameOwner},\n-    AstNode, SyntaxNodePtr,\n+    AstNode, TextRange, TextSize,\n };\n use text_edit::TextEdit;\n \n use crate::{\n-    diagnostics::{fix, fixes::DiagnosticWithFixes},\n-    Assist,\n+    diagnostics::{fix, DiagnosticsContext},\n+    Assist, Diagnostic,\n };\n \n+#[derive(Debug)]\n+pub(crate) struct UnlinkedFile {\n+    pub(crate) file: FileId,\n+}\n+\n // Diagnostic: unlinked-file\n //\n // This diagnostic is shown for files that are not included in any crate, or files that are part of\n // crates rust-analyzer failed to discover. The file will not have IDE features available.\n-#[derive(Debug)]\n-pub(crate) struct UnlinkedFile {\n-    pub(crate) file_id: FileId,\n-    pub(crate) node: SyntaxNodePtr,\n+pub(super) fn unlinked_file(ctx: &DiagnosticsContext, d: &UnlinkedFile) -> Diagnostic {\n+    // Limit diagnostic to the first few characters in the file. This matches how VS Code\n+    // renders it with the full span, but on other editors, and is less invasive.\n+    let range = ctx.sema.db.parse(d.file).syntax_node().text_range();\n+    // FIXME: This is wrong if one of the first three characters is not ascii: `//\u042b`.\n+    let range = range.intersect(TextRange::up_to(TextSize::of(\"...\"))).unwrap_or(range);\n+\n+    Diagnostic::new(\"unlinked-file\", \"file not included in module tree\", range)\n+        .with_fixes(fixes(ctx, d))\n }\n \n-impl Diagnostic for UnlinkedFile {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unlinked-file\")\n-    }\n+fn fixes(ctx: &DiagnosticsContext, d: &UnlinkedFile) -> Option<Vec<Assist>> {\n+    // If there's an existing module that could add `mod` or `pub mod` items to include the unlinked file,\n+    // suggest that as a fix.\n \n-    fn message(&self) -> String {\n-        \"file not included in module tree\".to_string()\n-    }\n+    let source_root = ctx.sema.db.source_root(ctx.sema.db.file_source_root(d.file));\n+    let our_path = source_root.path_for_file(&d.file)?;\n+    let module_name = our_path.name_and_extension()?.0;\n \n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file_id.into(), self.node.clone())\n-    }\n+    // Candidates to look for:\n+    // - `mod.rs` in the same folder\n+    //   - we also check `main.rs` and `lib.rs`\n+    // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n+    let parent = our_path.parent()?;\n+    let mut paths = vec![parent.join(\"mod.rs\")?, parent.join(\"lib.rs\")?, parent.join(\"main.rs\")?];\n \n-    fn as_any(&self) -> &(dyn std::any::Any + Send + 'static) {\n-        self\n+    // `submod/bla.rs` -> `submod.rs`\n+    if let Some(newmod) = (|| {\n+        let name = parent.name_and_extension()?.0;\n+        parent.parent()?.join(&format!(\"{}.rs\", name))\n+    })() {\n+        paths.push(newmod);\n     }\n-}\n \n-impl DiagnosticWithFixes for UnlinkedFile {\n-    fn fixes(\n-        &self,\n-        sema: &hir::Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        // If there's an existing module that could add `mod` or `pub mod` items to include the unlinked file,\n-        // suggest that as a fix.\n-\n-        let source_root = sema.db.source_root(sema.db.file_source_root(self.file_id));\n-        let our_path = source_root.path_for_file(&self.file_id)?;\n-        let module_name = our_path.name_and_extension()?.0;\n-\n-        // Candidates to look for:\n-        // - `mod.rs` in the same folder\n-        //   - we also check `main.rs` and `lib.rs`\n-        // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n-        let parent = our_path.parent()?;\n-        let mut paths =\n-            vec![parent.join(\"mod.rs\")?, parent.join(\"lib.rs\")?, parent.join(\"main.rs\")?];\n-\n-        // `submod/bla.rs` -> `submod.rs`\n-        if let Some(newmod) = (|| {\n-            let name = parent.name_and_extension()?.0;\n-            parent.parent()?.join(&format!(\"{}.rs\", name))\n-        })() {\n-            paths.push(newmod);\n-        }\n+    for path in &paths {\n+        if let Some(parent_id) = source_root.file_for_path(path) {\n+            for krate in ctx.sema.db.relevant_crates(*parent_id).iter() {\n+                let crate_def_map = ctx.sema.db.crate_def_map(*krate);\n+                for (_, module) in crate_def_map.modules() {\n+                    if module.origin.is_inline() {\n+                        // We don't handle inline `mod parent {}`s, they use different paths.\n+                        continue;\n+                    }\n \n-        for path in &paths {\n-            if let Some(parent_id) = source_root.file_for_path(path) {\n-                for krate in sema.db.relevant_crates(*parent_id).iter() {\n-                    let crate_def_map = sema.db.crate_def_map(*krate);\n-                    for (_, module) in crate_def_map.modules() {\n-                        if module.origin.is_inline() {\n-                            // We don't handle inline `mod parent {}`s, they use different paths.\n-                            continue;\n-                        }\n-\n-                        if module.origin.file_id() == Some(*parent_id) {\n-                            return make_fixes(sema.db, *parent_id, module_name, self.file_id);\n-                        }\n+                    if module.origin.file_id() == Some(*parent_id) {\n+                        return make_fixes(ctx.sema.db, *parent_id, module_name, d.file);\n                     }\n                 }\n             }\n         }\n-\n-        None\n     }\n+\n+    None\n }\n \n fn make_fixes(\n@@ -181,3 +161,144 @@ fn make_fixes(\n         ),\n     ])\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::{check_diagnostics, check_fix, check_fixes, check_no_fix};\n+\n+    #[test]\n+    fn unlinked_file_prepend_first_item() {\n+        cov_mark::check!(unlinked_file_prepend_before_first_item);\n+        // Only tests the first one for `pub mod` since the rest are the same\n+        check_fixes(\n+            r#\"\n+//- /main.rs\n+fn f() {}\n+//- /foo.rs\n+$0\n+\"#,\n+            vec![\n+                r#\"\n+mod foo;\n+\n+fn f() {}\n+\"#,\n+                r#\"\n+pub mod foo;\n+\n+fn f() {}\n+\"#,\n+            ],\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_append_mod() {\n+        cov_mark::check!(unlinked_file_append_to_existing_mods);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+//! Comment on top\n+\n+mod preexisting;\n+\n+mod preexisting2;\n+\n+struct S;\n+\n+mod preexisting_bottom;)\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+//! Comment on top\n+\n+mod preexisting;\n+\n+mod preexisting2;\n+mod foo;\n+\n+struct S;\n+\n+mod preexisting_bottom;)\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_in_empty_file() {\n+        cov_mark::check!(unlinked_file_empty_file);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_old_style_modrs() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod submod;\n+//- /submod/mod.rs\n+// in mod.rs\n+//- /submod/foo.rs\n+$0\n+\"#,\n+            r#\"\n+// in mod.rs\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_new_style_mod() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod submod;\n+//- /submod.rs\n+//- /submod/foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_with_cfg_off() {\n+        cov_mark::check!(unlinked_file_skip_fix_when_mod_already_exists);\n+        check_no_fix(\n+            r#\"\n+//- /main.rs\n+#[cfg(never)]\n+mod foo;\n+\n+//- /foo.rs\n+$0\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_with_cfg_on() {\n+        check_diagnostics(\n+            r#\"\n+//- /main.rs\n+#[cfg(not(never))]\n+mod foo;\n+\n+//- /foo.rs\n+\"#,\n+        );\n+    }\n+}"}]}