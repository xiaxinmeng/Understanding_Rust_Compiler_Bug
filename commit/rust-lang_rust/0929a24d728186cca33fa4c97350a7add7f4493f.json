{"sha": "0929a24d728186cca33fa4c97350a7add7f4493f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MjlhMjRkNzI4MTg2Y2NhMzNmYTRjOTczNTBhN2FkZDdmNDQ5M2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-15T22:36:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-15T22:36:57Z"}, "message": "Auto merge of #6828 - mgacek8:issue_6758_enhance_wrong_self_convention, r=flip1995\n\nwrong_self_convention: fix lint in case of `to_*_mut` method\n\nfixes #6758\nchangelog: wrong_self_convention: fix lint in case of `to_*_mut` method. When a method starts with `to_` and ends with `_mut`, clippy expects a `&mut self` parameter, otherwise `&self`.\n\nAny feedback is welcome. I was also thinking if shouldn't we treat `to_` the same way as `as_`. Namely to accept `self` taken:  `&self` or `&mut self`.", "tree": {"sha": "37587c9bd9b097e2dc96e7a5dc9ac174aa6898a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37587c9bd9b097e2dc96e7a5dc9ac174aa6898a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0929a24d728186cca33fa4c97350a7add7f4493f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0929a24d728186cca33fa4c97350a7add7f4493f", "html_url": "https://github.com/rust-lang/rust/commit/0929a24d728186cca33fa4c97350a7add7f4493f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0929a24d728186cca33fa4c97350a7add7f4493f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cd0f504a9219fa033d59e84f2f1ff92eefe8b6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cd0f504a9219fa033d59e84f2f1ff92eefe8b6d", "html_url": "https://github.com/rust-lang/rust/commit/9cd0f504a9219fa033d59e84f2f1ff92eefe8b6d"}, {"sha": "2547edb84272aeb3d01e2b61640a9107c01b281b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2547edb84272aeb3d01e2b61640a9107c01b281b", "html_url": "https://github.com/rust-lang/rust/commit/2547edb84272aeb3d01e2b61640a9107c01b281b"}], "stats": {"total": 234, "additions": 189, "deletions": 45}, "files": [{"sha": "53f63fdc28ed6d1fca72ab80dc62a4fda13ea31a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0929a24d728186cca33fa4c97350a7add7f4493f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0929a24d728186cca33fa4c97350a7add7f4493f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=0929a24d728186cca33fa4c97350a7add7f4493f", "patch": "@@ -192,13 +192,14 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for methods with certain name prefixes and which\n     /// doesn't match how self is taken. The actual rules are:\n     ///\n-    /// |Prefix |`self` taken          |\n-    /// |-------|----------------------|\n-    /// |`as_`  |`&self` or `&mut self`|\n-    /// |`from_`| none                 |\n-    /// |`into_`|`self`                |\n-    /// |`is_`  |`&self` or none       |\n-    /// |`to_`  |`&self`               |\n+    /// |Prefix |Postfix     |`self` taken          |\n+    /// |-------|------------|----------------------|\n+    /// |`as_`  | none       |`&self` or `&mut self`|\n+    /// |`from_`| none       | none                 |\n+    /// |`into_`| none       |`self`                |\n+    /// |`is_`  | none       |`&self` or none       |\n+    /// |`to_`  | `_mut`     |`&mut &self`          |\n+    /// |`to_`  | not `_mut` |`&self`               |\n     ///\n     /// **Why is this bad?** Consistency breeds readability. If you follow the\n     /// conventions, your users won't be surprised that they, e.g., need to supply a"}, {"sha": "c8bcad7be3ebd660fd22bf016ebf48345fe62dad", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0929a24d728186cca33fa4c97350a7add7f4493f/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0929a24d728186cca33fa4c97350a7add7f4493f/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=0929a24d728186cca33fa4c97350a7add7f4493f", "patch": "@@ -1,5 +1,5 @@\n use crate::methods::SelfKind;\n-use crate::utils::span_lint;\n+use crate::utils::span_lint_and_help;\n use rustc_lint::LateContext;\n use rustc_middle::ty::TyS;\n use rustc_span::source_map::Span;\n@@ -9,18 +9,22 @@ use super::WRONG_PUB_SELF_CONVENTION;\n use super::WRONG_SELF_CONVENTION;\n \n #[rustfmt::skip]\n-const CONVENTIONS: [(Convention, &[SelfKind]); 7] = [\n-    (Convention::Eq(\"new\"), &[SelfKind::No]),\n-    (Convention::StartsWith(\"as_\"), &[SelfKind::Ref, SelfKind::RefMut]),\n-    (Convention::StartsWith(\"from_\"), &[SelfKind::No]),\n-    (Convention::StartsWith(\"into_\"), &[SelfKind::Value]),\n-    (Convention::StartsWith(\"is_\"), &[SelfKind::Ref, SelfKind::No]),\n-    (Convention::Eq(\"to_mut\"), &[SelfKind::RefMut]),\n-    (Convention::StartsWith(\"to_\"), &[SelfKind::Ref]),\n+const CONVENTIONS: [(&[Convention], &[SelfKind]); 8] = [\n+    (&[Convention::Eq(\"new\")], &[SelfKind::No]),\n+    (&[Convention::StartsWith(\"as_\")], &[SelfKind::Ref, SelfKind::RefMut]),\n+    (&[Convention::StartsWith(\"from_\")], &[SelfKind::No]),\n+    (&[Convention::StartsWith(\"into_\")], &[SelfKind::Value]),\n+    (&[Convention::StartsWith(\"is_\")], &[SelfKind::Ref, SelfKind::No]),\n+    (&[Convention::Eq(\"to_mut\")], &[SelfKind::RefMut]),\n+    (&[Convention::StartsWith(\"to_\"), Convention::EndsWith(\"_mut\")], &[SelfKind::RefMut]),\n+    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\")], &[SelfKind::Ref]),\n ];\n+\n enum Convention {\n     Eq(&'static str),\n     StartsWith(&'static str),\n+    EndsWith(&'static str),\n+    NotEndsWith(&'static str),\n }\n \n impl Convention {\n@@ -29,6 +33,8 @@ impl Convention {\n         match *self {\n             Self::Eq(this) => this == other,\n             Self::StartsWith(this) => other.starts_with(this) && this != other,\n+            Self::EndsWith(this) => other.ends_with(this) && this != other,\n+            Self::NotEndsWith(this) => !Self::EndsWith(this).check(other),\n         }\n     }\n }\n@@ -38,6 +44,8 @@ impl fmt::Display for Convention {\n         match *self {\n             Self::Eq(this) => this.fmt(f),\n             Self::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n+            Self::EndsWith(this) => '*'.fmt(f).and_then(|_| this.fmt(f)),\n+            Self::NotEndsWith(this) => '~'.fmt(f).and_then(|_| this.fmt(f)),\n         }\n     }\n }\n@@ -55,21 +63,59 @@ pub(super) fn check<'tcx>(\n     } else {\n         WRONG_SELF_CONVENTION\n     };\n-    if let Some((ref conv, self_kinds)) = &CONVENTIONS.iter().find(|(ref conv, _)| conv.check(item_name)) {\n+    if let Some((conventions, self_kinds)) = &CONVENTIONS\n+        .iter()\n+        .find(|(convs, _)| convs.iter().all(|conv| conv.check(item_name)))\n+    {\n         if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n-            span_lint(\n+            let suggestion = {\n+                if conventions.len() > 1 {\n+                    let special_case = {\n+                        // Don't mention `NotEndsWith` when there is also `StartsWith` convention present\n+                        if conventions.len() == 2 {\n+                            match conventions {\n+                                [Convention::StartsWith(starts_with), Convention::NotEndsWith(_)]\n+                                | [Convention::NotEndsWith(_), Convention::StartsWith(starts_with)] => {\n+                                    Some(format!(\"methods called `{}`\", Convention::StartsWith(starts_with)))\n+                                },\n+                                _ => None,\n+                            }\n+                        } else {\n+                            None\n+                        }\n+                    };\n+\n+                    if let Some(suggestion) = special_case {\n+                        suggestion\n+                    } else {\n+                        let s = conventions\n+                            .iter()\n+                            .map(|c| format!(\"`{}`\", &c.to_string()))\n+                            .collect::<Vec<_>>()\n+                            .join(\" and \");\n+\n+                        format!(\"methods called like this: ({})\", &s)\n+                    }\n+                } else {\n+                    format!(\"methods called `{}`\", &conventions[0])\n+                }\n+            };\n+\n+            span_lint_and_help(\n                 cx,\n                 lint,\n                 first_arg_span,\n                 &format!(\n-                    \"methods called `{}` usually take {}; consider choosing a less ambiguous name\",\n-                    conv,\n+                    \"{} usually take {}\",\n+                    suggestion,\n                     &self_kinds\n                         .iter()\n                         .map(|k| k.description())\n                         .collect::<Vec<_>>()\n                         .join(\" or \")\n                 ),\n+                None,\n+                \"consider choosing a less ambiguous name\",\n             );\n         }\n     }"}, {"sha": "a3e9cc75b084726c9d3e644d811e721d4158df75", "filename": "tests/ui/def_id_nocore.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0929a24d728186cca33fa4c97350a7add7f4493f/tests%2Fui%2Fdef_id_nocore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0929a24d728186cca33fa4c97350a7add7f4493f/tests%2Fui%2Fdef_id_nocore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdef_id_nocore.stderr?ref=0929a24d728186cca33fa4c97350a7add7f4493f", "patch": "@@ -1,10 +1,11 @@\n-error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n+error: methods called `as_*` usually take self by reference or self by mutable reference\n   --> $DIR/def_id_nocore.rs:26:19\n    |\n LL |     pub fn as_ref(self) -> &'static str {\n    |                   ^^^^\n    |\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n+   = help: consider choosing a less ambiguous name\n \n error: aborting due to previous error\n "}, {"sha": "f43fea0d5137eef626add39a53d7248ac974ce08", "filename": "tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 71, "deletions": 24, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0929a24d728186cca33fa4c97350a7add7f4493f/tests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0929a24d728186cca33fa4c97350a7add7f4493f/tests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.stderr?ref=0929a24d728186cca33fa4c97350a7add7f4493f", "patch": "@@ -1,148 +1,195 @@\n-error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+error: methods called `from_*` usually take no self\n   --> $DIR/wrong_self_convention.rs:18:17\n    |\n LL |     fn from_i32(self) {}\n    |                 ^^^^\n    |\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+error: methods called `from_*` usually take no self\n   --> $DIR/wrong_self_convention.rs:24:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n+error: methods called `as_*` usually take self by reference or self by mutable reference\n   --> $DIR/wrong_self_convention.rs:36:15\n    |\n LL |     fn as_i32(self) {}\n    |               ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n+error: methods called `into_*` usually take self by value\n   --> $DIR/wrong_self_convention.rs:38:17\n    |\n LL |     fn into_i32(&self) {}\n    |                 ^^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n+error: methods called `is_*` usually take self by reference or no self\n   --> $DIR/wrong_self_convention.rs:40:15\n    |\n LL |     fn is_i32(self) {}\n    |               ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n+error: methods called `to_*` usually take self by reference\n   --> $DIR/wrong_self_convention.rs:42:15\n    |\n LL |     fn to_i32(self) {}\n    |               ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+error: methods called `from_*` usually take no self\n   --> $DIR/wrong_self_convention.rs:44:17\n    |\n LL |     fn from_i32(self) {}\n    |                 ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n+error: methods called `as_*` usually take self by reference or self by mutable reference\n   --> $DIR/wrong_self_convention.rs:46:19\n    |\n LL |     pub fn as_i64(self) {}\n    |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n+error: methods called `into_*` usually take self by value\n   --> $DIR/wrong_self_convention.rs:47:21\n    |\n LL |     pub fn into_i64(&self) {}\n    |                     ^^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n+error: methods called `is_*` usually take self by reference or no self\n   --> $DIR/wrong_self_convention.rs:48:19\n    |\n LL |     pub fn is_i64(self) {}\n    |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n+error: methods called `to_*` usually take self by reference\n   --> $DIR/wrong_self_convention.rs:49:19\n    |\n LL |     pub fn to_i64(self) {}\n    |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+error: methods called `from_*` usually take no self\n   --> $DIR/wrong_self_convention.rs:50:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n+error: methods called `as_*` usually take self by reference or self by mutable reference\n   --> $DIR/wrong_self_convention.rs:95:19\n    |\n LL |         fn as_i32(self) {}\n    |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n+error: methods called `into_*` usually take self by value\n   --> $DIR/wrong_self_convention.rs:98:25\n    |\n LL |         fn into_i32_ref(&self) {}\n    |                         ^^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n+error: methods called `is_*` usually take self by reference or no self\n   --> $DIR/wrong_self_convention.rs:100:19\n    |\n LL |         fn is_i32(self) {}\n    |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n+error: methods called `to_*` usually take self by reference\n   --> $DIR/wrong_self_convention.rs:102:19\n    |\n LL |         fn to_i32(self) {}\n    |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+error: methods called `from_*` usually take no self\n   --> $DIR/wrong_self_convention.rs:104:21\n    |\n LL |         fn from_i32(self) {}\n    |                     ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n+error: methods called `as_*` usually take self by reference or self by mutable reference\n   --> $DIR/wrong_self_convention.rs:119:19\n    |\n LL |         fn as_i32(self);\n    |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n+error: methods called `into_*` usually take self by value\n   --> $DIR/wrong_self_convention.rs:122:25\n    |\n LL |         fn into_i32_ref(&self);\n    |                         ^^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n+error: methods called `is_*` usually take self by reference or no self\n   --> $DIR/wrong_self_convention.rs:124:19\n    |\n LL |         fn is_i32(self);\n    |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n+error: methods called `to_*` usually take self by reference\n   --> $DIR/wrong_self_convention.rs:126:19\n    |\n LL |         fn to_i32(self);\n    |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+error: methods called `from_*` usually take no self\n   --> $DIR/wrong_self_convention.rs:128:21\n    |\n LL |         fn from_i32(self);\n    |                     ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n+error: methods called `into_*` usually take self by value\n   --> $DIR/wrong_self_convention.rs:146:25\n    |\n LL |         fn into_i32_ref(&self);\n    |                         ^^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+error: methods called `from_*` usually take no self\n   --> $DIR/wrong_self_convention.rs:152:21\n    |\n LL |         fn from_i32(self);\n    |                     ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n \n error: aborting due to 24 previous errors\n "}, {"sha": "486a0d772358531ca75e14eea62e41547ad294dd", "filename": "tests/ui/wrong_self_conventions_mut.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0929a24d728186cca33fa4c97350a7add7f4493f/tests%2Fui%2Fwrong_self_conventions_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0929a24d728186cca33fa4c97350a7add7f4493f/tests%2Fui%2Fwrong_self_conventions_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_conventions_mut.rs?ref=0929a24d728186cca33fa4c97350a7add7f4493f", "patch": "@@ -0,0 +1,30 @@\n+// edition:2018\n+#![warn(clippy::wrong_self_convention)]\n+#![allow(dead_code)]\n+\n+fn main() {}\n+\n+mod issue6758 {\n+    pub enum Test<T> {\n+        One(T),\n+        Many(Vec<T>),\n+    }\n+\n+    impl<T> Test<T> {\n+        // If a method starts with `to_` and not ends with `_mut` it should expect `&self`\n+        pub fn to_many(&mut self) -> Option<&mut [T]> {\n+            match self {\n+                Self::Many(data) => Some(data),\n+                _ => None,\n+            }\n+        }\n+\n+        // If a method starts with `to_` and ends with `_mut` it should expect `&mut self`\n+        pub fn to_many_mut(&self) -> Option<&[T]> {\n+            match self {\n+                Self::Many(data) => Some(data),\n+                _ => None,\n+            }\n+        }\n+    }\n+}"}, {"sha": "7662b38e67d0798c16e7e461bcc13a52cefd0ab1", "filename": "tests/ui/wrong_self_conventions_mut.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0929a24d728186cca33fa4c97350a7add7f4493f/tests%2Fui%2Fwrong_self_conventions_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0929a24d728186cca33fa4c97350a7add7f4493f/tests%2Fui%2Fwrong_self_conventions_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_conventions_mut.stderr?ref=0929a24d728186cca33fa4c97350a7add7f4493f", "patch": "@@ -0,0 +1,19 @@\n+error: methods called `to_*` usually take self by reference\n+  --> $DIR/wrong_self_conventions_mut.rs:15:24\n+   |\n+LL |         pub fn to_many(&mut self) -> Option<&mut [T]> {\n+   |                        ^^^^^^^^^\n+   |\n+   = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n+   = help: consider choosing a less ambiguous name\n+\n+error: methods called like this: (`to_*` and `*_mut`) usually take self by mutable reference\n+  --> $DIR/wrong_self_conventions_mut.rs:23:28\n+   |\n+LL |         pub fn to_many_mut(&self) -> Option<&[T]> {\n+   |                            ^^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n+\n+error: aborting due to 2 previous errors\n+"}]}