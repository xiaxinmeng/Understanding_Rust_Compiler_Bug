{"sha": "dc91e229d25b7074f5062662a089a66d627d292b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjOTFlMjI5ZDI1YjcwNzRmNTA2MjY2MmEwODlhNjZkNjI3ZDI5MmI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-28T08:59:15Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-05T06:33:09Z"}, "message": "resolve: move `resolve_block` to a better place.", "tree": {"sha": "9973c65eabb1bd6850a6c6bc1ae22928ab008b2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9973c65eabb1bd6850a6c6bc1ae22928ab008b2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc91e229d25b7074f5062662a089a66d627d292b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc91e229d25b7074f5062662a089a66d627d292b", "html_url": "https://github.com/rust-lang/rust/commit/dc91e229d25b7074f5062662a089a66d627d292b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc91e229d25b7074f5062662a089a66d627d292b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd3b44184650b12ce30900e49e4d3ecb462ea540", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd3b44184650b12ce30900e49e4d3ecb462ea540", "html_url": "https://github.com/rust-lang/rust/commit/fd3b44184650b12ce30900e49e4d3ecb462ea540"}], "stats": {"total": 86, "additions": 43, "deletions": 43}, "files": [{"sha": "c2513c2c76976097b5b848688bdec041cc5a84ed", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/dc91e229d25b7074f5062662a089a66d627d292b/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc91e229d25b7074f5062662a089a66d627d292b/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=dc91e229d25b7074f5062662a089a66d627d292b", "patch": "@@ -1229,49 +1229,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn resolve_block(&mut self, block: &Block) {\n-        debug!(\"(resolving block) entering block\");\n-        // Move down in the graph, if there's an anonymous module rooted here.\n-        let orig_module = self.parent_scope.module;\n-        let anonymous_module = self.r.block_map.get(&block.id).cloned(); // clones a reference\n-\n-        let mut num_macro_definition_ribs = 0;\n-        if let Some(anonymous_module) = anonymous_module {\n-            debug!(\"(resolving block) found anonymous module, moving down\");\n-            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.parent_scope.module = anonymous_module;\n-        } else {\n-            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-        }\n-\n-        // Descend into the block.\n-        for stmt in &block.stmts {\n-            if let StmtKind::Item(ref item) = stmt.node {\n-                if let ItemKind::MacroDef(..) = item.node {\n-                    num_macro_definition_ribs += 1;\n-                    let res = self.r.definitions.local_def_id(item.id);\n-                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n-                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n-                }\n-            }\n-\n-            self.visit_stmt(stmt);\n-        }\n-\n-        // Move back up.\n-        self.parent_scope.module = orig_module;\n-        for _ in 0 .. num_macro_definition_ribs {\n-            self.ribs[ValueNS].pop();\n-            self.label_ribs.pop();\n-        }\n-        self.ribs[ValueNS].pop();\n-        if anonymous_module.is_some() {\n-            self.ribs[TypeNS].pop();\n-        }\n-        debug!(\"(resolving block) leaving block\");\n-    }\n-\n     fn resolve_pattern(\n         &mut self,\n         pat: &Pat,\n@@ -1729,6 +1686,49 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         self.with_resolved_label(label, id, |this| this.visit_block(block));\n     }\n \n+    fn resolve_block(&mut self, block: &Block) {\n+        debug!(\"(resolving block) entering block\");\n+        // Move down in the graph, if there's an anonymous module rooted here.\n+        let orig_module = self.parent_scope.module;\n+        let anonymous_module = self.r.block_map.get(&block.id).cloned(); // clones a reference\n+\n+        let mut num_macro_definition_ribs = 0;\n+        if let Some(anonymous_module) = anonymous_module {\n+            debug!(\"(resolving block) found anonymous module, moving down\");\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.parent_scope.module = anonymous_module;\n+        } else {\n+            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+        }\n+\n+        // Descend into the block.\n+        for stmt in &block.stmts {\n+            if let StmtKind::Item(ref item) = stmt.node {\n+                if let ItemKind::MacroDef(..) = item.node {\n+                    num_macro_definition_ribs += 1;\n+                    let res = self.r.definitions.local_def_id(item.id);\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n+                }\n+            }\n+\n+            self.visit_stmt(stmt);\n+        }\n+\n+        // Move back up.\n+        self.parent_scope.module = orig_module;\n+        for _ in 0 .. num_macro_definition_ribs {\n+            self.ribs[ValueNS].pop();\n+            self.label_ribs.pop();\n+        }\n+        self.ribs[ValueNS].pop();\n+        if anonymous_module.is_some() {\n+            self.ribs[TypeNS].pop();\n+        }\n+        debug!(\"(resolving block) leaving block\");\n+    }\n+\n     fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call."}]}