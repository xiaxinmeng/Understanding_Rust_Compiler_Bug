{"sha": "68e766afab32a45e55728e11c17b996848a7dd49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZTc2NmFmYWIzMmE0NWU1NTcyOGUxMWMxN2I5OTY4NDhhN2RkNDk=", "commit": {"author": {"name": "Niv Kaminer", "email": "nivkner@zoho.com", "date": "2018-08-07T18:14:57Z"}, "committer": {"name": "Niv Kaminer", "email": "nivkner@zoho.com", "date": "2018-08-07T18:14:57Z"}, "message": "remove general pinning information from Unpin trait", "tree": {"sha": "a56d88f250843512bef610da7626f8f93d336a62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a56d88f250843512bef610da7626f8f93d336a62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68e766afab32a45e55728e11c17b996848a7dd49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68e766afab32a45e55728e11c17b996848a7dd49", "html_url": "https://github.com/rust-lang/rust/commit/68e766afab32a45e55728e11c17b996848a7dd49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68e766afab32a45e55728e11c17b996848a7dd49/comments", "author": {"login": "nivkner", "id": 22821514, "node_id": "MDQ6VXNlcjIyODIxNTE0", "avatar_url": "https://avatars.githubusercontent.com/u/22821514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nivkner", "html_url": "https://github.com/nivkner", "followers_url": "https://api.github.com/users/nivkner/followers", "following_url": "https://api.github.com/users/nivkner/following{/other_user}", "gists_url": "https://api.github.com/users/nivkner/gists{/gist_id}", "starred_url": "https://api.github.com/users/nivkner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nivkner/subscriptions", "organizations_url": "https://api.github.com/users/nivkner/orgs", "repos_url": "https://api.github.com/users/nivkner/repos", "events_url": "https://api.github.com/users/nivkner/events{/privacy}", "received_events_url": "https://api.github.com/users/nivkner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nivkner", "id": 22821514, "node_id": "MDQ6VXNlcjIyODIxNTE0", "avatar_url": "https://avatars.githubusercontent.com/u/22821514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nivkner", "html_url": "https://github.com/nivkner", "followers_url": "https://api.github.com/users/nivkner/followers", "following_url": "https://api.github.com/users/nivkner/following{/other_user}", "gists_url": "https://api.github.com/users/nivkner/gists{/gist_id}", "starred_url": "https://api.github.com/users/nivkner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nivkner/subscriptions", "organizations_url": "https://api.github.com/users/nivkner/orgs", "repos_url": "https://api.github.com/users/nivkner/repos", "events_url": "https://api.github.com/users/nivkner/events{/privacy}", "received_events_url": "https://api.github.com/users/nivkner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87bbd2eeef1ad321b294e2d3b0fb2dc960390c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/87bbd2eeef1ad321b294e2d3b0fb2dc960390c86", "html_url": "https://github.com/rust-lang/rust/commit/87bbd2eeef1ad321b294e2d3b0fb2dc960390c86"}], "stats": {"total": 97, "additions": 9, "deletions": 88}, "files": [{"sha": "596727a014109aff8531a04e9be00ebdf95f030f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 9, "deletions": 88, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/68e766afab32a45e55728e11c17b996848a7dd49/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e766afab32a45e55728e11c17b996848a7dd49/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=68e766afab32a45e55728e11c17b996848a7dd49", "patch": "@@ -603,101 +603,22 @@ unsafe impl<T: ?Sized> Freeze for *mut T {}\n unsafe impl<'a, T: ?Sized> Freeze for &'a T {}\n unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n \n-/// Types that are safe to move.\n+/// Types which can be safely moved after being pinned.\n ///\n-/// Since moving objects is almost always safe, it is automatically implemented in most cases.\n+/// Since Rust itself has no notion of immovable types, and will consider moves to always be safe,\n+/// this trait cannot prevent types from moving by itself.\n ///\n-/// This trait is mainly used to build self referencial structs,\n-/// since moving an object with pointers to itself will invalidate them,\n-/// causing undefined behavior.\n+/// Instead it can be used to prevent moves through the type system,\n+/// by controlling the behavior of special pointers types like [`PinMut`],\n+/// which \"pin\" the type in place by wrapping it in a type which can only be dereferenced immutably.\n ///\n-/// # The Pin API\n+/// Implementing this trait lifts the restrictions of pinning off a type,\n+/// which then allows it to move out of said pointers with functions such as [`swap`].\n ///\n-/// The `Unpin` trait doesn't actually change the behavior of the compiler around moves,\n-/// so code like this will compile just fine:\n-///\n-/// ```rust\n-/// #![feature(pin)]\n-/// use std::marker::Pinned;\n-///\n-/// struct Unmovable {\n-///     _pin: Pinned, // this marker type prevents Unpin from being implemented for this type\n-/// }\n-///\n-/// let unmoved = Unmovable { _pin: Pinned };\n-/// let moved = unmoved;\n-/// ```\n-///\n-/// In order to actually prevent the pinned objects from moving,\n-/// it has to be wrapped in special pointer types,\n-/// which currently include [`PinMut`] and [`PinBox`].\n-///\n-/// The way they work is by implementing [`DerefMut`] for all types that implement Unpin,\n-/// but only [`Deref`] otherwise.\n-///\n-/// This is done because, while modifying an object can be done in-place,\n-/// it might also relocate a buffer when its at full capacity,\n-/// or it might replace one object with another without logically \"moving\" them with [`swap`].\n+/// This trait is automatically implemented for almost every type.\n ///\n /// [`PinMut`]: ../mem/struct.PinMut.html\n-/// [`PinBox`]: ../../alloc/boxed/struct.PinBox.html\n-/// [`DerefMut`]: ../ops/trait.DerefMut.html\n-/// [`Deref`]: ../ops/trait.Deref.html\n /// [`swap`]: ../mem/fn.swap.html\n-///\n-/// # Examples\n-///\n-/// ```rust\n-/// #![feature(pin)]\n-///\n-/// use std::boxed::PinBox;\n-/// use std::marker::Pinned;\n-/// use std::ptr::NonNull;\n-///\n-/// // This is a self referencial struct since the slice field points to the data field.\n-/// // We cannot inform the compiler about that with a normal reference,\n-/// // since this pattern cannot be described with the usual borrowing rules.\n-/// // Instead we use a raw pointer, though one which is known to not be null,\n-/// // since we know it's pointing at the string.\n-/// struct Unmovable {\n-///     data: String,\n-///     slice: NonNull<String>,\n-///     _pin: Pinned,\n-/// }\n-///\n-/// impl Unmovable {\n-///     // To ensure the data doesn't move when the function returns,\n-///     // we place it in the heap where it will stay for the lifetime of the object,\n-///     // and the only way to access it would be through a pointer to it.\n-///     fn new(data: String) -> PinBox<Self> {\n-///         let res = Unmovable {\n-///             data,\n-///             // we only create the pointer once the data is in place\n-///             // otherwise it will have already moved before we even started\n-///             slice: NonNull::dangling(),\n-///             _pin: Pinned,\n-///         };\n-///         let mut boxed = PinBox::new(res);\n-///\n-///         let slice = NonNull::from(&boxed.data);\n-///         // we know this is safe because modifying a field doesn't move the whole struct\n-///         unsafe { PinBox::get_mut(&mut boxed).slice = slice };\n-///         boxed\n-///     }\n-/// }\n-///\n-/// let unmoved = Unmovable::new(\"hello\".to_string());\n-/// // The pointer should point to the correct location,\n-/// // so long as the struct hasn't moved.\n-/// // Meanwhile, we are free to move the pointer around.\n-/// let mut still_unmoved = unmoved;\n-/// assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n-///\n-/// // Now the only way to access to data (safely) is immutably,\n-/// // so this will fail to compile:\n-/// // still_unmoved.data.push_str(\" world\");\n-///\n-/// ```\n #[unstable(feature = \"pin\", issue = \"49150\")]\n pub auto trait Unpin {}\n "}]}