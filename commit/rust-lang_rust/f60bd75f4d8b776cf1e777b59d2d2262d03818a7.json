{"sha": "f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MGJkNzVmNGQ4Yjc3NmNmMWU3NzdiNTlkMmQyMjYyZDAzODE4YTc=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-19T23:06:31Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:57Z"}, "message": "std: remove fcntl const bindings + making valgrind clean w/ no owned vecs", "tree": {"sha": "21a1f9358cd09b0646a7a8f9635c6b1315b3004e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21a1f9358cd09b0646a7a8f9635c6b1315b3004e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "html_url": "https://github.com/rust-lang/rust/commit/f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f60bd75f4d8b776cf1e777b59d2d2262d03818a7/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0a80ee332dc347d588bfcea66c11896c04263bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a80ee332dc347d588bfcea66c11896c04263bb", "html_url": "https://github.com/rust-lang/rust/commit/e0a80ee332dc347d588bfcea66c11896c04263bb"}], "stats": {"total": 255, "additions": 68, "deletions": 187}, "files": [{"sha": "f3f6c325162557fab89031b25b13ee1e08c18a00", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 68, "deletions": 124, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f60bd75f4d8b776cf1e777b59d2d2262d03818a7/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bd75f4d8b776cf1e777b59d2d2262d03818a7/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "patch": "@@ -12,60 +12,19 @@ use prelude::*;\n use ptr::null;\n use libc::c_void;\n use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n-             status_to_maybe_uv_error_with_loop,\n-             vec_to_uv_buf, vec_from_uv_buf};\n+             status_to_maybe_uv_error_with_loop};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use path::Path;\n use cast::transmute;\n use libc::{c_int};\n use option::{None, Some, Option};\n-use vec;\n \n pub struct FsRequest(*uvll::uv_fs_t);\n impl Request for FsRequest;\n \n-#[allow(non_camel_case_types)]\n-pub enum UvFileFlag {\n-    O_RDONLY,\n-    O_WRONLY,\n-    O_RDWR,\n-    O_CREAT,\n-    O_TRUNC\n-}\n-// just want enough to get 0644\n-#[allow(non_camel_case_types)]\n-pub enum UvFileMode {\n-    S_IWUSR,\n-    S_IRUSR,\n-    S_IRGRP,\n-    S_IROTH\n-}\n-pub fn map_flag(v: UvFileFlag) -> int {\n-    unsafe {\n-        match v {\n-            O_RDONLY => uvll::get_O_RDONLY() as int,\n-            O_WRONLY => uvll::get_O_WRONLY() as int,\n-            O_RDWR => uvll::get_O_RDWR() as int,\n-            O_CREAT => uvll::get_O_CREAT() as int,\n-            O_TRUNC => uvll::get_O_TRUNC() as int\n-        }\n-    }\n-}\n-pub fn map_mode(v: UvFileMode) -> int {\n-    unsafe {\n-        match v {\n-            S_IWUSR => uvll::get_S_IWUSR() as int,\n-            S_IRUSR => uvll::get_S_IRUSR() as int,\n-            S_IRGRP => uvll::get_S_IRGRP() as int,\n-            S_IROTH => uvll::get_S_IROTH() as int\n-        }\n-    }\n-}\n-\n pub struct RequestData {\n     complete_cb: Option<FsCallback>,\n-    buf: Option<Buf>,\n     raw_fd: Option<c_int>\n }\n \n@@ -82,7 +41,6 @@ impl FsRequest {\n         let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n         let data = ~RequestData {\n             complete_cb: cb,\n-            buf: None,\n             raw_fd: None\n         };\n         unsafe {\n@@ -112,15 +70,7 @@ impl FsRequest {\n     fn cleanup_and_delete(self) {\n         unsafe {\n             let data = uvll::get_data_for_req(self.native_handle());\n-            let mut _data = transmute::<*c_void, ~RequestData>(data);\n-            // if set we're going to convert the buf param back into\n-            // a rust vec, as that's the mechanism by which the raw\n-            // uv_buf_t's .base field gets freed. We immediately discard\n-            // the result\n-            if _data.buf.is_some() {\n-                let buf = _data.buf.take_unwrap();\n-                vec_from_uv_buf(buf);\n-            }\n+            let _data = transmute::<*c_void, ~RequestData>(data);\n             uvll::set_data_for_req(self.native_handle(), null::<()>());\n             uvll::fs_req_cleanup(self.native_handle());\n             free_req(self.native_handle() as *c_void)\n@@ -192,18 +142,16 @@ impl FileDescriptor {\n     }\n \n     // as per bnoordhuis in #libuv: offset >= 0 uses prwrite instead of write\n-    fn write_common(&self, loop_: Loop, buf: ~[u8], offset: i64, cb: Option<FsCallback>)\n+    fn write_common(&self, loop_: Loop, buf: Buf, offset: i64, cb: Option<FsCallback>)\n           -> int {\n         let complete_cb_ptr = match cb {\n             Some(_) => compl_cb,\n             None => 0 as *u8\n         };\n         let is_sync = cb.is_none();\n         let mut req = FsRequest::new(cb);\n-        let len = buf.len();\n-        let buf = vec_to_uv_buf(buf);\n         let base_ptr = buf.base as *c_void;\n-        req.get_req_data().buf = Some(buf);\n+        let len = buf.len as uint;\n         req.get_req_data().raw_fd = Some(self.native_handle());\n         let result = unsafe {\n             uvll::fs_write(loop_.native_handle(), req.native_handle(),\n@@ -213,17 +161,17 @@ impl FileDescriptor {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn write(&self, loop_: Loop, buf: ~[u8], offset: i64, cb: FsCallback)\n+    pub fn write(&self, loop_: Loop, buf: Buf, offset: i64, cb: FsCallback)\n           -> int {\n         self.write_common(loop_, buf, offset, Some(cb))\n     }\n-    pub fn write_sync(&self, loop_: Loop, buf: ~[u8], offset: i64)\n+    pub fn write_sync(&self, loop_: Loop, buf: Buf, offset: i64)\n           -> int {\n         self.write_common(loop_, buf, offset, None)\n     }\n \n-    fn read_common(&self, loop_: Loop, buf_ptr: Option<*c_void>,\n-                   len: uint, offset: i64, cb: Option<FsCallback>)\n+    fn read_common(&self, loop_: Loop, buf: Buf,\n+                   offset: i64, cb: Option<FsCallback>)\n           -> int {\n         let complete_cb_ptr = match cb {\n             Some(_) => compl_cb,\n@@ -232,31 +180,22 @@ impl FileDescriptor {\n         let is_sync = cb.is_none();\n         let mut req = FsRequest::new(cb);\n         req.get_req_data().raw_fd = Some(self.native_handle());\n+        let buf_ptr = buf.base as *c_void;\n         let result = unsafe {\n-            let buf_ptr = match buf_ptr {\n-                Some(ptr) => ptr,\n-                None => {\n-                    let buf = vec::from_elem(len, 0u8);\n-                    let buf = vec_to_uv_buf(buf);\n-                    req.get_req_data().buf = Some(buf);\n-                    buf.base as *c_void\n-                }\n-            };\n             uvll::fs_read(loop_.native_handle(), req.native_handle(),\n                            self.native_handle(), buf_ptr,\n-                           len, offset, complete_cb_ptr) as int\n+                           buf.len as uint, offset, complete_cb_ptr) as int\n         };\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn read(&self, loop_: Loop, buf_ptr: Option<*c_void>,\n-                len: uint, offset: i64, cb: FsCallback)\n+    pub fn read(&self, loop_: Loop, buf: Buf, offset: i64, cb: FsCallback)\n           -> int {\n-        self.read_common(loop_, buf_ptr, len, offset, Some(cb))\n+        self.read_common(loop_, buf, offset, Some(cb))\n     }\n-    pub fn read_sync(&self, loop_: Loop, buf_ptr: Option<*c_void>, len: uint, offset: i64)\n+    pub fn read_sync(&self, loop_: Loop, buf: Buf, offset: i64)\n           -> int {\n-        self.read_common(loop_, buf_ptr, len, offset, None)\n+        self.read_common(loop_, buf, offset, None)\n     }\n \n     fn close_common(self, loop_: Loop, cb: Option<FsCallback>) -> int {\n@@ -316,61 +255,67 @@ impl NativeHandle<c_int> for FileDescriptor {\n mod test {\n     use super::*;\n     //use rt::test::*;\n-    use option::{Some};\n-    use libc::{STDOUT_FILENO, c_void};\n+    use libc::{STDOUT_FILENO};\n     use vec;\n     use str;\n     use unstable::run_in_bare_thread;\n     use path::Path;\n-    use rt::uv::{Loop, vec_to_uv_buf, vec_from_uv_buf,\n+    use rt::uv::{Loop, Buf, slice_to_uv_buf,\n                  status_to_maybe_uv_error_with_loop};\n-    use option::{None};\n+    use libc::{O_CREAT, O_RDWR, O_RDONLY,\n+               S_IWUSR, S_IRUSR}; //NOTE: need defs for S_**GRP|S_**OTH in libc:: ...\n+               //S_IRGRP, S_IROTH};\n \n     fn file_test_full_simple_impl() {\n         do run_in_bare_thread {\n             let mut loop_ = Loop::new();\n-            let create_flags = map_flag(O_RDWR) |\n-                map_flag(O_CREAT);\n-            let read_flags = map_flag(O_RDONLY);\n-            // 0644\n-            let mode = map_mode(S_IWUSR) |\n-                map_mode(S_IRUSR) |\n-                map_mode(S_IRGRP) |\n-                map_mode(S_IROTH);\n+            let create_flags = O_RDWR | O_CREAT;\n+            let read_flags = O_RDONLY;\n+            // 0644 BZZT! WRONG! 0600! See below.\n+            let mode = S_IWUSR |S_IRUSR;\n+                // these aren't defined in std::libc :(\n+                //map_mode(S_IRGRP) |\n+                //map_mode(S_IROTH);\n             let path_str = \"./file_full_simple.txt\";\n-            let write_val = \"hello\";\n-            do FileDescriptor::open(loop_, Path(path_str), create_flags, mode)\n+            let write_val = \"hello\".as_bytes().to_owned();\n+            let write_buf  = slice_to_uv_buf(write_val);\n+            let write_buf_ptr: *Buf = &write_buf;\n+            let read_buf_len = 1028;\n+            let read_mem = vec::from_elem(read_buf_len, 0u8);\n+            let read_buf = slice_to_uv_buf(read_mem);\n+            let read_buf_ptr: *Buf = &read_buf;\n+            do FileDescriptor::open(loop_, Path(path_str), create_flags as int, mode as int)\n             |req, uverr| {\n                 let loop_ = req.get_loop();\n                 assert!(uverr.is_none());\n                 let fd = FileDescriptor::from_open_req(req);\n-                let msg: ~[u8] = write_val.as_bytes().to_owned();\n                 let raw_fd = fd.native_handle();\n-                do fd.write(loop_, msg, -1) |_, uverr| {\n+                let buf = unsafe { *write_buf_ptr };\n+                do fd.write(loop_, buf, -1) |_, uverr| {\n                     let fd = FileDescriptor(raw_fd);\n                     do fd.close(loop_) |req, _| {\n                         let loop_ = req.get_loop();\n                         assert!(uverr.is_none());\n-                        do FileDescriptor::open(loop_, Path(path_str), read_flags,0)\n+                        do FileDescriptor::open(loop_, Path(path_str), read_flags as int,0)\n                             |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n-                            let len = 1028;\n                             let fd = FileDescriptor::from_open_req(req);\n                             let raw_fd = fd.native_handle();\n-                            do fd.read(loop_, None, len, 0) |req, uverr| {\n+                            let read_buf = unsafe { *read_buf_ptr };\n+                            do fd.read(loop_, read_buf, 0) |req, uverr| {\n                                 assert!(uverr.is_none());\n                                 let loop_ = req.get_loop();\n                                 // we know nread >=0 because uverr is none..\n                                 let nread = req.get_result() as uint;\n                                 // nread == 0 would be EOF\n                                 if nread > 0 {\n-                                    let buf = vec_from_uv_buf(\n-                                        req.get_req_data().buf.take_unwrap())\n-                                        .take_unwrap();\n-                                    let read_str = str::from_bytes(\n-                                        buf.slice(0,\n-                                                  nread));\n+                                    let read_str = unsafe {\n+                                        let read_buf = *read_buf_ptr;\n+                                        str::from_bytes(\n+                                            vec::from_buf(\n+                                                read_buf.base, nread))\n+                                    };\n                                     assert!(read_str == ~\"hello\");\n                                     do FileDescriptor(raw_fd).close(loop_) |_,uverr| {\n                                         assert!(uverr.is_none());\n@@ -393,50 +338,50 @@ mod test {\n         do run_in_bare_thread {\n             // setup\n             let mut loop_ = Loop::new();\n-            let create_flags = map_flag(O_RDWR) |\n-                map_flag(O_CREAT);\n-            let read_flags = map_flag(O_RDONLY);\n+            let create_flags = O_RDWR |\n+                O_CREAT;\n+            let read_flags = O_RDONLY;\n             // 0644\n-            let mode = map_mode(S_IWUSR) |\n-                map_mode(S_IRUSR) |\n-                map_mode(S_IRGRP) |\n-                map_mode(S_IROTH);\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+                //S_IRGRP |\n+                //S_IROTH;\n             let path_str = \"./file_full_simple_sync.txt\";\n-            let write_val = \"hello\";\n+            let write_val = \"hello\".as_bytes().to_owned();\n+            let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n-            let result = FileDescriptor::open_sync(loop_, Path(path_str), create_flags, mode);\n+            let result = FileDescriptor::open_sync(loop_, Path(path_str),\n+                                                   create_flags as int, mode as int);\n             assert!(status_to_maybe_uv_error_with_loop(\n                 loop_.native_handle(), result as i32).is_none());\n             let fd = FileDescriptor(result as i32);\n-            let msg: ~[u8] = write_val.as_bytes().to_owned();\n             // write\n-            let result = fd.write_sync(loop_, msg, -1);\n+            let result = fd.write_sync(loop_, write_buf, -1);\n             assert!(status_to_maybe_uv_error_with_loop(\n                 loop_.native_handle(), result as i32).is_none());\n             // close\n             let result = fd.close_sync(loop_);\n             assert!(status_to_maybe_uv_error_with_loop(\n                 loop_.native_handle(), result as i32).is_none());\n             // re-open\n-            let result = FileDescriptor::open_sync(loop_, Path(path_str), read_flags,0);\n+            let result = FileDescriptor::open_sync(loop_, Path(path_str),\n+                                                   read_flags as int,0);\n             assert!(status_to_maybe_uv_error_with_loop(\n                 loop_.native_handle(), result as i32).is_none());\n             let len = 1028;\n             let fd = FileDescriptor(result as i32);\n             // read\n-            let buf: ~[u8] = vec::from_elem(len, 0u8);\n-            let buf = vec_to_uv_buf(buf);\n-            let buf_ptr = buf.base as *c_void;\n-            let result = fd.read_sync(loop_, Some(buf_ptr), len, 0);\n+            let read_mem: ~[u8] = vec::from_elem(len, 0u8);\n+            let buf = slice_to_uv_buf(read_mem);\n+            let result = fd.read_sync(loop_, buf, 0);\n             assert!(status_to_maybe_uv_error_with_loop(\n                 loop_.native_handle(), result as i32).is_none());\n             let nread = result;\n             // nread == 0 would be EOF.. we know it's >= zero because otherwise\n             // the above assert would fail\n             if nread > 0 {\n-                let buf = vec_from_uv_buf(buf).take_unwrap();\n                 let read_str = str::from_bytes(\n-                    buf.slice(0, nread as uint));\n+                    read_mem.slice(0, nread as uint));\n                 assert!(read_str == ~\"hello\");\n                 // close\n                 let result = fd.close_sync(loop_);\n@@ -461,19 +406,18 @@ mod test {\n         file_test_full_simple_impl_sync();\n     }\n \n-    fn naive_print(loop_: Loop, input: ~str) {\n+    fn naive_print(loop_: Loop, input: &str) {\n         let stdout = FileDescriptor(STDOUT_FILENO);\n-        let msg = input.as_bytes().to_owned();\n-        do stdout.write(loop_, msg, -1) |_, uverr| {\n-            assert!(uverr.is_none());\n-        };\n+        let write_val = input.as_bytes();\n+        let write_buf = slice_to_uv_buf(write_val);\n+        stdout.write_sync(loop_, write_buf, 0);\n     }\n \n     #[test]\n     fn file_test_write_to_stdout() {\n         do run_in_bare_thread {\n             let mut loop_ = Loop::new();\n-            naive_print(loop_, ~\"zanzibar!\\n\");\n+            naive_print(loop_, \"zanzibar!\\n\");\n             loop_.run();\n             loop_.close();\n         };"}, {"sha": "caac418b7339b08f26015c7261c2acfa8f556703", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f60bd75f4d8b776cf1e777b59d2d2262d03818a7/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bd75f4d8b776cf1e777b59d2d2262d03818a7/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "patch": "@@ -643,15 +643,6 @@ pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n }\n \n // data access helpers\n-pub unsafe fn get_O_RDONLY() -> c_int { rust_uv_get_O_RDONLY() }\n-pub unsafe fn get_O_WRONLY() -> c_int { rust_uv_get_O_WRONLY() }\n-pub unsafe fn get_O_RDWR() -> c_int { rust_uv_get_O_RDWR() }\n-pub unsafe fn get_O_CREAT() -> c_int { rust_uv_get_O_CREAT() }\n-pub unsafe fn get_O_TRUNC() -> c_int { rust_uv_get_O_TRUNC() }\n-pub unsafe fn get_S_IWUSR() -> c_int { rust_uv_get_S_IWUSR() }\n-pub unsafe fn get_S_IRUSR() -> c_int { rust_uv_get_S_IRUSR() }\n-pub unsafe fn get_S_IRGRP() -> c_int { rust_uv_get_S_IRGRP() }\n-pub unsafe fn get_S_IROTH() -> c_int { rust_uv_get_S_IROTH() }\n pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n     rust_uv_get_result_from_fs_req(req)\n }\n@@ -835,15 +826,6 @@ extern {\n     fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n                         cb: *u8) -> c_int;\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n-    fn rust_uv_get_O_RDONLY() -> c_int;\n-    fn rust_uv_get_O_WRONLY() -> c_int;\n-    fn rust_uv_get_O_RDWR() -> c_int;\n-    fn rust_uv_get_O_CREAT() -> c_int;\n-    fn rust_uv_get_O_TRUNC() -> c_int;\n-    fn rust_uv_get_S_IWUSR() -> c_int;\n-    fn rust_uv_get_S_IRUSR() -> c_int;\n-    fn rust_uv_get_S_IRGRP() -> c_int;\n-    fn rust_uv_get_S_IROTH() -> c_int;\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n "}, {"sha": "7ee68ff53045d5b72ee3657c3de76ed49ce81ce0", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f60bd75f4d8b776cf1e777b59d2d2262d03818a7/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f60bd75f4d8b776cf1e777b59d2d2262d03818a7/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "patch": "@@ -538,42 +538,6 @@ rust_uv_fs_req_cleanup(uv_fs_t* req) {\n   uv_fs_req_cleanup(req);\n }\n extern \"C\" int\n-rust_uv_get_O_RDONLY() {\n-  return O_RDONLY;\n-}\n-extern \"C\" int\n-rust_uv_get_O_WRONLY() {\n-  return O_WRONLY;\n-}\n-extern \"C\" int\n-rust_uv_get_O_RDWR() {\n-  return O_RDWR;\n-}\n-extern \"C\" int\n-rust_uv_get_O_CREAT() {\n-  return O_CREAT;\n-}\n-extern \"C\" int\n-rust_uv_get_O_TRUNC() {\n-  return O_TRUNC;\n-}\n-extern \"C\" int\n-rust_uv_get_S_IWUSR() {\n-  return S_IWUSR;\n-}\n-extern \"C\" int\n-rust_uv_get_S_IRUSR() {\n-  return S_IRUSR;\n-}\n-extern \"C\" int\n-rust_uv_get_S_IRGRP() {\n-  return S_IRGRP;\n-}\n-extern \"C\" int\n-rust_uv_get_S_IROTH() {\n-  return S_IROTH;\n-}\n-extern \"C\" int\n rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n   return req->result;\n }"}, {"sha": "5100e732308f2dbeb39d38460a751ff44e3e5c31", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f60bd75f4d8b776cf1e777b59d2d2262d03818a7/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f60bd75f4d8b776cf1e777b59d2d2262d03818a7/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "patch": "@@ -113,15 +113,6 @@ rust_uv_fs_unlink\n rust_uv_fs_write\n rust_uv_fs_read\n rust_uv_fs_close\n-rust_uv_get_O_RDONLY\n-rust_uv_get_O_WRONLY\n-rust_uv_get_O_RDWR\n-rust_uv_get_O_CREAT\n-rust_uv_get_O_TRUNC\n-rust_uv_get_S_IRUSR\n-rust_uv_get_S_IWUSR\n-rust_uv_get_S_IROTH\n-rust_uv_get_S_IRGRP\n rust_uv_get_result_from_fs_req\n rust_uv_get_loop_from_fs_req\n rust_uv_fs_req_cleanup"}]}