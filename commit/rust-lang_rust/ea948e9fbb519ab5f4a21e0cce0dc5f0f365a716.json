{"sha": "ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhOTQ4ZTlmYmI1MTlhYjVmNGEyMWUwY2NlMGRjNWYwZjM2NWE3MTY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-25T09:04:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-25T09:04:17Z"}, "message": "refactor typing_handlers", "tree": {"sha": "6d4aea51365d7bdc22c8217cfa0f5fa3257e4b6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d4aea51365d7bdc22c8217cfa0f5fa3257e4b6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716", "html_url": "https://github.com/rust-lang/rust/commit/ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f00bb1cb0e5fb72fac092d63c07f8652091d4d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9", "html_url": "https://github.com/rust-lang/rust/commit/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9"}], "stats": {"total": 76, "additions": 41, "deletions": 35}, "files": [{"sha": "d0188da4493e6f19550dd141babbfc572a9b8462", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716", "patch": "@@ -323,6 +323,10 @@ impl Analysis {\n         position: FilePosition,\n         char_typed: char,\n     ) -> Cancelable<Option<SourceChange>> {\n+        // Fast path to not even parse the file.\n+        if !typing::TRIGGER_CHARS.contains(char_typed) {\n+            return Ok(None);\n+        }\n         self.with_db(|db| typing::on_char_typed(&db, position, char_typed))\n     }\n "}, {"sha": "17d0f08a5a09d6cc364062ad113af15497a3d4ef", "filename": "crates/ra_ide_api/src/typing.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs?ref=ea948e9fbb519ab5f4a21e0cce0dc5f0f365a716", "patch": "@@ -81,22 +81,32 @@ fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {\n     Some(text[pos..].into())\n }\n \n+pub(crate) const TRIGGER_CHARS: &str = \".=\";\n+\n pub(crate) fn on_char_typed(\n     db: &RootDatabase,\n     position: FilePosition,\n     char_typed: char,\n ) -> Option<SourceChange> {\n+    assert!(TRIGGER_CHARS.contains(char_typed));\n     let file = &db.parse(position.file_id).tree();\n     assert_eq!(file.syntax().text().char_at(position.offset), Some(char_typed));\n-    let single_file_change = match char_typed {\n-        '=' => on_eq_typed(file, position.offset)?,\n-        '.' => on_dot_typed(file, position.offset)?,\n-        _ => return None,\n-    };\n-\n+    let single_file_change = on_char_typed_inner(file, position.offset, char_typed)?;\n     Some(single_file_change.into_source_change(position.file_id))\n }\n \n+fn on_char_typed_inner(\n+    file: &SourceFile,\n+    offset: TextUnit,\n+    char_typed: char,\n+) -> Option<SingleFileChange> {\n+    match char_typed {\n+        '.' => on_dot_typed(file, offset),\n+        '=' => on_eq_typed(file, offset),\n+        _ => None,\n+    }\n+}\n+\n /// Returns an edit which should be applied after `=` was typed. Primarily,\n /// this works when adding `let =`.\n // FIXME: use a snippet completion instead of this hack here.\n@@ -167,22 +177,29 @@ mod tests {\n \n     use super::*;\n \n+    fn type_char(char_typed: char, before: &str, after: &str) {\n+        let (offset, before) = extract_offset(before);\n+        let edit = TextEdit::insert(offset, char_typed.to_string());\n+        let before = edit.apply(&before);\n+        let parse = SourceFile::parse(&before);\n+        if let Some(result) = on_char_typed_inner(&parse.tree(), offset, char_typed) {\n+            let actual = result.edit.apply(&before);\n+            assert_eq_text!(after, &actual);\n+        } else {\n+            assert_eq_text!(&before, after)\n+        };\n+    }\n+\n+    fn type_eq(before: &str, after: &str) {\n+        type_char('=', before, after);\n+    }\n+\n+    fn type_dot(before: &str, after: &str) {\n+        type_char('.', before, after);\n+    }\n+\n     #[test]\n     fn test_on_eq_typed() {\n-        fn type_eq(before: &str, after: &str) {\n-            let (offset, before) = extract_offset(before);\n-            let mut edit = TextEditBuilder::default();\n-            edit.insert(offset, \"=\".to_string());\n-            let before = edit.finish().apply(&before);\n-            let parse = SourceFile::parse(&before);\n-            if let Some(result) = on_eq_typed(&parse.tree(), offset) {\n-                let actual = result.edit.apply(&before);\n-                assert_eq_text!(after, &actual);\n-            } else {\n-                assert_eq_text!(&before, after)\n-            };\n-        }\n-\n         //     do_check(r\"\n         // fn foo() {\n         //     let foo =<|>\n@@ -217,21 +234,6 @@ fn foo() {\n         // \");\n     }\n \n-    fn type_dot(before: &str, after: &str) {\n-        let (offset, before) = extract_offset(before);\n-        let mut edit = TextEditBuilder::default();\n-        edit.insert(offset, \".\".to_string());\n-        let before = edit.finish().apply(&before);\n-        let (analysis, file_id) = single_file(&before);\n-        let file = analysis.parse(file_id).unwrap();\n-        if let Some(result) = on_dot_typed(&file, offset) {\n-            let actual = result.edit.apply(&before);\n-            assert_eq_text!(after, &actual);\n-        } else {\n-            assert_eq_text!(&before, after)\n-        };\n-    }\n-\n     #[test]\n     fn indents_new_chain_call() {\n         type_dot("}]}