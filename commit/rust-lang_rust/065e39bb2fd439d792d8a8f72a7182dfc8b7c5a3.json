{"sha": "065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NWUzOWJiMmZkNDM5ZDc5MmQ4YThmNzJhNzE4MmRmYzhiN2M1YTM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-12T20:17:55Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-12T20:17:55Z"}, "message": "Register new snapshots", "tree": {"sha": "7dc0761aee6f0eef769a3a4bbc475d3df7a789f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dc0761aee6f0eef769a3a4bbc475d3df7a789f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "html_url": "https://github.com/rust-lang/rust/commit/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4ead7b034c96b705ec34b8325f5f9f778f1cbb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4ead7b034c96b705ec34b8325f5f9f778f1cbb9", "html_url": "https://github.com/rust-lang/rust/commit/e4ead7b034c96b705ec34b8325f5f9f778f1cbb9"}], "stats": {"total": 589, "additions": 9, "deletions": 580}, "files": [{"sha": "26f8522e1c18a9b6dd5f4aa9e47ad87048d69224", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -65,50 +65,12 @@ impl<T: Clone> Clone for Box<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T:PartialEq> PartialEq for Box<T> {\n-    #[inline]\n-    fn eq(&self, other: &Box<T>) -> bool { *(*self) == *(*other) }\n-    #[inline]\n-    fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n-}\n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T:PartialOrd> PartialOrd for Box<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n-        (**self).partial_cmp(&**other)\n-    }\n-    #[inline]\n-    fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n-    #[inline]\n-    fn le(&self, other: &Box<T>) -> bool { *(*self) <= *(*other) }\n-    #[inline]\n-    fn ge(&self, other: &Box<T>) -> bool { *(*self) >= *(*other) }\n-    #[inline]\n-    fn gt(&self, other: &Box<T>) -> bool { *(*self) > *(*other) }\n-}\n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord> Ord for Box<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Box<T>) -> Ordering {\n-        (**self).cmp(&**other)\n-    }\n-}\n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Eq> Eq for Box<T> {}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<Sized? T: PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n@@ -123,14 +85,12 @@ impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<Sized? T: Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<Sized? T: Eq> Eq for Box<T> {}\n \n /// Extension methods for an owning `Any` trait object."}, {"sha": "20aa29fbb3dccccffcf2c2043d3033da39f912fc", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -534,13 +534,6 @@ impl<'a> PartialOrd for MaybeOwned<'a> {\n }\n \n impl<'a> Ord for MaybeOwned<'a> {\n-    // NOTE(stage0): remove method after a snapshot\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn cmp(&self, other: &MaybeOwned) -> Ordering {\n-        self.as_slice().cmp(&other.as_slice())\n-    }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[inline]\n     fn cmp(&self, other: &MaybeOwned) -> Ordering {\n         self.as_slice().cmp(other.as_slice())"}, {"sha": "9958943a70c4904359c5be264dce9104531535db", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -506,13 +506,6 @@ impl<T: PartialEq> PartialEq for Vec<T> {\n \n #[unstable = \"waiting on PartialOrd stability\"]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n-    // NOTE(stage0): remove method after a snapshot\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n-        self.as_slice().partial_cmp(&other.as_slice())\n-    }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(other.as_slice())\n@@ -530,13 +523,6 @@ impl<T: PartialEq, V: AsSlice<T>> Equiv<V> for Vec<T> {\n \n #[unstable = \"waiting on Ord stability\"]\n impl<T: Ord> Ord for Vec<T> {\n-    // NOTE(stage0): remove method after a snapshot\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn cmp(&self, other: &Vec<T>) -> Ordering {\n-        self.as_slice().cmp(&other.as_slice())\n-    }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n         self.as_slice().cmp(other.as_slice())"}, {"sha": "078cfce128edd92332fe3a2276b5ce768f1effb6", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -55,33 +55,6 @@ use option::{Option, Some, None};\n ///\n /// Eventually, this will be implemented by default for types that implement\n /// `Eq`.\n-// NOTE(stage0): remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"eq\"]\n-#[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait PartialEq {\n-    /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n-    fn eq(&self, other: &Self) -> bool;\n-\n-    /// This method tests for `!=`.\n-    #[inline]\n-    fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n-}\n-\n-/// Trait for values that can be compared for equality and inequality.\n-///\n-/// This trait allows for partial equality, for types that do not have an\n-/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n-/// so floating point types implement `PartialEq` but not `Eq`.\n-///\n-/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n-/// in terms of it by default. Any manual implementation of `ne` *must* respect\n-/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n-/// only if `a != b`.\n-///\n-/// Eventually, this will be implemented by default for types that implement\n-/// `Eq`.\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[lang=\"eq\"]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialEq for Sized? {\n@@ -102,32 +75,6 @@ pub trait PartialEq for Sized? {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n-// NOTE(stage0): remove trait after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait Eq: PartialEq {\n-    // FIXME #13101: this method is used solely by #[deriving] to\n-    // assert that every component of a type implements #[deriving]\n-    // itself, the current deriving infrastructure means doing this\n-    // assertion without using a method on this trait is nearly\n-    // impossible.\n-    //\n-    // This should never be implemented by hand.\n-    #[doc(hidden)]\n-    #[inline(always)]\n-    fn assert_receiver_is_total_eq(&self) {}\n-}\n-\n-/// Trait for equality comparisons which are [equivalence relations](\n-/// https://en.wikipedia.org/wiki/Equivalence_relation).\n-///\n-/// This means, that in addition to `a == b` and `a != b` being strict\n-/// inverses, the equality must be (for all `a`, `b` and `c`):\n-///\n-/// - reflexive: `a == a`;\n-/// - symmetric: `a == b` implies `b == a`; and\n-/// - transitive: `a == b` and `b == c` implies `a == c`.\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Eq for Sized?: PartialEq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n@@ -198,33 +145,6 @@ impl Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n-// NOTE(stage0): remove trait after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait Ord: Eq + PartialOrd {\n-    /// This method returns an ordering between `self` and `other` values.\n-    ///\n-    /// By convention, `self.cmp(&other)` returns the ordering matching\n-    /// the expression `self <operator> other` if true.  For example:\n-    ///\n-    /// ```\n-    /// assert_eq!( 5u.cmp(&10), Less);     // because 5 < 10\n-    /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n-    /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n-    /// ```\n-    fn cmp(&self, other: &Self) -> Ordering;\n-}\n-\n-/// Trait for types that form a [total order](\n-/// https://en.wikipedia.org/wiki/Total_order).\n-///\n-/// An order is a total order if it is (for all `a`, `b` and `c`):\n-///\n-/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is\n-///   true; and\n-/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n-///   both `==` and `>`.\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Ord for Sized?: Eq + PartialOrd {\n     /// This method returns an ordering between `self` and `other` values.\n@@ -268,62 +188,6 @@ impl PartialOrd for Ordering {\n /// which do not have a total order. For example, for floating point numbers,\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n-// NOTE(stage0): remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"ord\"]\n-#[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait PartialOrd: PartialEq {\n-    /// This method returns an ordering between `self` and `other` values\n-    /// if one exists.\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering>;\n-\n-    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n-    #[inline]\n-    fn lt(&self, other: &Self) -> bool {\n-        match self.partial_cmp(other) {\n-            Some(Less) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// This method tests less than or equal to (`<=`).\n-    #[inline]\n-    fn le(&self, other: &Self) -> bool {\n-        match self.partial_cmp(other) {\n-            Some(Less) | Some(Equal) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// This method tests greater than (`>`).\n-    #[inline]\n-    fn gt(&self, other: &Self) -> bool {\n-        match self.partial_cmp(other) {\n-            Some(Greater) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// This method tests greater than or equal to (`>=`).\n-    #[inline]\n-    fn ge(&self, other: &Self) -> bool {\n-        match self.partial_cmp(other) {\n-            Some(Greater) | Some(Equal) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-/// Trait for values that can be compared for a sort-order.\n-///\n-/// PartialOrd only requires implementation of the `partial_cmp` method,\n-/// with the others generated from default implementations.\n-///\n-/// However it remains possible to implement the others separately for types\n-/// which do not have a total order. For example, for floating point numbers,\n-/// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n-/// 5.11).\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[lang=\"ord\"]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialOrd for Sized?: PartialEq {\n@@ -422,7 +286,6 @@ pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n mod impls {\n     use cmp::{PartialOrd, Ord, PartialEq, Eq, Ordering,\n               Less, Greater, Equal};\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     use kinds::Sized;\n     use option::{Option, Some, None};\n \n@@ -531,53 +394,14 @@ mod impls {\n     ord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n     // & pointers\n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, T: PartialEq> PartialEq for &'a T {\n-        #[inline]\n-        fn eq(&self, other: & &'a T) -> bool { *(*self) == *(*other) }\n-        #[inline]\n-        fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }\n-    }\n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, T: PartialOrd> PartialOrd for &'a T {\n-        #[inline]\n-        fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> {\n-            (**self).partial_cmp(*other)\n-        }\n-        #[inline]\n-        fn lt(&self, other: & &'a T) -> bool { *(*self) < *(*other) }\n-        #[inline]\n-        fn le(&self, other: & &'a T) -> bool { *(*self) <= *(*other) }\n-        #[inline]\n-        fn ge(&self, other: & &'a T) -> bool { *(*self) >= *(*other) }\n-        #[inline]\n-        fn gt(&self, other: & &'a T) -> bool { *(*self) > *(*other) }\n-    }\n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, T: Ord> Ord for &'a T {\n-        #[inline]\n-        fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }\n-    }\n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, T: Eq> Eq for &'a T {}\n \n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: PartialEq> PartialEq for &'a T {\n         #[inline]\n         fn eq(&self, other: & &'a T) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'a T) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: PartialOrd> PartialOrd for &'a T {\n         #[inline]\n@@ -593,64 +417,23 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'a T) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: Ord> Ord for &'a T {\n         #[inline]\n         fn cmp(&self, other: & &'a T) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: Eq> Eq for &'a T {}\n \n     // &mut pointers\n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, T: PartialEq> PartialEq for &'a mut T {\n-        #[inline]\n-        fn eq(&self, other: &&'a mut T) -> bool { **self == *(*other) }\n-        #[inline]\n-        fn ne(&self, other: &&'a mut T) -> bool { **self != *(*other) }\n-    }\n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, T: PartialOrd> PartialOrd for &'a mut T {\n-        #[inline]\n-        fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> {\n-            (**self).partial_cmp(*other)\n-        }\n-        #[inline]\n-        fn lt(&self, other: &&'a mut T) -> bool { **self < **other }\n-        #[inline]\n-        fn le(&self, other: &&'a mut T) -> bool { **self <= **other }\n-        #[inline]\n-        fn ge(&self, other: &&'a mut T) -> bool { **self >= **other }\n-        #[inline]\n-        fn gt(&self, other: &&'a mut T) -> bool { **self > **other }\n-    }\n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, T: Ord> Ord for &'a mut T {\n-        #[inline]\n-        fn cmp(&self, other: &&'a mut T) -> Ordering { (**self).cmp(*other) }\n-    }\n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, T: Eq> Eq for &'a mut T {}\n \n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: PartialEq> PartialEq for &'a mut T {\n         #[inline]\n         fn eq(&self, other: &&'a mut T) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'a mut T) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: PartialOrd> PartialOrd for &'a mut T {\n         #[inline]\n@@ -666,13 +449,11 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'a mut T) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: Ord> Ord for &'a mut T {\n         #[inline]\n         fn cmp(&self, other: &&'a mut T) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: Eq> Eq for &'a mut T {}\n }"}, {"sha": "9689f7cdd711428c5d1d0cff2cb6213029204ea4", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -127,7 +127,6 @@ pub mod unit;\n pub mod fmt;\n \n // note: does not need to be public\n-#[cfg(not(stage0))]\n mod array;\n \n #[doc(hidden)]"}, {"sha": "3a2e178d2ea0a6ebbc81d2322554af5766978282", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -805,12 +805,10 @@ pub trait Deref<Sized? Result> {\n     fn deref<'a>(&'a self) -> &'a Result;\n }\n \n-#[cfg(not(stage0))]\n impl<'a, Sized? T> Deref<T> for &'a T {\n     fn deref(&self) -> &T { *self }\n }\n \n-#[cfg(not(stage0))]\n impl<'a, Sized? T> Deref<T> for &'a mut T {\n     fn deref(&self) -> &T { *self }\n }\n@@ -855,7 +853,6 @@ pub trait DerefMut<Sized? Result>: Deref<Result> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Result;\n }\n \n-#[cfg(not(stage0))]\n impl<'a, Sized? T> DerefMut<T> for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }"}, {"sha": "8a70ce648d662b2be7c4a4fff394a65217e12789", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -1661,21 +1661,6 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"waiting for DST\"]\n-impl<'a,T:PartialEq> PartialEq for &'a [T] {\n-    fn eq(&self, other: & &'a [T]) -> bool {\n-        self.len() == other.len() &&\n-            order::eq(self.iter(), other.iter())\n-    }\n-    fn ne(&self, other: & &'a [T]) -> bool {\n-        self.len() != other.len() ||\n-            order::ne(self.iter(), other.iter())\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[unstable = \"waiting for DST\"]\n impl<T: PartialEq> PartialEq for [T] {\n     fn eq(&self, other: &[T]) -> bool {\n@@ -1688,12 +1673,6 @@ impl<T: PartialEq> PartialEq for [T] {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"waiting for DST\"]\n-impl<'a,T:Eq> Eq for &'a [T] {}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[unstable = \"waiting for DST\"]\n impl<T: Eq> Eq for [T] {}\n \n@@ -1703,75 +1682,19 @@ impl<T: PartialEq, V: AsSlice<T>> Equiv<V> for [T] {\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"waiting for DST\"]\n-impl<'a,T:PartialEq> PartialEq for &'a mut [T] {\n-    fn eq(&self, other: & &'a mut [T]) -> bool {\n-        self.len() == other.len() &&\n-        order::eq(self.iter(), other.iter())\n-    }\n-    fn ne(&self, other: & &'a mut [T]) -> bool {\n-        self.len() != other.len() ||\n-        order::ne(self.iter(), other.iter())\n-    }\n-}\n-\n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"waiting for DST\"]\n-impl<'a,T:Eq> Eq for &'a mut [T] {}\n-\n #[unstable = \"waiting for DST\"]\n impl<'a,T:PartialEq, V: AsSlice<T>> Equiv<V> for &'a mut [T] {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"waiting for DST\"]\n-impl<'a,T:Ord> Ord for &'a [T] {\n-    fn cmp(&self, other: & &'a [T]) -> Ordering {\n-        order::cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[unstable = \"waiting for DST\"]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-#[unstable = \"waiting for DST\"]\n-impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n-    #[inline]\n-    fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> {\n-        order::partial_cmp(self.iter(), other.iter())\n-    }\n-    #[inline]\n-    fn lt(&self, other: & &'a [T]) -> bool {\n-        order::lt(self.iter(), other.iter())\n-    }\n-    #[inline]\n-    fn le(&self, other: & &'a [T]) -> bool {\n-        order::le(self.iter(), other.iter())\n-    }\n-    #[inline]\n-    fn ge(&self, other: & &'a [T]) -> bool {\n-        order::ge(self.iter(), other.iter())\n-    }\n-    #[inline]\n-    fn gt(&self, other: & &'a [T]) -> bool {\n-        order::gt(self.iter(), other.iter())\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[unstable = \"waiting for DST\"]\n impl<T: PartialOrd> PartialOrd for [T] {\n     #[inline]"}, {"sha": "7e9d414ca5393631233721f568fa51f494eaac98", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -1121,24 +1121,6 @@ pub mod traits {\n     use ops;\n     use str::{Str, StrPrelude, eq_slice};\n \n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    impl<'a> Ord for &'a str {\n-        #[inline]\n-        fn cmp(&self, other: & &'a str) -> Ordering {\n-            for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n-                match s_b.cmp(&o_b) {\n-                    Greater => return Greater,\n-                    Less => return Less,\n-                    Equal => ()\n-                }\n-            }\n-\n-            self.len().cmp(&other.len())\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n@@ -1154,18 +1136,6 @@ pub mod traits {\n         }\n     }\n \n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    impl<'a> PartialEq for &'a str {\n-        #[inline]\n-        fn eq(&self, other: & &'a str) -> bool {\n-            eq_slice((*self), (*other))\n-        }\n-        #[inline]\n-        fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n-    }\n-\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n@@ -1175,23 +1145,8 @@ pub mod traits {\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n     }\n \n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    impl<'a> Eq for &'a str {}\n-\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     impl Eq for str {}\n \n-    // NOTE(stage0): remove impl after a snapshot\n-    #[cfg(stage0)]\n-    impl<'a> PartialOrd for &'a str {\n-        #[inline]\n-        fn partial_cmp(&self, other: &&'a str) -> Option<Ordering> {\n-            Some(self.cmp(other))\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     impl PartialOrd for str {\n         #[inline]\n         fn partial_cmp(&self, other: &str) -> Option<Ordering> {"}, {"sha": "d091a98933c09ee7bb3e12de45689703265a161d", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -76,24 +76,12 @@ impl<'a, T: PartialEq> PartialEq for MaybeOwnedVector<'a, T> {\n impl<'a, T: Eq> Eq for MaybeOwnedVector<'a, T> {}\n \n impl<'a, T: PartialOrd> PartialOrd for MaybeOwnedVector<'a, T> {\n-    // NOTE(stage0): remove method after a snapshot\n-    #[cfg(stage0)]\n-    fn partial_cmp(&self, other: &MaybeOwnedVector<T>) -> Option<Ordering> {\n-        self.as_slice().partial_cmp(&other.as_slice())\n-    }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     fn partial_cmp(&self, other: &MaybeOwnedVector<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(other.as_slice())\n     }\n }\n \n impl<'a, T: Ord> Ord for MaybeOwnedVector<'a, T> {\n-    // NOTE(stage0): remove method after a snapshot\n-    #[cfg(stage0)]\n-    fn cmp(&self, other: &MaybeOwnedVector<T>) -> Ordering {\n-        self.as_slice().cmp(&other.as_slice())\n-    }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     fn cmp(&self, other: &MaybeOwnedVector<T>) -> Ordering {\n         self.as_slice().cmp(other.as_slice())\n     }"}, {"sha": "ba3134d7d1619b8c046e9665ecc2a56d5b536c21", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -1020,16 +1020,6 @@ fn is_valid_cap(c: char) -> bool {\n     || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n }\n \n-// NOTE(stage0): remove function after a snapshot\n-#[cfg(stage0)]\n-fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n-    match classes.binary_search(|&(s, _)| s.cmp(&name)) {\n-        slice::Found(i) => Some(classes[i].val1().to_vec()),\n-        slice::NotFound(_) => None,\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n     match classes.binary_search(|&(s, _)| s.cmp(name)) {\n         slice::Found(i) => Some(classes[i].val1().to_vec()),"}, {"sha": "edd82b42876aafed6f28f3b768ac331b8e74c8d1", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -182,21 +182,6 @@ Available lint options:\n \n \");\n \n-    // NOTE(stage0): remove function after a snapshot\n-    #[cfg(stage0)]\n-    fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n-        let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n-        lints.sort_by(|x: &&Lint, y: &&Lint| {\n-            match x.default_level.cmp(&y.default_level) {\n-                // The sort doesn't case-fold but it's doubtful we care.\n-                Equal => x.name.cmp(&y.name),\n-                r => r,\n-            }\n-        });\n-        lints\n-    }\n-\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n         lints.sort_by(|x: &&Lint, y: &&Lint| {\n@@ -209,19 +194,6 @@ Available lint options:\n         lints\n     }\n \n-    // NOTE(stage0): remove function after a snapshot\n-    #[cfg(stage0)]\n-    fn sort_lint_groups(lints: Vec<(&'static str, Vec<lint::LintId>, bool)>)\n-                     -> Vec<(&'static str, Vec<lint::LintId>)> {\n-        let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n-        lints.sort_by(|&(x, _): &(&'static str, Vec<lint::LintId>),\n-                       &(y, _): &(&'static str, Vec<lint::LintId>)| {\n-            x.cmp(&y)\n-        });\n-        lints\n-    }\n-\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     fn sort_lint_groups(lints: Vec<(&'static str, Vec<lint::LintId>, bool)>)\n                      -> Vec<(&'static str, Vec<lint::LintId>)> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();"}, {"sha": "21186a5ac30892ec992a89921d4542b63399ca07", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -121,13 +121,6 @@ impl PartialEq for CString {\n }\n \n impl PartialOrd for CString {\n-    // NOTE(stage0): remove method after a snapshot\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn partial_cmp(&self, other: &CString) -> Option<Ordering> {\n-        self.as_bytes().partial_cmp(&other.as_bytes())\n-    }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     #[inline]\n     fn partial_cmp(&self, other: &CString) -> Option<Ordering> {\n         self.as_bytes().partial_cmp(other.as_bytes())"}, {"sha": "0b557b9142fa15b6248a95098e39a4b397b106b2", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -890,18 +890,6 @@ impl Json {\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n-    // NOTE(stage0): remove function after a snapshot\n-    #[cfg(stage0)]\n-    pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n-        match self {\n-            &Object(ref map) => map.find_with(|s| key.cmp(&s.as_slice())),\n-            _ => None\n-        }\n-    }\n-\n-     /// If the Json value is an Object, returns the value associated with the provided key.\n-    /// Otherwise, returns None.\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n         match self {\n             &Object(ref map) => map.find_with(|s| key.cmp(s.as_slice())),\n@@ -926,32 +914,6 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n-    // NOTE(stage0): remove function after a snapshot\n-    #[cfg(stage0)]\n-    pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n-        match self {\n-            &Object(ref map) => {\n-                match map.find_with(|s| key.cmp(&s.as_slice())) {\n-                    Some(json_value) => Some(json_value),\n-                    None => {\n-                        for (_, v) in map.iter() {\n-                            match v.search(key) {\n-                                x if x.is_some() => return x,\n-                                _ => ()\n-                            }\n-                        }\n-                        None\n-                    }\n-                }\n-            },\n-            _ => None\n-        }\n-    }\n-\n-    /// If the Json value is an Object, performs a depth-first search until\n-    /// a value associated with the provided key is found. If no value is found\n-    /// or the Json value is not an Object, returns None.\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {"}, {"sha": "da670d5a3e5dc4978fc551efc6f977355578a40c", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -165,29 +165,6 @@ impl<K, V> RawBucket<K, V> {\n     }\n }\n \n-// For parameterizing over mutability.\n-\n-#[cfg(stage0)]\n-impl<'t, K, V> Deref<RawTable<K, V>> for &'t RawTable<K, V> {\n-    fn deref(&self) -> &RawTable<K, V> {\n-        &**self\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<'t, K, V> Deref<RawTable<K, V>> for &'t mut RawTable<K, V> {\n-    fn deref(&self) -> &RawTable<K,V> {\n-        &**self\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<'t, K, V> DerefMut<RawTable<K, V>> for &'t mut RawTable<K, V> {\n-    fn deref_mut(&mut self) -> &mut RawTable<K,V> {\n-        &mut **self\n-    }\n-}\n-\n // Buckets hold references to the table.\n impl<K, V, M> FullBucket<K, V, M> {\n     /// Borrow a reference to the table."}, {"sha": "7588d15b678a34ec4d19106fe0e38146bca3d6ed", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -97,12 +97,6 @@ pub struct RcStr {\n impl Eq for RcStr {}\n \n impl Ord for RcStr {\n-    // NOTE(stage0): remove method after a snapshot\n-    #[cfg(stage0)]\n-    fn cmp(&self, other: &RcStr) -> Ordering {\n-        self.as_slice().cmp(&other.as_slice())\n-    }\n-    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n     fn cmp(&self, other: &RcStr) -> Ordering {\n         self.as_slice().cmp(other.as_slice())\n     }"}, {"sha": "78f88fa1b58574cc57f3be5b871589c3098c0ed1", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -973,56 +973,6 @@ fn get_concurrency() -> uint {\n     }\n }\n \n-// NOTE(stage0): remove function after a snapshot\n-#[cfg(stage0)]\n-pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n-    let mut filtered = tests;\n-\n-    // Remove tests that don't match the test filter\n-    filtered = match opts.filter {\n-        None => filtered,\n-        Some(ref re) => {\n-            filtered.into_iter()\n-                .filter(|test| re.is_match(test.desc.name.as_slice())).collect()\n-        }\n-    };\n-\n-    // Maybe pull out the ignored test and unignore them\n-    filtered = if !opts.run_ignored {\n-        filtered\n-    } else {\n-        fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n-            if test.desc.ignore {\n-                let TestDescAndFn {desc, testfn} = test;\n-                Some(TestDescAndFn {\n-                    desc: TestDesc {ignore: false, ..desc},\n-                    testfn: testfn\n-                })\n-            } else {\n-                None\n-            }\n-        };\n-        filtered.into_iter().filter_map(|x| filter(x)).collect()\n-    };\n-\n-    // Sort the tests alphabetically\n-    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(&t2.desc.name.as_slice()));\n-\n-    // Shard the remaining tests, if sharding requested.\n-    match opts.test_shard {\n-        None => filtered,\n-        Some((a,b)) => {\n-            filtered.into_iter().enumerate()\n-            // note: using a - 1 so that the valid shards, for example, are\n-            // 1.2 and 2.2 instead of 0.2 and 1.2\n-            .filter(|&(i,_)| i % b == (a - 1))\n-            .map(|(_,t)| t)\n-            .collect()\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     let mut filtered = tests;\n "}, {"sha": "f679be2cbdbcd8a5ce7fda435c62326123108cf0", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=065e39bb2fd439d792d8a8f72a7182dfc8b7c5a3", "patch": "@@ -1,3 +1,12 @@\n+S 2014-11-10 f89e975\n+  freebsd-x86_64 52702569e3c3361d6fd96968443791e76bed18e3\n+  linux-i386 3f8bb33f86800affca3cb7245925c19b28a94498\n+  linux-x86_64 e0e13a4312bea0bcc7db35b46bcce957178b18a4\n+  macos-i386 22f084aaecb773e8348c64fb9ac6d5eba363eb56\n+  macos-x86_64 c8554badab19cee96fbf51c2b98ee1bba87caa5c\n+  winnt-i386 936bd7a60bce83208d34f2369a0178937e140fba\n+  winnt-x86_64 09ba12dc41b7305d3f15ca27ec8d0a5a2a64b204\n+\n S 2014-11-04 1b2ad78\n   freebsd-x86_64 f8c41a522d6a3c9691a0865dab170dcb988e9141\n   linux-i386 d827fbbd778b854923971873cf03bdb79c2e8575"}]}