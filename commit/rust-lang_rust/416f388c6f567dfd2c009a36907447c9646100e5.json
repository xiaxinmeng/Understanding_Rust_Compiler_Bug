{"sha": "416f388c6f567dfd2c009a36907447c9646100e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNmYzODhjNmY1NjdkZmQyYzAwOWEzNjkwNzQ0N2M5NjQ2MTAwZTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-07T10:12:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-17T14:12:55Z"}, "message": "Port to use the new Unify code, which has no UnifyValue trait\nbut is otherwise mostly the same.", "tree": {"sha": "d0ee33719cb42b247748ea55bd9cf184f639a585", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0ee33719cb42b247748ea55bd9cf184f639a585"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/416f388c6f567dfd2c009a36907447c9646100e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/416f388c6f567dfd2c009a36907447c9646100e5", "html_url": "https://github.com/rust-lang/rust/commit/416f388c6f567dfd2c009a36907447c9646100e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/416f388c6f567dfd2c009a36907447c9646100e5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "html_url": "https://github.com/rust-lang/rust/commit/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d"}], "stats": {"total": 488, "additions": 363, "deletions": 125}, "files": [{"sha": "d93d13beec8fc47867e881886be8d85faba4ceab", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=416f388c6f567dfd2c009a36907447c9646100e5", "patch": "@@ -37,7 +37,7 @@ use middle::ty_fold::TypeFolder;\n use std::collections::hash_map::{self, Entry};\n \n use super::InferCtxt;\n-use super::unify::ToType;\n+use super::unify_key::ToType;\n \n pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,"}, {"sha": "b0921a266f39f9c14a5eaa038b0162ae75d1cbf1", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=416f388c6f567dfd2c009a36907447c9646100e5", "patch": "@@ -29,6 +29,7 @@ use middle::ty::replace_late_bound_regions;\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell};\n use std::fmt;\n use std::rc::Rc;\n@@ -41,8 +42,8 @@ use util::ppaux::{Repr, UserString};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n-use self::unify::{ToType, UnificationTable};\n use self::error_reporting::ErrorReporting;\n+use self::unify_key::ToType;\n \n pub mod bivariate;\n pub mod combine;\n@@ -57,7 +58,7 @@ pub mod resolve;\n mod freshen;\n pub mod sub;\n pub mod type_variable;\n-pub mod unify;\n+pub mod unify_key;\n \n pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\""}, {"sha": "6b23e2c5029b8cddff34586de80e4e997272653f", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=416f388c6f567dfd2c009a36907447c9646100e5", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{self, IntVarValue, Ty};\n+use rustc_data_structures::unify::UnifyKey;\n+use syntax::ast;\n+\n+pub trait ToType<'tcx> {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n+}\n+\n+impl UnifyKey for ty::IntVid {\n+    type Value = Option<IntVarValue>;\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::IntVid { ty::IntVid { index: i } }\n+    fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n+}\n+\n+impl<'tcx> ToType<'tcx> for IntVarValue {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            ty::IntType(i) => ty::mk_mach_int(tcx, i),\n+            ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n+        }\n+    }\n+}\n+\n+// Floating point type keys\n+\n+impl UnifyKey for ty::FloatVid {\n+    type Value = Option<ast::FloatTy>;\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::FloatVid { ty::FloatVid { index: i } }\n+    fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n+}\n+\n+impl<'tcx> ToType<'tcx> for ast::FloatTy {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        ty::mk_mach_float(tcx, *self)\n+    }\n+}"}, {"sha": "6562a7488984cfae1481cb84ff01f8574471294b", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=416f388c6f567dfd2c009a36907447c9646100e5", "patch": "@@ -35,3 +35,4 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod snapshot_vec;\n pub mod graph;\n pub mod bitvec;\n+pub mod unify;"}, {"sha": "aff79e25956f29a00613463c6c6612233df88a9b", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "renamed", "additions": 125, "deletions": 122, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=416f388c6f567dfd2c009a36907447c9646100e5", "patch": "@@ -8,16 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::VarValue::*;\n-\n use std::marker;\n-\n-use middle::ty::{IntVarValue};\n-use middle::ty::{self, Ty};\n use std::fmt::Debug;\n use std::marker::PhantomData;\n-use syntax::ast;\n-use rustc_data_structures::snapshot_vec as sv;\n+use snapshot_vec as sv;\n+\n+#[cfg(test)]\n+mod test;\n \n /// This trait is implemented by any type that can serve as a type\n /// variable. We call such variables *unification keys*. For example,\n@@ -28,9 +25,10 @@ use rustc_data_structures::snapshot_vec as sv;\n /// `IntVid`, this is `Option<IntVarValue>`, representing some\n /// (possibly not yet known) sort of integer.\n ///\n-/// Implementations of this trait are at the end of this file.\n-pub trait UnifyKey : Clone + Debug + PartialEq {\n-    type Value : UnifyValue;\n+/// Clients are expected to provide implementations of this trait; you\n+/// can see some examples in the `test` module.\n+pub trait UnifyKey : Copy + Clone + Debug + PartialEq {\n+    type Value: Clone + PartialEq + Debug;\n \n     fn index(&self) -> u32;\n \n@@ -39,15 +37,6 @@ pub trait UnifyKey : Clone + Debug + PartialEq {\n     fn tag(k: Option<Self>) -> &'static str;\n }\n \n-/// Trait for valid types that a type variable can be set to. Note that\n-/// this is typically not the end type that the value will take on, but\n-/// rather an `Option` wrapper (where `None` represents a variable\n-/// whose value is not yet set).\n-///\n-/// Implementations of this trait are at the end of this file.\n-pub trait UnifyValue : Clone + PartialEq + Debug {\n-}\n-\n /// Value of a unification key. We implement Tarjan's union-find\n /// algorithm: when two keys are unified, one of them is converted\n /// into a \"redirect\" pointing at the other. These redirects form a\n@@ -57,9 +46,10 @@ pub trait UnifyValue : Clone + PartialEq + Debug {\n /// time of the algorithm under control. For more information, see\n /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n #[derive(PartialEq,Clone,Debug)]\n-pub enum VarValue<K:UnifyKey> {\n-    Redirect(K),\n-    Root(K::Value, usize),\n+pub struct VarValue<K:UnifyKey> {\n+    parent: K,       // if equal to self, this is a root\n+    value: K::Value, // value assigned (only relevant to root)\n+    rank: u32,       // max depth (only relevant to root)\n }\n \n /// Table of unification keys and their values.\n@@ -76,16 +66,46 @@ pub struct Snapshot<K:UnifyKey> {\n     snapshot: sv::Snapshot,\n }\n \n-/// Internal type used to represent the result of a `get()` operation.\n-/// Conveys the current root and value of the key.\n-pub struct Node<K:UnifyKey> {\n-    pub key: K,\n-    pub value: K::Value,\n-    pub rank: usize,\n-}\n-\n #[derive(Copy, Clone)]\n-pub struct Delegate<K>(PhantomData<K>);\n+struct Delegate<K>(PhantomData<K>);\n+\n+impl<K:UnifyKey> VarValue<K> {\n+    fn new_var(key: K, value: K::Value) -> VarValue<K> {\n+        VarValue::new(key, value, 0)\n+    }\n+\n+    fn new(parent: K, value: K::Value, rank: u32) -> VarValue<K> {\n+        VarValue { parent: parent, // this is a root\n+                   value: value,\n+                   rank: rank }\n+    }\n+\n+    fn redirect(self, to: K) -> VarValue<K> {\n+        VarValue { parent: to, ..self }\n+    }\n+\n+    fn root(self, rank: u32, value: K::Value) -> VarValue<K> {\n+        VarValue { rank: rank, value: value, ..self }\n+    }\n+\n+    /// Returns the key of this node. Only valid if this is a root\n+    /// node, which you yourself must ensure.\n+    fn key(&self) -> K {\n+        self.parent\n+    }\n+\n+    fn parent(&self, self_key: K) -> Option<K> {\n+        self.if_not_self(self.parent, self_key)\n+    }\n+\n+    fn if_not_self(&self, key: K, self_key: K) -> Option<K> {\n+        if key == self_key {\n+            None\n+        } else {\n+            Some(key)\n+        }\n+    }\n+}\n \n // We can't use V:LatticeValue, much as I would like to,\n // because frequently the pattern is that V=Option<U> for some\n@@ -95,7 +115,7 @@ pub struct Delegate<K>(PhantomData<K>);\n impl<K:UnifyKey> UnificationTable<K> {\n     pub fn new() -> UnificationTable<K> {\n         UnificationTable {\n-            values: sv::SnapshotVec::new(),\n+            values: sv::SnapshotVec::new()\n         }\n     }\n \n@@ -121,12 +141,13 @@ impl<K:UnifyKey> UnificationTable<K> {\n     }\n \n     pub fn new_key(&mut self, value: K::Value) -> K {\n-        let index = self.values.push(Root(value, 0));\n-        let k = UnifyKey::from_index(index as u32);\n+        let len = self.values.len();\n+        let key: K = UnifyKey::from_index(len as u32);\n+        self.values.push(VarValue::new_var(key, value));\n         debug!(\"{}: created new key: {:?}\",\n                UnifyKey::tag(None::<K>),\n-               k);\n-        k\n+               key);\n+        key\n     }\n \n     /// Find the root node for `vid`. This uses the standard\n@@ -135,36 +156,34 @@ impl<K:UnifyKey> UnificationTable<K> {\n     ///\n     /// NB. This is a building-block operation and you would probably\n     /// prefer to call `probe` below.\n-    fn get(&mut self, vid: K) -> Node<K> {\n+    fn get(&mut self, vid: K) -> VarValue<K> {\n         let index = vid.index() as usize;\n-        let value = (*self.values.get(index)).clone();\n-        match value {\n-            Redirect(redirect) => {\n-                let node: Node<K> = self.get(redirect.clone());\n-                if node.key != redirect {\n+        let mut value: VarValue<K> = self.values.get(index).clone();\n+        match value.parent(vid) {\n+            Some(redirect) => {\n+                let root: VarValue<K> = self.get(redirect);\n+                if root.key() != redirect {\n                     // Path compression\n-                    self.values.set(index, Redirect(node.key.clone()));\n+                    value.parent = root.key();\n+                    self.values.set(index, value);\n                 }\n-                node\n+                root\n             }\n-            Root(value, rank) => {\n-                Node { key: vid, value: value, rank: rank }\n+            None => {\n+                value\n             }\n         }\n     }\n \n-    fn is_root(&self, key: &K) -> bool {\n+    fn is_root(&self, key: K) -> bool {\n         let index = key.index() as usize;\n-        match *self.values.get(index) {\n-            Redirect(..) => false,\n-            Root(..) => true,\n-        }\n+        self.values.get(index).parent(key).is_none()\n     }\n \n     /// Sets the value for `vid` to `new_value`. `vid` MUST be a root\n     /// node! This is an internal operation used to impl other things.\n     fn set(&mut self, key: K, new_value: VarValue<K>) {\n-        assert!(self.is_root(&key));\n+        assert!(self.is_root(key));\n \n         debug!(\"Updating variable {:?} to {:?}\",\n                key, new_value);\n@@ -181,40 +200,68 @@ impl<K:UnifyKey> UnificationTable<K> {\n     /// really more of a building block. If the values associated with\n     /// your key are non-trivial, you would probably prefer to call\n     /// `unify_var_var` below.\n-    fn unify(&mut self, node_a: &Node<K>, node_b: &Node<K>, new_value: K::Value) {\n-        debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n-               node_a.key,\n-               node_a.rank,\n-               node_b.key,\n-               node_b.rank);\n-\n-        let (new_root, new_rank) = if node_a.rank > node_b.rank {\n+    fn unify(&mut self, root_a: VarValue<K>, root_b: VarValue<K>, new_value: K::Value) {\n+        debug!(\"unify(root_a(id={:?}, rank={:?}), root_b(id={:?}, rank={:?}))\",\n+               root_a.key(),\n+               root_a.rank,\n+               root_b.key(),\n+               root_b.rank);\n+\n+        if root_a.rank > root_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n-            (node_a.key.clone(), node_a.rank)\n-        } else if node_a.rank < node_b.rank {\n+            self.redirect_root(root_a.rank, root_b, root_a, new_value);\n+        } else if root_a.rank < root_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(node_a.key.clone(), Redirect(node_b.key.clone()));\n-            (node_b.key.clone(), node_b.rank)\n+            self.redirect_root(root_b.rank, root_a, root_b, new_value);\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n-            assert_eq!(node_a.rank, node_b.rank);\n-            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n-            (node_a.key.clone(), node_a.rank + 1)\n-        };\n+            self.redirect_root(root_a.rank + 1, root_a, root_b, new_value);\n+        }\n+    }\n \n-        self.set(new_root, Root(new_value, new_rank));\n+    fn redirect_root(&mut self,\n+                     new_rank: u32,\n+                     old_root: VarValue<K>,\n+                     new_root: VarValue<K>,\n+                     new_value: K::Value) {\n+        let old_root_key = old_root.key();\n+        let new_root_key = new_root.key();\n+        self.set(old_root_key, old_root.redirect(new_root_key));\n+        self.set(new_root_key, new_root.root(new_rank, new_value));\n     }\n }\n \n impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n     type Value = VarValue<K>;\n     type Undo = ();\n \n-    fn reverse(_: &mut Vec<VarValue<K>>, _: ()) {\n-        panic!(\"Nothing to reverse\");\n+    fn reverse(_: &mut Vec<VarValue<K>>, _: ()) {}\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Base union-find algorithm, where we are just making setes\n+\n+impl<'tcx,K> UnificationTable<K>\n+    where K : UnifyKey<Value=()>,\n+{\n+    pub fn union(&mut self, a_id: K, b_id: K) {\n+        let node_a = self.get(a_id);\n+        let node_b = self.get(b_id);\n+        let a_id = node_a.key();\n+        let b_id = node_b.key();\n+        if a_id != b_id {\n+            self.unify(node_a, node_b, ());\n+        }\n+    }\n+\n+    pub fn find(&mut self, id: K) -> K {\n+        self.get(id).key()\n+    }\n+\n+    pub fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n+        self.find(a_id) == self.find(b_id)\n     }\n }\n \n@@ -226,7 +273,6 @@ impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n impl<'tcx,K,V> UnificationTable<K>\n     where K: UnifyKey<Value=Option<V>>,\n           V: Clone+PartialEq,\n-          Option<V>: UnifyValue,\n {\n     pub fn unify_var_var(&mut self,\n                          a_id: K,\n@@ -235,8 +281,8 @@ impl<'tcx,K,V> UnificationTable<K>\n     {\n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n-        let a_id = node_a.key.clone();\n-        let b_id = node_b.key.clone();\n+        let a_id = node_a.key();\n+        let b_id = node_b.key();\n \n         if a_id == b_id { return Ok(()); }\n \n@@ -257,7 +303,7 @@ impl<'tcx,K,V> UnificationTable<K>\n             }\n         };\n \n-        Ok(self.unify(&node_a, &node_b, combined))\n+        Ok(self.unify(node_a, node_b, combined))\n     }\n \n     /// Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\n@@ -267,12 +313,12 @@ impl<'tcx,K,V> UnificationTable<K>\n                            b: V)\n                            -> Result<(),(V,V)>\n     {\n-        let node_a = self.get(a_id);\n-        let a_id = node_a.key.clone();\n+        let mut node_a = self.get(a_id);\n \n         match node_a.value {\n             None => {\n-                self.set(a_id, Root(Some(b), node_a.rank));\n+                node_a.value = Some(b);\n+                self.set(node_a.key(), node_a);\n                 Ok(())\n             }\n \n@@ -295,46 +341,3 @@ impl<'tcx,K,V> UnificationTable<K>\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n-// Integral type keys\n-\n-pub trait ToType<'tcx> {\n-    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n-}\n-\n-impl UnifyKey for ty::IntVid {\n-    type Value = Option<IntVarValue>;\n-    fn index(&self) -> u32 { self.index }\n-    fn from_index(i: u32) -> ty::IntVid { ty::IntVid { index: i } }\n-    fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n-}\n-\n-impl<'tcx> ToType<'tcx> for IntVarValue {\n-    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n-        match *self {\n-            ty::IntType(i) => ty::mk_mach_int(tcx, i),\n-            ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n-        }\n-    }\n-}\n-\n-impl UnifyValue for Option<IntVarValue> { }\n-\n-// Floating point type keys\n-\n-impl UnifyKey for ty::FloatVid {\n-    type Value = Option<ast::FloatTy>;\n-    fn index(&self) -> u32 { self.index }\n-    fn from_index(i: u32) -> ty::FloatVid { ty::FloatVid { index: i } }\n-    fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n-}\n-\n-impl UnifyValue for Option<ast::FloatTy> {\n-}\n-\n-impl<'tcx> ToType<'tcx> for ast::FloatTy {\n-    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n-        ty::mk_mach_float(tcx, *self)\n-    }\n-}", "previous_filename": "src/librustc/middle/infer/unify.rs"}, {"sha": "d662842a37afda44fce4ec0ab7d933416002c632", "filename": "src/librustc_data_structures/unify/test.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc_data_structures%2Funify%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416f388c6f567dfd2c009a36907447c9646100e5/src%2Flibrustc_data_structures%2Funify%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Ftest.rs?ref=416f388c6f567dfd2c009a36907447c9646100e5", "patch": "@@ -0,0 +1,185 @@\n+#![allow(non_snake_case)]\n+\n+extern crate test;\n+use self::test::Bencher;\n+use std::collections::HashSet;\n+use unify::{UnifyKey, UnificationTable};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+struct UnitKey(u32);\n+\n+impl UnifyKey for UnitKey {\n+    type Value = ();\n+    fn index(&self) -> u32 { self.0 }\n+    fn from_index(u: u32) -> UnitKey { UnitKey(u) }\n+    fn tag(_: Option<UnitKey>) -> &'static str { \"UnitKey\" }\n+}\n+\n+#[test]\n+fn basic() {\n+    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n+    let k1 = ut.new_key(());\n+    let k2 = ut.new_key(());\n+    assert_eq!(ut.unioned(k1, k2), false);\n+    ut.union(k1, k2);\n+    assert_eq!(ut.unioned(k1, k2), true);\n+}\n+\n+#[test]\n+fn big_array() {\n+    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n+    let mut keys = Vec::new();\n+    const MAX: usize = 1 << 15;\n+\n+    for _ in 0..MAX {\n+        keys.push(ut.new_key(()));\n+    }\n+\n+    for i in 1..MAX {\n+        let l = keys[i-1];\n+        let r = keys[i];\n+        ut.union(l, r);\n+    }\n+\n+    for i in 0..MAX {\n+        assert!(ut.unioned(keys[0], keys[i]));\n+    }\n+}\n+\n+#[bench]\n+fn big_array_bench(b: &mut Bencher) {\n+    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n+    let mut keys = Vec::new();\n+    const MAX: usize = 1 << 15;\n+\n+    for _ in 0..MAX {\n+        keys.push(ut.new_key(()));\n+    }\n+\n+\n+    b.iter(|| {\n+        for i in 1..MAX {\n+            let l = keys[i-1];\n+            let r = keys[i];\n+            ut.union(l, r);\n+        }\n+\n+        for i in 0..MAX {\n+            assert!(ut.unioned(keys[0], keys[i]));\n+        }\n+    })\n+}\n+\n+#[test]\n+fn even_odd() {\n+    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n+    let mut keys = Vec::new();\n+    const MAX: usize = 1 << 10;\n+\n+    for i in 0..MAX {\n+        let key = ut.new_key(());\n+        keys.push(key);\n+\n+        if i >= 2 {\n+            ut.union(key, keys[i-2]);\n+        }\n+    }\n+\n+    for i in 1..MAX {\n+        assert!(!ut.unioned(keys[i-1], keys[i]));\n+    }\n+\n+    for i in 2..MAX {\n+        assert!(ut.unioned(keys[i-2], keys[i]));\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+struct IntKey(u32);\n+\n+impl UnifyKey for IntKey {\n+    type Value = Option<i32>;\n+    fn index(&self) -> u32 { self.0 }\n+    fn from_index(u: u32) -> IntKey { IntKey(u) }\n+    fn tag(_: Option<IntKey>) -> &'static str { \"IntKey\" }\n+}\n+\n+/// Test unifying a key whose value is `Some(_)`  with a key whose value is `None`.\n+/// Afterwards both should be `Some(_)`.\n+#[test]\n+fn unify_key_Some_key_None() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    let k2 = ut.new_key(None);\n+    assert!(ut.unify_var_var(k1, k2).is_ok());\n+    assert_eq!(ut.probe(k2), Some(22));\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `None`  with a key whose value is `Some(_)`.\n+/// Afterwards both should be `Some(_)`.\n+#[test]\n+fn unify_key_None_key_Some() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    let k2 = ut.new_key(None);\n+    assert!(ut.unify_var_var(k2, k1).is_ok());\n+    assert_eq!(ut.probe(k2), Some(22));\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `Some(x)` with a key whose value is `Some(y)`.\n+/// This should yield an error.\n+#[test]\n+fn unify_key_Some_x_key_Some_y() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    let k2 = ut.new_key(Some(23));\n+    assert_eq!(ut.unify_var_var(k1, k2), Err((22, 23)));\n+    assert_eq!(ut.unify_var_var(k2, k1), Err((23, 22)));\n+    assert_eq!(ut.probe(k1), Some(22));\n+    assert_eq!(ut.probe(k2), Some(23));\n+}\n+\n+/// Test unifying a key whose value is `Some(x)` with a key whose value is `Some(x)`.\n+/// This should be ok.\n+#[test]\n+fn unify_key_Some_x_key_Some_x() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    let k2 = ut.new_key(Some(22));\n+    assert!(ut.unify_var_var(k1, k2).is_ok());\n+    assert_eq!(ut.probe(k1), Some(22));\n+    assert_eq!(ut.probe(k2), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `None` with a value is `x`.\n+/// Afterwards key should be `x`.\n+#[test]\n+fn unify_key_None_val() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(None);\n+    assert!(ut.unify_var_value(k1, 22).is_ok());\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `Some(x)` with the value `y`.\n+/// This should yield an error.\n+#[test]\n+fn unify_key_Some_x_val_y() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    assert_eq!(ut.unify_var_value(k1, 23), Err((22, 23)));\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `Some(x)` with the value `x`.\n+/// This should be ok.\n+#[test]\n+fn unify_key_Some_x_val_x() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    assert!(ut.unify_var_value(k1, 22).is_ok());\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+"}]}