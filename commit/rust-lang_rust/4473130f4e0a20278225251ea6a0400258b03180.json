{"sha": "4473130f4e0a20278225251ea6a0400258b03180", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NzMxMzBmNGUwYTIwMjc4MjI1MjUxZWE2YTA0MDAyNThiMDMxODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-30T13:01:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-30T13:01:39Z"}, "message": "Auto merge of #36126 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 16 pull requests\n\n- Successful merges: #35418, #35759, #35862, #35863, #35895, #35962, #35977, #35993, #35997, #36054, #36056, #36060, #36086, #36100, #36103, #36125\n- Failed merges: #35771, #35810", "tree": {"sha": "b4617649f5250d3a948c87bf1283eb66a1c96492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4617649f5250d3a948c87bf1283eb66a1c96492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4473130f4e0a20278225251ea6a0400258b03180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4473130f4e0a20278225251ea6a0400258b03180", "html_url": "https://github.com/rust-lang/rust/commit/4473130f4e0a20278225251ea6a0400258b03180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4473130f4e0a20278225251ea6a0400258b03180/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "url": "https://api.github.com/repos/rust-lang/rust/commits/71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "html_url": "https://github.com/rust-lang/rust/commit/71ee82a8aa0c02fc2c73e84f40bdb55512d10938"}, {"sha": "1d2308f2ed2c8708f78c5253661ec957f29b503b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2308f2ed2c8708f78c5253661ec957f29b503b", "html_url": "https://github.com/rust-lang/rust/commit/1d2308f2ed2c8708f78c5253661ec957f29b503b"}], "stats": {"total": 671, "additions": 543, "deletions": 128}, "files": [{"sha": "a9a81843ab199c471e3d2c2b56b7408c1d6b5b55", "filename": "src/doc/book/compiler-plugins.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcompiler-plugins.md?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -46,10 +46,10 @@ extern crate rustc;\n extern crate rustc_plugin;\n \n use syntax::parse::token;\n-use syntax::ast::TokenTree;\n+use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax::ext::build::AstBuilder;  // trait for expr_usize\n-use syntax_pos::Span;\n+use syntax::ext::quote::rt::Span;\n use rustc_plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n@@ -69,7 +69,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n     }\n \n     let text = match args[0] {\n-        TokenTree::Token(_, token::Ident(s, _)) => s.to_string(),\n+        TokenTree::Token(_, token::Ident(s)) => s.to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");\n             return DummyResult::any(sp);"}, {"sha": "b54b71cabd1e9cdaa21ee7a4b752733c52e09ac4", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -71,6 +71,12 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// does not use atomics, making it both thread-unsafe as well as significantly\n /// faster when updating the reference count.\n ///\n+/// Note: the inherent methods defined on `Arc<T>` are all associated functions,\n+/// which means that you have to call them as e.g.  `Arc::get_mut(&value)`\n+/// instead of `value.get_mut()`.  This is so that there are no conflicts with\n+/// methods on the inner type `T`, which are what you want to call in the\n+/// majority of cases.\n+///\n /// # Examples\n ///\n /// In this example, a large vector of data will be shared by several threads. First we"}, {"sha": "70c429cc3600a4f94809ee41470575e02b3f5a1c", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -271,6 +271,10 @@ impl<T: ?Sized> Box<T> {\n     /// proper way to do so is to convert the raw pointer back into a\n     /// `Box` with the `Box::from_raw` function.\n     ///\n+    /// Note: this is an associated function, which means that you have\n+    /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n+    /// is so that there is no conflict with a method on the inner type.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "c24c7ca47ad053ff6ae38be2947d5c3e20556f44", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -182,6 +182,12 @@ struct RcBox<T: ?Sized> {\n /// A reference-counted pointer type over an immutable value.\n ///\n /// See the [module level documentation](./index.html) for more details.\n+///\n+/// Note: the inherent methods defined on `Rc<T>` are all associated functions,\n+/// which means that you have to call them as e.g. `Rc::get_mut(&value)` instead\n+/// of `value.get_mut()`.  This is so that there are no conflicts with methods\n+/// on the inner type `T`, which are what you want to call in the majority of\n+/// cases.\n #[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {"}, {"sha": "beb3e6b3d4e3132bf87a012bd59935d1c691f583", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -165,9 +165,15 @@\n //! provides some helper methods.\n //!\n //! Additionally, the return value of this function is `fmt::Result` which is a\n-//! typedef to `Result<(), std::io::Error>` (also known as `std::io::Result<()>`).\n-//! Formatting implementations should ensure that they return errors from `write!`\n-//! correctly (propagating errors upward).\n+//! type alias of `Result<(), std::fmt::Error>`. Formatting implementations\n+//! should ensure that they propagate errors from the `Formatter` (e.g., when\n+//! calling `write!`) however, they should never return errors spuriously. That\n+//! is, a formatting implementation must and may only return an error if the\n+//! passed-in `Formatter` returns an error. This is because, contrary to what\n+//! the function signature might suggest, string formatting is an infallible\n+//! operation. This function only returns a result because writing to the\n+//! underlying stream might fail and it must provide a way to propagate the fact\n+//! that an error has occurred back up the stack.\n //!\n //! An example of implementing the formatting traits would look\n //! like:"}, {"sha": "f0710a1d93578495eeb0ccc3c0365d34df675674", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -119,26 +119,55 @@\n //! `Cell<T>`.\n //!\n //! ```\n+//! #![feature(core_intrinsics)]\n+//! #![feature(shared)]\n //! use std::cell::Cell;\n+//! use std::ptr::Shared;\n+//! use std::intrinsics::abort;\n+//! use std::intrinsics::assume;\n //!\n-//! struct Rc<T> {\n-//!     ptr: *mut RcBox<T>\n+//! struct Rc<T: ?Sized> {\n+//!     ptr: Shared<RcBox<T>>\n //! }\n //!\n-//! struct RcBox<T> {\n-//! # #[allow(dead_code)]\n+//! struct RcBox<T: ?Sized> {\n+//!     strong: Cell<usize>,\n+//!     refcount: Cell<usize>,\n //!     value: T,\n-//!     refcount: Cell<usize>\n //! }\n //!\n-//! impl<T> Clone for Rc<T> {\n+//! impl<T: ?Sized> Clone for Rc<T> {\n //!     fn clone(&self) -> Rc<T> {\n-//!         unsafe {\n-//!             (*self.ptr).refcount.set((*self.ptr).refcount.get() + 1);\n-//!             Rc { ptr: self.ptr }\n-//!         }\n+//!         self.inc_strong();\n+//!         Rc { ptr: self.ptr }\n+//!     }\n+//! }\n+//!\n+//! trait RcBoxPtr<T: ?Sized> {\n+//!\n+//!     fn inner(&self) -> &RcBox<T>;\n+//!\n+//!     fn strong(&self) -> usize {\n+//!         self.inner().strong.get()\n+//!     }\n+//!\n+//!     fn inc_strong(&self) {\n+//!         self.inner()\n+//!             .strong\n+//!             .set(self.strong()\n+//!                      .checked_add(1)\n+//!                      .unwrap_or_else(|| unsafe { abort() }));\n //!     }\n //! }\n+//!\n+//! impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n+//!    fn inner(&self) -> &RcBox<T> {\n+//!        unsafe {\n+//!            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n+//!            &(**self.ptr)\n+//!        }\n+//!    }\n+//! }\n //! ```\n //!\n "}, {"sha": "14aa2ba3bd429b1344806553d650b879d6ef7a56", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 325, "deletions": 51, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -21,6 +21,11 @@\n //! custom operators are required, you should look toward macros or compiler\n //! plugins to extend Rust's syntax.\n //!\n+//! Note that the `&&` and `||` operators short-circuit, i.e. they only\n+//! evaluate their second operand if it contributes to the result. Since this\n+//! behavior is not enforceable by traits, `&&` and `||` are not supported as\n+//! overloadable operators.\n+//!\n //! Many of the operators take their operands by value. In non-generic\n //! contexts involving built-in types, this is usually not a problem.\n //! However, using these operators in generic code, requires some\n@@ -68,6 +73,73 @@\n //! ```\n //!\n //! See the documentation for each trait for an example implementation.\n+//!\n+//! The [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\n+//! invoked like functions. Note that `Fn` takes `&self`, `FnMut` takes `&mut\n+//! self` and `FnOnce` takes `self`. These correspond to the three kinds of\n+//! methods that can be invoked on an instance: call-by-reference,\n+//! call-by-mutable-reference, and call-by-value. The most common use of these\n+//! traits is to act as bounds to higher-level functions that take functions or\n+//! closures as arguments.\n+//!\n+//! [`Fn`]: trait.Fn.html\n+//! [`FnMut`]: trait.FnMut.html\n+//! [`FnOnce`]: trait.FnOnce.html\n+//!\n+//! Taking a `Fn` as a parameter:\n+//!\n+//! ```rust\n+//! fn call_with_one<F>(func: F) -> usize\n+//!     where F: Fn(usize) -> usize\n+//! {\n+//!     func(1)\n+//! }\n+//!\n+//! let double = |x| x * 2;\n+//! assert_eq!(call_with_one(double), 2);\n+//! ```\n+//!\n+//! Taking a `FnMut` as a parameter:\n+//!\n+//! ```rust\n+//! fn do_twice<F>(mut func: F)\n+//!     where F: FnMut()\n+//! {\n+//!     func();\n+//!     func();\n+//! }\n+//!\n+//! let mut x: usize = 1;\n+//! {\n+//!     let add_two_to_x = || x += 2;\n+//!     do_twice(add_two_to_x);\n+//! }\n+//!\n+//! assert_eq!(x, 5);\n+//! ```\n+//!\n+//! Taking a `FnOnce` as a parameter:\n+//!\n+//! ```rust\n+//! fn consume_with_relish<F>(func: F)\n+//!     where F: FnOnce() -> String\n+//! {\n+//!     // `func` consumes its captured variables, so it cannot be run more\n+//!     // than once\n+//!     println!(\"Consumed: {}\", func());\n+//!\n+//!     println!(\"Delicious!\");\n+//!\n+//!     // Attempting to invoke `func()` again will throw a `use of moved\n+//!     // value` error for `func`\n+//! }\n+//!\n+//! let x = String::from(\"x\");\n+//! let consume_and_return_x = move || x;\n+//! consume_with_relish(consume_and_return_x);\n+//!\n+//! // `consume_and_return_x` can no longer be invoked at this point\n+//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -793,41 +865,56 @@ not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///\n /// # Examples\n ///\n-/// In this example, the `BitAnd` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// In this example, the `&` operator is lifted to a trivial `Scalar` type.\n ///\n /// ```\n /// use std::ops::BitAnd;\n ///\n-/// #[derive(Debug)]\n-/// struct BooleanVector {\n-///     value: Vec<bool>,\n-/// };\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n ///\n-/// impl BitAnd for BooleanVector {\n+/// impl BitAnd for Scalar {\n ///     type Output = Self;\n ///\n+///     // rhs is the \"right-hand side\" of the expression `a & b`\n ///     fn bitand(self, rhs: Self) -> Self {\n-///         BooleanVector {\n-///             value: self.value\n-///                 .iter()\n-///                 .zip(rhs.value.iter())\n-///                 .map(|(x, y)| *x && *y)\n-///                 .collect(),\n-///         }\n+///         Scalar(self.0 & rhs.0)\n ///     }\n /// }\n ///\n-/// impl PartialEq for BooleanVector {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.value == other.value\n+/// fn main() {\n+///     assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n+///     assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n+///     assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitAnd` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitAnd;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitAnd for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitand(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n ///     }\n /// }\n ///\n-/// let bv1 = BooleanVector { value: vec![true, true, false, false] };\n-/// let bv2 = BooleanVector { value: vec![true, false, true, false] };\n-/// let expected = BooleanVector { value: vec![true, false, false, false] };\n-/// assert_eq!(bv1 & bv2, expected);\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, false, false, false]);\n+///     assert_eq!(bv1 & bv2, expected);\n+/// }\n /// ```\n #[lang = \"bitand\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -967,25 +1054,54 @@ bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n-/// calling `shl`, and therefore, `main` prints `Shifting left!`.\n+/// An implementation of `Shl` that lifts the `<<` operation on integers to a\n+/// `Scalar` struct.\n ///\n /// ```\n /// use std::ops::Shl;\n ///\n-/// struct Foo;\n+/// #[derive(PartialEq, Debug)]\n+/// struct Scalar(usize);\n ///\n-/// impl Shl<Foo> for Foo {\n-///     type Output = Foo;\n+/// impl Shl<Scalar> for Scalar {\n+///     type Output = Self;\n ///\n-///     fn shl(self, _rhs: Foo) -> Foo {\n-///         println!(\"Shifting left!\");\n-///         self\n+///     fn shl(self, Scalar(rhs): Self) -> Scalar {\n+///         let Scalar(lhs) = self;\n+///         Scalar(lhs << rhs)\n+///     }\n+/// }\n+/// fn main() {\n+///     assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n+/// }\n+/// ```\n+///\n+/// An implementation of `Shl` that spins a vector leftward by a given amount.\n+///\n+/// ```\n+/// use std::ops::Shl;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SpinVector<T: Clone> {\n+///     vec: Vec<T>,\n+/// }\n+///\n+/// impl<T: Clone> Shl<usize> for SpinVector<T> {\n+///     type Output = Self;\n+///\n+///     fn shl(self, rhs: usize) -> SpinVector<T> {\n+///         // rotate the vector by `rhs` places\n+///         let (a, b) = self.vec.split_at(rhs);\n+///         let mut spun_vector: Vec<T> = vec![];\n+///         spun_vector.extend_from_slice(b);\n+///         spun_vector.extend_from_slice(a);\n+///         SpinVector { vec: spun_vector }\n ///     }\n /// }\n ///\n /// fn main() {\n-///     Foo << Foo;\n+///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n+///                SpinVector { vec: vec![2, 3, 4, 0, 1] });\n /// }\n /// ```\n #[lang = \"shl\"]\n@@ -1039,25 +1155,54 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n-/// calling `shr`, and therefore, `main` prints `Shifting right!`.\n+/// An implementation of `Shr` that lifts the `>>` operation on integers to a\n+/// `Scalar` struct.\n ///\n /// ```\n /// use std::ops::Shr;\n ///\n-/// struct Foo;\n+/// #[derive(PartialEq, Debug)]\n+/// struct Scalar(usize);\n ///\n-/// impl Shr<Foo> for Foo {\n-///     type Output = Foo;\n+/// impl Shr<Scalar> for Scalar {\n+///     type Output = Self;\n ///\n-///     fn shr(self, _rhs: Foo) -> Foo {\n-///         println!(\"Shifting right!\");\n-///         self\n+///     fn shr(self, Scalar(rhs): Self) -> Scalar {\n+///         let Scalar(lhs) = self;\n+///         Scalar(lhs >> rhs)\n+///     }\n+/// }\n+/// fn main() {\n+///     assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n+/// }\n+/// ```\n+///\n+/// An implementation of `Shr` that spins a vector rightward by a given amount.\n+///\n+/// ```\n+/// use std::ops::Shr;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SpinVector<T: Clone> {\n+///     vec: Vec<T>,\n+/// }\n+///\n+/// impl<T: Clone> Shr<usize> for SpinVector<T> {\n+///     type Output = Self;\n+///\n+///     fn shr(self, rhs: usize) -> SpinVector<T> {\n+///         // rotate the vector by `rhs` places\n+///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n+///         let mut spun_vector: Vec<T> = vec![];\n+///         spun_vector.extend_from_slice(b);\n+///         spun_vector.extend_from_slice(a);\n+///         SpinVector { vec: spun_vector }\n ///     }\n /// }\n ///\n /// fn main() {\n-///     Foo >> Foo;\n+///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n+///                SpinVector { vec: vec![3, 4, 0, 1, 2] });\n /// }\n /// ```\n #[lang = \"shr\"]\n@@ -1873,17 +2018,33 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n ///\n /// It cannot serve as an iterator because it doesn't have a starting point.\n ///\n+/// # Examples\n+///\n+/// The `..{integer}` syntax is a `RangeTo`:\n+///\n+/// ```\n+/// assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n /// ```\n-/// fn main() {\n-///     assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n ///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ .. ], [0,1,2,3]);\n-///     assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n-///     assert_eq!(arr[1.. ], [  1,2,3]);\n-///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in ..5 {\n+///     // ...\n /// }\n /// ```\n+///\n+/// When used as a slicing index, `RangeTo` produces a slice of all array\n+/// elements before the index indicated by `end`.\n+///\n+/// ```\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n@@ -2011,16 +2172,31 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n ///\n /// # Examples\n ///\n+/// The `...{integer}` syntax is a `RangeToInclusive`:\n+///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n-/// fn main() {\n-///     assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n+/// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n+/// ```\n ///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n-///     assert_eq!(arr[1...2], [  1,2  ]);\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in ...5 {\n+///     // ...\n /// }\n /// ```\n+///\n+/// When used as a slicing index, `RangeToInclusive` produces a slice of all\n+/// array elements up to and including the index indicated by `end`.\n+///\n+/// ```\n+/// #![feature(inclusive_range_syntax)]\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n+/// assert_eq!(arr[1...2], [  1,2  ]);\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeToInclusive<Idx> {\n@@ -2169,6 +2345,35 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n }\n \n /// A version of the call operator that takes an immutable receiver.\n+///\n+/// # Examples\n+///\n+/// Closures automatically implement this trait, which allows them to be\n+/// invoked. Note, however, that `Fn` takes an immutable reference to any\n+/// captured variables. To take a mutable capture, implement [`FnMut`], and to\n+/// consume the capture, implement [`FnOnce`].\n+///\n+/// [`FnMut`]: trait.FnMut.html\n+/// [`FnOnce`]: trait.FnOnce.html\n+///\n+/// ```\n+/// let square = |x| x * x;\n+/// assert_eq!(square(5), 25);\n+/// ```\n+///\n+/// Closures can also be passed to higher-level functions through a `Fn`\n+/// parameter (or a `FnMut` or `FnOnce` parameter, which are supertraits of\n+/// `Fn`).\n+///\n+/// ```\n+/// fn call_with_one<F>(func: F) -> usize\n+///     where F: Fn(usize) -> usize {\n+///     func(1)\n+/// }\n+///\n+/// let double = |x| x * 2;\n+/// assert_eq!(call_with_one(double), 2);\n+/// ```\n #[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -2180,6 +2385,40 @@ pub trait Fn<Args> : FnMut<Args> {\n }\n \n /// A version of the call operator that takes a mutable receiver.\n+///\n+/// # Examples\n+///\n+/// Closures that mutably capture variables automatically implement this trait,\n+/// which allows them to be invoked.\n+///\n+/// ```\n+/// let mut x = 5;\n+/// {\n+///     let mut square_x = || x *= x;\n+///     square_x();\n+/// }\n+/// assert_eq!(x, 25);\n+/// ```\n+///\n+/// Closures can also be passed to higher-level functions through a `FnMut`\n+/// parameter (or a `FnOnce` parameter, which is a supertrait of `FnMut`).\n+///\n+/// ```\n+/// fn do_twice<F>(mut func: F)\n+///     where F: FnMut()\n+/// {\n+///     func();\n+///     func();\n+/// }\n+///\n+/// let mut x: usize = 1;\n+/// {\n+///     let add_two_to_x = || x += 2;\n+///     do_twice(add_two_to_x);\n+/// }\n+///\n+/// assert_eq!(x, 5);\n+/// ```\n #[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -2191,6 +2430,41 @@ pub trait FnMut<Args> : FnOnce<Args> {\n }\n \n /// A version of the call operator that takes a by-value receiver.\n+///\n+/// # Examples\n+///\n+/// By-value closures automatically implement this trait, which allows them to\n+/// be invoked.\n+///\n+/// ```\n+/// let x = 5;\n+/// let square_x = move || x * x;\n+/// assert_eq!(square_x(), 25);\n+/// ```\n+///\n+/// By-value Closures can also be passed to higher-level functions through a\n+/// `FnOnce` parameter.\n+///\n+/// ```\n+/// fn consume_with_relish<F>(func: F)\n+///     where F: FnOnce() -> String\n+/// {\n+///     // `func` consumes its captured variables, so it cannot be run more\n+///     // than once\n+///     println!(\"Consumed: {}\", func());\n+///\n+///     println!(\"Delicious!\");\n+///\n+///     // Attempting to invoke `func()` again will throw a `use of moved\n+///     // value` error for `func`\n+/// }\n+///\n+/// let x = String::from(\"x\");\n+/// let consume_and_return_x = move || x;\n+/// consume_with_relish(consume_and_return_x);\n+///\n+/// // `consume_and_return_x` can no longer be invoked at this point\n+/// ```\n #[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]"}, {"sha": "5a8a52f7dfc6e15d9b5bc215395f620ae75e1747", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -726,7 +726,7 @@ pub mod reader {\n         fn read_u8(&mut self) -> DecodeResult<u8> {\n             Ok(doc_as_u8(self.next_doc(EsU8)?))\n         }\n-        fn read_uint(&mut self) -> DecodeResult<usize> {\n+        fn read_usize(&mut self) -> DecodeResult<usize> {\n             let v = self._next_int(EsU8, EsU64)?;\n             if v > (::std::usize::MAX as u64) {\n                 Err(IntTooBig(v as usize))\n@@ -747,7 +747,7 @@ pub mod reader {\n         fn read_i8(&mut self) -> DecodeResult<i8> {\n             Ok(doc_as_u8(self.next_doc(EsI8)?) as i8)\n         }\n-        fn read_int(&mut self) -> DecodeResult<isize> {\n+        fn read_isize(&mut self) -> DecodeResult<isize> {\n             let v = self._next_int(EsI8, EsI64)? as i64;\n             if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n@@ -1219,7 +1219,7 @@ pub mod writer {\n             Ok(())\n         }\n \n-        fn emit_uint(&mut self, v: usize) -> EncodeResult {\n+        fn emit_usize(&mut self, v: usize) -> EncodeResult {\n             self.emit_u64(v as u64)\n         }\n         fn emit_u64(&mut self, v: u64) -> EncodeResult {\n@@ -1247,7 +1247,7 @@ pub mod writer {\n             self.wr_tagged_raw_u8(EsU8 as usize, v)\n         }\n \n-        fn emit_int(&mut self, v: isize) -> EncodeResult {\n+        fn emit_isize(&mut self, v: isize) -> EncodeResult {\n             self.emit_i64(v as i64)\n         }\n         fn emit_i64(&mut self, v: i64) -> EncodeResult {"}, {"sha": "6dc7a72b1b1bb0d234a50f128e820934f5c573e9", "filename": "src/librbml/opaque.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrbml%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrbml%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fopaque.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -54,7 +54,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_uint(&mut self, v: usize) -> EncodeResult {\n+    fn emit_usize(&mut self, v: usize) -> EncodeResult {\n         write_uleb128!(self, v)\n     }\n \n@@ -75,7 +75,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_int(&mut self, v: isize) -> EncodeResult {\n+    fn emit_isize(&mut self, v: isize) -> EncodeResult {\n         write_sleb128!(self, v)\n     }\n \n@@ -120,7 +120,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        self.emit_uint(v.len())?;\n+        self.emit_usize(v.len())?;\n         let _ = self.cursor.write_all(v.as_bytes());\n         Ok(())\n     }\n@@ -139,7 +139,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n                             -> EncodeResult\n         where F: FnOnce(&mut Self) -> EncodeResult\n     {\n-        self.emit_uint(v_id)?;\n+        self.emit_usize(v_id)?;\n         f(self)\n     }\n \n@@ -221,7 +221,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n         where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n-        self.emit_uint(len)?;\n+        self.emit_usize(len)?;\n         f(self)\n     }\n \n@@ -234,7 +234,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n         where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n-        self.emit_uint(len)?;\n+        self.emit_usize(len)?;\n         f(self)\n     }\n \n@@ -329,7 +329,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         Ok(value)\n     }\n \n-    fn read_uint(&mut self) -> Result<usize, Self::Error> {\n+    fn read_usize(&mut self) -> Result<usize, Self::Error> {\n         read_uleb128!(self, usize)\n     }\n \n@@ -351,7 +351,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         unsafe { Ok(::std::mem::transmute(as_u8)) }\n     }\n \n-    fn read_int(&mut self) -> Result<isize, Self::Error> {\n+    fn read_isize(&mut self) -> Result<isize, Self::Error> {\n         read_sleb128!(self, isize)\n     }\n \n@@ -376,7 +376,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     }\n \n     fn read_str(&mut self) -> Result<String, Self::Error> {\n-        let len = self.read_uint()?;\n+        let len = self.read_usize()?;\n         let s = ::std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();\n         self.position += len;\n         Ok(s.to_string())\n@@ -391,7 +391,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n-        let disr = self.read_uint()?;\n+        let disr = self.read_usize()?;\n         f(self, disr)\n     }\n \n@@ -404,7 +404,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n-        let disr = self.read_uint()?;\n+        let disr = self.read_usize()?;\n         f(self, disr)\n     }\n \n@@ -483,7 +483,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n-        let len = self.read_uint()?;\n+        let len = self.read_usize()?;\n         f(self, len)\n     }\n \n@@ -496,7 +496,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n-        let len = self.read_uint()?;\n+        let len = self.read_usize()?;\n         f(self, len)\n     }\n "}, {"sha": "e71a780dd89bca7e6e2649b16befbcc8cb61ca29", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -324,7 +324,10 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             let &(ref first_arm_pats, _) = &arms[0];\n                             let first_pat = &first_arm_pats[0];\n                             let span = first_pat.span;\n-                            span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n+                            struct_span_err!(cx.tcx.sess, span, E0165,\n+                                             \"irrefutable while-let pattern\")\n+                                .span_label(span, &format!(\"irrefutable pattern\"))\n+                                .emit();\n                         },\n \n                         hir::MatchSource::ForLoopDesugar => {"}, {"sha": "44d7861066da3a84108e2b00841bd60d37507c1d", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -342,9 +342,11 @@ impl<'a> Context<'a> {\n                              \"found crate `{}` compiled by an incompatible version of rustc{}\",\n                              self.ident, add)\n         } else {\n-            struct_span_err!(self.sess, self.span, E0463,\n-                             \"can't find crate for `{}`{}\",\n-                             self.ident, add)\n+            let mut err = struct_span_err!(self.sess, self.span, E0463,\n+                                           \"can't find crate for `{}`{}\",\n+                                           self.ident, add);\n+            err.span_label(self.span, &format!(\"can't find crate\"));\n+            err\n         };\n \n         if !self.rejected_via_triple.is_empty() {"}, {"sha": "41b7c51e3009026dae4162849c2a5aa042b0b83e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -384,8 +384,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n         if def.adt_kind() == ty::AdtKind::Struct &&\n            !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n-            span_err!(self.tcx.sess, span, E0451, \"field `{}` of struct `{}` is private\",\n-                      field.name, self.tcx.item_path_str(def.did));\n+            struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of struct `{}` is private\",\n+                      field.name, self.tcx.item_path_str(def.did))\n+                .span_label(span, &format!(\"field `{}` is private\", field.name))\n+                .emit();\n         }\n     }\n \n@@ -425,14 +427,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 let method = self.tcx.tables.borrow().method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n-            hir::ExprStruct(..) => {\n+            hir::ExprStruct(_, ref fields, _) => {\n                 let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n                 // (i.e. `all_fields - fields`), just check them all.\n-                for field in &variant.fields {\n-                    self.check_field(expr.span, adt, field);\n+                for field in variant.fields.iter() {\n+                    let span = if let Some(f) = fields.iter().find(|f| f.name.node == field.name) {\n+                        f.span\n+                    } else {\n+                        expr.span\n+                    };\n+                    self.check_field(span, adt, field);\n                 }\n             }\n             hir::ExprPath(..) => {\n@@ -491,7 +498,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(pattern.id));\n                 for field in fields {\n-                    self.check_field(pattern.span, adt, variant.field_named(field.node.name));\n+                    self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n             PatKind::TupleStruct(_, ref fields, ddpos) => {"}, {"sha": "3dd6485f15fa790d40d85c41bbab4c4e1023b58e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -3355,7 +3355,11 @@ impl<'a> Resolver<'a> {\n                 e.span_label(span, &\"already imported\");\n                 e\n             },\n-            (true, _) | (_, true) => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n+            (true, _) | (_, true) => {\n+                let mut e = struct_span_err!(self.session, span, E0260, \"{}\", msg);\n+                e.span_label(span, &format!(\"`{}` already imported\", name));\n+                e\n+            },\n             _ => match (old_binding.is_import(), binding.is_import()) {\n                 (false, false) => {\n                     let mut e = struct_span_err!(self.session, span, E0428, \"{}\", msg);"}, {"sha": "225468cb9f40c40d7cd98db80ed56efcc4c2b50e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -574,7 +574,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n                                   pat.id, pat.span, msg);\n             } else {\n-                span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n+                struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n+                    .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n                 on_error();\n             }\n         };"}, {"sha": "ddb4d7c7012a0751a4e8dfe03d17d62f520aa6cd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -4404,14 +4404,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // use inference variables instead of the provided types.\n             *segment = None;\n         } else if !(can_omit && types.len() == 0) && types.len() < required_len {\n-            let qualifier =\n-                if type_defs.len() != required_len { \"at least \" } else { \"\" };\n-            span_err!(self.tcx.sess, span, E0089,\n-                      \"too few type parameters provided: \\\n-                       expected {}{}, found {}\",\n-                      qualifier,\n-                      count(required_len),\n-                      count(types.len()));\n+            let adjust = |len| if len > 1 { \"parameters\" } else { \"parameter\" };\n+            let required_param_str = adjust(required_len);\n+            let actual_param_str = adjust(types.len());\n+            struct_span_err!(self.tcx.sess, span, E0089,\n+                             \"too few type parameters provided: \\\n+                              expected {} {}, found {} {}\",\n+                             count(required_len),\n+                             required_param_str,\n+                             count(types.len()),\n+                             actual_param_str)\n+                .span_label(span, &format!(\"expected {} type {}\", required_len, required_param_str))\n+                .emit();\n         }\n \n         if !bindings.is_empty() {"}, {"sha": "a236c8baa9f9c416eb0694e2c1fea6c3aad906ba", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -631,7 +631,9 @@ fn error_392<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, span: Span, param_name: ast::N\n }\n \n fn error_194(tcx: TyCtxt, span: Span, name: ast::Name) {\n-    span_err!(tcx.sess, span, E0194,\n+    struct_span_err!(tcx.sess, span, E0194,\n               \"type parameter `{}` shadows another type parameter of the same name\",\n-              name);\n+              name)\n+        .span_label(span, &format!(\"`{}` shadows another type parameter\", name))\n+        .emit();\n }"}, {"sha": "f743ef21875611434fb9de7de52911f2f8bf2d49", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -348,9 +348,11 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         .emit();\n                 }\n                 Err(CopyImplementationError::HasDestructor) => {\n-                    span_err!(tcx.sess, span, E0184,\n+                    struct_span_err!(tcx.sess, span, E0184,\n                               \"the trait `Copy` may not be implemented for this type; \\\n-                               the type has a destructor\");\n+                               the type has a destructor\")\n+                        .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n+                        .emit();\n                 }\n             }\n         });"}, {"sha": "7b5092e8848e4072a40dd88f9d6712006a48706b", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -136,15 +136,15 @@ impl<\n         for item in self {\n             bits |= item.to_usize();\n         }\n-        s.emit_uint(bits)\n+        s.emit_usize(bits)\n     }\n }\n \n impl<\n     T: Decodable + CLike\n > Decodable for EnumSet<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> {\n-        let bits = d.read_uint()?;\n+        let bits = d.read_usize()?;\n         let mut set = EnumSet::new();\n         for bit in 0..(mem::size_of::<usize>()*8) {\n             if bits & (1 << bit) != 0 {"}, {"sha": "34df594e847568b7fe5e70b3d81f1eecc2c38e85", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -495,13 +495,13 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_uint(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_usize(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_isize(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -743,13 +743,13 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_uint(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_usize(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_isize(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -2137,12 +2137,12 @@ impl ::Decoder for Decoder {\n         expect!(self.pop(), Null)\n     }\n \n-    read_primitive! { read_uint, usize }\n+    read_primitive! { read_usize, usize }\n     read_primitive! { read_u8, u8 }\n     read_primitive! { read_u16, u16 }\n     read_primitive! { read_u32, u32 }\n     read_primitive! { read_u64, u64 }\n-    read_primitive! { read_int, isize }\n+    read_primitive! { read_isize, isize }\n     read_primitive! { read_i8, i8 }\n     read_primitive! { read_i16, i16 }\n     read_primitive! { read_i32, i32 }"}, {"sha": "b75ec5dad8ddd7088a9539288b551f886ee35c58", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -24,12 +24,12 @@ pub trait Encoder {\n \n     // Primitive types:\n     fn emit_nil(&mut self) -> Result<(), Self::Error>;\n-    fn emit_uint(&mut self, v: usize) -> Result<(), Self::Error>;\n+    fn emit_usize(&mut self, v: usize) -> Result<(), Self::Error>;\n     fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n     fn emit_u32(&mut self, v: u32) -> Result<(), Self::Error>;\n     fn emit_u16(&mut self, v: u16) -> Result<(), Self::Error>;\n     fn emit_u8(&mut self, v: u8) -> Result<(), Self::Error>;\n-    fn emit_int(&mut self, v: isize) -> Result<(), Self::Error>;\n+    fn emit_isize(&mut self, v: isize) -> Result<(), Self::Error>;\n     fn emit_i64(&mut self, v: i64) -> Result<(), Self::Error>;\n     fn emit_i32(&mut self, v: i32) -> Result<(), Self::Error>;\n     fn emit_i16(&mut self, v: i16) -> Result<(), Self::Error>;\n@@ -108,12 +108,12 @@ pub trait Decoder {\n \n     // Primitive types:\n     fn read_nil(&mut self) -> Result<(), Self::Error>;\n-    fn read_uint(&mut self) -> Result<usize, Self::Error>;\n+    fn read_usize(&mut self) -> Result<usize, Self::Error>;\n     fn read_u64(&mut self) -> Result<u64, Self::Error>;\n     fn read_u32(&mut self) -> Result<u32, Self::Error>;\n     fn read_u16(&mut self) -> Result<u16, Self::Error>;\n     fn read_u8(&mut self) -> Result<u8, Self::Error>;\n-    fn read_int(&mut self) -> Result<isize, Self::Error>;\n+    fn read_isize(&mut self) -> Result<isize, Self::Error>;\n     fn read_i64(&mut self) -> Result<i64, Self::Error>;\n     fn read_i32(&mut self) -> Result<i32, Self::Error>;\n     fn read_i16(&mut self) -> Result<i16, Self::Error>;\n@@ -200,13 +200,13 @@ pub trait Decodable: Sized {\n \n impl Encodable for usize {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_uint(*self)\n+        s.emit_usize(*self)\n     }\n }\n \n impl Decodable for usize {\n     fn decode<D: Decoder>(d: &mut D) -> Result<usize, D::Error> {\n-        d.read_uint()\n+        d.read_usize()\n     }\n }\n \n@@ -260,13 +260,13 @@ impl Decodable for u64 {\n \n impl Encodable for isize {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_int(*self)\n+        s.emit_isize(*self)\n     }\n }\n \n impl Decodable for isize {\n     fn decode<D: Decoder>(d: &mut D) -> Result<isize, D::Error> {\n-        d.read_int()\n+        d.read_isize()\n     }\n }\n "}, {"sha": "e3f3f9dd6de1e8ce5513a22de6de15a417999211", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -320,6 +320,24 @@ pub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n }\n \n /// Gets a handle to the thread that invokes it.\n+///\n+/// #Examples\n+///\n+/// Getting a handle to the current thread with `thread::current()`:\n+///\n+/// ```\n+/// use std::thread;\n+///\n+/// let handler = thread::Builder::new()\n+///     .name(\"named thread\".into())\n+///     .spawn(|| {\n+///         let handle = thread::current();\n+///         assert_eq!(handle.name(), Some(\"named thread\"));\n+///     })\n+///     .unwrap();\n+///\n+/// handler.join().unwrap();\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn current() -> Thread {\n     thread_info::current_thread().expect(\"use of std::thread::current() is not \\"}, {"sha": "9ce36523709e504f5581576be17c2f74cdc6f3df", "filename": "src/test/compile-fail/E0089.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0089.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0089.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0089.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -11,5 +11,7 @@\n fn foo<T, U>() {}\n \n fn main() {\n-    foo::<f64>(); //~ ERROR E0089\n+    foo::<f64>();\n+//~^ ERROR E0089\n+//~| NOTE expected 2 type parameters\n }"}, {"sha": "1665a80bead770dc7293ff67486a1e22953b5b78", "filename": "src/test/compile-fail/E0164.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0164.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0164.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0164.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -13,6 +13,7 @@ enum Foo { B { i: u32 } }\n fn bar(foo: Foo) -> u32 {\n     match foo {\n         Foo::B(i) => i, //~ ERROR E0164\n+                        //~| NOTE not a tuple variant or struct\n     }\n }\n "}, {"sha": "142635fc6ee4543adc577f8e4aacd2d410991dcc", "filename": "src/test/compile-fail/E0165.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0165.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0165.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0165.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -13,6 +13,7 @@ struct Irrefutable(i32);\n fn main() {\n     let irr = Irrefutable(0);\n     while let Irrefutable(x) = irr { //~ ERROR E0165\n+                                     //~| irrefutable pattern\n         // ...\n     }\n }"}, {"sha": "9ec2eeba5cc5f5a0ff49c0383d0dc1de0bd9466e", "filename": "src/test/compile-fail/E0184.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0184.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0184.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0184.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n #[derive(Copy)] //~ ERROR E0184\n+                //~| NOTE Copy not allowed on types with destructors\n+                //~| NOTE in this expansion of #[derive(Copy)]\n struct Foo;\n \n impl Drop for Foo {"}, {"sha": "fa94c88328a86ed08a2dafe49d101c96e8f911eb", "filename": "src/test/compile-fail/E0194.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0194.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0194.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0194.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -10,7 +10,9 @@\n \n trait Foo<T> {\n     fn do_something(&self) -> T;\n-    fn do_something_else<T: Clone>(&self, bar: T); //~ ERROR E0194\n+    fn do_something_else<T: Clone>(&self, bar: T);\n+    //~^ ERROR E0194\n+    //~| NOTE `T` shadows another type parameter\n }\n \n fn main() {"}, {"sha": "63647cb41035afe096744489482b66202b8f87d2", "filename": "src/test/compile-fail/E0260.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0260.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -9,8 +9,11 @@\n // except according to those terms.\n \n extern crate collections;\n+//~^ NOTE previous import of `collections` here\n \n-mod collections { //~ ERROR E0260\n+mod collections {\n+//~^ ERROR `collections` has already been imported in this module [E0260]\n+//~| NOTE `collections` already imported\n     pub trait MyTrait {\n         fn do_something();\n     }"}, {"sha": "f7b106d160dae78d1c0fdc87997a8314d639fbbf", "filename": "src/test/compile-fail/E0451.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0451.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0451.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0451.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -13,8 +13,24 @@ mod Bar {\n         pub a: isize,\n         b: isize,\n     }\n+\n+    pub struct FooTuple (\n+        pub isize,\n+        isize,\n+    );\n+}\n+\n+fn pat_match(foo: Bar::Foo) {\n+    let Bar::Foo{a:a, b:b} = foo; //~ ERROR E0451\n+                                  //~^ NOTE field `b` is private\n+}\n+\n+fn pat_match_tuple(foo: Bar::FooTuple) {\n+    let Bar::FooTuple(a,b) = foo; //~ ERROR E0451\n+                                  //~^ NOTE field `1` is private\n }\n \n fn main() {\n     let f = Bar::Foo{ a: 0, b: 0 }; //~ ERROR E0451\n+                                    //~^ NOTE field `b` is private\n }"}, {"sha": "3ce5b83e89fd45a67b07fa0413c9038c3d247172", "filename": "src/test/compile-fail/E0463.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0463.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Fcompile-fail%2FE0463.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0463.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n #![feature(plugin)]\n-#![plugin(cookie_monster)] //~ ERROR E0463\n+#![plugin(cookie_monster)]\n+//~^ ERROR E0463\n+//~| NOTE can't find crate\n extern crate cake_is_a_lie;\n \n fn main() {"}, {"sha": "35d0c305ed8348449d0518b1fef033b1d6b6d52f", "filename": "src/test/run-pass/issue-35423.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Frun-pass%2Fissue-35423.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4473130f4e0a20278225251ea6a0400258b03180/src%2Ftest%2Frun-pass%2Fissue-35423.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-35423.rs?ref=4473130f4e0a20278225251ea6a0400258b03180", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main () {\n+    let x = 4;\n+    match x {\n+        ref r if *r < 0 => println!(\"got negative num {} < 0\", r),\n+        e @ 1 ... 100 => println!(\"got number within range [1,100] {}\", e),\n+        _ => println!(\"no\"),\n+    }\n+}"}]}