{"sha": "baf149437452f6aec9f873bb312723bf62cb3a74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZjE0OTQzNzQ1MmY2YWVjOWY4NzNiYjMxMjcyM2JmNjJjYjNhNzQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-12T17:55:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-12T17:55:29Z"}, "message": "Merge #9807\n\n9807: Implicit `Sized` bounds r=iDawer a=iDawer\n\nThis should close #8984 \r\n\r\n`hir_ty`:\r\n- Type parameters, associated types and `impl Trait` are `Sized` by deafault except `Self` in a trait.\r\n- Implicit `Sized` bound is added to end of predicate list. It does not check if such bound is present already. Also it does not track the bound is implicit.\r\n- Allowed ambiguous unsize coercion if Chalk returns definite guidance.\r\n- Allowed ambiguous autoderef if Chalk returns definite guidance.\r\n\r\n`hir_def`:\r\n- `ItemTree` pretty printing shows `?Sized` bounds.\r\n\r\n`HirDisplay`:\r\n- `impl Trait` with weird bounds rendered correctly.\r\n- `Sized`/`?Sized` bounds are not shown if they are default.\r\n\r\n### Perf\r\n`./target/rust-analyzer-baseline_8a843113 -q analysis-stats --memory-usage .`\r\n```\r\nDatabase loaded:     1.63s, 287minstr, 91mb\r\n  crates: 38, mods: 741, decls: 15914, fns: 11835\r\nItem Collection:     26.80s, 73ginstr, 338mb\r\n  exprs: 318994, ??ty: 398 (0%), ?ty: 435 (0%), !ty: 174\r\nInference:           50.28s, 116ginstr, 516mb\r\nTotal:               77.08s, 189ginstr, 855mb\r\n```\r\n\r\n`./target/rust-analyzer-sized-fixed_ambig_coercion-de074fe6 -q analysis-stats --memory-usage .`\r\n```\r\nDatabase loaded:     1.63s, 287minstr, 91mb\r\n  crates: 38, mods: 741, decls: 15914, fns: 11835\r\nItem Collection:     26.95s, 73ginstr, 338mb\r\n  exprs: 318994, ??ty: 398 (0%), ?ty: 435 (0%), !ty: 166\r\nInference:           96.39s, 234ginstr, 543mb\r\nTotal:               123.33s, 307ginstr, 881mb\r\n```\r\n\n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>", "tree": {"sha": "aa9f703c7982944aed7d7393bb0db0f653686b2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa9f703c7982944aed7d7393bb0db0f653686b2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baf149437452f6aec9f873bb312723bf62cb3a74", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhFWCRCRBK7hj4Ov3rIwAASfIIAI/P7xB8hRLqANm+yyTGZH3Z\nKYoD7qV41RmdETMTJP+MP1Yw/fMoRgGx3iIHiPP6ISJ3AtNw/D/aqodnyj3i3Utb\noKUM+IRqXNnaeH4ev1+4dzEZ2x50VNlr4te3olXiLU2zuYvquEjaVKVjW/1jBk2m\nN58GnXVzoNkPavx/3zzMz0OMWOtQeMLuB/+ITeG6GnV+VATWd5ExWh+6iMFtaF+T\n78gsDRqZimmPfP2C/EYeT5MaVKQVKveT+rU5EKCgXrQbnWRbD7cIPiUzjhzbytfE\nGiUpXQXGJhA/vHXBp/ko3PAeWcxRwRrWXh6qWWxrZNgpAXL6dTQ/WLfiirmGAWs=\n=IxyD\n-----END PGP SIGNATURE-----\n", "payload": "tree aa9f703c7982944aed7d7393bb0db0f653686b2d\nparent c619cb12d7f7c1cf65d44007b144b4c9bcafc7c5\nparent 6c366ade0087db292b9a1eee71b6a20653a4d0e9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628790929 +0000\ncommitter GitHub <noreply@github.com> 1628790929 +0000\n\nMerge #9807\n\n9807: Implicit `Sized` bounds r=iDawer a=iDawer\n\nThis should close #8984 \r\n\r\n`hir_ty`:\r\n- Type parameters, associated types and `impl Trait` are `Sized` by deafault except `Self` in a trait.\r\n- Implicit `Sized` bound is added to end of predicate list. It does not check if such bound is present already. Also it does not track the bound is implicit.\r\n- Allowed ambiguous unsize coercion if Chalk returns definite guidance.\r\n- Allowed ambiguous autoderef if Chalk returns definite guidance.\r\n\r\n`hir_def`:\r\n- `ItemTree` pretty printing shows `?Sized` bounds.\r\n\r\n`HirDisplay`:\r\n- `impl Trait` with weird bounds rendered correctly.\r\n- `Sized`/`?Sized` bounds are not shown if they are default.\r\n\r\n### Perf\r\n`./target/rust-analyzer-baseline_8a843113 -q analysis-stats --memory-usage .`\r\n```\r\nDatabase loaded:     1.63s, 287minstr, 91mb\r\n  crates: 38, mods: 741, decls: 15914, fns: 11835\r\nItem Collection:     26.80s, 73ginstr, 338mb\r\n  exprs: 318994, ??ty: 398 (0%), ?ty: 435 (0%), !ty: 174\r\nInference:           50.28s, 116ginstr, 516mb\r\nTotal:               77.08s, 189ginstr, 855mb\r\n```\r\n\r\n`./target/rust-analyzer-sized-fixed_ambig_coercion-de074fe6 -q analysis-stats --memory-usage .`\r\n```\r\nDatabase loaded:     1.63s, 287minstr, 91mb\r\n  crates: 38, mods: 741, decls: 15914, fns: 11835\r\nItem Collection:     26.95s, 73ginstr, 338mb\r\n  exprs: 318994, ??ty: 398 (0%), ?ty: 435 (0%), !ty: 166\r\nInference:           96.39s, 234ginstr, 543mb\r\nTotal:               123.33s, 307ginstr, 881mb\r\n```\r\n\n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baf149437452f6aec9f873bb312723bf62cb3a74", "html_url": "https://github.com/rust-lang/rust/commit/baf149437452f6aec9f873bb312723bf62cb3a74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baf149437452f6aec9f873bb312723bf62cb3a74/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c619cb12d7f7c1cf65d44007b144b4c9bcafc7c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c619cb12d7f7c1cf65d44007b144b4c9bcafc7c5", "html_url": "https://github.com/rust-lang/rust/commit/c619cb12d7f7c1cf65d44007b144b4c9bcafc7c5"}, {"sha": "6c366ade0087db292b9a1eee71b6a20653a4d0e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c366ade0087db292b9a1eee71b6a20653a4d0e9", "html_url": "https://github.com/rust-lang/rust/commit/6c366ade0087db292b9a1eee71b6a20653a4d0e9"}], "stats": {"total": 724, "additions": 620, "deletions": 104}, "files": [{"sha": "dff4372738b7f3025e329ccaeed76e23b774803d", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -7,7 +7,7 @@ use hir_def::{\n };\n use hir_ty::display::{\n     write_bounds_like_dyn_trait_with_prefix, write_visibility, HirDisplay, HirDisplayError,\n-    HirFormatter,\n+    HirFormatter, SizedByDefault,\n };\n use hir_ty::Interner;\n use syntax::ast::{self, NameOwner};\n@@ -93,7 +93,7 @@ impl HirDisplay for Function {\n         } else {\n             match &*data.ret_type {\n                 TypeRef::ImplTrait(bounds) => match bounds[0].as_ref() {\n-                    TypeBound::Path(path) => {\n+                    TypeBound::Path(path, _) => {\n                         path.segments().iter().last().unwrap().args_and_bindings.unwrap().bindings\n                             [0]\n                         .type_ref\n@@ -239,7 +239,8 @@ impl HirDisplay for TypeParam {\n         let predicates =\n             bounds.iter().cloned().map(|b| b.substitute(&Interner, &substs)).collect::<Vec<_>>();\n         if !(predicates.is_empty() || f.omit_verbose_types()) {\n-            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, f)?;\n+            let default_sized = SizedByDefault::Sized { anchor: self.module(f.db).krate().id };\n+            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, default_sized, f)?;\n         }\n         Ok(())\n     }"}, {"sha": "40104833db3089b971db8c79a3596b40bdd2cd57", "filename": "crates/hir_def/src/generics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fgenerics.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -338,10 +338,6 @@ impl GenericParams {\n         hrtb_lifetimes: Option<&Box<[Name]>>,\n         target: Either<TypeRef, LifetimeRef>,\n     ) {\n-        if bound.question_mark_token().is_some() {\n-            // FIXME: remove this bound\n-            return;\n-        }\n         let bound = TypeBound::from_ast(lower_ctx, bound);\n         let predicate = match (target, bound) {\n             (Either::Left(type_ref), bound) => match hrtb_lifetimes {"}, {"sha": "2f9e33b6adc8e3b4f8c9e950cb55ff7f33a206e2", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -10,7 +10,7 @@ use syntax::{\n \n use crate::{\n     generics::{GenericParams, TypeParamData, TypeParamProvenance},\n-    type_ref::{LifetimeRef, TraitRef},\n+    type_ref::{LifetimeRef, TraitBoundModifier, TraitRef},\n };\n \n use super::*;\n@@ -369,7 +369,7 @@ impl<'a> Ctx<'a> {\n         let (ret_type, async_ret_type) = if func.async_token().is_some() {\n             let async_ret_type = ret_type.clone();\n             let future_impl = desugar_future_path(ret_type);\n-            let ty_bound = Interned::new(TypeBound::Path(future_impl));\n+            let ty_bound = Interned::new(TypeBound::Path(future_impl, TraitBoundModifier::None));\n             (TypeRef::ImplTrait(vec![ty_bound]), Some(async_ret_type))\n         } else {\n             (ret_type, None)"}, {"sha": "24cc2408de2ffa7f3b5a4404371a9c7c877b3356", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -8,6 +8,7 @@ use crate::{\n     attr::RawAttrs,\n     generics::{WherePredicate, WherePredicateTypeTarget},\n     path::GenericArg,\n+    type_ref::TraitBoundModifier,\n     visibility::RawVisibility,\n };\n \n@@ -543,7 +544,13 @@ impl<'a> Printer<'a> {\n             }\n \n             match bound.as_ref() {\n-                TypeBound::Path(path) => self.print_path(path),\n+                TypeBound::Path(path, modifier) => {\n+                    match modifier {\n+                        TraitBoundModifier::None => (),\n+                        TraitBoundModifier::Maybe => w!(self, \"?\"),\n+                    }\n+                    self.print_path(path)\n+                }\n                 TypeBound::ForLifetime(lifetimes, path) => {\n                     w!(self, \"for<{}> \", lifetimes.iter().format(\", \"));\n                     self.print_path(path);"}, {"sha": "a153e17b17a83952d5fb22e11e451bcaa34aad6e", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -304,7 +304,7 @@ struct S<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> {\n     field: &'a &'b T,\n }\n \n-struct Tuple<T: Copy>(T);\n+struct Tuple<T: Copy, U: ?Sized>(T, U);\n \n impl<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> S<'a, 'b, T, K> {\n     fn f<G: 'a>(arg: impl Copy) -> impl Copy {}\n@@ -325,11 +325,13 @@ trait Tr<'a, T: 'a>: Super where Self: for<'a> Tr<'a, T> {}\n                 pub(self) field: &'a &'b T,\n             }\n \n-            pub(self) struct Tuple<T>(\n+            pub(self) struct Tuple<T, U>(\n                 pub(self) 0: T,\n+                pub(self) 1: U,\n             )\n             where\n-                T: Copy;\n+                T: Copy,\n+                U: ?Sized;\n \n             impl<'a, 'b, T, const K: u8> S<'a, 'b, T, K>\n             where"}, {"sha": "9f33fd26e845ce4d79412d7aa3d7588103b01a24", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -118,12 +118,20 @@ impl LifetimeRef {\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum TypeBound {\n-    Path(Path),\n+    Path(Path, TraitBoundModifier),\n     ForLifetime(Box<[Name]>, Path),\n     Lifetime(LifetimeRef),\n     Error,\n }\n \n+/// A modifier on a bound, currently this is only used for `?Sized`, where the\n+/// modifier is `Maybe`.\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TraitBoundModifier {\n+    None,\n+    Maybe,\n+}\n+\n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n     pub fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Self {\n@@ -233,7 +241,7 @@ impl TypeRef {\n                 TypeRef::ImplTrait(bounds) | TypeRef::DynTrait(bounds) => {\n                     for bound in bounds {\n                         match bound.as_ref() {\n-                            TypeBound::Path(path) | TypeBound::ForLifetime(_, path) => {\n+                            TypeBound::Path(path, _) | TypeBound::ForLifetime(_, path) => {\n                                 go_path(path, f)\n                             }\n                             TypeBound::Lifetime(_) | TypeBound::Error => (),\n@@ -265,7 +273,7 @@ impl TypeRef {\n                         }\n                         for bound in &binding.bounds {\n                             match bound.as_ref() {\n-                                TypeBound::Path(path) | TypeBound::ForLifetime(_, path) => {\n+                                TypeBound::Path(path, _) | TypeBound::ForLifetime(_, path) => {\n                                     go_path(path, f)\n                                 }\n                                 TypeBound::Lifetime(_) | TypeBound::Error => (),\n@@ -295,7 +303,13 @@ impl TypeBound {\n \n         match node.kind() {\n             ast::TypeBoundKind::PathType(path_type) => {\n-                lower_path_type(path_type).map(TypeBound::Path).unwrap_or(TypeBound::Error)\n+                let m = match node.question_mark_token() {\n+                    Some(_) => TraitBoundModifier::Maybe,\n+                    None => TraitBoundModifier::None,\n+                };\n+                lower_path_type(path_type)\n+                    .map(|p| TypeBound::Path(p, m))\n+                    .unwrap_or(TypeBound::Error)\n             }\n             ast::TypeBoundKind::ForType(for_type) => {\n                 let lt_refs = match for_type.generic_param_list() {\n@@ -320,9 +334,10 @@ impl TypeBound {\n         }\n     }\n \n-    pub fn as_path(&self) -> Option<&Path> {\n+    pub fn as_path(&self) -> Option<(&Path, &TraitBoundModifier)> {\n         match self {\n-            TypeBound::Path(p) | TypeBound::ForLifetime(_, p) => Some(p),\n+            TypeBound::Path(p, m) => Some((p, m)),\n+            TypeBound::ForLifetime(_, p) => Some((p, &TraitBoundModifier::None)),\n             TypeBound::Lifetime(_) | TypeBound::Error => None,\n         }\n     }"}, {"sha": "0be337fc2df88c81fc8dde89343cecae73a641de", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -14,8 +14,8 @@ use log::{info, warn};\n \n use crate::{\n     db::HirDatabase, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds,\n-    DebruijnIndex, Environment, InEnvironment, Interner, ProjectionTyExt, Solution, Substitution,\n-    Ty, TyBuilder, TyKind,\n+    ConstrainedSubst, DebruijnIndex, Environment, Guidance, InEnvironment, Interner,\n+    ProjectionTyExt, Solution, Substitution, Ty, TyBuilder, TyKind,\n };\n \n const AUTODEREF_RECURSION_LIMIT: Limit = Limit::new(10);\n@@ -187,7 +187,8 @@ fn deref_by_trait(\n     let solution = db.trait_solve(krate, canonical)?;\n \n     match &solution {\n-        Solution::Unique(vars) => {\n+        Solution::Unique(Canonical { value: ConstrainedSubst { subst, .. }, binders })\n+        | Solution::Ambig(Guidance::Definite(Canonical { value: subst, binders })) => {\n             // FIXME: vars may contain solutions for any inference variables\n             // that happened to be inside ty. To correctly handle these, we\n             // would have to pass the solution up to the inference context, but\n@@ -203,8 +204,8 @@ fn deref_by_trait(\n             // assumptions will be broken. We would need to properly introduce\n             // new variables in that case\n \n-            for i in 1..vars.binders.len(&Interner) {\n-                if vars.value.subst.at(&Interner, i - 1).assert_ty_ref(&Interner).kind(&Interner)\n+            for i in 1..binders.len(&Interner) {\n+                if subst.at(&Interner, i - 1).assert_ty_ref(&Interner).kind(&Interner)\n                     != &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n                     warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.goal, solution);\n@@ -214,13 +215,11 @@ fn deref_by_trait(\n             // FIXME: we remove lifetime variables here since they can confuse\n             // the method resolution code later\n             Some(fixup_lifetime_variables(Canonical {\n-                value: vars\n-                    .value\n-                    .subst\n-                    .at(&Interner, vars.value.subst.len(&Interner) - 1)\n+                value: subst\n+                    .at(&Interner, subst.len(&Interner) - 1)\n                     .assert_ty_ref(&Interner)\n                     .clone(),\n-                binders: vars.binders.clone(),\n+                binders: binders.clone(),\n             }))\n         }\n         Solution::Ambig(_) => {"}, {"sha": "333d934ed37c1671254a9f549125fb4eac3e3010", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -412,13 +412,28 @@ pub(crate) fn associated_ty_data_query(\n         .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n     let self_ty =\n         TyKind::BoundVar(BoundVar::new(crate::DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n-    let bounds = type_alias_data\n+    let mut bounds: Vec<_> = type_alias_data\n         .bounds\n         .iter()\n         .flat_map(|bound| ctx.lower_type_bound(bound, self_ty.clone(), false))\n         .filter_map(|pred| generic_predicate_to_inline_bound(db, &pred, &self_ty))\n         .collect();\n \n+    if !ctx.unsized_types.borrow().contains(&self_ty) {\n+        let sized_trait = resolver\n+            .krate()\n+            .and_then(|krate| db.lang_item(krate, \"sized\".into()))\n+            .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n+        let sized_bound = sized_trait.into_iter().map(|sized_trait| {\n+            let trait_bound =\n+                rust_ir::TraitBound { trait_id: sized_trait, args_no_self: Default::default() };\n+            let inline_bound = rust_ir::InlineBound::TraitBound(trait_bound);\n+            chalk_ir::Binders::empty(&Interner, inline_bound)\n+        });\n+        bounds.extend(sized_bound);\n+        bounds.shrink_to_fit();\n+    }\n+\n     // FIXME: Re-enable where clauses on associated types when an upstream chalk bug is fixed.\n     //        (rust-analyzer#9052)\n     // let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);"}, {"sha": "91c705afb78d70333cf69cc5fde4440fd034d554", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 120, "deletions": 25, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -4,6 +4,7 @@\n \n use std::fmt::{self, Debug};\n \n+use base_db::CrateId;\n use chalk_ir::BoundVar;\n use hir_def::{\n     body,\n@@ -13,9 +14,9 @@ use hir_def::{\n     intern::{Internable, Interned},\n     item_scope::ItemInNs,\n     path::{Path, PathKind},\n-    type_ref::{TypeBound, TypeRef},\n+    type_ref::{TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n-    AssocContainerId, Lookup, ModuleId, TraitId,\n+    AssocContainerId, HasModule, Lookup, ModuleId, TraitId,\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use itertools::Itertools;\n@@ -376,10 +377,20 @@ impl HirDisplay for Ty {\n                 }\n \n                 // FIXME: all this just to decide whether to use parentheses...\n-                let datas;\n-                let predicates: Vec<_> = match t.kind(&Interner) {\n+                let contains_impl_fn = |bounds: &[QuantifiedWhereClause]| {\n+                    bounds.iter().any(|bound| {\n+                        if let WhereClause::Implemented(trait_ref) = bound.skip_binders() {\n+                            let trait_ = trait_ref.hir_trait_id();\n+                            fn_traits(f.db.upcast(), trait_).any(|it| it == trait_)\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                };\n+                let (preds_to_print, has_impl_fn_pred) = match t.kind(&Interner) {\n                     TyKind::Dyn(dyn_ty) if dyn_ty.bounds.skip_binders().interned().len() > 1 => {\n-                        dyn_ty.bounds.skip_binders().interned().iter().cloned().collect()\n+                        let bounds = dyn_ty.bounds.skip_binders().interned();\n+                        (bounds.len(), contains_impl_fn(bounds))\n                     }\n                     TyKind::Alias(AliasTy::Opaque(OpaqueTy {\n                         opaque_ty_id,\n@@ -389,33 +400,54 @@ impl HirDisplay for Ty {\n                         let impl_trait_id =\n                             f.db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n                         if let ImplTraitId::ReturnTypeImplTrait(func, idx) = impl_trait_id {\n-                            datas =\n+                            let datas =\n                                 f.db.return_type_impl_traits(func)\n                                     .expect(\"impl trait id without data\");\n                             let data = (*datas)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                             let bounds = data.substitute(&Interner, parameters);\n-                            bounds.into_value_and_skipped_binders().0\n+                            let mut len = bounds.skip_binders().len();\n+\n+                            // Don't count Sized but count when it absent\n+                            // (i.e. when explicit ?Sized bound is set).\n+                            let default_sized = SizedByDefault::Sized {\n+                                anchor: func.lookup(f.db.upcast()).module(f.db.upcast()).krate(),\n+                            };\n+                            let sized_bounds = bounds\n+                                .skip_binders()\n+                                .iter()\n+                                .filter(|b| {\n+                                    matches!(\n+                                        b.skip_binders(),\n+                                        WhereClause::Implemented(trait_ref)\n+                                            if default_sized.is_sized_trait(\n+                                                trait_ref.hir_trait_id(),\n+                                                f.db.upcast(),\n+                                            ),\n+                                    )\n+                                })\n+                                .count();\n+                            match sized_bounds {\n+                                0 => len += 1,\n+                                _ => {\n+                                    len = len.saturating_sub(sized_bounds);\n+                                }\n+                            }\n+\n+                            (len, contains_impl_fn(bounds.skip_binders()))\n                         } else {\n-                            Vec::new()\n+                            (0, false)\n                         }\n                     }\n-                    _ => Vec::new(),\n+                    _ => (0, false),\n                 };\n \n-                if let Some(WhereClause::Implemented(trait_ref)) =\n-                    predicates.get(0).map(|b| b.skip_binders())\n-                {\n-                    let trait_ = trait_ref.hir_trait_id();\n-                    if fn_traits(f.db.upcast(), trait_).any(|it| it == trait_)\n-                        && predicates.len() <= 2\n-                    {\n-                        return t.hir_fmt(f);\n-                    }\n+                if has_impl_fn_pred && preds_to_print <= 2 {\n+                    return t.hir_fmt(f);\n                 }\n \n-                if predicates.len() > 1 {\n+                if preds_to_print > 1 {\n                     write!(f, \"(\")?;\n                     t.hir_fmt(f)?;\n                     write!(f, \")\")?;\n@@ -582,7 +614,13 @@ impl HirDisplay for Ty {\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.substitute(&Interner, &parameters);\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", bounds.skip_binders(), f)?;\n+                        let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n+                        write_bounds_like_dyn_trait_with_prefix(\n+                            \"impl\",\n+                            bounds.skip_binders(),\n+                            SizedByDefault::Sized { anchor: krate },\n+                            f,\n+                        )?;\n                         // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n@@ -641,7 +679,13 @@ impl HirDisplay for Ty {\n                                     _ => false,\n                                 })\n                                 .collect::<Vec<_>>();\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", &bounds, f)?;\n+                        let krate = id.parent.module(f.db.upcast()).krate();\n+                        write_bounds_like_dyn_trait_with_prefix(\n+                            \"impl\",\n+                            &bounds,\n+                            SizedByDefault::Sized { anchor: krate },\n+                            f,\n+                        )?;\n                     }\n                 }\n             }\n@@ -650,6 +694,7 @@ impl HirDisplay for Ty {\n                 write_bounds_like_dyn_trait_with_prefix(\n                     \"dyn\",\n                     dyn_ty.bounds.skip_binders().interned(),\n+                    SizedByDefault::NotSized,\n                     f,\n                 )?;\n             }\n@@ -664,7 +709,13 @@ impl HirDisplay for Ty {\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.substitute(&Interner, &opaque_ty.substitution);\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", bounds.skip_binders(), f)?;\n+                        let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n+                        write_bounds_like_dyn_trait_with_prefix(\n+                            \"impl\",\n+                            bounds.skip_binders(),\n+                            SizedByDefault::Sized { anchor: krate },\n+                            f,\n+                        )?;\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                         write!(f, \"{{async block}}\")?;\n@@ -713,22 +764,45 @@ fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = Trai\n     utils::fn_traits(db, krate)\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum SizedByDefault {\n+    NotSized,\n+    Sized { anchor: CrateId },\n+}\n+\n+impl SizedByDefault {\n+    fn is_sized_trait(self, trait_: TraitId, db: &dyn DefDatabase) -> bool {\n+        match self {\n+            Self::NotSized => false,\n+            Self::Sized { anchor } => {\n+                let sized_trait =\n+                    db.lang_item(anchor, \"sized\".into()).and_then(|lang_item| lang_item.as_trait());\n+                Some(trait_) == sized_trait\n+            }\n+        }\n+    }\n+}\n+\n pub fn write_bounds_like_dyn_trait_with_prefix(\n     prefix: &str,\n     predicates: &[QuantifiedWhereClause],\n+    default_sized: SizedByDefault,\n     f: &mut HirFormatter,\n ) -> Result<(), HirDisplayError> {\n     write!(f, \"{}\", prefix)?;\n-    if !predicates.is_empty() {\n+    if !predicates.is_empty()\n+        || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. })\n+    {\n         write!(f, \" \")?;\n-        write_bounds_like_dyn_trait(predicates, f)\n+        write_bounds_like_dyn_trait(predicates, default_sized, f)\n     } else {\n         Ok(())\n     }\n }\n \n fn write_bounds_like_dyn_trait(\n     predicates: &[QuantifiedWhereClause],\n+    default_sized: SizedByDefault,\n     f: &mut HirFormatter,\n ) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n@@ -740,10 +814,18 @@ fn write_bounds_like_dyn_trait(\n     let mut first = true;\n     let mut angle_open = false;\n     let mut is_fn_trait = false;\n+    let mut is_sized = false;\n     for p in predicates.iter() {\n         match p.skip_binders() {\n             WhereClause::Implemented(trait_ref) => {\n                 let trait_ = trait_ref.hir_trait_id();\n+                if default_sized.is_sized_trait(trait_, f.db.upcast()) {\n+                    is_sized = true;\n+                    if matches!(default_sized, SizedByDefault::Sized { .. }) {\n+                        // Don't print +Sized, but rather +?Sized if absent.\n+                        continue;\n+                    }\n+                }\n                 if !is_fn_trait {\n                     is_fn_trait = fn_traits(f.db.upcast(), trait_).any(|it| it == trait_);\n                 }\n@@ -808,6 +890,13 @@ fn write_bounds_like_dyn_trait(\n     if angle_open {\n         write!(f, \">\")?;\n     }\n+    if matches!(default_sized, SizedByDefault::Sized { .. }) {\n+        if !is_sized {\n+            write!(f, \"{}?Sized\", if first { \"\" } else { \" + \" })?;\n+        } else if first {\n+            write!(f, \"Sized\")?;\n+        }\n+    }\n     Ok(())\n }\n \n@@ -1026,7 +1115,13 @@ impl HirDisplay for TypeRef {\n impl HirDisplay for TypeBound {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self {\n-            TypeBound::Path(path) => path.hir_fmt(f),\n+            TypeBound::Path(path, modifier) => {\n+                match modifier {\n+                    TraitBoundModifier::None => (),\n+                    TraitBoundModifier::Maybe => write!(f, \"?\")?,\n+                }\n+                path.hir_fmt(f)\n+            }\n             TypeBound::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n             TypeBound::ForLifetime(lifetimes, path) => {\n                 write!(f, \"for<{}> \", lifetimes.iter().format(\", \"))?;"}, {"sha": "0f5859c433f2bf50ef1f51d8205cd6ce37e6535a", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -17,8 +17,8 @@ use crate::{\n         Adjust, Adjustment, AutoBorrow, InferOk, InferResult, InferenceContext, OverloadedDeref,\n         PointerCast, TypeError, TypeMismatch,\n     },\n-    static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, InEnvironment, Interner, Solution,\n-    Substitution, Ty, TyBuilder, TyExt, TyKind,\n+    static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, Guidance, InEnvironment, Interner,\n+    Solution, Substitution, Ty, TyBuilder, TyExt, TyKind,\n };\n \n pub(crate) type CoerceResult = Result<InferOk<(Vec<Adjustment>, Ty)>, TypeError>;\n@@ -541,7 +541,7 @@ impl<'a> InferenceContext<'a> {\n             _ => return Err(TypeError),\n         };\n \n-        let trait_ref = {\n+        let coerce_unsized_tref = {\n             let b = TyBuilder::trait_ref(self.db, coerce_unsized_trait);\n             if b.remaining() != 2 {\n                 // The CoerceUnsized trait should have two generic params: Self and T.\n@@ -551,7 +551,7 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         let goal: InEnvironment<DomainGoal> =\n-            InEnvironment::new(&self.trait_env.env, trait_ref.cast(&Interner));\n+            InEnvironment::new(&self.trait_env.env, coerce_unsized_tref.cast(&Interner));\n \n         let canonicalized = self.canonicalize(goal);\n \n@@ -575,7 +575,9 @@ impl<'a> InferenceContext<'a> {\n                     },\n                 );\n             }\n-            // FIXME: should we accept ambiguous results here?\n+            Solution::Ambig(Guidance::Definite(subst)) => {\n+                canonicalized.apply_solution(&mut self.table, subst)\n+            }\n             _ => return Err(TypeError),\n         };\n         let unsize ="}, {"sha": "8cac285cb195e9ae08b948b27fb67e03fce6790e", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 116, "deletions": 14, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -18,13 +18,14 @@ use hir_def::{\n     generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n-    type_ref::{TraitRef as HirTraitRef, TypeBound, TypeRef},\n+    type_ref::{TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n     AdtId, AssocContainerId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId,\n     GenericDefId, HasModule, ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId,\n     TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::Name, ExpandResult};\n use la_arena::ArenaMap;\n+use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n use stdx::impl_from;\n use syntax::ast;\n@@ -65,6 +66,8 @@ pub struct TyLoweringContext<'a> {\n     /// Splitting this up would be a possible fix.\n     opaque_type_data: RefCell<Vec<ReturnTypeImplTrait>>,\n     expander: RefCell<Option<Expander>>,\n+    /// Tracks types with explicit `?Sized` bounds.\n+    pub(crate) unsized_types: RefCell<FxHashSet<Ty>>,\n }\n \n impl<'a> TyLoweringContext<'a> {\n@@ -83,6 +86,7 @@ impl<'a> TyLoweringContext<'a> {\n             type_param_mode,\n             opaque_type_data,\n             expander: RefCell::new(None),\n+            unsized_types: RefCell::default(),\n         }\n     }\n \n@@ -93,17 +97,20 @@ impl<'a> TyLoweringContext<'a> {\n     ) -> T {\n         let opaque_ty_data_vec = self.opaque_type_data.replace(Vec::new());\n         let expander = self.expander.replace(None);\n+        let unsized_types = self.unsized_types.replace(Default::default());\n         let new_ctx = Self {\n             in_binders: debruijn,\n             impl_trait_counter: Cell::new(self.impl_trait_counter.get()),\n             opaque_type_data: RefCell::new(opaque_ty_data_vec),\n             expander: RefCell::new(expander),\n+            unsized_types: RefCell::new(unsized_types),\n             ..*self\n         };\n         let result = f(&new_ctx);\n         self.impl_trait_counter.set(new_ctx.impl_trait_counter.get());\n         self.opaque_type_data.replace(new_ctx.opaque_type_data.into_inner());\n         self.expander.replace(new_ctx.expander.into_inner());\n+        self.unsized_types.replace(new_ctx.unsized_types.into_inner());\n         result\n     }\n \n@@ -219,6 +226,10 @@ impl<'a> TyLoweringContext<'a> {\n                     ImplTraitLoweringMode::Opaque => {\n                         let idx = self.impl_trait_counter.get();\n                         self.impl_trait_counter.set(idx + 1);\n+                        let func = match self.resolver.generic_def() {\n+                            Some(GenericDefId::FunctionId(f)) => f,\n+                            _ => panic!(\"opaque impl trait lowering in non-function\"),\n+                        };\n \n                         assert!(idx as usize == self.opaque_type_data.borrow().len());\n                         // this dance is to make sure the data is in the right\n@@ -238,14 +249,10 @@ impl<'a> TyLoweringContext<'a> {\n                         // away instead of two.\n                         let actual_opaque_type_data = self\n                             .with_debruijn(DebruijnIndex::INNERMOST, |ctx| {\n-                                ctx.lower_impl_trait(bounds)\n+                                ctx.lower_impl_trait(bounds, func)\n                             });\n                         self.opaque_type_data.borrow_mut()[idx as usize] = actual_opaque_type_data;\n \n-                        let func = match self.resolver.generic_def() {\n-                            Some(GenericDefId::FunctionId(f)) => f,\n-                            _ => panic!(\"opaque impl trait lowering in non-function\"),\n-                        };\n                         let impl_trait_id = ImplTraitId::ReturnTypeImplTrait(func, idx);\n                         let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                         let generics = generics(self.db.upcast(), func.into());\n@@ -776,10 +783,27 @@ impl<'a> TyLoweringContext<'a> {\n     ) -> impl Iterator<Item = QuantifiedWhereClause> + 'a {\n         let mut bindings = None;\n         let trait_ref = match bound {\n-            TypeBound::Path(path) => {\n+            TypeBound::Path(path, TraitBoundModifier::None) => {\n                 bindings = self.lower_trait_ref_from_path(path, Some(self_ty));\n                 bindings.clone().map(WhereClause::Implemented).map(crate::wrap_empty_binders)\n             }\n+            TypeBound::Path(path, TraitBoundModifier::Maybe) => {\n+                let sized_trait = self\n+                    .resolver\n+                    .krate()\n+                    .and_then(|krate| self.db.lang_item(krate, \"sized\".into()))\n+                    .and_then(|lang_item| lang_item.as_trait());\n+                // Don't lower associated type bindings as the only possible relaxed trait bound\n+                // `?Sized` has no of them.\n+                // If we got another trait here ignore the bound completely.\n+                let trait_id = self\n+                    .lower_trait_ref_from_path(path, Some(self_ty.clone()))\n+                    .map(|trait_ref| trait_ref.hir_trait_id());\n+                if trait_id == sized_trait {\n+                    self.unsized_types.borrow_mut().insert(self_ty);\n+                }\n+                None\n+            }\n             TypeBound::ForLifetime(_, path) => {\n                 // FIXME Don't silently drop the hrtb lifetimes here\n                 bindings = self.lower_trait_ref_from_path(path, Some(self_ty));\n@@ -802,8 +826,12 @@ impl<'a> TyLoweringContext<'a> {\n         trait_ref: TraitRef,\n     ) -> impl Iterator<Item = QuantifiedWhereClause> + 'a {\n         let last_segment = match bound {\n-            TypeBound::Path(path) | TypeBound::ForLifetime(_, path) => path.segments().last(),\n-            TypeBound::Error | TypeBound::Lifetime(_) => None,\n+            TypeBound::Path(path, TraitBoundModifier::None) | TypeBound::ForLifetime(_, path) => {\n+                path.segments().last()\n+            }\n+            TypeBound::Path(_, TraitBoundModifier::Maybe)\n+            | TypeBound::Error\n+            | TypeBound::Lifetime(_) => None,\n         };\n         last_segment\n             .into_iter()\n@@ -843,13 +871,39 @@ impl<'a> TyLoweringContext<'a> {\n             })\n     }\n \n-    fn lower_impl_trait(&self, bounds: &[Interned<TypeBound>]) -> ReturnTypeImplTrait {\n+    fn lower_impl_trait(\n+        &self,\n+        bounds: &[Interned<TypeBound>],\n+        func: FunctionId,\n+    ) -> ReturnTypeImplTrait {\n         cov_mark::hit!(lower_rpit);\n         let self_ty =\n             TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n         let predicates = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-            bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)).collect()\n+            let mut predicates: Vec<_> = bounds\n+                .iter()\n+                .flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false))\n+                .collect();\n+\n+            if !ctx.unsized_types.borrow().contains(&self_ty) {\n+                let krate = func.lookup(ctx.db.upcast()).module(ctx.db.upcast()).krate();\n+                let sized_trait = ctx\n+                    .db\n+                    .lang_item(krate, \"sized\".into())\n+                    .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n+                let sized_clause = sized_trait.map(|trait_id| {\n+                    let clause = WhereClause::Implemented(TraitRef {\n+                        trait_id,\n+                        substitution: Substitution::from1(&Interner, self_ty.clone()),\n+                    });\n+                    crate::wrap_empty_binders(clause)\n+                });\n+                predicates.extend(sized_clause.into_iter());\n+                predicates.shrink_to_fit();\n+            }\n+            predicates\n         });\n+\n         ReturnTypeImplTrait { bounds: crate::make_only_type_binders(1, predicates) }\n     }\n }\n@@ -1008,7 +1062,7 @@ pub(crate) fn trait_environment_query(\n                 traits_in_scope\n                     .push((tr.self_type_parameter(&Interner).clone(), tr.hir_trait_id()));\n             }\n-            let program_clause: chalk_ir::ProgramClause<Interner> = pred.clone().cast(&Interner);\n+            let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(&Interner);\n             clauses.push(program_clause.into_from_env_clause(&Interner));\n         }\n     }\n@@ -1035,6 +1089,15 @@ pub(crate) fn trait_environment_query(\n         clauses.push(program_clause.into_from_env_clause(&Interner));\n     }\n \n+    let subst = generics(db.upcast(), def).type_params_subst(db);\n+    let explicitly_unsized_tys = ctx.unsized_types.into_inner();\n+    let implicitly_sized_clauses =\n+        implicitly_sized_clauses(db, def, &explicitly_unsized_tys, &subst, &resolver).map(|pred| {\n+            let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(&Interner);\n+            program_clause.into_from_env_clause(&Interner)\n+        });\n+    clauses.extend(implicitly_sized_clauses);\n+\n     let krate = def.module(db.upcast()).krate();\n \n     let env = chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses);\n@@ -1051,10 +1114,49 @@ pub(crate) fn generic_predicates_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let generics = generics(db.upcast(), def);\n-    resolver\n+\n+    let mut predicates = resolver\n         .where_predicates_in_scope()\n         .flat_map(|pred| ctx.lower_where_predicate(pred, false).map(|p| make_binders(&generics, p)))\n-        .collect()\n+        .collect::<Vec<_>>();\n+\n+    let subst = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let explicitly_unsized_tys = ctx.unsized_types.into_inner();\n+    let implicitly_sized_predicates =\n+        implicitly_sized_clauses(db, def, &explicitly_unsized_tys, &subst, &resolver)\n+            .map(|p| make_binders(&generics, crate::wrap_empty_binders(p)));\n+    predicates.extend(implicitly_sized_predicates);\n+    predicates.into()\n+}\n+\n+/// Generate implicit `: Sized` predicates for all generics that has no `?Sized` bound.\n+/// Exception is Self of a trait def.\n+fn implicitly_sized_clauses<'a>(\n+    db: &dyn HirDatabase,\n+    def: GenericDefId,\n+    explicitly_unsized_tys: &'a FxHashSet<Ty>,\n+    substitution: &'a Substitution,\n+    resolver: &Resolver,\n+) -> impl Iterator<Item = WhereClause> + 'a {\n+    let is_trait_def = matches!(def, GenericDefId::TraitId(..));\n+    let generic_args = &substitution.as_slice(&Interner)[is_trait_def as usize..];\n+    let sized_trait = resolver\n+        .krate()\n+        .and_then(|krate| db.lang_item(krate, \"sized\".into()))\n+        .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n+\n+    sized_trait.into_iter().flat_map(move |sized_trait| {\n+        let implicitly_sized_tys = generic_args\n+            .iter()\n+            .filter_map(|generic_arg| generic_arg.ty(&Interner))\n+            .filter(move |&self_ty| !explicitly_unsized_tys.contains(self_ty));\n+        implicitly_sized_tys.map(move |self_ty| {\n+            WhereClause::Implemented(TraitRef {\n+                trait_id: sized_trait,\n+                substitution: Substitution::from1(&Interner, self_ty.clone()),\n+            })\n+        })\n+    })\n }\n \n /// Resolve the default type params from generics"}, {"sha": "4e761a6b474eeaef6768ca6f44c8d86331365c5e", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -398,15 +398,15 @@ fn test() {\n \n #[test]\n fn coerce_unsize_apit() {\n-    // FIXME: #8984\n     check(\n         r#\"\n //- minicore: coerce_unsized\n trait Foo {}\n \n-fn test(f: impl Foo) {\n+fn test(f: impl Foo, g: &(impl Foo + ?Sized)) {\n     let _: &dyn Foo = &f;\n-                    //^^ expected &dyn Foo, got &impl Foo\n+    let _: &dyn Foo = g;\n+                    //^ expected &dyn Foo, got &impl Foo + ?Sized\n }\n         \"#,\n     );\n@@ -559,3 +559,16 @@ fn test() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn coerce_type_var() {\n+    check_types(\n+        r#\"\n+//- minicore: from, coerce_unsized\n+fn test() {\n+    let x = ();\n+    let _: &() = &x.into();\n+}               //^^^^^^^^ ()\n+\"#,\n+    )\n+}"}, {"sha": "240942e488d7de79adbe9e9a08e8fe6b8e44255c", "filename": "crates/hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 109, "deletions": 2, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -44,13 +44,13 @@ fn main() {\n fn render_raw_ptr_impl_ty() {\n     check_types_source_code(\n         r#\"\n-trait Sized {}\n+//- minicore: sized\n trait Unpin {}\n fn foo() -> *const (impl Unpin + Sized) { loop {} }\n fn main() {\n     let foo = foo();\n     foo;\n-} //^^^ *const (impl Unpin + Sized)\n+} //^^^ *const impl Unpin\n \"#,\n     );\n }\n@@ -67,3 +67,110 @@ fn foo(foo: &dyn for<'a> Foo<'a>) {}\n \"#,\n     );\n }\n+\n+#[test]\n+fn sized_bounds_apit() {\n+    check_types_source_code(\n+        r#\"\n+//- minicore: sized\n+trait Foo {}\n+trait Bar<T> {}\n+struct S<T>;\n+fn test(\n+    a: impl Foo,\n+    b: impl Foo + Sized,\n+    c: &(impl Foo + ?Sized),\n+    d: S<impl Foo>,\n+    ref_any: &impl ?Sized,\n+    empty: impl,\n+) {\n+    a;\n+  //^ impl Foo\n+    b;\n+  //^ impl Foo\n+    c;\n+  //^ &impl Foo + ?Sized\n+    d;\n+  //^ S<impl Foo>\n+    ref_any;\n+  //^^^^^^^ &impl ?Sized\n+    empty;\n+} //^^^^^ impl Sized\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn sized_bounds_rpit() {\n+    check_types_source_code(\n+        r#\"\n+//- minicore: sized\n+trait Foo {}\n+fn foo1() -> impl Foo { loop {} }\n+fn foo2() -> impl Foo + Sized { loop {} }\n+fn foo3() -> impl Foo + ?Sized { loop {} }\n+fn test() {\n+    let foo = foo1();\n+    foo;\n+  //^^^ impl Foo\n+    let foo = foo2();\n+    foo;\n+  //^^^ impl Foo\n+    let foo = foo3();\n+    foo;\n+} //^^^ impl Foo + ?Sized\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn parenthesize_ptr_rpit_sized_bounds() {\n+    check_types_source_code(\n+        r#\"\n+//- minicore: sized\n+trait Foo {}\n+fn foo1() -> *const impl Foo { loop {} }\n+fn foo2() -> *const (impl Foo + Sized) { loop {} }\n+fn foo3() -> *const (impl Sized + Foo) { loop {} }\n+fn foo4() -> *const (impl Foo + ?Sized) { loop {} }\n+fn foo5() -> *const (impl ?Sized + Foo) { loop {} }\n+fn test() {\n+    let foo = foo1();\n+    foo;\n+  //^^^ *const impl Foo\n+    let foo = foo2();\n+    foo;\n+  //^^^ *const impl Foo\n+    let foo = foo3();\n+    foo;\n+  //^^^ *const impl Foo\n+    let foo = foo4();\n+    foo;\n+  //^^^ *const (impl Foo + ?Sized)\n+    let foo = foo5();\n+    foo;\n+} //^^^ *const (impl Foo + ?Sized)\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn sized_bounds_impl_traits_in_fn_signature() {\n+    check_types_source_code(\n+        r#\"\n+//- minicore: sized\n+trait Foo {}\n+fn test(\n+    a: fn(impl Foo) -> impl Foo,\n+    b: fn(impl Foo + Sized) -> impl Foo + Sized,\n+    c: fn(&(impl Foo + ?Sized)) -> &(impl Foo + ?Sized),\n+) {\n+    a;\n+  //^ fn(impl Foo) -> impl Foo\n+    b;\n+  //^ fn(impl Foo) -> impl Foo\n+    c;\n+} //^ fn(&impl Foo + ?Sized) -> &impl Foo + ?Sized\n+\"#,\n+    );\n+}"}, {"sha": "0c5022730998d44871eaef1a0d7d7070ccf7a808", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -922,6 +922,7 @@ fn test() { foo.call(); }\n fn super_trait_impl_return_trait_method_resolution() {\n     check_infer(\n         r#\"\n+        //- minicore: sized\n         trait Base {\n             fn foo(self) -> usize;\n         }\n@@ -1312,3 +1313,29 @@ impl<'a, T> IntoIterator for &'a [T] {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn sized_blanket_impl() {\n+    check_infer(\n+        r#\"\n+//- minicore: sized\n+trait Foo { fn foo() -> u8; }\n+impl<T: Sized> Foo for T {}\n+fn f<S: Sized, T, U: ?Sized>() {\n+    u32::foo;\n+    S::foo;\n+    T::foo;\n+    U::foo;\n+    <[u32]>::foo;\n+}\n+\"#,\n+        expect![[r#\"\n+            89..160 '{     ...foo; }': ()\n+            95..103 'u32::foo': fn foo<u32>() -> u8\n+            109..115 'S::foo': fn foo<S>() -> u8\n+            121..127 'T::foo': fn foo<T>() -> u8\n+            133..139 'U::foo': {unknown}\n+            145..157 '<[u32]>::foo': {unknown}\n+        \"#]],\n+    );\n+}"}, {"sha": "2574dfca3203b5fc0ca9d777095dffe72ca0fb07", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -944,7 +944,7 @@ fn lifetime_from_chalk_during_deref() {\n         r#\"\n //- minicore: deref\n struct Box<T: ?Sized> {}\n-impl<T> core::ops::Deref for Box<T> {\n+impl<T: ?Sized> core::ops::Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &Self::Target {\n@@ -1063,6 +1063,7 @@ fn cfg_tail() {\n fn impl_trait_in_option_9530() {\n     check_types(\n         r#\"\n+//- minicore: sized\n struct Option<T>;\n impl<T> Option<T> {\n     fn unwrap(self) -> T { loop {} }"}, {"sha": "de1b0e9f298069600c9bf0ba4bfbc35eae053347", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 77, "deletions": 14, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -43,7 +43,7 @@ fn test() {\n fn infer_desugar_async() {\n     check_types(\n         r#\"\n-//- minicore: future\n+//- minicore: future, sized\n async fn foo() -> u64 { 128 }\n \n fn test() {\n@@ -147,7 +147,7 @@ mod ops {\n     pub use self::try_trait::Try;\n }\n \n-mov convert {\n+mod convert {\n     pub trait From<T> {}\n     impl<T> From<T> for T {}\n }\n@@ -567,8 +567,8 @@ fn deref_trait() {\n     check_types(\n         r#\"\n //- minicore: deref\n-struct Arc<T>;\n-impl<T> core::ops::Deref for Arc<T> {\n+struct Arc<T: ?Sized>;\n+impl<T: ?Sized> core::ops::Deref for Arc<T> {\n     type Target = T;\n }\n \n@@ -589,9 +589,9 @@ fn deref_trait_with_inference_var() {\n     check_types(\n         r#\"\n //- minicore: deref\n-struct Arc<T>;\n-fn new_arc<T>() -> Arc<T> { Arc }\n-impl<T> core::ops::Deref for Arc<T> {\n+struct Arc<T: ?Sized>;\n+fn new_arc<T: ?Sized>() -> Arc<T> { Arc }\n+impl<T: ?Sized> core::ops::Deref for Arc<T> {\n     type Target = T;\n }\n \n@@ -631,7 +631,7 @@ fn deref_trait_with_question_mark_size() {\n     check_types(\n         r#\"\n //- minicore: deref\n-struct Arc<T>;\n+struct Arc<T: ?Sized>;\n impl<T: ?Sized> core::ops::Deref for Arc<T> {\n     type Target = T;\n }\n@@ -648,6 +648,25 @@ fn test(s: Arc<S>) {\n     );\n }\n \n+#[test]\n+fn deref_trait_with_implicit_sized_requirement_on_inference_var() {\n+    check_types(\n+        r#\"\n+//- minicore: deref\n+struct Foo<T>;\n+impl<T> core::ops::Deref for Foo<T> {\n+    type Target = ();\n+}\n+fn test() {\n+    let foo = Foo;\n+    *foo;\n+  //^^^^ ()\n+    let _: Foo<u8> = foo;\n+}\n+\"#,\n+    )\n+}\n+\n #[test]\n fn obligation_from_function_clause() {\n     check_types(\n@@ -845,6 +864,7 @@ fn test<T: ApplyL>(t: T) {\n fn argument_impl_trait() {\n     check_infer_with_mismatches(\n         r#\"\n+//- minicore: sized\n trait Trait<T> {\n     fn foo(&self) -> T;\n     fn foo2(&self) -> i64;\n@@ -902,6 +922,7 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u32>) {\n fn argument_impl_trait_type_args_1() {\n     check_infer_with_mismatches(\n         r#\"\n+//- minicore: sized\n trait Trait {}\n trait Foo {\n     // this function has an implicit Self param, an explicit type param,\n@@ -967,6 +988,7 @@ fn test() {\n fn argument_impl_trait_type_args_2() {\n     check_infer_with_mismatches(\n         r#\"\n+//- minicore: sized\n trait Trait {}\n struct S;\n impl Trait for S {}\n@@ -1008,6 +1030,7 @@ fn test() {\n fn argument_impl_trait_to_fn_pointer() {\n     check_infer_with_mismatches(\n         r#\"\n+//- minicore: sized\n trait Trait {}\n fn foo(x: impl Trait) { loop {} }\n struct S;\n@@ -1032,6 +1055,7 @@ fn test() {\n fn impl_trait() {\n     check_infer(\n         r#\"\n+//- minicore: sized\n trait Trait<T> {\n     fn foo(&self) -> T;\n     fn foo2(&self) -> i64;\n@@ -1082,6 +1106,7 @@ fn simple_return_pos_impl_trait() {\n     cov_mark::check!(lower_rpit);\n     check_infer(\n         r#\"\n+//- minicore: sized\n trait Trait<T> {\n     fn foo(&self) -> T;\n }\n@@ -1110,6 +1135,7 @@ fn test() {\n fn more_return_pos_impl_trait() {\n     check_infer(\n         r#\"\n+//- minicore: sized\n trait Iterator {\n     type Item;\n     fn next(&mut self) -> Self::Item;\n@@ -1168,6 +1194,7 @@ fn test() {\n fn dyn_trait() {\n     check_infer(\n         r#\"\n+//- minicore: sized\n trait Trait<T> {\n     fn foo(&self) -> T;\n     fn foo2(&self) -> i64;\n@@ -1217,6 +1244,7 @@ fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n fn dyn_trait_in_impl() {\n     check_infer(\n         r#\"\n+//- minicore: sized\n trait Trait<T, U> {\n     fn foo(&self) -> (T, U);\n }\n@@ -1252,6 +1280,7 @@ fn test(s: S<u32, i32>) {\n fn dyn_trait_bare() {\n     check_infer(\n         r#\"\n+//- minicore: sized\n trait Trait {\n     fn foo(&self) -> u64;\n }\n@@ -1290,6 +1319,7 @@ fn test(x: Trait, y: &Trait) -> u64 {\n fn weird_bounds() {\n     check_infer(\n         r#\"\n+//- minicore: sized\n trait Trait {}\n fn test(\n     a: impl Trait + 'lifetime,\n@@ -1302,11 +1332,11 @@ fn test(\n \"#,\n         expect![[r#\"\n             28..29 'a': impl Trait\n-            59..60 'b': impl\n+            59..60 'b': impl Sized\n             82..83 'c': impl Trait\n-            103..104 'd': impl\n-            128..129 'e': impl\n-            148..149 'f': impl Trait\n+            103..104 'd': impl Sized\n+            128..129 'e': impl ?Sized\n+            148..149 'f': impl Trait + ?Sized\n             173..175 '{}': ()\n         \"#]],\n     );\n@@ -1331,6 +1361,7 @@ fn test(x: (impl Trait + UnknownTrait)) {\n fn assoc_type_bindings() {\n     check_infer(\n         r#\"\n+//- minicore: sized\n trait Trait {\n     type Type;\n }\n@@ -1495,6 +1526,7 @@ fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n fn super_trait_impl_trait_method_resolution() {\n     check_infer(\n         r#\"\n+//- minicore: sized\n mod foo {\n     trait SuperTrait {\n         fn foo(&self) -> u32 {}\n@@ -2299,6 +2331,7 @@ impl TokenStream for Rustc {\n fn unify_impl_trait() {\n     check_infer_with_mismatches(\n         r#\"\n+//- minicore: sized\n trait Trait<T> {}\n \n fn foo(x: impl Trait<u32>) { loop {} }\n@@ -2417,8 +2450,8 @@ fn dyn_trait_through_chalk() {\n     check_types(\n         r#\"\n //- minicore: deref\n-struct Box<T> {}\n-impl<T> core::ops::Deref for Box<T> {\n+struct Box<T: ?Sized> {}\n+impl<T: ?Sized> core::ops::Deref for Box<T> {\n     type Target = T;\n }\n trait Trait {\n@@ -3515,3 +3548,33 @@ fn test() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn associated_type_sized_bounds() {\n+    check_infer(\n+        r#\"\n+//- minicore: sized\n+struct Yes;\n+trait IsSized { const IS_SIZED: Yes; }\n+impl<T: Sized> IsSized for T { const IS_SIZED: Yes = Yes; }\n+\n+trait Foo {\n+    type Explicit: Sized;\n+    type Implicit;\n+    type Relaxed: ?Sized;\n+}\n+fn f<F: Foo>() {\n+    F::Explicit::IS_SIZED;\n+    F::Implicit::IS_SIZED;\n+    F::Relaxed::IS_SIZED;\n+}\n+\"#,\n+        expect![[r#\"\n+            104..107 'Yes': Yes\n+            212..295 '{     ...ZED; }': ()\n+            218..239 'F::Exp..._SIZED': Yes\n+            245..266 'F::Imp..._SIZED': Yes\n+            272..292 'F::Rel..._SIZED': {unknown}\n+        \"#]],\n+    );\n+}"}, {"sha": "14b8a726a8faa25ac502f6727bcd441784d92aa8", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -13,7 +13,7 @@ use hir_def::{\n     intern::Interned,\n     path::Path,\n     resolver::{HasResolver, TypeNs},\n-    type_ref::TypeRef,\n+    type_ref::{TraitBoundModifier, TypeRef},\n     AssocContainerId, GenericDefId, Lookup, TraitId, TypeAliasId, TypeParamId,\n };\n use hir_expand::name::{name, Name};\n@@ -58,6 +58,10 @@ fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n             },\n             WherePredicate::Lifetime { .. } => None,\n         })\n+        .filter_map(|(path, bound_modifier)| match bound_modifier {\n+            TraitBoundModifier::None => Some(path),\n+            TraitBoundModifier::Maybe => None,\n+        })\n         .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {\n             Some(TypeNs::TraitId(t)) => Some(t),\n             _ => None,"}, {"sha": "f11eaaa546daefb4bdba620b38fde20a8b3032df", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -1226,7 +1226,9 @@ fn main() {\n     #[test]\n     fn hover_for_param_with_multiple_traits() {\n         check(\n-            r#\"trait Deref {\n+            r#\"\n+            //- minicore: sized\n+            trait Deref {\n                 type Target: ?Sized;\n             }\n             trait DerefMut {\n@@ -3417,17 +3419,17 @@ fn foo() {\n     fn hover_type_param() {\n         check(\n             r#\"\n+//- minicore: sized\n struct Foo<T>(T);\n trait Copy {}\n trait Clone {}\n-trait Sized {}\n impl<T: Copy + Clone> Foo<T$0> where T: Sized {}\n \"#,\n             expect![[r#\"\n                 *T*\n \n                 ```rust\n-                T: Copy + Clone + Sized\n+                T: Copy + Clone\n                 ```\n             \"#]],\n         );\n@@ -3460,6 +3462,26 @@ impl<T: 'static> Foo<T$0> {}\n         );\n     }\n \n+    #[test]\n+    fn hover_type_param_not_sized() {\n+        check(\n+            r#\"\n+//- minicore: sized\n+struct Foo<T>(T);\n+trait Copy {}\n+trait Clone {}\n+impl<T: Copy + Clone> Foo<T$0> where T: ?Sized {}\n+\"#,\n+            expect![[r#\"\n+                *T*\n+\n+                ```rust\n+                T: Copy + Clone + ?Sized\n+                ```\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn hover_const_param() {\n         check("}, {"sha": "e3d63cc949e1d81c72233323381a149a9be31727", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -924,9 +924,53 @@ fn main() {\n     let foo = foo5();\n      // ^^^ &dyn Fn(&dyn Fn(f64, f64) -> u32, f64) -> u32\n     let foo = foo6();\n-     // ^^^ impl Fn(f64, f64) -> u32 + Sized\n+     // ^^^ impl Fn(f64, f64) -> u32\n+    let foo = foo7();\n+     // ^^^ *const impl Fn(f64, f64) -> u32\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn fn_hints_ptr_rpit_fn_parentheses() {\n+        check_types(\n+            r#\"\n+//- minicore: fn, sized\n+trait Trait {}\n+\n+fn foo1() -> *const impl Fn() { loop {} }\n+fn foo2() -> *const (impl Fn() + Sized) { loop {} }\n+fn foo3() -> *const (impl Fn() + ?Sized) { loop {} }\n+fn foo4() -> *const (impl Sized + Fn()) { loop {} }\n+fn foo5() -> *const (impl ?Sized + Fn()) { loop {} }\n+fn foo6() -> *const (impl Fn() + Trait) { loop {} }\n+fn foo7() -> *const (impl Fn() + Sized + Trait) { loop {} }\n+fn foo8() -> *const (impl Fn() + ?Sized + Trait) { loop {} }\n+fn foo9() -> *const (impl Fn() -> u8 + ?Sized) { loop {} }\n+fn foo10() -> *const (impl Fn() + Sized + ?Sized) { loop {} }\n+\n+fn main() {\n+    let foo = foo1();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo2();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo3();\n+    //  ^^^ *const (impl Fn() + ?Sized)\n+    let foo = foo4();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo5();\n+    //  ^^^ *const (impl Fn() + ?Sized)\n+    let foo = foo6();\n+    //  ^^^ *const (impl Fn() + Trait)\n     let foo = foo7();\n-     // ^^^ *const (impl Fn(f64, f64) -> u32 + Sized)\n+    //  ^^^ *const (impl Fn() + Trait)\n+    let foo = foo8();\n+    //  ^^^ *const (impl Fn() + Trait + ?Sized)\n+    let foo = foo9();\n+    //  ^^^ *const (impl Fn() -> u8 + ?Sized)\n+    let foo = foo10();\n+    //  ^^^ *const impl Fn()\n }\n \"#,\n         )"}, {"sha": "63503392cbd3e88cc3ec737404ef07ea7200ebeb", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf149437452f6aec9f873bb312723bf62cb3a74/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=baf149437452f6aec9f873bb312723bf62cb3a74", "patch": "@@ -937,16 +937,17 @@ fn bar(worble: ()) ${0:-> ()} {\n     fn add_function_with_impl_trait_arg() {\n         check_assist(\n             generate_function,\n-            r\"\n+            r#\"\n+//- minicore: sized\n trait Foo {}\n fn foo() -> impl Foo {\n     todo!()\n }\n fn baz() {\n     $0bar(foo())\n }\n-\",\n-            r\"\n+\"#,\n+            r#\"\n trait Foo {}\n fn foo() -> impl Foo {\n     todo!()\n@@ -958,7 +959,7 @@ fn baz() {\n fn bar(foo: impl Foo) ${0:-> ()} {\n     todo!()\n }\n-\",\n+\"#,\n         )\n     }\n "}]}