{"sha": "9a5978966305fdb921982db365bf77ac22d090cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNTk3ODk2NjMwNWZkYjkyMTk4MmRiMzY1YmY3N2FjMjJkMDkwY2Y=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-20T07:47:26Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-27T10:09:59Z"}, "message": "Store query jobs and query results in separate maps to reduce memory usage", "tree": {"sha": "5b714e27e108fecd2a162046102bd9282d965fd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b714e27e108fecd2a162046102bd9282d965fd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a5978966305fdb921982db365bf77ac22d090cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a5978966305fdb921982db365bf77ac22d090cf", "html_url": "https://github.com/rust-lang/rust/commit/9a5978966305fdb921982db365bf77ac22d090cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a5978966305fdb921982db365bf77ac22d090cf/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "html_url": "https://github.com/rust-lang/rust/commit/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c"}], "stats": {"total": 48, "additions": 23, "deletions": 25}, "files": [{"sha": "3b6af018d6b789d839c4bb2a2f84781bc867cc9a", "filename": "src/librustc/ty/maps/job.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a5978966305fdb921982db365bf77ac22d090cf/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5978966305fdb921982db365bf77ac22d090cf/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=9a5978966305fdb921982db365bf77ac22d090cf", "patch": "@@ -17,13 +17,10 @@ use ty::context::TyCtxt;\n use errors::Diagnostic;\n \n /// Indicates the state of a query for a given key in a query map\n-pub(super) enum QueryResult<'tcx, T> {\n+pub(super) enum QueryResult<'tcx> {\n     /// An already executing query. The query job can be used to await for its completion\n     Started(Lrc<QueryJob<'tcx>>),\n \n-    /// The query is complete and produced `T`\n-    Complete(T),\n-\n     /// The query panicked. Queries trying to wait on this will raise a fatal error / silently panic\n     Poisoned,\n }"}, {"sha": "cea2a03fd532c58c3ea572c5c90c6ffe2567de14", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a5978966305fdb921982db365bf77ac22d090cf/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5978966305fdb921982db365bf77ac22d090cf/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=9a5978966305fdb921982db365bf77ac22d090cf", "patch": "@@ -30,7 +30,6 @@ use syntax::codemap::{CodeMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n-use ty::maps::job::QueryResult;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use ty::context::TyCtxt;\n use util::common::time;\n@@ -240,13 +239,11 @@ impl<'sess> OnDiskCache<'sess> {\n \n                 // const eval is special, it only encodes successfully evaluated constants\n                 use ty::maps::QueryConfig;\n-                for (key, entry) in const_eval::query_map(tcx).borrow().map.iter() {\n+                let map = const_eval::query_map(tcx).borrow();\n+                assert!(map.active.is_empty());\n+                for (key, entry) in map.results.iter() {\n                     use ty::maps::config::QueryDescription;\n                     if const_eval::cache_on_disk(key.clone()) {\n-                        let entry = match *entry {\n-                            QueryResult::Complete(ref v) => v,\n-                            _ => panic!(\"incomplete query\"),\n-                        };\n                         if let Ok(ref value) = entry.value {\n                             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n@@ -1133,12 +1130,10 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     time(tcx.sess, desc, || {\n \n-    for (key, entry) in Q::query_map(tcx).borrow().map.iter() {\n+    let map = Q::query_map(tcx).borrow();\n+    assert!(map.active.is_empty());\n+    for (key, entry) in map.results.iter() {\n         if Q::cache_on_disk(key.clone()) {\n-            let entry = match *entry {\n-                QueryResult::Complete(ref v) => v,\n-                _ => panic!(\"incomplete query\"),\n-            };\n             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n             // Record position of the cache entry"}, {"sha": "83305db57dad7960f93acb0e78ad430b08760c42", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9a5978966305fdb921982db365bf77ac22d090cf/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5978966305fdb921982db365bf77ac22d090cf/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=9a5978966305fdb921982db365bf77ac22d090cf", "patch": "@@ -36,7 +36,8 @@ use syntax_pos::Span;\n use syntax::codemap::DUMMY_SP;\n \n pub struct QueryMap<'tcx, D: QueryConfig<'tcx> + ?Sized> {\n-    pub(super) map: FxHashMap<D::Key, QueryResult<'tcx, QueryValue<D::Value>>>,\n+    pub(super) results: FxHashMap<D::Key, QueryValue<D::Value>>,\n+    pub(super) active: FxHashMap<D::Key, QueryResult<'tcx>>,\n }\n \n pub(super) struct QueryValue<T> {\n@@ -58,7 +59,8 @@ impl<T> QueryValue<T> {\n impl<'tcx, M: QueryConfig<'tcx>> QueryMap<'tcx, M> {\n     pub(super) fn new() -> QueryMap<'tcx, M> {\n         QueryMap {\n-            map: FxHashMap(),\n+            results: FxHashMap(),\n+            active: FxHashMap(),\n         }\n     }\n }\n@@ -111,15 +113,15 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n         let map = Q::query_map(tcx);\n         loop {\n             let mut lock = map.borrow_mut();\n-            let job = match lock.map.entry((*key).clone()) {\n+            if let Some(value) = lock.results.get(key) {\n+                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                let result = Ok((value.value.clone(), value.index));\n+                return TryGetJob::JobCompleted(result);\n+            }\n+            let job = match lock.active.entry((*key).clone()) {\n                 Entry::Occupied(entry) => {\n                     match *entry.get() {\n                         QueryResult::Started(ref job) => job.clone(),\n-                        QueryResult::Complete(ref value) => {\n-                            profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                            let result = Ok((value.value.clone(), value.index));\n-                            return TryGetJob::JobCompleted(result);\n-                        },\n                         QueryResult::Poisoned => FatalError.raise(),\n                     }\n                 }\n@@ -161,7 +163,11 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n         mem::forget(self);\n \n         let value = QueryValue::new(result.clone(), dep_node_index);\n-        map.borrow_mut().map.insert(key, QueryResult::Complete(value));\n+        {\n+            let mut lock = map.borrow_mut();\n+            lock.active.remove(&key);\n+            lock.results.insert(key, value);\n+        }\n \n         job.signal_complete();\n     }\n@@ -205,7 +211,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n     fn drop(&mut self) {\n         // Poison the query so jobs waiting on it panic\n-        self.map.borrow_mut().map.insert(self.key.clone(), QueryResult::Poisoned);\n+        self.map.borrow_mut().active.insert(self.key.clone(), QueryResult::Poisoned);\n         // Also signal the completion of the job, so waiters\n         // will continue execution\n         self.job.signal_complete();"}]}