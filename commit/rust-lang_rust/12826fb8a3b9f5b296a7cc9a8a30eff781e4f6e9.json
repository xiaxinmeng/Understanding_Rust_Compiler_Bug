{"sha": "12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyODI2ZmI4YTNiOWY1YjI5NmE3Y2M5YThhMzBlZmY3ODFlNGY2ZTk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-10T11:57:47Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-10T13:34:10Z"}, "message": "factor out lvalue field access into its own function", "tree": {"sha": "927adfaa75b5a76dac82023e9a2ef275089cdec9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/927adfaa75b5a76dac82023e9a2ef275089cdec9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlidwVIACgkQpp+NIls6\n19nSSxAAmcivRNpRlrjfWGAzZ5aEPPqqO3grnQxQNTynbncabVvMwLAazt96LCgJ\n0XOnILXJp+vSXcWPcJR9sQvrNLxwt5+g6Cu9E7wRjfq1gmGDsIjqeCqoWCmpxluJ\nq5alfZuepgpjm/ovq0qGk9ihns/5+IFwIgN57fZ8xXnAO9TqrfHB2sjP9Lyi6P4H\nIbnwu5AjgHbn+TEZ/YiZ/SiZfyH12Ht7ftkGrrokFAQ47cB6T9tlX/PSr43r9Z7K\nWGk1z5H53q7Mm9SGSyW6ihk86opElq+4SNMdARAzg6KHs9/NGeHyhCZkpJPn+369\nLtpk9AgIPAOulO7otpGWG0ZZrzzlKrClCBo5OKovO4tCcSKrxU53UmjjHGhEkUjj\n6GrtN3tkKADlCRz9954xQ2kxrF0ftgKKl7MDJZobmyC0UdBWGtw4r55/28ZX/3qT\n/4szYFGFBLLTAl7/1Vr0l8z98Q9b24ckce/3lRSGQNkpucOClHTPBgu+fCa/DZ7d\nL1+8b3noxNowijKkjbnlvYQLexrrPSm4FosY9lmQmsnhHHMr9Hs1j/09uqcmR+25\nGscoeW38iFmENd3aM5V/ZQ7U6/L4bqSm/JZYTrS1e/MZRf107PRlQb3gJSp3pxYp\nq3HOj8j8pw5IZ9yHBJZ7mkfPIIXu6Jg8rTUGA/OJRsL7NApV+Rk=\n=6EeJ\n-----END PGP SIGNATURE-----", "payload": "tree 927adfaa75b5a76dac82023e9a2ef275089cdec9\nparent 680e6498054b496787707cb1cf77994c2ba8744c\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1486727867 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1486733650 +0100\n\nfactor out lvalue field access into its own function"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9", "html_url": "https://github.com/rust-lang/rust/commit/12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "680e6498054b496787707cb1cf77994c2ba8744c", "url": "https://api.github.com/repos/rust-lang/rust/commits/680e6498054b496787707cb1cf77994c2ba8744c", "html_url": "https://github.com/rust-lang/rust/commit/680e6498054b496787707cb1cf77994c2ba8744c"}], "stats": {"total": 147, "additions": 78, "deletions": 69}, "files": [{"sha": "61ffeef7d593d9c57d6b27f60a6bd2859585077f", "filename": "src/lvalue.rs", "status": "modified", "additions": 78, "deletions": 69, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9", "patch": "@@ -160,88 +160,97 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(lvalue)\n     }\n \n-    fn eval_lvalue_projection(\n+    fn lvalue_field(\n         &mut self,\n-        proj: &mir::LvalueProjection<'tcx>,\n+        base: Lvalue<'tcx>,\n+        field: usize,\n+        base_ty: Ty<'tcx>,\n+        field_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n-        use rustc::mir::ProjectionElem::*;\n-        let (ptr, extra) = match proj.elem {\n-            Field(field, field_ty) => {\n-                let base = self.eval_lvalue(&proj.base)?;\n-                let base_ty = self.lvalue_ty(&proj.base);\n-                let base_layout = self.type_layout(base_ty)?;\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, base_extra) = base.to_ptr_and_extra();\n-\n-                let field_ty = self.monomorphize(field_ty, self.substs());\n-                let field = field.index();\n-\n-                use rustc::ty::layout::Layout::*;\n-                let (offset, packed) = match *base_layout {\n-                    Univariant { ref variant, .. } => {\n-                        (variant.offsets[field], variant.packed)\n-                    },\n+        let base_layout = self.type_layout(base_ty)?;\n+        // FIXME(solson)\n+        let base = self.force_allocation(base)?;\n+        let (base_ptr, base_extra) = base.to_ptr_and_extra();\n+\n+        let field_ty = self.monomorphize(field_ty, self.substs());\n+\n+        use rustc::ty::layout::Layout::*;\n+        let (offset, packed) = match *base_layout {\n+            Univariant { ref variant, .. } => {\n+                (variant.offsets[field], variant.packed)\n+            },\n+\n+            General { ref variants, .. } => {\n+                if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n+                    // +1 for the discriminant, which is field 0\n+                    (variants[variant_idx].offsets[field + 1], variants[variant_idx].packed)\n+                } else {\n+                    bug!(\"field access on enum had no variant index\");\n+                }\n+            }\n \n-                    General { ref variants, .. } => {\n-                        if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n-                            // +1 for the discriminant, which is field 0\n-                            (variants[variant_idx].offsets[field + 1], variants[variant_idx].packed)\n-                        } else {\n-                            bug!(\"field access on enum had no variant index\");\n-                        }\n-                    }\n+            RawNullablePointer { .. } => {\n+                assert_eq!(field, 0);\n+                return Ok(base);\n+            }\n \n-                    RawNullablePointer { .. } => {\n-                        assert_eq!(field, 0);\n-                        return Ok(base);\n-                    }\n+            StructWrappedNullablePointer { ref nonnull, .. } => {\n+                (nonnull.offsets[field], nonnull.packed)\n+            }\n \n-                    StructWrappedNullablePointer { ref nonnull, .. } => {\n-                        (nonnull.offsets[field], nonnull.packed)\n-                    }\n+            UntaggedUnion { .. } => return Ok(base),\n \n-                    UntaggedUnion { .. } => return Ok(base),\n+            Vector { element, count } => {\n+                let field = field as u64;\n+                assert!(field < count);\n+                let elem_size = element.size(&self.tcx.data_layout).bytes();\n+                (Size::from_bytes(field * elem_size), false)\n+            }\n \n-                    Vector { element, count } => {\n-                        let field = field as u64;\n-                        assert!(field < count);\n-                        let elem_size = element.size(&self.tcx.data_layout).bytes();\n-                        (Size::from_bytes(field * elem_size), false)\n-                    }\n+            _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n+        };\n \n-                    _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n-                };\n+        let offset = match base_extra {\n+            LvalueExtra::Vtable(tab) => {\n+                let (_, align) = self.size_and_align_of_dst(base_ty, Value::ByValPair(PrimVal::Ptr(base_ptr), PrimVal::Ptr(tab)))?;\n+                offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n+            }\n+            _ => offset.bytes(),\n+        };\n \n-                let offset = match base_extra {\n-                    LvalueExtra::Vtable(tab) => {\n-                        let (_, align) = self.size_and_align_of_dst(base_ty, Value::ByValPair(PrimVal::Ptr(base_ptr), PrimVal::Ptr(tab)))?;\n-                        offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n-                    }\n-                    _ => offset.bytes(),\n-                };\n+        let ptr = base_ptr.offset(offset);\n \n-                let ptr = base_ptr.offset(offset);\n+        if packed {\n+            let size = self.type_size(field_ty)?.expect(\"packed struct must be sized\");\n+            self.memory.mark_packed(ptr, size);\n+        }\n \n-                if packed {\n-                    let size = self.type_size(field_ty)?.expect(\"packed struct must be sized\");\n-                    self.memory.mark_packed(ptr, size);\n-                }\n+        let extra = if self.type_is_sized(field_ty) {\n+            LvalueExtra::None\n+        } else {\n+            match base_extra {\n+                LvalueExtra::None => bug!(\"expected fat pointer\"),\n+                LvalueExtra::DowncastVariant(..) =>\n+                    bug!(\"Rust doesn't support unsized fields in enum variants\"),\n+                LvalueExtra::Vtable(_) |\n+                LvalueExtra::Length(_) => {},\n+            }\n+            base_extra\n+        };\n \n-                let extra = if self.type_is_sized(field_ty) {\n-                    LvalueExtra::None\n-                } else {\n-                    match base_extra {\n-                        LvalueExtra::None => bug!(\"expected fat pointer\"),\n-                        LvalueExtra::DowncastVariant(..) =>\n-                            bug!(\"Rust doesn't support unsized fields in enum variants\"),\n-                        LvalueExtra::Vtable(_) |\n-                        LvalueExtra::Length(_) => {},\n-                    }\n-                    base_extra\n-                };\n+        Ok(Lvalue::Ptr { ptr, extra })\n+    }\n \n-                (ptr, extra)\n+    fn eval_lvalue_projection(\n+        &mut self,\n+        proj: &mir::LvalueProjection<'tcx>,\n+    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        use rustc::mir::ProjectionElem::*;\n+        let (ptr, extra) = match proj.elem {\n+            Field(field, field_ty) => {\n+                let base = self.eval_lvalue(&proj.base)?;\n+                let base_ty = self.lvalue_ty(&proj.base);\n+                return self.lvalue_field(base, field.index(), base_ty, field_ty);\n             }\n \n             Downcast(_, variant) => {"}]}