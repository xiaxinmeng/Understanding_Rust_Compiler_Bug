{"sha": "9096d31dcc292bad1281e0ab37e55d9a3aac5dc4", "node_id": "C_kwDOAAsO6NoAKDkwOTZkMzFkY2MyOTJiYWQxMjgxZTBhYjM3ZTU1ZDlhM2FhYzVkYzQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-19T22:23:41Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-27T18:22:45Z"}, "message": "Extract SsaLocals abstraction.", "tree": {"sha": "ae93dc027148852ab73a688db931d604e7c285b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae93dc027148852ab73a688db931d604e7c285b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4", "html_url": "https://github.com/rust-lang/rust/commit/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bec73b09fdc77d74972d25fefd111fbb9d20fba1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bec73b09fdc77d74972d25fefd111fbb9d20fba1", "html_url": "https://github.com/rust-lang/rust/commit/bec73b09fdc77d74972d25fefd111fbb9d20fba1"}], "stats": {"total": 415, "additions": 240, "deletions": 175}, "files": [{"sha": "58211bc795feedd45a615065d53c7294d901a6b8", "filename": "compiler/rustc_mir_transform/src/copy_prop.rs", "status": "modified", "additions": 20, "deletions": 175, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs?ref=9096d31dcc292bad1281e0ab37e55d9a3aac5dc4", "patch": "@@ -1,13 +1,10 @@\n-use either::Either;\n-use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::resolve_lifetime::Set1;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{ParamEnv, TyCtxt};\n-use rustc_mir_dataflow::impls::borrowed_locals;\n+use rustc_middle::ty::TyCtxt;\n \n+use crate::ssa::SsaLocals;\n use crate::MirPass;\n \n /// Unify locals that copy each other.\n@@ -38,123 +35,28 @@ fn propagate_ssa<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n     let ssa = SsaLocals::new(tcx, param_env, body);\n \n-    let (copy_classes, fully_moved) = compute_copy_classes(&ssa, body);\n-    debug!(?copy_classes);\n+    let fully_moved = fully_moved_locals(&ssa, body);\n+    debug!(?fully_moved);\n \n     let mut storage_to_remove = BitSet::new_empty(fully_moved.domain_size());\n-    for (local, &head) in copy_classes.iter_enumerated() {\n+    for (local, &head) in ssa.copy_classes().iter_enumerated() {\n         if local != head {\n             storage_to_remove.insert(head);\n             storage_to_remove.insert(local);\n         }\n     }\n \n-    let any_replacement = copy_classes.iter_enumerated().any(|(l, &h)| l != h);\n+    let any_replacement = ssa.copy_classes().iter_enumerated().any(|(l, &h)| l != h);\n \n-    Replacer { tcx, copy_classes, fully_moved, storage_to_remove }.visit_body_preserves_cfg(body);\n+    Replacer { tcx, copy_classes: &ssa.copy_classes(), fully_moved, storage_to_remove }\n+        .visit_body_preserves_cfg(body);\n \n     if any_replacement {\n         crate::simplify::remove_unused_definitions(body);\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum LocationExtended {\n-    Plain(Location),\n-    Arg,\n-}\n-\n-#[derive(Debug)]\n-struct SsaLocals {\n-    dominators: Dominators<BasicBlock>,\n-    /// Assignments to each local. This defines whether the local is SSA.\n-    assignments: IndexVec<Local, Set1<LocationExtended>>,\n-    /// We visit the body in reverse postorder, to ensure each local is assigned before it is used.\n-    /// We remember the order in which we saw the assignments to compute the SSA values in a single\n-    /// pass.\n-    assignment_order: Vec<Local>,\n-}\n-\n-impl SsaLocals {\n-    fn new<'tcx>(tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, body: &Body<'tcx>) -> SsaLocals {\n-        let assignment_order = Vec::new();\n-\n-        let assignments = IndexVec::from_elem(Set1::Empty, &body.local_decls);\n-        let dominators = body.basic_blocks.dominators();\n-        let mut this = SsaLocals { assignments, assignment_order, dominators };\n-\n-        let borrowed = borrowed_locals(body);\n-        for (local, decl) in body.local_decls.iter_enumerated() {\n-            if matches!(body.local_kind(local), LocalKind::Arg) {\n-                this.assignments[local] = Set1::One(LocationExtended::Arg);\n-            }\n-            if borrowed.contains(local) && !decl.ty.is_freeze(tcx, param_env) {\n-                this.assignments[local] = Set1::Many;\n-            }\n-        }\n-\n-        for (bb, data) in traversal::reverse_postorder(body) {\n-            this.visit_basic_block_data(bb, data);\n-        }\n-\n-        for var_debug_info in &body.var_debug_info {\n-            this.visit_var_debug_info(var_debug_info);\n-        }\n-\n-        debug!(?this.assignments);\n-\n-        this.assignment_order.retain(|&local| matches!(this.assignments[local], Set1::One(_)));\n-        debug!(?this.assignment_order);\n-\n-        this\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for SsaLocals {\n-    fn visit_local(&mut self, local: Local, ctxt: PlaceContext, loc: Location) {\n-        match ctxt {\n-            PlaceContext::MutatingUse(MutatingUseContext::Store) => {\n-                self.assignments[local].insert(LocationExtended::Plain(loc));\n-                self.assignment_order.push(local);\n-            }\n-            // Anything can happen with raw pointers, so remove them.\n-            PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf)\n-            | PlaceContext::MutatingUse(_) => self.assignments[local] = Set1::Many,\n-            // Immutable borrows are taken into account in `SsaLocals::new` by\n-            // removing non-freeze locals.\n-            PlaceContext::NonMutatingUse(_) => {\n-                let set = &mut self.assignments[local];\n-                let assign_dominates = match *set {\n-                    Set1::Empty | Set1::Many => false,\n-                    Set1::One(LocationExtended::Arg) => true,\n-                    Set1::One(LocationExtended::Plain(assign)) => {\n-                        assign.dominates(loc, &self.dominators)\n-                    }\n-                };\n-                // We are visiting a use that is not dominated by an assignment.\n-                // Either there is a cycle involved, or we are reading for uninitialized local.\n-                // Bail out.\n-                if !assign_dominates {\n-                    *set = Set1::Many;\n-                }\n-            }\n-            PlaceContext::NonUse(_) => {}\n-        }\n-    }\n-}\n-\n-/// Compute the equivalence classes for locals, based on copy statements.\n-///\n-/// The returned vector maps each local to the one it copies. In the following case:\n-///   _a = &mut _0\n-///   _b = move? _a\n-///   _c = move? _a\n-///   _d = move? _c\n-/// We return the mapping\n-///   _a => _a // not a copy so, represented by itself\n-///   _b => _a\n-///   _c => _a\n-///   _d => _a // transitively through _c\n+/// `SsaLocals` computed equivalence classes between locals considering copy/move assignments.\n ///\n /// This function also returns whether all the `move?` in the pattern are `move` and not copies.\n /// A local which is in the bitset can be replaced by `move _a`. Otherwise, it must be\n@@ -164,95 +66,38 @@ impl<'tcx> Visitor<'tcx> for SsaLocals {\n /// This means that replacing it by a copy of `_a` if ok, since this copy happens before `_c` is\n /// moved, and therefore that `_d` is moved.\n #[instrument(level = \"trace\", skip(ssa, body))]\n-fn compute_copy_classes(\n-    ssa: &SsaLocals,\n-    body: &Body<'_>,\n-) -> (IndexVec<Local, Local>, BitSet<Local>) {\n-    let mut copies = IndexVec::from_fn_n(|l| l, body.local_decls.len());\n-    let mut fully_moved = BitSet::new_filled(copies.len());\n-\n-    for &local in &ssa.assignment_order {\n-        debug!(?local);\n-\n-        if local == RETURN_PLACE {\n-            // `_0` is special, we cannot rename it.\n-            continue;\n-        }\n-\n-        // This is not SSA: mark that we don't know the value.\n-        debug!(assignments = ?ssa.assignments[local]);\n-        let Set1::One(LocationExtended::Plain(loc)) = ssa.assignments[local] else { continue };\n-\n-        // `loc` must point to a direct assignment to `local`.\n-        let Either::Left(stmt) = body.stmt_at(loc) else { bug!() };\n-        let Some((_target, rvalue)) = stmt.kind.as_assign() else { bug!() };\n-        assert_eq!(_target.as_local(), Some(local));\n+fn fully_moved_locals(ssa: &SsaLocals, body: &Body<'_>) -> BitSet<Local> {\n+    let mut fully_moved = BitSet::new_filled(body.local_decls.len());\n \n+    for (_, rvalue) in ssa.assignments(body) {\n         let (Rvalue::Use(Operand::Copy(place) | Operand::Move(place)) | Rvalue::CopyForDeref(place))\n             = rvalue\n         else { continue };\n \n         let Some(rhs) = place.as_local() else { continue };\n-        let Set1::One(_) = ssa.assignments[rhs] else { continue };\n-\n-        // We visit in `assignment_order`, ie. reverse post-order, so `rhs` has been\n-        // visited before `local`, and we just have to copy the representing local.\n-        copies[local] = copies[rhs];\n+        if !ssa.is_ssa(rhs) {\n+            continue;\n+        }\n \n         if let Rvalue::Use(Operand::Copy(_)) | Rvalue::CopyForDeref(_) = rvalue {\n             fully_moved.remove(rhs);\n         }\n     }\n \n-    debug!(?copies);\n+    ssa.meet_copy_equivalence(&mut fully_moved);\n \n-    // Invariant: `copies` must point to the head of an equivalence class.\n-    #[cfg(debug_assertions)]\n-    for &head in copies.iter() {\n-        assert_eq!(copies[head], head);\n-    }\n-\n-    meet_copy_equivalence(&copies, &mut fully_moved);\n-\n-    (copies, fully_moved)\n-}\n-\n-/// Make a property uniform on a copy equivalence class by removing elements.\n-fn meet_copy_equivalence(copies: &IndexVec<Local, Local>, property: &mut BitSet<Local>) {\n-    // Consolidate to have a local iff all its copies are.\n-    //\n-    // `copies` defines equivalence classes between locals. The `local`s that recursively\n-    // move/copy the same local all have the same `head`.\n-    for (local, &head) in copies.iter_enumerated() {\n-        // If any copy does not have `property`, then the head is not.\n-        if !property.contains(local) {\n-            property.remove(head);\n-        }\n-    }\n-    for (local, &head) in copies.iter_enumerated() {\n-        // If any copy does not have `property`, then the head doesn't either,\n-        // then no copy has `property`.\n-        if !property.contains(head) {\n-            property.remove(local);\n-        }\n-    }\n-\n-    // Verify that we correctly computed equivalence classes.\n-    #[cfg(debug_assertions)]\n-    for (local, &head) in copies.iter_enumerated() {\n-        assert_eq!(property.contains(local), property.contains(head));\n-    }\n+    fully_moved\n }\n \n /// Utility to help performing subtitution of `*pattern` by `target`.\n-struct Replacer<'tcx> {\n+struct Replacer<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fully_moved: BitSet<Local>,\n     storage_to_remove: BitSet<Local>,\n-    copy_classes: IndexVec<Local, Local>,\n+    copy_classes: &'a IndexVec<Local, Local>,\n }\n \n-impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n+impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }"}, {"sha": "8a7c14472ac2f074d342cde0b8c9721ab9e5ce74", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=9096d31dcc292bad1281e0ab37e55d9a3aac5dc4", "patch": "@@ -87,6 +87,7 @@ mod required_consts;\n mod reveal_all;\n mod separate_const_switch;\n mod shim;\n+mod ssa;\n // This pass is public to allow external drivers to perform MIR cleanup\n pub mod simplify;\n mod simplify_branches;"}, {"sha": "a5ae671be81f727b854c07d7227e4c68aa7fdaee", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9096d31dcc292bad1281e0ab37e55d9a3aac5dc4/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=9096d31dcc292bad1281e0ab37e55d9a3aac5dc4", "patch": "@@ -0,0 +1,219 @@\n+use either::Either;\n+use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::middle::resolve_lifetime::Set1;\n+use rustc_middle::mir::visit::*;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_mir_dataflow::impls::borrowed_locals;\n+\n+#[derive(Debug)]\n+pub struct SsaLocals {\n+    /// Assignments to each local. This defines whether the local is SSA.\n+    assignments: IndexVec<Local, Set1<LocationExtended>>,\n+    /// We visit the body in reverse postorder, to ensure each local is assigned before it is used.\n+    /// We remember the order in which we saw the assignments to compute the SSA values in a single\n+    /// pass.\n+    assignment_order: Vec<Local>,\n+    /// Copy equivalence classes between locals. See `copy_classes` for documentation.\n+    copy_classes: IndexVec<Local, Local>,\n+}\n+\n+impl SsaLocals {\n+    pub fn new<'tcx>(tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, body: &Body<'tcx>) -> SsaLocals {\n+        let assignment_order = Vec::new();\n+\n+        let assignments = IndexVec::from_elem(Set1::Empty, &body.local_decls);\n+        let dominators = body.basic_blocks.dominators();\n+        let mut visitor = SsaVisitor { assignments, assignment_order, dominators };\n+\n+        let borrowed = borrowed_locals(body);\n+        for (local, decl) in body.local_decls.iter_enumerated() {\n+            if matches!(body.local_kind(local), LocalKind::Arg) {\n+                visitor.assignments[local] = Set1::One(LocationExtended::Arg);\n+            }\n+            if borrowed.contains(local) && !decl.ty.is_freeze(tcx, param_env) {\n+                visitor.assignments[local] = Set1::Many;\n+            }\n+        }\n+\n+        for (bb, data) in traversal::reverse_postorder(body) {\n+            visitor.visit_basic_block_data(bb, data);\n+        }\n+\n+        for var_debug_info in &body.var_debug_info {\n+            visitor.visit_var_debug_info(var_debug_info);\n+        }\n+\n+        debug!(?visitor.assignments);\n+\n+        visitor\n+            .assignment_order\n+            .retain(|&local| matches!(visitor.assignments[local], Set1::One(_)));\n+        debug!(?visitor.assignment_order);\n+\n+        let copy_classes = compute_copy_classes(&visitor, body);\n+\n+        SsaLocals {\n+            assignments: visitor.assignments,\n+            assignment_order: visitor.assignment_order,\n+            copy_classes,\n+        }\n+    }\n+\n+    pub fn is_ssa(&self, local: Local) -> bool {\n+        matches!(self.assignments[local], Set1::One(_))\n+    }\n+\n+    pub fn assignments<'a, 'tcx>(\n+        &'a self,\n+        body: &'a Body<'tcx>,\n+    ) -> impl Iterator<Item = (Local, &'a Rvalue<'tcx>)> + 'a {\n+        self.assignment_order.iter().filter_map(|&local| {\n+            if let Set1::One(LocationExtended::Plain(loc)) = self.assignments[local] {\n+                // `loc` must point to a direct assignment to `local`.\n+                let Either::Left(stmt) = body.stmt_at(loc) else { bug!() };\n+                let Some((target, rvalue)) = stmt.kind.as_assign() else { bug!() };\n+                assert_eq!(target.as_local(), Some(local));\n+                Some((local, rvalue))\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// Compute the equivalence classes for locals, based on copy statements.\n+    ///\n+    /// The returned vector maps each local to the one it copies. In the following case:\n+    ///   _a = &mut _0\n+    ///   _b = move? _a\n+    ///   _c = move? _a\n+    ///   _d = move? _c\n+    /// We return the mapping\n+    ///   _a => _a // not a copy so, represented by itself\n+    ///   _b => _a\n+    ///   _c => _a\n+    ///   _d => _a // transitively through _c\n+    ///\n+    /// Exception: we do not see through the return place, as it cannot be substituted.\n+    pub fn copy_classes(&self) -> &IndexVec<Local, Local> {\n+        &self.copy_classes\n+    }\n+\n+    /// Make a property uniform on a copy equivalence class by removing elements.\n+    pub fn meet_copy_equivalence(&self, property: &mut BitSet<Local>) {\n+        // Consolidate to have a local iff all its copies are.\n+        //\n+        // `copy_classes` defines equivalence classes between locals. The `local`s that recursively\n+        // move/copy the same local all have the same `head`.\n+        for (local, &head) in self.copy_classes.iter_enumerated() {\n+            // If any copy does not have `property`, then the head is not.\n+            if !property.contains(local) {\n+                property.remove(head);\n+            }\n+        }\n+        for (local, &head) in self.copy_classes.iter_enumerated() {\n+            // If any copy does not have `property`, then the head doesn't either,\n+            // then no copy has `property`.\n+            if !property.contains(head) {\n+                property.remove(local);\n+            }\n+        }\n+\n+        // Verify that we correctly computed equivalence classes.\n+        #[cfg(debug_assertions)]\n+        for (local, &head) in self.copy_classes.iter_enumerated() {\n+            assert_eq!(property.contains(local), property.contains(head));\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum LocationExtended {\n+    Plain(Location),\n+    Arg,\n+}\n+\n+struct SsaVisitor {\n+    dominators: Dominators<BasicBlock>,\n+    assignments: IndexVec<Local, Set1<LocationExtended>>,\n+    assignment_order: Vec<Local>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for SsaVisitor {\n+    fn visit_local(&mut self, local: Local, ctxt: PlaceContext, loc: Location) {\n+        match ctxt {\n+            PlaceContext::MutatingUse(MutatingUseContext::Store) => {\n+                self.assignments[local].insert(LocationExtended::Plain(loc));\n+                self.assignment_order.push(local);\n+            }\n+            // Anything can happen with raw pointers, so remove them.\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf)\n+            | PlaceContext::MutatingUse(_) => self.assignments[local] = Set1::Many,\n+            // Immutable borrows are taken into account in `SsaLocals::new` by\n+            // removing non-freeze locals.\n+            PlaceContext::NonMutatingUse(_) => {\n+                let set = &mut self.assignments[local];\n+                let assign_dominates = match *set {\n+                    Set1::Empty | Set1::Many => false,\n+                    Set1::One(LocationExtended::Arg) => true,\n+                    Set1::One(LocationExtended::Plain(assign)) => {\n+                        assign.dominates(loc, &self.dominators)\n+                    }\n+                };\n+                // We are visiting a use that is not dominated by an assignment.\n+                // Either there is a cycle involved, or we are reading for uninitialized local.\n+                // Bail out.\n+                if !assign_dominates {\n+                    *set = Set1::Many;\n+                }\n+            }\n+            PlaceContext::NonUse(_) => {}\n+        }\n+    }\n+}\n+\n+#[instrument(level = \"trace\", skip(ssa, body))]\n+fn compute_copy_classes(ssa: &SsaVisitor, body: &Body<'_>) -> IndexVec<Local, Local> {\n+    let mut copies = IndexVec::from_fn_n(|l| l, body.local_decls.len());\n+\n+    for &local in &ssa.assignment_order {\n+        debug!(?local);\n+\n+        if local == RETURN_PLACE {\n+            // `_0` is special, we cannot rename it.\n+            continue;\n+        }\n+\n+        // This is not SSA: mark that we don't know the value.\n+        debug!(assignments = ?ssa.assignments[local]);\n+        let Set1::One(LocationExtended::Plain(loc)) = ssa.assignments[local] else { continue };\n+\n+        // `loc` must point to a direct assignment to `local`.\n+        let Either::Left(stmt) = body.stmt_at(loc) else { bug!() };\n+        let Some((_target, rvalue)) = stmt.kind.as_assign() else { bug!() };\n+        assert_eq!(_target.as_local(), Some(local));\n+\n+        let (Rvalue::Use(Operand::Copy(place) | Operand::Move(place)) | Rvalue::CopyForDeref(place))\n+            = rvalue\n+        else { continue };\n+\n+        let Some(rhs) = place.as_local() else { continue };\n+        let Set1::One(_) = ssa.assignments[rhs] else { continue };\n+\n+        // We visit in `assignment_order`, ie. reverse post-order, so `rhs` has been\n+        // visited before `local`, and we just have to copy the representing local.\n+        copies[local] = copies[rhs];\n+    }\n+\n+    debug!(?copies);\n+\n+    // Invariant: `copies` must point to the head of an equivalence class.\n+    #[cfg(debug_assertions)]\n+    for &head in copies.iter() {\n+        assert_eq!(copies[head], head);\n+    }\n+\n+    copies\n+}"}]}