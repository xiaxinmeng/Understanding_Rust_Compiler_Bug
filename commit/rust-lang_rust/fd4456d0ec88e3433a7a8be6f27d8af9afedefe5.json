{"sha": "fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNDQ1NmQwZWM4OGUzNDMzYTdhOGJlNmYyN2Q4YWY5YWZlZGVmZTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-06T14:33:27Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-06T14:36:10Z"}, "message": "flatten module structure", "tree": {"sha": "37f1225b085e22756cbfd65875595c60205cc93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37f1225b085e22756cbfd65875595c60205cc93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "html_url": "https://github.com/rust-lang/rust/commit/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a505189a8f7ed274893a45aed0d0249083d1277", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a505189a8f7ed274893a45aed0d0249083d1277", "html_url": "https://github.com/rust-lang/rust/commit/5a505189a8f7ed274893a45aed0d0249083d1277"}], "stats": {"total": 867, "additions": 431, "deletions": 436}, "files": [{"sha": "09b532f7464757672965107e0694ef2c07b878af", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -1,7 +1,8 @@\n+use relative_path::RelativePathBuf;\n use ra_db::{CrateId, Cancelable, FileId};\n use ra_syntax::{ast, SyntaxNode};\n \n-use crate::{Name, db::HirDatabase, DefId, Path, PerNs, module::{Problem, ModuleScope}};\n+use crate::{Name, db::HirDatabase, DefId, Path, PerNs, nameres::ModuleScope};\n \n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the\n@@ -39,6 +40,17 @@ pub enum ModuleSource {\n     Module(ast::ModuleNode),\n }\n \n+#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Problem {\n+    UnresolvedModule {\n+        candidate: RelativePathBuf,\n+    },\n+    NotDirOwner {\n+        move_to: RelativePathBuf,\n+        candidate: RelativePathBuf,\n+    },\n+}\n+\n impl Module {\n     /// Name of this module.\n     pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {"}, {"sha": "d602a439df6ba5213b2c3d6d89c5841175d17d29", "filename": "crates/ra_hir/src/code_model_impl.rs", "status": "modified", "additions": 2, "deletions": 194, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -1,194 +1,2 @@\n-use ra_db::{CrateId, Cancelable, SourceRootId, FileId};\n-use ra_syntax::{ast, SyntaxNode, AstNode};\n-\n-use crate::{\n-    HirFileId, Crate, CrateDependency, AsName, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def, ModuleId,\n-    module::{ModuleScope, Problem},\n-    db::HirDatabase,\n-};\n-\n-use crate::code_model_api::{Module, ModuleSource};\n-\n-impl Crate {\n-    pub(crate) fn new(crate_id: CrateId) -> Crate {\n-        Crate { crate_id }\n-    }\n-    pub(crate) fn dependencies_impl(&self, db: &impl HirDatabase) -> Vec<CrateDependency> {\n-        let crate_graph = db.crate_graph();\n-        crate_graph\n-            .dependencies(self.crate_id)\n-            .map(|dep| {\n-                let krate = Crate::new(dep.crate_id());\n-                let name = dep.as_name();\n-                CrateDependency { krate, name }\n-            })\n-            .collect()\n-    }\n-    pub(crate) fn root_module_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n-        let crate_graph = db.crate_graph();\n-        let file_id = crate_graph.crate_root(self.crate_id);\n-        let source_root_id = db.file_source_root(file_id);\n-        let file_id = HirFileId::from(file_id);\n-        let module_tree = db.module_tree(source_root_id)?;\n-        // FIXME: teach module tree about crate roots instead of guessing\n-        let (module_id, _) = ctry!(module_tree\n-            .modules_with_sources()\n-            .find(|(_, src)| src.file_id() == file_id));\n-\n-        let def_loc = DefLoc {\n-            kind: DefKind::Module,\n-            source_root_id,\n-            module_id,\n-            source_item_id: module_id.source(&module_tree).0,\n-        };\n-        let def_id = def_loc.id(db);\n-\n-        let module = Module::new(def_id);\n-        Ok(Some(module))\n-    }\n-}\n-\n-impl Module {\n-    pub(crate) fn new(def_id: DefId) -> Self {\n-        crate::code_model_api::Module { def_id }\n-    }\n-    pub(crate) fn from_module_id(\n-        db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Cancelable<Self> {\n-        let module_tree = db.module_tree(source_root_id)?;\n-        let def_loc = DefLoc {\n-            kind: DefKind::Module,\n-            source_root_id,\n-            module_id,\n-            source_item_id: module_id.source(&module_tree).0,\n-        };\n-        let def_id = def_loc.id(db);\n-        let module = Module::new(def_id);\n-        Ok(module)\n-    }\n-\n-    pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id)?;\n-        let link = ctry!(loc.module_id.parent_link(&module_tree));\n-        Ok(Some(link.name(&module_tree).clone()))\n-    }\n-\n-    pub fn defenition_source_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-    ) -> Cancelable<(FileId, ModuleSource)> {\n-        let loc = self.def_id.loc(db);\n-        let file_id = loc.source_item_id.file_id.as_original_file();\n-        let syntax_node = db.file_item(loc.source_item_id);\n-        let syntax_node = syntax_node.borrowed();\n-        let module_source = if let Some(source_file) = ast::SourceFile::cast(syntax_node) {\n-            ModuleSource::SourceFile(source_file.owned())\n-        } else {\n-            let module = ast::Module::cast(syntax_node).unwrap();\n-            ModuleSource::Module(module.owned())\n-        };\n-        Ok((file_id, module_source))\n-    }\n-\n-    pub fn declaration_source_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id)?;\n-        let link = ctry!(loc.module_id.parent_link(&module_tree));\n-        let file_id = link\n-            .owner(&module_tree)\n-            .source(&module_tree)\n-            .file_id()\n-            .as_original_file();\n-        let src = link.bind_source(&module_tree, db);\n-        Ok(Some((file_id, src)))\n-    }\n-\n-    pub(crate) fn krate_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n-        let root = self.crate_root(db)?;\n-        let loc = root.def_id.loc(db);\n-        let file_id = loc.source_item_id.file_id.as_original_file();\n-\n-        let crate_graph = db.crate_graph();\n-        let crate_id = ctry!(crate_graph.crate_id_for_crate_root(file_id));\n-        Ok(Some(Crate::new(crate_id)))\n-    }\n-\n-    pub(crate) fn crate_root_impl(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id)?;\n-        let module_id = loc.module_id.crate_root(&module_tree);\n-        Module::from_module_id(db, loc.source_root_id, module_id)\n-    }\n-    /// Finds a child module with the specified name.\n-    pub fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id)?;\n-        let child_id = ctry!(loc.module_id.child(&module_tree, name));\n-        Module::from_module_id(db, loc.source_root_id, child_id).map(Some)\n-    }\n-    pub fn parent_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id)?;\n-        let parent_id = ctry!(loc.module_id.parent(&module_tree));\n-        Module::from_module_id(db, loc.source_root_id, parent_id).map(Some)\n-    }\n-    /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope_impl(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n-        let loc = self.def_id.loc(db);\n-        let item_map = db.item_map(loc.source_root_id)?;\n-        let res = item_map.per_module[&loc.module_id].clone();\n-        Ok(res)\n-    }\n-    pub fn resolve_path_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-        path: &Path,\n-    ) -> Cancelable<PerNs<DefId>> {\n-        let mut curr_per_ns = PerNs::types(\n-            match path.kind {\n-                PathKind::Crate => self.crate_root(db)?,\n-                PathKind::Self_ | PathKind::Plain => self.clone(),\n-                PathKind::Super => {\n-                    if let Some(p) = self.parent(db)? {\n-                        p\n-                    } else {\n-                        return Ok(PerNs::none());\n-                    }\n-                }\n-            }\n-            .def_id,\n-        );\n-\n-        let segments = &path.segments;\n-        for name in segments.iter() {\n-            let curr = if let Some(r) = curr_per_ns.as_ref().take_types() {\n-                r\n-            } else {\n-                return Ok(PerNs::none());\n-            };\n-            let module = match curr.resolve(db)? {\n-                Def::Module(it) => it,\n-                // TODO here would be the place to handle enum variants...\n-                _ => return Ok(PerNs::none()),\n-            };\n-            let scope = module.scope(db)?;\n-            curr_per_ns = if let Some(r) = scope.get(&name) {\n-                r.def_id\n-            } else {\n-                return Ok(PerNs::none());\n-            };\n-        }\n-        Ok(curr_per_ns)\n-    }\n-    pub fn problems_impl(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id)?;\n-        Ok(loc.module_id.problems(&module_tree, db))\n-    }\n-}\n+mod krate; // `crate` is invalid ident :(\n+pub(crate) mod module;"}, {"sha": "591a81597da6715fa25916c158d3a014ebb7f98d", "filename": "crates/ra_hir/src/code_model_impl/krate.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -0,0 +1,45 @@\n+use ra_db::{CrateId, Cancelable};\n+\n+use crate::{\n+    HirFileId, Crate, CrateDependency, AsName, DefLoc, DefKind, Module,\n+    db::HirDatabase,\n+};\n+\n+impl Crate {\n+    pub(crate) fn new(crate_id: CrateId) -> Crate {\n+        Crate { crate_id }\n+    }\n+    pub(crate) fn dependencies_impl(&self, db: &impl HirDatabase) -> Vec<CrateDependency> {\n+        let crate_graph = db.crate_graph();\n+        crate_graph\n+            .dependencies(self.crate_id)\n+            .map(|dep| {\n+                let krate = Crate::new(dep.crate_id());\n+                let name = dep.as_name();\n+                CrateDependency { krate, name }\n+            })\n+            .collect()\n+    }\n+    pub(crate) fn root_module_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n+        let crate_graph = db.crate_graph();\n+        let file_id = crate_graph.crate_root(self.crate_id);\n+        let source_root_id = db.file_source_root(file_id);\n+        let file_id = HirFileId::from(file_id);\n+        let module_tree = db.module_tree(source_root_id)?;\n+        // FIXME: teach module tree about crate roots instead of guessing\n+        let (module_id, _) = ctry!(module_tree\n+            .modules_with_sources()\n+            .find(|(_, src)| src.file_id() == file_id));\n+\n+        let def_loc = DefLoc {\n+            kind: DefKind::Module,\n+            source_root_id,\n+            module_id,\n+            source_item_id: module_id.source(&module_tree).0,\n+        };\n+        let def_id = def_loc.id(db);\n+\n+        let module = Module::new(def_id);\n+        Ok(Some(module))\n+    }\n+}"}, {"sha": "02078f188dcc71d5542aa8e3976df757bd8da8a1", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -0,0 +1,154 @@\n+use ra_db::{Cancelable, SourceRootId, FileId};\n+use ra_syntax::{ast, SyntaxNode, AstNode};\n+\n+use crate::{\n+    Module, ModuleSource, Problem,\n+    Crate, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def, ModuleId,\n+    nameres::ModuleScope,\n+    db::HirDatabase,\n+};\n+\n+impl Module {\n+    pub(crate) fn new(def_id: DefId) -> Self {\n+        crate::code_model_api::Module { def_id }\n+    }\n+    pub(crate) fn from_module_id(\n+        db: &impl HirDatabase,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> Cancelable<Self> {\n+        let module_tree = db.module_tree(source_root_id)?;\n+        let def_loc = DefLoc {\n+            kind: DefKind::Module,\n+            source_root_id,\n+            module_id,\n+            source_item_id: module_id.source(&module_tree).0,\n+        };\n+        let def_id = def_loc.id(db);\n+        let module = Module::new(def_id);\n+        Ok(module)\n+    }\n+\n+    pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let link = ctry!(loc.module_id.parent_link(&module_tree));\n+        Ok(Some(link.name(&module_tree).clone()))\n+    }\n+\n+    pub fn defenition_source_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<(FileId, ModuleSource)> {\n+        let loc = self.def_id.loc(db);\n+        let file_id = loc.source_item_id.file_id.as_original_file();\n+        let syntax_node = db.file_item(loc.source_item_id);\n+        let syntax_node = syntax_node.borrowed();\n+        let module_source = if let Some(source_file) = ast::SourceFile::cast(syntax_node) {\n+            ModuleSource::SourceFile(source_file.owned())\n+        } else {\n+            let module = ast::Module::cast(syntax_node).unwrap();\n+            ModuleSource::Module(module.owned())\n+        };\n+        Ok((file_id, module_source))\n+    }\n+\n+    pub fn declaration_source_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let link = ctry!(loc.module_id.parent_link(&module_tree));\n+        let file_id = link\n+            .owner(&module_tree)\n+            .source(&module_tree)\n+            .file_id()\n+            .as_original_file();\n+        let src = link.bind_source(&module_tree, db);\n+        Ok(Some((file_id, src)))\n+    }\n+\n+    pub(crate) fn krate_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n+        let root = self.crate_root(db)?;\n+        let loc = root.def_id.loc(db);\n+        let file_id = loc.source_item_id.file_id.as_original_file();\n+\n+        let crate_graph = db.crate_graph();\n+        let crate_id = ctry!(crate_graph.crate_id_for_crate_root(file_id));\n+        Ok(Some(Crate::new(crate_id)))\n+    }\n+\n+    pub(crate) fn crate_root_impl(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let module_id = loc.module_id.crate_root(&module_tree);\n+        Module::from_module_id(db, loc.source_root_id, module_id)\n+    }\n+    /// Finds a child module with the specified name.\n+    pub fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let child_id = ctry!(loc.module_id.child(&module_tree, name));\n+        Module::from_module_id(db, loc.source_root_id, child_id).map(Some)\n+    }\n+    pub fn parent_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let parent_id = ctry!(loc.module_id.parent(&module_tree));\n+        Module::from_module_id(db, loc.source_root_id, parent_id).map(Some)\n+    }\n+    /// Returns a `ModuleScope`: a set of items, visible in this module.\n+    pub fn scope_impl(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+        let loc = self.def_id.loc(db);\n+        let item_map = db.item_map(loc.source_root_id)?;\n+        let res = item_map.per_module[&loc.module_id].clone();\n+        Ok(res)\n+    }\n+    pub fn resolve_path_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: &Path,\n+    ) -> Cancelable<PerNs<DefId>> {\n+        let mut curr_per_ns = PerNs::types(\n+            match path.kind {\n+                PathKind::Crate => self.crate_root(db)?,\n+                PathKind::Self_ | PathKind::Plain => self.clone(),\n+                PathKind::Super => {\n+                    if let Some(p) = self.parent(db)? {\n+                        p\n+                    } else {\n+                        return Ok(PerNs::none());\n+                    }\n+                }\n+            }\n+            .def_id,\n+        );\n+\n+        let segments = &path.segments;\n+        for name in segments.iter() {\n+            let curr = if let Some(r) = curr_per_ns.as_ref().take_types() {\n+                r\n+            } else {\n+                return Ok(PerNs::none());\n+            };\n+            let module = match curr.resolve(db)? {\n+                Def::Module(it) => it,\n+                // TODO here would be the place to handle enum variants...\n+                _ => return Ok(PerNs::none()),\n+            };\n+            let scope = module.scope(db)?;\n+            curr_per_ns = if let Some(r) = scope.get(&name) {\n+                r.def_id\n+            } else {\n+                return Ok(PerNs::none());\n+            };\n+        }\n+        Ok(curr_per_ns)\n+    }\n+    pub fn problems_impl(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        Ok(loc.module_id.problems(&module_tree, db))\n+    }\n+}"}, {"sha": "2702961ba751507bfebf9f4c874e9b59e8f86f57", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -9,8 +9,8 @@ use crate::{\n     query_definitions,\n     FnSignature, FnScopes,\n     macros::MacroExpansion,\n-    module::{ModuleId, ModuleTree, ModuleSource,\n-    nameres::{ItemMap, InputModuleItems}},\n+    module_tree::{ModuleId, ModuleTree, ModuleSource},\n+    nameres::{ItemMap, InputModuleItems},\n     ty::{InferenceResult, Ty},\n     adt::{StructData, EnumData},\n     impl_block::ModuleImplBlocks,\n@@ -71,7 +71,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::file_item;\n     }\n \n-    fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::module::imp::Submodule>>> {\n+    fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::module_tree::Submodule>>> {\n         type SubmodulesQuery;\n         use fn query_definitions::submodules;\n     }\n@@ -86,7 +86,7 @@ pub trait HirDatabase: SyntaxDatabase\n     }\n     fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n         type ModuleTreeQuery;\n-        use fn crate::module::imp::module_tree;\n+        use fn crate::module_tree::ModuleTree::module_tree_query;\n     }\n \n     fn impls_in_module(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleImplBlocks>> {"}, {"sha": "7ce8d17e66420d0595d48ba349fa6769034a0c22", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     Function,\n     db::HirDatabase,\n     type_ref::TypeRef,\n-    module::ModuleId,\n+    module_tree::ModuleId,\n };\n \n use crate::code_model_api::{Module, ModuleSource};"}, {"sha": "7e74f2eaf818e57c9a176d4377a8ebc7e9175dda", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -24,22 +24,22 @@ pub mod source_binder;\n mod ids;\n mod macros;\n mod name;\n-mod module;\n+mod module_tree;\n+mod nameres;\n mod function;\n mod adt;\n mod type_ref;\n mod ty;\n mod impl_block;\n mod expr;\n \n-pub mod code_model_api;\n+mod code_model_api;\n mod code_model_impl;\n \n use crate::{\n     db::HirDatabase,\n     name::{AsName, KnownName},\n     ids::{DefKind, SourceItemId, SourceFileItemId, SourceFileItems},\n-    code_model_api::{Crate, CrateDependency}\n };\n \n pub use self::{\n@@ -56,7 +56,10 @@ pub use self::{\n \n pub use self::function::FnSignatureInfo;\n \n-pub use self::code_model_api::Module;\n+pub use self::code_model_api::{\n+    Crate, CrateDependency,\n+    Module, ModuleSource, Problem,\n+};\n \n pub enum Def {\n     Module(Module),"}, {"sha": "3849026dbdd7a745ccee4a1a840c019ec6d156b3", "filename": "crates/ra_hir/src/module/imp.rs", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/5a505189a8f7ed274893a45aed0d0249083d1277/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a505189a8f7ed274893a45aed0d0249083d1277/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=5a505189a8f7ed274893a45aed0d0249083d1277", "patch": "@@ -1,190 +0,0 @@\n-use std::sync::Arc;\n-\n-use ra_syntax::ast::{self, NameOwner};\n-use relative_path::RelativePathBuf;\n-use rustc_hash::{FxHashMap, FxHashSet};\n-use arrayvec::ArrayVec;\n-use ra_db::{SourceRoot, SourceRootId, Cancelable, FileId};\n-\n-use crate::{\n-    HirDatabase, Name, AsName,\n-};\n-\n-use super::{\n-    LinkData, LinkId, ModuleData, ModuleId, ModuleSource,\n-    ModuleTree, Problem,\n-};\n-\n-#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub enum Submodule {\n-    Declaration(Name),\n-    Definition(Name, ModuleSource),\n-}\n-\n-impl Submodule {\n-    fn name(&self) -> &Name {\n-        match self {\n-            Submodule::Declaration(name) => name,\n-            Submodule::Definition(name, _) => name,\n-        }\n-    }\n-}\n-\n-pub(crate) fn modules<'a>(\n-    root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n-    root.items()\n-        .filter_map(|item| match item {\n-            ast::ModuleItem::Module(m) => Some(m),\n-            _ => None,\n-        })\n-        .filter_map(|module| {\n-            let name = module.name()?.as_name();\n-            Some((name, module))\n-        })\n-}\n-\n-pub(crate) fn module_tree(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<Arc<ModuleTree>> {\n-    db.check_canceled()?;\n-    let res = create_module_tree(db, source_root)?;\n-    Ok(Arc::new(res))\n-}\n-\n-fn create_module_tree<'a>(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<ModuleTree> {\n-    let mut tree = ModuleTree::default();\n-\n-    let mut roots = FxHashMap::default();\n-    let mut visited = FxHashSet::default();\n-\n-    let source_root = db.source_root(source_root);\n-    for &file_id in source_root.files.values() {\n-        let source = ModuleSource::new_file(file_id.into());\n-        if visited.contains(&source) {\n-            continue; // TODO: use explicit crate_roots here\n-        }\n-        assert!(!roots.contains_key(&file_id));\n-        let module_id = build_subtree(\n-            db,\n-            &source_root,\n-            &mut tree,\n-            &mut visited,\n-            &mut roots,\n-            None,\n-            source,\n-        )?;\n-        roots.insert(file_id, module_id);\n-    }\n-    Ok(tree)\n-}\n-\n-fn build_subtree(\n-    db: &impl HirDatabase,\n-    source_root: &SourceRoot,\n-    tree: &mut ModuleTree,\n-    visited: &mut FxHashSet<ModuleSource>,\n-    roots: &mut FxHashMap<FileId, ModuleId>,\n-    parent: Option<LinkId>,\n-    source: ModuleSource,\n-) -> Cancelable<ModuleId> {\n-    visited.insert(source);\n-    let id = tree.push_mod(ModuleData {\n-        source,\n-        parent,\n-        children: Vec::new(),\n-    });\n-    for sub in db.submodules(source)?.iter() {\n-        let link = tree.push_link(LinkData {\n-            name: sub.name().clone(),\n-            owner: id,\n-            points_to: Vec::new(),\n-            problem: None,\n-        });\n-\n-        let (points_to, problem) = match sub {\n-            Submodule::Declaration(name) => {\n-                let (points_to, problem) = resolve_submodule(db, source, &name);\n-                let points_to = points_to\n-                    .into_iter()\n-                    .map(|file_id| match roots.remove(&file_id) {\n-                        Some(module_id) => {\n-                            tree.mods[module_id].parent = Some(link);\n-                            Ok(module_id)\n-                        }\n-                        None => build_subtree(\n-                            db,\n-                            source_root,\n-                            tree,\n-                            visited,\n-                            roots,\n-                            Some(link),\n-                            ModuleSource::new_file(file_id.into()),\n-                        ),\n-                    })\n-                    .collect::<Cancelable<Vec<_>>>()?;\n-                (points_to, problem)\n-            }\n-            Submodule::Definition(_name, submodule_source) => {\n-                let points_to = build_subtree(\n-                    db,\n-                    source_root,\n-                    tree,\n-                    visited,\n-                    roots,\n-                    Some(link),\n-                    *submodule_source,\n-                )?;\n-                (vec![points_to], None)\n-            }\n-        };\n-\n-        tree.links[link].points_to = points_to;\n-        tree.links[link].problem = problem;\n-    }\n-    Ok(id)\n-}\n-\n-fn resolve_submodule(\n-    db: &impl HirDatabase,\n-    source: ModuleSource,\n-    name: &Name,\n-) -> (Vec<FileId>, Option<Problem>) {\n-    // FIXME: handle submodules of inline modules properly\n-    let file_id = source.file_id().original_file(db);\n-    let source_root_id = db.file_source_root(file_id);\n-    let path = db.file_relative_path(file_id);\n-    let root = RelativePathBuf::default();\n-    let dir_path = path.parent().unwrap_or(&root);\n-    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n-    let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n-\n-    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n-    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n-    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n-    let mut candidates = ArrayVec::<[_; 2]>::new();\n-    if is_dir_owner {\n-        candidates.push(file_mod.clone());\n-        candidates.push(dir_mod);\n-    } else {\n-        candidates.push(file_dir_mod.clone());\n-    };\n-    let sr = db.source_root(source_root_id);\n-    let points_to = candidates\n-        .into_iter()\n-        .filter_map(|path| sr.files.get(&path))\n-        .map(|&it| it)\n-        .collect::<Vec<_>>();\n-    let problem = if points_to.is_empty() {\n-        Some(Problem::UnresolvedModule {\n-            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n-        })\n-    } else {\n-        None\n-    };\n-    (points_to, problem)\n-}"}, {"sha": "cd82f25dbe25a51412f54af9c3326ceaebd0252e", "filename": "crates/ra_hir/src/module_tree.rs", "status": "renamed", "additions": 199, "deletions": 33, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -1,17 +1,32 @@\n-pub(super) mod imp;\n-pub(super) mod nameres;\n+use std::sync::Arc;\n \n+use rustc_hash::{FxHashMap, FxHashSet};\n+use arrayvec::ArrayVec;\n+use relative_path::RelativePathBuf;\n+use ra_db::{FileId, SourceRootId, Cancelable, SourceRoot};\n use ra_syntax::{\n     algo::generate,\n     ast::{self, AstNode, NameOwner},\n     SyntaxNode,\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n-use relative_path::RelativePathBuf;\n \n-use crate::{Name, HirDatabase, SourceItemId, SourceFileItemId, HirFileId};\n+use crate::{Name, AsName, HirDatabase, SourceItemId, SourceFileItemId, HirFileId, Problem};\n \n-pub use self::nameres::{ModuleScope, Resolution, Namespace, PerNs};\n+#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n+pub enum Submodule {\n+    Declaration(Name),\n+    Definition(Name, ModuleSource),\n+}\n+\n+impl Submodule {\n+    fn name(&self) -> &Name {\n+        match self {\n+            Submodule::Declaration(name) => name,\n+            Submodule::Definition(name, _) => name,\n+        }\n+    }\n+}\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ModuleId(RawId);\n@@ -34,7 +49,31 @@ pub struct ModuleTree {\n     links: Arena<LinkId, LinkData>,\n }\n \n+#[derive(Debug, PartialEq, Eq, Hash)]\n+pub struct ModuleData {\n+    source: ModuleSource,\n+    parent: Option<LinkId>,\n+    children: Vec<LinkId>,\n+}\n+\n+#[derive(Hash, Debug, PartialEq, Eq)]\n+struct LinkData {\n+    owner: ModuleId,\n+    name: Name,\n+    points_to: Vec<ModuleId>,\n+    problem: Option<Problem>,\n+}\n+\n impl ModuleTree {\n+    pub(crate) fn module_tree_query(\n+        db: &impl HirDatabase,\n+        source_root: SourceRootId,\n+    ) -> Cancelable<Arc<ModuleTree>> {\n+        db.check_canceled()?;\n+        let res = create_module_tree(db, source_root)?;\n+        Ok(Arc::new(res))\n+    }\n+\n     pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n         self.mods.iter().map(|(id, _)| id)\n     }\n@@ -58,17 +97,6 @@ pub(crate) enum ModuleSourceNode {\n     Module(ast::ModuleNode),\n }\n \n-#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Problem {\n-    UnresolvedModule {\n-        candidate: RelativePathBuf,\n-    },\n-    NotDirOwner {\n-        move_to: RelativePathBuf,\n-        candidate: RelativePathBuf,\n-    },\n-}\n-\n impl ModuleId {\n     pub(crate) fn source(self, tree: &ModuleTree) -> ModuleSource {\n         tree.mods[self].source\n@@ -93,7 +121,10 @@ impl ModuleId {\n             .find(|it| it.name == *name)?;\n         Some(*link.points_to.first()?)\n     }\n-    fn children<'a>(self, tree: &'a ModuleTree) -> impl Iterator<Item = (Name, ModuleId)> + 'a {\n+    pub(crate) fn children<'a>(\n+        self,\n+        tree: &'a ModuleTree,\n+    ) -> impl Iterator<Item = (Name, ModuleId)> + 'a {\n         tree.mods[self].children.iter().filter_map(move |&it| {\n             let link = &tree.links[it];\n             let module = *link.points_to.first()?;\n@@ -133,7 +164,7 @@ impl LinkId {\n         let owner = self.owner(tree);\n         match owner.source(tree).resolve(db) {\n             ModuleSourceNode::SourceFile(root) => {\n-                let ast = imp::modules(root.borrowed())\n+                let ast = modules(root.borrowed())\n                     .find(|(name, _)| name == &tree.links[self].name)\n                     .unwrap()\n                     .1;\n@@ -144,13 +175,6 @@ impl LinkId {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Hash)]\n-pub struct ModuleData {\n-    source: ModuleSource,\n-    parent: Option<LinkId>,\n-    children: Vec<LinkId>,\n-}\n-\n impl ModuleSource {\n     // precondition: item_id **must** point to module\n     fn new(file_id: HirFileId, item_id: Option<SourceFileItemId>) -> ModuleSource {\n@@ -188,14 +212,6 @@ impl ModuleSource {\n     }\n }\n \n-#[derive(Hash, Debug, PartialEq, Eq)]\n-struct LinkData {\n-    owner: ModuleId,\n-    name: Name,\n-    points_to: Vec<ModuleId>,\n-    problem: Option<Problem>,\n-}\n-\n impl ModuleTree {\n     fn push_mod(&mut self, data: ModuleData) -> ModuleId {\n         self.mods.alloc(data)\n@@ -207,3 +223,153 @@ impl ModuleTree {\n         id\n     }\n }\n+\n+fn modules<'a>(\n+    root: impl ast::ModuleItemOwner<'a>,\n+) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n+    root.items()\n+        .filter_map(|item| match item {\n+            ast::ModuleItem::Module(m) => Some(m),\n+            _ => None,\n+        })\n+        .filter_map(|module| {\n+            let name = module.name()?.as_name();\n+            Some((name, module))\n+        })\n+}\n+\n+fn create_module_tree<'a>(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<ModuleTree> {\n+    let mut tree = ModuleTree::default();\n+\n+    let mut roots = FxHashMap::default();\n+    let mut visited = FxHashSet::default();\n+\n+    let source_root = db.source_root(source_root);\n+    for &file_id in source_root.files.values() {\n+        let source = ModuleSource::new_file(file_id.into());\n+        if visited.contains(&source) {\n+            continue; // TODO: use explicit crate_roots here\n+        }\n+        assert!(!roots.contains_key(&file_id));\n+        let module_id = build_subtree(\n+            db,\n+            &source_root,\n+            &mut tree,\n+            &mut visited,\n+            &mut roots,\n+            None,\n+            source,\n+        )?;\n+        roots.insert(file_id, module_id);\n+    }\n+    Ok(tree)\n+}\n+\n+fn build_subtree(\n+    db: &impl HirDatabase,\n+    source_root: &SourceRoot,\n+    tree: &mut ModuleTree,\n+    visited: &mut FxHashSet<ModuleSource>,\n+    roots: &mut FxHashMap<FileId, ModuleId>,\n+    parent: Option<LinkId>,\n+    source: ModuleSource,\n+) -> Cancelable<ModuleId> {\n+    visited.insert(source);\n+    let id = tree.push_mod(ModuleData {\n+        source,\n+        parent,\n+        children: Vec::new(),\n+    });\n+    for sub in db.submodules(source)?.iter() {\n+        let link = tree.push_link(LinkData {\n+            name: sub.name().clone(),\n+            owner: id,\n+            points_to: Vec::new(),\n+            problem: None,\n+        });\n+\n+        let (points_to, problem) = match sub {\n+            Submodule::Declaration(name) => {\n+                let (points_to, problem) = resolve_submodule(db, source, &name);\n+                let points_to = points_to\n+                    .into_iter()\n+                    .map(|file_id| match roots.remove(&file_id) {\n+                        Some(module_id) => {\n+                            tree.mods[module_id].parent = Some(link);\n+                            Ok(module_id)\n+                        }\n+                        None => build_subtree(\n+                            db,\n+                            source_root,\n+                            tree,\n+                            visited,\n+                            roots,\n+                            Some(link),\n+                            ModuleSource::new_file(file_id.into()),\n+                        ),\n+                    })\n+                    .collect::<Cancelable<Vec<_>>>()?;\n+                (points_to, problem)\n+            }\n+            Submodule::Definition(_name, submodule_source) => {\n+                let points_to = build_subtree(\n+                    db,\n+                    source_root,\n+                    tree,\n+                    visited,\n+                    roots,\n+                    Some(link),\n+                    *submodule_source,\n+                )?;\n+                (vec![points_to], None)\n+            }\n+        };\n+\n+        tree.links[link].points_to = points_to;\n+        tree.links[link].problem = problem;\n+    }\n+    Ok(id)\n+}\n+\n+fn resolve_submodule(\n+    db: &impl HirDatabase,\n+    source: ModuleSource,\n+    name: &Name,\n+) -> (Vec<FileId>, Option<Problem>) {\n+    // FIXME: handle submodules of inline modules properly\n+    let file_id = source.file_id().original_file(db);\n+    let source_root_id = db.file_source_root(file_id);\n+    let path = db.file_relative_path(file_id);\n+    let root = RelativePathBuf::default();\n+    let dir_path = path.parent().unwrap_or(&root);\n+    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n+    let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+\n+    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n+    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n+    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n+    let mut candidates = ArrayVec::<[_; 2]>::new();\n+    if is_dir_owner {\n+        candidates.push(file_mod.clone());\n+        candidates.push(dir_mod);\n+    } else {\n+        candidates.push(file_dir_mod.clone());\n+    };\n+    let sr = db.source_root(source_root_id);\n+    let points_to = candidates\n+        .into_iter()\n+        .filter_map(|path| sr.files.get(&path))\n+        .map(|&it| it)\n+        .collect::<Vec<_>>();\n+    let problem = if points_to.is_empty() {\n+        Some(Problem::UnresolvedModule {\n+            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n+        })\n+    } else {\n+        None\n+    };\n+    (points_to, problem)\n+}", "previous_filename": "crates/ra_hir/src/module.rs"}, {"sha": "e65cbcb2707bf9a501939561945033856a2af8a3", "filename": "crates/ra_hir/src/nameres.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -31,7 +31,7 @@ use crate::{\n     Path, PathKind,\n     HirDatabase, Crate,\n     Name, AsName,\n-    module::{ModuleId, ModuleTree},\n+    module_tree::{ModuleId, ModuleTree},\n };\n \n /// Item map is the result of the name resolution. Item map contains, for each", "previous_filename": "crates/ra_hir/src/module/nameres.rs"}, {"sha": "a6a0bea3160e4189e9815aa56179c0f1903801f3", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -17,7 +17,7 @@ fn item_map(fixture: &str) -> (Arc<hir::ItemMap>, hir::ModuleId) {\n     let module = hir::source_binder::module_from_position(&db, pos)\n         .unwrap()\n         .unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n+    let module_id = module.module_id;\n     (db.item_map(source_root).unwrap(), module_id)\n }\n \n@@ -155,7 +155,7 @@ fn item_map_across_crates() {\n     let module = hir::source_binder::module_from_file_id(&db, main_id)\n         .unwrap()\n         .unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n+    let module_id = module.module_id;\n     let item_map = db.item_map(source_root).unwrap();\n \n     check_module_item_map(", "previous_filename": "crates/ra_hir/src/module/nameres/tests.rs"}, {"sha": "b17c00e26f33143a5b95c8a795e34dd75db114cc", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -15,11 +15,8 @@ use crate::{\n     MacroCallLoc,\n     db::HirDatabase,\n     function::FnScopes,\n-    module::{\n-        ModuleSource, ModuleSourceNode, ModuleId,\n-        imp::Submodule,\n-        nameres::{InputModuleItems, ItemMap, Resolver},\n-    },\n+    module_tree::{ModuleId, Submodule, ModuleSource, ModuleSourceNode},\n+    nameres::{InputModuleItems, ItemMap, Resolver},\n     adt::{StructData, EnumData},\n };\n "}, {"sha": "b7e3ff9b0c56944b4fc0cb9e556b4d9b7c19002f", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4456d0ec88e3433a7a8be6f27d8af9afedefe5/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=fd4456d0ec88e3433a7a8be6f27d8af9afedefe5", "patch": "@@ -14,7 +14,7 @@ use ra_syntax::{\n \n use crate::{\n     HirDatabase, Function, SourceItemId,\n-    module::ModuleSource,\n+    module_tree::ModuleSource,\n     DefKind, DefLoc, AsName,\n };\n "}]}