{"sha": "d65953330b45672b61a321add42056376b3c2342", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NTk1MzMzMGI0NTY3MmI2MWEzMjFhZGQ0MjA1NjM3NmIzYzIzNDI=", "commit": {"author": {"name": "Oliver 'ker' Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-15T19:09:53Z"}, "committer": {"name": "Oliver 'ker' Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-15T19:09:53Z"}, "message": "rustup const eval changes", "tree": {"sha": "99b891fe032d7530ba71ae36a5ca5b63c3b81d50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99b891fe032d7530ba71ae36a5ca5b63c3b81d50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d65953330b45672b61a321add42056376b3c2342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d65953330b45672b61a321add42056376b3c2342", "html_url": "https://github.com/rust-lang/rust/commit/d65953330b45672b61a321add42056376b3c2342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d65953330b45672b61a321add42056376b3c2342/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20123eef982d3bd26fb30df8ead2f386d0daad7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/20123eef982d3bd26fb30df8ead2f386d0daad7b", "html_url": "https://github.com/rust-lang/rust/commit/20123eef982d3bd26fb30df8ead2f386d0daad7b"}], "stats": {"total": 175, "additions": 71, "deletions": 104}, "files": [{"sha": "3c6acb93284301e8b874679ab46bca70cb6a7429", "filename": "src/array_indexing.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d65953330b45672b61a321add42056376b3c2342/src%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65953330b45672b61a321add42056376b3c2342/src%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farray_indexing.rs?ref=d65953330b45672b61a321add42056376b3c2342", "patch": "@@ -3,6 +3,7 @@ use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::middle::const_eval::{eval_const_expr_partial, ConstVal};\n use rustc::middle::ty::TyArray;\n use rustc_front::hir::*;\n+use rustc_const_eval::ConstInt;\n use syntax::ast::RangeLimits;\n use utils;\n \n@@ -62,11 +63,11 @@ impl LateLintPass for ArrayIndexing {\n             // Array with known size can be checked statically\n             let ty = cx.tcx.expr_ty(array);\n             if let TyArray(_, size) = ty.sty {\n-                let size = size as u64;\n+                let size = ConstInt::Infer(size as u64);\n \n                 // Index is a constant uint\n                 let const_index = eval_const_expr_partial(cx.tcx, &index, ExprTypeChecked, None);\n-                if let Ok(ConstVal::Uint(const_index)) = const_index {\n+                if let Ok(ConstVal::Integral(const_index)) = const_index {\n                     if size <= const_index {\n                         utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n                     }\n@@ -115,24 +116,24 @@ impl LateLintPass for ArrayIndexing {\n fn to_const_range(start: Option<Option<ConstVal>>,\n                     end: Option<Option<ConstVal>>,\n                     limits: RangeLimits,\n-                    array_size: u64)\n-                    -> Option<(u64, u64)> {\n+                    array_size: ConstInt)\n+                    -> Option<(ConstInt, ConstInt)> {\n     let start = match start {\n-        Some(Some(ConstVal::Uint(x))) => x,\n+        Some(Some(ConstVal::Integral(x))) => x,\n         Some(_) => return None,\n-        None => 0,\n+        None => ConstInt::Infer(0),\n     };\n \n     let end = match end {\n-        Some(Some(ConstVal::Uint(x))) => {\n+        Some(Some(ConstVal::Integral(x))) => {\n             if limits == RangeLimits::Closed {\n                 x\n             } else {\n-                x - 1\n+                (x - ConstInt::Infer(1)).expect(\"x > 0\")\n             }\n         }\n         Some(_) => return None,\n-        None => array_size - 1,\n+        None => (array_size - ConstInt::Infer(1)).expect(\"array_size > 0\"),\n     };\n \n     Some((start, end))"}, {"sha": "02d428e834d75e04ce6f14eb9046f2de72a3d907", "filename": "src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d65953330b45672b61a321add42056376b3c2342/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65953330b45672b61a321add42056376b3c2342/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=d65953330b45672b61a321add42056376b3c2342", "patch": "@@ -271,7 +271,7 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n                 }\n             }\n             .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, None, None))\n-            .and_then(|l| fetch_int_literal(cx, l))\n+            .and_then(|(l, _ty)| fetch_int_literal(cx, l))\n         }\n         _ => None,\n     }"}, {"sha": "eae9747d6e0043ef4f9ea4921018eaa9e380aad4", "filename": "src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d65953330b45672b61a321add42056376b3c2342/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65953330b45672b61a321add42056376b3c2342/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=d65953330b45672b61a321add42056376b3c2342", "patch": "@@ -347,7 +347,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             }\n             // separate if lets to avoid double borrowing the def_map\n             if let Some(id) = maybe_id {\n-                if let Some(const_expr) = lookup_const_by_id(lcx.tcx, id, None, None) {\n+                if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, id, None, None) {\n                     let ret = self.expr(const_expr);\n                     if ret.is_some() {\n                         self.needed_resolution = true;"}, {"sha": "85fa418f278892ddeb91677f0ccb63746beae279", "filename": "src/enum_clike.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d65953330b45672b61a321add42056376b3c2342/src%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65953330b45672b61a321add42056376b3c2342/src%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_clike.rs?ref=d65953330b45672b61a321add42056376b3c2342", "patch": "@@ -1,11 +1,9 @@\n //! lint on C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\n \n use rustc::lint::*;\n-use syntax::ast::{IntTy, UintTy};\n use syntax::attr::*;\n use rustc_front::hir::*;\n use rustc::middle::const_eval::{ConstVal, EvalHint, eval_const_expr_partial};\n-use rustc::middle::ty;\n use utils::span_lint;\n \n /// **What it does:** Lints on C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`.\n@@ -35,12 +33,10 @@ impl LateLintPass for EnumClikeUnportableVariant {\n             for var in &def.variants {\n                 let variant = &var.node;\n                 if let Some(ref disr) = variant.disr_expr {\n-                    let cv = eval_const_expr_partial(cx.tcx, &**disr, EvalHint::ExprTypeChecked, None);\n-                    let bad = match (cv, &cx.tcx.expr_ty(&**disr).sty) {\n-                        (Ok(ConstVal::Int(i)), &ty::TyInt(IntTy::Is)) => i as i32 as i64 != i,\n-                        (Ok(ConstVal::Uint(i)), &ty::TyInt(IntTy::Is)) => i as i32 as u64 != i,\n-                        (Ok(ConstVal::Int(i)), &ty::TyUint(UintTy::Us)) => (i < 0) || (i as u32 as i64 != i),\n-                        (Ok(ConstVal::Uint(i)), &ty::TyUint(UintTy::Us)) => i as u32 as u64 != i,\n+                    use rustc_const_eval::*;\n+                    let bad = match eval_const_expr_partial(cx.tcx, &**disr, EvalHint::ExprTypeChecked, None) {\n+                        Ok(ConstVal::Integral(Usize(Us64(i)))) => i as u32 as u64 != i,\n+                        Ok(ConstVal::Integral(Isize(Is64(i)))) => i as i32 as i64 != i,\n                         _ => false,\n                     };\n                     if bad {"}, {"sha": "7987c70d0275d8a0e5408dadea7976140dbd38ef", "filename": "src/loops.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d65953330b45672b61a321add42056376b3c2342/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65953330b45672b61a321add42056376b3c2342/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=d65953330b45672b61a321add42056376b3c2342", "patch": "@@ -429,10 +429,7 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                 // who think that this will iterate from the larger value to the\n                 // smaller value.\n                 let (sup, eq) = match (start_idx, end_idx) {\n-                    (ConstVal::Int(start_idx), ConstVal::Int(end_idx)) => {\n-                        (start_idx > end_idx, start_idx == end_idx)\n-                    }\n-                    (ConstVal::Uint(start_idx), ConstVal::Uint(end_idx)) => {\n+                    (ConstVal::Integral(start_idx), ConstVal::Integral(end_idx)) => {\n                         (start_idx > end_idx, start_idx == end_idx)\n                     }\n                     _ => (false, false),"}, {"sha": "a456a816f627ec9ad44924fc543f1b5fde32863a", "filename": "src/matches.rs", "status": "modified", "additions": 22, "deletions": 54, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d65953330b45672b61a321add42056376b3c2342/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65953330b45672b61a321add42056376b3c2342/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=d65953330b45672b61a321add42056376b3c2342", "patch": "@@ -1,9 +1,9 @@\n use rustc::lint::*;\n-use rustc::middle::const_eval::ConstVal::{Int, Uint};\n use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::middle::const_eval::{eval_const_expr_partial, ConstVal};\n use rustc::middle::ty;\n use rustc_front::hir::*;\n+use rustc_const_eval::ConstInt;\n use std::cmp::Ordering;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n@@ -288,19 +288,16 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n fn check_overlapping_arms(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n     if arms.len() >= 2 && cx.tcx.expr_ty(ex).is_integral() {\n         let ranges = all_ranges(cx, arms);\n-        let overlap = match type_ranges(&ranges) {\n-            TypedRanges::IntRanges(ranges) => overlapping(&ranges).map(|(start, end)| (start.span, end.span)),\n-            TypedRanges::UintRanges(ranges) => overlapping(&ranges).map(|(start, end)| (start.span, end.span)),\n-            TypedRanges::None => None,\n-        };\n-\n-        if let Some((start, end)) = overlap {\n-            span_note_and_lint(cx,\n-                               MATCH_OVERLAPPING_ARM,\n-                               start,\n-                               \"some ranges overlap\",\n-                               end,\n-                               \"overlaps with this\");\n+        let type_ranges = type_ranges(&ranges);\n+        if !type_ranges.is_empty() {\n+            if let Some((start, end)) = overlapping(&type_ranges) {\n+                span_note_and_lint(cx,\n+                                   MATCH_OVERLAPPING_ARM,\n+                                   start.span,\n+                                   \"some ranges overlap\",\n+                                   end.span,\n+                                   \"overlaps with this\");\n+            }\n         }\n     }\n }\n@@ -370,51 +367,22 @@ pub struct SpannedRange<T> {\n     pub node: (T, T),\n }\n \n-#[derive(Debug)]\n-enum TypedRanges {\n-    IntRanges(Vec<SpannedRange<i64>>),\n-    UintRanges(Vec<SpannedRange<u64>>),\n-    None,\n-}\n+type TypedRanges = Vec<SpannedRange<ConstInt>>;\n \n /// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway and other types than\n /// `Uint` and `Int` probably don't make sense.\n fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n-    if ranges.is_empty() {\n-        TypedRanges::None\n-    } else {\n-        match ranges[0].node {\n-            (Int(_), Int(_)) => {\n-                TypedRanges::IntRanges(ranges.iter()\n-                                             .filter_map(|range| {\n-                                                 if let (Int(start), Int(end)) = range.node {\n-                                                     Some(SpannedRange {\n-                                                         span: range.span,\n-                                                         node: (start, end),\n-                                                     })\n-                                                 } else {\n-                                                     None\n-                                                 }\n-                                             })\n-                                             .collect())\n-            }\n-            (Uint(_), Uint(_)) => {\n-                TypedRanges::UintRanges(ranges.iter()\n-                                              .filter_map(|range| {\n-                                                  if let (Uint(start), Uint(end)) = range.node {\n-                                                      Some(SpannedRange {\n-                                                          span: range.span,\n-                                                          node: (start, end),\n-                                                      })\n-                                                  } else {\n-                                                      None\n-                                                  }\n-                                              })\n-                                              .collect())\n-            }\n-            _ => TypedRanges::None,\n+    ranges.iter().filter_map(|range| {\n+        if let (ConstVal::Integral(start), ConstVal::Integral(end)) = range.node {\n+            Some(SpannedRange {\n+                span: range.span,\n+                node: (start, end),\n+            })\n+        } else {\n+            None\n         }\n-    }\n+    })\n+    .collect()\n }\n \n fn is_unit_expr(expr: &Expr) -> bool {"}, {"sha": "c5acbb41ea15ca9134adad5a0f253b1495264d73", "filename": "src/types.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d65953330b45672b61a321add42056376b3c2342/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65953330b45672b61a321add42056376b3c2342/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=d65953330b45672b61a321add42056376b3c2342", "patch": "@@ -673,6 +673,7 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n     use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n     use types::ExtremeType::*;\n     use rustc::middle::const_eval::ConstVal::*;\n+    use rustc_const_eval::*;\n \n     let ty = &cx.tcx.expr_ty(expr).sty;\n \n@@ -687,33 +688,37 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n     };\n \n     let which = match (ty, cv) {\n-        (&ty::TyBool, Bool(false)) => Minimum,\n-\n-        (&ty::TyInt(IntTy::Is), Int(x)) if x == ::std::isize::MIN as i64 => Minimum,\n-        (&ty::TyInt(IntTy::I8), Int(x)) if x == ::std::i8::MIN as i64 => Minimum,\n-        (&ty::TyInt(IntTy::I16), Int(x)) if x == ::std::i16::MIN as i64 => Minimum,\n-        (&ty::TyInt(IntTy::I32), Int(x)) if x == ::std::i32::MIN as i64 => Minimum,\n-        (&ty::TyInt(IntTy::I64), Int(x)) if x == ::std::i64::MIN as i64 => Minimum,\n-\n-        (&ty::TyUint(UintTy::Us), Uint(x)) if x == ::std::usize::MIN as u64 => Minimum,\n-        (&ty::TyUint(UintTy::U8), Uint(x)) if x == ::std::u8::MIN as u64 => Minimum,\n-        (&ty::TyUint(UintTy::U16), Uint(x)) if x == ::std::u16::MIN as u64 => Minimum,\n-        (&ty::TyUint(UintTy::U32), Uint(x)) if x == ::std::u32::MIN as u64 => Minimum,\n-        (&ty::TyUint(UintTy::U64), Uint(x)) if x == ::std::u64::MIN as u64 => Minimum,\n-\n-        (&ty::TyBool, Bool(true)) => Maximum,\n-\n-        (&ty::TyInt(IntTy::Is), Int(x)) if x == ::std::isize::MAX as i64 => Maximum,\n-        (&ty::TyInt(IntTy::I8), Int(x)) if x == ::std::i8::MAX as i64 => Maximum,\n-        (&ty::TyInt(IntTy::I16), Int(x)) if x == ::std::i16::MAX as i64 => Maximum,\n-        (&ty::TyInt(IntTy::I32), Int(x)) if x == ::std::i32::MAX as i64 => Maximum,\n-        (&ty::TyInt(IntTy::I64), Int(x)) if x == ::std::i64::MAX as i64 => Maximum,\n-\n-        (&ty::TyUint(UintTy::Us), Uint(x)) if x == ::std::usize::MAX as u64 => Maximum,\n-        (&ty::TyUint(UintTy::U8), Uint(x)) if x == ::std::u8::MAX as u64 => Maximum,\n-        (&ty::TyUint(UintTy::U16), Uint(x)) if x == ::std::u16::MAX as u64 => Maximum,\n-        (&ty::TyUint(UintTy::U32), Uint(x)) if x == ::std::u32::MAX as u64 => Maximum,\n-        (&ty::TyUint(UintTy::U64), Uint(x)) if x == ::std::u64::MAX as u64 => Maximum,\n+        (&ty::TyBool, Bool(false)) |\n+\n+        (&ty::TyInt(IntTy::Is), Integral(Isize(Is32(::std::i32::MIN)))) |\n+        (&ty::TyInt(IntTy::Is), Integral(Isize(Is64(::std::i64::MIN)))) |\n+        (&ty::TyInt(IntTy::I8), Integral(I8(::std::i8::MIN))) |\n+        (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MIN))) |\n+        (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MIN))) |\n+        (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MIN))) |\n+\n+        (&ty::TyUint(UintTy::Us), Integral(Usize(Us32(::std::u32::MIN)))) |\n+        (&ty::TyUint(UintTy::Us), Integral(Usize(Us64(::std::u64::MIN)))) |\n+        (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MIN))) |\n+        (&ty::TyUint(UintTy::U16), Integral(U16(::std::u16::MIN))) |\n+        (&ty::TyUint(UintTy::U32), Integral(U32(::std::u32::MIN))) |\n+        (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MIN))) => Minimum,\n+\n+        (&ty::TyBool, Bool(true)) |\n+\n+        (&ty::TyInt(IntTy::Is), Integral(Isize(Is32(::std::i32::MAX)))) |\n+        (&ty::TyInt(IntTy::Is), Integral(Isize(Is64(::std::i64::MAX)))) |\n+        (&ty::TyInt(IntTy::I8), Integral(I8(::std::i8::MAX))) |\n+        (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MAX))) |\n+        (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MAX))) |\n+        (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MAX))) |\n+\n+        (&ty::TyUint(UintTy::Us), Integral(Usize(Us32(::std::u32::MAX)))) |\n+        (&ty::TyUint(UintTy::Us), Integral(Usize(Us64(::std::u64::MAX)))) |\n+        (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MAX))) |\n+        (&ty::TyUint(UintTy::U16), Integral(U16(::std::u16::MAX))) |\n+        (&ty::TyUint(UintTy::U32), Integral(U32(::std::u32::MAX))) |\n+        (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MAX))) => Maximum,\n \n         _ => return None,\n     };"}]}