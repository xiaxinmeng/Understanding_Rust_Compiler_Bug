{"sha": "8122ce81d0909bed39c6df3e47bc751851bded84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMjJjZTgxZDA5MDliZWQzOWM2ZGYzZTQ3YmM3NTE4NTFiZGVkODQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-02-05T08:46:01Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-02-08T20:29:53Z"}, "message": "Accept quantification of lifetimes outside the self type in where clauses.\n\nCloses #20022", "tree": {"sha": "438c010af390cb3d7b67bbfe422e0772c80ca006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/438c010af390cb3d7b67bbfe422e0772c80ca006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8122ce81d0909bed39c6df3e47bc751851bded84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8122ce81d0909bed39c6df3e47bc751851bded84", "html_url": "https://github.com/rust-lang/rust/commit/8122ce81d0909bed39c6df3e47bc751851bded84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8122ce81d0909bed39c6df3e47bc751851bded84/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "012e9643e4d6f6fa449ca4f4e5e3fc9fb8e536db", "url": "https://api.github.com/repos/rust-lang/rust/commits/012e9643e4d6f6fa449ca4f4e5e3fc9fb8e536db", "html_url": "https://github.com/rust-lang/rust/commit/012e9643e4d6f6fa449ca4f4e5e3fc9fb8e536db"}], "stats": {"total": 127, "additions": 100, "deletions": 27}, "files": [{"sha": "efcc3715d3e3d97f22e3f0586fc039346b39d402", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -126,7 +126,8 @@ register_diagnostics! {\n     E0312, // lifetime of reference outlives lifetime of borrowed content\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n     E0314, // closure outlives stack frame\n-    E0315 // cannot invoke closure outside of its lifetime\n+    E0315, // cannot invoke closure outside of its lifetime\n+    E0316 // nested quantification of lifetimes\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "99896535442d81363f00d01d88ea58ce0bd132e6", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -1076,7 +1076,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         trait_ref: ast::TraitRef {\n                             path: new_path,\n                             ref_id: tr.ref_id,\n-                        }\n+                        },\n+                        span: poly_tr.span,\n                     }, modifier)\n                 }\n             }"}, {"sha": "6f38dc81064209b997752ae332c8ef5fbcc6c258", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -45,15 +45,31 @@ pub enum DefRegion {\n                   /* lifetime decl */ ast::NodeId),\n }\n \n-// maps the id of each lifetime reference to the lifetime decl\n-// that it corresponds to\n+// Maps the id of each lifetime reference to the lifetime decl\n+// that it corresponds to.\n pub type NamedRegionMap = NodeMap<DefRegion>;\n \n struct LifetimeContext<'a> {\n     sess: &'a Session,\n     named_region_map: &'a mut NamedRegionMap,\n     scope: Scope<'a>,\n     def_map: &'a DefMap,\n+    // Deep breath. Our representation for poly trait refs contains a single\n+    // binder and thus we only allow a single level of quantification. However,\n+    // the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n+    // and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the de Bruijn indices\n+    // correct when representing these constraints, we should only introduce one\n+    // scope. However, we want to support both locations for the quantifier and\n+    // during lifetime resolution we want precise information (so we can't\n+    // desugar in an earlier phase).\n+\n+    // SO, if we encounter a quantifier at the outer scope, we set\n+    // trait_ref_hack to true (and introduce a scope), and then if we encounter\n+    // a quantifier at the inner scope, we error. If trait_ref_hack is false,\n+    // then we introduce the scope at the inner quantifier.\n+\n+    // I'm sorry.\n+    trait_ref_hack: bool,\n }\n \n enum ScopeChain<'a> {\n@@ -80,6 +96,7 @@ pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegio\n         named_region_map: &mut named_region_map,\n         scope: &ROOT_SCOPE,\n         def_map: def_map,\n+        trait_ref_hack: false,\n     }, krate);\n     sess.abort_if_errors();\n     named_region_map\n@@ -198,9 +215,22 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ ref bounded_ty,\n                                                                                ref bounds,\n+                                                                               ref bound_lifetimes,\n                                                                                .. }) => {\n-                    self.visit_ty(&**bounded_ty);\n-                    visit::walk_ty_param_bounds_helper(self, bounds);\n+                    if bound_lifetimes.len() > 0 {\n+                        self.trait_ref_hack = true;\n+                        let result = self.with(LateScope(bound_lifetimes, self.scope),\n+                                               |old_scope, this| {\n+                            this.check_lifetime_defs(old_scope, bound_lifetimes);\n+                            this.visit_ty(&**bounded_ty);\n+                            visit::walk_ty_param_bounds_helper(this, bounds);\n+                        });\n+                        self.trait_ref_hack = false;\n+                        result\n+                    } else {\n+                        self.visit_ty(&**bounded_ty);\n+                        visit::walk_ty_param_bounds_helper(self, bounds);\n+                    }\n                 }\n                 &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n                                                                                 ref bounds,\n@@ -222,18 +252,27 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         }\n     }\n \n-    fn visit_poly_trait_ref(&mut self, trait_ref:\n-                            &ast::PolyTraitRef,\n+    fn visit_poly_trait_ref(&mut self,\n+                            trait_ref: &ast::PolyTraitRef,\n                             _modifier: &ast::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n-        self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n-            this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n-            for lifetime in &trait_ref.bound_lifetimes {\n-                this.visit_lifetime_def(lifetime);\n+        if !self.trait_ref_hack || trait_ref.bound_lifetimes.len() > 0 {\n+            if self.trait_ref_hack {\n+                println!(\"{:?}\", trait_ref.span);\n+                span_err!(self.sess, trait_ref.span, E0316,\n+                          \"nested quantification of lifetimes\");\n             }\n-            this.visit_trait_ref(&trait_ref.trait_ref)\n-        })\n+            self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n+                this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n+                for lifetime in &trait_ref.bound_lifetimes {\n+                    this.visit_lifetime_def(lifetime);\n+                }\n+                this.visit_trait_ref(&trait_ref.trait_ref)\n+            })\n+        } else {\n+            self.visit_trait_ref(&trait_ref.trait_ref)\n+        }\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n@@ -251,6 +290,7 @@ impl<'a> LifetimeContext<'a> {\n             named_region_map: *named_region_map,\n             scope: &wrap_scope,\n             def_map: self.def_map,\n+            trait_ref_hack: self.trait_ref_hack,\n         };\n         debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);"}, {"sha": "95f7ff58524402f37655c6dc68c6a64d8b33c1ed", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -1478,7 +1478,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n /// compiler's representation for things like `for<'a> Fn(&'a int)`\n /// (which would be represented by the type `PolyTraitRef ==\n /// Binder<TraitRef>`). Note that when we skolemize, instantiate,\n-/// erase, or otherwise \"discharge\" these bound reons, we change the\n+/// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "0dbb53e09b7d97f32c28bb05c563e8d65503e898", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -526,7 +526,7 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n {\n     let mut projections = Vec::new();\n \n-    // the trait reference introduces a binding level here, so\n+    // The trait reference introduces a binding level here, so\n     // we need to shift the `rscope`. It'd be nice if we could\n     // do away with this rscope stuff and work this knowledge\n     // into resolve_lifetimes, as we do with non-omitted"}, {"sha": "f8793f81b199642e13371c51e2456765afb8f5e7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -443,6 +443,7 @@ pub enum WherePredicate {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n+    pub bound_lifetimes: Vec<LifetimeDef>,\n     pub bounded_ty: P<Ty>,\n     pub bounds: OwnedSlice<TyParamBound>,\n }\n@@ -1535,6 +1536,8 @@ pub struct PolyTraitRef {\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n     pub trait_ref: TraitRef,\n+\n+    pub span: Span,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "6d9a2fdb9f19814092c4173be5ace28cebccb8d0", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -70,7 +70,7 @@ pub trait AstBuilder {\n                default: Option<P<ast::Ty>>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n-    fn poly_trait_ref(&self, path: ast::Path) -> ast::PolyTraitRef;\n+    fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef;\n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n     fn lifetime(&self, span: Span, ident: ast::Name) -> ast::Lifetime;\n     fn lifetime_def(&self,\n@@ -442,15 +442,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn poly_trait_ref(&self, path: ast::Path) -> ast::PolyTraitRef {\n+    fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef {\n         ast::PolyTraitRef {\n             bound_lifetimes: Vec::new(),\n-            trait_ref: self.trait_ref(path)\n+            trait_ref: self.trait_ref(path),\n+            span: span,\n         }\n     }\n \n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound {\n-        ast::TraitTyParamBound(self.poly_trait_ref(path), ast::TraitBoundModifier::None)\n+        ast::TraitTyParamBound(self.poly_trait_ref(path.span, path), ast::TraitBoundModifier::None)\n     }\n \n     fn lifetime(&self, span: Span, name: ast::Name) -> ast::Lifetime {"}, {"sha": "d9242417e047511fc4cd982a4869e01d86f75a48", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -443,6 +443,7 @@ impl<'a> TraitDef<'a> {\n                 ast::WherePredicate::BoundPredicate(ref wb) => {\n                     ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n                         span: self.span,\n+                        bound_lifetimes: wb.bound_lifetimes.clone(),\n                         bounded_ty: wb.bounded_ty.clone(),\n                         bounds: OwnedSlice::from_vec(wb.bounds.iter().map(|b| b.clone()).collect())\n                     })"}, {"sha": "8f1d15f6da885f3d5304cc23ea892b6195d54099", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -806,10 +806,12 @@ pub fn noop_fold_where_predicate<T: Folder>(\n                                  fld: &mut T)\n                                  -> WherePredicate {\n     match pred {\n-        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{bounded_ty,\n+        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{bound_lifetimes,\n+                                                                     bounded_ty,\n                                                                      bounds,\n                                                                      span}) => {\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                bound_lifetimes: fld.fold_lifetime_defs(bound_lifetimes),\n                 bounded_ty: fld.fold_ty(bounded_ty),\n                 bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n                 span: fld.new_span(span)\n@@ -895,7 +897,8 @@ pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n     ast::PolyTraitRef {\n         bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n-        trait_ref: fld.fold_trait_ref(p.trait_ref)\n+        trait_ref: fld.fold_trait_ref(p.trait_ref),\n+        span: fld.new_span(p.span),\n     }\n }\n "}, {"sha": "fd2f0685cab8386d3bf6cf59cd176547f869fdee", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122ce81d0909bed39c6df3e47bc751851bded84/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8122ce81d0909bed39c6df3e47bc751851bded84", "patch": "@@ -1036,6 +1036,8 @@ impl<'a> Parser<'a> {\n         */\n \n         // parse <'lt>\n+        let lo = self.span.lo;\n+\n         let lifetime_defs = self.parse_late_bound_lifetime_defs();\n \n         // examine next token to decide to do\n@@ -1047,9 +1049,11 @@ impl<'a> Parser<'a> {\n                   self.token.is_ident() ||\n                   self.token.is_path()\n         {\n+            let hi = self.span.hi;\n             let trait_ref = self.parse_trait_ref();\n             let poly_trait_ref = ast::PolyTraitRef { bound_lifetimes: lifetime_defs,\n-                                                     trait_ref: trait_ref };\n+                                                     trait_ref: trait_ref,\n+                                                     span: mk_sp(lo, hi)};\n             let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n                 self.parse_ty_param_bounds(BoundParsingMode::Bare)\n             } else {\n@@ -4070,7 +4074,8 @@ impl<'a> Parser<'a> {\n         if let Some(unbound) = unbound {\n             let mut bounds_as_vec = bounds.into_vec();\n             bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n-                                                                trait_ref: unbound },\n+                                                                trait_ref: unbound,\n+                                                                span: span },\n                                                  TraitBoundModifier::Maybe));\n             bounds = OwnedSlice::from_vec(bounds_as_vec);\n         };\n@@ -4223,6 +4228,16 @@ impl<'a> Parser<'a> {\n                 }\n \n                 _ => {\n+                    let bound_lifetimes = if self.eat_keyword(keywords::For) {\n+                        // Higher ranked constraint.\n+                        self.expect(&token::Lt);\n+                        let lifetime_defs = self.parse_lifetime_defs();\n+                        self.expect_gt();\n+                        lifetime_defs\n+                    } else {\n+                        vec![]\n+                    };\n+\n                     let bounded_ty = self.parse_ty();\n \n                     if self.eat(&token::Colon) {\n@@ -4233,12 +4248,13 @@ impl<'a> Parser<'a> {\n                         if bounds.len() == 0 {\n                             self.span_err(span,\n                                           \"each predicate in a `where` clause must have \\\n-                                   at least one bound in it\");\n+                                           at least one bound in it\");\n                         }\n \n                         generics.where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                                 ast::WhereBoundPredicate {\n                                     span: span,\n+                                    bound_lifetimes: bound_lifetimes,\n                                     bounded_ty: bounded_ty,\n                                     bounds: bounds,\n                         }));\n@@ -4674,8 +4690,12 @@ impl<'a> Parser<'a> {\n \n     /// Parse trait Foo { ... }\n     fn parse_item_trait(&mut self, unsafety: Unsafety) -> ItemInfo {\n+\n         let ident = self.parse_ident();\n         let mut tps = self.parse_generics();\n+        // This is not very accurate, but since unbound only exists to catch\n+        // obsolete syntax, the span is unlikely to ever be used.\n+        let unbound_span = self.span;\n         let unbound = self.parse_for_sized();\n \n         // Parse supertrait bounds.\n@@ -4684,7 +4704,8 @@ impl<'a> Parser<'a> {\n         if let Some(unbound) = unbound {\n             let mut bounds_as_vec = bounds.into_vec();\n             bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n-                                                                trait_ref: unbound },\n+                                                                trait_ref: unbound,\n+                                                                span:  unbound_span },\n                                                  TraitBoundModifier::Maybe));\n             bounds = OwnedSlice::from_vec(bounds_as_vec);\n         };\n@@ -4803,11 +4824,13 @@ impl<'a> Parser<'a> {\n \n     /// Parse for<'l> a::B<String,i32>\n     fn parse_poly_trait_ref(&mut self) -> PolyTraitRef {\n+        let lo = self.span.lo;\n         let lifetime_defs = self.parse_late_bound_lifetime_defs();\n \n         ast::PolyTraitRef {\n             bound_lifetimes: lifetime_defs,\n-            trait_ref: self.parse_trait_ref()\n+            trait_ref: self.parse_trait_ref(),\n+            span: mk_sp(lo, self.last_span.hi),\n         }\n     }\n "}]}