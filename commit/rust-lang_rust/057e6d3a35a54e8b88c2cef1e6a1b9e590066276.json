{"sha": "057e6d3a35a54e8b88c2cef1e6a1b9e590066276", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1N2U2ZDNhMzVhNTRlOGI4OGMyY2VmMWU2YTFiOWU1OTAwNjYyNzY=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-11-25T16:33:16Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-11-25T21:34:59Z"}, "message": "Add TryFrom<&[T]> for [T; $N] where T: Copy\n\n`TryFrom<&[T]> for &[T; $N]` (note *reference* to an array) already exists,\nbut not needing to dereference makes type inference easier\nfor example when using `u32::from_be_bytes`.\n\nAlso add doc examples doing just that.", "tree": {"sha": "5e1ab2b55554895154dc7225e430950c90dbfafb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e1ab2b55554895154dc7225e430950c90dbfafb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/057e6d3a35a54e8b88c2cef1e6a1b9e590066276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/057e6d3a35a54e8b88c2cef1e6a1b9e590066276", "html_url": "https://github.com/rust-lang/rust/commit/057e6d3a35a54e8b88c2cef1e6a1b9e590066276", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/057e6d3a35a54e8b88c2cef1e6a1b9e590066276/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bd451b26580de465d59ed5389209ed191b7dbdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bd451b26580de465d59ed5389209ed191b7dbdd", "html_url": "https://github.com/rust-lang/rust/commit/5bd451b26580de465d59ed5389209ed191b7dbdd"}], "stats": {"total": 87, "additions": 87, "deletions": 0}, "files": [{"sha": "26e7a79d35df606e15d969c26ae9258370ccb6c3", "filename": "src/libcore/array.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/057e6d3a35a54e8b88c2cef1e6a1b9e590066276/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057e6d3a35a54e8b88c2cef1e6a1b9e590066276/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=057e6d3a35a54e8b88c2cef1e6a1b9e590066276", "patch": "@@ -148,6 +148,15 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            impl<'a, T> TryFrom<&'a [T]> for [T; $N] where T: Copy {\n+                type Error = TryFromSliceError;\n+\n+                fn try_from(slice: &[T]) -> Result<[T; $N], TryFromSliceError> {\n+                    <&Self>::try_from(slice).map(|r| *r)\n+                }\n+            }\n+\n             #[unstable(feature = \"try_from\", issue = \"33417\")]\n             impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n                 type Error = TryFromSliceError;"}, {"sha": "f6f649bc06d0199be77c7802b614499c6352fa43", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/057e6d3a35a54e8b88c2cef1e6a1b9e590066276/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057e6d3a35a54e8b88c2cef1e6a1b9e590066276/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=057e6d3a35a54e8b88c2cef1e6a1b9e590066276", "patch": "@@ -1989,6 +1989,19 @@ big endian.\n ```\n let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -2008,6 +2021,19 @@ little endian.\n ```\n let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -2037,6 +2063,19 @@ let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"bi\n         \", $le_bytes, \"\n     });\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -3719,6 +3758,19 @@ big endian.\n ```\n let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -3738,6 +3790,19 @@ little endian.\n ```\n let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -3767,6 +3832,19 @@ let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"bi\n         \", $le_bytes, \"\n     });\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]"}]}