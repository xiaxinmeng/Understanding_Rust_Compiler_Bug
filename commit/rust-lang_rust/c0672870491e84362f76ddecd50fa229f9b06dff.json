{"sha": "c0672870491e84362f76ddecd50fa229f9b06dff", "node_id": "C_kwDOAAsO6NoAKGMwNjcyODcwNDkxZTg0MzYyZjc2ZGRlY2Q1MGZhMjI5ZjliMDZkZmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-19T13:08:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-19T13:08:51Z"}, "message": "Auto merge of #97024 - lcnr:simplify_type-sus, r=<try>\n\n`simplify_type` improvements and cursed docs\n\nthe existing `TreatParams` enum pretty much mixes everything up. Not sure why this looked right to me in #94057\n\nThis also includes two changes which impact perf:\n- `ty::Projection` with inference vars shouldn't be treated as a rigid type, even if fully normalized\n- `ty::Placeholder` only unifies with itself, so actually return `Some` for them\n\nr? `@nikomatsakis`", "tree": {"sha": "2d4b8aec361303871c67fa9d0e0fea3376d1d226", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d4b8aec361303871c67fa9d0e0fea3376d1d226"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0672870491e84362f76ddecd50fa229f9b06dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0672870491e84362f76ddecd50fa229f9b06dff", "html_url": "https://github.com/rust-lang/rust/commit/c0672870491e84362f76ddecd50fa229f9b06dff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0672870491e84362f76ddecd50fa229f9b06dff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6913c7487ec8d423633cc2613a6099133194fa90", "url": "https://api.github.com/repos/rust-lang/rust/commits/6913c7487ec8d423633cc2613a6099133194fa90", "html_url": "https://github.com/rust-lang/rust/commit/6913c7487ec8d423633cc2613a6099133194fa90"}, {"sha": "db19e2bd01fc974a62784e14f291f9b00cf95836", "url": "https://api.github.com/repos/rust-lang/rust/commits/db19e2bd01fc974a62784e14f291f9b00cf95836", "html_url": "https://github.com/rust-lang/rust/commit/db19e2bd01fc974a62784e14f291f9b00cf95836"}], "stats": {"total": 149, "additions": 63, "deletions": 86}, "files": [{"sha": "b933409e98d628481db6269bac69e8f2a4c76e1b", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c0672870491e84362f76ddecd50fa229f9b06dff", "patch": "@@ -1804,7 +1804,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n-                        TreatParams::AsPlaceholders,\n+                        TreatParams::AsInfer,\n                     );\n \n                     fx_hash_map"}, {"sha": "de4cc67893b0e1f3896cf7491e8cc378bdd360e7", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 43, "deletions": 60, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=c0672870491e84362f76ddecd50fa229f9b06dff", "patch": "@@ -1,11 +1,8 @@\n use crate::mir::Mutability;\n-use crate::ty::{self, Ty, TyCtxt};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir::def_id::DefId;\n-use rustc_query_system::ich::StableHashingContext;\n use std::fmt::Debug;\n use std::hash::Hash;\n-use std::mem;\n \n use self::SimplifiedTypeGen::*;\n \n@@ -17,7 +14,7 @@ pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n /// because we sometimes need to use SimplifiedTypeGen values as stable sorting\n /// keys (in which case we use a DefPathHash as id-type) but in the general case\n /// the non-stable but fast to construct DefId-version is the better choice.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum SimplifiedTypeGen<D>\n where\n     D: Copy + Debug + Eq,\n@@ -45,34 +42,49 @@ where\n     GeneratorWitnessSimplifiedType(usize),\n     OpaqueSimplifiedType(D),\n     FunctionSimplifiedType(usize),\n-    ParameterSimplifiedType,\n+    PlaceholderSimplifiedType,\n }\n \n+/// Generic parameters are pretty much just bound variables, e.g.\n+/// the type of `fn foo<'a, T>(x: &'a T) -> u32 { ... }` can be thought of as\n+/// `for<'a, T> fn(&'a T) -> u32`.\n+///\n+/// Typecheck of `foo` has to succeed for all possible generic arguments, so\n+/// during typeck, we have to treat its generic parameters as if they\n+/// were placeholders.\n+///\n+/// But when calling `foo` we only have to provide a specific generic argument.\n+/// In that case the generic parameters are instantiated with inference variables.\n+/// As we use `simplify_type` before that instantiation happens, we just treat\n+/// generic parameters as if they were inference variables in that case.\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n pub enum TreatParams {\n-    /// Treat parameters as bound types in the given environment.\n+    /// Treat parameters as placeholders in the given environment.\n     ///\n-    /// For this to be correct the input has to be fully normalized\n-    /// in its param env as it may otherwise cause us to ignore\n-    /// potentially applying impls.\n-    AsBoundTypes,\n-    AsPlaceholders,\n+    /// Note that this also causes us to treat projections as if they were\n+    /// placeholders. This is only correct if the given projection cannot\n+    /// be normalized in the current context. Even if normalization fails,\n+    /// it may still succeed later if the projection contains any inference\n+    /// variables.\n+    AsPlaceholder,\n+    AsInfer,\n }\n \n /// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n ///\n /// The idea is to get something simple that we can use to quickly decide if two types could unify,\n-/// for example during method lookup.\n+/// for example during method lookup. If this function returns `Some(x)` it can only unify with\n+/// types for which this method returns either `Some(x)` as well or `None`.\n ///\n /// A special case here are parameters and projections, which are only injective\n-/// if they are treated as bound types.\n+/// if they are treated as placeholders.\n ///\n /// For example when storing impls based on their simplified self type, we treat\n-/// generic parameters as placeholders. We must not simplify them here,\n+/// generic parameters as if they were inference variables. We must not simplify them here,\n /// as they can unify with any other type.\n ///\n-/// With projections we have to be even more careful, as even when treating them as bound types\n-/// this is still only correct if they are fully normalized.\n+/// With projections we have to be even more careful, as treating them as placeholders\n+/// is only correct if they are fully normalized.\n ///\n /// \u00b9 meaning that if the outermost layers are different, then the whole types are also different.\n pub fn simplify_type<'tcx>(\n@@ -104,20 +116,25 @@ pub fn simplify_type<'tcx>(\n         ty::Never => Some(NeverSimplifiedType),\n         ty::Tuple(tys) => Some(TupleSimplifiedType(tys.len())),\n         ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n-        ty::Param(_) | ty::Projection(_) => match treat_params {\n-            // When treated as bound types, projections don't unify with\n-            // anything as long as they are fully normalized.\n+        ty::Placeholder(..) => Some(PlaceholderSimplifiedType),\n+        ty::Param(_) => match treat_params {\n+            TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n+            TreatParams::AsInfer => None,\n+        },\n+        ty::Projection(_) => match treat_params {\n+            // When treating `ty::Param` as a placeholder, projections also\n+            // don't unify with anything else as long as they are fully normalized.\n             //\n             // We will have to be careful with lazy normalization here.\n-            TreatParams::AsBoundTypes => {\n-                debug!(\"treating `{}` as a bound type\", ty);\n-                Some(ParameterSimplifiedType)\n+            TreatParams::AsPlaceholder if !ty.has_infer_types_or_consts() => {\n+                debug!(\"treating `{}` as a placeholder\", ty);\n+                Some(PlaceholderSimplifiedType)\n             }\n-            TreatParams::AsPlaceholders => None,\n+            TreatParams::AsPlaceholder | TreatParams::AsInfer => None,\n         },\n         ty::Opaque(def_id, _) => Some(OpaqueSimplifiedType(def_id)),\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n+        ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n     }\n }\n \n@@ -161,41 +178,7 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n             GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n             OpaqueSimplifiedType(d) => OpaqueSimplifiedType(map(d)),\n             FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n-            ParameterSimplifiedType => ParameterSimplifiedType,\n-        }\n-    }\n-}\n-\n-impl<'a, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n-where\n-    D: Copy + Debug + Eq + HashStable<StableHashingContext<'a>>,\n-{\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            BoolSimplifiedType\n-            | CharSimplifiedType\n-            | StrSimplifiedType\n-            | ArraySimplifiedType\n-            | SliceSimplifiedType\n-            | NeverSimplifiedType\n-            | ParameterSimplifiedType\n-            | MarkerTraitObjectSimplifiedType => {\n-                // nothing to do\n-            }\n-            RefSimplifiedType(m) | PtrSimplifiedType(m) => m.hash_stable(hcx, hasher),\n-            IntSimplifiedType(t) => t.hash_stable(hcx, hasher),\n-            UintSimplifiedType(t) => t.hash_stable(hcx, hasher),\n-            FloatSimplifiedType(t) => t.hash_stable(hcx, hasher),\n-            AdtSimplifiedType(d) => d.hash_stable(hcx, hasher),\n-            TupleSimplifiedType(n) => n.hash_stable(hcx, hasher),\n-            TraitSimplifiedType(d) => d.hash_stable(hcx, hasher),\n-            ClosureSimplifiedType(d) => d.hash_stable(hcx, hasher),\n-            GeneratorSimplifiedType(d) => d.hash_stable(hcx, hasher),\n-            GeneratorWitnessSimplifiedType(n) => n.hash_stable(hcx, hasher),\n-            OpaqueSimplifiedType(d) => d.hash_stable(hcx, hasher),\n-            FunctionSimplifiedType(n) => n.hash_stable(hcx, hasher),\n-            ForeignSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            PlaceholderSimplifiedType => PlaceholderSimplifiedType,\n         }\n     }\n }"}, {"sha": "cb34b64660d2b32db8deff31bb20dfbf8300d5e4", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=c0672870491e84362f76ddecd50fa229f9b06dff", "patch": "@@ -143,7 +143,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n         let impls = self.trait_impls_of(def_id);\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsPlaceholders) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsInfer) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n             }\n@@ -173,14 +173,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        // Note that we're using `TreatParams::AsBoundTypes` to query `non_blanket_impls` while using\n-        // `TreatParams::AsPlaceholders` while actually adding them.\n+        // Note that we're using `TreatParams::AsPlaceholder` to query `non_blanket_impls` while using\n+        // `TreatParams::AsInfer` while actually adding them.\n         //\n         // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n         // whose outer level is not a parameter or projection. Especially for things like\n         // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n         // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsBoundTypes) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsPlaceholder) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -240,7 +240,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n         }\n \n         if let Some(simplified_self_ty) =\n-            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsPlaceholders)\n+            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsInfer)\n         {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {"}, {"sha": "a7893c0193fae173f82f1ee0683abdeeff37f658", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=c0672870491e84362f76ddecd50fa229f9b06dff", "patch": "@@ -88,8 +88,8 @@ where\n         impl2_ref.iter().flat_map(|tref| tref.substs.types()),\n     )\n     .any(|(ty1, ty2)| {\n-        let t1 = fast_reject::simplify_type(tcx, ty1, TreatParams::AsPlaceholders);\n-        let t2 = fast_reject::simplify_type(tcx, ty2, TreatParams::AsPlaceholders);\n+        let t1 = fast_reject::simplify_type(tcx, ty1, TreatParams::AsInfer);\n+        let t2 = fast_reject::simplify_type(tcx, ty2, TreatParams::AsInfer);\n \n         if let (Some(t1), Some(t2)) = (t1, t2) {\n             // Simplified successfully"}, {"sha": "9a1128f2f28f3beb3b064a0f2998df6da8034e4a", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c0672870491e84362f76ddecd50fa229f9b06dff", "patch": "@@ -2148,13 +2148,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         let simplified_obligation_ty = fast_reject::simplify_type(\n                             self.tcx(),\n                             obligation_ty,\n-                            TreatParams::AsBoundTypes,\n-                        );\n-                        let simplified_impl_ty = fast_reject::simplify_type(\n-                            self.tcx(),\n-                            impl_ty,\n-                            TreatParams::AsPlaceholders,\n+                            TreatParams::AsPlaceholder,\n                         );\n+                        let simplified_impl_ty =\n+                            fast_reject::simplify_type(self.tcx(), impl_ty, TreatParams::AsInfer);\n \n                         simplified_obligation_ty.is_some()\n                             && simplified_impl_ty.is_some()"}, {"sha": "930c80e0abb81d5e47a3516ac686935438e796e2", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c0672870491e84362f76ddecd50fa229f9b06dff", "patch": "@@ -49,8 +49,7 @@ impl ChildrenExt<'_> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        if let Some(st) =\n-            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders)\n+        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n         {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n@@ -66,8 +65,7 @@ impl ChildrenExt<'_> for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) =\n-            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders)\n+        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n         {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n@@ -316,8 +314,7 @@ impl GraphExt for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified =\n-            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders);\n+        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer);\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}, {"sha": "0edf8fac9d66b1b52d6c6442a9995666434f947e", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=c0672870491e84362f76ddecd50fa229f9b06dff", "patch": "@@ -681,7 +681,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_for_incoherent_ty(&mut self, self_ty: Ty<'tcx>) {\n-        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsPlaceholders) else {\n+        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) else {\n             bug!(\"unexpected incoherent type: {:?}\", self_ty)\n         };\n         for &impl_def_id in self.tcx.incoherent_impls(simp) {"}, {"sha": "7d873556ab779eddef2f96c1831e6afa9f42c3e2", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c0672870491e84362f76ddecd50fa229f9b06dff", "patch": "@@ -1236,7 +1236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .into_iter()\n             .any(|info| self.associated_value(info.def_id, item_name).is_some());\n         let found_assoc = |ty: Ty<'tcx>| {\n-            simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n+            simplify_type(tcx, ty, TreatParams::AsInfer)\n                 .and_then(|simp| {\n                     tcx.incoherent_impls(simp)\n                         .iter()\n@@ -1956,7 +1956,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n             } else if let Some(simp_rcvr_ty) =\n-                simplify_type(self.tcx, rcvr_ty, TreatParams::AsBoundTypes)\n+                simplify_type(self.tcx, rcvr_ty, TreatParams::AsPlaceholder)\n             {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n@@ -1971,7 +1971,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap();\n                             let imp_simp =\n-                                simplify_type(self.tcx, imp.self_ty(), TreatParams::AsBoundTypes);\n+                                simplify_type(self.tcx, imp.self_ty(), TreatParams::AsPlaceholder);\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}, {"sha": "7a9b874b5e45643ae4e7992929cde3eea76e4b61", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0672870491e84362f76ddecd50fa229f9b06dff/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=c0672870491e84362f76ddecd50fa229f9b06dff", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> InherentCollect<'tcx> {\n                 }\n             }\n \n-            if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsPlaceholders) {\n+            if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) {\n                 self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n@@ -169,7 +169,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             }\n         }\n \n-        if let Some(simp) = simplify_type(self.tcx, ty, TreatParams::AsPlaceholders) {\n+        if let Some(simp) = simplify_type(self.tcx, ty, TreatParams::AsInfer) {\n             self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n         } else {\n             bug!(\"unexpected primitive type: {:?}\", ty);"}]}