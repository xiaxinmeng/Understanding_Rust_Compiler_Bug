{"sha": "ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMTM2M2ZmZTEyYWMxYWM3OTZhNjIwYWVmMjAwOGU0YWU2YzA0Nzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-21T03:36:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-21T03:36:30Z"}, "message": "Auto merge of #50924 - petrochenkov:spanover, r=alexcrichton\n\nlexer: Fix span override for the first token in a string\n\nPreviously due to peculiarities of `StringReader` construction something like `\"a b c d\".parse::<TokenStream>()` gave you one non-overridden span for `a` and then three correctly overridden spans for `b`, `c` and `d`.\nNow all the spans are overridden.", "tree": {"sha": "9c68fc9d3d4127faf63e439187387a8d252f4385", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c68fc9d3d4127faf63e439187387a8d252f4385"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "html_url": "https://github.com/rust-lang/rust/commit/ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba1363ffe12ac1ac796a620aef2008e4ae6c0477/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e508c420904e35098cb4f4e6f285f8920163a59", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e508c420904e35098cb4f4e6f285f8920163a59", "html_url": "https://github.com/rust-lang/rust/commit/1e508c420904e35098cb4f4e6f285f8920163a59"}, {"sha": "b4714cdf6e9caa0fc312b93917fe721f9c549426", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4714cdf6e9caa0fc312b93917fe721f9c549426", "html_url": "https://github.com/rust-lang/rust/commit/b4714cdf6e9caa0fc312b93917fe721f9c549426"}], "stats": {"total": 28, "additions": 15, "deletions": 13}, "files": [{"sha": "3d3d46555c37bcceb5fa188ec9f85947daa568dd", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba1363ffe12ac1ac796a620aef2008e4ae6c0477/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1363ffe12ac1ac796a620aef2008e4ae6c0477/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "patch": "@@ -48,7 +48,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n     }\n     write_header(class, id, &mut out).unwrap();\n \n-    let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm), sess.codemap());\n+    let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None), sess.codemap());\n     if let Err(_) = classifier.write_source(&mut out) {\n         return format!(\"<pre>{}</pre>\", src);\n     }\n@@ -68,7 +68,7 @@ pub fn render_inner_with_highlighting(src: &str) -> io::Result<String> {\n     let fm = sess.codemap().new_filemap(FileName::Custom(\"stdin\".to_string()), src.to_string());\n \n     let mut out = Vec::new();\n-    let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm), sess.codemap());\n+    let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None), sess.codemap());\n     classifier.write_source(&mut out)?;\n \n     Ok(String::from_utf8_lossy(&out).into_owned())"}, {"sha": "7ead1ceeed0ef49dd70e66cf06148713996734ef", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba1363ffe12ac1ac796a620aef2008e4ae6c0477/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1363ffe12ac1ac796a620aef2008e4ae6c0477/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "patch": "@@ -362,7 +362,7 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut\n     let src = String::from_utf8(src).unwrap();\n     let cm = CodeMap::new(sess.codemap().path_mapping().clone());\n     let filemap = cm.new_filemap(path, src);\n-    let mut rdr = lexer::StringReader::new_raw(sess, filemap);\n+    let mut rdr = lexer::StringReader::new_raw(sess, filemap, None);\n \n     let mut comments: Vec<Comment> = Vec::new();\n     let mut literals: Vec<Literal> = Vec::new();"}, {"sha": "1d7f20e69e719793236f7ee567b284f1ce9e7307", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ba1363ffe12ac1ac796a620aef2008e4ae6c0477/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1363ffe12ac1ac796a620aef2008e4ae6c0477/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "patch": "@@ -155,13 +155,15 @@ impl<'a> StringReader<'a> {\n \n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into next_pos and ch\n-    pub fn new_raw(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>) -> Self {\n-        let mut sr = StringReader::new_raw_internal(sess, filemap);\n+    pub fn new_raw(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>,\n+                   override_span: Option<Span>) -> Self {\n+        let mut sr = StringReader::new_raw_internal(sess, filemap, override_span);\n         sr.bump();\n         sr\n     }\n \n-    fn new_raw_internal(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>) -> Self {\n+    fn new_raw_internal(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>,\n+                        override_span: Option<Span>) -> Self {\n         if filemap.src.is_none() {\n             sess.span_diagnostic.bug(&format!(\"Cannot lex filemap without source: {}\",\n                                               filemap.name));\n@@ -185,12 +187,13 @@ impl<'a> StringReader<'a> {\n             token: token::Eof,\n             span: syntax_pos::DUMMY_SP,\n             open_braces: Vec::new(),\n-            override_span: None,\n+            override_span,\n         }\n     }\n \n-    pub fn new(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>) -> Self {\n-        let mut sr = StringReader::new_raw(sess, filemap);\n+    pub fn new(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>, override_span: Option<Span>)\n+               -> Self {\n+        let mut sr = StringReader::new_raw(sess, filemap, override_span);\n         if sr.advance_token().is_err() {\n             sr.emit_fatal_errors();\n             FatalError.raise();\n@@ -207,7 +210,7 @@ impl<'a> StringReader<'a> {\n             span = span.shrink_to_lo();\n         }\n \n-        let mut sr = StringReader::new_raw_internal(sess, begin.fm);\n+        let mut sr = StringReader::new_raw_internal(sess, begin.fm, None);\n \n         // Seek the lexer to the right byte range.\n         sr.save_new_lines_and_multibyte = false;\n@@ -1795,7 +1798,7 @@ mod tests {\n                  teststr: String)\n                  -> StringReader<'a> {\n         let fm = cm.new_filemap(PathBuf::from(\"zebra.rs\").into(), teststr);\n-        StringReader::new(sess, fm)\n+        StringReader::new(sess, fm, None)\n     }\n \n     #[test]"}, {"sha": "25490829f9e56d7e14eef3cc7e1939679f7b2635", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba1363ffe12ac1ac796a620aef2008e4ae6c0477/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1363ffe12ac1ac796a620aef2008e4ae6c0477/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "patch": "@@ -229,8 +229,7 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n /// Given a filemap, produce a sequence of token-trees\n pub fn filemap_to_stream(sess: &ParseSess, filemap: Lrc<FileMap>, override_span: Option<Span>)\n                          -> TokenStream {\n-    let mut srdr = lexer::StringReader::new(sess, filemap);\n-    srdr.override_span = override_span;\n+    let mut srdr = lexer::StringReader::new(sess, filemap, override_span);\n     srdr.real_token();\n     panictry!(srdr.parse_all_token_trees())\n }"}]}