{"sha": "e5fb78482372a9fce3a276a07f99ff994384a343", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZmI3ODQ4MjM3MmE5ZmNlM2EyNzZhMDdmOTlmZjk5NDM4NGEzNDM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-08T20:32:56Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-12T19:14:52Z"}, "message": "Create intermediate enum ty::ConstKind.", "tree": {"sha": "aa427076e4613873573eb3c9ff215c64b0615e11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa427076e4613873573eb3c9ff215c64b0615e11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5fb78482372a9fce3a276a07f99ff994384a343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5fb78482372a9fce3a276a07f99ff994384a343", "html_url": "https://github.com/rust-lang/rust/commit/e5fb78482372a9fce3a276a07f99ff994384a343", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5fb78482372a9fce3a276a07f99ff994384a343/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dda3ee9314cfee9c4e30a7b17dcd5ebdec081a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dda3ee9314cfee9c4e30a7b17dcd5ebdec081a7", "html_url": "https://github.com/rust-lang/rust/commit/5dda3ee9314cfee9c4e30a7b17dcd5ebdec081a7"}], "stats": {"total": 405, "additions": 205, "deletions": 200}, "files": [{"sha": "e782ec592958974d02e68977b7f519c55913a08f", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -10,7 +10,6 @@ use crate::infer::canonical::{\n     OriginalQueryValues,\n };\n use crate::infer::InferCtxt;\n-use crate::mir::interpret::ConstValue;\n use std::sync::atomic::Ordering;\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::GenericArg;\n@@ -441,7 +440,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match ct.val {\n-            ConstValue::Infer(InferConst::Var(vid)) => {\n+            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 debug!(\"canonical: const var found with vid {:?}\", vid);\n                 match self.infcx.unwrap().probe_const_var(vid) {\n                     Ok(c) => {\n@@ -465,17 +464,17 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     }\n                 }\n             }\n-            ConstValue::Infer(InferConst::Fresh(_)) => {\n+            ty::ConstKind::Infer(InferConst::Fresh(_)) => {\n                 bug!(\"encountered a fresh const during canonicalization\")\n             }\n-            ConstValue::Bound(debruijn, _) => {\n+            ty::ConstKind::Bound(debruijn, _) => {\n                 if debruijn >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n                 } else {\n                     return ct;\n                 }\n             }\n-            ConstValue::Placeholder(placeholder) => {\n+            ty::ConstKind::Placeholder(placeholder) => {\n                 return self.canonicalize_const_var(\n                     CanonicalVarInfo {\n                         kind: CanonicalVarKind::PlaceholderConst(placeholder),\n@@ -700,7 +699,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n             let var = self.canonical_var(info, const_var.into());\n             self.tcx().mk_const(\n                 ty::Const {\n-                    val: ConstValue::Bound(self.binder_index, var.into()),\n+                    val: ty::ConstKind::Bound(self.binder_index, var.into()),\n                     ty: self.fold_ty(const_var.ty),\n                 }\n             )"}, {"sha": "4e86cbb2cf6646ef5a936ca58654ac01d9e79740", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -24,7 +24,6 @@\n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{ConstVariableOrigin, ConstVariableOriginKind};\n use crate::infer::region_constraints::MemberConstraint;\n-use crate::mir::interpret::ConstValue;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_serialize::UseSpecializedDecodable;\n@@ -447,7 +446,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 };\n                 self.tcx.mk_const(\n                     ty::Const {\n-                        val: ConstValue::Placeholder(placeholder_mapped),\n+                        val: ty::ConstKind::Placeholder(placeholder_mapped),\n                         ty: self.tcx.types.err, // FIXME(const_generics)\n                     }\n                 ).into()\n@@ -510,7 +509,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                     GenericArgKind::Const(ct) => {\n                         tcx.mk_const(ty::Const {\n                             ty: ct.ty,\n-                            val: ConstValue::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n+                            val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n                         }).into()\n                     }\n                 })"}, {"sha": "825e98cedb9e07eda7f4f5cb01a8860bdd2694aa", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -16,7 +16,6 @@ use crate::infer::canonical::{\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxtBuilder;\n use crate::infer::{InferCtxt, InferOk, InferResult};\n-use crate::mir::interpret::ConstValue;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use std::fmt::Debug;\n@@ -493,7 +492,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     }\n                 }\n                 GenericArgKind::Const(result_value) => {\n-                    if let ty::Const { val: ConstValue::Bound(debrujin, b), .. } = result_value {\n+                    if let ty::Const { val: ty::ConstKind::Bound(debrujin, b), .. } = result_value {\n                         // ...in which case we would set `canonical_vars[0]` to `Some(const X)`.\n \n                         // We only allow a `ty::INNERMOST` index in substitutions."}, {"sha": "a2f0531f0af36e0150d2ef1ffd06bb33bf108801", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -33,7 +33,6 @@ use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use super::unify_key::replace_if_possible;\n \n use crate::hir::def_id::DefId;\n-use crate::mir::interpret::ConstValue;\n use crate::ty::{IntType, UintType};\n use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::ty::error::TypeError;\n@@ -137,8 +136,8 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         let a_is_expected = relation.a_is_expected();\n \n         match (a.val, b.val) {\n-            (ConstValue::Infer(InferConst::Var(a_vid)),\n-                ConstValue::Infer(InferConst::Var(b_vid))) => {\n+            (ty::ConstKind::Infer(InferConst::Var(a_vid)),\n+                ty::ConstKind::Infer(InferConst::Var(b_vid))) => {\n                 self.const_unification_table\n                     .borrow_mut()\n                     .unify_var_var(a_vid, b_vid)\n@@ -147,16 +146,16 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             }\n \n             // All other cases of inference with other variables are errors.\n-            (ConstValue::Infer(InferConst::Var(_)), ConstValue::Infer(_)) |\n-            (ConstValue::Infer(_), ConstValue::Infer(InferConst::Var(_))) => {\n-                bug!(\"tried to combine ConstValue::Infer/ConstValue::Infer(InferConst::Var)\")\n+            (ty::ConstKind::Infer(InferConst::Var(_)), ty::ConstKind::Infer(_)) |\n+            (ty::ConstKind::Infer(_), ty::ConstKind::Infer(InferConst::Var(_))) => {\n+                bug!(\"tried to combine ConstKind::Infer/ConstKind::Infer(InferConst::Var)\")\n             }\n \n-            (ConstValue::Infer(InferConst::Var(vid)), _) => {\n+            (ty::ConstKind::Infer(InferConst::Var(vid)), _) => {\n                 return self.unify_const_variable(a_is_expected, vid, b);\n             }\n \n-            (_, ConstValue::Infer(InferConst::Var(vid))) => {\n+            (_, ty::ConstKind::Infer(InferConst::Var(vid))) => {\n                 return self.unify_const_variable(!a_is_expected, vid, a);\n             }\n \n@@ -603,7 +602,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         assert_eq!(c, c2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n         match c.val {\n-            ConstValue::Infer(InferConst::Var(vid)) => {\n+            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {"}, {"sha": "32b51da920d66e722debe391980f9c8f4aa3284c", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -31,7 +31,6 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n-use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::fold::TypeFolder;\n use crate::util::nodemap::FxHashMap;\n@@ -227,7 +226,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match ct.val {\n-            ConstValue::Infer(ty::InferConst::Var(v)) => {\n+            ty::ConstKind::Infer(ty::InferConst::Var(v)) => {\n                 let opt_ct = self.infcx.const_unification_table\n                     .borrow_mut()\n                     .probe_value(v)\n@@ -240,7 +239,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     ct.ty,\n                 );\n             }\n-            ConstValue::Infer(ty::InferConst::Fresh(i)) => {\n+            ty::ConstKind::Infer(ty::InferConst::Fresh(i)) => {\n                 if i >= self.const_freshen_count {\n                     bug!(\n                         \"Encountered a freshend const with id {} \\\n@@ -252,16 +251,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 return ct;\n             }\n \n-            ConstValue::Bound(..) |\n-            ConstValue::Placeholder(_) => {\n+            ty::ConstKind::Bound(..) |\n+            ty::ConstKind::Placeholder(_) => {\n                 bug!(\"unexpected const {:?}\", ct)\n             }\n \n-            ConstValue::Param(_) |\n-            ConstValue::Scalar(_) |\n-            ConstValue::Slice { .. } |\n-            ConstValue::ByRef { .. } |\n-            ConstValue::Unevaluated(..) => {}\n+            ty::ConstKind::Param(_) |\n+            ty::ConstKind::Value(_) |\n+            ty::ConstKind::Unevaluated(..) => {}\n         }\n \n         ct.super_fold_with(self)"}, {"sha": "11f86a619b5c2a41795a882fa281288e1844b8ad", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -1,6 +1,5 @@\n use crate::ty::{self, Ty, TyCtxt, TyVid, IntVid, FloatVid, RegionVid, ConstVid};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::mir::interpret::ConstValue;\n \n use super::InferCtxt;\n use super::{RegionVariableOrigin, ConstVariableOrigin};\n@@ -198,7 +197,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ConstValue::Infer(ty::InferConst::Var(vid)), ty } = ct {\n+        if let ty::Const { val: ty::ConstKind::Infer(ty::InferConst::Var(vid)), ty } = ct {\n             if self.const_vars.0.contains(&vid) {\n                 // This variable was created during the fudging.\n                 // Recreate it with a fresh variable here."}, {"sha": "49c095c69d6c4bfacf986573fe1e290f60b65808", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -7,7 +7,6 @@ use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n use crate::infer::CombinedSnapshot;\n use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n use crate::ty::{self, Binder, TypeFoldable};\n-use crate::mir::interpret::ConstValue;\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n@@ -103,7 +102,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let fld_c = |bound_var: ty::BoundVar, ty| {\n             self.tcx.mk_const(\n                 ty::Const {\n-                    val: ConstValue::Placeholder(ty::PlaceholderConst {\n+                    val: ty::ConstKind::Placeholder(ty::PlaceholderConst {\n                         universe: next_universe,\n                         name: bound_var,\n                     }),"}, {"sha": "49fb84a8260bd3333fcbfee2c2a50ea097024505", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -14,7 +14,6 @@ use crate::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use crate::middle::free_region::RegionRelations;\n use crate::middle::lang_items;\n use crate::middle::region;\n-use crate::mir::interpret::ConstValue;\n use crate::session::config::BorrowckMode;\n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n@@ -1662,7 +1661,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } = ct {\n+        if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n                 self.infcx.const_unification_table\n                     .borrow_mut()\n                     .probe_value(*vid)"}, {"sha": "1e0feb6a7da8d97606ff91989a37caa365250ba1", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -29,7 +29,6 @@ use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::infer::{ConstVariableValue, ConstVarValue};\n-use crate::mir::interpret::ConstValue;\n use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Debug;\n \n@@ -626,7 +625,7 @@ where\n         }\n \n         match b.val {\n-            ConstValue::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n+            ty::ConstKind::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n                 // Forbid inference variables in the RHS.\n                 bug!(\"unexpected inference var {:?}\", b)\n             }\n@@ -999,13 +998,13 @@ where\n         _: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         match a.val {\n-            ConstValue::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n+            ty::ConstKind::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n                 bug!(\n                     \"unexpected inference variable encountered in NLL generalization: {:?}\",\n                     a\n                 );\n             }\n-            ConstValue::Infer(InferConst::Var(vid)) => {\n+            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val.known() {"}, {"sha": "dc54a273ed08d366c8ed89235cb0c3175e9ad7aa", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -4,7 +4,6 @@ use crate::hir::Node;\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::middle::region;\n-use crate::mir::interpret::ConstValue;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{InternalSubsts, GenericArg, SubstsRef, GenericArgKind};\n@@ -945,7 +944,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         trace!(\"checking const {:?}\", ct);\n         // Find a const parameter\n         match ct.val {\n-            ConstValue::Param(..) => {\n+            ty::ConstKind::Param(..) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ct.into()).map(|k| k.unpack()) {\n                     // Found it in the substitution list, replace with the parameter from the"}, {"sha": "613f66d7ffd7ee2422151a22fa4734ac1e82df47", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -1,6 +1,5 @@\n use super::{InferCtxt, FixupError, FixupResult, Span};\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Ty, Const, TyCtxt, TypeFoldable, InferConst};\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n@@ -230,11 +229,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n         } else {\n             let c = self.infcx.shallow_resolve(c);\n             match c.val {\n-                ConstValue::Infer(InferConst::Var(vid)) => {\n+                ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                     self.err = Some(FixupError::UnresolvedConst(vid));\n                     return self.tcx().consts.err;\n                 }\n-                ConstValue::Infer(InferConst::Fresh(_)) => {\n+                ty::ConstKind::Infer(InferConst::Fresh(_)) => {\n                     bug!(\"Unexpected const in full const resolver: {:?}\", c);\n                 }\n                 _ => {}"}, {"sha": "8ad6990a75dafde22bc5f83f394f71659ca27364", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -1,5 +1,4 @@\n use crate::ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt, InferConst};\n-use crate::mir::interpret::ConstValue;\n use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue, UnificationTable};\n use rustc_data_structures::unify::InPlace;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -180,7 +179,7 @@ pub fn replace_if_possible(\n     mut table: RefMut<'_, UnificationTable<InPlace<ty::ConstVid<'tcx>>>>,\n     c: &'tcx ty::Const<'tcx>\n ) -> &'tcx ty::Const<'tcx> {\n-    if let ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } = c {\n+    if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = c {\n         match table.probe_value(*vid).val.known() {\n             Some(c) => c,\n             None => c,"}, {"sha": "e5778528e38a2f776de4db63886fce04cb6fde2f", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -2,10 +2,7 @@ use std::fmt;\n use rustc_macros::HashStable;\n use rustc_apfloat::{Float, ieee::{Double, Single}};\n \n-use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n-use crate::ty::PlaceholderConst;\n-use crate::hir::def_id::DefId;\n-use crate::ty::{BoundVar, DebruijnIndex};\n+use crate::ty::{Ty, layout::{HasDataLayout, Size}};\n \n use super::{InterpResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n@@ -23,18 +20,6 @@ pub struct RawConst<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum ConstValue<'tcx> {\n-    /// A const generic parameter.\n-    Param(ParamConst),\n-\n-    /// Infer the value of the const.\n-    Infer(InferConst<'tcx>),\n-\n-    /// Bound const variable, used only when preparing a trait query.\n-    Bound(DebruijnIndex, BoundVar),\n-\n-    /// A placeholder const - universally quantified higher-ranked const.\n-    Placeholder(PlaceholderConst),\n-\n     /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n     ///\n     /// Not using the enum `Value` to encode that this must not be `Undef`.\n@@ -55,10 +40,6 @@ pub enum ConstValue<'tcx> {\n         /// Offset into `alloc`\n         offset: Size,\n     },\n-\n-    /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other\n-    /// variants when the code is monomorphic enough for that.\n-    Unevaluated(DefId, SubstsRef<'tcx>),\n }\n \n #[cfg(target_arch = \"x86_64\")]\n@@ -68,26 +49,21 @@ impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n     pub fn try_to_scalar(&self) -> Option<Scalar> {\n         match *self {\n-            ConstValue::Param(_) |\n-            ConstValue::Infer(_) |\n-            ConstValue::Bound(..) |\n-            ConstValue::Placeholder(_) |\n             ConstValue::ByRef { .. } |\n-            ConstValue::Unevaluated(..) |\n             ConstValue::Slice { .. } => None,\n             ConstValue::Scalar(val) => Some(val),\n         }\n     }\n-\n-    #[inline]\n-    pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n-        self.try_to_scalar()?.to_bits(size).ok()\n-    }\n-\n-    #[inline]\n-    pub fn try_to_ptr(&self) -> Option<Pointer> {\n-        self.try_to_scalar()?.to_ptr().ok()\n-    }\n+//\n+//    #[inline]\n+//    pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n+//        self.try_to_scalar()?.to_bits(size).ok()\n+//    }\n+//\n+//    #[inline]\n+//    pub fn try_to_ptr(&self) -> Option<Pointer> {\n+//        self.try_to_scalar()?.to_ptr().ok()\n+//    }\n }\n \n /// A `Scalar` represents an immediate, primitive value existing outside of a"}, {"sha": "066998a171838f3fda52a6147df4d181885b6aba", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -7,7 +7,7 @@\n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n use crate::hir::{self, InlineAsm as HirInlineAsm};\n-use crate::mir::interpret::{ConstValue, PanicInfo, Scalar};\n+use crate::mir::interpret::{PanicInfo, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -1506,10 +1506,11 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 values\n                     .iter()\n                     .map(|&u| {\n-                        tcx.mk_const(ty::Const {\n-                            val: ConstValue::Scalar(Scalar::from_uint(u, size).into()),\n-                            ty: switch_ty,\n-                        })\n+                        ty::Const::from_scalar(\n+                            tcx,\n+                            Scalar::from_uint(u, size).into(),\n+                            switch_ty,\n+                        )\n                         .to_string()\n                         .into()\n                     })"}, {"sha": "ea8a6ff2b2e527d8644c96631efee3207bcbfe88", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -1,7 +1,6 @@\n use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::ty::error::TypeError;\n use crate::ty::relate::{self, Relate, TypeRelation, RelateResult};\n-use crate::mir::interpret::ConstValue;\n \n /// A type \"A\" *matches* \"B\" if the fresh types in B could be\n /// substituted with values so as to make it equal to A. Matching is\n@@ -92,11 +91,11 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n         }\n \n         match (a.val, b.val) {\n-            (_, ConstValue::Infer(InferConst::Fresh(_))) => {\n+            (_, ty::ConstKind::Infer(InferConst::Fresh(_))) => {\n                 return Ok(a);\n             }\n \n-            (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n+            (ty::ConstKind::Infer(_), _) | (_, ty::ConstKind::Infer(_)) => {\n                 return Err(TypeError::ConstMismatch(relate::expected_found(self, &a, &b)));\n             }\n "}, {"sha": "ba014e3002b178b16adb6d3d29fa6b468635197a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -885,7 +885,7 @@ impl CanonicalUserType<'tcx> {\n                         },\n \n                         GenericArgKind::Const(ct) => match ct.val {\n-                            ConstValue::Bound(debruijn, b) => {\n+                            ty::ConstKind::Bound(debruijn, b) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(debruijn, ty::INNERMOST);\n                                 cvar == b\n@@ -986,7 +986,7 @@ impl<'tcx> CommonConsts<'tcx> {\n \n         CommonConsts {\n             err: mk_const(ty::Const {\n-                val: ConstValue::Scalar(Scalar::zst()),\n+                val: ty::ConstKind::Value(ConstValue::Scalar(Scalar::zst())),\n                 ty: types.err,\n             }),\n         }\n@@ -2534,7 +2534,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n         self.mk_const(ty::Const {\n-            val: ConstValue::Infer(InferConst::Var(v)),\n+            val: ty::ConstKind::Infer(InferConst::Var(v)),\n             ty,\n         })\n     }\n@@ -2561,7 +2561,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> &'tcx ty::Const<'tcx> {\n         self.mk_const(ty::Const {\n-            val: ConstValue::Infer(ic),\n+            val: ty::ConstKind::Infer(ic),\n             ty,\n         })\n     }\n@@ -2579,7 +2579,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty: Ty<'tcx>\n     ) -> &'tcx Const<'tcx> {\n         self.mk_const(ty::Const {\n-            val: ConstValue::Param(ParamConst { index, name }),\n+            val: ty::ConstKind::Param(ParamConst { index, name }),\n             ty,\n         })\n     }"}, {"sha": "aee0ec7806b7679f22838e05984c73348237dba1", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -1,6 +1,5 @@\n use crate::ty::subst::{SubstsRef, GenericArgKind};\n use crate::ty::{self, Ty, TypeFlags, InferConst};\n-use crate::mir::interpret::ConstValue;\n \n #[derive(Debug)]\n pub struct FlagComputation {\n@@ -232,29 +231,27 @@ impl FlagComputation {\n     fn add_const(&mut self, c: &ty::Const<'_>) {\n         self.add_ty(c.ty);\n         match c.val {\n-            ConstValue::Unevaluated(_, substs) => {\n+            ty::ConstKind::Unevaluated(_, substs) => {\n                 self.add_substs(substs);\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n             },\n-            ConstValue::Infer(infer) => {\n+            ty::ConstKind::Infer(infer) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_CT_INFER);\n                 match infer {\n                     InferConst::Fresh(_) => {}\n                     InferConst::Var(_) => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX),\n                 }\n             }\n-            ConstValue::Bound(debruijn, _) => self.add_binder(debruijn),\n-            ConstValue::Param(_) => {\n+            ty::ConstKind::Bound(debruijn, _) => self.add_binder(debruijn),\n+            ty::ConstKind::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_flags(TypeFlags::HAS_PARAMS);\n             }\n-            ConstValue::Placeholder(_) => {\n+            ty::ConstKind::Placeholder(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_flags(TypeFlags::HAS_CT_PLACEHOLDER);\n             }\n-            ConstValue::Scalar(_) => {}\n-            ConstValue::Slice { .. } => {}\n-            ConstValue::ByRef { .. } => {}\n+            ty::ConstKind::Value(_) => {}\n         }\n     }\n "}, {"sha": "f3480ce5739e9ba73cb76644cb1c871bd847be0d", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -32,7 +32,6 @@\n //! looking for, and does not need to visit anything else.\n \n use crate::hir::def_id::DefId;\n-use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Binder, Ty, TyCtxt, TypeFlags, flags::FlagComputation};\n \n use std::collections::BTreeMap;\n@@ -521,7 +520,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ConstValue::Bound(debruijn, bound_const), ty } = *ct {\n+        if let ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty } = *ct {\n             if debruijn == self.current_index {\n                 let fld_c = &mut self.fld_c;\n                 let ct = fld_c(bound_const, ty);\n@@ -568,7 +567,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let fld_t = |bound_ty| self.mk_ty(ty::Bound(ty::INNERMOST, bound_ty));\n         let fld_c = |bound_ct, ty| {\n             self.mk_const(ty::Const {\n-                val: ConstValue::Bound(ty::INNERMOST, bound_ct),\n+                val: ty::ConstKind::Bound(ty::INNERMOST, bound_ct),\n                 ty,\n             })\n         };\n@@ -801,7 +800,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ConstValue::Bound(debruijn, bound_ct), ty } = *ct {\n+        if let ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty } = *ct {\n             if self.amount == 0 || debruijn < self.current_index {\n                 ct\n             } else {\n@@ -813,7 +812,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n                     }\n                 };\n                 self.tcx.mk_const(ty::Const {\n-                    val: ConstValue::Bound(debruijn, bound_ct),\n+                    val: ty::ConstKind::Bound(debruijn, bound_ct),\n                     ty,\n                 })\n             }\n@@ -919,7 +918,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         // const, as it has types/regions embedded in a lot of other\n         // places.\n         match ct.val {\n-            ConstValue::Bound(debruijn, _) if debruijn >= self.outer_index => true,\n+            ty::ConstKind::Bound(debruijn, _) if debruijn >= self.outer_index => true,\n             _ => ct.super_visit_with(self),\n         }\n     }"}, {"sha": "8aa212ce3101c3c1e7f74a733633c9809bac4809", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -63,7 +63,7 @@ pub use self::sty::{InferTy, ParamTy, ParamConst, InferConst, ProjectionTy, Exis\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, UpvarSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TyKind, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n-pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n+pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const, ConstKind};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n pub use self::sty::{TyVid, IntVid, FloatVid, ConstVid, RegionVid};"}, {"sha": "7eb774849b1786862cb5126a8757d8e81edaa87a", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -6,7 +6,6 @@\n //! FIXME(eddyb) implement a custom `PrettyPrinter` for this.\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::ConstValue;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Const, Instance, Ty, TyCtxt};\n use rustc::{bug, hir};\n@@ -170,21 +169,16 @@ impl DefPathBasedNames<'tcx> {\n     // If `debug` is true, usually-unprintable consts (such as `Infer`) will be printed,\n     // as well as the unprintable types of constants (see `push_type_name` for more details).\n     pub fn push_const_name(&self, c: &Const<'tcx>, output: &mut String, debug: bool) {\n-        match c.val {\n-            ConstValue::Scalar(..) | ConstValue::Slice { .. } | ConstValue::ByRef { .. } => {\n-                // FIXME(const_generics): we could probably do a better job here.\n-                write!(output, \"{:?}\", c).unwrap()\n-            }\n-            _ => {\n-                if debug {\n-                    write!(output, \"{:?}\", c).unwrap()\n-                } else {\n-                    bug!(\n-                        \"DefPathBasedNames: trying to create const name for unexpected const: {:?}\",\n-                        c,\n-                    );\n-                }\n-            }\n+        if let ty::ConstKind::Value(_) = c.val {\n+            // FIXME(const_generics): we could probably do a better job here.\n+            write!(output, \"{:?}\", c).unwrap()\n+        } else if debug {\n+            write!(output, \"{:?}\", c).unwrap()\n+        } else {\n+            bug!(\n+                \"DefPathBasedNames: trying to create const name for unexpected const: {:?}\",\n+                c,\n+            );\n         }\n         output.push_str(\": \");\n         self.push_type_name(c.ty, output, debug);"}, {"sha": "c70bb2552ccdfec0a6d8a119341df53b1a26db6d", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -699,7 +699,7 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(write(\"[\"), print(ty), write(\"; \"));\n                 if self.tcx().sess.verbose() {\n                     p!(write(\"{:?}\", sz));\n-                } else if let ConstValue::Unevaluated(..) = sz.val {\n+                } else if let ty::ConstKind::Unevaluated(..) = sz.val {\n                     // do not try to evalute unevaluated constants. If we are const evaluating an\n                     // array length anon const, rustc will (with debug assertions) print the\n                     // constant's path. Which will end up here again.\n@@ -865,7 +865,7 @@ pub trait PrettyPrinter<'tcx>:\n \n         match (ct.val, &ct.ty.kind) {\n             (_,  ty::FnDef(did, substs)) => p!(print_value_path(*did, substs)),\n-            (ConstValue::Unevaluated(did, substs), _) => {\n+            (ty::ConstKind::Unevaluated(did, substs), _) => {\n                 match self.tcx().def_kind(did) {\n                     | Some(DefKind::Static)\n                     | Some(DefKind::Const)\n@@ -882,15 +882,15 @@ pub trait PrettyPrinter<'tcx>:\n                     },\n                 }\n             },\n-            (ConstValue::Infer(..), _) =>  p!(write(\"_: \"), print(ct.ty)),\n-            (ConstValue::Param(ParamConst { name, .. }), _) => p!(write(\"{}\", name)),\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Bool) =>\n+            (ty::ConstKind::Infer(..), _) =>  p!(write(\"_: \"), print(ct.ty)),\n+            (ty::ConstKind::Param(ParamConst { name, .. }), _) => p!(write(\"{}\", name)),\n+            (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Bool) =>\n                 p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" })),\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F32)) =>\n+            (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Float(ast::FloatTy::F32)) =>\n                 p!(write(\"{}f32\", Single::from_bits(data))),\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F64)) =>\n+            (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Float(ast::FloatTy::F64)) =>\n                 p!(write(\"{}f64\", Double::from_bits(data))),\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Uint(ui)) => {\n+            (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Uint(ui)) => {\n                 let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n                 let max = truncate(u128::max_value(), bit_size);\n \n@@ -901,7 +901,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"{}{}\", data, ui_str))\n                 };\n             },\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Int(i)) => {\n+            (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Int(i)) => {\n                 let bit_size = Integer::from_attr(&self.tcx(), SignedInt(*i))\n                     .size().bits() as u128;\n                 let min = 1u128 << (bit_size - 1);\n@@ -918,10 +918,10 @@ pub trait PrettyPrinter<'tcx>:\n                     _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i_str))\n                 }\n             },\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Char) =>\n+            (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Char) =>\n                 p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap())),\n-            (ConstValue::Scalar(_), ty::RawPtr(_)) => p!(write(\"{{pointer}}\")),\n-            (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::FnPtr(_)) => {\n+            (ty::ConstKind::Value(ConstValue::Scalar(_)), ty::RawPtr(_)) => p!(write(\"{{pointer}}\")),\n+            (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Ptr(ptr))), ty::FnPtr(_)) => {\n                 let instance = {\n                     let alloc_map = self.tcx().alloc_map.lock();\n                     alloc_map.unwrap_fn(ptr.alloc_id)\n@@ -931,14 +931,14 @@ pub trait PrettyPrinter<'tcx>:\n             _ => {\n                 let printed = if let ty::Ref(_, ref_ty, _) = ct.ty.kind {\n                     let byte_str = match (ct.val, &ref_ty.kind) {\n-                        (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n+                        (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Ptr(ptr))), ty::Array(t, n)) if *t == u8 => {\n                             let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n                             Some(self.tcx()\n                                 .alloc_map.lock()\n                                 .unwrap_memory(ptr.alloc_id)\n                                 .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n                         },\n-                        (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n+                        (ty::ConstKind::Value(ConstValue::Slice { data, start, end }), ty::Slice(t)) if *t == u8 => {\n                             // The `inspect` here is okay since we checked the bounds, and there are\n                             // no relocations (we have an active slice reference here). We don't use\n                             // this result to affect interpreter execution.\n@@ -956,7 +956,7 @@ pub trait PrettyPrinter<'tcx>:\n                         }\n                         p!(write(\"\\\"\"));\n                         true\n-                    } else if let (ConstValue::Slice { data, start, end }, ty::Str) =\n+                    } else if let (ty::ConstKind::Value(ConstValue::Slice { data, start, end }), ty::Str) =\n                         (ct.val, &ref_ty.kind)\n                     {\n                         // The `inspect` here is okay since we checked the bounds, and there are no"}, {"sha": "49a25347912aa37610cd74bc8794155b4f162d52", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -561,51 +561,62 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     // and those that derive both `PartialEq` and `Eq`, corresponding\n     // to `structural_match` types.\n     let new_const_val = match (eagerly_eval(a), eagerly_eval(b)) {\n-        (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n+        (ty::ConstKind::Infer(_), _) | (_, ty::ConstKind::Infer(_)) => {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n         }\n-        (ConstValue::Param(a_p), ConstValue::Param(b_p)) if a_p.index == b_p.index => {\n+        (ty::ConstKind::Param(a_p), ty::ConstKind::Param(b_p)) if a_p.index == b_p.index => {\n             return Ok(a);\n         }\n-        (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n+        (ty::ConstKind::Placeholder(p1), ty::ConstKind::Placeholder(p2)) if p1 == p2 => {\n             return Ok(a);\n         }\n-        (ConstValue::Scalar(a_val), ConstValue::Scalar(b_val)) if a.ty == b.ty => {\n-            if a_val == b_val {\n-                Ok(ConstValue::Scalar(a_val))\n-            } else if let ty::FnPtr(_) = a.ty.kind {\n-                let alloc_map = tcx.alloc_map.lock();\n-                let a_instance = alloc_map.unwrap_fn(a_val.to_ptr().unwrap().alloc_id);\n-                let b_instance = alloc_map.unwrap_fn(b_val.to_ptr().unwrap().alloc_id);\n-                if a_instance == b_instance {\n-                    Ok(ConstValue::Scalar(a_val))\n-                } else {\n-                    Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+        (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => {\n+            let new_val = match (a_val, b_val) {\n+                (ConstValue::Scalar(a_val), ConstValue::Scalar(b_val)) if a.ty == b.ty => {\n+                    if a_val == b_val {\n+                        Ok(ConstValue::Scalar(a_val))\n+                    } else if let ty::FnPtr(_) = a.ty.kind {\n+                        let alloc_map = tcx.alloc_map.lock();\n+                        let a_instance = alloc_map.unwrap_fn(a_val.to_ptr().unwrap().alloc_id);\n+                        let b_instance = alloc_map.unwrap_fn(b_val.to_ptr().unwrap().alloc_id);\n+                        if a_instance == b_instance {\n+                            Ok(ConstValue::Scalar(a_val))\n+                        } else {\n+                            Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                        }\n+                    } else {\n+                        Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                    }\n                 }\n-            } else {\n-                Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n-            }\n-        }\n \n-        (a_val @ ConstValue::Slice { .. }, b_val @ ConstValue::Slice { .. }) => {\n-            let a_bytes = get_slice_bytes(&tcx, a_val);\n-            let b_bytes = get_slice_bytes(&tcx, b_val);\n-            if a_bytes == b_bytes {\n-                Ok(a_val)\n-            } else {\n-                Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n-            }\n-        }\n+                (a_val @ ConstValue::Slice { .. }, b_val @ ConstValue::Slice { .. }) => {\n+                    let a_bytes = get_slice_bytes(&tcx, a_val);\n+                    let b_bytes = get_slice_bytes(&tcx, b_val);\n+                    if a_bytes == b_bytes {\n+                        Ok(a_val)\n+                    } else {\n+                        Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                    }\n+                }\n+\n+                // FIXME(const_generics): handle `ConstValue::ByRef`.\n \n-        // FIXME(const_generics): handle `ConstValue::ByRef`.\n+                _ =>  Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n+            };\n+\n+            match new_val {\n+                Ok(val) => Ok(ty::ConstKind::Value(val)),\n+                Err(err) => Err(err),\n+            }\n+        },\n \n         // FIXME(const_generics): this is wrong, as it is a projection\n-        (ConstValue::Unevaluated(a_def_id, a_substs),\n-            ConstValue::Unevaluated(b_def_id, b_substs)) if a_def_id == b_def_id => {\n+        (ty::ConstKind::Unevaluated(a_def_id, a_substs),\n+            ty::ConstKind::Unevaluated(b_def_id, b_substs)) if a_def_id == b_def_id => {\n             let substs =\n                 relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n-            Ok(ConstValue::Unevaluated(a_def_id, &substs))\n+            Ok(ty::ConstKind::Unevaluated(a_def_id, &substs))\n         }\n         _ =>  Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n     };"}, {"sha": "dd92898e434a8fbc0800b1b7cc625cd2b9200127", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -5,7 +5,6 @@\n \n use crate::hir::def::Namespace;\n use crate::mir::ProjectionKind;\n-use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Lift, Ty, TyCtxt, InferConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n@@ -1378,26 +1377,25 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstValue::Infer(ic) => ConstValue::Infer(ic.fold_with(folder)),\n-            ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n-            ConstValue::Unevaluated(did, substs)\n-                => ConstValue::Unevaluated(did, substs.fold_with(folder)),\n-            ConstValue::ByRef { .. } | ConstValue::Bound(..) | ConstValue::Placeholder(..)\n-            | ConstValue::Scalar(..) | ConstValue::Slice { .. } => *self,\n-\n+            ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.fold_with(folder)),\n+            ty::ConstKind::Param(p) => ty::ConstKind::Param(p.fold_with(folder)),\n+            ty::ConstKind::Unevaluated(did, substs)\n+                => ty::ConstKind::Unevaluated(did, substs.fold_with(folder)),\n+            ty::ConstKind::Value(_) | ty::ConstKind::Bound(..)\n+            | ty::ConstKind::Placeholder(..) => *self,\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ConstValue::Infer(ic) => ic.visit_with(visitor),\n-            ConstValue::Param(p) => p.visit_with(visitor),\n-            ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),\n-            ConstValue::ByRef { .. } | ConstValue::Bound(..) | ConstValue::Placeholder(_)\n-            | ConstValue::Scalar(_) | ConstValue::Slice { .. } => false,\n+            ty::ConstKind::Infer(ic) => ic.visit_with(visitor),\n+            ty::ConstKind::Param(p) => p.visit_with(visitor),\n+            ty::ConstKind::Unevaluated(_, substs) => substs.visit_with(visitor),\n+            ty::ConstKind::Value(_) | ty::ConstKind::Bound(..)\n+            | ty::ConstKind::Placeholder(_) => false,\n         }\n     }\n }"}, {"sha": "bb2fc9f013140da98457efe01705e837ca49c820", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -2257,17 +2257,17 @@ impl<'tcx> TyS<'tcx> {\n pub struct Const<'tcx> {\n     pub ty: Ty<'tcx>,\n \n-    pub val: ConstValue<'tcx>,\n+    pub val: ConstKind<'tcx>,\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Const<'_>, 40);\n+static_assert_size!(Const<'_>, 48);\n \n impl<'tcx> Const<'tcx> {\n     #[inline]\n     pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n         tcx.mk_const(Self {\n-            val: ConstValue::Scalar(val),\n+            val: ConstKind::Value(ConstValue::Scalar(val)),\n             ty,\n         })\n     }\n@@ -2317,7 +2317,7 @@ impl<'tcx> Const<'tcx> {\n         // FIXME(const_generics): this doesn't work right now,\n         // because it tries to relate an `Infer` to a `Param`.\n         match self.val {\n-            ConstValue::Unevaluated(did, substs) => {\n+            ConstKind::Unevaluated(did, substs) => {\n                 // if `substs` has no unresolved components, use and empty param_env\n                 let (param_env, substs) = param_env.with_reveal_all().and(substs).into_parts();\n                 // try to resolve e.g. associated constants to their definition on an impl\n@@ -2363,6 +2363,54 @@ impl<'tcx> Const<'tcx> {\n \n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Const<'tcx> {}\n \n+/// Represents a constant in Rust.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n+         RustcEncodable, RustcDecodable, Hash, HashStable)]\n+pub enum ConstKind<'tcx> {\n+    /// A const generic parameter.\n+    Param(ParamConst),\n+\n+    /// Infer the value of the const.\n+    Infer(InferConst<'tcx>),\n+\n+    /// Bound const variable, used only when preparing a trait query.\n+    Bound(DebruijnIndex, BoundVar),\n+\n+    /// A placeholder const - universally quantified higher-ranked const.\n+    Placeholder(ty::PlaceholderConst),\n+\n+    /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other\n+    /// variants when the code is monomorphic enough for that.\n+    Unevaluated(DefId, SubstsRef<'tcx>),\n+\n+    /// Used to hold computed value.\n+    Value(ConstValue<'tcx>),\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(ConstKind<'_>, 40);\n+\n+impl<'tcx> ConstKind<'tcx> {\n+    #[inline]\n+    pub fn try_to_scalar(&self) -> Option<Scalar> {\n+        if let ConstKind::Value(val) = self {\n+            val.try_to_scalar()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn try_to_bits(&self, size: ty::layout::Size) -> Option<u128> {\n+        self.try_to_scalar()?.to_bits(size).ok()\n+    }\n+\n+    //#[inline]\n+    //pub fn try_to_ptr(&self) -> Option<mir::interpret::Pointer> {\n+    //    self.try_to_scalar()?.to_ptr().ok()\n+    //}\n+}\n+\n /// An inference variable for a const, for use in const generics.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd,\n          Ord, RustcEncodable, RustcDecodable, Hash, HashStable)]"}, {"sha": "8ba8622704af48147bf1e1571ae41d10a16c28f7", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -4,7 +4,6 @@ use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n use crate::ty::{self, Lift, List, Ty, TyCtxt, ParamConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::mir::interpret::ConstValue;\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n \n use rustc_serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -234,7 +233,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n \n                 ty::GenericParamDefKind::Const => {\n                     tcx.mk_const(ty::Const {\n-                        val: ConstValue::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n+                        val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n                         ty: tcx.type_of(def_id),\n                     }).into()\n                 }\n@@ -578,7 +577,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n             return c;\n         }\n \n-        if let ConstValue::Param(p) = c.val {\n+        if let ty::ConstKind::Param(p) = c.val {\n             self.const_for_param(p, c)\n         } else {\n             c.super_fold_with(self)"}, {"sha": "76afba220ce44a9eb2ae358ce235e4f29f5d627b", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -12,7 +12,6 @@ use crate::ty::subst::{Subst, InternalSubsts, SubstsRef, GenericArgKind};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::TyKind::*;\n use crate::ty::layout::{Integer, IntegerExt};\n-use crate::mir::interpret::ConstValue;\n use crate::util::common::ErrorReported;\n use crate::middle::lang_items;\n \n@@ -566,7 +565,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         !impl_generics.type_param(pt, self).pure_wrt_drop\n                     }\n                     GenericArgKind::Const(&ty::Const {\n-                        val: ConstValue::Param(ref pc),\n+                        val: ty::ConstKind::Param(ref pc),\n                         ..\n                     }) => {\n                         !impl_generics.const_param(pc, self).pure_wrt_drop"}, {"sha": "8d0f9a4716247ee39145a0ed80961229b91c4d20", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -3,7 +3,6 @@\n \n use crate::ty::{self, Ty};\n use smallvec::{self, SmallVec};\n-use crate::mir::interpret::ConstValue;\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n // avoid heap allocations.\n@@ -75,7 +74,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::Placeholder(..) | ty::Bound(..) | ty::Foreign(..) => {\n         }\n         ty::Array(ty, len) => {\n-            if let ConstValue::Unevaluated(_, substs) = len.val {\n+            if let ty::ConstKind::Unevaluated(_, substs) = len.val {\n                 stack.extend(substs.types().rev());\n             }\n             stack.push(len.ty);"}, {"sha": "aa0456b78af3ed599d0a1c985ca5907c8dd16a62", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb78482372a9fce3a276a07f99ff994384a343/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=e5fb78482372a9fce3a276a07f99ff994384a343", "patch": "@@ -8,7 +8,6 @@ use std::iter::once;\n use syntax::symbol::{kw, Ident};\n use syntax_pos::Span;\n use crate::middle::lang_items;\n-use crate::mir::interpret::ConstValue;\n \n /// Returns the set of obligations needed to make `ty` well-formed.\n /// If `ty` contains unresolved inference variables, this may include\n@@ -363,7 +362,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     /// Pushes the obligations required for an array length to be WF\n     /// into `self.out`.\n     fn compute_array_len(&mut self, constant: ty::Const<'tcx>) {\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n+        if let ty::ConstKind::Unevaluated(def_id, substs) = constant.val {\n             let obligations = self.nominal_obligations(def_id, substs);\n             self.out.extend(obligations);\n "}]}