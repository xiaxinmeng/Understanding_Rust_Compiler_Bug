{"sha": "f6a57c195519d1e3e1f2f84b5793b2449f6c1625", "node_id": "C_kwDOAAsO6NoAKGY2YTU3YzE5NTUxOWQxZTNlMWYyZjg0YjU3OTNiMjQ0OWY2YzE2MjU", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-03-01T18:57:46Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-03-12T04:29:26Z"}, "message": "Move `Option::as_slice` to an always-sound implementation\n\nThis approach depends on CSE to not have any branches or selects when the guessed offset is correct -- which it always will be right now -- but to also be *sound* (just less efficient) if the layout algorithms change such that the guess is incorrect.", "tree": {"sha": "ebe6f2ba16bf6775e7ef165ad446ca56e940c250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebe6f2ba16bf6775e7ef165ad446ca56e940c250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6a57c195519d1e3e1f2f84b5793b2449f6c1625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6a57c195519d1e3e1f2f84b5793b2449f6c1625", "html_url": "https://github.com/rust-lang/rust/commit/f6a57c195519d1e3e1f2f84b5793b2449f6c1625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6a57c195519d1e3e1f2f84b5793b2449f6c1625/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5423745db8b434fcde54888b35f518f00cce00e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5423745db8b434fcde54888b35f518f00cce00e4", "html_url": "https://github.com/rust-lang/rust/commit/5423745db8b434fcde54888b35f518f00cce00e4"}], "stats": {"total": 134, "additions": 92, "deletions": 42}, "files": [{"sha": "c480b6ca4af90e1a810c8447bc58e9ee605f45ba", "filename": "library/core/src/option.rs", "status": "modified", "additions": 79, "deletions": 37, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f6a57c195519d1e3e1f2f84b5793b2449f6c1625/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a57c195519d1e3e1f2f84b5793b2449f6c1625/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=f6a57c195519d1e3e1f2f84b5793b2449f6c1625", "patch": "@@ -735,22 +735,43 @@ impl<T> Option<T> {\n         }\n     }\n \n-    const fn get_some_offset() -> isize {\n-        if mem::size_of::<Option<T>>() == mem::size_of::<T>() {\n-            // niche optimization means the `T` is always stored at the same position as the Option.\n-            0\n+    /// This is a guess at how many bytes into the option the payload can be found.\n+    ///\n+    /// For niche-optimized types it's correct because it's pigeon-holed to only\n+    /// one possible place.  For other types, it's usually correct today, but\n+    /// tweaks to the layout algorithm (particularly expansions of\n+    /// `-Z randomize-layout`) might make it incorrect at any point.\n+    ///\n+    /// It's guaranteed to be a multiple of alignment (so will always give a\n+    /// correctly-aligned location) and to be within the allocated object, so\n+    /// is valid to use with `offset` and to use for a zero-sized read.\n+    const SOME_BYTE_OFFSET_GUESS: isize = {\n+        let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n+        let payload_ref = some_uninit.as_ref().unwrap();\n+        // SAFETY: `as_ref` gives an address inside the existing `Option`,\n+        // so both pointers are derived from the same thing and the result\n+        // cannot overflow an `isize`.\n+        let offset = unsafe { <*const _>::byte_offset_from(payload_ref, &some_uninit) };\n+\n+        // The offset is into the object, so it's guaranteed to be non-negative.\n+        assert!(offset >= 0);\n+\n+        // The payload and the overall option are aligned,\n+        // so the offset will be a multiple of the alignment too.\n+        assert!((offset as usize) % mem::align_of::<T>() == 0);\n+\n+        let max_offset = mem::size_of::<Self>() - mem::size_of::<T>();\n+        if offset as usize <= max_offset {\n+            // The offset is at least inside the object, so let's try it.\n+            offset\n         } else {\n-            assert!(mem::size_of::<Option<T>>() == mem::size_of::<Option<mem::MaybeUninit<T>>>());\n-            let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n-            // SAFETY: This gets the byte offset of the `Some(_)` value following the fact that\n-            // niche optimization is not active, and thus Option<T> and Option<MaybeUninit<t>> share\n-            // the same layout.\n-            unsafe {\n-                (some_uninit.as_ref().unwrap() as *const mem::MaybeUninit<T>)\n-                    .byte_offset_from(&some_uninit as *const Option<mem::MaybeUninit<T>>)\n-            }\n+            // The offset guess is definitely wrong, so use the address\n+            // of the original option since we have it already.\n+            // This also correctly handles the case of layout-optimized enums\n+            // where `max_offset == 0` and thus this is the only possibility.\n+            0\n         }\n-    }\n+    };\n \n     /// Returns a slice of the contained value, if any. If this is `None`, an\n     /// empty slice is returned. This can be useful to have a single type of\n@@ -784,18 +805,28 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_slice(&self) -> &[T] {\n-        // SAFETY: This is sound as long as `get_some_offset` returns the\n-        // correct offset. Though in the `None` case, the slice may be located\n-        // at a pointer pointing into padding, the fact that the slice is\n-        // empty, and the padding is at a properly aligned position for a\n-        // value of that type makes it sound.\n-        unsafe {\n-            slice::from_raw_parts(\n-                (self as *const Option<T>).wrapping_byte_offset(Self::get_some_offset())\n-                    as *const T,\n-                self.is_some() as usize,\n-            )\n-        }\n+        let payload_ptr: *const T =\n+            // The goal here is that both arms here are calculating exactly\n+            // the same pointer, and thus it'll be folded away when the guessed\n+            // offset is correct, but if the guess is wrong for some reason\n+            // it'll at least still be sound, just no longer optimal.\n+            if let Some(payload) = self {\n+                payload\n+            } else {\n+                let self_ptr: *const Self = self;\n+                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n+                // such that this will be in-bounds of the object.\n+                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n+            };\n+        let len = usize::from(self.is_some());\n+\n+        // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n+        // to the payload, with a length of 1, so this is equivalent to\n+        // `slice::from_ref`, and thus is safe.\n+        // When the `Option` is `None`, the length used is 0, so to be safe it\n+        // just needs to be aligned, which it is because `&self` is aligned and\n+        // the offset used is a multiple of alignment.\n+        unsafe { slice::from_raw_parts(payload_ptr, len) }\n     }\n \n     /// Returns a mutable slice of the contained value, if any. If this is\n@@ -840,17 +871,28 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        // SAFETY: This is sound as long as `get_some_offset` returns the\n-        // correct offset. Though in the `None` case, the slice may be located\n-        // at a pointer pointing into padding, the fact that the slice is\n-        // empty, and the padding is at a properly aligned position for a\n-        // value of that type makes it sound.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                (self as *mut Option<T>).wrapping_byte_offset(Self::get_some_offset()) as *mut T,\n-                self.is_some() as usize,\n-            )\n-        }\n+        let payload_ptr: *mut T =\n+            // The goal here is that both arms here are calculating exactly\n+            // the same pointer, and thus it'll be folded away when the guessed\n+            // offset is correct, but if the guess is wrong for some reason\n+            // it'll at least still be sound, just no longer optimal.\n+            if let Some(payload) = self {\n+                payload\n+            } else {\n+                let self_ptr: *mut Self = self;\n+                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n+                // such that this will be in-bounds of the object.\n+                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n+            };\n+        let len = usize::from(self.is_some());\n+\n+        // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n+        // to the payload, with a length of 1, so this is equivalent to\n+        // `slice::from_mut`, and thus is safe.\n+        // When the `Option` is `None`, the length used is 0, so to be safe it\n+        // just needs to be aligned, which it is because `&self` is aligned and\n+        // the offset used is a multiple of alignment.\n+        unsafe { slice::from_raw_parts_mut(payload_ptr, len) }\n     }\n \n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "d735d558374082a512579cec614a142a2cfb23ec", "filename": "tests/codegen/option-as-slice.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6a57c195519d1e3e1f2f84b5793b2449f6c1625/tests%2Fcodegen%2Foption-as-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a57c195519d1e3e1f2f84b5793b2449f6c1625/tests%2Fcodegen%2Foption-as-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Foption-as-slice.rs?ref=f6a57c195519d1e3e1f2f84b5793b2449f6c1625", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O\n+// compile-flags: -O -Z randomize-layout=no\n // only-x86_64\n \n #![crate_type = \"lib\"]\n@@ -12,17 +12,25 @@ use core::option::Option;\n // CHECK-LABEL: @u64_opt_as_slice\n #[no_mangle]\n pub fn u64_opt_as_slice(o: &Option<u64>) -> &[u64] {\n-    // CHECK: start:\n     // CHECK-NOT: select\n-    // CHECK: ret\n+    // CHECK-NOT: br\n+    // CHECK-NOT: switch\n+    // CHECK-NOT: icmp\n     o.as_slice()\n }\n \n // CHECK-LABEL: @nonzero_u64_opt_as_slice\n #[no_mangle]\n pub fn nonzero_u64_opt_as_slice(o: &Option<NonZeroU64>) -> &[NonZeroU64] {\n-    // CHECK: start:\n     // CHECK-NOT: select\n-    // CHECK: ret\n+    // CHECK-NOT: br\n+    // CHECK-NOT: switch\n+    // CHECK-NOT: icmp\n+    // CHECK: %[[NZ:.+]] = icmp ne i64 %{{.+}}, 0\n+    // CHECK-NEXT: zext i1 %[[NZ]] to i64\n+    // CHECK-NOT: select\n+    // CHECK-NOT: br\n+    // CHECK-NOT: switch\n+    // CHECK-NOT: icmp\n     o.as_slice()\n }"}]}