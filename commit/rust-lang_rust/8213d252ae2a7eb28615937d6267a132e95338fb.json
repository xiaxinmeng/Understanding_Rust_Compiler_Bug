{"sha": "8213d252ae2a7eb28615937d6267a132e95338fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMTNkMjUyYWUyYTdlYjI4NjE1OTM3ZDYyNjdhMTMyZTk1MzM4ZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-09T11:41:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-09T11:41:26Z"}, "message": "Auto merge of #3861 - flip1995:rollup, r=flip1995\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #3851 (Refactor: Extract `trait_ref_of_method` function)\n - #3852 (Refactor: Cleanup one part of assign_ops lint)\n - #3857 (Document match_path, improve match_qpath docs)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7b63a55c43bbf290641c32ab2456589aeb784c31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b63a55c43bbf290641c32ab2456589aeb784c31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8213d252ae2a7eb28615937d6267a132e95338fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8213d252ae2a7eb28615937d6267a132e95338fb", "html_url": "https://github.com/rust-lang/rust/commit/8213d252ae2a7eb28615937d6267a132e95338fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8213d252ae2a7eb28615937d6267a132e95338fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "html_url": "https://github.com/rust-lang/rust/commit/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e"}, {"sha": "c32135a87f96ec8e4721cd2563ee71ccef061246", "url": "https://api.github.com/repos/rust-lang/rust/commits/c32135a87f96ec8e4721cd2563ee71ccef061246", "html_url": "https://github.com/rust-lang/rust/commit/c32135a87f96ec8e4721cd2563ee71ccef061246"}], "stats": {"total": 181, "additions": 107, "deletions": 74}, "files": [{"sha": "9e0b87bc37775b538446d7d180fe840293195250", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8213d252ae2a7eb28615937d6267a132e95338fb/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213d252ae2a7eb28615937d6267a132e95338fb/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=8213d252ae2a7eb28615937d6267a132e95338fb", "patch": "@@ -1,4 +1,6 @@\n-use crate::utils::{get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, SpanlessEq};\n+use crate::utils::{\n+    get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n+};\n use crate::utils::{higher, sugg};\n use if_chain::if_chain;\n use rustc::hir;\n@@ -68,52 +70,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n         match &expr.node {\n             hir::ExprKind::AssignOp(op, lhs, rhs) => {\n                 if let hir::ExprKind::Binary(binop, l, r) = &rhs.node {\n-                    if op.node == binop.node {\n-                        let lint = |assignee: &hir::Expr, rhs_other: &hir::Expr| {\n-                            span_lint_and_then(\n-                                cx,\n-                                MISREFACTORED_ASSIGN_OP,\n-                                expr.span,\n-                                \"variable appears on both sides of an assignment operation\",\n-                                |db| {\n-                                    if let (Some(snip_a), Some(snip_r)) =\n-                                        (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span))\n-                                    {\n-                                        let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n-                                        let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n-                                        let long =\n-                                            format!(\"{} = {}\", snip_a, sugg::make_binop(higher::binop(op.node), a, r));\n-                                        db.span_suggestion(\n-                                            expr.span,\n-                                            &format!(\n-                                                \"Did you mean {} = {} {} {} or {}? Consider replacing it with\",\n-                                                snip_a,\n-                                                snip_a,\n-                                                op.node.as_str(),\n-                                                snip_r,\n-                                                long\n-                                            ),\n-                                            format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                        db.span_suggestion(\n-                                            expr.span,\n-                                            \"or\",\n-                                            long,\n-                                            Applicability::MachineApplicable, // snippet\n-                                        );\n-                                    }\n-                                },\n-                            );\n-                        };\n-                        // lhs op= l op r\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n-                            lint(lhs, r);\n-                        }\n-                        // lhs op= l commutative_op r\n-                        if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n-                            lint(lhs, l);\n-                        }\n+                    if op.node != binop.node {\n+                        return;\n+                    }\n+                    // lhs op= l op r\n+                    if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n+                    }\n+                    // lhs op= l commutative_op r\n+                    if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n                     }\n                 }\n             },\n@@ -140,13 +106,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                         };\n                                         // check that we are not inside an `impl AssignOp` of this exact operation\n                                         let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n-                                        let parent_impl = cx.tcx.hir().get_parent_item(parent_fn);\n-                                        // the crate node is the only one that is not in the map\n                                         if_chain! {\n-                                            if parent_impl != hir::CRATE_HIR_ID;\n-                                            if let hir::Node::Item(item) = cx.tcx.hir().get_by_hir_id(parent_impl);\n-                                            if let hir::ItemKind::Impl(_, _, _, _, Some(trait_ref), _, _) =\n-                                                &item.node;\n+                                            if let Some(trait_ref) = trait_ref_of_method(cx, parent_fn);\n                                             if trait_ref.path.def.def_id() == trait_id;\n                                             then { return; }\n                                         }\n@@ -234,6 +195,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     }\n }\n \n+fn lint_misrefactored_assign_op(\n+    cx: &LateContext<'_, '_>,\n+    expr: &hir::Expr,\n+    op: hir::BinOp,\n+    rhs: &hir::Expr,\n+    assignee: &hir::Expr,\n+    rhs_other: &hir::Expr,\n+) {\n+    span_lint_and_then(\n+        cx,\n+        MISREFACTORED_ASSIGN_OP,\n+        expr.span,\n+        \"variable appears on both sides of an assignment operation\",\n+        |db| {\n+            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n+                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n+                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n+                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(higher::binop(op.node), a, r));\n+                db.span_suggestion(\n+                    expr.span,\n+                    &format!(\n+                        \"Did you mean {} = {} {} {} or {}? Consider replacing it with\",\n+                        snip_a,\n+                        snip_a,\n+                        op.node.as_str(),\n+                        snip_r,\n+                        long\n+                    ),\n+                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                    Applicability::MachineApplicable,\n+                );\n+                db.span_suggestion(\n+                    expr.span,\n+                    \"or\",\n+                    long,\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            }\n+        },\n+    );\n+}\n+\n fn is_commutative(op: hir::BinOpKind) -> bool {\n     use rustc::hir::BinOpKind::*;\n     match op {"}, {"sha": "5bc949a6688adff8625961945e514363f92608ab", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8213d252ae2a7eb28615937d6267a132e95338fb/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213d252ae2a7eb28615937d6267a132e95338fb/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=8213d252ae2a7eb28615937d6267a132e95338fb", "patch": "@@ -1,5 +1,4 @@\n-use crate::utils::{is_entrypoint_fn, span_lint};\n-use if_chain::if_chain;\n+use crate::utils::{is_entrypoint_fn, span_lint, trait_ref_of_method};\n use rustc::hir;\n use rustc::hir::intravisit::FnKind;\n use rustc::hir::{Body, Constness, FnDecl, HirId};\n@@ -96,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingConstForFn {\n                 }\n             },\n             FnKind::Method(_, sig, ..) => {\n-                if is_trait_method(cx, hir_id) || already_const(sig.header) {\n+                if trait_ref_of_method(cx, hir_id).is_some() || already_const(sig.header) {\n                     return;\n                 }\n             },\n@@ -115,18 +114,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingConstForFn {\n     }\n }\n \n-fn is_trait_method(cx: &LateContext<'_, '_>, hir_id: HirId) -> bool {\n-    // Get the implemented trait for the current function\n-    let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n-    if_chain! {\n-        if parent_impl != hir::CRATE_HIR_ID;\n-        if let hir::Node::Item(item) = cx.tcx.hir().get_by_hir_id(parent_impl);\n-        if let hir::ItemKind::Impl(_, _, _, _, Some(_trait_ref), _, _) = &item.node;\n-        then { return true; }\n-    }\n-    false\n-}\n-\n // We don't have to lint on something that's already `const`\n fn already_const(header: hir::FnHeader) -> bool {\n     header.constness == Constness::Const"}, {"sha": "76ca1dc284827f8db4ecec3527637e976f942c29", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8213d252ae2a7eb28615937d6267a132e95338fb/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213d252ae2a7eb28615937d6267a132e95338fb/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=8213d252ae2a7eb28615937d6267a132e95338fb", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{get_trait_def_id, span_lint};\n+use crate::utils::{get_trait_def_id, span_lint, trait_ref_of_method};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n@@ -177,12 +177,9 @@ fn check_binop<'a>(\n \n     // Get the actually implemented trait\n     let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n-    let parent_impl = cx.tcx.hir().get_parent_item(parent_fn);\n \n     if_chain! {\n-        if parent_impl != hir::CRATE_HIR_ID;\n-        if let hir::Node::Item(item) = cx.tcx.hir().get_by_hir_id(parent_impl);\n-        if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n+        if let Some(trait_ref) = trait_ref_of_method(cx, parent_fn);\n         if let Some(idx) = trait_ids.iter().position(|&tid| tid == trait_ref.path.def.def_id());\n         if binop != expected_ops[idx];\n         then{"}, {"sha": "2e341bc74353367a42e3162e8ade38ddfa152831", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8213d252ae2a7eb28615937d6267a132e95338fb/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213d252ae2a7eb28615937d6267a132e95338fb/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8213d252ae2a7eb28615937d6267a132e95338fb", "patch": "@@ -190,7 +190,10 @@ pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n     }\n }\n \n-/// Match a `Path` against a slice of segment string literals.\n+/// Match a `QPath` against a slice of segment string literals.\n+///\n+/// There is also `match_path` if you are dealing with a `rustc::hir::Path` instead of a\n+/// `rustc::hir::QPath`.\n ///\n /// # Examples\n /// ```rust,ignore\n@@ -210,6 +213,22 @@ pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n     }\n }\n \n+/// Match a `Path` against a slice of segment string literals.\n+///\n+/// There is also `match_qpath` if you are dealing with a `rustc::hir::QPath` instead of a\n+/// `rustc::hir::Path`.\n+///\n+/// # Examples\n+///\n+/// ```rust,ignore\n+/// if match_path(&trait_ref.path, &paths::HASH) {\n+///     // This is the `std::hash::Hash` trait.\n+/// }\n+///\n+/// if match_path(ty_path, &[\"rustc\", \"lint\", \"Lint\"]) {\n+///     // This is a `rustc::lint::Lint`.\n+/// }\n+/// ```\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n     path.segments\n         .iter()\n@@ -301,6 +320,33 @@ pub fn implements_trait<'a, 'tcx>(\n         .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n }\n \n+/// Get the `hir::TraitRef` of the trait the given method is implemented for\n+///\n+/// Use this if you want to find the `TraitRef` of the `Add` trait in this example:\n+///\n+/// ```rust\n+/// struct Point(isize, isize);\n+///\n+/// impl std::ops::Add for Point {\n+///     type Output = Self;\n+///\n+///     fn add(self, other: Self) -> Self {\n+///         Point(0, 0)\n+///     }\n+/// }\n+/// ```\n+pub fn trait_ref_of_method(cx: &LateContext<'_, '_>, hir_id: HirId) -> Option<TraitRef> {\n+    // Get the implemented trait for the current function\n+    let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n+    if_chain! {\n+        if parent_impl != hir::CRATE_HIR_ID;\n+        if let hir::Node::Item(item) = cx.tcx.hir().get_by_hir_id(parent_impl);\n+        if let hir::ItemKind::Impl(_, _, _, _, trait_ref, _, _) = &item.node;\n+        then { return trait_ref.clone(); }\n+    }\n+    None\n+}\n+\n /// Check whether this type implements Drop.\n pub fn has_drop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.ty_adt_def() {"}]}