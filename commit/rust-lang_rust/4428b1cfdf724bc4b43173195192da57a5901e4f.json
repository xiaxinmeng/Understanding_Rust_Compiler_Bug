{"sha": "4428b1cfdf724bc4b43173195192da57a5901e4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MjhiMWNmZGY3MjRiYzRiNDMxNzMxOTUxOTJkYTU3YTU5MDFlNGY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-07T21:48:24Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-08T02:25:00Z"}, "message": "Refactor away separate tracking of used_public and used_reexport.\n\nNameBinding now encodes these directly with binding.is_public() and (binding.is_public() && binding.is_import()) (respectively)", "tree": {"sha": "fa3c993a4a8d307a5c5e050359246887e9f289d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa3c993a4a8d307a5c5e050359246887e9f289d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4428b1cfdf724bc4b43173195192da57a5901e4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4428b1cfdf724bc4b43173195192da57a5901e4f", "html_url": "https://github.com/rust-lang/rust/commit/4428b1cfdf724bc4b43173195192da57a5901e4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4428b1cfdf724bc4b43173195192da57a5901e4f/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e24c7410f47d5a69ab9bd69b06e4999e0e6bea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e24c7410f47d5a69ab9bd69b06e4999e0e6bea3", "html_url": "https://github.com/rust-lang/rust/commit/2e24c7410f47d5a69ab9bd69b06e4999e0e6bea3"}], "stats": {"total": 85, "additions": 37, "deletions": 48}, "files": [{"sha": "20663a1e12cea6b6174d75f1e9ea5c4b06e24230", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4428b1cfdf724bc4b43173195192da57a5901e4f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4428b1cfdf724bc4b43173195192da57a5901e4f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4428b1cfdf724bc4b43173195192da57a5901e4f", "patch": "@@ -1311,15 +1311,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                            name);\n                     return Indeterminate;\n                 }\n-                Success((binding, used_proxy)) => {\n+                Success(binding) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n                     if let Some(module_def) = binding.module() {\n                         search_module = module_def;\n \n                         // Keep track of the closest private module used\n                         // when resolving this import chain.\n-                        if !used_proxy && !search_module.is_public {\n+                        if !binding.is_public() {\n                             if let Some(did) = search_module.def_id() {\n                                 closest_private = LastMod(DependsOn(did));\n                             }\n@@ -1410,7 +1410,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 debug!(\"(resolving module path for import) indeterminate; bailing\");\n                                 return Indeterminate;\n                             }\n-                            Success((binding, _)) => match binding.module() {\n+                            Success(binding) => match binding.module() {\n                                 Some(containing_module) => {\n                                     search_module = containing_module;\n                                     start_index = 1;\n@@ -1444,7 +1444,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      name: Name,\n                                      namespace: Namespace,\n                                      record_used: bool)\n-                                     -> ResolveResult<(&'a NameBinding<'a>, bool)> {\n+                                     -> ResolveResult<&'a NameBinding<'a>> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n                name,\n                namespace,\n@@ -1466,10 +1466,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"(resolving item in lexical scope) indeterminate higher scope; bailing\");\n                     return Indeterminate;\n                 }\n-                Success((binding, used_reexport)) => {\n+                Success(binding) => {\n                     // We found the module.\n                     debug!(\"(resolving item in lexical scope) found name in module, done\");\n-                    return Success((binding, used_reexport));\n+                    return Success(binding);\n                 }\n             }\n \n@@ -1565,16 +1565,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Attempts to resolve the supplied name in the given module for the\n     /// given namespace. If successful, returns the binding corresponding to\n     /// the name.\n-    ///\n-    /// The boolean returned on success is an indicator of whether this lookup\n-    /// passed through a public re-export proxy.\n     fn resolve_name_in_module(&mut self,\n                               module_: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n                               allow_private_imports: bool,\n                               record_used: bool)\n-                              -> ResolveResult<(&'a NameBinding<'a>, bool)> {\n+                              -> ResolveResult<&'a NameBinding<'a>> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                name,\n                module_to_string(&*module_));\n@@ -1590,7 +1587,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     self.used_crates.insert(krate);\n                 }\n             }\n-            return Success((binding, false));\n+            return Success(binding);\n         }\n \n         // Check the list of resolved imports.\n@@ -1605,7 +1602,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if record_used {\n                         self.record_import_use(name, namespace, &import_resolution);\n                     }\n-                    return Success((binding, true));\n+                    return Success(binding);\n                 }\n             }\n             Some(..) | None => {} // Continue.\n@@ -2636,7 +2633,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        -> BareIdentifierPatternResolution {\n         let module = self.current_module;\n         match self.resolve_item_in_lexical_scope(module, name, ValueNS, true) {\n-            Success((binding, _)) => {\n+            Success(binding) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n                        name,\n                        binding);\n@@ -2796,7 +2793,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module = self.current_module;\n         let name = identifier.unhygienic_name;\n         match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n-            Success((binding, _)) => binding.def().map(LocalDef::from_def),\n+            Success(binding) => binding.def().map(LocalDef::from_def),\n             Failed(Some((span, msg))) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 None\n@@ -2934,7 +2931,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         let def = match result {\n-            Success((binding, _)) => {\n+            Success(binding) => {\n                 let (def, lp) = binding.def_and_lp();\n                 (def, last_private.or(lp))\n             }\n@@ -2990,7 +2987,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let name = segments.last().unwrap().identifier.name;\n         match self.resolve_name_in_module(containing_module, name, namespace, false, true) {\n-            Success((binding, _)) => {\n+            Success(binding) => {\n                 let (def, lp) = binding.def_and_lp();\n                 Some((def, last_private.or(lp)))\n             }\n@@ -3028,11 +3025,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             if let AnonymousModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n-                if let Success((binding, _)) = self.resolve_name_in_module(module,\n-                                                                           ident.unhygienic_name,\n-                                                                           namespace,\n-                                                                           true,\n-                                                                           true) {\n+                if let Success(binding) = self.resolve_name_in_module(module,\n+                                                                      ident.unhygienic_name,\n+                                                                      namespace,\n+                                                                      true,\n+                                                                      true) {\n                     if let Some(def) = binding.def() {\n                         return Some(LocalDef::from_def(def));\n                     }"}, {"sha": "54dcd0001c4a5ee409be361f19af8874d7fafde4", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4428b1cfdf724bc4b43173195192da57a5901e4f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4428b1cfdf724bc4b43173195192da57a5901e4f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=4428b1cfdf724bc4b43173195192da57a5901e4f", "patch": "@@ -371,14 +371,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     }\n \n     /// Resolves the name in the namespace of the module because it is being imported by\n-    /// importing_module. Returns the name bindings defining the name\n-    /// and whether or not the name was imported.\n+    /// importing_module. Returns the name bindings defining the name.\n     fn resolve_name_in_module(&mut self,\n                               module: Module<'b>, // Module containing the name\n                               name: Name,\n                               ns: Namespace,\n                               importing_module: Module<'b>) // Module importing the name\n-                              -> (ResolveResult<&'b NameBinding<'b>>, bool) {\n+                              -> ResolveResult<&'b NameBinding<'b>> {\n         build_reduced_graph::populate_module_if_necessary(self.resolver, module);\n         if let Some(name_binding) = module.get_child(name, ns) {\n             if name_binding.is_extern_crate() {\n@@ -387,32 +386,32 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     self.resolver.used_crates.insert(krate);\n                 }\n             }\n-            return (Success(name_binding), false)\n+            return Success(name_binding);\n         }\n \n         // If there is an unresolved glob at this point in the containing module, bail out.\n         // We don't know enough to be able to resolve the name.\n         if module.pub_glob_count.get() > 0 {\n-            return (Indeterminate, false);\n+            return Indeterminate;\n         }\n \n         match module.import_resolutions.borrow().get(&(name, ns)) {\n             // The containing module definitely doesn't have an exported import with the\n             // name in question. We can therefore accurately report that names are unbound.\n-            None => (Failed(None), false),\n+            None => Failed(None),\n \n             // The name is an import which has been fully resolved, so we just follow it.\n             Some(resolution) if resolution.outstanding_references == 0 => {\n                 // Import resolutions must be declared with \"pub\" in order to be exported.\n                 if !resolution.is_public {\n-                    return (Failed(None), false);\n+                    return Failed(None);\n                 }\n \n                 if let Some(binding) = resolution.binding {\n                     self.resolver.record_import_use(name, ns, &resolution);\n-                    (Success(binding), true)\n+                    Success(binding)\n                 } else {\n-                    (Failed(None), false)\n+                    Failed(None)\n                 }\n             }\n \n@@ -427,8 +426,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             // In this case we continue as if we resolved the import and let\n             // check_for_conflicts_between_imports_and_items handle the conflict\n             Some(_) => match (importing_module.def_id(), module.def_id()) {\n-                (Some(id1), Some(id2)) if id1 == id2 => (Failed(None), false),\n-                _ => (Indeterminate, false)\n+                (Some(id1), Some(id2)) if id1 == id2 => Failed(None),\n+                _ => Indeterminate\n             },\n         }\n     }\n@@ -460,13 +459,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n-        let (value_result, value_used_reexport) =\n+        let value_result =\n             self.resolve_name_in_module(target_module, source, ValueNS, module_);\n-        let (type_result, type_used_reexport) =\n+        let type_result =\n             self.resolve_name_in_module(target_module, source, TypeNS, module_);\n \n         match (&value_result, &type_result) {\n-            (&Success(name_binding), _) if !value_used_reexport &&\n+            (&Success(name_binding), _) if !name_binding.is_import() &&\n                                            directive.is_public &&\n                                            !name_binding.is_public() => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n@@ -477,7 +476,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success(name_binding)) if !type_used_reexport && directive.is_public => {\n+            (_, &Success(name_binding)) if !name_binding.is_import() && directive.is_public => {\n                 if !name_binding.is_public() {\n                     let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                     let note_msg =\n@@ -521,14 +520,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => (),\n         }\n \n-        let mut value_used_public = false;\n-        let mut type_used_public = false;\n-\n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n \n         {\n-            let mut check_and_write_import = |namespace, result, used_public: &mut bool| {\n+            let mut check_and_write_import = |namespace, result| {\n                 let result: &ResolveResult<&NameBinding> = result;\n \n                 let import_resolution = import_resolutions.get_mut(&(target, namespace)).unwrap();\n@@ -557,7 +553,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         import_resolution.is_public = directive.is_public;\n \n                         self.add_export(module_, target, &import_resolution);\n-                        *used_public = name_binding.is_public();\n                     }\n                     Failed(_) => {\n                         // Continue.\n@@ -572,8 +567,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                                    directive.span,\n                                                                    (target, namespace));\n             };\n-            check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n-            check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n+            check_and_write_import(ValueNS, &value_result);\n+            check_and_write_import(TypeNS, &type_result);\n         }\n \n         if let (&Failed(_), &Failed(_)) = (&value_result, &type_result) {\n@@ -583,9 +578,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             return Failed(Some((directive.span, msg)));\n         }\n \n-        let value_used_public = value_used_reexport || value_used_public;\n-        let type_used_public = type_used_reexport || type_used_public;\n-\n         let value_def_and_priv = {\n             let import_resolution_value = import_resolutions.get_mut(&(target, ValueNS)).unwrap();\n             assert!(import_resolution_value.outstanding_references >= 1);\n@@ -596,7 +588,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             // purposes it's good enough to just favor one over the other.\n             import_resolution_value.binding.as_ref().map(|binding| {\n                 let def = binding.def().unwrap();\n-                let last_private = if value_used_public { lp } else { DependsOn(def.def_id()) };\n+                let last_private = if binding.is_public() { lp } else { DependsOn(def.def_id()) };\n                 (def, last_private)\n             })\n         };\n@@ -608,7 +600,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             import_resolution_type.binding.as_ref().map(|binding| {\n                 let def = binding.def().unwrap();\n-                let last_private = if type_used_public { lp } else { DependsOn(def.def_id()) };\n+                let last_private = if binding.is_public() { lp } else { DependsOn(def.def_id()) };\n                 (def, last_private)\n             })\n         };"}]}