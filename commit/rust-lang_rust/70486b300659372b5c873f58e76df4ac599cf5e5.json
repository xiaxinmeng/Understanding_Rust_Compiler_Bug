{"sha": "70486b300659372b5c873f58e76df4ac599cf5e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNDg2YjMwMDY1OTM3MmI1Yzg3M2Y1OGU3NmRmNGFjNTk5Y2Y1ZTU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-01T22:28:11Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-01T22:28:11Z"}, "message": "Merge pull request #527 from karyon/master\n\nAdd \"warn/allow by default\" to lint descriptions", "tree": {"sha": "6d3d5279c383f901eb7dd2f98cadb3560152980a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d3d5279c383f901eb7dd2f98cadb3560152980a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70486b300659372b5c873f58e76df4ac599cf5e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70486b300659372b5c873f58e76df4ac599cf5e5", "html_url": "https://github.com/rust-lang/rust/commit/70486b300659372b5c873f58e76df4ac599cf5e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70486b300659372b5c873f58e76df4ac599cf5e5/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "261bed1f8e4717228d5270133522f65da9ced034", "url": "https://api.github.com/repos/rust-lang/rust/commits/261bed1f8e4717228d5270133522f65da9ced034", "html_url": "https://github.com/rust-lang/rust/commit/261bed1f8e4717228d5270133522f65da9ced034"}, {"sha": "f89e4005784abfe0b71a2c24fbd2fa007e57a61a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f89e4005784abfe0b71a2c24fbd2fa007e57a61a", "html_url": "https://github.com/rust-lang/rust/commit/f89e4005784abfe0b71a2c24fbd2fa007e57a61a"}], "stats": {"total": 49, "additions": 25, "deletions": 24}, "files": [{"sha": "f0dbf390ebb3d1320231a4dcf218145db2587046", "filename": "src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -8,7 +8,7 @@ use syntax::attr::*;\n use syntax::ast::{Attribute, MetaList, MetaWord};\n use utils::{in_macro, match_path, span_lint, BEGIN_UNWIND};\n \n-/// **What it does:** This lint warns on items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.\n+/// **What it does:** This lint `Warn`s on items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.\n ///\n /// **Why is this bad?** While there are valid uses of this annotation (and once you know when to use it, by all means `allow` this lint), it's a common newbie-mistake to pepper one's code with it.\n ///"}, {"sha": "03265635b1d8dde11f3c762f2cecc14eb0033a8b", "filename": "src/block_in_if_condition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblock_in_if_condition.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::{LateLintPass, LateContext, LintArray, LintPass};\n use rustc_front::intravisit::{Visitor, walk_expr};\n use utils::*;\n \n-/// **What it does:** This lint checks for `if` conditions that use blocks to contain an expression.\n+/// **What it does:** This lint checks for `if` conditions that use blocks to contain an expression. It is `Warn` by default.\n ///\n /// **Why is this bad?** It isn't really rust style, same as using parentheses to contain expressions.\n ///\n@@ -15,7 +15,7 @@ declare_lint! {\n     \"braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\"\n }\n \n-/// **What it does:** This lint checks for `if` conditions that use blocks containing statements, or conditions that use closures with blocks.\n+/// **What it does:** This lint checks for `if` conditions that use blocks containing statements, or conditions that use closures with blocks. It is `Warn` by default.\n ///\n /// **Why is this bad?** Using blocks in the condition makes it hard to read.\n ///"}, {"sha": "4b6a8258dbe58ab930d21e33e49da65031fedd2e", "filename": "src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -14,11 +14,11 @@ use utils::span_lint;\n \n pub struct EscapePass;\n \n-/// **What it does:** This lint checks for usage of `Box<T>` where an unboxed `T` would work fine\n+/// **What it does:** This lint checks for usage of `Box<T>` where an unboxed `T` would work fine. It is `Warn` by default.\n ///\n-/// **Why is this bad?** This is an unnecessary allocation, and bad for performance\n+/// **Why is this bad?** This is an unnecessary allocation, and bad for performance. It is only necessary to allocate if you wish to move the box into something.\n ///\n-/// It is only necessary to allocate if you wish to move the box into something.\n+/// **Known problems:** None\n ///\n /// **Example:**\n ///"}, {"sha": "9f103f4e7a80448504baf56b0c136473fb359640", "filename": "src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -50,7 +50,7 @@ declare_lint!{ pub EXPLICIT_ITER_LOOP, Warn,\n declare_lint!{ pub ITER_NEXT_LOOP, Warn,\n                \"for-looping over `_.next()` which is probably not intended\" }\n \n-/// **What it does:** This lint detects `loop + match` combinations that are easier written as a `while let` loop.\n+/// **What it does:** This lint detects `loop + match` combinations that are easier written as a `while let` loop. It is `Warn` by default.\n ///\n /// **Why is this bad?** The `while let` loop is usually shorter and more readable\n ///\n@@ -85,7 +85,7 @@ declare_lint!{ pub UNUSED_COLLECT, Warn,\n                \"`collect()`ing an iterator without using the result; this is usually better \\\n                 written as a for loop\" }\n \n-/// **What it does:** This lint checks for loops over ranges `x..y` where both `x` and `y` are constant and `x` is greater or equal to `y`, unless the range is reversed or has a negative `.step_by(_)`.\n+/// **What it does:** This lint checks for loops over ranges `x..y` where both `x` and `y` are constant and `x` is greater or equal to `y`, unless the range is reversed or has a negative `.step_by(_)`. It is `Warn` by default.\n ///\n /// **Why is it bad?** Such loops will either be skipped or loop until wrap-around (in debug code, this may `panic!()`). Both options are probably not intended.\n ///"}, {"sha": "ef992ad086cb42e5f221ee23f385ee594275e3a9", "filename": "src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -8,7 +8,7 @@ use utils::{walk_ptrs_ty, walk_ptrs_ty_depth};\n ///\n /// **Why is this bad?** It makes the code less readable.\n ///\n-/// **Known problems:** False negative: The lint currently misses mapping `Clone::clone` directly. Issue #436 is tracking this.\n+/// **Known problems:** None\n ///\n /// **Example:** `x.map(|e| e.clone());`\n declare_lint!(pub MAP_CLONE, Warn,"}, {"sha": "b63e839612c0e105d3bacc1c4444a7b9a57adf5f", "filename": "src/minmax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -8,7 +8,7 @@ use consts::{Constant, constant_simple};\n use utils::{match_def_path, span_lint};\n use self::MinMax::{Min, Max};\n \n-/// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to clamp values, but switched so that the result is constant.\n+/// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to clamp values, but switched so that the result is constant. It is `Warn` by default.\n ///\n /// **Why is this bad?** This is in all probability not the intended outcome. At the least it hurts readability of the code.\n ///"}, {"sha": "92276961d11c634d468df6f7b05cbd8a4694a8bc", "filename": "src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -281,7 +281,7 @@ impl LateLintPass for ModuloOne {\n     }\n }\n \n-/// **What it does:** This lint checks for patterns in the form `name @ _`.\n+/// **What it does:** This lint checks for patterns in the form `name @ _`. It is `Warn` by default.\n ///\n /// **Why is this bad?** It's almost always more readable to just use direct bindings.\n ///"}, {"sha": "ddfd9ddcc13a23b7e1635fc94aab44babd74d582", "filename": "src/mut_reference.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -4,7 +4,7 @@ use utils::span_lint;\n use rustc::middle::ty::{TypeAndMut, TypeVariants, MethodCall, TyS};\n use syntax::ptr::P;\n \n-/// **What it does:** This lint detects giving a mutable reference to a function that only requires an immutable reference.\n+/// **What it does:** This lint detects giving a mutable reference to a function that only requires an immutable reference. It is `Warn` by default.\n ///\n /// **Why is this bad?** The immutable reference rules out all other references to the value. Also the code misleads about the intent of the call site.\n ///\n@@ -36,7 +36,7 @@ impl LateLintPass for UnnecessaryMutPassed {\n                 match borrowed_table.node_types.get(&fn_expr.id) {\n                     Some(function_type) => {\n                         if let ExprPath(_, ref path) = fn_expr.node {\n-                            check_arguments(cx, &arguments, function_type, \n+                            check_arguments(cx, &arguments, function_type,\n                                             &format!(\"{}\", path));\n                         }\n                     }\n@@ -50,7 +50,7 @@ impl LateLintPass for UnnecessaryMutPassed {\n             ExprMethodCall(ref name, _, ref arguments) => {\n                 let method_call = MethodCall::expr(e.id);\n                 match borrowed_table.method_map.get(&method_call) {\n-                    Some(method_type) => check_arguments(cx, &arguments, method_type.ty, \n+                    Some(method_type) => check_arguments(cx, &arguments, method_type.ty,\n                                                          &format!(\"{}\", name.node.as_str())),\n                     None => unreachable!(), // Just like above, this should never happen.\n                 };\n@@ -68,9 +68,9 @@ fn check_arguments(cx: &LateContext, arguments: &[P<Expr>], type_definition: &Ty\n                 TypeVariants::TyRef(_, TypeAndMut {mutbl: MutImmutable, ..}) |\n                 TypeVariants::TyRawPtr(TypeAndMut {mutbl: MutImmutable, ..}) => {\n                     if let ExprAddrOf(MutMutable, _) = argument.node {\n-                        span_lint(cx, UNNECESSARY_MUT_PASSED, \n+                        span_lint(cx, UNNECESSARY_MUT_PASSED,\n                                   argument.span, &format!(\"The function/method \\\"{}\\\" \\\n-                                  doesn't need a mutable reference\", \n+                                  doesn't need a mutable reference\",\n                                   name));\n                     }\n                 }"}, {"sha": "3aae9fd0d6c33346951e10ca3be8a737d6607c32", "filename": "src/precedence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -4,7 +4,7 @@ use syntax::ast::*;\n \n use utils::{span_lint, snippet};\n \n-/// **What it does:** This lint checks for operations where precedence may be unclear and `Warn`'s about them by default, suggesting to add parentheses. Currently it catches the following:\n+/// **What it does:** This lint checks for operations where precedence may be unclear and `Warn`s about them by default, suggesting to add parentheses. Currently it catches the following:\n /// * mixed usage of arithmetic and bit shifting/combining operators without parentheses\n /// * a \"negative\" numeric literal (which is really a unary `-` followed by a numeric literal) followed by a method call\n ///\n@@ -33,17 +33,17 @@ impl EarlyLintPass for Precedence {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if !is_bit_op(op) { return; }\n             match (is_arith_expr(left), is_arith_expr(right)) {\n-                (true, true) =>  span_lint(cx, PRECEDENCE, expr.span, \n+                (true, true) =>  span_lint(cx, PRECEDENCE, expr.span,\n                     &format!(\"operator precedence can trip the unwary. \\\n                          Consider parenthesizing your expression:\\\n                          `({}) {} ({})`\", snippet(cx, left.span, \"..\"),\n                          op.to_string(), snippet(cx, right.span, \"..\"))),\n-                (true, false) => span_lint(cx, PRECEDENCE, expr.span, \n+                (true, false) => span_lint(cx, PRECEDENCE, expr.span,\n                     &format!(\"operator precedence can trip the unwary. \\\n                          Consider parenthesizing your expression:\\\n                          `({}) {} {}`\", snippet(cx, left.span, \"..\"),\n                          op.to_string(), snippet(cx, right.span, \"..\"))),\n-                (false, true) => span_lint(cx, PRECEDENCE, expr.span, \n+                (false, true) => span_lint(cx, PRECEDENCE, expr.span,\n                     &format!(\"operator precedence can trip the unwary. \\\n                          Consider parenthesizing your expression:\\\n                          `{} {} ({})`\", snippet(cx, left.span, \"..\"),"}, {"sha": "d60a045aa7539993ddc0181682f1bc9642337eda", "filename": "src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -11,7 +11,7 @@ use eq_op::is_exp_equal;\n use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n use utils::STRING_PATH;\n \n-/// **What it does:** This lint matches code of the form `x = x + y` (without `let`!)\n+/// **What it does:** This lint matches code of the form `x = x + y` (without `let`!). It is `Allow` by default.\n ///\n /// **Why is this bad?** Because this expression needs another copy as opposed to `x.push_str(y)` (in practice LLVM will usually elide it, though). Despite [llogiq](https://github.com/llogiq)'s reservations, this lint also is `allow` by default, as some people opine that it's more readable.\n ///"}, {"sha": "f332659188b472301c171ad15f2e30551db93da6", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -17,7 +17,7 @@ use utils::{LL_PATH, VEC_PATH};\n #[allow(missing_copy_implementations)]\n pub struct TypePass;\n \n-/// **What it does:** This lint checks for use of `Box<Vec<_>>` anywhere in the code.\n+/// **What it does:** This lint checks for use of `Box<Vec<_>>` anywhere in the code. It is `Warn` by default.\n ///\n /// **Why is this bad?** `Vec` already keeps its contents in a separate area on the heap. So if you `Box` it, you just add another level of indirection without any benefit whatsoever.\n ///\n@@ -26,7 +26,8 @@ pub struct TypePass;\n /// **Example:** `struct X { values: Box<Vec<Foo>> }`\n declare_lint!(pub BOX_VEC, Warn,\n               \"usage of `Box<Vec<T>>`, vector elements are already on the heap\");\n-/// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or a `VecDeque` (formerly called `RingBuf`).\n+\n+/// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or a `VecDeque` (formerly called `RingBuf`). It is `Warn` by default.\n ///\n /// **Why is this bad?** Gankro says:\n ///"}, {"sha": "5a4d3931606f8e1ebcd72fd083fe8682b30095e3", "filename": "src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70486b300659372b5c873f58e76df4ac599cf5e5/src%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fzero_div_zero.rs?ref=70486b300659372b5c873f58e76df4ac599cf5e5", "patch": "@@ -9,7 +9,7 @@ use consts::{Constant, constant_simple, FloatWidth};\n /// 0.0/0.0 with std::f32::NaN or std::f64::NaN, depending on the precision.\n pub struct ZeroDivZeroPass;\n \n-/// **What it does:** This lint checks for `0.0 / 0.0`\n+/// **What it does:** This lint checks for `0.0 / 0.0`. It is `Warn` by default.\n ///\n /// **Why is this bad?** It's less readable than `std::f32::NAN` or `std::f64::NAN`\n ///"}]}