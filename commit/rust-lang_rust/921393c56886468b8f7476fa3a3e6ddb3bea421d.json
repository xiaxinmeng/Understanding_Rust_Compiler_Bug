{"sha": "921393c56886468b8f7476fa3a3e6ddb3bea421d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMTM5M2M1Njg4NjQ2OGI4Zjc0NzZmYTNhM2U2ZGRiM2JlYTQyMWQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-08T00:13:29Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-08T02:08:19Z"}, "message": "Change the self def_id to a self_info in typeck, and inherit\n\nThat is, treat `self` as if it has dynamic scope. This seems to\nbe harmless, and prevents an ICE as per #3563", "tree": {"sha": "05c9482a8e6c6d50dbe5c226f1998adf4030e61d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05c9482a8e6c6d50dbe5c226f1998adf4030e61d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/921393c56886468b8f7476fa3a3e6ddb3bea421d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/921393c56886468b8f7476fa3a3e6ddb3bea421d", "html_url": "https://github.com/rust-lang/rust/commit/921393c56886468b8f7476fa3a3e6ddb3bea421d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/921393c56886468b8f7476fa3a3e6ddb3bea421d/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb9458e1ec6278e3b43a88b3404b2682d4b9bb01", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9458e1ec6278e3b43a88b3404b2682d4b9bb01", "html_url": "https://github.com/rust-lang/rust/commit/fb9458e1ec6278e3b43a88b3404b2682d4b9bb01"}], "stats": {"total": 256, "additions": 248, "deletions": 8}, "files": [{"sha": "ce9a9e3783db701783d769190e71a80ab0a324eb", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=921393c56886468b8f7476fa3a3e6ddb3bea421d", "patch": "@@ -178,7 +178,10 @@ pub struct fn_ctxt {\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n     // (and with any functions whose environment is being captured).\n-    self_impl_def_id: Option<ast::def_id>,\n+\n+    // Refers to whichever `self` is in scope, even this fn_ctxt is\n+    // for a nested closure that captures `self`\n+    self_info: Option<self_info>,\n     ret_ty: ty::t,\n     // Used by loop bodies that return from the outer function\n     indirect_ret_ty: Option<ty::t>,\n@@ -227,7 +230,7 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n     @fn_ctxt {\n-        self_impl_def_id: None,\n+        self_info: None,\n         ret_ty: rty,\n         indirect_ret_ty: None,\n         purity: ast::pure_fn,\n@@ -320,7 +323,7 @@ fn check_fn(ccx: @crate_ctxt,\n         } else { None };\n \n         @fn_ctxt {\n-            self_impl_def_id: self_info.map(|self_info| self_info.def_id),\n+            self_info: self_info,\n             ret_ty: ret_ty,\n             indirect_ret_ty: indirect_ret_ty,\n             purity: purity,\n@@ -1553,7 +1556,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         fcx.write_ty(expr.id, fty);\n \n-        check_fn(fcx.ccx, None, &fn_ty, decl, body,\n+        // We inherit the same self info as the enclosing scope,\n+        // since the function we're checking might capture `self`\n+        check_fn(fcx.ccx, fcx.self_info, &fn_ty, decl, body,\n                  fn_kind, Some(fcx));\n     }\n "}, {"sha": "ccd0066de28c16fac7983af3a6995ad2d5d1a33d", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=921393c56886468b8f7476fa3a3e6ddb3bea421d", "patch": "@@ -737,15 +737,16 @@ impl infer_ctxt {\n     fn type_error_message(sp: span, mk_msg: fn(~str) -> ~str,\n                           actual_ty: ty::t, err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n+        let mut actual_sty = ty::get(copy actual_ty);\n \n         // Don't report an error if actual type is ty_err.\n-        match ty::get(actual_ty).sty {\n+        match actual_sty.sty {\n             ty::ty_err => return,\n             // Should really not report an error if the type\n             // has ty_err anywhere as a component, but that's\n             // annoying since we haven't written a visitor for\n             // ty::t yet\n-            ty::ty_fn(fty) => match ty::get(fty.sig.output).sty {\n+            ty::ty_fn(ref fty) => match ty::get(fty.sig.output).sty {\n                 ty::ty_err => return,\n                 _ => ()\n             },"}, {"sha": "9f7a0745c3b1ba14c514548694cecd3d81b130b7", "filename": "src/test/compile-fail/issue-3563.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs?ref=921393c56886468b8f7476fa3a3e6ddb3bea421d", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n trait A {\n   fn a(&self) {\n-    || self.b()\n+      || self.b() //~ ERROR type `&self/self` does not implement any method in scope named `b`\n   }\n }\n+fn main() {}", "previous_filename": "src/test/run-pass/issue-3563.rs"}, {"sha": "aa4598fc90b300b909fb9e12e3d408b7fcaf80e4", "filename": "src/test/run-pass/issue-3563-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs?ref=921393c56886468b8f7476fa3a3e6ddb3bea421d", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(default_methods)]\n+trait Canvas {\n+    fn add_point(point: &int);\n+    fn add_points(shapes: &[int]) {\n+        for shapes.each |pt| {\n+            self.add_point(pt)\n+        }\n+    }\n+\n+}\n+\n+fn main() {}"}, {"sha": "4517ce770ae40927b997a2fb07c1b0074a327018", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/921393c56886468b8f7476fa3a3e6ddb3bea421d/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=921393c56886468b8f7476fa3a3e6ddb3bea421d", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ASCII art shape renderer.\n+// Demonstrates traits, impls, operator overloading, non-copyable struct, unit testing.\n+// To run execute: rustc --test shapes.rs && ./shapes\n+\n+// Rust's core library is tightly bound to the language itself so it is automatically linked in.\n+// However the std library is designed to be optional (for code that must run on constrained\n+//  environments like embedded devices or special environments like kernel code) so it must\n+// be explicitly linked in.\n+extern mod std;\n+\n+// Extern mod controls linkage. Use controls the visibility of names to modules that are\n+// already linked in. Using WriterUtil allows us to use the write_line method.\n+use io::WriterUtil;\n+\n+// Represents a position on a canvas.\n+struct Point\n+{\n+    x: int,\n+    y: int,\n+}\n+\n+// Represents an offset on a canvas. (This has the same structure as a Point.\n+// but different semantics).\n+struct Size\n+{\n+    width: int,\n+    height: int,\n+}\n+\n+struct Rect\n+{\n+    top_left: Point,\n+    size: Size,\n+}\n+\n+// TODO: operators\n+\n+// Contains the information needed to do shape rendering via ASCII art.\n+struct AsciiArt\n+{\n+    width: uint,\n+    height: uint,\n+    priv fill: char,\n+    priv lines: ~[~[mut char]],\n+\n+    // This struct can be quite large so we'll disable copying: developers need\n+    // to either pass these structs around via borrowed pointers or move them.\n+    drop {}\n+}\n+\n+// It's common to define a constructor sort of function to create struct instances.\n+// If there is a canonical constructor it is typically named the same as the type.\n+// Other constructor sort of functions are typically named from_foo, from_bar, etc. \n+fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt\n+{\n+    // Use an anonymous function to build a vector of vectors containing\n+    // blank characters for each position in our canvas.\n+    let lines = do vec::build_sized(height)\n+        |push|\n+        {\n+            for height.times\n+            {\n+                let mut line = ~[];   \n+                vec::grow_set(&mut line, width-1, &'.', '.');\n+                push(vec::to_mut(line));\n+            }\n+        };\n+\n+    // Rust code often returns values by omitting the trailing semi-colon\n+    // instead of using an explicit return statement.\n+    AsciiArt {width: width, height: height, fill: fill, lines: lines}\n+}\n+\n+// Methods particular to the AsciiArt struct.\n+impl AsciiArt\n+{\n+    fn add_pt(x: int, y: int)\n+    {\n+        if x >= 0 && x < self.width as int\n+        {\n+            if y >= 0 && y < self.height as int\n+            {\n+                // Note that numeric types don't implicitly convert to each other.\n+                let v = y as uint;\n+                let h = x as uint;\n+\n+                // Vector subscripting will normally copy the element, but &v[i]\n+                // will return a reference which is what we need because the\n+                // element is:\n+                // 1) potentially large\n+                // 2) needs to be modified\n+                let row = &self.lines[v];\n+                row[h] = self.fill;\n+            }\n+        }\n+    }\n+}\n+\n+// Allows AsciiArt to be converted to a string using the libcore ToStr trait.\n+// Note that the %s fmt! specifier will not call this automatically.\n+impl AsciiArt : ToStr\n+{\n+    pure fn to_str() -> ~str\n+    {\n+        // Convert each line into a string.\n+        let lines = do self.lines.map |line| {str::from_chars(*line)};\n+\n+        // Concatenate the lines together using a new-line.\n+        str::connect(lines, \"\\n\")\n+    }\n+}\n+\n+// This is similar to an interface in other languages: it defines a protocol which\n+// developers can implement for arbitrary concrete types.\n+#[allow(default_methods)]\n+trait Canvas\n+{\n+    fn add_point(shape: Point);\n+    fn add_rect(shape: Rect);\n+\n+    // Unlike interfaces traits support default implementations.\n+    // Got an ICE as soon as I added this method.\n+    fn add_points(shapes: &[Point])\n+    {\n+        for shapes.each |pt| {self.add_point(*pt)};\n+    }\n+}\n+\n+// Here we provide an implementation of the Canvas methods for AsciiArt.\n+// Other implementations could also be provided (e.g. for PDF or Apple's Quartz)\n+// and code can use them polymorphically via the Canvas trait.\n+impl AsciiArt : Canvas\n+{\n+    fn add_point(shape: Point)\n+    {\n+        self.add_pt(shape.x, shape.y);\n+    }\n+\n+    fn add_rect(shape: Rect)\n+    {\n+        // Add the top and bottom lines.\n+        for int::range(shape.top_left.x, shape.top_left.x + shape.size.width)\n+        |x|\n+        {\n+            self.add_pt(x, shape.top_left.y);\n+            self.add_pt(x, shape.top_left.y + shape.size.height - 1);\n+        }\n+\n+        // Add the left and right lines.\n+        for int::range(shape.top_left.y, shape.top_left.y + shape.size.height)\n+        |y|\n+        {\n+            self.add_pt(shape.top_left.x, y);\n+            self.add_pt(shape.top_left.x + shape.size.width - 1, y);\n+        }\n+    }\n+}\n+\n+// Rust's unit testing framework is currently a bit under-developed so we'll use\n+// this little helper.\n+pub fn check_strs(actual: &str, expected: &str) -> bool\n+{\n+    if actual != expected\n+    {\n+        io::stderr().write_line(fmt!(\"Found:\\n%s\\nbut expected\\n%s\", actual, expected));\n+        return false;\n+    }\n+    return true;\n+}\n+\n+\n+fn test_ascii_art_ctor()\n+{\n+    let art = AsciiArt(3, 3, '*');\n+    assert check_strs(art.to_str(), \"...\\n...\\n...\");\n+}\n+\n+\n+fn test_add_pt()\n+{\n+    let art = AsciiArt(3, 3, '*');\n+    art.add_pt(0, 0);\n+    art.add_pt(0, -10);\n+    art.add_pt(1, 2);\n+    assert check_strs(art.to_str(), \"*..\\n...\\n.*.\");\n+}\n+\n+\n+fn test_shapes()\n+{\n+    let art = AsciiArt(4, 4, '*');\n+    art.add_rect(Rect {top_left: Point {x: 0, y: 0}, size: Size {width: 4, height: 4}});\n+    art.add_point(Point {x: 2, y: 2});\n+    assert check_strs(art.to_str(), \"****\\n*..*\\n*.**\\n****\");\n+}\n+\n+fn main() {\n+    test_ascii_art_ctor();\n+    test_add_pt();\n+    test_shapes();\n+}\n+"}]}