{"sha": "3ff4d56650bf5f7a57d11f3666fb429f0b00b18f", "node_id": "C_kwDOAAsO6NoAKDNmZjRkNTY2NTBiZjVmN2E1N2QxMWYzNjY2ZmI0MjlmMGIwMGIxOGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T02:23:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T02:23:27Z"}, "message": "Auto merge of #108262 - ChrisDenton:libntdll, r=Mark-Simulacrum\n\nDistribute libntdll.a with windows-gnu toolchains\n\nThis allows the OS loader to load essential functions (e.g. read/write file) at load time instead of lazily doing so at runtime.\n\nr? libs", "tree": {"sha": "f055f8e8dad46366d71184fa59d46fe55e5963e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f055f8e8dad46366d71184fa59d46fe55e5963e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f", "html_url": "https://github.com/rust-lang/rust/commit/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "822c10feb7d594f324d0160bef47ed999769a789", "url": "https://api.github.com/repos/rust-lang/rust/commits/822c10feb7d594f324d0160bef47ed999769a789", "html_url": "https://github.com/rust-lang/rust/commit/822c10feb7d594f324d0160bef47ed999769a789"}, {"sha": "154f5d7f7160bdfcc29e2356423d25b52741b579", "url": "https://api.github.com/repos/rust-lang/rust/commits/154f5d7f7160bdfcc29e2356423d25b52741b579", "html_url": "https://github.com/rust-lang/rust/commit/154f5d7f7160bdfcc29e2356423d25b52741b579"}], "stats": {"total": 232, "additions": 114, "deletions": 118}, "files": [{"sha": "1f4092ad73847c0977f22cccf4e0a00d9005a8ee", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=3ff4d56650bf5f7a57d11f3666fb429f0b00b18f", "patch": "@@ -296,7 +296,6 @@ pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n \n pub const STATUS_PENDING: NTSTATUS = 0x103 as _;\n pub const STATUS_END_OF_FILE: NTSTATUS = 0xC0000011_u32 as _;\n-pub const STATUS_NOT_IMPLEMENTED: NTSTATUS = 0xC0000002_u32 as _;\n \n // Equivalent to the `NT_SUCCESS` C preprocessor macro.\n // See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n@@ -1282,6 +1281,46 @@ extern \"system\" {\n     ) -> NTSTATUS;\n }\n \n+#[link(name = \"ntdll\")]\n+extern \"system\" {\n+    pub fn NtCreateFile(\n+        FileHandle: *mut HANDLE,\n+        DesiredAccess: ACCESS_MASK,\n+        ObjectAttributes: *const OBJECT_ATTRIBUTES,\n+        IoStatusBlock: *mut IO_STATUS_BLOCK,\n+        AllocationSize: *mut i64,\n+        FileAttributes: ULONG,\n+        ShareAccess: ULONG,\n+        CreateDisposition: ULONG,\n+        CreateOptions: ULONG,\n+        EaBuffer: *mut c_void,\n+        EaLength: ULONG,\n+    ) -> NTSTATUS;\n+    pub fn NtReadFile(\n+        FileHandle: BorrowedHandle<'_>,\n+        Event: HANDLE,\n+        ApcRoutine: Option<IO_APC_ROUTINE>,\n+        ApcContext: *mut c_void,\n+        IoStatusBlock: &mut IO_STATUS_BLOCK,\n+        Buffer: *mut crate::mem::MaybeUninit<u8>,\n+        Length: ULONG,\n+        ByteOffset: Option<&LARGE_INTEGER>,\n+        Key: Option<&ULONG>,\n+    ) -> NTSTATUS;\n+    pub fn NtWriteFile(\n+        FileHandle: BorrowedHandle<'_>,\n+        Event: HANDLE,\n+        ApcRoutine: Option<IO_APC_ROUTINE>,\n+        ApcContext: *mut c_void,\n+        IoStatusBlock: &mut IO_STATUS_BLOCK,\n+        Buffer: *const u8,\n+        Length: ULONG,\n+        ByteOffset: Option<&LARGE_INTEGER>,\n+        Key: Option<&ULONG>,\n+    ) -> NTSTATUS;\n+    pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;\n+}\n+\n // Functions that aren't available on every version of Windows that we support,\n // but we still use them and just provide some form of a fallback implementation.\n compat_fn_with_fallback! {\n@@ -1322,52 +1361,6 @@ compat_fn_optional! {\n compat_fn_with_fallback! {\n     pub static NTDLL: &CStr = ansi_str!(\"ntdll\");\n \n-    pub fn NtCreateFile(\n-        FileHandle: *mut HANDLE,\n-        DesiredAccess: ACCESS_MASK,\n-        ObjectAttributes: *const OBJECT_ATTRIBUTES,\n-        IoStatusBlock: *mut IO_STATUS_BLOCK,\n-        AllocationSize: *mut i64,\n-        FileAttributes: ULONG,\n-        ShareAccess: ULONG,\n-        CreateDisposition: ULONG,\n-        CreateOptions: ULONG,\n-        EaBuffer: *mut c_void,\n-        EaLength: ULONG\n-    ) -> NTSTATUS {\n-        STATUS_NOT_IMPLEMENTED\n-    }\n-    pub fn NtReadFile(\n-        FileHandle: BorrowedHandle<'_>,\n-        Event: HANDLE,\n-        ApcRoutine: Option<IO_APC_ROUTINE>,\n-        ApcContext: *mut c_void,\n-        IoStatusBlock: &mut IO_STATUS_BLOCK,\n-        Buffer: *mut crate::mem::MaybeUninit<u8>,\n-        Length: ULONG,\n-        ByteOffset: Option<&LARGE_INTEGER>,\n-        Key: Option<&ULONG>\n-    ) -> NTSTATUS {\n-        STATUS_NOT_IMPLEMENTED\n-    }\n-    pub fn NtWriteFile(\n-        FileHandle: BorrowedHandle<'_>,\n-        Event: HANDLE,\n-        ApcRoutine: Option<IO_APC_ROUTINE>,\n-        ApcContext: *mut c_void,\n-        IoStatusBlock: &mut IO_STATUS_BLOCK,\n-        Buffer: *const u8,\n-        Length: ULONG,\n-        ByteOffset: Option<&LARGE_INTEGER>,\n-        Key: Option<&ULONG>\n-    ) -> NTSTATUS {\n-        STATUS_NOT_IMPLEMENTED\n-    }\n-    pub fn RtlNtStatusToDosError(\n-        Status: NTSTATUS\n-    ) -> ULONG {\n-        Status as ULONG\n-    }\n     pub fn NtCreateKeyedEvent(\n         KeyedEventHandle: LPHANDLE,\n         DesiredAccess: ACCESS_MASK,"}, {"sha": "dceb4bd1b893c9711dcc683315470d2a1e887cf9", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=3ff4d56650bf5f7a57d11f3666fb429f0b00b18f", "patch": "@@ -210,6 +210,8 @@ fn make_win_dist(\n         rustc_dlls.push(\"libgcc_s_seh-1.dll\");\n     }\n \n+    // Libraries necessary to link the windows-gnu toolchains.\n+    // System libraries will be preferred if they are available (see #67429).\n     let target_libs = [\n         //MinGW libs\n         \"libgcc.a\",\n@@ -223,6 +225,7 @@ fn make_win_dist(\n         \"libmoldname.a\",\n         \"libpthread.a\",\n         //Windows import libs\n+        //This should contain only the set of libraries necessary to link the standard library.\n         \"libadvapi32.a\",\n         \"libbcrypt.a\",\n         \"libcomctl32.a\",\n@@ -236,6 +239,7 @@ fn make_win_dist(\n         \"libkernel32.a\",\n         \"libmsimg32.a\",\n         \"libmsvcrt.a\",\n+        \"libntdll.a\",\n         \"libodbc32.a\",\n         \"libole32.a\",\n         \"liboleaut32.a\","}, {"sha": "7e2051fc98a0ee8ed2f5c65d5874dd4aa88d16aa", "filename": "src/tools/miri/src/shims/windows/dlsym.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs?ref=3ff4d56650bf5f7a57d11f3666fb429f0b00b18f", "patch": "@@ -1,5 +1,4 @@\n use rustc_middle::mir;\n-use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use log::trace;\n@@ -11,7 +10,6 @@ use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n-    NtWriteFile,\n     SetThreadDescription,\n     WaitOnAddress,\n     WakeByAddressSingle,\n@@ -23,7 +21,6 @@ impl Dlsym {\n     pub fn from_str<'tcx>(name: &str) -> InterpResult<'tcx, Option<Dlsym>> {\n         Ok(match name {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n-            \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n             \"SetThreadDescription\" => Some(Dlsym::SetThreadDescription),\n             \"WaitOnAddress\" => Some(Dlsym::WaitOnAddress),\n             \"WakeByAddressSingle\" => Some(Dlsym::WakeByAddressSingle),\n@@ -49,72 +46,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.check_abi(abi, Abi::System { unwind: false })?;\n \n         match dlsym {\n-            Dlsym::NtWriteFile => {\n-                if !this.frame_in_std() {\n-                    throw_unsup_format!(\n-                        \"`NtWriteFile` support is crude and just enough for stdout to work\"\n-                    );\n-                }\n-\n-                let [\n-                    handle,\n-                    _event,\n-                    _apc_routine,\n-                    _apc_context,\n-                    io_status_block,\n-                    buf,\n-                    n,\n-                    byte_offset,\n-                    _key,\n-                ] = check_arg_count(args)?;\n-                let handle = this.read_target_isize(handle)?;\n-                let buf = this.read_pointer(buf)?;\n-                let n = this.read_scalar(n)?.to_u32()?;\n-                let byte_offset = this.read_target_usize(byte_offset)?; // is actually a pointer\n-                let io_status_block = this.deref_operand(io_status_block)?;\n-\n-                if byte_offset != 0 {\n-                    throw_unsup_format!(\n-                        \"`NtWriteFile` `ByteOffset` paremeter is non-null, which is unsupported\"\n-                    );\n-                }\n-\n-                let written = if handle == -11 || handle == -12 {\n-                    // stdout/stderr\n-                    use std::io::{self, Write};\n-\n-                    let buf_cont =\n-                        this.read_bytes_ptr_strip_provenance(buf, Size::from_bytes(u64::from(n)))?;\n-                    let res = if this.machine.mute_stdout_stderr {\n-                        Ok(buf_cont.len())\n-                    } else if handle == -11 {\n-                        io::stdout().write(buf_cont)\n-                    } else {\n-                        io::stderr().write(buf_cont)\n-                    };\n-                    // We write at most `n` bytes, which is a `u32`, so we cannot have written more than that.\n-                    res.ok().map(|n| u32::try_from(n).unwrap())\n-                } else {\n-                    throw_unsup_format!(\n-                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n-                    )\n-                };\n-                // We have to put the result into io_status_block.\n-                if let Some(n) = written {\n-                    let io_status_information =\n-                        this.mplace_field_named(&io_status_block, \"Information\")?;\n-                    this.write_scalar(\n-                        Scalar::from_target_usize(n.into(), this),\n-                        &io_status_information.into(),\n-                    )?;\n-                }\n-                // Return whether this was a success. >= 0 is success.\n-                // For the error code we arbitrarily pick 0xC0000185, STATUS_IO_DEVICE_ERROR.\n-                this.write_scalar(\n-                    Scalar::from_u32(if written.is_some() { 0 } else { 0xC0000185u32 }),\n-                    dest,\n-                )?;\n-            }\n             Dlsym::SetThreadDescription => {\n                 let [handle, name] = check_arg_count(args)?;\n "}, {"sha": "665c7ed438f3d1bf777f250398dfa7971481cff6", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=3ff4d56650bf5f7a57d11f3666fb429f0b00b18f", "patch": "@@ -69,6 +69,74 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.write_scalar(result, dest)?;\n             }\n \n+            // File related shims\n+            \"NtWriteFile\" => {\n+                if !this.frame_in_std() {\n+                    throw_unsup_format!(\n+                        \"`NtWriteFile` support is crude and just enough for stdout to work\"\n+                    );\n+                }\n+\n+                let [\n+                    handle,\n+                    _event,\n+                    _apc_routine,\n+                    _apc_context,\n+                    io_status_block,\n+                    buf,\n+                    n,\n+                    byte_offset,\n+                    _key,\n+                ] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let handle = this.read_target_isize(handle)?;\n+                let buf = this.read_pointer(buf)?;\n+                let n = this.read_scalar(n)?.to_u32()?;\n+                let byte_offset = this.read_target_usize(byte_offset)?; // is actually a pointer\n+                let io_status_block = this.deref_operand(io_status_block)?;\n+\n+                if byte_offset != 0 {\n+                    throw_unsup_format!(\n+                        \"`NtWriteFile` `ByteOffset` paremeter is non-null, which is unsupported\"\n+                    );\n+                }\n+\n+                let written = if handle == -11 || handle == -12 {\n+                    // stdout/stderr\n+                    use std::io::{self, Write};\n+\n+                    let buf_cont =\n+                        this.read_bytes_ptr_strip_provenance(buf, Size::from_bytes(u64::from(n)))?;\n+                    let res = if this.machine.mute_stdout_stderr {\n+                        Ok(buf_cont.len())\n+                    } else if handle == -11 {\n+                        io::stdout().write(buf_cont)\n+                    } else {\n+                        io::stderr().write(buf_cont)\n+                    };\n+                    // We write at most `n` bytes, which is a `u32`, so we cannot have written more than that.\n+                    res.ok().map(|n| u32::try_from(n).unwrap())\n+                } else {\n+                    throw_unsup_format!(\n+                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n+                    )\n+                };\n+                // We have to put the result into io_status_block.\n+                if let Some(n) = written {\n+                    let io_status_information =\n+                        this.mplace_field_named(&io_status_block, \"Information\")?;\n+                    this.write_scalar(\n+                        Scalar::from_target_usize(n.into(), this),\n+                        &io_status_information.into(),\n+                    )?;\n+                }\n+                // Return whether this was a success. >= 0 is success.\n+                // For the error code we arbitrarily pick 0xC0000185, STATUS_IO_DEVICE_ERROR.\n+                this.write_scalar(\n+                    Scalar::from_u32(if written.is_some() { 0 } else { 0xC0000185u32 }),\n+                    dest,\n+                )?;\n+            }\n+\n             // Allocation\n             \"HeapAlloc\" => {\n                 let [handle, flags, size] ="}, {"sha": "ea06b620c4cff7b24b41adb586fa0a038caf6ebf", "filename": "tests/run-make-fulldeps/tools.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/tests%2Frun-make-fulldeps%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3ff4d56650bf5f7a57d11f3666fb429f0b00b18f/tests%2Frun-make-fulldeps%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Ftools.mk?ref=3ff4d56650bf5f7a57d11f3666fb429f0b00b18f", "patch": "@@ -112,9 +112,9 @@ endif\n # Extra flags needed to compile a working executable with the standard library\n ifdef IS_WINDOWS\n ifdef IS_MSVC\n-\tEXTRACFLAGS := ws2_32.lib userenv.lib advapi32.lib bcrypt.lib\n+\tEXTRACFLAGS := ws2_32.lib userenv.lib advapi32.lib bcrypt.lib ntdll.lib\n else\n-\tEXTRACFLAGS := -lws2_32 -luserenv -lbcrypt\n+\tEXTRACFLAGS := -lws2_32 -luserenv -lbcrypt -lntdll\n \tEXTRACXXFLAGS := -lstdc++\n \t# So this is a bit hacky: we can't use the DLL version of libstdc++ because\n \t# it pulls in the DLL version of libgcc, which means that we end up with 2"}]}