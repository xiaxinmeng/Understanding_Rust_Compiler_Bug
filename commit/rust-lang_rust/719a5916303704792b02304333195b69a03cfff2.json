{"sha": "719a5916303704792b02304333195b69a03cfff2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxOWE1OTE2MzAzNzA0NzkyYjAyMzA0MzMzMTk1YjY5YTAzY2ZmZjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-31T17:27:36Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-07T15:50:58Z"}, "message": "mir: distinguish between variable visibility scopes and SEME scopes.", "tree": {"sha": "a911f11ede10f79f3082fa916030c6750822c2fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a911f11ede10f79f3082fa916030c6750822c2fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/719a5916303704792b02304333195b69a03cfff2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/719a5916303704792b02304333195b69a03cfff2", "html_url": "https://github.com/rust-lang/rust/commit/719a5916303704792b02304333195b69a03cfff2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/719a5916303704792b02304333195b69a03cfff2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f35255038bacaf2dd3c8a1188657f76c8f974375", "url": "https://api.github.com/repos/rust-lang/rust/commits/f35255038bacaf2dd3c8a1188657f76c8f974375", "html_url": "https://github.com/rust-lang/rust/commit/f35255038bacaf2dd3c8a1188657f76c8f974375"}], "stats": {"total": 516, "additions": 259, "deletions": 257}, "files": [{"sha": "0d9c46461619d3954a98ea46a1b579b3bbaf5a8c", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -32,9 +32,9 @@ pub struct Mir<'tcx> {\n     /// that indexes into this vector.\n     pub basic_blocks: Vec<BasicBlockData<'tcx>>,\n \n-    /// List of lexical scopes; these are referenced by statements and\n-    /// used (eventually) for debuginfo. Indexed by a `ScopeId`.\n-    pub scopes: Vec<ScopeData>,\n+    /// List of visibility (lexical) scopes; these are referenced by statements\n+    /// and used (eventually) for debuginfo. Indexed by a `VisibilityScope`.\n+    pub visibility_scopes: Vec<VisibilityScopeData>,\n \n     /// Rvalues promoted from this function, such as borrows of constants.\n     /// Each of them is the Mir of a constant with the fn's type parameters\n@@ -173,7 +173,7 @@ pub struct VarDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n \n     /// scope in which variable was declared\n-    pub scope: ScopeId,\n+    pub scope: VisibilityScope,\n \n     /// span where variable was declared\n     pub span: Span,\n@@ -276,7 +276,7 @@ pub struct BasicBlockData<'tcx> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Terminator<'tcx> {\n     pub span: Span,\n-    pub scope: ScopeId,\n+    pub scope: VisibilityScope,\n     pub kind: TerminatorKind<'tcx>\n }\n \n@@ -588,7 +588,7 @@ pub enum AssertMessage<'tcx> {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Statement<'tcx> {\n     pub span: Span,\n-    pub scope: ScopeId,\n+    pub scope: VisibilityScope,\n     pub kind: StatementKind<'tcx>,\n }\n \n@@ -754,29 +754,32 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n-impl Index<ScopeId> for Vec<ScopeData> {\n-    type Output = ScopeData;\n+impl Index<VisibilityScope> for Vec<VisibilityScopeData> {\n+    type Output = VisibilityScopeData;\n \n     #[inline]\n-    fn index(&self, index: ScopeId) -> &ScopeData {\n+    fn index(&self, index: VisibilityScope) -> &VisibilityScopeData {\n         &self[index.index()]\n     }\n }\n \n-impl IndexMut<ScopeId> for Vec<ScopeData> {\n+impl IndexMut<VisibilityScope> for Vec<VisibilityScopeData> {\n     #[inline]\n-    fn index_mut(&mut self, index: ScopeId) -> &mut ScopeData {\n+    fn index_mut(&mut self, index: VisibilityScope) -> &mut VisibilityScopeData {\n         &mut self[index.index()]\n     }\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub struct ScopeId(u32);\n+pub struct VisibilityScope(u32);\n \n-impl ScopeId {\n-    pub fn new(index: usize) -> ScopeId {\n+/// The visibility scope all arguments go into.\n+pub const ARGUMENT_VISIBILITY_SCOPE: VisibilityScope = VisibilityScope(0);\n+\n+impl VisibilityScope {\n+    pub fn new(index: usize) -> VisibilityScope {\n         assert!(index < (u32::MAX as usize));\n-        ScopeId(index as u32)\n+        VisibilityScope(index as u32)\n     }\n \n     pub fn index(self) -> usize {\n@@ -785,9 +788,9 @@ impl ScopeId {\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct ScopeData {\n+pub struct VisibilityScopeData {\n     pub span: Span,\n-    pub parent_scope: Option<ScopeId>,\n+    pub parent_scope: Option<VisibilityScope>,\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "d340695761de083a179a4550306d34060492c6da", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -97,9 +97,9 @@ macro_rules! make_mir_visitor {\n                 self.super_basic_block_data(block, data);\n             }\n \n-            fn visit_scope_data(&mut self,\n-                                scope_data: & $($mutability)* ScopeData) {\n-                self.super_scope_data(scope_data);\n+            fn visit_visibility_scope_data(&mut self,\n+                                           scope_data: & $($mutability)* VisibilityScopeData) {\n+                self.super_visibility_scope_data(scope_data);\n             }\n \n             fn visit_statement(&mut self,\n@@ -236,9 +236,9 @@ macro_rules! make_mir_visitor {\n                 self.super_arg_decl(arg_decl);\n             }\n \n-            fn visit_scope_id(&mut self,\n-                              scope_id: & $($mutability)* ScopeId) {\n-                self.super_scope_id(scope_id);\n+            fn visit_visibility_scope(&mut self,\n+                                      scope: & $($mutability)* VisibilityScope) {\n+                self.super_visibility_scope(scope);\n             }\n \n             // The `super_xxx` methods comprise the default behavior and are\n@@ -248,7 +248,7 @@ macro_rules! make_mir_visitor {\n                          mir: & $($mutability)* Mir<'tcx>) {\n                 let Mir {\n                     ref $($mutability)* basic_blocks,\n-                    ref $($mutability)* scopes,\n+                    ref $($mutability)* visibility_scopes,\n                     promoted: _, // Visited by passes separately.\n                     ref $($mutability)* return_ty,\n                     ref $($mutability)* var_decls,\n@@ -263,8 +263,8 @@ macro_rules! make_mir_visitor {\n                     self.visit_basic_block_data(block, data);\n                 }\n \n-                for scope in scopes {\n-                    self.visit_scope_data(scope);\n+                for scope in visibility_scopes {\n+                    self.visit_visibility_scope_data(scope);\n                 }\n \n                 self.visit_fn_output(return_ty);\n@@ -302,16 +302,16 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n-            fn super_scope_data(&mut self,\n-                                scope_data: & $($mutability)* ScopeData) {\n-                let ScopeData {\n+            fn super_visibility_scope_data(&mut self,\n+                                           scope_data: & $($mutability)* VisibilityScopeData) {\n+                let VisibilityScopeData {\n                     ref $($mutability)* span,\n                     ref $($mutability)* parent_scope,\n                 } = *scope_data;\n \n                 self.visit_span(span);\n                 if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n-                    self.visit_scope_id(parent_scope);\n+                    self.visit_visibility_scope(parent_scope);\n                 }\n             }\n \n@@ -325,7 +325,7 @@ macro_rules! make_mir_visitor {\n                 } = *statement;\n \n                 self.visit_span(span);\n-                self.visit_scope_id(scope);\n+                self.visit_visibility_scope(scope);\n                 match *kind {\n                     StatementKind::Assign(ref $($mutability)* lvalue,\n                                           ref $($mutability)* rvalue) => {\n@@ -352,7 +352,7 @@ macro_rules! make_mir_visitor {\n                 } = *terminator;\n \n                 self.visit_span(span);\n-                self.visit_scope_id(scope);\n+                self.visit_visibility_scope(scope);\n                 self.visit_terminator_kind(block, kind);\n             }\n \n@@ -627,7 +627,7 @@ macro_rules! make_mir_visitor {\n                 } = *var_decl;\n \n                 self.visit_ty(ty);\n-                self.visit_scope_id(scope);\n+                self.visit_visibility_scope(scope);\n                 self.visit_span(span);\n             }\n \n@@ -651,8 +651,8 @@ macro_rules! make_mir_visitor {\n                 self.visit_ty(ty);\n             }\n \n-            fn super_scope_id(&mut self,\n-                              _scope_id: & $($mutability)* ScopeId) {\n+            fn super_visibility_scope(&mut self,\n+                                      _scope: & $($mutability)* VisibilityScope) {\n             }\n \n             fn super_branch(&mut self,"}, {"sha": "f4e4b78b64677d4647af1e492de514427de46902", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -22,7 +22,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      ast_block: &'tcx hir::Block)\n                      -> BlockAnd<()> {\n         let Block { extent, span, stmts, expr } = self.hir.mirror(ast_block);\n-        self.in_scope(extent, block, move |this, _| {\n+        self.in_scope(extent, block, move |this| {\n             // This convoluted structure is to avoid using recursion as we walk down a list\n             // of statements. Basically, the structure we get back is something like:\n             //\n@@ -40,27 +40,40 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // First we build all the statements in the block.\n             let mut let_extent_stack = Vec::with_capacity(8);\n+            let outer_visibility_scope = this.visibility_scope;\n             for stmt in stmts {\n                 let Stmt { span: _, kind } = this.hir.mirror(stmt);\n                 match kind {\n                     StmtKind::Expr { scope, expr } => {\n-                        unpack!(block = this.in_scope(scope, block, |this, _| {\n+                        unpack!(block = this.in_scope(scope, block, |this| {\n                             let expr = this.hir.mirror(expr);\n                             this.stmt_expr(block, expr)\n                         }));\n                     }\n                     StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                        let remainder_scope_id = this.push_scope(remainder_scope, block);\n+                        let tcx = this.hir.tcx();\n+\n+                        // Enter the remainder scope, i.e. the bindings' destruction scope.\n+                        this.push_scope(remainder_scope, block);\n                         let_extent_stack.push(remainder_scope);\n-                        unpack!(block = this.in_scope(init_scope, block, move |this, _| {\n-                            // FIXME #30046                              ^~~~\n-                            if let Some(init) = initializer {\n-                                this.expr_into_pattern(block, remainder_scope_id, pattern, init)\n-                            } else {\n-                                this.declare_bindings(remainder_scope_id, &pattern);\n-                                block.unit()\n-                            }\n-                        }));\n+\n+                        // Declare the bindings, which may create a visibility scope.\n+                        let remainder_span = remainder_scope.span(&tcx.region_maps, &tcx.map);\n+                        let remainder_span = remainder_span.unwrap_or(span);\n+                        let scope = this.declare_bindings(None, remainder_span, &pattern);\n+\n+                        // Evaluate the initializer, if present.\n+                        if let Some(init) = initializer {\n+                            unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                                // FIXME #30046                              ^~~~\n+                                this.expr_into_pattern(block, pattern, init)\n+                            }));\n+                        }\n+\n+                        // Enter the visibility scope, after evaluating the initializer.\n+                        if let Some(visibility_scope) = scope {\n+                            this.visibility_scope = visibility_scope;\n+                        }\n                     }\n                 }\n             }\n@@ -78,6 +91,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             for extent in let_extent_stack.into_iter().rev() {\n                 unpack!(block = this.pop_scope(extent, block));\n             }\n+            // Restore the original visibility scope.\n+            this.visibility_scope = outer_visibility_scope;\n             block.unit()\n         })\n     }"}, {"sha": "4045497575d3cbee5453486dfc68f607c11327b9", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> CFG<'tcx> {\n \n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n-                       scope: ScopeId,\n+                       scope: VisibilityScope,\n                        span: Span,\n                        lvalue: &Lvalue<'tcx>,\n                        rvalue: Rvalue<'tcx>) {\n@@ -63,7 +63,7 @@ impl<'tcx> CFG<'tcx> {\n \n     pub fn push_assign_constant(&mut self,\n                                 block: BasicBlock,\n-                                scope: ScopeId,\n+                                scope: VisibilityScope,\n                                 span: Span,\n                                 temp: &Lvalue<'tcx>,\n                                 constant: Constant<'tcx>) {\n@@ -73,7 +73,7 @@ impl<'tcx> CFG<'tcx> {\n \n     pub fn push_assign_unit(&mut self,\n                             block: BasicBlock,\n-                            scope: ScopeId,\n+                            scope: VisibilityScope,\n                             span: Span,\n                             lvalue: &Lvalue<'tcx>) {\n         self.push_assign(block, scope, span, lvalue, Rvalue::Aggregate(\n@@ -83,7 +83,7 @@ impl<'tcx> CFG<'tcx> {\n \n     pub fn terminate(&mut self,\n                      block: BasicBlock,\n-                     scope: ScopeId,\n+                     scope: VisibilityScope,\n                      span: Span,\n                      kind: TerminatorKind<'tcx>) {\n         debug_assert!(self.block_data(block).terminator.is_none(),"}, {"sha": "1f78071dfcea4abdacf556a8b64b5702677daccc", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let expr_span = expr.span;\n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this, _| this.as_lvalue(block, value))\n+                this.in_scope(extent, block, |this| this.as_lvalue(block, value))\n             }\n             ExprKind::Field { lhs, name } => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, lhs));"}, {"sha": "beb9ca256abfd9248a93b3a4805838f1853be284", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this, _| this.as_operand(block, value));\n+            return this.in_scope(extent, block, |this| this.as_operand(block, value));\n         }\n \n         let category = Category::of(&expr.kind).unwrap();"}, {"sha": "19a3bc4d0e91e2d5a427a034b485093bd0e27f2b", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this, _| this.as_rvalue(block, value))\n+                this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n             }\n             ExprKind::InlineAsm { asm, outputs, inputs } => {\n                 let outputs = outputs.into_iter().map(|output| {\n@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let result = this.temp(expr.ty);\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n                 this.cfg.push_assign(block, scope_id, expr_span, &result, Rvalue::Box(value.ty));\n-                this.in_scope(value_extents, block, |this, _| {\n+                this.in_scope(value_extents, block, |this| {\n                     // schedule a shallow free of that memory, lest we unwind:\n                     this.schedule_box_free(expr_span, value_extents, &result, value.ty);\n                     // initialize the box contents:"}, {"sha": "2a28f33180198a631c863b3700a10f8465afbd1c", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this, _| this.as_temp(block, value));\n+            return this.in_scope(extent, block, |this| this.as_temp(block, value));\n         }\n \n         let expr_ty = expr.ty.clone();"}, {"sha": "fb77fc50f8686130221c4e56776b5de4c467c380", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this, _| this.into(destination, block, value))\n+                this.in_scope(extent, block, |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, expr.ty.is_nil(), block, ast_block)"}, {"sha": "add268d394ab73938dee6c54142ca47317c44745", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n                 let value = this.hir.mirror(value);\n-                this.in_scope(extent, block, |this, _| this.stmt_expr(block, value))\n+                this.in_scope(extent, block, |this| this.stmt_expr(block, value))\n             }\n             ExprKind::Assign { lhs, rhs } => {\n                 let lhs = this.hir.mirror(lhs);"}, {"sha": "46c907009a379abc87ff781a94ed805c4fc8c070", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -44,21 +44,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .collect(),\n         };\n \n-        // Get the body expressions and their scopes, while declaring bindings.\n-        let arm_bodies: Vec<_> = arms.iter().enumerate().map(|(i, arm)| {\n-            // Assume that all expressions are wrapped in Scope.\n+        // Get the arm bodies and their scopes, while declaring bindings.\n+        let arm_bodies: Vec<_> = arms.iter().map(|arm| {\n             let body = self.hir.mirror(arm.body.clone());\n-            match body.kind {\n-                ExprKind::Scope { extent, value } => {\n-                    let scope_id = self.push_scope(extent, arm_blocks.blocks[i]);\n-                    self.declare_bindings(scope_id, &arm.patterns[0]);\n-                    (extent, self.scopes.pop().unwrap(), value)\n-                }\n-                _ => {\n-                    span_bug!(body.span, \"arm body is not wrapped in Scope {:?}\",\n-                              body.kind);\n-                }\n-            }\n+            let scope = self.declare_bindings(None, body.span, &arm.patterns[0]);\n+            (body, scope.unwrap_or(self.visibility_scope))\n         }).collect();\n \n         // assemble a list of candidates: there is one candidate per\n@@ -99,63 +89,48 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n-        let scope_id = self.innermost_scope_id();\n-        for (arm_index, (extent, scope, body)) in arm_bodies.into_iter().enumerate() {\n+        let outer_visibility_scope = self.innermost_scope_id();\n+        for (arm_index, (body, visibility_scope)) in arm_bodies.into_iter().enumerate() {\n             let mut arm_block = arm_blocks.blocks[arm_index];\n-            // Re-enter the scope we created the bindings in.\n-            self.scopes.push(scope);\n+            // Re-enter the visibility scope we created the bindings in.\n+            self.visibility_scope = visibility_scope;\n             unpack!(arm_block = self.into(destination, arm_block, body));\n-            unpack!(arm_block = self.pop_scope(extent, arm_block));\n             self.cfg.terminate(arm_block,\n-                               scope_id,\n+                               outer_visibility_scope,\n                                span,\n                                TerminatorKind::Goto { target: end_block });\n         }\n+        self.visibility_scope = outer_visibility_scope;\n \n         end_block.unit()\n     }\n \n     pub fn expr_into_pattern(&mut self,\n                              mut block: BasicBlock,\n-                             var_scope_id: ScopeId, // lifetime of vars\n                              irrefutable_pat: Pattern<'tcx>,\n                              initializer: ExprRef<'tcx>)\n                              -> BlockAnd<()> {\n         // optimize the case of `let x = ...`\n         match *irrefutable_pat.kind {\n-            PatternKind::Binding { mutability,\n-                                   name,\n-                                   mode: BindingMode::ByValue,\n+            PatternKind::Binding { mode: BindingMode::ByValue,\n                                    var,\n-                                   ty,\n-                                   subpattern: None } => {\n-                let index = self.declare_binding(var_scope_id,\n-                                                 mutability,\n-                                                 name,\n-                                                 var,\n-                                                 ty,\n-                                                 irrefutable_pat.span);\n-                let lvalue = Lvalue::Var(index);\n+                                   subpattern: None, .. } => {\n+                let lvalue = Lvalue::Var(self.var_indices[&var]);\n                 return self.into(&lvalue, block, initializer);\n             }\n             _ => {}\n         }\n         let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n         self.lvalue_into_pattern(block,\n-                                 var_scope_id,\n                                  irrefutable_pat,\n                                  &lvalue)\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n                                mut block: BasicBlock,\n-                               var_scope_id: ScopeId,\n                                irrefutable_pat: Pattern<'tcx>,\n                                initializer: &Lvalue<'tcx>)\n                                -> BlockAnd<()> {\n-        // first, creating the bindings\n-        self.declare_bindings(var_scope_id, &irrefutable_pat);\n-\n         // create a dummy candidate\n         let mut candidate = Candidate {\n             span: irrefutable_pat.span,\n@@ -182,32 +157,43 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         block.unit()\n     }\n \n-    pub fn declare_bindings(&mut self, var_scope_id: ScopeId, pattern: &Pattern<'tcx>) {\n+    /// Declares the bindings of the given pattern and returns the visibility scope\n+    /// for the bindings in this patterns, if such a scope had to be created.\n+    /// NOTE: Declaring the bindings should always be done in their drop scope.\n+    pub fn declare_bindings(&mut self,\n+                            mut var_scope: Option<VisibilityScope>,\n+                            scope_span: Span,\n+                            pattern: &Pattern<'tcx>)\n+                            -> Option<VisibilityScope> {\n         match *pattern.kind {\n             PatternKind::Binding { mutability, name, mode: _, var, ty, ref subpattern } => {\n-                self.declare_binding(var_scope_id, mutability, name, var, ty, pattern.span);\n+                if var_scope.is_none() {\n+                    var_scope = Some(self.new_visibility_scope(scope_span));\n+                }\n+                self.declare_binding(var_scope.unwrap(), mutability, name, var, ty, pattern.span);\n                 if let Some(subpattern) = subpattern.as_ref() {\n-                    self.declare_bindings(var_scope_id, subpattern);\n+                    var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n                 }\n             }\n             PatternKind::Array { ref prefix, ref slice, ref suffix } |\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    self.declare_bindings(var_scope_id, subpattern);\n+                    var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n             }\n             PatternKind::Deref { ref subpattern } => {\n-                self.declare_bindings(var_scope_id, subpattern);\n+                var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n             }\n             PatternKind::Leaf { ref subpatterns } |\n             PatternKind::Variant { ref subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.declare_bindings(var_scope_id, &subpattern.pattern);\n+                    var_scope = self.declare_bindings(var_scope, scope_span, &subpattern.pattern);\n                 }\n             }\n         }\n+        var_scope\n     }\n }\n \n@@ -635,7 +621,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     fn declare_binding(&mut self,\n-                       var_scope_id: ScopeId,\n+                       var_scope_id: VisibilityScope,\n                        mutability: Mutability,\n                        name: Name,\n                        var_id: NodeId,\n@@ -655,7 +641,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             span: span,\n         });\n         let index = index as u32;\n-        let extent = self.scope_auxiliary[var_scope_id].extent;\n+        let extent = self.extent_of_innermost_scope();\n         self.schedule_drop(span, extent, &Lvalue::Var(index), var_ty);\n         self.var_indices.insert(var_id, index);\n "}, {"sha": "a6294406ea5671d90e26cbdc5b74eda88ee77b62", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn push_usize(&mut self,\n                       block: BasicBlock,\n-                      scope_id: ScopeId,\n+                      scope_id: VisibilityScope,\n                       span: Span,\n                       value: u64)\n                       -> Lvalue<'tcx> {"}, {"sha": "27cced2ae1ac786d81fd4fe48f2bb416b8e4162a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::hir;\n use std::ops::{Index, IndexMut};\n+use std::u32;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -43,7 +44,8 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later\n-    scope_datas: Vec<ScopeData>,\n+    visibility_scopes: Vec<VisibilityScopeData>,\n+    visibility_scope: VisibilityScope,\n \n     var_decls: Vec<VarDecl<'tcx>>,\n     var_indices: FnvHashMap<ast::NodeId, u32>,\n@@ -61,6 +63,20 @@ struct CFG<'tcx> {\n     basic_blocks: Vec<BasicBlockData<'tcx>>,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct ScopeId(u32);\n+\n+impl ScopeId {\n+    pub fn new(index: usize) -> ScopeId {\n+        assert!(index < (u32::MAX as usize));\n+        ScopeId(index as u32)\n+    }\n+\n+    pub fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n /// For each scope, we track the extent (from the HIR) and a\n /// single-entry-multiple-exit subgraph that contains all the\n /// statements/terminators within it.\n@@ -179,17 +195,16 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         tcx.region_maps.lookup_code_extent(\n             CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n     let mut block = START_BLOCK;\n-    let mut arg_decls = unpack!(block = builder.in_scope(call_site_extent, block,\n-                                                         |builder, call_site_scope_id| {\n-        let arg_decls = unpack!(block = builder.in_scope(arg_extent, block,\n-                                                         |builder, arg_scope_id| {\n-            builder.args_and_body(block, return_ty, arguments, arg_scope_id, ast_block)\n+    let mut arg_decls = unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n+        let arg_decls = unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n+            builder.args_and_body(block, return_ty, arguments, arg_extent, ast_block)\n         }));\n \n+        let visibility_scope = builder.visibility_scope;\n         let return_block = builder.return_block();\n-        builder.cfg.terminate(block, call_site_scope_id, span,\n+        builder.cfg.terminate(block, visibility_scope, span,\n                               TerminatorKind::Goto { target: return_block });\n-        builder.cfg.terminate(return_block, call_site_scope_id, span,\n+        builder.cfg.terminate(return_block, visibility_scope, span,\n                               TerminatorKind::Return);\n         return_block.and(arg_decls)\n     }));\n@@ -241,14 +256,15 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let extent = ROOT_CODE_EXTENT;\n     let mut block = START_BLOCK;\n-    let _ = builder.in_scope(extent, block, |builder, call_site_scope_id| {\n+    let _ = builder.in_scope(extent, block, |builder| {\n         let expr = builder.hir.mirror(ast_expr);\n         unpack!(block = builder.into(&Lvalue::ReturnPointer, block, expr));\n \n+        let visibility_scope = builder.visibility_scope;\n         let return_block = builder.return_block();\n-        builder.cfg.terminate(block, call_site_scope_id, span,\n+        builder.cfg.terminate(block, visibility_scope, span,\n                               TerminatorKind::Goto { target: return_block });\n-        builder.cfg.terminate(return_block, call_site_scope_id, span,\n+        builder.cfg.terminate(return_block, visibility_scope, span,\n                               TerminatorKind::Return);\n \n         return_block.unit()\n@@ -265,7 +281,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             cfg: CFG { basic_blocks: vec![] },\n             fn_span: span,\n             scopes: vec![],\n-            scope_datas: vec![],\n+            visibility_scopes: vec![],\n+            visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n             scope_auxiliary: ScopeAuxiliaryVec { vec: vec![] },\n             loop_scopes: vec![],\n             temp_decls: vec![],\n@@ -277,6 +294,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n+        assert_eq!(builder.new_visibility_scope(span), ARGUMENT_VISIBILITY_SCOPE);\n+        builder.visibility_scopes[ARGUMENT_VISIBILITY_SCOPE].parent_scope = None;\n \n         builder\n     }\n@@ -294,7 +313,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         (Mir {\n             basic_blocks: self.cfg.basic_blocks,\n-            scopes: self.scope_datas,\n+            visibility_scopes: self.visibility_scopes,\n             promoted: vec![],\n             var_decls: self.var_decls,\n             arg_decls: arg_decls,\n@@ -309,24 +328,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         mut block: BasicBlock,\n                         return_ty: ty::FnOutput<'tcx>,\n                         arguments: A,\n-                        argument_scope_id: ScopeId,\n+                        argument_extent: CodeExtent,\n                         ast_block: &'gcx hir::Block)\n                         -> BlockAnd<Vec<ArgDecl<'tcx>>>\n         where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n     {\n         // to start, translate the argument patterns and collect the argument types.\n+        let mut scope = None;\n         let arg_decls = arguments.enumerate().map(|(index, (ty, pattern))| {\n             let lvalue = Lvalue::Arg(index as u32);\n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.irrefutable_pat(pattern);\n-                unpack!(block = self.lvalue_into_pattern(block,\n-                                                         argument_scope_id,\n-                                                         pattern,\n-                                                         &lvalue));\n+                scope = self.declare_bindings(scope, ast_block.span, &pattern);\n+                unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n-            let argument_extent = self.scope_auxiliary[argument_scope_id].extent;\n             self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n                                argument_extent, &lvalue, ty);\n \n@@ -344,6 +361,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }).collect();\n \n+        // Enter the argument pattern bindings visibility scope, if it exists.\n+        if let Some(visibility_scope) = scope {\n+            self.visibility_scope = visibility_scope;\n+        }\n+\n         // FIXME(#32959): temporary hack for the issue at hand\n         let return_is_unit = if let ty::FnConverging(t) = return_ty {\n             t.is_nil()"}, {"sha": "93ca01ba2ec4ae3cd23714d11069bb9f09112c38", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -86,7 +86,7 @@ should go to.\n \n */\n \n-use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary};\n+use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary, ScopeId};\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n use rustc::ty::subst::{Substs, Subst, VecPerParamSpace};\n@@ -98,9 +98,12 @@ use rustc::middle::const_val::ConstVal;\n use rustc_const_math::ConstInt;\n \n pub struct Scope<'tcx> {\n-    /// the scope-id within the scope_datas\n+    /// the scope-id within the scope_auxiliary\n     id: ScopeId,\n \n+    /// The visibility scope this scope was created in.\n+    visibility_scope: VisibilityScope,\n+\n     /// the extent of this scope within source code; also stored in\n     /// `ScopeAuxiliary`, but kept here for convenience\n     extent: CodeExtent,\n@@ -237,11 +240,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>, ScopeId) -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        let id = self.push_scope(extent, block);\n-        let rv = unpack!(block = f(self, id));\n+        self.push_scope(extent, block);\n+        let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(extent, block));\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n         block.and(rv)\n@@ -251,17 +254,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) -> ScopeId {\n+    pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) {\n         debug!(\"push_scope({:?})\", extent);\n-        let parent_id = self.scopes.last().map(|s| s.id);\n-        let id = ScopeId::new(self.scope_datas.len());\n-        let tcx = self.hir.tcx();\n-        self.scope_datas.push(ScopeData {\n-            span: extent.span(&tcx.region_maps, &tcx.map).unwrap_or(DUMMY_SP),\n-            parent_scope: parent_id,\n-        });\n+        let id = ScopeId::new(self.scope_auxiliary.vec.len());\n+        let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n             id: id,\n+            visibility_scope: vis_scope,\n             extent: extent,\n             drops: vec![],\n             free: None,\n@@ -272,7 +271,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             dom: self.cfg.current_location(entry),\n             postdoms: vec![]\n         });\n-        id\n     }\n \n     /// Pops a scope, which should have extent `extent`, adding any\n@@ -320,7 +318,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n                 let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n-                self.cfg.terminate(block, scope.id, span, free);\n+                self.cfg.terminate(block, scope.visibility_scope, span, free);\n                 block = next;\n             }\n             self.scope_auxiliary[scope.id]\n@@ -334,11 +332,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                             .next()\n                                             .unwrap();\n         self.cfg.terminate(block,\n-                           scope.id,\n+                           scope.visibility_scope,\n                            span,\n                            TerminatorKind::Goto { target: target });\n     }\n \n+    /// Creates a new visibility scope, nested in the current one.\n+    pub fn new_visibility_scope(&mut self, span: Span) -> VisibilityScope {\n+        let parent = self.visibility_scope;\n+        let scope = VisibilityScope::new(self.visibility_scopes.len());\n+        self.visibility_scopes.push(VisibilityScopeData {\n+            span: span,\n+            parent_scope: Some(parent),\n+        });\n+        scope\n+    }\n+\n     // Finding scopes\n     // ==============\n     /// Finds the loop scope for a given label. This is used for\n@@ -363,8 +372,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }.unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n     }\n \n-    pub fn innermost_scope_id(&self) -> ScopeId {\n-        self.scopes.last().map(|scope| scope.id).unwrap()\n+    pub fn innermost_scope_id(&self) -> VisibilityScope {\n+        self.visibility_scope\n     }\n \n     pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n@@ -481,7 +490,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             target\n         } else {\n             let resumeblk = cfg.start_new_cleanup_block();\n-            cfg.terminate(resumeblk, scopes[0].id, self.fn_span, TerminatorKind::Resume);\n+            cfg.terminate(resumeblk,\n+                          scopes[0].visibility_scope,\n+                          self.fn_span,\n+                          TerminatorKind::Resume);\n             *cached_resume_block = Some(resumeblk);\n             resumeblk\n         };\n@@ -658,7 +670,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n             earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n         });\n         let next = cfg.start_new_block();\n-        cfg.terminate(block, scope.id, drop_data.span, TerminatorKind::Drop {\n+        cfg.terminate(block, scope.visibility_scope, drop_data.span, TerminatorKind::Drop {\n             location: drop_data.location.clone(),\n             target: next,\n             unwind: on_diverge\n@@ -695,7 +707,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         } else {\n             let into = cfg.start_new_cleanup_block();\n             cfg.terminate(into,\n-                          scope.id,\n+                          scope.visibility_scope,\n                           free_data.span,\n                           build_free(tcx, unit_temp, free_data, target));\n             free_data.cached_block = Some(into);\n@@ -712,7 +724,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         } else {\n             let block = cfg.start_new_cleanup_block();\n             cfg.terminate(block,\n-                          scope.id,\n+                          scope.visibility_scope,\n                           drop_data.span,\n                           TerminatorKind::Drop {\n                               location: drop_data.location.clone(),"}, {"sha": "5849db6bbd271f64b1789effc2b127018b88004b", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 57, "deletions": 79, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use build::{Location, ScopeAuxiliaryVec};\n+use build::{Location, ScopeAuxiliaryVec, ScopeId};\n use rustc::hir;\n use rustc::mir::repr::*;\n use rustc::mir::transform::MirSource;\n@@ -139,20 +139,11 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.all_basic_blocks() {\n         write_basic_block(tcx, block, mir, w, &annotations)?;\n+        if block.index() + 1 != mir.basic_blocks.len() {\n+            writeln!(w, \"\")?;\n+        }\n     }\n \n-    // construct a scope tree and write it out\n-    let mut scope_tree: FnvHashMap<Option<ScopeId>, Vec<ScopeId>> = FnvHashMap();\n-    for (index, scope_data) in mir.scopes.iter().enumerate() {\n-        scope_tree.entry(scope_data.parent_scope)\n-                  .or_insert(vec![])\n-                  .push(ScopeId::new(index));\n-    }\n-\n-    writeln!(w, \"{}scope tree:\", INDENT)?;\n-    write_scope_tree(tcx, mir, auxiliary, &scope_tree, w, None, 1, false)?;\n-    writeln!(w, \"\")?;\n-\n     writeln!(w, \"}}\")?;\n     Ok(())\n }\n@@ -204,66 +195,59 @@ fn write_basic_block(tcx: TyCtxt,\n     writeln!(w, \"{}}}\\n\", INDENT)\n }\n \n-fn comment(tcx: TyCtxt, scope: ScopeId, span: Span) -> String {\n+fn comment(tcx: TyCtxt, scope: VisibilityScope, span: Span) -> String {\n     format!(\"scope {} at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n }\n \n fn write_scope_tree(tcx: TyCtxt,\n                     mir: &Mir,\n-                    auxiliary: Option<&ScopeAuxiliaryVec>,\n-                    scope_tree: &FnvHashMap<Option<ScopeId>, Vec<ScopeId>>,\n+                    scope_tree: &FnvHashMap<VisibilityScope, Vec<VisibilityScope>>,\n                     w: &mut Write,\n-                    parent: Option<ScopeId>,\n-                    depth: usize,\n-                    same_line: bool)\n+                    parent: VisibilityScope,\n+                    depth: usize)\n                     -> io::Result<()> {\n-    let indent = if same_line {\n-        0\n-    } else {\n-        depth * INDENT.len()\n-    };\n+    let indent = depth * INDENT.len();\n \n     let children = match scope_tree.get(&parent) {\n         Some(childs) => childs,\n         None => return Ok(()),\n     };\n \n-    for (index, &child) in children.iter().enumerate() {\n-        if index == 0 && same_line {\n-            // We know we're going to output a scope, so prefix it with a space to separate it from\n-            // the previous scopes on this line\n-            write!(w, \" \")?;\n-        }\n-\n-        let data = &mir.scopes[child];\n-        assert_eq!(data.parent_scope, parent);\n-        write!(w, \"{0:1$}{2}\", \"\", indent, child.index())?;\n+    for &child in children {\n+        let data = &mir.visibility_scopes[child];\n+        assert_eq!(data.parent_scope, Some(parent));\n+        writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n \n-        let indent = indent + INDENT.len();\n+        // User variable types (including the user's name in a comment).\n+        for (i, var) in mir.var_decls.iter().enumerate() {\n+            // Skip if not declared in this scope.\n+            if var.scope != child {\n+                continue;\n+            }\n \n-        if let Some(auxiliary) = auxiliary {\n-            let extent = auxiliary[child].extent;\n-            let data = tcx.region_maps.code_extent_data(extent);\n-            writeln!(w, \"{0:1$}Extent: {2:?}\", \"\", indent, data)?;\n+            let mut_str = if var.mutability == Mutability::Mut {\n+                \"mut \"\n+            } else {\n+                \"\"\n+            };\n+\n+            let indent = indent + INDENT.len();\n+            let indented_var = format!(\"{0:1$}let {2}{3:?}: {4};\",\n+                                       INDENT,\n+                                       indent,\n+                                       mut_str,\n+                                       Lvalue::Var(i as u32),\n+                                       var.ty);\n+            writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n+                     indented_var,\n+                     ALIGN,\n+                     var.name,\n+                     comment(tcx, var.scope, var.span))?;\n         }\n \n-        let child_count = scope_tree.get(&Some(child)).map(Vec::len).unwrap_or(0);\n-        if child_count < 2 {\n-            // Skip the braces when there's no or only a single subscope\n-            write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n-                             Some(child), depth, true)?;\n-        } else {\n-            // 2 or more child scopes? Put them in braces and on new lines.\n-            writeln!(w, \" {{\")?;\n-            write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n-                             Some(child), depth + 1, false)?;\n-\n-            write!(w, \"\\n{0:1$}}}\", \"\", depth * INDENT.len())?;\n-        }\n+        write_scope_tree(tcx, mir, scope_tree, w, child, depth + 1)?;\n \n-        if !same_line && index + 1 < children.len() {\n-            writeln!(w, \"\")?;\n-        }\n+        writeln!(w, \"{0:1$}}}\", \"\", depth * INDENT.len())?;\n     }\n \n     Ok(())\n@@ -278,7 +262,23 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> io::Result<()> {\n     write_mir_sig(tcx, src, mir, w)?;\n     writeln!(w, \" {{\")?;\n-    write_mir_decls(tcx, mir, w)\n+\n+    // construct a scope tree and write it out\n+    let mut scope_tree: FnvHashMap<VisibilityScope, Vec<VisibilityScope>> = FnvHashMap();\n+    for (index, scope_data) in mir.visibility_scopes.iter().enumerate() {\n+        if let Some(parent) = scope_data.parent_scope {\n+            scope_tree.entry(parent)\n+                      .or_insert(vec![])\n+                      .push(VisibilityScope::new(index));\n+        } else {\n+            // Only the argument scope has no parent, because it's the root.\n+            assert_eq!(index, ARGUMENT_VISIBILITY_SCOPE.index());\n+        }\n+    }\n+\n+    write_scope_tree(tcx, mir, &scope_tree, w, ARGUMENT_VISIBILITY_SCOPE, 1)?;\n+\n+    write_mir_decls(mir, w)\n }\n \n fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n@@ -318,29 +318,7 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n     }\n }\n \n-fn write_mir_decls(tcx: TyCtxt, mir: &Mir, w: &mut Write)\n-                   -> io::Result<()>\n-{\n-    // User variable types (including the user's name in a comment).\n-    for (i, var) in mir.var_decls.iter().enumerate() {\n-        let mut_str = if var.mutability == Mutability::Mut {\n-            \"mut \"\n-        } else {\n-            \"\"\n-        };\n-\n-        let indented_var = format!(\"{}let {}{:?}: {};\",\n-                                   INDENT,\n-                                   mut_str,\n-                                   Lvalue::Var(i as u32),\n-                                   var.ty);\n-        writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n-                 indented_var,\n-                 ALIGN,\n-                 var.name,\n-                 comment(tcx, var.scope, var.span))?;\n-    }\n-\n+fn write_mir_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n     // Compiler-introduced temporary types.\n     for (i, temp) in mir.temp_decls.iter().enumerate() {\n         writeln!(w, \"{}let mut {:?}: {};\", INDENT, Lvalue::Temp(i as u32), temp.ty)?;"}, {"sha": "0a533d6e289b3cbd761eddb8bb0b7d280dcda378", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             statements: vec![],\n             terminator: Some(Terminator {\n                 span: self.promoted.span,\n-                scope: ScopeId::new(0),\n+                scope: VisibilityScope::new(0),\n                 kind: TerminatorKind::Return\n             }),\n             is_cleanup: false\n@@ -180,7 +180,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         let data = self.promoted.basic_blocks.last_mut().unwrap();\n         data.statements.push(Statement {\n             span: span,\n-            scope: ScopeId::new(0),\n+            scope: VisibilityScope::new(0),\n             kind: StatementKind::Assign(dest, rvalue)\n         });\n     }\n@@ -367,7 +367,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n             source: mir,\n             promoted: Mir {\n                 basic_blocks: vec![],\n-                scopes: vec![ScopeData {\n+                visibility_scopes: vec![VisibilityScopeData {\n                     span: span,\n                     parent_scope: None\n                 }],"}, {"sha": "2c23be02ddcf35fbbcfb4b49d4cdf975ab8bdf2a", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -16,7 +16,7 @@ use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram};\n use common::{CrateContext, FunctionContext};\n use rustc::hir::pat_util;\n-use rustc::mir::repr::{Mir, ScopeId};\n+use rustc::mir::repr::{Mir, VisibilityScope};\n use rustc::util::nodemap::NodeMap;\n \n use libc::c_uint;\n@@ -71,7 +71,7 @@ pub fn create_scope_map(cx: &CrateContext,\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes(fcx: &FunctionContext) -> Vec<DIScope> {\n     let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n-    let mut scopes = vec![ptr::null_mut(); mir.scopes.len()];\n+    let mut scopes = vec![ptr::null_mut(); mir.visibility_scopes.len()];\n \n     let fn_metadata = match fcx.debug_context {\n         FunctionDebugContext::RegularContext(box ref data) => data.fn_metadata,\n@@ -82,14 +82,14 @@ pub fn create_mir_scopes(fcx: &FunctionContext) -> Vec<DIScope> {\n     };\n \n     // Find all the scopes with variables defined in them.\n-    let mut has_variables = BitVector::new(mir.scopes.len());\n+    let mut has_variables = BitVector::new(mir.visibility_scopes.len());\n     for var in &mir.var_decls {\n         has_variables.insert(var.scope.index());\n     }\n \n     // Instantiate all scopes.\n-    for idx in 0..mir.scopes.len() {\n-        let scope = ScopeId::new(idx);\n+    for idx in 0..mir.visibility_scopes.len() {\n+        let scope = VisibilityScope::new(idx);\n         make_mir_scope(fcx.ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n     }\n \n@@ -100,14 +100,14 @@ fn make_mir_scope(ccx: &CrateContext,\n                   mir: &Mir,\n                   has_variables: &BitVector,\n                   fn_metadata: DISubprogram,\n-                  scope: ScopeId,\n+                  scope: VisibilityScope,\n                   scopes: &mut [DIScope]) {\n     let idx = scope.index();\n     if !scopes[idx].is_null() {\n         return;\n     }\n \n-    let scope_data = &mir.scopes[scope];\n+    let scope_data = &mir.visibility_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n         make_mir_scope(ccx, mir, has_variables, fn_metadata, parent, scopes);\n         scopes[parent.index()]"}, {"sha": "a6174cd4d371c4428408185ed1ce51c6650d7eea", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -266,16 +266,13 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n     let mut idx = 0;\n     let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n \n-    // Get the argument scope assuming ScopeId(0) has no parent.\n-    let arg_scope = mir.scopes.get(0).and_then(|data| {\n-        let scope = scopes[0];\n-        if data.parent_scope.is_none() && !scope.is_null() &&\n-           bcx.sess().opts.debuginfo == FullDebugInfo {\n-            Some(scope)\n-        } else {\n-            None\n-        }\n-    });\n+    // Get the argument scope, if it exists and if we need it.\n+    let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE.index()];\n+    let arg_scope = if !arg_scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n+        Some(arg_scope)\n+    } else {\n+        None\n+    };\n \n     mir.arg_decls.iter().enumerate().map(|(arg_index, arg_decl)| {\n         let arg_ty = bcx.monomorphize(&arg_decl.ty);"}, {"sha": "b5b6ca7572703cc65fab869385623d0d4b924be5", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/719a5916303704792b02304333195b69a03cfff2/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a5916303704792b02304333195b69a03cfff2/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=719a5916303704792b02304333195b69a03cfff2", "patch": "@@ -247,11 +247,10 @@\n // lldb-command:continue\n \n #![allow(dead_code, unused_assignments, unused_variables)]\n-#![feature(omit_gdb_pretty_printer_section, rustc_attrs)]\n+#![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn immediate_args(a: isize, b: bool, c: f64) {\n     println!(\"\");\n }\n@@ -268,51 +267,43 @@ struct BigStruct {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn non_immediate_args(a: BigStruct, b: BigStruct) {\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0;\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b;\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn function_call(x: u64, y: u64, z: f64) {\n     println!(\"Hi!\")\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn identifier(x: u64, y: u64, z: f64) -> u64 {\n     x\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n     return x;\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n     x + y\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n     if x + y < 1000 {\n         x\n@@ -322,7 +313,6 @@ fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     while x + y < 1000 {\n         x += z\n@@ -331,7 +321,6 @@ fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     loop {\n         x += z;"}]}