{"sha": "ad09abc19415d48e24dbb231c85e521d909e77f7", "node_id": "C_kwDOAAsO6NoAKGFkMDlhYmMxOTQxNWQ0OGUyNGRiYjIzMWM4NWU1MjFkOTA5ZTc3Zjc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-09T23:28:08Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-14T17:06:05Z"}, "message": "Move some code and add comments.", "tree": {"sha": "f72ef57322d484c8b224187bfa6bb749164d4c75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f72ef57322d484c8b224187bfa6bb749164d4c75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad09abc19415d48e24dbb231c85e521d909e77f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad09abc19415d48e24dbb231c85e521d909e77f7", "html_url": "https://github.com/rust-lang/rust/commit/ad09abc19415d48e24dbb231c85e521d909e77f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad09abc19415d48e24dbb231c85e521d909e77f7/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd45139cb014d51adaff46b9797504bc6eac2564", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd45139cb014d51adaff46b9797504bc6eac2564", "html_url": "https://github.com/rust-lang/rust/commit/bd45139cb014d51adaff46b9797504bc6eac2564"}], "stats": {"total": 444, "additions": 192, "deletions": 252}, "files": [{"sha": "9281d57ac64b4bc15b21e08bfaac8ef2784d8c95", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 103, "deletions": 32, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=ad09abc19415d48e24dbb231c85e521d909e77f7", "patch": "@@ -6,10 +6,11 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::{intravisit, HirId};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::{\n-    struct_lint_level, LevelAndSource, LintExpectation, LintLevelQueryMap, LintLevelSets,\n-    LintLevelSource, LintSet, LintStackIndex, COMMAND_LINE,\n+    reveal_actual_level, struct_lint_level, LevelAndSource, LintExpectation, LintLevelSource,\n+    ShallowLintLevelMap,\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{RegisteredTools, TyCtxt};\n@@ -27,13 +28,80 @@ use crate::errors::{\n     UnknownToolInScopedLint,\n };\n \n+#[derive(Debug)]\n+struct LintLevelSets {\n+    list: IndexVec<LintStackIndex, LintSet>,\n+}\n+\n+rustc_index::newtype_index! {\n+    struct LintStackIndex {\n+        ENCODABLE = custom, // we don't need encoding\n+        const COMMAND_LINE = 0,\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct LintSet {\n+    // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n+    // flag.\n+    specs: FxHashMap<LintId, LevelAndSource>,\n+\n+    parent: LintStackIndex,\n+}\n+\n+impl LintLevelSets {\n+    fn new() -> Self {\n+        LintLevelSets { list: IndexVec::new() }\n+    }\n+\n+    fn get_lint_level(\n+        &self,\n+        lint: &'static Lint,\n+        idx: LintStackIndex,\n+        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+        sess: &Session,\n+    ) -> LevelAndSource {\n+        let lint = LintId::of(lint);\n+        let (level, mut src) = self.raw_lint_id_level(lint, idx, aux);\n+        let level = reveal_actual_level(level, &mut src, sess, lint, |id| {\n+            self.raw_lint_id_level(id, idx, aux)\n+        });\n+        (level, src)\n+    }\n+\n+    fn raw_lint_id_level(\n+        &self,\n+        id: LintId,\n+        mut idx: LintStackIndex,\n+        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+    ) -> (Option<Level>, LintLevelSource) {\n+        if let Some(specs) = aux {\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src);\n+            }\n+        }\n+        loop {\n+            let LintSet { ref specs, parent } = self.list[idx];\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src);\n+            }\n+            if idx == COMMAND_LINE {\n+                return (None, LintLevelSource::Default);\n+            }\n+            idx = parent;\n+        }\n+    }\n+}\n+\n fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExpectation)> {\n     let store = unerased_lint_store(tcx);\n \n     let mut builder = LintLevelsBuilder {\n         sess: tcx.sess,\n         provider: QueryMapExpectationsWrapper {\n-            map: LintLevelQueryMap { tcx, cur: hir::CRATE_HIR_ID, specs: FxHashMap::default() },\n+            tcx,\n+            cur: hir::CRATE_HIR_ID,\n+            specs: ShallowLintLevelMap::default(),\n             expectations: Vec::new(),\n             unstable_to_stable_ids: FxHashMap::default(),\n         },\n@@ -51,12 +119,12 @@ fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExp\n     builder.provider.expectations\n }\n \n-fn lint_levels_on(tcx: TyCtxt<'_>, hir_id: HirId) -> FxHashMap<LintId, LevelAndSource> {\n+fn shallow_lint_levels_on(tcx: TyCtxt<'_>, hir_id: HirId) -> ShallowLintLevelMap {\n     let store = unerased_lint_store(tcx);\n \n     let mut levels = LintLevelsBuilder {\n         sess: tcx.sess,\n-        provider: LintLevelQueryMap { tcx, cur: hir_id, specs: FxHashMap::default() },\n+        provider: LintLevelQueryMap { tcx, cur: hir_id, specs: ShallowLintLevelMap::default() },\n         warn_about_weird_lints: false,\n         store,\n         registered_tools: &tcx.resolutions(()).registered_tools,\n@@ -77,12 +145,6 @@ pub struct TopDown {\n     cur: LintStackIndex,\n }\n \n-pub struct QueryMapExpectationsWrapper<'tcx> {\n-    map: LintLevelQueryMap<'tcx>,\n-    expectations: Vec<(LintExpectationId, LintExpectation)>,\n-    unstable_to_stable_ids: FxHashMap<LintExpectationId, LintExpectationId>,\n-}\n-\n pub trait LintLevelsProvider {\n     fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource>;\n     fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource>;\n@@ -104,28 +166,42 @@ impl LintLevelsProvider for TopDown {\n     }\n }\n \n+struct LintLevelQueryMap<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    cur: HirId,\n+    specs: ShallowLintLevelMap,\n+}\n+\n impl LintLevelsProvider for LintLevelQueryMap<'_> {\n     fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        &self.specs\n+        &self.specs.specs\n     }\n     fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        &mut self.specs\n+        &mut self.specs.specs\n     }\n     fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n-        self.lint_level(lint)\n+        self.specs.lint_level_id_at_node(self.tcx, LintId::of(lint), self.cur)\n     }\n }\n \n+struct QueryMapExpectationsWrapper<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    cur: HirId,\n+    specs: ShallowLintLevelMap,\n+    expectations: Vec<(LintExpectationId, LintExpectation)>,\n+    unstable_to_stable_ids: FxHashMap<LintExpectationId, LintExpectationId>,\n+}\n+\n impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n     fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        &self.map.specs\n+        &self.specs.specs\n     }\n     fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        self.map.specs.clear();\n-        &mut self.map.specs\n+        self.specs.specs.clear();\n+        &mut self.specs.specs\n     }\n     fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n-        self.map.lint_level(lint)\n+        self.specs.lint_level_id_at_node(self.tcx, LintId::of(lint), self.cur)\n     }\n     fn push_expectation(&mut self, id: LintExpectationId, expectation: LintExpectation) {\n         let LintExpectationId::Stable { attr_id: Some(attr_id), hir_id, attr_index, .. } = id else { bug!(\"unstable expectation id should already be mapped\") };\n@@ -144,19 +220,15 @@ impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n \n impl<'tcx> LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n     fn add_id(&mut self, hir_id: HirId) {\n-        self.add(\n-            self.provider.map.tcx.hir().attrs(hir_id),\n-            hir_id == hir::CRATE_HIR_ID,\n-            Some(hir_id),\n-        );\n+        self.add(self.provider.tcx.hir().attrs(hir_id), hir_id == hir::CRATE_HIR_ID, Some(hir_id));\n     }\n }\n \n impl<'tcx> intravisit::Visitor<'tcx> for LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n     type NestedFilter = nested_filter::All;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n-        self.provider.map.tcx.hir()\n+        self.provider.tcx.hir()\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n@@ -225,13 +297,12 @@ pub struct LintLevelsBuilder<'s, P> {\n     registered_tools: &'s RegisteredTools,\n }\n \n-pub struct BuilderPush {\n+pub(crate) struct BuilderPush {\n     prev: LintStackIndex,\n-    pub changed: bool,\n }\n \n impl<'s> LintLevelsBuilder<'s, TopDown> {\n-    pub fn new(\n+    pub(crate) fn new(\n         sess: &'s Session,\n         warn_about_weird_lints: bool,\n         store: &'s LintStore,\n@@ -289,11 +360,11 @@ impl<'s> LintLevelsBuilder<'s, TopDown> {\n             self.provider.cur = prev;\n         }\n \n-        BuilderPush { prev, changed: prev != self.provider.cur }\n+        BuilderPush { prev }\n     }\n \n     /// Called after `push` when the scope of a set of attributes are exited.\n-    pub fn pop(&mut self, push: BuilderPush) {\n+    pub(crate) fn pop(&mut self, push: BuilderPush) {\n         self.provider.cur = push.prev;\n     }\n }\n@@ -855,7 +926,7 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n \n     /// Used to emit a lint-related diagnostic based on the current state of\n     /// this lint context.\n-    pub fn struct_lint(\n+    pub(crate) fn struct_lint(\n         &self,\n         lint: &'static Lint,\n         span: Option<MultiSpan>,\n@@ -866,6 +937,6 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers { lint_levels_on, lint_expectations, ..*providers };\n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers { shallow_lint_levels_on, lint_expectations, ..*providers };\n }"}, {"sha": "2a22a6e5be1bad7c39f4492278a422ad312c61fb", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=ad09abc19415d48e24dbb231c85e521d909e77f7", "patch": "@@ -35,6 +35,7 @@\n #![feature(iter_order_by)]\n #![feature(let_chains)]\n #![feature(let_else)]\n+#![feature(min_specialization)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "c43a4b7a42eea985987295cd9dbd308234fb0bd9", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 83, "deletions": 180, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=ad09abc19415d48e24dbb231c85e521d909e77f7", "patch": "@@ -1,14 +1,11 @@\n use std::cmp;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::{Diagnostic, DiagnosticId, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir::HirId;\n-use rustc_index::vec::IndexVec;\n-use rustc_query_system::ich::StableHashingContext;\n use rustc_session::lint::{\n     builtin::{self, FORBIDDEN_LINT_GROUPS},\n-    FutureIncompatibilityReason, Level, Lint, LintExpectationId, LintId,\n+    FutureIncompatibilityReason, Level, Lint, LintId,\n };\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n@@ -61,209 +58,115 @@ impl LintLevelSource {\n /// A tuple of a lint level and its source.\n pub type LevelAndSource = (Level, LintLevelSource);\n \n-#[derive(Debug, HashStable)]\n-pub struct LintLevelSets {\n-    pub list: IndexVec<LintStackIndex, LintSet>,\n-}\n-\n-rustc_index::newtype_index! {\n-    #[derive(HashStable)]\n-    pub struct LintStackIndex {\n-        const COMMAND_LINE = 0,\n-    }\n-}\n-\n-#[derive(Debug, HashStable)]\n-pub struct LintSet {\n-    // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n-    // flag.\n+/// Return type for the `shallow_lint_levels_on` query.\n+///\n+/// This map represents the set of allowed lints and allowance levels given\n+/// by the attributes for *a single HirId*.\n+#[derive(Default, Debug, HashStable)]\n+pub struct ShallowLintLevelMap {\n     pub specs: FxHashMap<LintId, LevelAndSource>,\n-\n-    pub parent: LintStackIndex,\n }\n \n-impl LintLevelSets {\n-    pub fn new() -> Self {\n-        LintLevelSets { list: IndexVec::new() }\n-    }\n-\n-    pub fn actual_level(\n-        level: Option<Level>,\n-        src: &mut LintLevelSource,\n-        sess: &Session,\n-        lint: &'static Lint,\n-        get_lint_id_level: impl FnOnce(LintId) -> (Option<Level>, LintLevelSource),\n-    ) -> Level {\n-        // If `level` is none then we actually assume the default level for this\n-        // lint.\n-        let mut level = level.unwrap_or_else(|| lint.default_level(sess.edition()));\n-\n-        // If we're about to issue a warning, check at the last minute for any\n-        // directives against the warnings \"lint\". If, for example, there's an\n-        // `allow(warnings)` in scope then we want to respect that instead.\n-        //\n-        // We exempt `FORBIDDEN_LINT_GROUPS` from this because it specifically\n-        // triggers in cases (like #80988) where you have `forbid(warnings)`,\n-        // and so if we turned that into an error, it'd defeat the purpose of the\n-        // future compatibility warning.\n-        if level == Level::Warn && LintId::of(lint) != LintId::of(FORBIDDEN_LINT_GROUPS) {\n-            let (warnings_level, warnings_src) = get_lint_id_level(LintId::of(builtin::WARNINGS));\n-            if let Some(configured_warning_level) = warnings_level {\n-                if configured_warning_level != Level::Warn {\n-                    level = configured_warning_level;\n-                    *src = warnings_src;\n-                }\n+/// From an initial level and source, verify the effect of special annotations:\n+/// `warnings` lint level and lint caps.\n+///\n+/// The return of this function is suitable for diagnostics.\n+pub fn reveal_actual_level(\n+    level: Option<Level>,\n+    src: &mut LintLevelSource,\n+    sess: &Session,\n+    lint: LintId,\n+    probe_for_lint_level: impl FnOnce(LintId) -> (Option<Level>, LintLevelSource),\n+) -> Level {\n+    // If `level` is none then we actually assume the default level for this lint.\n+    let mut level = level.unwrap_or_else(|| lint.lint.default_level(sess.edition()));\n+\n+    // If we're about to issue a warning, check at the last minute for any\n+    // directives against the warnings \"lint\". If, for example, there's an\n+    // `allow(warnings)` in scope then we want to respect that instead.\n+    //\n+    // We exempt `FORBIDDEN_LINT_GROUPS` from this because it specifically\n+    // triggers in cases (like #80988) where you have `forbid(warnings)`,\n+    // and so if we turned that into an error, it'd defeat the purpose of the\n+    // future compatibility warning.\n+    if level == Level::Warn && lint != LintId::of(FORBIDDEN_LINT_GROUPS) {\n+        let (warnings_level, warnings_src) = probe_for_lint_level(LintId::of(builtin::WARNINGS));\n+        if let Some(configured_warning_level) = warnings_level {\n+            if configured_warning_level != Level::Warn {\n+                level = configured_warning_level;\n+                *src = warnings_src;\n             }\n         }\n-\n-        // Ensure that we never exceed the `--cap-lints` argument\n-        // unless the source is a --force-warn\n-        level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n-            level\n-        } else {\n-            cmp::min(level, sess.opts.lint_cap.unwrap_or(Level::Forbid))\n-        };\n-\n-        if let Some(driver_level) = sess.driver_lint_caps.get(&LintId::of(lint)) {\n-            // Ensure that we never exceed driver level.\n-            level = cmp::min(*driver_level, level);\n-        }\n-\n-        level\n     }\n \n-    pub fn get_lint_level(\n-        &self,\n-        lint: &'static Lint,\n-        idx: LintStackIndex,\n-        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n-        sess: &Session,\n-    ) -> LevelAndSource {\n-        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n-\n-        let level = Self::actual_level(level, &mut src, sess, lint, |id| {\n-            self.get_lint_id_level(id, idx, aux)\n-        });\n+    // Ensure that we never exceed the `--cap-lints` argument unless the source is a --force-warn\n+    level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n+        level\n+    } else {\n+        cmp::min(level, sess.opts.lint_cap.unwrap_or(Level::Forbid))\n+    };\n \n-        (level, src)\n+    if let Some(driver_level) = sess.driver_lint_caps.get(&lint) {\n+        // Ensure that we never exceed driver level.\n+        level = cmp::min(*driver_level, level);\n     }\n \n-    pub fn get_lint_id_level(\n+    level\n+}\n+\n+impl ShallowLintLevelMap {\n+    /// Perform a deep probe in the HIR tree looking for the actual level for the lint.\n+    /// This lint level is not usable for diagnostics, it needs to be corrected by\n+    /// `reveal_actual_level` beforehand.\n+    fn probe_for_lint_level(\n         &self,\n+        tcx: TyCtxt<'_>,\n         id: LintId,\n-        mut idx: LintStackIndex,\n-        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+        start: HirId,\n     ) -> (Option<Level>, LintLevelSource) {\n-        if let Some(specs) = aux {\n-            if let Some(&(level, src)) = specs.get(&id) {\n-                return (Some(level), src);\n-            }\n+        if let Some(&(level, src)) = self.specs.get(&id) {\n+            return (Some(level), src);\n         }\n-        loop {\n-            let LintSet { ref specs, parent } = self.list[idx];\n-            if let Some(&(level, src)) = specs.get(&id) {\n+\n+        for (parent, _) in tcx.hir().parent_iter(start) {\n+            let specs = tcx.shallow_lint_levels_on(parent);\n+            if let Some(&(level, src)) = specs.specs.get(&id) {\n                 return (Some(level), src);\n             }\n-            if idx == COMMAND_LINE {\n-                return (None, LintLevelSource::Default);\n-            }\n-            idx = parent;\n         }\n+        (None, LintLevelSource::Default)\n     }\n-}\n-\n-#[derive(Debug)]\n-pub struct LintLevelMap {\n-    /// This is a collection of lint expectations as described in RFC 2383, that\n-    /// can be fulfilled during this compilation session. This means that at least\n-    /// one expected lint is currently registered in the lint store.\n-    ///\n-    /// The [`LintExpectationId`] is stored as a part of the [`Expect`](Level::Expect)\n-    /// lint level.\n-    pub lint_expectations: Vec<(LintExpectationId, LintExpectation)>,\n-    pub sets: LintLevelSets,\n-    pub id_to_set: FxHashMap<HirId, LintStackIndex>,\n-}\n \n-impl LintLevelMap {\n-    /// If the `id` was previously registered with `register_id` when building\n-    /// this `LintLevelMap` this returns the corresponding lint level and source\n-    /// of the lint level for the lint provided.\n-    ///\n-    /// If the `id` was not previously registered, returns `None`. If `None` is\n-    /// returned then the parent of `id` should be acquired and this function\n-    /// should be called again.\n-    pub fn level_and_source(\n+    /// Fetch and return the user-visible lint level for the given lint at the given HirId.\n+    pub fn lint_level_id_at_node(\n         &self,\n-        lint: &'static Lint,\n+        tcx: TyCtxt<'_>,\n+        lint: LintId,\n         id: HirId,\n-        session: &Session,\n-    ) -> Option<LevelAndSource> {\n-        self.id_to_set.get(&id).map(|idx| self.sets.get_lint_level(lint, *idx, None, session))\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let LintLevelMap { ref sets, ref id_to_set, ref lint_expectations } = *self;\n-\n-        id_to_set.hash_stable(hcx, hasher);\n-        lint_expectations.hash_stable(hcx, hasher);\n-\n-        hcx.while_hashing_spans(true, |hcx| sets.hash_stable(hcx, hasher))\n+    ) -> (Level, LintLevelSource) {\n+        let (level, mut src) = self.probe_for_lint_level(tcx, lint, id);\n+        let level = reveal_actual_level(level, &mut src, tcx.sess, lint, |lint| {\n+            self.probe_for_lint_level(tcx, lint, id)\n+        });\n+        debug!(?id, ?level, ?src);\n+        (level, src)\n     }\n }\n-pub struct LintLevelQueryMap<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub cur: HirId,\n-    pub specs: FxHashMap<LintId, LevelAndSource>,\n-}\n-\n-impl<'tcx> LintLevelQueryMap<'tcx> {\n-    pub fn lint_id_level(&self, id: LintId) -> (Option<Level>, LintLevelSource) {\n-        Self::get_lint_id_level(id, self.cur, self.tcx, &self.specs)\n-    }\n \n-    pub fn lint_level(&self, lint: &'static Lint) -> LevelAndSource {\n-        Self::get_lint_level(LintId::of(lint), self.cur, self.tcx, &self.specs)\n+impl TyCtxt<'_> {\n+    /// Fetch and return the user-visible lint level for the given lint at the given HirId.\n+    pub fn lint_level_at_node(self, lint: &'static Lint, id: HirId) -> (Level, LintLevelSource) {\n+        self.shallow_lint_levels_on(id).lint_level_id_at_node(self, LintId::of(lint), id)\n     }\n \n-    pub fn get_lint_id_level(\n-        id: LintId,\n-        cur: HirId,\n-        tcx: TyCtxt<'tcx>,\n-        specs: &FxHashMap<LintId, LevelAndSource>,\n-    ) -> (Option<Level>, LintLevelSource) {\n-        if let Some(&(level, src)) = specs.get(&id) {\n-            return (Some(level), src);\n+    /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n+    /// It stops at `bound` and just returns it if reached.\n+    pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n+        let hir = self.hir();\n+        while id != bound && self.shallow_lint_levels_on(id).specs.is_empty() {\n+            id = hir.get_parent_node(id)\n         }\n-        let mut cur = cur;\n-\n-        loop {\n-            let parent = tcx.hir().get_parent_node(cur);\n-            if cur == parent {\n-                return (None, LintLevelSource::Default);\n-            }\n-            let specs = tcx.lint_levels_on(parent);\n-            if let Some(&(level, src)) = specs.get(&id) {\n-                return (Some(level), src);\n-            }\n-            cur = parent\n-        }\n-    }\n-\n-    pub fn get_lint_level(\n-        id: LintId,\n-        cur: HirId,\n-        tcx: TyCtxt<'tcx>,\n-        specs: &FxHashMap<LintId, LevelAndSource>,\n-    ) -> (Level, LintLevelSource) {\n-        let (level, mut src) = Self::get_lint_id_level(id, cur, tcx, specs);\n-        let level = LintLevelSets::actual_level(level, &mut src, tcx.sess, id.lint, |id| {\n-            Self::get_lint_id_level(id, cur, tcx, specs)\n-        });\n-        (level, src)\n+        id\n     }\n }\n "}, {"sha": "312777230aaea455122e9dfd72669bc74fcbbd94", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=ad09abc19415d48e24dbb231c85e521d909e77f7", "patch": "@@ -273,7 +273,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query lint_levels_on(key: HirId) -> FxHashMap<LintId, LevelAndSource> {\n+    query shallow_lint_levels_on(key: HirId) -> rustc_middle::lint::ShallowLintLevelMap {\n         arena_cache\n         desc { |tcx| \"looking up lint levels for `{}`\", key }\n     }"}, {"sha": "50d6dcbb79f20bb9f3f7956b660270e941185b89", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=ad09abc19415d48e24dbb231c85e521d909e77f7", "patch": "@@ -4,7 +4,7 @@ use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKind, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::{struct_lint_level, LintLevelSource};\n+use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n use crate::middle::stability;\n@@ -53,7 +53,7 @@ use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n use rustc_session::cstore::CrateStoreDyn;\n-use rustc_session::lint::{Level, Lint, LintId};\n+use rustc_session::lint::Lint;\n use rustc_session::Limit;\n use rustc_session::Session;\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n@@ -2809,41 +2809,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_bound_variable_kinds(xs))\n     }\n \n-    /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n-    /// It stops at `bound` and just returns it if reached.\n-    pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n-        let hir = self.hir();\n-        loop {\n-            if id == bound {\n-                return bound;\n-            }\n-\n-            if hir.attrs(id).iter().any(|attr| Level::from_attr(attr).is_some()) {\n-                return id;\n-            }\n-            let next = hir.get_parent_node(id);\n-            if next == id {\n-                bug!(\"lint traversal reached the root of the crate\");\n-            }\n-            id = next;\n-        }\n-    }\n-\n-    pub fn lint_level_at_node(\n-        self,\n-        lint: &'static Lint,\n-        id: hir::HirId,\n-    ) -> (Level, LintLevelSource) {\n-        let level_and_src = crate::lint::LintLevelQueryMap::get_lint_level(\n-            LintId::of(lint),\n-            id,\n-            self,\n-            self.lint_levels_on(id),\n-        );\n-        debug!(?id, ?level_and_src);\n-        level_and_src\n-    }\n-\n     /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,\n     /// typically generated by `#[derive(LintDiagnostic)]`).\n     pub fn emit_spanned_lint("}, {"sha": "36ea7946e9ae43f830df2d81ab2242873fb2a057", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad09abc19415d48e24dbb231c85e521d909e77f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=ad09abc19415d48e24dbb231c85e521d909e77f7", "patch": "@@ -1,6 +1,6 @@\n use crate::dep_graph;\n use crate::infer::canonical::{self, Canonical};\n-use crate::lint::{LevelAndSource, LintExpectation};\n+use crate::lint::LintExpectation;\n use crate::metadata::ModChild;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n@@ -51,7 +51,7 @@ use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n-use rustc_session::lint::{LintExpectationId, LintId};\n+use rustc_session::lint::LintExpectationId;\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Limits;\n use rustc_span::symbol::Symbol;"}]}