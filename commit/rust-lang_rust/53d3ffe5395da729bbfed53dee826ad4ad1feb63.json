{"sha": "53d3ffe5395da729bbfed53dee826ad4ad1feb63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZDNmZmU1Mzk1ZGE3MjliYmZlZDUzZGVlODI2YWQ0YWQxZmViNjM=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-02-12T06:22:07Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-08T15:50:22Z"}, "message": "Move borrowed_box to its own module", "tree": {"sha": "1ed9c7c00233d6c11aa1355c1326bfb1da7bcaa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ed9c7c00233d6c11aa1355c1326bfb1da7bcaa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53d3ffe5395da729bbfed53dee826ad4ad1feb63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53d3ffe5395da729bbfed53dee826ad4ad1feb63", "html_url": "https://github.com/rust-lang/rust/commit/53d3ffe5395da729bbfed53dee826ad4ad1feb63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53d3ffe5395da729bbfed53dee826ad4ad1feb63/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc3ab1c0ec8c94920fea7aab6c912297f489ff49", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc3ab1c0ec8c94920fea7aab6c912297f489ff49", "html_url": "https://github.com/rust-lang/rust/commit/cc3ab1c0ec8c94920fea7aab6c912297f489ff49"}], "stats": {"total": 240, "additions": 127, "deletions": 113}, "files": [{"sha": "4c2cad0ee94ddf2dedd89ec4d90dc8fa0dbd3792", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/53d3ffe5395da729bbfed53dee826ad4ad1feb63/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d3ffe5395da729bbfed53dee826ad4ad1feb63/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=53d3ffe5395da729bbfed53dee826ad4ad1feb63", "patch": "@@ -0,0 +1,118 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    self as hir, GenericArg, GenericBounds, GenericParamKind, HirId, Lifetime, MutTy, Mutability, Node, QPath,\n+    SyntheticTyParamKind, TyKind,\n+};\n+use rustc_lint::LateContext;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{match_path, paths, snippet, span_lint_and_sugg};\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    hir_ty: &hir::Ty<'_>,\n+    is_local: bool,\n+    lt: &Lifetime,\n+    mut_ty: &MutTy<'_>,\n+) -> bool {\n+    match mut_ty.ty.kind {\n+        TyKind::Path(ref qpath) => {\n+            let hir_id = mut_ty.ty.hir_id;\n+            let def = cx.qpath_res(qpath, hir_id);\n+            if_chain! {\n+                if let Some(def_id) = def.opt_def_id();\n+                if Some(def_id) == cx.tcx.lang_items().owned_box();\n+                if let QPath::Resolved(None, ref path) = *qpath;\n+                if let [ref bx] = *path.segments;\n+                if let Some(ref params) = bx.args;\n+                if !params.parenthesized;\n+                if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    _ => None,\n+                });\n+                then {\n+                    if is_any_trait(inner) {\n+                        // Ignore `Box<Any>` types; see issue #1884 for details.\n+                        return false;\n+                    }\n+\n+                    let ltopt = if lt.is_elided() {\n+                        String::new()\n+                    } else {\n+                        format!(\"{} \", lt.name.ident().as_str())\n+                    };\n+\n+                    if mut_ty.mutbl == Mutability::Mut {\n+                        // Ignore `&mut Box<T>` types; see issue #2907 for\n+                        // details.\n+                        return false;\n+                    }\n+\n+                    // When trait objects or opaque types have lifetime or auto-trait bounds,\n+                    // we need to add parentheses to avoid a syntax error due to its ambiguity.\n+                    // Originally reported as the issue #3128.\n+                    let inner_snippet = snippet(cx, inner.span, \"..\");\n+                    let suggestion = match &inner.kind {\n+                        TyKind::TraitObject(bounds, lt_bound) if bounds.len() > 1 || !lt_bound.is_elided() => {\n+                            format!(\"&{}({})\", ltopt, &inner_snippet)\n+                        },\n+                        TyKind::Path(qpath)\n+                            if get_bounds_if_impl_trait(cx, qpath, inner.hir_id)\n+                                .map_or(false, |bounds| bounds.len() > 1) =>\n+                        {\n+                            format!(\"&{}({})\", ltopt, &inner_snippet)\n+                        },\n+                        _ => format!(\"&{}{}\", ltopt, &inner_snippet),\n+                    };\n+                    span_lint_and_sugg(\n+                        cx,\n+                        super::BORROWED_BOX,\n+                        hir_ty.span,\n+                        \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n+                        \"try\",\n+                        suggestion,\n+                        // To make this `MachineApplicable`, at least one needs to check if it isn't a trait item\n+                        // because the trait impls of it will break otherwise;\n+                        // and there may be other cases that result in invalid code.\n+                        // For example, type coercion doesn't work nicely.\n+                        Applicability::Unspecified,\n+                    );\n+                    return true;\n+                }\n+            };\n+            false\n+        },\n+        _ => false,\n+    }\n+}\n+\n+// Returns true if given type is `Any` trait.\n+fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let TyKind::TraitObject(ref traits, _) = t.kind;\n+        if !traits.is_empty();\n+        // Only Send/Sync can be used as additional traits, so it is enough to\n+        // check only the first trait.\n+        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n+    if_chain! {\n+        if let Some(did) = cx.qpath_res(qpath, id).opt_def_id();\n+        if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n+        if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n+        if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n+        then {\n+            Some(generic_param.bounds)\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "8c2fc55308568fc0fc68cfeb1193c947f62240f6", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 9, "deletions": 113, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/53d3ffe5395da729bbfed53dee826ad4ad1feb63/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d3ffe5395da729bbfed53dee826ad4ad1feb63/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=53d3ffe5395da729bbfed53dee826ad4ad1feb63", "patch": "@@ -1,5 +1,6 @@\n #![allow(rustc::default_hash_types)]\n \n+mod borrowed_box;\n mod box_vec;\n mod linked_list;\n mod option_option;\n@@ -18,9 +19,9 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericBounds, GenericParamKind, HirId,\n-    ImplItem, ImplItemKind, Item, ItemKind, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt,\n-    StmtKind, SyntheticTyParamKind, TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n+    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n+    ImplItemKind, Item, ItemKind, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt, StmtKind, TraitFn,\n+    TraitItem, TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -376,7 +377,11 @@ impl Types {\n                     QPath::LangItem(..) => {},\n                 }\n             },\n-            TyKind::Rptr(ref lt, ref mut_ty) => self.check_ty_rptr(cx, hir_ty, is_local, lt, mut_ty),\n+            TyKind::Rptr(ref lt, ref mut_ty) => {\n+                if !borrowed_box::check(cx, hir_ty, is_local, lt, mut_ty) {\n+                    self.check_ty(cx, &mut_ty.ty, is_local);\n+                }\n+            },\n             TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n                 self.check_ty(cx, ty, is_local)\n             },\n@@ -388,115 +393,6 @@ impl Types {\n             _ => {},\n         }\n     }\n-\n-    fn check_ty_rptr(\n-        &mut self,\n-        cx: &LateContext<'_>,\n-        hir_ty: &hir::Ty<'_>,\n-        is_local: bool,\n-        lt: &Lifetime,\n-        mut_ty: &MutTy<'_>,\n-    ) {\n-        match mut_ty.ty.kind {\n-            TyKind::Path(ref qpath) => {\n-                let hir_id = mut_ty.ty.hir_id;\n-                let def = cx.qpath_res(qpath, hir_id);\n-                if_chain! {\n-                    if let Some(def_id) = def.opt_def_id();\n-                    if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                    if let QPath::Resolved(None, ref path) = *qpath;\n-                    if let [ref bx] = *path.segments;\n-                    if let Some(ref params) = bx.args;\n-                    if !params.parenthesized;\n-                    if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n-                        GenericArg::Type(ty) => Some(ty),\n-                        _ => None,\n-                    });\n-                    then {\n-                        if is_any_trait(inner) {\n-                            // Ignore `Box<Any>` types; see issue #1884 for details.\n-                            return;\n-                        }\n-\n-                        let ltopt = if lt.is_elided() {\n-                            String::new()\n-                        } else {\n-                            format!(\"{} \", lt.name.ident().as_str())\n-                        };\n-\n-                        if mut_ty.mutbl == Mutability::Mut {\n-                            // Ignore `&mut Box<T>` types; see issue #2907 for\n-                            // details.\n-                            return;\n-                        }\n-\n-                        // When trait objects or opaque types have lifetime or auto-trait bounds,\n-                        // we need to add parentheses to avoid a syntax error due to its ambiguity.\n-                        // Originally reported as the issue #3128.\n-                        let inner_snippet = snippet(cx, inner.span, \"..\");\n-                        let suggestion = match &inner.kind {\n-                            TyKind::TraitObject(bounds, lt_bound) if bounds.len() > 1 || !lt_bound.is_elided() => {\n-                                format!(\"&{}({})\", ltopt, &inner_snippet)\n-                            },\n-                            TyKind::Path(qpath)\n-                                if get_bounds_if_impl_trait(cx, qpath, inner.hir_id)\n-                                    .map_or(false, |bounds| bounds.len() > 1) =>\n-                            {\n-                                format!(\"&{}({})\", ltopt, &inner_snippet)\n-                            },\n-                            _ => format!(\"&{}{}\", ltopt, &inner_snippet),\n-                        };\n-                        span_lint_and_sugg(\n-                            cx,\n-                            BORROWED_BOX,\n-                            hir_ty.span,\n-                            \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n-                            \"try\",\n-                            suggestion,\n-                            // To make this `MachineApplicable`, at least one needs to check if it isn't a trait item\n-                            // because the trait impls of it will break otherwise;\n-                            // and there may be other cases that result in invalid code.\n-                            // For example, type coercion doesn't work nicely.\n-                            Applicability::Unspecified,\n-                        );\n-                        return; // don't recurse into the type\n-                    }\n-                };\n-                self.check_ty(cx, &mut_ty.ty, is_local);\n-            },\n-            _ => self.check_ty(cx, &mut_ty.ty, is_local),\n-        }\n-    }\n-}\n-\n-// Returns true if given type is `Any` trait.\n-fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let TyKind::TraitObject(ref traits, _) = t.kind;\n-        if !traits.is_empty();\n-        // Only Send/Sync can be used as additional traits, so it is enough to\n-        // check only the first trait.\n-        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n-    if_chain! {\n-        if let Some(did) = cx.qpath_res(qpath, id).opt_def_id();\n-        if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n-        if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n-        if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n-        then {\n-            Some(generic_param.bounds)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n declare_clippy_lint! {"}]}