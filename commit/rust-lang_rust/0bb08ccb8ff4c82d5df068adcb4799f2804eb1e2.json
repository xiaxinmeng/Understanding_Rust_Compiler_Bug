{"sha": "0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2", "node_id": "C_kwDOAAsO6NoAKDBiYjA4Y2NiOGZmNGM4MmQ1ZGYwNjhhZGNiNDc5OWYyODA0ZWIxZTI", "commit": {"author": {"name": "rainy-me", "email": "github@yue.coffee", "date": "2021-11-24T15:21:29Z"}, "committer": {"name": "rainy-me", "email": "github@yue.coffee", "date": "2021-11-24T15:21:29Z"}, "message": "fix: derive path handling", "tree": {"sha": "ffcbd7b30d2a8696ba5f9a4ad78d32497d0328ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffcbd7b30d2a8696ba5f9a4ad78d32497d0328ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2", "html_url": "https://github.com/rust-lang/rust/commit/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2/comments", "author": {"login": "yue4u", "id": 26110087, "node_id": "MDQ6VXNlcjI2MTEwMDg3", "avatar_url": "https://avatars.githubusercontent.com/u/26110087?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yue4u", "html_url": "https://github.com/yue4u", "followers_url": "https://api.github.com/users/yue4u/followers", "following_url": "https://api.github.com/users/yue4u/following{/other_user}", "gists_url": "https://api.github.com/users/yue4u/gists{/gist_id}", "starred_url": "https://api.github.com/users/yue4u/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yue4u/subscriptions", "organizations_url": "https://api.github.com/users/yue4u/orgs", "repos_url": "https://api.github.com/users/yue4u/repos", "events_url": "https://api.github.com/users/yue4u/events{/privacy}", "received_events_url": "https://api.github.com/users/yue4u/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yue4u", "id": 26110087, "node_id": "MDQ6VXNlcjI2MTEwMDg3", "avatar_url": "https://avatars.githubusercontent.com/u/26110087?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yue4u", "html_url": "https://github.com/yue4u", "followers_url": "https://api.github.com/users/yue4u/followers", "following_url": "https://api.github.com/users/yue4u/following{/other_user}", "gists_url": "https://api.github.com/users/yue4u/gists{/gist_id}", "starred_url": "https://api.github.com/users/yue4u/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yue4u/subscriptions", "organizations_url": "https://api.github.com/users/yue4u/orgs", "repos_url": "https://api.github.com/users/yue4u/repos", "events_url": "https://api.github.com/users/yue4u/events{/privacy}", "received_events_url": "https://api.github.com/users/yue4u/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e4ac8a2c9136052c6394014048095e5c2468859", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e4ac8a2c9136052c6394014048095e5c2468859", "html_url": "https://github.com/rust-lang/rust/commit/3e4ac8a2c9136052c6394014048095e5c2468859"}], "stats": {"total": 171, "additions": 118, "deletions": 53}, "files": [{"sha": "3e33c62144ea727aa2f45bf3ce55508fa2ac7eaf", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 85, "deletions": 30, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2", "patch": "@@ -1,10 +1,13 @@\n use hir::ModuleDef;\n-use ide_db::helpers::{import_assets::NameToImport, mod_path_to_ast};\n+use ide_db::helpers::{\n+    get_path_at_cursor_in_tt, import_assets::NameToImport, mod_path_to_ast,\n+    parse_tt_as_comma_sep_paths,\n+};\n use ide_db::items_locator;\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, make, AstNode, HasName},\n-    SyntaxKind::{IDENT, WHITESPACE},\n+    ast::{self, AstNode, AstToken, HasName},\n+    SyntaxKind::WHITESPACE,\n };\n \n use crate::{\n@@ -52,9 +55,8 @@ pub(crate) fn replace_derive_with_manual_impl(\n         return None;\n     }\n \n-    let trait_token = args.syntax().token_at_offset(ctx.offset()).find(|t| t.kind() == IDENT)?;\n-    let trait_name = trait_token.text();\n-\n+    let ident = args.syntax().token_at_offset(ctx.offset()).find_map(ast::Ident::cast)?;\n+    let trait_path = get_path_at_cursor_in_tt(&ident)?;\n     let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n \n     let current_module = ctx.sema.scope(adt.syntax()).module()?;\n@@ -63,7 +65,7 @@ pub(crate) fn replace_derive_with_manual_impl(\n     let found_traits = items_locator::items_with_name(\n         &ctx.sema,\n         current_crate,\n-        NameToImport::Exact(trait_name.to_string()),\n+        NameToImport::Exact(trait_path.segments().last()?.to_string()),\n         items_locator::AssocItemSearch::Exclude,\n         Some(items_locator::DEFAULT_QUERY_SEARCH_LIMIT.inner()),\n     )\n@@ -80,12 +82,23 @@ pub(crate) fn replace_derive_with_manual_impl(\n     });\n \n     let mut no_traits_found = true;\n-    for (trait_path, trait_) in found_traits.inspect(|_| no_traits_found = false) {\n-        add_assist(acc, ctx, &attr, &args, &trait_path, Some(trait_), &adt)?;\n+    let current_derives = parse_tt_as_comma_sep_paths(args.clone())?;\n+    let current_derives = current_derives.as_slice();\n+    for (replace_trait_path, trait_) in found_traits.inspect(|_| no_traits_found = false) {\n+        add_assist(\n+            acc,\n+            ctx,\n+            &attr,\n+            &current_derives,\n+            &args,\n+            &trait_path,\n+            &replace_trait_path,\n+            Some(trait_),\n+            &adt,\n+        )?;\n     }\n     if no_traits_found {\n-        let trait_path = make::ext::ident_path(trait_name);\n-        add_assist(acc, ctx, &attr, &args, &trait_path, None, &adt)?;\n+        add_assist(acc, ctx, &attr, &current_derives, &args, &trait_path, &trait_path, None, &adt)?;\n     }\n     Some(())\n }\n@@ -94,15 +107,16 @@ fn add_assist(\n     acc: &mut Assists,\n     ctx: &AssistContext,\n     attr: &ast::Attr,\n-    input: &ast::TokenTree,\n-    trait_path: &ast::Path,\n+    old_derives: &[ast::Path],\n+    old_tree: &ast::TokenTree,\n+    old_trait_path: &ast::Path,\n+    replace_trait_path: &ast::Path,\n     trait_: Option<hir::Trait>,\n     adt: &ast::Adt,\n ) -> Option<()> {\n     let target = attr.syntax().text_range();\n     let annotated_name = adt.name()?;\n-    let label = format!(\"Convert to manual `impl {} for {}`\", trait_path, annotated_name);\n-    let trait_name = trait_path.segment().and_then(|seg| seg.name_ref())?;\n+    let label = format!(\"Convert to manual `impl {} for {}`\", replace_trait_path, annotated_name);\n \n     acc.add(\n         AssistId(\"replace_derive_with_manual_impl\", AssistKind::Refactor),\n@@ -111,9 +125,9 @@ fn add_assist(\n         |builder| {\n             let insert_pos = adt.syntax().text_range().end();\n             let impl_def_with_items =\n-                impl_def_from_trait(&ctx.sema, adt, &annotated_name, trait_, trait_path);\n-            update_attribute(builder, input, &trait_name, attr);\n-            let trait_path = format!(\"{}\", trait_path);\n+                impl_def_from_trait(&ctx.sema, adt, &annotated_name, trait_, replace_trait_path);\n+            update_attribute(builder, old_derives, old_tree, old_trait_path, attr);\n+            let trait_path = format!(\"{}\", replace_trait_path);\n             match (ctx.config.snippet_cap, impl_def_with_items) {\n                 (None, _) => {\n                     builder.insert(insert_pos, generate_trait_impl_text(adt, &trait_path, \"\"))\n@@ -192,23 +206,20 @@ fn impl_def_from_trait(\n \n fn update_attribute(\n     builder: &mut AssistBuilder,\n-    input: &ast::TokenTree,\n-    trait_name: &ast::NameRef,\n+    old_derives: &[ast::Path],\n+    old_tree: &ast::TokenTree,\n+    old_trait_path: &ast::Path,\n     attr: &ast::Attr,\n ) {\n-    let trait_name = trait_name.text();\n-    let new_attr_input = input\n-        .syntax()\n-        .descendants_with_tokens()\n-        .filter(|t| t.kind() == IDENT)\n-        .filter_map(|t| t.into_token().map(|t| t.text().to_string()))\n-        .filter(|t| t != &trait_name)\n+    let new_derives = old_derives\n+        .iter()\n+        .filter(|t| t.to_string() != old_trait_path.to_string())\n         .collect::<Vec<_>>();\n-    let has_more_derives = !new_attr_input.is_empty();\n+    let has_more_derives = !new_derives.is_empty();\n \n     if has_more_derives {\n-        let new_attr_input = format!(\"({})\", new_attr_input.iter().format(\", \"));\n-        builder.replace(input.syntax().text_range(), new_attr_input);\n+        let new_derives = format!(\"({})\", new_derives.iter().format(\", \"));\n+        builder.replace(old_tree.syntax().text_range(), new_derives);\n     } else {\n         let attr_range = attr.syntax().text_range();\n         builder.delete(attr_range);\n@@ -1165,4 +1176,48 @@ struct S;\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn add_custom_impl_keep_path() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: clone\n+#[derive(std::fmt::Debug, Clo$0ne)]\n+pub struct Foo;\n+\"#,\n+            r#\"\n+#[derive(std::fmt::Debug)]\n+pub struct Foo;\n+\n+impl Clone for Foo {\n+    $0fn clone(&self) -> Self {\n+        Self {  }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_replace_path() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: fmt\n+#[derive(core::fmt::Deb$0ug, Clone)]\n+pub struct Foo;\n+\"#,\n+            r#\"\n+#[derive(Clone)]\n+pub struct Foo;\n+\n+impl core::fmt::Debug for Foo {\n+    $0fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        f.debug_struct(\"Foo\").finish()\n+    }\n+}\n+\"#,\n+        )\n+    }\n }"}, {"sha": "8740db326b0e9e2108b5a538af65d1af6ac47312", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2", "patch": "@@ -4,7 +4,10 @@\n //! for built-in attributes.\n \n use hir::HasAttrs;\n-use ide_db::helpers::generated_lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES, RUSTDOC_LINTS};\n+use ide_db::helpers::{\n+    generated_lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES, RUSTDOC_LINTS},\n+    parse_tt_as_comma_sep_paths,\n+};\n use itertools::Itertools;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n@@ -30,12 +33,14 @@ pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n     match (name_ref, attribute.token_tree()) {\n         (Some(path), Some(token_tree)) => match path.text().as_str() {\n             \"repr\" => repr::complete_repr(acc, ctx, token_tree),\n-            \"derive\" => derive::complete_derive(acc, ctx, &parse_comma_sep_paths(token_tree)?),\n+            \"derive\" => {\n+                derive::complete_derive(acc, ctx, &parse_tt_as_comma_sep_paths(token_tree)?)\n+            }\n             \"feature\" => {\n-                lint::complete_lint(acc, ctx, &parse_comma_sep_paths(token_tree)?, FEATURES)\n+                lint::complete_lint(acc, ctx, &parse_tt_as_comma_sep_paths(token_tree)?, FEATURES)\n             }\n             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                let existing_lints = parse_comma_sep_paths(token_tree)?;\n+                let existing_lints = parse_tt_as_comma_sep_paths(token_tree)?;\n                 lint::complete_lint(acc, ctx, &existing_lints, DEFAULT_LINTS);\n                 lint::complete_lint(acc, ctx, &existing_lints, CLIPPY_LINTS);\n                 lint::complete_lint(acc, ctx, &existing_lints, RUSTDOC_LINTS);\n@@ -307,23 +312,6 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     .prefer_inner(),\n ];\n \n-fn parse_comma_sep_paths(input: ast::TokenTree) -> Option<Vec<ast::Path>> {\n-    let r_paren = input.r_paren_token()?;\n-    let tokens = input\n-        .syntax()\n-        .children_with_tokens()\n-        .skip(1)\n-        .take_while(|it| it.as_token() != Some(&r_paren));\n-    let input_expressions = tokens.into_iter().group_by(|tok| tok.kind() == T![,]);\n-    Some(\n-        input_expressions\n-            .into_iter()\n-            .filter_map(|(is_sep, group)| (!is_sep).then(|| group))\n-            .filter_map(|mut tokens| ast::Path::parse(&tokens.join(\"\")).ok())\n-            .collect::<Vec<ast::Path>>(),\n-    )\n-}\n-\n fn parse_comma_sep_expr(input: ast::TokenTree) -> Option<Vec<ast::Expr>> {\n     let r_paren = input.r_paren_token()?;\n     let tokens = input"}, {"sha": "1b9cb7ff51cdbacd81d27d7c70aeee77f8a245ef", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=0bb08ccb8ff4c82d5df068adcb4799f2804eb1e2", "patch": "@@ -39,10 +39,9 @@ pub fn get_path_in_derive_attr(\n     attr: &ast::Attr,\n     cursor: &Ident,\n ) -> Option<ast::Path> {\n-    let cursor = cursor.syntax();\n     let path = attr.path()?;\n     let tt = attr.token_tree()?;\n-    if !tt.syntax().text_range().contains_range(cursor.text_range()) {\n+    if !tt.syntax().text_range().contains_range(cursor.syntax().text_range()) {\n         return None;\n     }\n     let scope = sema.scope(attr.syntax());\n@@ -51,7 +50,12 @@ pub fn get_path_in_derive_attr(\n     if PathResolution::Macro(derive) != resolved_attr {\n         return None;\n     }\n+    get_path_at_cursor_in_tt(cursor)\n+}\n \n+/// Parses the path the identifier is part of inside a token tree.\n+pub fn get_path_at_cursor_in_tt(cursor: &Ident) -> Option<ast::Path> {\n+    let cursor = cursor.syntax();\n     let first = cursor\n         .siblings_with_tokens(Direction::Prev)\n         .filter_map(SyntaxElement::into_token)\n@@ -300,3 +304,21 @@ pub fn lint_eq_or_in_group(lint: &str, lint_is: &str) -> bool {\n         false\n     }\n }\n+\n+/// Parses the input token tree as comma separated paths.\n+pub fn parse_tt_as_comma_sep_paths(input: ast::TokenTree) -> Option<Vec<ast::Path>> {\n+    let r_paren = input.r_paren_token()?;\n+    let tokens = input\n+        .syntax()\n+        .children_with_tokens()\n+        .skip(1)\n+        .take_while(|it| it.as_token() != Some(&r_paren));\n+    let input_expressions = tokens.into_iter().group_by(|tok| tok.kind() == T![,]);\n+    Some(\n+        input_expressions\n+            .into_iter()\n+            .filter_map(|(is_sep, group)| (!is_sep).then(|| group))\n+            .filter_map(|mut tokens| ast::Path::parse(&tokens.join(\"\")).ok())\n+            .collect::<Vec<ast::Path>>(),\n+    )\n+}"}]}