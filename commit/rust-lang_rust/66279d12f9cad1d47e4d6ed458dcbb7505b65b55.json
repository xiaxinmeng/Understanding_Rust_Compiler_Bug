{"sha": "66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2Mjc5ZDEyZjljYWQxZDQ3ZTRkNmVkNDU4ZGNiYjc1MDViNjViNTU=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-10-14T05:38:38Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-12-02T13:30:30Z"}, "message": "Revert back to using FunctionCx's Body", "tree": {"sha": "d9bfb8af0401d4850f8881d5d04e6c38e621a0a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9bfb8af0401d4850f8881d5d04e6c38e621a0a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "html_url": "https://github.com/rust-lang/rust/commit/66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16952cce01578e935aff02d12ab2d95821d7aed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/16952cce01578e935aff02d12ab2d95821d7aed2", "html_url": "https://github.com/rust-lang/rust/commit/16952cce01578e935aff02d12ab2d95821d7aed2"}], "stats": {"total": 265, "additions": 118, "deletions": 147}, "files": [{"sha": "171e3c840fbf792ba49ef0c2636282dc24a366c0", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "patch": "@@ -245,7 +245,7 @@ impl<'mir, 'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n         if let Some(index) = place.as_local() {\n             self.assign(index, location);\n             let decl_span = self.fx.mir.local_decls[index].source_info.span;\n-            if !self.fx.rvalue_creates_operand(rvalue, decl_span, self.fx.mir) {\n+            if !self.fx.rvalue_creates_operand(rvalue, decl_span) {\n                 self.not_ssa(index);\n             }\n         } else {"}, {"sha": "53bffc794d7703629759ff336f4543386466bb14", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 67, "deletions": 86, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "patch": "@@ -2,7 +2,7 @@ use rustc_index::vec::Idx;\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnAbiExt};\n-use rustc::mir::{self, Body, PlaceBase, Static, StaticKind};\n+use rustc::mir::{self, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::PanicInfo;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::spec::abi::Abi;\n@@ -46,7 +46,6 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n     fn lltarget<'b, 'c, 'd, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n         fx: &'d mut FunctionCx<'b, 'c, 'tcx, Bx>,\n-        mir: &Body<'tcx>,\n         target: mir::BasicBlock\n     ) -> (Bx::BasicBlock, bool) {\n         let span = self.terminator.source_info.span;\n@@ -57,20 +56,19 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n             (Some(f), Some(t_f)) if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) =>\n                 (lltarget, false),\n             // jump *into* cleanup - need a landing pad if GNU\n-            (None, Some(_)) => (fx.landing_pad_to(target, mir), false),\n+            (None, Some(_)) => (fx.landing_pad_to(target), false),\n             (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n-            (Some(_), Some(_)) => (fx.landing_pad_to(target, mir), true),\n+            (Some(_), Some(_)) => (fx.landing_pad_to(target), true),\n         }\n     }\n \n     /// Create a basic block.\n     fn llblock<'d, 'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n         fx: &'d mut FunctionCx<'b, 'c, 'tcx, Bx>,\n-        mir: &Body<'tcx>,\n         target: mir::BasicBlock\n     ) -> Bx::BasicBlock {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, mir, target);\n+        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n         if is_cleanupret {\n             // MSVC cross-funclet jump - need a trampoline\n \n@@ -88,11 +86,10 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n     fn funclet_br<'d, 'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n         fx: &'d mut FunctionCx<'b, 'c, 'tcx, Bx>,\n-        mir: &Body<'tcx>,\n         bx: &mut Bx,\n         target: mir::BasicBlock,\n     ) {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, mir, target);\n+        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n         if is_cleanupret {\n             // micro-optimization: generate a `ret` rather than a jump\n             // to a trampoline.\n@@ -107,7 +104,6 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n     fn do_call<'d, 'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n         fx: &'d mut FunctionCx<'b, 'c, 'tcx, Bx>,\n-        mir: &Body<'tcx>,\n         bx: &mut Bx,\n         fn_abi: FnAbi<'tcx, Ty<'tcx>>,\n         fn_ptr: Bx::Value,\n@@ -124,19 +120,19 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n             let invokeret = bx.invoke(fn_ptr,\n                                       &llargs,\n                                       ret_bx,\n-                                      self.llblock(fx, mir, cleanup),\n+                                      self.llblock(fx, cleanup),\n                                       self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, invokeret);\n \n             if let Some((ret_dest, target)) = destination {\n                 let mut ret_bx = fx.build_block(target);\n-                fx.set_debug_loc(&mut ret_bx, self.terminator.source_info, mir);\n+                fx.set_debug_loc(&mut ret_bx, self.terminator.source_info);\n                 fx.store_return(&mut ret_bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n             let llret = bx.call(fn_ptr, &llargs, self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, llret);\n-            if mir[*self.bb].is_cleanup {\n+            if fx.mir[*self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline\n                 // drop glue. Also, when there is a deeply-nested\n                 // struct, there are \"symmetry\" issues that cause\n@@ -146,7 +142,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n \n             if let Some((ret_dest, target)) = destination {\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, llret);\n-                self.funclet_br(fx, mir, bx, target);\n+                self.funclet_br(fx, bx, target);\n             } else {\n                 bx.unreachable();\n             }\n@@ -208,20 +204,19 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     fn codegen_switchint_terminator<'c>(\n         &mut self,\n         helper: TerminatorCodegenHelper<'c, 'tcx>,\n-        mir: &Body<'tcx>,\n         mut bx: Bx,\n         discr: &mir::Operand<'tcx>,\n         switch_ty: Ty<'tcx>,\n         values: &Cow<'tcx, [u128]>,\n         targets: &Vec<mir::BasicBlock>,\n     ) {\n-        let discr = self.codegen_operand(mir, &mut bx, &discr);\n+        let discr = self.codegen_operand(&mut bx, &discr);\n         if targets.len() == 2 {\n             // If there are two targets, emit br instead of switch\n-            let lltrue = helper.llblock(self, mir, targets[0]);\n-            let llfalse = helper.llblock(self, mir, targets[1]);\n+            let lltrue = helper.llblock(self, targets[0]);\n+            let llfalse = helper.llblock(self, targets[1]);\n             if switch_ty == bx.tcx().types.bool {\n-                helper.maybe_sideeffect(mir, &mut bx, targets.as_slice());\n+                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 // Don't generate trivial icmps when switching on bool\n                 if let [0] = values[..] {\n                     bx.cond_br(discr.immediate(), llfalse, lltrue);\n@@ -243,15 +238,15 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             let (otherwise, targets) = targets.split_last().unwrap();\n             bx.switch(\n                 discr.immediate(),\n-                helper.llblock(self, mir, *otherwise),\n+                helper.llblock(self, *otherwise),\n                 values.iter().zip(targets).map(|(&value, target)| {\n-                    (value, helper.llblock(self, mir, *target))\n+                    (value, helper.llblock(self, *target))\n                 })\n             );\n         }\n     }\n \n-    fn codegen_return_terminator(&mut self, mir: &Body<'tcx>, mut bx: Bx) {\n+    fn codegen_return_terminator(&mut self, mut bx: Bx) {\n         // Call `va_end` if this is the definition of a C-variadic function.\n         if self.fn_abi.c_variadic {\n             // The `VaList` \"spoofed\" argument is just after all the real arguments.\n@@ -278,7 +273,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 let op =\n-                    self.codegen_consume(mir, &mut bx, &mir::Place::return_place().as_ref());\n+                    self.codegen_consume(&mut bx, &mir::Place::return_place().as_ref());\n                 if let Ref(llval, _, align) = op.val {\n                     bx.load(llval, align)\n                 } else {\n@@ -324,24 +319,23 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     fn codegen_drop_terminator<'c>(\n         &mut self,\n         helper: TerminatorCodegenHelper<'c, 'tcx>,\n-        mir: &Body<'tcx>,\n         mut bx: Bx,\n         location: &mir::Place<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(mir, bx.tcx()).ty;\n+        let ty = location.ty(self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n-            helper.maybe_sideeffect(mir, &mut bx, &[target]);\n-            helper.funclet_br(self, mir, &mut bx, target);\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+            helper.funclet_br(self, &mut bx, target);\n             return\n         }\n \n-        let place = self.codegen_place(mir, &mut bx, &location.as_ref());\n+        let place = self.codegen_place(&mut bx, &location.as_ref());\n         let (args1, args2);\n         let mut args = if let Some(llextra) = place.llextra {\n             args2 = [place.llval, llextra];\n@@ -367,7 +361,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                  FnAbi::of_instance(&bx, drop_fn))\n             }\n         };\n-        helper.maybe_sideeffect(mir, &mut bx, &[target]);\n+        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n                        Some((ReturnDest::Nothing, target)),\n                        unwind);\n@@ -376,7 +370,6 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     fn codegen_assert_terminator<'c>(\n         &mut self,\n         helper: TerminatorCodegenHelper<'c, 'tcx>,\n-        mir: &Body<'tcx>,\n         mut bx: Bx,\n         terminator: &mir::Terminator<'tcx>,\n         cond: &mir::Operand<'tcx>,\n@@ -386,7 +379,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         cleanup: Option<mir::BasicBlock>,\n     ) {\n         let span = terminator.source_info.span;\n-        let cond = self.codegen_operand(mir, &mut bx, cond).immediate();\n+        let cond = self.codegen_operand(&mut bx, cond).immediate();\n         let mut const_cond = bx.const_to_opt_u128(cond, false).map(|c| c == 1);\n \n         // This case can currently arise only from functions marked\n@@ -404,18 +397,18 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n-            helper.maybe_sideeffect(mir, &mut bx, &[target]);\n-            helper.funclet_br(self, mir, &mut bx, target);\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+            helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n \n         // Pass the condition through llvm.expect for branch hinting.\n         let cond = bx.expect(cond, expected);\n \n         // Create the failure block and the conditional branch to it.\n-        let lltarget = helper.llblock(self, mir, target);\n+        let lltarget = helper.llblock(self, target);\n         let panic_block = self.new_block(\"panic\");\n-        helper.maybe_sideeffect(mir, &mut bx, &[target]);\n+        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -424,16 +417,16 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         // After this point, bx is the block for the call to panic.\n         bx = panic_block;\n-        self.set_debug_loc(&mut bx, terminator.source_info, mir);\n+        self.set_debug_loc(&mut bx, terminator.source_info);\n \n         // Get the location information.\n         let location = self.get_caller_location(&mut bx, span).immediate();\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match msg {\n             PanicInfo::BoundsCheck { ref len, ref index } => {\n-                let len = self.codegen_operand(mir, &mut bx, len).immediate();\n-                let index = self.codegen_operand(mir, &mut bx, index).immediate();\n+                let len = self.codegen_operand(&mut bx, len).immediate();\n+                let index = self.codegen_operand(&mut bx, index).immediate();\n                 (lang_items::PanicBoundsCheckFnLangItem, vec![location, index, len])\n             }\n             _ => {\n@@ -450,13 +443,12 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         let llfn = bx.get_fn_addr(instance);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, mir, &mut bx, fn_abi, llfn, &args, None, cleanup);\n+        helper.do_call(self, &mut bx, fn_abi, llfn, &args, None, cleanup);\n     }\n \n     fn codegen_call_terminator<'c>(\n         &mut self,\n         helper: TerminatorCodegenHelper<'c, 'tcx>,\n-        mir: &Body<'tcx>,\n         mut bx: Bx,\n         terminator: &mir::Terminator<'tcx>,\n         func: &mir::Operand<'tcx>,\n@@ -466,7 +458,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     ) {\n         let span = terminator.source_info.span;\n         // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n-        let callee = self.codegen_operand(mir, &mut bx, func);\n+        let callee = self.codegen_operand(&mut bx, func);\n \n         let (instance, mut llfn) = match callee.layout.ty.kind {\n             ty::FnDef(def_id, substs) => {\n@@ -500,9 +492,9 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         if intrinsic == Some(\"transmute\") {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(ref dest, target) = destination_ref;\n-                self.codegen_transmute(mir, &mut bx, &args[0], dest);\n-                helper.maybe_sideeffect(mir, &mut bx, &[target]);\n-                helper.funclet_br(self, mir, &mut bx, target);\n+                self.codegen_transmute(&mut bx, &args[0], dest);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.funclet_br(self, &mut bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n                 // it is likely there is no allotted destination. In fact,\n@@ -518,7 +510,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         let extra_args = &args[sig.inputs().len()..];\n         let extra_args = extra_args.iter().map(|op_arg| {\n-            let op_ty = op_arg.ty(mir, bx.tcx());\n+            let op_ty = op_arg.ty(self.mir, bx.tcx());\n             self.monomorphize(&op_ty)\n         }).collect::<Vec<_>>();\n \n@@ -529,8 +521,8 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             Some(ty::InstanceDef::DropGlue(_, None)) => {\n                 // Empty drop glue; a no-op.\n                 let &(_, target) = destination.as_ref().unwrap();\n-                helper.maybe_sideeffect(mir, &mut bx, &[target]);\n-                helper.funclet_br(self, mir, &mut bx, target);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.funclet_br(self, &mut bx, target);\n                 return;\n             }\n             _ => FnAbi::new(&bx, sig, &extra_args)\n@@ -566,7 +558,6 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n                     self,\n-                    mir,\n                     &mut bx,\n                     fn_abi,\n                     llfn,\n@@ -590,8 +581,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         // Prepare the return value destination\n         let ret_dest = if let Some((ref dest, _)) = *destination {\n             let is_intrinsic = intrinsic.is_some();\n-            self.make_return_dest(&mut bx, dest, &fn_abi.ret, &mut llargs,\n-                                  is_intrinsic, mir)\n+            self.make_return_dest(&mut bx, dest, &fn_abi.ret, &mut llargs, is_intrinsic)\n         } else {\n             ReturnDest::Nothing\n         };\n@@ -680,7 +670,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                     }\n                 }\n \n-                self.codegen_operand(mir, &mut bx, arg)\n+                self.codegen_operand(&mut bx, arg)\n             }).collect();\n \n \n@@ -692,8 +682,8 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             if let Some((_, target)) = *destination {\n-                helper.maybe_sideeffect(mir, &mut bx, &[target]);\n-                helper.funclet_br(self, mir, &mut bx, target);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.funclet_br(self, &mut bx, target);\n             } else {\n                 bx.unreachable();\n             }\n@@ -710,7 +700,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         };\n \n         'make_args: for (i, arg) in first_args.iter().enumerate() {\n-            let mut op = self.codegen_operand(mir, &mut bx, arg);\n+            let mut op = self.codegen_operand(&mut bx, arg);\n \n             if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n                 if let Pair(..) = op.val {\n@@ -775,7 +765,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             self.codegen_argument(&mut bx, op, &mut llargs, &fn_abi.args[i]);\n         }\n         if let Some(tup) = untuple {\n-            self.codegen_arguments_untupled(mir, &mut bx, tup, &mut llargs,\n+            self.codegen_arguments_untupled(&mut bx, tup, &mut llargs,\n                 &fn_abi.args[first_args.len()..])\n         }\n \n@@ -786,7 +776,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         };\n \n         if let Some((_, target)) = destination.as_ref() {\n-            helper.maybe_sideeffect(mir, &mut bx, &[*target]);\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n         }\n         helper.do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n@@ -798,26 +788,24 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     pub fn codegen_block(\n         &mut self,\n         bb: mir::BasicBlock,\n-        mir: &Body<'tcx>,\n     ) {\n         let mut bx = self.build_block(bb);\n-        let data = &mir[bb];\n+        let data = &self.mir[bb];\n \n         debug!(\"codegen_block({:?}={:?})\", bb, data);\n \n         for statement in &data.statements {\n-            bx = self.codegen_statement(mir, bx, statement);\n+            bx = self.codegen_statement(bx, statement);\n         }\n \n-        self.codegen_terminator(bx, bb, data.terminator(), mir);\n+        self.codegen_terminator(bx, bb, data.terminator());\n     }\n \n     fn codegen_terminator(\n         &mut self,\n         mut bx: Bx,\n         bb: mir::BasicBlock,\n         terminator: &mir::Terminator<'tcx>,\n-        mir: &Body<'tcx>\n     ) {\n         debug!(\"codegen_terminator: {:?}\", terminator);\n \n@@ -827,7 +815,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             bb: &bb, terminator, funclet_bb\n         };\n \n-        self.set_debug_loc(&mut bx, terminator.source_info, mir);\n+        self.set_debug_loc(&mut bx, terminator.source_info);\n         match terminator.kind {\n             mir::TerminatorKind::Resume => {\n                 self.codegen_resume_terminator(helper, bx)\n@@ -839,31 +827,30 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                helper.maybe_sideeffect(mir, &mut bx, &[target]);\n-                helper.funclet_br(self, mir, &mut bx, target);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.funclet_br(self, &mut bx, target);\n             }\n \n             mir::TerminatorKind::SwitchInt {\n                 ref discr, switch_ty, ref values, ref targets\n             } => {\n-                self.codegen_switchint_terminator(helper, mir, bx, discr, switch_ty,\n-                                                  values, targets);\n+                self.codegen_switchint_terminator(helper, bx, discr, switch_ty, values, targets);\n             }\n \n             mir::TerminatorKind::Return => {\n-                self.codegen_return_terminator(mir, bx);\n+                self.codegen_return_terminator(bx);\n             }\n \n             mir::TerminatorKind::Unreachable => {\n                 bx.unreachable();\n             }\n \n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                self.codegen_drop_terminator(helper, mir, bx, location, target, unwind);\n+                self.codegen_drop_terminator(helper, bx, location, target, unwind);\n             }\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                self.codegen_assert_terminator(helper, mir, bx, terminator, cond,\n+                self.codegen_assert_terminator(helper, bx, terminator, cond,\n                                                expected, msg, target, cleanup);\n             }\n \n@@ -878,7 +865,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 cleanup,\n                 from_hir_call: _\n             } => {\n-                self.codegen_call_terminator(helper, mir, bx, terminator, func,\n+                self.codegen_call_terminator(helper, bx, terminator, func,\n                                              args, destination, cleanup);\n             }\n             mir::TerminatorKind::GeneratorDrop |\n@@ -983,13 +970,12 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n     fn codegen_arguments_untupled(\n         &mut self,\n-        mir: &Body<'tcx>,\n         bx: &mut Bx,\n         operand: &mir::Operand<'tcx>,\n         llargs: &mut Vec<Bx::Value>,\n         args: &[ArgAbi<'tcx, Ty<'tcx>>]\n     ) {\n-        let tuple = self.codegen_operand(mir, bx, operand);\n+        let tuple = self.codegen_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n         if let Ref(llval, None, align) = tuple.val {\n@@ -1049,25 +1035,23 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     fn landing_pad_to(\n         &mut self,\n         target_bb: mir::BasicBlock,\n-        mir: &Body<'tcx>\n     ) -> Bx::BasicBlock {\n         if let Some(block) = self.landing_pads[target_bb] {\n             return block;\n         }\n \n         let block = self.blocks[target_bb];\n-        let landing_pad = self.landing_pad_uncached(block, mir);\n+        let landing_pad = self.landing_pad_uncached(block);\n         self.landing_pads[target_bb] = Some(landing_pad);\n         landing_pad\n     }\n \n     fn landing_pad_uncached(\n         &mut self,\n         target_bb: Bx::BasicBlock,\n-        mir: &Body<'tcx>\n     ) -> Bx::BasicBlock {\n         if base::wants_msvc_seh(self.cx.sess()) {\n-            span_bug!(mir.span, \"landing pad was not inserted?\")\n+            span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n \n         let mut bx = self.new_block(\"cleanup\");\n@@ -1120,7 +1104,6 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         dest: &mir::Place<'tcx>,\n         fn_ret: &ArgAbi<'tcx, Ty<'tcx>>,\n         llargs: &mut Vec<Bx::Value>, is_intrinsic: bool,\n-        mir: &Body<'tcx>\n     ) -> ReturnDest<'tcx, Bx::Value> {\n         // If the return is ignored, we can just return a do-nothing `ReturnDest`.\n         if fn_ret.is_ignore() {\n@@ -1156,7 +1139,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 }\n             }\n         } else {\n-            self.codegen_place(mir, bx, &mir::PlaceRef {\n+            self.codegen_place(bx, &mir::PlaceRef {\n                 base: &dest.base,\n                 projection: &dest.projection,\n             })\n@@ -1169,7 +1152,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 //\n                 // If someone changes that, please update this code path\n                 // to create a temporary.\n-                span_bug!(mir.span, \"can't directly store to unaligned value\");\n+                span_bug!(self.mir.span, \"can't directly store to unaligned value\");\n             }\n             llargs.push(dest.llval);\n             ReturnDest::Nothing\n@@ -1180,21 +1163,20 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n     fn codegen_transmute(\n         &mut self,\n-        mir: &Body<'tcx>,\n         bx: &mut Bx,\n         src: &mir::Operand<'tcx>,\n         dst: &mir::Place<'tcx>\n     ) {\n         if let Some(index) = dst.as_local() {\n             match self.locals[index] {\n-                LocalRef::Place(place) => self.codegen_transmute_into(mir, bx, src, place),\n+                LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n-                    let dst_layout = bx.layout_of(self.monomorphized_place_ty(&dst.as_ref(), mir));\n+                    let dst_layout = bx.layout_of(self.monomorphized_place_ty(&dst.as_ref()));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n                     let place = PlaceRef::alloca(bx, dst_layout);\n                     place.storage_live(bx);\n-                    self.codegen_transmute_into(mir, bx, src, place);\n+                    self.codegen_transmute_into(bx, src, place);\n                     let op = bx.load_operand(place);\n                     place.storage_dead(bx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n@@ -1205,19 +1187,18 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 }\n             }\n         } else {\n-            let dst = self.codegen_place(mir, bx, &dst.as_ref());\n-            self.codegen_transmute_into(mir, bx, src, dst);\n+            let dst = self.codegen_place(bx, &dst.as_ref());\n+            self.codegen_transmute_into(bx, src, dst);\n         }\n     }\n \n     fn codegen_transmute_into(\n         &mut self,\n-        mir: &Body<'tcx>,\n         bx: &mut Bx,\n         src: &mir::Operand<'tcx>,\n         dst: PlaceRef<'tcx, Bx::Value>\n     ) {\n-        let src = self.codegen_operand(mir, bx, src);\n+        let src = self.codegen_operand(bx, src);\n         let llty = bx.backend_type(src.layout);\n         let cast_ptr = bx.pointercast(dst.llval, bx.type_ptr_to(llty));\n         let align = src.layout.align.abi.min(dst.align);"}, {"sha": "64129f4b5e48d043d929ec8c95ab4ff3fa8e40fa", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "patch": "@@ -178,7 +178,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&mut bx, &fx, &mir, &memory_locals);\n+        let args = arg_local_refs(&mut bx, &fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n@@ -232,7 +232,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in rpo {\n         visited.insert(bb.index());\n-        fx.codegen_block(bb, &mir);\n+        fx.codegen_block(bb);\n     }\n \n     // Remove blocks that haven't been visited, or have no\n@@ -321,16 +321,15 @@ fn create_funclets<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n fn arg_local_refs<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     fx: &FunctionCx<'a, 'b, 'tcx, Bx>,\n-    mir: &Body<'tcx>,\n     memory_locals: &BitSet<mir::Local>,\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mut idx = 0;\n     let mut llarg_idx = fx.fn_abi.ret.is_indirect() as usize;\n \n-    mir.args_iter().enumerate().map(|(arg_index, local)| {\n-        let arg_decl = &mir.local_decls[local];\n+    fx.mir.args_iter().enumerate().map(|(arg_index, local)| {\n+        let arg_decl = &fx.mir.local_decls[local];\n \n-        if Some(local) == mir.spread_arg {\n+        if Some(local) == fx.mir.spread_arg {\n             // This argument (e.g., the last argument in the \"rust-call\" ABI)\n             // is a tuple that was spread at the ABI level and now we have\n             // to reconstruct it into a tuple local variable, from multiple"}, {"sha": "947dc2df87d20bc97ed0a1814e5c0040c9b25f97", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "patch": "@@ -7,7 +7,7 @@ use crate::glue;\n use crate::traits::*;\n \n use rustc::mir::interpret::{ConstValue, ErrorHandled, Pointer, Scalar};\n-use rustc::mir::{self, Body};\n+use rustc::mir;\n use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, Size};\n \n@@ -428,13 +428,12 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n     pub fn codegen_consume(\n         &mut self,\n-        mir: &Body<'tcx>,\n         bx: &mut Bx,\n         place_ref: &mir::PlaceRef<'_, 'tcx>\n     ) -> OperandRef<'tcx, Bx::Value> {\n         debug!(\"codegen_consume(place_ref={:?})\", place_ref);\n \n-        let ty = self.monomorphized_place_ty(place_ref, mir);\n+        let ty = self.monomorphized_place_ty(place_ref);\n         let layout = bx.cx().layout_of(ty);\n \n         // ZSTs don't require any actual memory access.\n@@ -448,13 +447,12 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         // for most places, to consume them we just load them\n         // out from their home\n-        let place = self.codegen_place(mir, bx, place_ref);\n+        let place = self.codegen_place(bx, place_ref);\n         bx.load_operand(place)\n     }\n \n     pub fn codegen_operand(\n         &mut self,\n-        mir: &Body<'tcx>,\n         bx: &mut Bx,\n         operand: &mir::Operand<'tcx>\n     ) -> OperandRef<'tcx, Bx::Value> {\n@@ -463,7 +461,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         match *operand {\n             mir::Operand::Copy(ref place) |\n             mir::Operand::Move(ref place) => {\n-                self.codegen_consume(mir, bx, &place.as_ref())\n+                self.codegen_consume(bx, &place.as_ref())\n             }\n \n             mir::Operand::Constant(ref constant) => {"}, {"sha": "245998bd87d9bf8cb6e347bd11ea577b91206782", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "patch": "@@ -8,7 +8,7 @@ use crate::traits::*;\n \n use rustc::ty::{self, Instance, Ty};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n-use rustc::mir::{self, Body};\n+use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n \n #[derive(Copy, Clone, Debug)]\n@@ -438,7 +438,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     pub fn codegen_place(\n         &mut self,\n-        mir: &Body<'tcx>,\n         bx: &mut Bx,\n         place_ref: &mir::PlaceRef<'_, 'tcx>\n     ) -> PlaceRef<'tcx, Bx::Value> {\n@@ -519,7 +518,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 projection: [proj_base @ .., mir::ProjectionElem::Deref],\n             } => {\n                 // Load the pointer from its location.\n-                self.codegen_consume(mir, bx, &mir::PlaceRef {\n+                self.codegen_consume(bx, &mir::PlaceRef {\n                     base,\n                     projection: proj_base,\n                 }).deref(bx.cx())\n@@ -529,7 +528,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 projection: [proj_base @ .., elem],\n             } => {\n                 // FIXME turn this recursion into iteration\n-                let cg_base = self.codegen_place(mir, bx, &mir::PlaceRef {\n+                let cg_base = self.codegen_place(bx, &mir::PlaceRef {\n                     base,\n                     projection: proj_base,\n                 });\n@@ -543,7 +542,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                         let index = &mir::Operand::Copy(\n                             mir::Place::from(*index)\n                         );\n-                        let index = self.codegen_operand(mir, bx, index);\n+                        let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();\n                         cg_base.project_index(bx, llindex)\n                     }\n@@ -590,9 +589,9 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         result\n     }\n \n-    pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>, mir: &Body<'tcx>) -> Ty<'tcx> {\n+    pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, mir, tcx);\n+        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, self.mir, tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "5180f4376a67eac01d1a501efd56b7cee503e520", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "patch": "@@ -10,7 +10,7 @@ use crate::traits::*;\n use rustc::ty::{self, Ty, adjustment::{PointerCast}, Instance};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n-use rustc::mir::{self, Body};\n+use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n use syntax::symbol::sym;\n@@ -21,7 +21,6 @@ use std::{u128, i128};\n impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     pub fn codegen_rvalue(\n         &mut self,\n-        mir: &Body<'tcx>,\n         mut bx: Bx,\n         dest: PlaceRef<'tcx, Bx::Value>,\n         rvalue: &mir::Rvalue<'tcx>\n@@ -31,7 +30,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         match *rvalue {\n            mir::Rvalue::Use(ref operand) => {\n-               let cg_operand = self.codegen_operand(mir, &mut bx, operand);\n+               let cg_operand = self.codegen_operand(&mut bx, operand);\n                // FIXME: consider not copying constants through stack. (Fixable by codegen'ing\n                // constants into `OperandValue::Ref`; why don\u2019t we do that yet if we don\u2019t?)\n                cg_operand.val.store(&mut bx, dest);\n@@ -44,7 +43,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 if bx.cx().is_backend_scalar_pair(dest.layout) {\n                     // Into-coerce of a thin pointer to a fat pointer -- just\n                     // use the operand path.\n-                    let (mut bx, temp) = self.codegen_rvalue_operand(mir, bx, rvalue);\n+                    let (mut bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n                     temp.val.store(&mut bx, dest);\n                     return bx;\n                 }\n@@ -53,7 +52,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 // this to be eliminated by MIR building, but\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n-                let operand = self.codegen_operand(mir, &mut bx, source);\n+                let operand = self.codegen_operand(&mut bx, source);\n                 match operand.val {\n                     OperandValue::Pair(..) |\n                     OperandValue::Immediate(_) => {\n@@ -82,7 +81,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Repeat(ref elem, count) => {\n-                let cg_elem = self.codegen_operand(mir, &mut bx, elem);\n+                let cg_elem = self.codegen_operand(&mut bx, elem);\n \n                 // Do not generate the loop for zero-sized elements or empty arrays.\n                 if dest.layout.is_zst() {\n@@ -125,7 +124,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                     _ => (dest, None)\n                 };\n                 for (i, operand) in operands.iter().enumerate() {\n-                    let op = self.codegen_operand(mir, &mut bx, operand);\n+                    let op = self.codegen_operand(&mut bx, operand);\n                     // Do not generate stores and GEPis for zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n@@ -137,8 +136,8 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             _ => {\n-                assert!(self.rvalue_creates_operand(rvalue, DUMMY_SP, mir));\n-                let (mut bx, temp) = self.codegen_rvalue_operand(mir, bx, rvalue);\n+                assert!(self.rvalue_creates_operand(rvalue, DUMMY_SP));\n+                let (mut bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n                 temp.val.store(&mut bx, dest);\n                 bx\n             }\n@@ -147,7 +146,6 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n     pub fn codegen_rvalue_unsized(\n         &mut self,\n-        mir: &Body<'tcx>,\n         mut bx: Bx,\n         indirect_dest: PlaceRef<'tcx, Bx::Value>,\n         rvalue: &mir::Rvalue<'tcx>,\n@@ -157,7 +155,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                let cg_operand = self.codegen_operand(mir, &mut bx, operand);\n+                let cg_operand = self.codegen_operand(&mut bx, operand);\n                 cg_operand.val.store_unsized(&mut bx, indirect_dest);\n                 bx\n             }\n@@ -168,19 +166,18 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n     pub fn codegen_rvalue_operand(\n         &mut self,\n-        mir: &Body<'tcx>,\n         mut bx: Bx,\n         rvalue: &mir::Rvalue<'tcx>\n     ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n         assert!(\n-            self.rvalue_creates_operand(rvalue, DUMMY_SP, mir),\n+            self.rvalue_creates_operand(rvalue, DUMMY_SP),\n             \"cannot codegen {:?} to operand\",\n             rvalue,\n         );\n \n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n-                let operand = self.codegen_operand(mir, &mut bx, source);\n+                let operand = self.codegen_operand(&mut bx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n                 let cast = bx.cx().layout_of(self.monomorphize(&mir_cast_ty));\n \n@@ -373,7 +370,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Ref(_, bk, ref place) => {\n-                let cg_place = self.codegen_place(mir, &mut bx, &place.as_ref());\n+                let cg_place = self.codegen_place(&mut bx, &place.as_ref());\n \n                 let ty = cg_place.layout.ty;\n \n@@ -394,7 +391,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Len(ref place) => {\n-                let size = self.evaluate_array_len(mir, &mut bx, place);\n+                let size = self.evaluate_array_len(&mut bx, place);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(size),\n                     layout: bx.cx().layout_of(bx.tcx().types.usize),\n@@ -403,8 +400,8 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.codegen_operand(mir, &mut bx, lhs);\n-                let rhs = self.codegen_operand(mir, &mut bx, rhs);\n+                let lhs = self.codegen_operand(&mut bx, lhs);\n+                let rhs = self.codegen_operand(&mut bx, rhs);\n                 let llresult = match (lhs.val, rhs.val) {\n                     (OperandValue::Pair(lhs_addr, lhs_extra),\n                      OperandValue::Pair(rhs_addr, rhs_extra)) => {\n@@ -429,8 +426,8 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 (bx, operand)\n             }\n             mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.codegen_operand(mir, &mut bx, lhs);\n-                let rhs = self.codegen_operand(mir, &mut bx, rhs);\n+                let lhs = self.codegen_operand(&mut bx, lhs);\n+                let rhs = self.codegen_operand(&mut bx, rhs);\n                 let result = self.codegen_scalar_checked_binop(&mut bx, op,\n                                                              lhs.immediate(), rhs.immediate(),\n                                                              lhs.layout.ty);\n@@ -445,7 +442,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n-                let operand = self.codegen_operand(mir, &mut bx, operand);\n+                let operand = self.codegen_operand(&mut bx, operand);\n                 let lloperand = operand.immediate();\n                 let is_float = operand.layout.ty.is_floating_point();\n                 let llval = match op {\n@@ -463,8 +460,8 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n-                let discr_ty = rvalue.ty(mir, bx.tcx());\n-                let discr =  self.codegen_place(mir, &mut bx, &place.as_ref())\n+                let discr_ty = rvalue.ty(self.mir, bx.tcx());\n+                let discr =  self.codegen_place(&mut bx, &place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n                 (bx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n@@ -509,14 +506,14 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 (bx, operand)\n             }\n             mir::Rvalue::Use(ref operand) => {\n-                let operand = self.codegen_operand(mir, &mut bx, operand);\n+                let operand = self.codegen_operand(&mut bx, operand);\n                 (bx, operand)\n             }\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir, self.cx.tcx());\n                 let operand = OperandRef::new_zst(\n                     &mut bx,\n                     self.cx.layout_of(self.monomorphize(&ty)),\n@@ -528,7 +525,6 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n     fn evaluate_array_len(\n         &mut self,\n-        mir: &Body<'tcx>,\n         bx: &mut Bx,\n         place: &mir::Place<'tcx>,\n     ) -> Bx::Value {\n@@ -543,7 +539,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n         }\n         // use common size calculation for non zero-sized types\n-        let cg_value = self.codegen_place(mir, bx, &place.as_ref());\n+        let cg_value = self.codegen_place(bx, &place.as_ref());\n         cg_value.len(bx.cx())\n     }\n \n@@ -704,7 +700,6 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         &self,\n         rvalue: &mir::Rvalue<'tcx>,\n         span: Span,\n-        mir: &Body<'tcx>\n     ) -> bool {\n         match *rvalue {\n             mir::Rvalue::Ref(..) |\n@@ -719,7 +714,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir, self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }"}, {"sha": "5307108f8571c951ff5a750404e369eb8d2ddd5a", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66279d12f9cad1d47e4d6ed458dcbb7505b65b55/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=66279d12f9cad1d47e4d6ed458dcbb7505b65b55", "patch": "@@ -1,4 +1,4 @@\n-use rustc::mir::{self, Body};\n+use rustc::mir;\n \n use crate::traits::BuilderMethods;\n use super::FunctionCx;\n@@ -11,25 +11,24 @@ use rustc_error_codes::*;\n impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     pub fn codegen_statement(\n         &mut self,\n-        mir: &Body<'tcx>,\n         mut bx: Bx,\n         statement: &mir::Statement<'tcx>\n     ) -> Bx {\n         debug!(\"codegen_statement(statement={:?})\", statement);\n \n-        self.set_debug_loc(&mut bx, statement.source_info, mir);\n+        self.set_debug_loc(&mut bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n                 if let Some(index) = place.as_local() {\n                     match self.locals[index] {\n                         LocalRef::Place(cg_dest) => {\n-                            self.codegen_rvalue(mir, bx, cg_dest, rvalue)\n+                            self.codegen_rvalue(bx, cg_dest, rvalue)\n                         }\n                         LocalRef::UnsizedPlace(cg_indirect_dest) => {\n-                            self.codegen_rvalue_unsized(mir, bx, cg_indirect_dest, rvalue)\n+                            self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n-                            let (mut bx, operand) = self.codegen_rvalue_operand(mir, bx, rvalue);\n+                            let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n                             self.debug_introduce_local(&mut bx, index);\n                             bx\n@@ -43,16 +42,16 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n                             // If the type is zero-sized, it's already been set here,\n                             // but we still need to make sure we codegen the operand\n-                            self.codegen_rvalue_operand(mir, bx, rvalue).0\n+                            self.codegen_rvalue_operand(bx, rvalue).0\n                         }\n                     }\n                 } else {\n-                    let cg_dest = self.codegen_place(mir, &mut bx, &place.as_ref());\n-                    self.codegen_rvalue(mir, bx, cg_dest, rvalue)\n+                    let cg_dest = self.codegen_place(&mut bx, &place.as_ref());\n+                    self.codegen_rvalue(bx, cg_dest, rvalue)\n                 }\n             }\n             mir::StatementKind::SetDiscriminant{box ref place, variant_index} => {\n-                self.codegen_place(mir, &mut bx, &place.as_ref())\n+                self.codegen_place(&mut bx, &place.as_ref())\n                     .codegen_set_discr(&mut bx, variant_index);\n                 bx\n             }\n@@ -74,12 +73,12 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n             mir::StatementKind::InlineAsm(ref asm) => {\n                 let outputs = asm.outputs.iter().map(|output| {\n-                    self.codegen_place(mir, &mut bx, &output.as_ref())\n+                    self.codegen_place(&mut bx, &output.as_ref())\n                 }).collect();\n \n                 let input_vals = asm.inputs.iter()\n                     .fold(Vec::with_capacity(asm.inputs.len()), |mut acc, (span, input)| {\n-                        let op = self.codegen_operand(mir, &mut bx, input);\n+                        let op = self.codegen_operand(&mut bx, input);\n                         if let OperandValue::Immediate(_) = op.val {\n                             acc.push(op.immediate());\n                         } else {"}]}