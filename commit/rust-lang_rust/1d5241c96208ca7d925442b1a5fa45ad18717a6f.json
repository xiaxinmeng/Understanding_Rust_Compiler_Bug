{"sha": "1d5241c96208ca7d925442b1a5fa45ad18717a6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNTI0MWM5NjIwOGNhN2Q5MjU0NDJiMWE1ZmE0NWFkMTg3MTdhNmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-08T10:51:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-08T10:51:46Z"}, "message": "Auto merge of #69822 - Centril:rollup-360ca2j, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #69422 (Remove use of `unwrap()` from save-analysis)\n - #69548 (Turn trailing tokens in `assert!()` into hard errors)\n - #69561 (Clean up unstable book)\n - #69599 (check_binding_alt_eq_ty: improve precision wrt. `if let`)\n - #69641 (Update books)\n - #69776 (Fix & test leak of some BTreeMap nodes on panic during `into_iter`)\n - #69805 (resolve: Modernize some naming)\n - #69810 (test(bindings_after_at): add dynamic drop tests for bindings_after_at)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3405a2f3f23004a2e1df12fdc22b589b5731b816", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3405a2f3f23004a2e1df12fdc22b589b5731b816"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d5241c96208ca7d925442b1a5fa45ad18717a6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5241c96208ca7d925442b1a5fa45ad18717a6f", "html_url": "https://github.com/rust-lang/rust/commit/1d5241c96208ca7d925442b1a5fa45ad18717a6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d5241c96208ca7d925442b1a5fa45ad18717a6f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f943349eafaa75a60c05b0c84dcdb771d0eae8c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f943349eafaa75a60c05b0c84dcdb771d0eae8c9", "html_url": "https://github.com/rust-lang/rust/commit/f943349eafaa75a60c05b0c84dcdb771d0eae8c9"}, {"sha": "49c82d117084ad0362fee6fb9a524400c1140ce7", "url": "https://api.github.com/repos/rust-lang/rust/commits/49c82d117084ad0362fee6fb9a524400c1140ce7", "html_url": "https://github.com/rust-lang/rust/commit/49c82d117084ad0362fee6fb9a524400c1140ce7"}], "stats": {"total": 917, "additions": 462, "deletions": 455}, "files": [{"sha": "b81ffb7a6f4c5aaed92786e770e99db116aa4ebd", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1 +1 @@\n-Subproject commit b2e1092bf67bd4d7686c4553f186edbb7f5f92db\n+Subproject commit b81ffb7a6f4c5aaed92786e770e99db116aa4ebd"}, {"sha": "9f797e65e6bcc79419975b17aff8e21c9adc039f", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1 +1 @@\n-Subproject commit 3e6e1001dc6e095dbd5c88005e80969f60e384e1\n+Subproject commit 9f797e65e6bcc79419975b17aff8e21c9adc039f"}, {"sha": "559e09caa9661043744cf7af7bd88432d966f743", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1 +1 @@\n-Subproject commit 64239df6d173562b9deb4f012e4c3e6e960c4754\n+Subproject commit 559e09caa9661043744cf7af7bd88432d966f743"}, {"sha": "db57f899ea2a56a544c8d280cbf033438666273d", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1 +1 @@\n-Subproject commit 32facd5522ddbbf37baf01e4e4b6562bc55c071a\n+Subproject commit db57f899ea2a56a544c8d280cbf033438666273d"}, {"sha": "940916944bdaa6f5b8e78c7da1cde91a6ec9c35e", "filename": "src/doc/unstable-book/src/language-features/const-in-array-repeat-expressions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -2,7 +2,7 @@\n \n The tracking issue for this feature is: [#49147]\n \n-[#44109]: https://github.com/rust-lang/rust/issues/49147\n+[#49147]: https://github.com/rust-lang/rust/issues/49147\n \n ------------------------\n "}, {"sha": "5c6aa912c1b24ec3ff7c7e95887aadf6f2d4c860", "filename": "src/doc/unstable-book/src/language-features/impl-trait-in-bindings.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fimpl-trait-in-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fimpl-trait-in-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fimpl-trait-in-bindings.md?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1,8 +1,8 @@\n # `impl_trait_in_bindings`\n \n-The tracking issue for this feature is: [#34511]\n+The tracking issue for this feature is: [#63065]\n \n-[#34511]: https://github.com/rust-lang/rust/issues/34511\n+[#63065]: https://github.com/rust-lang/rust/issues/63065\n \n ------------------------\n "}, {"sha": "ee0fd5bf8698c7b3139aca796a0aca8adea53b13", "filename": "src/doc/unstable-book/src/language-features/link-cfg.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flink-cfg.md", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flink-cfg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flink-cfg.md?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -0,0 +1,5 @@\n+# `link_cfg`\n+\n+This feature is internal to the Rust compiler and is not intended for general use.\n+\n+------------------------"}, {"sha": "f1be053ddc42ec9bddb17e85b194406e64aa53e9", "filename": "src/doc/unstable-book/src/language-features/trait-alias.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrait-alias.md", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrait-alias.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrait-alias.md?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -2,7 +2,7 @@\n \n The tracking issue for this feature is: [#41517]\n \n-[#41417]: https://github.com/rust-lang/rust/issues/41517\n+[#41517]: https://github.com/rust-lang/rust/issues/41517\n \n ------------------------\n "}, {"sha": "9b39b8971644fbab4051c29a157e19f2336de079", "filename": "src/doc/unstable-book/src/language-features/transparent-unions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-unions.md", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-unions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-unions.md?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -2,7 +2,7 @@\n \n The tracking issue for this feature is [#60405]\n \n-[60405]: https://github.com/rust-lang/rust/issues/60405\n+[#60405]: https://github.com/rust-lang/rust/issues/60405\n \n ----\n "}, {"sha": "898fe58eeee536bff5ae749271d4148e712576ea", "filename": "src/doc/unstable-book/src/library-features/read-initializer.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f943349eafaa75a60c05b0c84dcdb771d0eae8c9/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fread-initializer.md", "raw_url": "https://github.com/rust-lang/rust/raw/f943349eafaa75a60c05b0c84dcdb771d0eae8c9/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fread-initializer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fread-initializer.md?ref=f943349eafaa75a60c05b0c84dcdb771d0eae8c9", "patch": "@@ -1,7 +0,0 @@\n-# `read_initializer`\n-\n-The tracking issue for this feature is: [#42788]\n-\n-[#0]: https://github.com/rust-lang/rust/issues/42788\n-\n-------------------------"}, {"sha": "c194d79a19d3e5aa3ef07d6bcce225df6612901f", "filename": "src/doc/unstable-book/src/library-features/tidy-test-never-used-anywhere-else.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftidy-test-never-used-anywhere-else.md", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftidy-test-never-used-anywhere-else.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftidy-test-never-used-anywhere-else.md?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -0,0 +1,5 @@\n+# `tidy_test_never_used_anywhere_else`\n+\n+This feature is internal to the Rust compiler and is not intended for general use.\n+\n+------------------------"}, {"sha": "9da324ba2d4f14c3d73fc910394c000658cbd12b", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1477,6 +1477,14 @@ impl<K, V> Drop for IntoIter<K, V> {\n                 // Continue the same loop we perform below. This only runs when unwinding, so we\n                 // don't have to care about panics this time (they'll abort).\n                 while let Some(_) = self.0.next() {}\n+\n+                // No need to avoid the shared root, because the tree was definitely not empty.\n+                unsafe {\n+                    let mut node = ptr::read(&self.0.front).into_node().forget_type();\n+                    while let Some(parent) = node.deallocate_and_ascend() {\n+                        node = parent.into_node().forget_type();\n+                    }\n+                }\n             }\n         }\n \n@@ -1491,7 +1499,8 @@ impl<K, V> Drop for IntoIter<K, V> {\n             if node.is_shared_root() {\n                 return;\n             }\n-\n+            // Most of the nodes have been deallocated while traversing\n+            // but one pile from a leaf up to the root is left standing.\n             while let Some(parent) = node.deallocate_and_ascend() {\n                 node = parent.into_node().forget_type();\n             }"}, {"sha": "d05eec19346de86e9ea93deaba8b492a837d6fae", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1021,7 +1021,7 @@ fn test_split_off_large_random_sorted() {\n }\n \n #[test]\n-fn test_into_iter_drop_leak() {\n+fn test_into_iter_drop_leak_1() {\n     static DROPS: AtomicU32 = AtomicU32::new(0);\n \n     struct D;\n@@ -1045,3 +1045,27 @@ fn test_into_iter_drop_leak() {\n \n     assert_eq!(DROPS.load(Ordering::SeqCst), 5);\n }\n+\n+#[test]\n+fn test_into_iter_drop_leak_2() {\n+    let size = 12; // to obtain tree with 2 levels (having edges to leaf nodes)\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+    static PANIC_POINT: AtomicU32 = AtomicU32::new(0);\n+\n+    struct D;\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == PANIC_POINT.load(Ordering::SeqCst) {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    for panic_point in vec![0, 1, size - 2, size - 1] {\n+        DROPS.store(0, Ordering::SeqCst);\n+        PANIC_POINT.store(panic_point, Ordering::SeqCst);\n+        let map: BTreeMap<_, _> = (0..size).map(|i| (i, D)).collect();\n+        catch_unwind(move || drop(map.into_iter())).ok();\n+        assert_eq!(DROPS.load(Ordering::SeqCst), size);\n+    }\n+}"}, {"sha": "09ff770e87b59276e8654a678c4a67e00b8d38c9", "filename": "src/librustc_builtin_macros/assert.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_builtin_macros%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_builtin_macros%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fassert.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -80,17 +80,15 @@ fn parse_assert<'a>(\n     //     my_function();\n     // );\n     //\n-    // Warn about semicolon and suggest removing it. Eventually, this should be turned into an\n-    // error.\n+    // Emit an error about semicolon and suggest removing it.\n     if parser.token == token::Semi {\n-        let mut err = cx.struct_span_warn(sp, \"macro requires an expression as an argument\");\n+        let mut err = cx.struct_span_err(sp, \"macro requires an expression as an argument\");\n         err.span_suggestion(\n             parser.token.span,\n             \"try removing semicolon\",\n             String::new(),\n             Applicability::MaybeIncorrect,\n         );\n-        err.note(\"this is going to be an error in the future\");\n         err.emit();\n \n         parser.bump();\n@@ -101,19 +99,17 @@ fn parse_assert<'a>(\n     //\n     // assert!(true \"error message\");\n     //\n-    // Parse this as an actual message, and suggest inserting a comma. Eventually, this should be\n-    // turned into an error.\n+    // Emit an error and suggest inserting a comma.\n     let custom_message =\n         if let token::Literal(token::Lit { kind: token::Str, .. }) = parser.token.kind {\n-            let mut err = cx.struct_span_warn(parser.token.span, \"unexpected string literal\");\n+            let mut err = cx.struct_span_err(parser.token.span, \"unexpected string literal\");\n             let comma_span = parser.prev_token.span.shrink_to_hi();\n             err.span_suggestion_short(\n                 comma_span,\n                 \"try adding a comma\",\n                 \", \".to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n-            err.note(\"this is going to be an error in the future\");\n             err.emit();\n \n             parse_custom_message(&mut parser)"}, {"sha": "87a912bd89efb92d6577aadd804228c2a79feef9", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -99,6 +99,9 @@ declare_features! (\n \n     // no-tracking-issue-start\n \n+    /// Allows using `rustc_*` attributes (RFC 572).\n+    (active, rustc_attrs, \"1.0.0\", None, None),\n+\n     /// Allows using compiler's own crates.\n     (active, rustc_private, \"1.0.0\", Some(27812), None),\n \n@@ -128,9 +131,6 @@ declare_features! (\n     /// Allows using `#[link_name=\"llvm.*\"]`.\n     (active, link_llvm_intrinsics, \"1.0.0\", Some(29602), None),\n \n-    /// Allows using `rustc_*` attributes (RFC 572).\n-    (active, rustc_attrs, \"1.0.0\", Some(29642), None),\n-\n     /// Allows using the `box $expr` syntax.\n     (active, box_syntax, \"1.0.0\", Some(49733), None),\n "}, {"sha": "ec5a8c4a0b896c92ed7322be9c9489130591c162", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -6,8 +6,7 @@\n //! Imports are also considered items and placed into modules here, but not resolved yet.\n \n use crate::def_collector::collect_definitions;\n-use crate::imports::ImportDirective;\n-use crate::imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n+use crate::imports::{Import, ImportKind};\n use crate::macros::{LegacyBinding, LegacyScope};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n use crate::{CrateLint, Determinacy, PathResult, ResolutionError, VisResolutionError};\n@@ -308,11 +307,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         })\n     }\n \n-    // Add an import directive to the current module.\n-    fn add_import_directive(\n+    // Add an import to the current module.\n+    fn add_import(\n         &mut self,\n         module_path: Vec<Segment>,\n-        subclass: ImportDirectiveSubclass<'a>,\n+        kind: ImportKind<'a>,\n         span: Span,\n         id: NodeId,\n         item: &ast::Item,\n@@ -321,11 +320,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         vis: ty::Visibility,\n     ) {\n         let current_module = self.parent_scope.module;\n-        let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n+        let import = self.r.arenas.alloc_import(Import {\n+            kind,\n             parent_scope: self.parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n-            subclass,\n             span,\n             id,\n             use_span: item.span,\n@@ -337,25 +336,25 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             used: Cell::new(false),\n         });\n \n-        debug!(\"add_import_directive({:?})\", directive);\n+        debug!(\"add_import({:?})\", import);\n \n-        self.r.indeterminate_imports.push(directive);\n-        match directive.subclass {\n+        self.r.indeterminate_imports.push(import);\n+        match import.kind {\n             // Don't add unresolved underscore imports to modules\n-            SingleImport { target: Ident { name: kw::Underscore, .. }, .. } => {}\n-            SingleImport { target, type_ns_only, .. } => {\n+            ImportKind::Single { target: Ident { name: kw::Underscore, .. }, .. } => {}\n+            ImportKind::Single { target, type_ns_only, .. } => {\n                 self.r.per_ns(|this, ns| {\n                     if !type_ns_only || ns == TypeNS {\n                         let key = this.new_key(target, ns);\n                         let mut resolution = this.resolution(current_module, key).borrow_mut();\n-                        resolution.add_single_import(directive);\n+                        resolution.add_single_import(import);\n                     }\n                 });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n-            GlobImport { is_prelude: true, .. } => {}\n-            GlobImport { .. } => current_module.globs.borrow_mut().push(directive),\n+            ImportKind::Glob { is_prelude: true, .. } => {}\n+            ImportKind::Glob { .. } => current_module.globs.borrow_mut().push(import),\n             _ => unreachable!(),\n         }\n     }\n@@ -480,7 +479,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     );\n                 }\n \n-                let subclass = SingleImport {\n+                let kind = ImportKind::Single {\n                     source: source.ident,\n                     target: ident,\n                     source_bindings: PerNS {\n@@ -496,9 +495,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     type_ns_only,\n                     nested,\n                 };\n-                self.add_import_directive(\n+                self.add_import(\n                     module_path,\n-                    subclass,\n+                    kind,\n                     use_tree.span,\n                     id,\n                     item,\n@@ -508,20 +507,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n-                let subclass = GlobImport {\n+                let kind = ImportKind::Glob {\n                     is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n-                self.add_import_directive(\n-                    prefix,\n-                    subclass,\n-                    use_tree.span,\n-                    id,\n-                    item,\n-                    root_span,\n-                    item.id,\n-                    vis,\n-                );\n+                self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 // Ensure there is at most one `self` in the list\n@@ -637,15 +627,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n-                let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n+                let import = self.r.arenas.alloc_import(Import {\n+                    kind: ImportKind::ExternCrate { source: orig_name, target: ident },\n                     root_id: item.id,\n                     id: item.id,\n                     parent_scope: self.parent_scope,\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n-                    subclass: ImportDirectiveSubclass::ExternCrate {\n-                        source: orig_name,\n-                        target: ident,\n-                    },\n                     has_attributes: !item.attrs.is_empty(),\n                     use_span_with_attributes: item.span_with_attributes(),\n                     use_span: item.span,\n@@ -655,8 +642,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     vis: Cell::new(vis),\n                     used: Cell::new(used),\n                 });\n-                self.r.potentially_unused_imports.push(directive);\n-                let imported_binding = self.r.import(binding, directive);\n+                self.r.potentially_unused_imports.push(import);\n+                let imported_binding = self.r.import(binding, import);\n                 if ptr::eq(parent, self.r.graph_root) {\n                     if let Some(entry) = self.r.extern_prelude.get(&ident.modern()) {\n                         if expansion != ExpnId::root()\n@@ -992,13 +979,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n         }\n \n-        let macro_use_directive = |this: &Self, span| {\n-            this.r.arenas.alloc_import_directive(ImportDirective {\n+        let macro_use_import = |this: &Self, span| {\n+            this.r.arenas.alloc_import(Import {\n+                kind: ImportKind::MacroUse,\n                 root_id: item.id,\n                 id: item.id,\n                 parent_scope: this.parent_scope,\n                 imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n-                subclass: ImportDirectiveSubclass::MacroUse,\n                 use_span_with_attributes: item.span_with_attributes(),\n                 has_attributes: !item.attrs.is_empty(),\n                 use_span: item.span,\n@@ -1012,11 +999,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n         let allow_shadowing = self.parent_scope.expansion == ExpnId::root();\n         if let Some(span) = import_all {\n-            let directive = macro_use_directive(self, span);\n-            self.r.potentially_unused_imports.push(directive);\n+            let import = macro_use_import(self, span);\n+            self.r.potentially_unused_imports.push(import);\n             module.for_each_child(self, |this, ident, ns, binding| {\n                 if ns == MacroNS {\n-                    let imported_binding = this.r.import(binding, directive);\n+                    let imported_binding = this.r.import(binding, import);\n                     this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n                 }\n             });\n@@ -1031,9 +1018,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     ident.span,\n                 );\n                 if let Ok(binding) = result {\n-                    let directive = macro_use_directive(self, ident.span);\n-                    self.r.potentially_unused_imports.push(directive);\n-                    let imported_binding = self.r.import(binding, directive);\n+                    let import = macro_use_import(self, ident.span);\n+                    self.r.potentially_unused_imports.push(import);\n+                    let imported_binding = self.r.import(binding, import);\n                     self.legacy_import_macro(\n                         ident.name,\n                         imported_binding,"}, {"sha": "722f843ab6e7ead20f33305bcde33f7613e342ba", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -3,7 +3,7 @@\n //\n // Although this is mostly a lint pass, it lives in here because it depends on\n // resolve data structures and because it finalises the privacy information for\n-// `use` directives.\n+// `use` items.\n //\n // Unused trait imports can't be checked until the method resolution. We save\n // candidates here, and do the actual check in librustc_typeck/check_unused.rs.\n@@ -23,7 +23,7 @@\n //  - `check_crate` finally emits the diagnostics based on the data generated\n //    in the last step\n \n-use crate::imports::ImportDirectiveSubclass;\n+use crate::imports::ImportKind;\n use crate::Resolver;\n \n use rustc::{lint, ty};\n@@ -58,7 +58,7 @@ struct UnusedImportCheckVisitor<'a, 'b> {\n }\n \n impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n-    // We have information about whether `use` (import) directives are actually\n+    // We have information about whether `use` (import) items are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, id: ast::NodeId) {\n         let mut used = false;\n@@ -223,33 +223,33 @@ fn calc_unused_spans(\n \n impl Resolver<'_> {\n     crate fn check_unused(&mut self, krate: &ast::Crate) {\n-        for directive in self.potentially_unused_imports.iter() {\n-            match directive.subclass {\n-                _ if directive.used.get()\n-                    || directive.vis.get() == ty::Visibility::Public\n-                    || directive.span.is_dummy() =>\n+        for import in self.potentially_unused_imports.iter() {\n+            match import.kind {\n+                _ if import.used.get()\n+                    || import.vis.get() == ty::Visibility::Public\n+                    || import.span.is_dummy() =>\n                 {\n-                    if let ImportDirectiveSubclass::MacroUse = directive.subclass {\n-                        if !directive.span.is_dummy() {\n+                    if let ImportKind::MacroUse = import.kind {\n+                        if !import.span.is_dummy() {\n                             self.lint_buffer.buffer_lint(\n                                 lint::builtin::MACRO_USE_EXTERN_CRATE,\n-                                directive.id,\n-                                directive.span,\n-                                \"deprecated `#[macro_use]` directive used to \\\n+                                import.id,\n+                                import.span,\n+                                \"deprecated `#[macro_use]` attribute used to \\\n                                 import macros should be replaced at use sites \\\n-                                with a `use` statement to import the macro \\\n+                                with a `use` item to import the macro \\\n                                 instead\",\n                             );\n                         }\n                     }\n                 }\n-                ImportDirectiveSubclass::ExternCrate { .. } => {\n-                    self.maybe_unused_extern_crates.push((directive.id, directive.span));\n+                ImportKind::ExternCrate { .. } => {\n+                    self.maybe_unused_extern_crates.push((import.id, import.span));\n                 }\n-                ImportDirectiveSubclass::MacroUse => {\n+                ImportKind::MacroUse => {\n                     let lint = lint::builtin::UNUSED_IMPORTS;\n                     let msg = \"unused `#[macro_use]` import\";\n-                    self.lint_buffer.buffer_lint(lint, directive.id, directive.span, msg);\n+                    self.lint_buffer.buffer_lint(lint, import.id, import.span, msg);\n                 }\n                 _ => {}\n             }"}, {"sha": "47a05ec90d42fc8cfa7427f8da3577cf29f0f226", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -18,7 +18,7 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span};\n \n-use crate::imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n+use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n@@ -1125,7 +1125,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n         &mut self,\n-        directive: &'b ImportDirective<'b>,\n+        import: &'b Import<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n     ) -> Option<(Option<Suggestion>, Vec<String>)> {\n@@ -1150,28 +1150,26 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();\n-            let import = match directive.subclass {\n-                ImportDirectiveSubclass::SingleImport { source, target, .. }\n-                    if source != target =>\n-                {\n+            let import_snippet = match import.kind {\n+                ImportKind::Single { source, target, .. } if source != target => {\n                     format!(\"{} as {}\", source, target)\n                 }\n                 _ => format!(\"{}\", ident),\n             };\n \n             let mut corrections: Vec<(Span, String)> = Vec::new();\n-            if !directive.is_nested() {\n+            if !import.is_nested() {\n                 // Assume this is the easy case of `use issue_59764::foo::makro;` and just remove\n                 // intermediate segments.\n-                corrections.push((directive.span, format!(\"{}::{}\", module_name, import)));\n+                corrections.push((import.span, format!(\"{}::{}\", module_name, import_snippet)));\n             } else {\n                 // Find the binding span (and any trailing commas and spaces).\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n                     self.r.session,\n-                    directive.span,\n-                    directive.use_span,\n+                    import.span,\n+                    import.use_span,\n                 );\n                 debug!(\n                     \"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n@@ -1208,7 +1206,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n                     self.r.session,\n                     module_name,\n-                    directive.use_span,\n+                    import.use_span,\n                 );\n                 debug!(\n                     \"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n@@ -1224,11 +1222,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         start_point,\n                         if has_nested {\n                             // In this case, `start_snippet` must equal '{'.\n-                            format!(\"{}{}, \", start_snippet, import)\n+                            format!(\"{}{}, \", start_snippet, import_snippet)\n                         } else {\n                             // In this case, add a `{`, then the moved import, then whatever\n                             // was there before.\n-                            format!(\"{{{}, {}\", import, start_snippet)\n+                            format!(\"{{{}, {}\", import_snippet, start_snippet)\n                         },\n                     ));\n                 }"}, {"sha": "485b86636a0bada0519a90e7a3e23bfb15bfd8d9", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 169, "deletions": 191, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1,7 +1,5 @@\n //! A bunch of methods and structures more or less related to resolving imports.\n \n-use ImportDirectiveSubclass::*;\n-\n use crate::diagnostics::Suggestion;\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, MacroNS, TypeNS};\n@@ -36,10 +34,10 @@ use std::{mem, ptr};\n \n type Res = def::Res<NodeId>;\n \n-/// Contains data for specific types of import directives.\n+/// Contains data for specific kinds of imports.\n #[derive(Clone, Debug)]\n-pub enum ImportDirectiveSubclass<'a> {\n-    SingleImport {\n+pub enum ImportKind<'a> {\n+    Single {\n         /// `source` in `use prefix::source as target`.\n         source: Ident,\n         /// `target` in `use prefix::source as target`.\n@@ -53,7 +51,7 @@ pub enum ImportDirectiveSubclass<'a> {\n         /// Did this import result from a nested import? ie. `use foo::{bar, baz};`\n         nested: bool,\n     },\n-    GlobImport {\n+    Glob {\n         is_prelude: bool,\n         max_vis: Cell<ty::Visibility>, // The visibility of the greatest re-export.\n                                        // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n@@ -65,19 +63,21 @@ pub enum ImportDirectiveSubclass<'a> {\n     MacroUse,\n }\n \n-/// One import directive.\n+/// One import.\n #[derive(Debug, Clone)]\n-crate struct ImportDirective<'a> {\n-    /// The ID of the `extern crate`, `UseTree` etc that imported this `ImportDirective`.\n+crate struct Import<'a> {\n+    pub kind: ImportKind<'a>,\n+\n+    /// The ID of the `extern crate`, `UseTree` etc that imported this `Import`.\n     ///\n-    /// In the case where the `ImportDirective` was expanded from a \"nested\" use tree,\n+    /// In the case where the `Import` was expanded from a \"nested\" use tree,\n     /// this id is the ID of the leaf tree. For example:\n     ///\n     /// ```ignore (pacify the mercilous tidy)\n     /// use foo::bar::{a, b}\n     /// ```\n     ///\n-    /// If this is the import directive for `foo::bar::a`, we would have the ID of the `UseTree`\n+    /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n     /// for `a` in this field.\n     pub id: NodeId,\n \n@@ -107,22 +107,21 @@ crate struct ImportDirective<'a> {\n     pub module_path: Vec<Segment>,\n     /// The resolution of `module_path`.\n     pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n-    pub subclass: ImportDirectiveSubclass<'a>,\n     pub vis: Cell<ty::Visibility>,\n     pub used: Cell<bool>,\n }\n \n-impl<'a> ImportDirective<'a> {\n+impl<'a> Import<'a> {\n     pub fn is_glob(&self) -> bool {\n-        match self.subclass {\n-            ImportDirectiveSubclass::GlobImport { .. } => true,\n+        match self.kind {\n+            ImportKind::Glob { .. } => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_nested(&self) -> bool {\n-        match self.subclass {\n-            ImportDirectiveSubclass::SingleImport { nested, .. } => nested,\n+        match self.kind {\n+            ImportKind::Single { nested, .. } => nested,\n             _ => false,\n         }\n     }\n@@ -136,8 +135,8 @@ impl<'a> ImportDirective<'a> {\n /// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n-    /// Import directives are arena-allocated, so it's ok to use pointers as keys.\n-    single_imports: FxHashSet<PtrKey<'a, ImportDirective<'a>>>,\n+    /// Imports are arena-allocated, so it's ok to use pointers as keys.\n+    single_imports: FxHashSet<PtrKey<'a, Import<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     shadowed_glob: Option<&'a NameBinding<'a>>,\n@@ -155,8 +154,8 @@ impl<'a> NameResolution<'a> {\n         })\n     }\n \n-    crate fn add_single_import(&mut self, directive: &'a ImportDirective<'a>) {\n-        self.single_imports.insert(PtrKey(directive));\n+    crate fn add_single_import(&mut self, import: &'a Import<'a>) {\n+        self.single_imports.insert(PtrKey(import));\n     }\n }\n \n@@ -348,8 +347,8 @@ impl<'a> Resolver<'a> {\n                 single_import.imported_module.get(),\n                 return Err((Undetermined, Weak::No))\n             );\n-            let ident = match single_import.subclass {\n-                SingleImport { source, .. } => source,\n+            let ident = match single_import.kind {\n+                ImportKind::Single { source, .. } => source,\n                 _ => unreachable!(),\n             };\n             match self.resolve_ident_in_module(\n@@ -451,34 +450,34 @@ impl<'a> Resolver<'a> {\n         Err((Determined, Weak::No))\n     }\n \n-    // Given a binding and an import directive that resolves to it,\n-    // return the corresponding binding defined by the import directive.\n+    // Given a binding and an import that resolves to it,\n+    // return the corresponding binding defined by the import.\n     crate fn import(\n         &self,\n         binding: &'a NameBinding<'a>,\n-        directive: &'a ImportDirective<'a>,\n+        import: &'a Import<'a>,\n     ) -> &'a NameBinding<'a> {\n-        let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n+        let vis = if binding.pseudo_vis().is_at_least(import.vis.get(), self) ||\n                      // cf. `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n-                     !directive.is_glob() && binding.is_extern_crate()\n+                     !import.is_glob() && binding.is_extern_crate()\n         {\n-            directive.vis.get()\n+            import.vis.get()\n         } else {\n             binding.pseudo_vis()\n         };\n \n-        if let GlobImport { ref max_vis, .. } = directive.subclass {\n-            if vis == directive.vis.get() || vis.is_at_least(max_vis.get(), self) {\n+        if let ImportKind::Glob { ref max_vis, .. } = import.kind {\n+            if vis == import.vis.get() || vis.is_at_least(max_vis.get(), self) {\n                 max_vis.set(vis)\n             }\n         }\n \n         self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Import { binding, directive, used: Cell::new(false) },\n+            kind: NameBindingKind::Import { binding, import, used: Cell::new(false) },\n             ambiguity: None,\n-            span: directive.span,\n+            span: import.span,\n             vis,\n-            expansion: directive.parent_scope.expansion,\n+            expansion: import.parent_scope.expansion,\n         })\n     }\n \n@@ -577,17 +576,17 @@ impl<'a> Resolver<'a> {\n         };\n \n         // Define `binding` in `module`s glob importers.\n-        for directive in module.glob_importers.borrow_mut().iter() {\n+        for import in module.glob_importers.borrow_mut().iter() {\n             let mut ident = key.ident;\n-            let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n+            let scope = match ident.span.reverse_glob_adjust(module.expansion, import.span) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n-                Some(None) => directive.parent_scope.module,\n+                Some(None) => import.parent_scope.module,\n                 None => continue,\n             };\n             if self.is_accessible_from(binding.vis, scope) {\n-                let imported_binding = self.import(binding, directive);\n+                let imported_binding = self.import(binding, import);\n                 let key = BindingKey { ident, ..key };\n-                let _ = self.try_define(directive.parent_scope.module, key, imported_binding);\n+                let _ = self.try_define(import.parent_scope.module, key, imported_binding);\n             }\n         }\n \n@@ -596,13 +595,13 @@ impl<'a> Resolver<'a> {\n \n     // Define a \"dummy\" resolution containing a Res::Err as a placeholder for a\n     // failed resolution\n-    fn import_dummy_binding(&mut self, directive: &'a ImportDirective<'a>) {\n-        if let SingleImport { target, .. } = directive.subclass {\n+    fn import_dummy_binding(&mut self, import: &'a Import<'a>) {\n+        if let ImportKind::Single { target, .. } = import.kind {\n             let dummy_binding = self.dummy_binding;\n-            let dummy_binding = self.import(dummy_binding, directive);\n+            let dummy_binding = self.import(dummy_binding, import);\n             self.per_ns(|this, ns| {\n                 let key = this.new_key(target, ns);\n-                let _ = this.try_define(directive.parent_scope.module, key, dummy_binding);\n+                let _ = this.try_define(import.parent_scope.module, key, dummy_binding);\n                 // Consider erroneous imports used to avoid duplicate diagnostics.\n                 this.record_use(target, ns, dummy_binding, false);\n             });\n@@ -671,7 +670,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             .chain(indeterminate_imports.into_iter().map(|i| (true, i)))\n         {\n             if let Some(err) = self.finalize_import(import) {\n-                if let SingleImport { source, ref source_bindings, .. } = import.subclass {\n+                if let ImportKind::Single { source, ref source_bindings, .. } = import.kind {\n                     if source.name == kw::SelfLower {\n                         // Silence `unresolved import` error if E0429 is already emitted\n                         if let Err(Determined) = source_bindings.value_ns.get() {\n@@ -695,7 +694,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if seen_spans.insert(err.span) {\n                     let path = import_path_to_string(\n                         &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n-                        &import.subclass,\n+                        &import.kind,\n                         err.span,\n                     );\n                     errors.push((path, err));\n@@ -706,7 +705,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 self.r.used_imports.insert((import.id, TypeNS));\n                 let path = import_path_to_string(\n                     &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n-                    &import.subclass,\n+                    &import.kind,\n                     import.span,\n                 );\n                 let err = UnresolvedImportError {\n@@ -767,28 +766,28 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n+    fn resolve_import(&mut self, import: &'b Import<'b>) -> bool {\n         debug!(\n             \"(resolving import for module) resolving import `{}::...` in `{}`\",\n-            Segment::names_to_string(&directive.module_path),\n-            module_to_string(directive.parent_scope.module).unwrap_or_else(|| \"???\".to_string()),\n+            Segment::names_to_string(&import.module_path),\n+            module_to_string(import.parent_scope.module).unwrap_or_else(|| \"???\".to_string()),\n         );\n \n-        let module = if let Some(module) = directive.imported_module.get() {\n+        let module = if let Some(module) = import.imported_module.get() {\n             module\n         } else {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n-            let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+            let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n             let path_res = self.r.resolve_path(\n-                &directive.module_path,\n+                &import.module_path,\n                 None,\n-                &directive.parent_scope,\n+                &import.parent_scope,\n                 false,\n-                directive.span,\n-                directive.crate_lint(),\n+                import.span,\n+                import.crate_lint(),\n             );\n-            directive.vis.set(orig_vis);\n+            import.vis.set(orig_vis);\n \n             match path_res {\n                 PathResult::Module(module) => module,\n@@ -797,68 +796,67 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n         };\n \n-        directive.imported_module.set(Some(module));\n-        let (source, target, source_bindings, target_bindings, type_ns_only) =\n-            match directive.subclass {\n-                SingleImport {\n-                    source,\n-                    target,\n-                    ref source_bindings,\n-                    ref target_bindings,\n-                    type_ns_only,\n-                    ..\n-                } => (source, target, source_bindings, target_bindings, type_ns_only),\n-                GlobImport { .. } => {\n-                    self.resolve_glob_import(directive);\n-                    return true;\n-                }\n-                _ => unreachable!(),\n-            };\n+        import.imported_module.set(Some(module));\n+        let (source, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n+            ImportKind::Single {\n+                source,\n+                target,\n+                ref source_bindings,\n+                ref target_bindings,\n+                type_ns_only,\n+                ..\n+            } => (source, target, source_bindings, target_bindings, type_ns_only),\n+            ImportKind::Glob { .. } => {\n+                self.resolve_glob_import(import);\n+                return true;\n+            }\n+            _ => unreachable!(),\n+        };\n \n         let mut indeterminate = false;\n         self.r.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 if let Err(Undetermined) = source_bindings[ns].get() {\n                     // For better failure detection, pretend that the import will\n                     // not define any names while resolving its module path.\n-                    let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+                    let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n                     let binding = this.resolve_ident_in_module(\n                         module,\n                         source,\n                         ns,\n-                        &directive.parent_scope,\n+                        &import.parent_scope,\n                         false,\n-                        directive.span,\n+                        import.span,\n                     );\n-                    directive.vis.set(orig_vis);\n+                    import.vis.set(orig_vis);\n \n                     source_bindings[ns].set(binding);\n                 } else {\n                     return;\n                 };\n \n-                let parent = directive.parent_scope.module;\n+                let parent = import.parent_scope.module;\n                 match source_bindings[ns].get() {\n                     Err(Undetermined) => indeterminate = true,\n                     // Don't update the resolution, because it was never added.\n                     Err(Determined) if target.name == kw::Underscore => {}\n                     Err(Determined) => {\n                         let key = this.new_key(target, ns);\n                         this.update_resolution(parent, key, |_, resolution| {\n-                            resolution.single_imports.remove(&PtrKey(directive));\n+                            resolution.single_imports.remove(&PtrKey(import));\n                         });\n                     }\n                     Ok(binding) if !binding.is_importable() => {\n                         let msg = format!(\"`{}` is not directly importable\", target);\n-                        struct_span_err!(this.session, directive.span, E0253, \"{}\", &msg)\n-                            .span_label(directive.span, \"cannot be imported directly\")\n+                        struct_span_err!(this.session, import.span, E0253, \"{}\", &msg)\n+                            .span_label(import.span, \"cannot be imported directly\")\n                             .emit();\n                         // Do not import this illegal binding. Import a dummy binding and pretend\n                         // everything is fine\n-                        this.import_dummy_binding(directive);\n+                        this.import_dummy_binding(import);\n                     }\n                     Ok(binding) => {\n-                        let imported_binding = this.import(binding, directive);\n+                        let imported_binding = this.import(binding, import);\n                         target_bindings[ns].set(Some(imported_binding));\n                         this.define(parent, target, ns, imported_binding);\n                     }\n@@ -873,58 +871,55 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ///\n     /// Optionally returns an unresolved import error. This error is buffered and used to\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n-    fn finalize_import(\n-        &mut self,\n-        directive: &'b ImportDirective<'b>,\n-    ) -> Option<UnresolvedImportError> {\n-        let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+    fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n+        let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n         let path_res = self.r.resolve_path(\n-            &directive.module_path,\n+            &import.module_path,\n             None,\n-            &directive.parent_scope,\n+            &import.parent_scope,\n             true,\n-            directive.span,\n-            directive.crate_lint(),\n+            import.span,\n+            import.crate_lint(),\n         );\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n-        directive.vis.set(orig_vis);\n+        import.vis.set(orig_vis);\n         if let PathResult::Failed { .. } | PathResult::NonModule(..) = path_res {\n             // Consider erroneous imports used to avoid duplicate diagnostics.\n-            self.r.used_imports.insert((directive.id, TypeNS));\n+            self.r.used_imports.insert((import.id, TypeNS));\n         }\n         let module = match path_res {\n             PathResult::Module(module) => {\n                 // Consistency checks, analogous to `finalize_macro_resolutions`.\n-                if let Some(initial_module) = directive.imported_module.get() {\n+                if let Some(initial_module) = import.imported_module.get() {\n                     if !ModuleOrUniformRoot::same_def(module, initial_module) && no_ambiguity {\n-                        span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                        span_bug!(import.span, \"inconsistent resolution for an import\");\n                     }\n                 } else {\n                     if self.r.privacy_errors.is_empty() {\n                         let msg = \"cannot determine resolution for the import\";\n                         let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                        self.r.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n+                        self.r.session.struct_span_err(import.span, msg).note(msg_note).emit();\n                     }\n                 }\n \n                 module\n             }\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 if no_ambiguity {\n-                    assert!(directive.imported_module.get().is_none());\n+                    assert!(import.imported_module.get().is_none());\n                     self.r\n                         .report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n                 }\n                 return None;\n             }\n             PathResult::Failed { is_error_from_last_segment: true, span, label, suggestion } => {\n                 if no_ambiguity {\n-                    assert!(directive.imported_module.get().is_none());\n+                    assert!(import.imported_module.get().is_none());\n                     let err = match self.make_path_suggestion(\n                         span,\n-                        directive.module_path.clone(),\n-                        &directive.parent_scope,\n+                        import.module_path.clone(),\n+                        &import.parent_scope,\n                     ) {\n                         Some((suggestion, note)) => UnresolvedImportError {\n                             span,\n@@ -949,44 +944,42 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n             PathResult::NonModule(path_res) if path_res.base_res() == Res::Err => {\n                 if no_ambiguity {\n-                    assert!(directive.imported_module.get().is_none());\n+                    assert!(import.imported_module.get().is_none());\n                 }\n                 // The error was already reported earlier.\n                 return None;\n             }\n             PathResult::Indeterminate | PathResult::NonModule(..) => unreachable!(),\n         };\n \n-        let (ident, target, source_bindings, target_bindings, type_ns_only) = match directive\n-            .subclass\n-        {\n-            SingleImport {\n+        let (ident, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n+            ImportKind::Single {\n                 source,\n                 target,\n                 ref source_bindings,\n                 ref target_bindings,\n                 type_ns_only,\n                 ..\n             } => (source, target, source_bindings, target_bindings, type_ns_only),\n-            GlobImport { is_prelude, ref max_vis } => {\n-                if directive.module_path.len() <= 1 {\n+            ImportKind::Glob { is_prelude, ref max_vis } => {\n+                if import.module_path.len() <= 1 {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n-                    let mut full_path = directive.module_path.clone();\n+                    let mut full_path = import.module_path.clone();\n                     full_path.push(Segment::from_ident(Ident::invalid()));\n                     self.r.lint_if_path_starts_with_module(\n-                        directive.crate_lint(),\n+                        import.crate_lint(),\n                         &full_path,\n-                        directive.span,\n+                        import.span,\n                         None,\n                     );\n                 }\n \n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    if module.def_id() == directive.parent_scope.module.def_id() {\n+                    if module.def_id() == import.parent_scope.module.def_id() {\n                         // Importing a module into itself is not allowed.\n                         return Some(UnresolvedImportError {\n-                            span: directive.span,\n+                            span: import.span,\n                             label: Some(String::from(\"cannot glob-import a module into itself\")),\n                             note: Vec::new(),\n                             suggestion: None,\n@@ -995,15 +988,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 }\n                 if !is_prelude &&\n                    max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n-                   !max_vis.get().is_at_least(directive.vis.get(), &*self)\n+                   !max_vis.get().is_at_least(import.vis.get(), &*self)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.lint_buffer.buffer_lint(\n-                        UNUSED_IMPORTS,\n-                        directive.id,\n-                        directive.span,\n-                        msg,\n-                    );\n+                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n                 }\n                 return None;\n             }\n@@ -1013,21 +1001,21 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut all_ns_err = true;\n         self.r.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n-                let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+                let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n                 let orig_blacklisted_binding =\n                     mem::replace(&mut this.blacklisted_binding, target_bindings[ns].get());\n                 let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n                 let binding = this.resolve_ident_in_module(\n                     module,\n                     ident,\n                     ns,\n-                    &directive.parent_scope,\n+                    &import.parent_scope,\n                     true,\n-                    directive.span,\n+                    import.span,\n                 );\n                 this.last_import_segment = orig_last_import_segment;\n                 this.blacklisted_binding = orig_blacklisted_binding;\n-                directive.vis.set(orig_vis);\n+                import.vis.set(orig_vis);\n \n                 match binding {\n                     Ok(binding) => {\n@@ -1044,7 +1032,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                         ident,\n                                         ns,\n                                         target_binding,\n-                                        directive.module_path.is_empty(),\n+                                        import.module_path.is_empty(),\n                                     );\n                                 }\n                             }\n@@ -1053,7 +1041,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         let res = binding.res();\n                         if let Ok(initial_res) = initial_res {\n                             if res != initial_res && this.ambiguity_errors.is_empty() {\n-                                span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                                span_bug!(import.span, \"inconsistent resolution for an import\");\n                             }\n                         } else {\n                             if res != Res::Err\n@@ -1064,7 +1052,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 let msg_note =\n                                     \"import resolution is stuck, try simplifying other imports\";\n                                 this.session\n-                                    .struct_span_err(directive.span, msg)\n+                                    .struct_span_err(import.span, msg)\n                                     .note(msg_note)\n                                     .emit();\n                             }\n@@ -1090,9 +1078,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         module,\n                         ident,\n                         ns,\n-                        &directive.parent_scope,\n+                        &import.parent_scope,\n                         true,\n-                        directive.span,\n+                        import.span,\n                     );\n                     if binding.is_ok() {\n                         all_ns_failed = false;\n@@ -1143,7 +1131,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     });\n \n                 let (suggestion, note) =\n-                    match self.check_for_module_export_macro(directive, module, ident) {\n+                    match self.check_for_module_export_macro(import, module, ident) {\n                         Some((suggestion, note)) => (suggestion.or(lev_suggestion), note),\n                         _ => (lev_suggestion, Vec::new()),\n                     };\n@@ -1169,14 +1157,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 };\n \n                 Some(UnresolvedImportError {\n-                    span: directive.span,\n+                    span: import.span,\n                     label: Some(label),\n                     note,\n                     suggestion,\n                 })\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n-                self.r.import_dummy_binding(directive);\n+                self.r.import_dummy_binding(import);\n                 None\n             };\n         }\n@@ -1185,7 +1173,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut any_successful_reexport = false;\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                let vis = directive.vis.get();\n+                let vis = import.vis.get();\n                 if !binding.pseudo_vis().is_at_least(vis, &*this) {\n                     reexport_error = Some((ns, binding));\n                 } else {\n@@ -1206,42 +1194,42 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 );\n                 self.r.lint_buffer.buffer_lint(\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-                    directive.id,\n-                    directive.span,\n+                    import.id,\n+                    import.span,\n                     &msg,\n                 );\n             } else if ns == TypeNS {\n                 struct_span_err!(\n                     self.r.session,\n-                    directive.span,\n+                    import.span,\n                     E0365,\n                     \"`{}` is private, and cannot be re-exported\",\n                     ident\n                 )\n-                .span_label(directive.span, format!(\"re-export of private `{}`\", ident))\n+                .span_label(import.span, format!(\"re-export of private `{}`\", ident))\n                 .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                 .emit();\n             } else {\n                 let msg = format!(\"`{}` is private, and cannot be re-exported\", ident);\n                 let note_msg =\n                     format!(\"consider marking `{}` as `pub` in the imported module\", ident,);\n-                struct_span_err!(self.r.session, directive.span, E0364, \"{}\", &msg)\n-                    .span_note(directive.span, &note_msg)\n+                struct_span_err!(self.r.session, import.span, E0364, \"{}\", &msg)\n+                    .span_note(import.span, &note_msg)\n                     .emit();\n             }\n         }\n \n-        if directive.module_path.len() <= 1 {\n+        if import.module_path.len() <= 1 {\n             // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n             // 2 segments, so the `resolve_path` above won't trigger it.\n-            let mut full_path = directive.module_path.clone();\n+            let mut full_path = import.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n             self.r.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n                     this.lint_if_path_starts_with_module(\n-                        directive.crate_lint(),\n+                        import.crate_lint(),\n                         &full_path,\n-                        directive.span,\n+                        import.span,\n                         Some(binding),\n                     );\n                 }\n@@ -1253,17 +1241,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // purposes it's good enough to just favor one over the other.\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                this.import_res_map.entry(directive.id).or_default()[ns] = Some(binding.res());\n+                this.import_res_map.entry(import.id).or_default()[ns] = Some(binding.res());\n             }\n         });\n \n-        self.check_for_redundant_imports(\n-            ident,\n-            directive,\n-            source_bindings,\n-            target_bindings,\n-            target,\n-        );\n+        self.check_for_redundant_imports(ident, import, source_bindings, target_bindings, target);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         None\n@@ -1272,19 +1254,19 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     fn check_for_redundant_imports(\n         &mut self,\n         ident: Ident,\n-        directive: &'b ImportDirective<'b>,\n+        import: &'b Import<'b>,\n         source_bindings: &PerNS<Cell<Result<&'b NameBinding<'b>, Determinacy>>>,\n         target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n         target: Ident,\n     ) {\n         // Skip if the import was produced by a macro.\n-        if directive.parent_scope.expansion != ExpnId::root() {\n+        if import.parent_scope.expansion != ExpnId::root() {\n             return;\n         }\n \n         // Skip if we are inside a named module (in contrast to an anonymous\n         // module defined by a block).\n-        if let ModuleKind::Def(..) = directive.parent_scope.module.kind {\n+        if let ModuleKind::Def(..) = import.parent_scope.module.kind {\n             return;\n         }\n \n@@ -1304,10 +1286,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 match this.early_resolve_ident_in_lexical_scope(\n                     target,\n                     ScopeSet::All(ns, false),\n-                    &directive.parent_scope,\n+                    &import.parent_scope,\n                     false,\n                     false,\n-                    directive.span,\n+                    import.span,\n                 ) {\n                     Ok(other_binding) => {\n                         is_redundant[ns] = Some(\n@@ -1329,35 +1311,35 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             redundant_spans.dedup();\n             self.r.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n-                directive.id,\n-                directive.span,\n+                import.id,\n+                import.span,\n                 &format!(\"the item `{}` is imported redundantly\", ident),\n                 BuiltinLintDiagnostics::RedundantImport(redundant_spans, ident),\n             );\n         }\n     }\n \n-    fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n-        let module = match directive.imported_module.get().unwrap() {\n+    fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n+        let module = match import.imported_module.get().unwrap() {\n             ModuleOrUniformRoot::Module(module) => module,\n             _ => {\n-                self.r.session.span_err(directive.span, \"cannot glob-import all possible crates\");\n+                self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n                 return;\n             }\n         };\n \n         if module.is_trait() {\n-            self.r.session.span_err(directive.span, \"items in traits are not importable.\");\n+            self.r.session.span_err(import.span, \"items in traits are not importable.\");\n             return;\n-        } else if module.def_id() == directive.parent_scope.module.def_id() {\n+        } else if module.def_id() == import.parent_scope.module.def_id() {\n             return;\n-        } else if let GlobImport { is_prelude: true, .. } = directive.subclass {\n+        } else if let ImportKind::Glob { is_prelude: true, .. } = import.kind {\n             self.r.prelude = Some(module);\n             return;\n         }\n \n         // Add to module's glob_importers\n-        module.glob_importers.borrow_mut().push(directive);\n+        module.glob_importers.borrow_mut().push(import);\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n@@ -1371,19 +1353,19 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             })\n             .collect::<Vec<_>>();\n         for (mut key, binding) in bindings {\n-            let scope = match key.ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n+            let scope = match key.ident.span.reverse_glob_adjust(module.expansion, import.span) {\n                 Some(Some(def)) => self.r.macro_def_scope(def),\n-                Some(None) => directive.parent_scope.module,\n+                Some(None) => import.parent_scope.module,\n                 None => continue,\n             };\n             if self.r.is_accessible_from(binding.pseudo_vis(), scope) {\n-                let imported_binding = self.r.import(binding, directive);\n-                let _ = self.r.try_define(directive.parent_scope.module, key, imported_binding);\n+                let imported_binding = self.r.import(binding, import);\n+                let _ = self.r.try_define(import.parent_scope.module, key, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        self.r.record_partial_res(directive.id, PartialRes::new(module.res().unwrap()));\n+        self.r.record_partial_res(import.id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n@@ -1407,16 +1389,16 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 }\n             }\n \n-            if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n+            if let NameBindingKind::Import { binding: orig_binding, import, .. } = binding.kind {\n                 if ns == TypeNS\n                     && orig_binding.is_variant()\n                     && !orig_binding.vis.is_at_least(binding.vis, &*this)\n                 {\n-                    let msg = match directive.subclass {\n-                        ImportDirectiveSubclass::SingleImport { .. } => {\n+                    let msg = match import.kind {\n+                        ImportKind::Single { .. } => {\n                             format!(\"variant `{}` is private and cannot be re-exported\", ident)\n                         }\n-                        ImportDirectiveSubclass::GlobImport { .. } => {\n+                        ImportKind::Glob { .. } => {\n                             let msg = \"enum is private and its variants \\\n                                            cannot be re-exported\"\n                                 .to_owned();\n@@ -1432,18 +1414,18 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             }\n                             msg\n                         }\n-                        ref s => bug!(\"unexpected import subclass {:?}\", s),\n+                        ref s => bug!(\"unexpected import kind {:?}\", s),\n                     };\n                     let mut err = this.session.struct_span_err(binding.span, &msg);\n \n-                    let imported_module = match directive.imported_module.get() {\n+                    let imported_module = match import.imported_module.get() {\n                         Some(ModuleOrUniformRoot::Module(module)) => module,\n                         _ => bug!(\"module should exist\"),\n                     };\n                     let parent_module = imported_module.parent.expect(\"parent should exist\");\n                     let resolutions = this.resolutions(parent_module).borrow();\n-                    let enum_path_segment_index = directive.module_path.len() - 1;\n-                    let enum_ident = directive.module_path[enum_path_segment_index].ident;\n+                    let enum_path_segment_index = import.module_path.len() - 1;\n+                    let enum_ident = import.module_path[enum_path_segment_index].ident;\n \n                     let key = this.new_key(enum_ident, TypeNS);\n                     let enum_resolution = resolutions.get(&key).expect(\"resolution should exist\");\n@@ -1481,11 +1463,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     }\n }\n \n-fn import_path_to_string(\n-    names: &[Ident],\n-    subclass: &ImportDirectiveSubclass<'_>,\n-    span: Span,\n-) -> String {\n+fn import_path_to_string(names: &[Ident], import_kind: &ImportKind<'_>, span: Span) -> String {\n     let pos = names.iter().position(|p| span == p.span && p.name != kw::PathRoot);\n     let global = !names.is_empty() && names[0].name == kw::PathRoot;\n     if let Some(pos) = pos {\n@@ -1494,22 +1472,22 @@ fn import_path_to_string(\n     } else {\n         let names = if global { &names[1..] } else { names };\n         if names.is_empty() {\n-            import_directive_subclass_to_string(subclass)\n+            import_kind_to_string(import_kind)\n         } else {\n             format!(\n                 \"{}::{}\",\n                 names_to_string(&names.iter().map(|ident| ident.name).collect::<Vec<_>>()),\n-                import_directive_subclass_to_string(subclass),\n+                import_kind_to_string(import_kind),\n             )\n         }\n     }\n }\n \n-fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass<'_>) -> String {\n-    match *subclass {\n-        SingleImport { source, .. } => source.to_string(),\n-        GlobImport { .. } => \"*\".to_string(),\n-        ExternCrate { .. } => \"<extern crate>\".to_string(),\n-        MacroUse => \"#[macro_use]\".to_string(),\n+fn import_kind_to_string(import_kind: &ImportKind<'_>) -> String {\n+    match import_kind {\n+        ImportKind::Single { source, .. } => source.to_string(),\n+        ImportKind::Glob { .. } => \"*\".to_string(),\n+        ImportKind::ExternCrate { .. } => \"<extern crate>\".to_string(),\n+        ImportKind::MacroUse => \"#[macro_use]\".to_string(),\n     }\n }"}, {"sha": "97d60e1a23d8dcad7aae37450e14ce40d7dda06c", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -2189,10 +2189,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         trait_name: Ident,\n     ) -> SmallVec<[NodeId; 1]> {\n         let mut import_ids = smallvec![];\n-        while let NameBindingKind::Import { directive, binding, .. } = kind {\n-            self.r.maybe_unused_trait_imports.insert(directive.id);\n-            self.r.add_to_glob_map(&directive, trait_name);\n-            import_ids.push(directive.id);\n+        while let NameBindingKind::Import { import, binding, .. } = kind {\n+            self.r.maybe_unused_trait_imports.insert(import.id);\n+            self.r.add_to_glob_map(&import, trait_name);\n+            import_ids.push(import.id);\n             kind = &binding.kind;\n         }\n         import_ids"}, {"sha": "492ac6ed839770f8847ad79c3257c874cd3ebd12", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 47, "deletions": 52, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -56,7 +56,7 @@ use std::{cmp, fmt, iter, ptr};\n \n use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_next_binding};\n use diagnostics::{ImportSuggestion, Suggestion};\n-use imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver, NameResolution};\n+use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{HasGenericParams, PathSource, Rib, RibKind::*};\n use macros::{LegacyBinding, LegacyScope};\n \n@@ -456,8 +456,8 @@ pub struct ModuleData<'a> {\n \n     no_implicit_prelude: bool,\n \n-    glob_importers: RefCell<Vec<&'a ImportDirective<'a>>>,\n-    globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n+    glob_importers: RefCell<Vec<&'a Import<'a>>>,\n+    globs: RefCell<Vec<&'a Import<'a>>>,\n \n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n     traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n@@ -584,7 +584,7 @@ impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n enum NameBindingKind<'a> {\n     Res(Res, /* is_macro_export */ bool),\n     Module(Module<'a>),\n-    Import { binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>, used: Cell<bool> },\n+    Import { binding: &'a NameBinding<'a>, import: &'a Import<'a>, used: Cell<bool> },\n }\n \n impl<'a> NameBindingKind<'a> {\n@@ -713,8 +713,7 @@ impl<'a> NameBinding<'a> {\n     fn is_extern_crate(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import {\n-                directive:\n-                    &ImportDirective { subclass: ImportDirectiveSubclass::ExternCrate { .. }, .. },\n+                import: &Import { kind: ImportKind::ExternCrate { .. }, .. },\n                 ..\n             } => true,\n             NameBindingKind::Module(&ModuleData {\n@@ -734,7 +733,7 @@ impl<'a> NameBinding<'a> {\n \n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n-            NameBindingKind::Import { directive, .. } => directive.is_glob(),\n+            NameBindingKind::Import { import, .. } => import.is_glob(),\n             _ => false,\n         }\n     }\n@@ -839,10 +838,10 @@ pub struct Resolver<'a> {\n     field_names: FxHashMap<DefId, Vec<Spanned<Name>>>,\n \n     /// All imports known to succeed or fail.\n-    determined_imports: Vec<&'a ImportDirective<'a>>,\n+    determined_imports: Vec<&'a Import<'a>>,\n \n     /// All non-determined imports.\n-    indeterminate_imports: Vec<&'a ImportDirective<'a>>,\n+    indeterminate_imports: Vec<&'a Import<'a>>,\n \n     /// FIXME: Refactor things so that these fields are passed through arguments and not resolver.\n     /// We are resolving a last import segment during import validation.\n@@ -947,7 +946,7 @@ pub struct Resolver<'a> {\n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n \n-    potentially_unused_imports: Vec<&'a ImportDirective<'a>>,\n+    potentially_unused_imports: Vec<&'a Import<'a>>,\n \n     /// Table for mapping struct IDs into struct constructor IDs,\n     /// it's not used during normal resolution, only for better error reporting.\n@@ -971,7 +970,7 @@ pub struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleData<'a>>,\n     local_modules: RefCell<Vec<Module<'a>>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n-    import_directives: arena::TypedArena<ImportDirective<'a>>,\n+    imports: arena::TypedArena<Import<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n     legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n     ast_paths: arena::TypedArena<ast::Path>,\n@@ -991,11 +990,8 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n         self.name_bindings.alloc(name_binding)\n     }\n-    fn alloc_import_directive(\n-        &'a self,\n-        import_directive: ImportDirective<'a>,\n-    ) -> &'a ImportDirective<'_> {\n-        self.import_directives.alloc(import_directive)\n+    fn alloc_import(&'a self, import: Import<'a>) -> &'a Import<'_> {\n+        self.imports.alloc(import)\n     }\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n@@ -1410,7 +1406,7 @@ impl<'a> Resolver<'a> {\n                 misc2: AmbiguityErrorMisc::None,\n             });\n         }\n-        if let NameBindingKind::Import { directive, binding, ref used } = used_binding.kind {\n+        if let NameBindingKind::Import { import, binding, ref used } = used_binding.kind {\n             // Avoid marking `extern crate` items that refer to a name from extern prelude,\n             // but not introduce it, as used if they are accessed from lexical scope.\n             if is_lexical_scope {\n@@ -1423,17 +1419,17 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             used.set(true);\n-            directive.used.set(true);\n-            self.used_imports.insert((directive.id, ns));\n-            self.add_to_glob_map(&directive, ident);\n+            import.used.set(true);\n+            self.used_imports.insert((import.id, ns));\n+            self.add_to_glob_map(&import, ident);\n             self.record_use(ident, ns, binding, false);\n         }\n     }\n \n     #[inline]\n-    fn add_to_glob_map(&mut self, directive: &ImportDirective<'_>, ident: Ident) {\n-        if directive.is_glob() {\n-            self.glob_map.entry(directive.id).or_default().insert(ident.name);\n+    fn add_to_glob_map(&mut self, import: &Import<'_>, ident: Ident) {\n+        if import.is_glob() {\n+            self.glob_map.entry(import.id).or_default().insert(ident.name);\n         }\n     }\n \n@@ -2258,10 +2254,9 @@ impl<'a> Resolver<'a> {\n         // `ExternCrate` (also used for `crate::...`) then no need to issue a\n         // warning, this looks all good!\n         if let Some(binding) = second_binding {\n-            if let NameBindingKind::Import { directive: d, .. } = binding.kind {\n-                // Careful: we still want to rewrite paths from\n-                // renamed extern crates.\n-                if let ImportDirectiveSubclass::ExternCrate { source: None, .. } = d.subclass {\n+            if let NameBindingKind::Import { import, .. } = binding.kind {\n+                // Careful: we still want to rewrite paths from renamed extern crates.\n+                if let ImportKind::ExternCrate { source: None, .. } = import.kind {\n                     return;\n                 }\n             }\n@@ -2564,10 +2559,10 @@ impl<'a> Resolver<'a> {\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         use NameBindingKind::Import;\n-        let directive = match (&new_binding.kind, &old_binding.kind) {\n+        let import = match (&new_binding.kind, &old_binding.kind) {\n             // If there are two imports where one or both have attributes then prefer removing the\n             // import without attributes.\n-            (Import { directive: new, .. }, Import { directive: old, .. })\n+            (Import { import: new, .. }, Import { import: old, .. })\n                 if {\n                     !new_binding.span.is_dummy()\n                         && !old_binding.span.is_dummy()\n@@ -2581,11 +2576,11 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             // Otherwise prioritize the new binding.\n-            (Import { directive, .. }, other) if !new_binding.span.is_dummy() => {\n-                Some((directive, new_binding.span, other.is_import()))\n+            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+                Some((import, new_binding.span, other.is_import()))\n             }\n-            (other, Import { directive, .. }) if !old_binding.span.is_dummy() => {\n-                Some((directive, old_binding.span, other.is_import()))\n+            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+                Some((import, old_binding.span, other.is_import()))\n             }\n             _ => None,\n         };\n@@ -2602,22 +2597,22 @@ impl<'a> Resolver<'a> {\n             && !has_dummy_span\n             && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n \n-        match directive {\n-            Some((directive, span, true)) if should_remove_import && directive.is_nested() => {\n-                self.add_suggestion_for_duplicate_nested_use(&mut err, directive, span)\n+        match import {\n+            Some((import, span, true)) if should_remove_import && import.is_nested() => {\n+                self.add_suggestion_for_duplicate_nested_use(&mut err, import, span)\n             }\n-            Some((directive, _, true)) if should_remove_import && !directive.is_glob() => {\n+            Some((import, _, true)) if should_remove_import && !import.is_glob() => {\n                 // Simple case - remove the entire import. Due to the above match arm, this can\n                 // only be a single use so just remove it entirely.\n                 err.tool_only_span_suggestion(\n-                    directive.use_span_with_attributes,\n+                    import.use_span_with_attributes,\n                     \"remove unnecessary import\",\n                     String::new(),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            Some((directive, span, _)) => {\n-                self.add_suggestion_for_rename_of_use(&mut err, name, directive, span)\n+            Some((import, span, _)) => {\n+                self.add_suggestion_for_rename_of_use(&mut err, name, import, span)\n             }\n             _ => {}\n         }\n@@ -2639,7 +2634,7 @@ impl<'a> Resolver<'a> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         name: Name,\n-        directive: &ImportDirective<'_>,\n+        import: &Import<'_>,\n         binding_span: Span,\n     ) {\n         let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n@@ -2649,11 +2644,11 @@ impl<'a> Resolver<'a> {\n         };\n \n         let mut suggestion = None;\n-        match directive.subclass {\n-            ImportDirectiveSubclass::SingleImport { type_ns_only: true, .. } => {\n+        match import.kind {\n+            ImportKind::Single { type_ns_only: true, .. } => {\n                 suggestion = Some(format!(\"self as {}\", suggested_name))\n             }\n-            ImportDirectiveSubclass::SingleImport { source, .. } => {\n+            ImportKind::Single { source, .. } => {\n                 if let Some(pos) =\n                     source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n                 {\n@@ -2669,7 +2664,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            ImportDirectiveSubclass::ExternCrate { source, target, .. } => {\n+            ImportKind::ExternCrate { source, target, .. } => {\n                 suggestion = Some(format!(\n                     \"extern crate {} as {};\",\n                     source.unwrap_or(target.name),\n@@ -2711,27 +2706,27 @@ impl<'a> Resolver<'a> {\n     /// If the nested use contains only one import then the suggestion will remove the entire\n     /// line.\n     ///\n-    /// It is expected that the directive provided is a nested import - this isn't checked by the\n+    /// It is expected that the provided import is nested - this isn't checked by the\n     /// function. If this invariant is not upheld, this function's behaviour will be unexpected\n     /// as characters expected by span manipulations won't be present.\n     fn add_suggestion_for_duplicate_nested_use(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        directive: &ImportDirective<'_>,\n+        import: &Import<'_>,\n         binding_span: Span,\n     ) {\n-        assert!(directive.is_nested());\n+        assert!(import.is_nested());\n         let message = \"remove unnecessary import\";\n \n         // Two examples will be used to illustrate the span manipulations we're doing:\n         //\n         // - Given `use issue_52891::{d, a, e};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `directive.use_span` is `issue_52891::{d, a, e};`.\n+        //   `a` and `import.use_span` is `issue_52891::{d, a, e};`.\n         // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `directive.use_span` is `issue_52891::{d, e, a};`.\n+        //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n \n         let (found_closing_brace, span) =\n-            find_span_of_binding_until_next_binding(self.session, binding_span, directive.use_span);\n+            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n \n         // If there was a closing brace then identify the span to remove any trailing commas from\n         // previous imports.\n@@ -2747,7 +2742,7 @@ impl<'a> Resolver<'a> {\n                 // Remove the entire line if we cannot extend the span back, this indicates a\n                 // `issue_52891::{self}` case.\n                 err.span_suggestion(\n-                    directive.use_span_with_attributes,\n+                    import.use_span_with_attributes,\n                     message,\n                     String::new(),\n                     Applicability::MaybeIncorrect,"}, {"sha": "88bfe7661e20320938047bb94898fe2dba7874c6", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -532,13 +532,16 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 match self.tables.expr_ty_adjusted(&hir_node).kind {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n-                        let index = self.tcx.find_field_index(ident, variant).unwrap();\n                         filter!(self.span_utils, ident.span);\n                         let span = self.span_from_span(ident.span);\n                         return Some(Data::RefData(Ref {\n                             kind: RefKind::Variable,\n                             span,\n-                            ref_id: id_from_def_id(variant.fields[index].did),\n+                            ref_id: self\n+                                .tcx\n+                                .find_field_index(ident, variant)\n+                                .map(|index| id_from_def_id(variant.fields[index].did))\n+                                .unwrap_or_else(|| null_id()),\n                         }));\n                     }\n                     ty::Tuple(..) => None,"}, {"sha": "84854dff85165b78a44597ee1b6f001cd5b716db", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -577,8 +577,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let var_ty = self.resolve_vars_with_obligations(var_ty);\n             let msg = format!(\"first introduced with type `{}` here\", var_ty);\n             err.span_label(hir.span(var_id), msg);\n-            let in_arm = hir.parent_iter(var_id).any(|(_, n)| matches!(n, hir::Node::Arm(..)));\n-            let pre = if in_arm { \"in the same arm, \" } else { \"\" };\n+            let in_match = hir.parent_iter(var_id).any(|(_, n)| {\n+                matches!(\n+                    n,\n+                    hir::Node::Expr(hir::Expr {\n+                        kind: hir::ExprKind::Match(.., hir::MatchSource::Normal),\n+                        ..\n+                    })\n+                )\n+            });\n+            let pre = if in_match { \"in the same arm, \" } else { \"\" };\n             err.note(&format!(\"{}a binding must have the same type in all alternatives\", pre));\n             err.emit();\n         }"}, {"sha": "95f066c382c8d8d00b5b084e4f286411c644a286", "filename": "src/test/ui/assign-to-method.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f943349eafaa75a60c05b0c84dcdb771d0eae8c9/src%2Ftest%2Fui%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f943349eafaa75a60c05b0c84dcdb771d0eae8c9/src%2Ftest%2Fui%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassign-to-method.rs?ref=f943349eafaa75a60c05b0c84dcdb771d0eae8c9", "patch": "@@ -1,22 +0,0 @@\n-struct Cat {\n-  meows : usize,\n-\n-  how_hungry : isize,\n-}\n-\n-impl Cat {\n-    pub fn speak(&self) { self.meows += 1; }\n-}\n-\n-fn cat(in_x : usize, in_y : isize) -> Cat {\n-    Cat {\n-        meows: in_x,\n-        how_hungry: in_y\n-    }\n-}\n-\n-fn main() {\n-  let nyan : Cat = cat(52, 99);\n-  nyan.speak = || println!(\"meow\"); //~ ERROR attempted to take value of method\n-  nyan.speak += || println!(\"meow\"); //~ ERROR attempted to take value of method\n-}"}, {"sha": "7794cc7583dfcefa8cdaf753b016e8276fa95a47", "filename": "src/test/ui/consts/min_const_fn/allow_const_fn_ptr_feature_gate.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -4,7 +4,6 @@ error[E0658]: internal implementation detail\n LL | #[rustc_allow_const_fn_ptr]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: aborting due to previous error"}, {"sha": "d31736f142c3f45394d12e29ae6a9367136377e3", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -3,6 +3,7 @@\n \n #![feature(generators, generator_trait, untagged_unions)]\n #![feature(move_ref_pattern)]\n+#![feature(bindings_after_at)]\n \n #![allow(unused_assignments)]\n #![allow(unused_variables)]\n@@ -291,6 +292,44 @@ fn subslice_mixed_min_lengths(a: &Allocator, c: i32) {\n     }\n }\n \n+fn bindings_after_at_dynamic_init_move(a: &Allocator, c: bool) {\n+    let foo = if c { Some(a.alloc()) } else { None };\n+    let _x;\n+\n+    if let bar @ Some(_) = foo {\n+        _x = bar;\n+    }\n+}\n+\n+fn bindings_after_at_dynamic_init_ref(a: &Allocator, c: bool) {\n+    let foo = if c { Some(a.alloc()) } else { None };\n+    let _x;\n+\n+    if let bar @ Some(_baz) = &foo {\n+        _x = bar;\n+    }\n+}\n+\n+fn bindings_after_at_dynamic_drop_move(a: &Allocator, c: bool) {\n+    let foo = if c { Some(a.alloc()) } else { None };\n+\n+    if let bar @ Some(_) = foo {\n+        bar\n+    } else {\n+        None\n+    };\n+}\n+\n+fn bindings_after_at_dynamic_drop_ref(a: &Allocator, c: bool) {\n+    let foo = if c { Some(a.alloc()) } else { None };\n+\n+    if let bar @ Some(_baz) = &foo {\n+        bar\n+    } else {\n+        &None\n+    };\n+}\n+\n fn move_ref_pattern(a: &Allocator) {\n     let mut tup = (a.alloc(), a.alloc(), a.alloc(), a.alloc());\n     let (ref _a, ref mut _b, _c, mut _d) = tup;\n@@ -471,5 +510,14 @@ fn main() {\n     run_test(|a| panic_after_init_temp(a));\n     run_test(|a| panic_after_init_by_loop(a));\n \n+    run_test(|a| bindings_after_at_dynamic_init_move(a, true));\n+    run_test(|a| bindings_after_at_dynamic_init_move(a, false));\n+    run_test(|a| bindings_after_at_dynamic_init_ref(a, true));\n+    run_test(|a| bindings_after_at_dynamic_init_ref(a, false));\n+    run_test(|a| bindings_after_at_dynamic_drop_move(a, true));\n+    run_test(|a| bindings_after_at_dynamic_drop_move(a, false));\n+    run_test(|a| bindings_after_at_dynamic_drop_ref(a, true));\n+    run_test(|a| bindings_after_at_dynamic_drop_ref(a, false));\n+\n     run_test_nopanic(|a| union1(a));\n }"}, {"sha": "82dec1fd4cf21f74ba75da84fc99bc84d6c7f552", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs-1.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -4,7 +4,6 @@ error[E0658]: the `#[rustc_variance]` attribute is just used for rustc unit test\n LL | #[rustc_variance]\n    | ^^^^^^^^^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error[E0658]: the `#[rustc_error]` attribute is just used for rustc unit tests and will never be stable\n@@ -13,7 +12,6 @@ error[E0658]: the `#[rustc_error]` attribute is just used for rustc unit tests a\n LL | #[rustc_error]\n    | ^^^^^^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error[E0658]: the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable niche optimizations in libcore and will never be stable\n@@ -22,7 +20,6 @@ error[E0658]: the `#[rustc_nonnull_optimization_guaranteed]` attribute is just u\n LL | #[rustc_nonnull_optimization_guaranteed]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors"}, {"sha": "1e039f17a0d115f3b080805791d3b600908633c9", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -4,7 +4,6 @@ error[E0658]: attributes starting with `rustc` are reserved for use by the `rust\n LL | #[rustc::unknown]\n    |   ^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: expected attribute, found macro `rustc::unknown`\n@@ -19,7 +18,6 @@ error[E0658]: attributes starting with `rustc` are reserved for use by the `rust\n LL | #[unknown::rustc]\n    |            ^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: expected attribute, found macro `unknown::rustc`\n@@ -34,7 +32,6 @@ error[E0658]: attributes starting with `rustc` are reserved for use by the `rust\n LL | #[rustc_unknown]\n    |   ^^^^^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: cannot find attribute `rustc_unknown` in this scope\n@@ -49,7 +46,6 @@ error[E0658]: the `#[rustc_dummy]` attribute is just used for rustc unit tests a\n LL | #[rustc_dummy]\n    | ^^^^^^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: aborting due to 7 previous errors"}, {"sha": "3494df37fe7f107f2a50543fc904a5b3c320569b", "filename": "src/test/ui/issues/issue-3763.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fissues%2Fissue-3763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fissues%2Fissue-3763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3763.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1,3 +1,6 @@\n+// compile-flags: -Zsave-analysis\n+// Also regression test for #69416\n+\n mod my_mod {\n     pub struct MyStruct {\n         priv_field: isize"}, {"sha": "873f69d390e678fe504ee01a0032b03434080edb", "filename": "src/test/ui/issues/issue-3763.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fissues%2Fissue-3763.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fissues%2Fissue-3763.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3763.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1,29 +1,29 @@\n error[E0616]: field `priv_field` of struct `my_mod::MyStruct` is private\n-  --> $DIR/issue-3763.rs:15:19\n+  --> $DIR/issue-3763.rs:18:19\n    |\n LL |     let _woohoo = (&my_struct).priv_field;\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0616]: field `priv_field` of struct `my_mod::MyStruct` is private\n-  --> $DIR/issue-3763.rs:18:19\n+  --> $DIR/issue-3763.rs:21:19\n    |\n LL |     let _woohoo = (Box::new(my_struct)).priv_field;\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0624]: method `happyfun` is private\n-  --> $DIR/issue-3763.rs:21:18\n+  --> $DIR/issue-3763.rs:24:18\n    |\n LL |     (&my_struct).happyfun();\n    |                  ^^^^^^^^\n \n error[E0624]: method `happyfun` is private\n-  --> $DIR/issue-3763.rs:23:27\n+  --> $DIR/issue-3763.rs:26:27\n    |\n LL |     (Box::new(my_struct)).happyfun();\n    |                           ^^^^^^^^\n \n error[E0616]: field `priv_field` of struct `my_mod::MyStruct` is private\n-  --> $DIR/issue-3763.rs:24:16\n+  --> $DIR/issue-3763.rs:27:16\n    |\n LL |     let nope = my_struct.priv_field;\n    |                ^^^^^^^^^^^^^^^^^^^^"}, {"sha": "cd7faf9bf8bfb056a8ed983dbdc1f8c54a009434", "filename": "src/test/ui/macros/assert-trailing-junk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -13,12 +13,12 @@ fn main() {\n     //~^ ERROR no rules expected\n \n     assert!(true \"whatever\" blah);\n-    //~^ WARN unexpected string literal\n+    //~^ ERROR unexpected string literal\n     //~^^ ERROR no rules expected\n \n     assert!(true;);\n-    //~^ WARN macro requires an expression\n+    //~^ ERROR macro requires an expression\n \n     assert!(false || true \"error message\");\n-    //~^ WARN unexpected string literal\n+    //~^ ERROR unexpected string literal\n }"}, {"sha": "84a6768b3f453cde932ed520909c8f88d9b189f8", "filename": "src/test/ui/macros/assert-trailing-junk.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -18,15 +18,13 @@ LL |     assert!(true, \"whatever\" blah);\n    |                             |\n    |                             help: missing comma here\n \n-warning: unexpected string literal\n+error: unexpected string literal\n   --> $DIR/assert-trailing-junk.rs:15:18\n    |\n LL |     assert!(true \"whatever\" blah);\n    |                 -^^^^^^^^^^\n    |                 |\n    |                 help: try adding a comma\n-   |\n-   = note: this is going to be an error in the future\n \n error: no rules expected the token `blah`\n   --> $DIR/assert-trailing-junk.rs:15:29\n@@ -36,25 +34,21 @@ LL |     assert!(true \"whatever\" blah);\n    |                            |\n    |                            help: missing comma here\n \n-warning: macro requires an expression as an argument\n+error: macro requires an expression as an argument\n   --> $DIR/assert-trailing-junk.rs:19:5\n    |\n LL |     assert!(true;);\n    |     ^^^^^^^^^^^^-^^\n    |                 |\n    |                 help: try removing semicolon\n-   |\n-   = note: this is going to be an error in the future\n \n-warning: unexpected string literal\n+error: unexpected string literal\n   --> $DIR/assert-trailing-junk.rs:22:27\n    |\n LL |     assert!(false || true \"error message\");\n    |                          -^^^^^^^^^^^^^^^\n    |                          |\n    |                          help: try adding a comma\n-   |\n-   = note: this is going to be an error in the future\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "85beaee8df0a18d68dd844089c41d6d720bb2500", "filename": "src/test/ui/methods/assign-to-method.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fmethods%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fmethods%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fassign-to-method.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags: -Zsave-analysis\n+// Also regression test for #69409\n+\n+struct Cat {\n+    meows : usize,\n+    how_hungry : isize,\n+}\n+\n+impl Cat {\n+    pub fn speak(&self) { self.meows += 1; }\n+}\n+\n+fn cat(in_x : usize, in_y : isize) -> Cat {\n+    Cat {\n+        meows: in_x,\n+        how_hungry: in_y\n+    }\n+}\n+\n+fn main() {\n+    let nyan : Cat = cat(52, 99);\n+    nyan.speak = || println!(\"meow\"); //~ ERROR attempted to take value of method\n+    nyan.speak += || println!(\"meow\"); //~ ERROR attempted to take value of method\n+}"}, {"sha": "c0dd529b6818ff9c7d9e3f02ece636c7fe8c9ca1", "filename": "src/test/ui/methods/assign-to-method.stderr", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fmethods%2Fassign-to-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fmethods%2Fassign-to-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fassign-to-method.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1,16 +1,16 @@\n error[E0615]: attempted to take value of method `speak` on type `Cat`\n-  --> $DIR/assign-to-method.rs:20:8\n+  --> $DIR/assign-to-method.rs:22:10\n    |\n-LL |   nyan.speak = || println!(\"meow\");\n-   |        ^^^^^\n+LL |     nyan.speak = || println!(\"meow\");\n+   |          ^^^^^\n    |\n    = help: methods are immutable and cannot be assigned to\n \n error[E0615]: attempted to take value of method `speak` on type `Cat`\n-  --> $DIR/assign-to-method.rs:21:8\n+  --> $DIR/assign-to-method.rs:23:10\n    |\n-LL |   nyan.speak += || println!(\"meow\");\n-   |        ^^^^^\n+LL |     nyan.speak += || println!(\"meow\");\n+   |          ^^^^^\n    |\n    = help: methods are immutable and cannot be assigned to\n ", "previous_filename": "src/test/ui/assign-to-method.stderr"}, {"sha": "a4b33963fb0b95b6bffa497f670cf31d932a41ae", "filename": "src/test/ui/on-unimplemented/feature-gate-on-unimplemented.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fon-unimplemented%2Ffeature-gate-on-unimplemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fon-unimplemented%2Ffeature-gate-on-unimplemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Ffeature-gate-on-unimplemented.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -4,7 +4,6 @@ error[E0658]: this is an internal attribute that will never be stable\n LL | #[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}`\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: aborting due to previous error"}, {"sha": "1dabb7c975430058b2ca0c5be09f9a2b743a82d7", "filename": "src/test/ui/or-patterns/or-patterns-binding-type-mismatch.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -101,7 +101,7 @@ LL |     if let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2) {\n    |                          |               expected `usize`, found `isize`\n    |                          first introduced with type `usize` here\n    |\n-   = note: in the same arm, a binding must have the same type in all alternatives\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:38:47\n@@ -112,7 +112,7 @@ LL |     if let Some(Blah::A(_, x, y) | Blah::B(x, y)) = Some(Blah::A(1, 1, 2))\n    |                               |               expected `usize`, found `isize`\n    |                               first introduced with type `usize` here\n    |\n-   = note: in the same arm, a binding must have the same type in all alternatives\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:42:22\n@@ -123,7 +123,7 @@ LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n    |                |     expected `u16`, found `u8`\n    |                first introduced with type `u16` here\n    |\n-   = note: in the same arm, a binding must have the same type in all alternatives\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:42:25\n@@ -134,7 +134,7 @@ LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n    |             |           expected `u8`, found `u16`\n    |             first introduced with type `u8` here\n    |\n-   = note: in the same arm, a binding must have the same type in all alternatives\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:44\n@@ -147,7 +147,7 @@ LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n    |\n-   = note: in the same arm, a binding must have the same type in all alternatives\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:53\n@@ -160,7 +160,7 @@ LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n    |\n-   = note: in the same arm, a binding must have the same type in all alternatives\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:62\n@@ -173,7 +173,7 @@ LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n    |\n-   = note: in the same arm, a binding must have the same type in all alternatives\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:65\n@@ -184,7 +184,7 @@ LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n    |\n-   = note: in the same arm, a binding must have the same type in all alternatives\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:55:39"}, {"sha": "19144b210a12740bbf6f7e55e40d9e737f7e55a7", "filename": "src/test/ui/proc-macro/expand-to-unstable-2.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -4,7 +4,6 @@ error[E0658]: attributes starting with `rustc` are reserved for use by the `rust\n LL | #[derive(Unstable)]\n    |          ^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "c387bba0a13102c9fbb424a6021f4c34a00786dc", "filename": "src/test/ui/reserved/reserved-attr-on-macro.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -4,7 +4,6 @@ error[E0658]: attributes starting with `rustc` are reserved for use by the `rust\n LL | #[rustc_attribute_should_be_reserved]\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: cannot determine resolution for the macro `foo`"}, {"sha": "65400163ddd86ab09fe09102de41923eabda44d5", "filename": "src/test/ui/rust-2018/macro-use-warned-against.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -4,7 +4,7 @@\n \n #![warn(macro_use_extern_crate, unused)]\n \n-#[macro_use] //~ WARN should be replaced at use sites with a `use` statement\n+#[macro_use] //~ WARN should be replaced at use sites with a `use` item\n extern crate macro_use_warned_against;\n #[macro_use] //~ WARN unused `#[macro_use]`\n extern crate macro_use_warned_against2;"}, {"sha": "ef00b865815c06032c5b268751921c2904350b16", "filename": "src/test/ui/rust-2018/macro-use-warned-against.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1,4 +1,4 @@\n-warning: deprecated `#[macro_use]` directive used to import macros should be replaced at use sites with a `use` statement to import the macro instead\n+warning: deprecated `#[macro_use]` attribute used to import macros should be replaced at use sites with a `use` item to import the macro instead\n   --> $DIR/macro-use-warned-against.rs:7:1\n    |\n LL | #[macro_use]"}, {"sha": "c7c257ba5fe5386ace366ae430588704de0b3fb1", "filename": "src/test/ui/suggestions/attribute-typos.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -4,7 +4,6 @@ error[E0658]: attributes starting with `rustc` are reserved for use by the `rust\n LL | #[rustc_err]\n    |   ^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: cannot find attribute `rustc_err` in this scope"}, {"sha": "743e4b658c6b7a5daca671ec39d1b4ec2838e06e", "filename": "src/test/ui/tool-attributes/diagnostic_item.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Ftool-attributes%2Fdiagnostic_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftest%2Fui%2Ftool-attributes%2Fdiagnostic_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes%2Fdiagnostic_item.stderr?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -4,7 +4,6 @@ error[E0658]: diagnostic items compiler internal support for linting\n LL | #[rustc_diagnostic_item = \"foomp\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: see issue #29642 <https://github.com/rust-lang/rust/issues/29642> for more information\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: aborting due to previous error"}, {"sha": "d9320e9147cffd31da018f866c6765d21b6f4621", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -63,20 +63,6 @@ pub struct CollectedFeatures {\n pub fn collect_lib_features(base_src_path: &Path) -> Features {\n     let mut lib_features = Features::new();\n \n-    // This library feature is defined in the `compiler_builtins` crate, which\n-    // has been moved out-of-tree. Now it can no longer be auto-discovered by\n-    // `tidy`, because we need to filter out its (submodule) directory. Manually\n-    // add it to the set of known library features so we can still generate docs.\n-    lib_features.insert(\n-        \"compiler_builtins_lib\".to_owned(),\n-        Feature {\n-            level: Status::Unstable,\n-            since: None,\n-            has_gate_test: false,\n-            tracking_issue: None,\n-        },\n-    );\n-\n     map_lib_features(base_src_path, &mut |res, _, _| {\n         if let Ok((name, feature)) = res {\n             lib_features.insert(name.to_owned(), feature);"}, {"sha": "7dfb6224d240a69e54ba88400f36a8c39f628ad1", "filename": "src/tools/tidy/src/unstable_book.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5241c96208ca7d925442b1a5fa45ad18717a6f/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs?ref=1d5241c96208ca7d925442b1a5fa45ad18717a6f", "patch": "@@ -1,4 +1,4 @@\n-use crate::features::{CollectedFeatures, Feature, Features, Status};\n+use crate::features::{CollectedFeatures, Features, Status};\n use std::collections::BTreeSet;\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -73,26 +73,12 @@ fn collect_unstable_book_lib_features_section_file_names(base_src_path: &Path) -\n \n pub fn check(path: &Path, features: CollectedFeatures, bad: &mut bool) {\n     let lang_features = features.lang;\n-    let mut lib_features = features\n+    let lib_features = features\n         .lib\n         .into_iter()\n         .filter(|&(ref name, _)| !lang_features.contains_key(name))\n         .collect::<Features>();\n \n-    // This library feature is defined in the `compiler_builtins` crate, which\n-    // has been moved out-of-tree. Now it can no longer be auto-discovered by\n-    // `tidy`, because we need to filter out its (submodule) directory. Manually\n-    // add it to the set of known library features so we can still generate docs.\n-    lib_features.insert(\n-        \"compiler_builtins_lib\".to_owned(),\n-        Feature {\n-            level: Status::Unstable,\n-            since: None,\n-            has_gate_test: false,\n-            tracking_issue: None,\n-        },\n-    );\n-\n     // Library features\n     let unstable_lib_feature_names = collect_unstable_feature_names(&lib_features);\n     let unstable_book_lib_features_section_file_names ="}]}