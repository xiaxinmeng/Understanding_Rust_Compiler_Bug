{"sha": "10667753c71242c75e70e7b8c46486f37685c186", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNjY3NzUzYzcxMjQyYzc1ZTcwZTdiOGM0NjQ4NmYzNzY4NWMxODY=", "commit": {"author": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-03-31T21:02:48Z"}, "committer": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-04-01T21:06:14Z"}, "message": "Use ast::make API in add_function assist", "tree": {"sha": "e32cd2b6965f9f2ed6cda7f84b426bb8de435b35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e32cd2b6965f9f2ed6cda7f84b426bb8de435b35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10667753c71242c75e70e7b8c46486f37685c186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10667753c71242c75e70e7b8c46486f37685c186", "html_url": "https://github.com/rust-lang/rust/commit/10667753c71242c75e70e7b8c46486f37685c186", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10667753c71242c75e70e7b8c46486f37685c186/comments", "author": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "html_url": "https://github.com/rust-lang/rust/commit/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae"}], "stats": {"total": 140, "additions": 73, "deletions": 67}, "files": [{"sha": "488bae08f14f5bfeb6e36d32a4c89a27a0074399", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 48, "deletions": 67, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/10667753c71242c75e70e7b8c46486f37685c186/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10667753c71242c75e70e7b8c46486f37685c186/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=10667753c71242c75e70e7b8c46486f37685c186", "patch": "@@ -1,12 +1,11 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n-    SmolStr, SyntaxKind, SyntaxNode, TextUnit,\n+    SyntaxKind, SyntaxNode, TextUnit,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n-use ast::{ArgListOwner, CallExpr, Expr};\n+use ast::{edit::IndentLevel, ArgListOwner, CallExpr, Expr};\n use hir::HirDisplay;\n-use ra_fmt::leading_indent;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n // Assist: add_function\n@@ -53,73 +52,62 @@ pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n     ctx.add_assist(AssistId(\"add_function\"), \"Add function\", |edit| {\n         edit.target(call.syntax().text_range());\n \n-        let function_template = function_builder.render();\n-        edit.set_cursor(function_template.cursor_offset);\n-        edit.insert(function_template.insert_offset, function_template.fn_text);\n+        if let Some(function_template) = function_builder.render() {\n+            edit.set_cursor(function_template.cursor_offset);\n+            edit.insert(function_template.insert_offset, function_template.fn_def.to_string());\n+        }\n     })\n }\n \n struct FunctionTemplate {\n     insert_offset: TextUnit,\n     cursor_offset: TextUnit,\n-    fn_text: String,\n+    fn_def: ast::SourceFile,\n }\n \n struct FunctionBuilder {\n-    start_offset: TextUnit,\n-    fn_name: String,\n-    fn_generics: String,\n-    fn_args: String,\n-    indent: String,\n+    append_fn_at: SyntaxNode,\n+    fn_name: ast::Name,\n+    type_params: Option<ast::TypeParamList>,\n+    params: ast::ParamList,\n }\n \n impl FunctionBuilder {\n     fn from_call(ctx: &AssistCtx, call: &ast::CallExpr) -> Option<Self> {\n-        let (start, indent) = next_space_for_fn(&call)?;\n+        let append_fn_at = next_space_for_fn(&call)?;\n         let fn_name = fn_name(&call)?;\n-        let fn_generics = fn_generics(&call)?;\n-        let fn_args = fn_args(ctx, &call)?;\n-        let indent = if let Some(i) = &indent { i.to_string() } else { String::new() };\n-        Some(Self { start_offset: start, fn_name, fn_generics, fn_args, indent })\n-    }\n-    fn render(&self) -> FunctionTemplate {\n-        let mut fn_buf = String::with_capacity(128);\n-        fn_buf.push_str(\"\\n\\n\");\n-        fn_buf.push_str(&self.indent);\n-        fn_buf.push_str(\"fn \");\n-        fn_buf.push_str(&self.fn_name);\n-        fn_buf.push_str(&self.fn_generics);\n-        fn_buf.push_str(&self.fn_args);\n-        fn_buf.push_str(\" {\\n\");\n-        fn_buf.push_str(&self.indent);\n-        fn_buf.push_str(\"    \");\n-\n-        // We take the offset here to put the cursor in front of the `unimplemented!()` body\n-        let offset = TextUnit::of_str(&fn_buf);\n-\n-        fn_buf.push_str(\"unimplemented!()\\n\");\n-        fn_buf.push_str(&self.indent);\n-        fn_buf.push_str(\"}\");\n-\n-        let cursor_pos = self.start_offset + offset;\n-        FunctionTemplate {\n-            fn_text: fn_buf,\n-            cursor_offset: cursor_pos,\n-            insert_offset: self.start_offset,\n-        }\n-    }\n-}\n-\n-fn fn_name(call: &CallExpr) -> Option<String> {\n-    Some(call.expr()?.syntax().to_string())\n-}\n-\n-fn fn_generics(_call: &CallExpr) -> Option<String> {\n-    // TODO\n-    Some(\"\".into())\n-}\n-\n-fn fn_args(ctx: &AssistCtx, call: &CallExpr) -> Option<String> {\n+        let (type_params, params) = fn_args(ctx, &call)?;\n+        Some(Self { append_fn_at, fn_name, type_params, params })\n+    }\n+    fn render(self) -> Option<FunctionTemplate> {\n+        let placeholder_expr = ast::make::expr_unimplemented();\n+        let fn_body = ast::make::block_expr(vec![], Some(placeholder_expr));\n+        let fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n+        let fn_def = ast::make::add_newlines(2, fn_def);\n+        let fn_def = IndentLevel::from_node(&self.append_fn_at).increase_indent(fn_def);\n+        let insert_offset = self.append_fn_at.text_range().end();\n+        let cursor_offset_from_fn_start = fn_def\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::MacroCall::cast)?\n+            .syntax()\n+            .text_range()\n+            .start();\n+        let cursor_offset = insert_offset + cursor_offset_from_fn_start;\n+        Some(FunctionTemplate { insert_offset, cursor_offset, fn_def })\n+    }\n+}\n+\n+fn fn_name(call: &CallExpr) -> Option<ast::Name> {\n+    let name = call.expr()?.syntax().to_string();\n+    Some(ast::make::name(&name))\n+}\n+\n+/// Computes the type variables and arguments required for the generated function\n+fn fn_args(\n+    ctx: &AssistCtx,\n+    call: &CallExpr,\n+) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n@@ -134,15 +122,8 @@ fn fn_args(ctx: &AssistCtx, call: &CallExpr) -> Option<String> {\n         });\n     }\n     deduplicate_arg_names(&mut arg_names);\n-    Some(format!(\n-        \"({})\",\n-        arg_names\n-            .into_iter()\n-            .zip(arg_types)\n-            .map(|(name, ty)| format!(\"{}: {}\", name, ty))\n-            .collect::<Vec<_>>()\n-            .join(\", \")\n-    ))\n+    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| ast::make::param(name, ty));\n+    Some((None, ast::make::param_list(params)))\n }\n \n /// Makes duplicate argument names unique by appending incrementing numbers.\n@@ -203,7 +184,7 @@ fn fn_arg_type(ctx: &AssistCtx, fn_arg: &Expr) -> Option<String> {\n /// directly after the current block\n /// We want to write the generated function directly after\n /// fns, impls or macro calls, but inside mods\n-fn next_space_for_fn(expr: &CallExpr) -> Option<(TextUnit, Option<SmolStr>)> {\n+fn next_space_for_fn(expr: &CallExpr) -> Option<SyntaxNode> {\n     let mut ancestors = expr.syntax().ancestors().peekable();\n     let mut last_ancestor: Option<SyntaxNode> = None;\n     while let Some(next_ancestor) = ancestors.next() {\n@@ -220,7 +201,7 @@ fn next_space_for_fn(expr: &CallExpr) -> Option<(TextUnit, Option<SmolStr>)> {\n         }\n         last_ancestor = Some(next_ancestor);\n     }\n-    last_ancestor.map(|a| (a.text_range().end(), leading_indent(&a)))\n+    last_ancestor\n }\n \n #[cfg(test)]"}, {"sha": "dbb9c8a9b379f6e7d5d3fe97a7588bec06c75746", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/10667753c71242c75e70e7b8c46486f37685c186/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10667753c71242c75e70e7b8c46486f37685c186/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=10667753c71242c75e70e7b8c46486f37685c186", "patch": "@@ -269,6 +269,31 @@ pub fn unreachable_macro_call() -> ast::MacroCall {\n     ast_from_text(&format!(\"unreachable!()\"))\n }\n \n+pub fn param(name: String, ty: String) -> ast::Param {\n+    ast_from_text(&format!(\"fn f({}: {}) {{ }}\", name, ty))\n+}\n+\n+pub fn param_list(pats: impl IntoIterator<Item = ast::Param>) -> ast::ParamList {\n+    let args = pats.into_iter().join(\", \");\n+    ast_from_text(&format!(\"fn f({}) {{ }}\", args))\n+}\n+\n+pub fn fn_def(\n+    fn_name: ast::Name,\n+    type_params: Option<ast::TypeParamList>,\n+    params: ast::ParamList,\n+    body: ast::BlockExpr,\n+) -> ast::FnDef {\n+    let type_params =\n+        if let Some(type_params) = type_params { format!(\"<{}>\", type_params) } else { \"\".into() };\n+    ast_from_text(&format!(\"fn {}{}{} {}\", fn_name, type_params, params, body))\n+}\n+\n+pub fn add_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n+    let newlines = \"\\n\".repeat(amount_of_newlines);\n+    ast_from_text(&format!(\"{}{}\", newlines, t.syntax()))\n+}\n+\n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let node = parse.tree().syntax().descendants().find_map(N::cast).unwrap();"}]}