{"sha": "4e26e2d8ca0a389280cf9d46297043df9a63ce06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMjZlMmQ4Y2EwYTM4OTI4MGNmOWQ0NjI5NzA0M2RmOWE2M2NlMDY=", "commit": {"author": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2014-06-21T01:14:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-25T00:23:21Z"}, "message": "Use macros to implement syntax::ext::quote::ToSource\n\nThis code deserves a bigger refactor, but here's a local improvement.", "tree": {"sha": "7fc5af69f46516a890d626417918561973a3ece8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fc5af69f46516a890d626417918561973a3ece8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e26e2d8ca0a389280cf9d46297043df9a63ce06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e26e2d8ca0a389280cf9d46297043df9a63ce06", "html_url": "https://github.com/rust-lang/rust/commit/4e26e2d8ca0a389280cf9d46297043df9a63ce06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e26e2d8ca0a389280cf9d46297043df9a63ce06/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0ec902e239b2219edf1a18b036dd32c18d3be42", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0ec902e239b2219edf1a18b036dd32c18d3be42", "html_url": "https://github.com/rust-lang/rust/commit/a0ec902e239b2219edf1a18b036dd32c18d3be42"}], "stats": {"total": 199, "additions": 74, "deletions": 125}, "files": [{"sha": "04c3f699cd7545a0add592363980f72f02761bae", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 74, "deletions": 125, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/4e26e2d8ca0a389280cf9d46297043df9a63ce06/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e26e2d8ca0a389280cf9d46297043df9a63ce06/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=4e26e2d8ca0a389280cf9d46297043df9a63ce06", "patch": "@@ -68,72 +68,61 @@ pub mod rt {\n \n     */\n \n+    // FIXME: Move this trait to pprust and get rid of *_to_str?\n     pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n         fn to_source(&self) -> String;\n     }\n \n-    impl ToSource for ast::Ident {\n-        fn to_source(&self) -> String {\n-            token::get_ident(*self).get().to_string()\n-        }\n-    }\n-\n-    impl ToSource for Gc<ast::Item> {\n-        fn to_source(&self) -> String {\n-            pprust::item_to_str(&**self)\n-        }\n-    }\n-\n-    impl<'a> ToSource for &'a [Gc<ast::Item>] {\n-        fn to_source(&self) -> String {\n-            self.iter()\n-                .map(|i| i.to_source())\n-                .collect::<Vec<String>>()\n-                .connect(\"\\n\\n\")\n-                .to_string()\n-        }\n-    }\n-\n-    impl ToSource for ast::Ty {\n-        fn to_source(&self) -> String {\n-            pprust::ty_to_str(self)\n-        }\n-    }\n-\n-    impl<'a> ToSource for &'a [ast::Ty] {\n-        fn to_source(&self) -> String {\n-            self.iter()\n-                .map(|i| i.to_source())\n-                .collect::<Vec<String>>()\n-                .connect(\", \")\n-                .to_string()\n-        }\n-    }\n+    macro_rules! impl_to_source(\n+        (Gc<$t:ty>, $pp:ident) => (\n+            impl ToSource for Gc<$t> {\n+                fn to_source(&self) -> String {\n+                    pprust::$pp(&**self)\n+                }\n+            }\n+        );\n+        ($t:ty, $pp:ident) => (\n+            impl ToSource for $t {\n+                fn to_source(&self) -> String {\n+                    pprust::$pp(self)\n+                }\n+            }\n+        );\n+    )\n \n-    impl ToSource for Generics {\n-        fn to_source(&self) -> String {\n-            pprust::generics_to_str(self)\n-        }\n+    fn slice_to_source<'a, T: ToSource>(sep: &'static str, xs: &'a [T]) -> String {\n+        xs.iter()\n+            .map(|i| i.to_source())\n+            .collect::<Vec<String>>()\n+            .connect(sep)\n+            .to_string()\n     }\n \n-    impl ToSource for Gc<ast::Expr> {\n-        fn to_source(&self) -> String {\n-            pprust::expr_to_str(&**self)\n-        }\n-    }\n+    macro_rules! impl_to_source_slice(\n+        ($t:ty, $sep:expr) => (\n+            impl<'a> ToSource for &'a [$t] {\n+                fn to_source(&self) -> String {\n+                    slice_to_source($sep, *self)\n+                }\n+            }\n+        )\n+    )\n \n-    impl ToSource for ast::Block {\n+    impl ToSource for ast::Ident {\n         fn to_source(&self) -> String {\n-            pprust::block_to_str(self)\n+            token::get_ident(*self).get().to_string()\n         }\n     }\n \n-    impl ToSource for ast::Arg {\n-        fn to_source(&self) -> String {\n-            pprust::arg_to_str(self)\n-        }\n-    }\n+    impl_to_source!(ast::Ty, ty_to_str)\n+    impl_to_source!(ast::Block, block_to_str)\n+    impl_to_source!(ast::Arg, arg_to_str)\n+    impl_to_source!(Generics, generics_to_str)\n+    impl_to_source!(Gc<ast::Item>, item_to_str)\n+    impl_to_source!(Gc<ast::Expr>, expr_to_str)\n+    impl_to_source_slice!(ast::Ty, \", \")\n+    impl_to_source_slice!(Gc<ast::Item>, \"\\n\\n\")\n \n     impl<'a> ToSource for &'a str {\n         fn to_source(&self) -> String {\n@@ -163,76 +152,36 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for int {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n-\n-    impl ToSource for i8 {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI8));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n-\n-    impl ToSource for i16 {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI16));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n-\n-\n-    impl ToSource for i32 {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI32));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n-\n-    impl ToSource for i64 {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI64));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n-\n-    impl ToSource for uint {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n-\n-    impl ToSource for u8 {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU8));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n-\n-    impl ToSource for u16 {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU16));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n+    macro_rules! impl_to_source_int(\n+        (signed, $t:ty, $tag:ident) => (\n+            impl ToSource for $t {\n+                fn to_source(&self) -> String {\n+                    let lit = dummy_spanned(ast::LitInt(*self as i64, ast::$tag));\n+                    pprust::lit_to_str(&lit)\n+                }\n+            }\n+        );\n+        (unsigned, $t:ty, $tag:ident) => (\n+            impl ToSource for $t {\n+                fn to_source(&self) -> String {\n+                    let lit = dummy_spanned(ast::LitUint(*self as u64, ast::$tag));\n+                    pprust::lit_to_str(&lit)\n+                }\n+            }\n+        );\n+    )\n \n-    impl ToSource for u32 {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU32));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n+    impl_to_source_int!(signed, int, TyI)\n+    impl_to_source_int!(signed, i8,  TyI8)\n+    impl_to_source_int!(signed, i16, TyI16)\n+    impl_to_source_int!(signed, i32, TyI32)\n+    impl_to_source_int!(signed, i64, TyI64)\n \n-    impl ToSource for u64 {\n-        fn to_source(&self) -> String {\n-            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU64));\n-            pprust::lit_to_str(&lit)\n-        }\n-    }\n+    impl_to_source_int!(unsigned, uint, TyU)\n+    impl_to_source_int!(unsigned, u8,   TyU8)\n+    impl_to_source_int!(unsigned, u16,  TyU16)\n+    impl_to_source_int!(unsigned, u32,  TyU32)\n+    impl_to_source_int!(unsigned, u64,  TyU64)\n \n     // Alas ... we write these out instead. All redundant.\n \n@@ -246,7 +195,7 @@ pub mod rt {\n         )\n     )\n \n-    macro_rules! impl_to_tokens_self(\n+    macro_rules! impl_to_tokens_lifetime(\n         ($t:ty) => (\n             impl<'a> ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n@@ -258,14 +207,14 @@ pub mod rt {\n \n     impl_to_tokens!(ast::Ident)\n     impl_to_tokens!(Gc<ast::Item>)\n-    impl_to_tokens_self!(&'a [Gc<ast::Item>])\n+    impl_to_tokens_lifetime!(&'a [Gc<ast::Item>])\n     impl_to_tokens!(ast::Ty)\n-    impl_to_tokens_self!(&'a [ast::Ty])\n+    impl_to_tokens_lifetime!(&'a [ast::Ty])\n     impl_to_tokens!(Generics)\n     impl_to_tokens!(Gc<ast::Expr>)\n     impl_to_tokens!(ast::Block)\n     impl_to_tokens!(ast::Arg)\n-    impl_to_tokens_self!(&'a str)\n+    impl_to_tokens_lifetime!(&'a str)\n     impl_to_tokens!(())\n     impl_to_tokens!(char)\n     impl_to_tokens!(bool)"}]}