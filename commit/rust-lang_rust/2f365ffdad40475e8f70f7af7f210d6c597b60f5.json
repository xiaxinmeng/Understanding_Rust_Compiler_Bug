{"sha": "2f365ffdad40475e8f70f7af7f210d6c597b60f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMzY1ZmZkYWQ0MDQ3NWU4ZjcwZjdhZjdmMjEwZDZjNTk3YjYwZjU=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-02T18:47:38Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-02T18:47:38Z"}, "message": "Revert \"Review and rebasing changes\"\n\nThis reverts commit 6e0611a48707a1f5d90aee32a02b2b15957ef25b.", "tree": {"sha": "51154f8a256deb911f52558b4355fcb68bf2ea4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51154f8a256deb911f52558b4355fcb68bf2ea4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f365ffdad40475e8f70f7af7f210d6c597b60f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f365ffdad40475e8f70f7af7f210d6c597b60f5", "html_url": "https://github.com/rust-lang/rust/commit/2f365ffdad40475e8f70f7af7f210d6c597b60f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f365ffdad40475e8f70f7af7f210d6c597b60f5/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2d4eb186e99b66051be9089f836c66a558dd995", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d4eb186e99b66051be9089f836c66a558dd995", "html_url": "https://github.com/rust-lang/rust/commit/b2d4eb186e99b66051be9089f836c66a558dd995"}], "stats": {"total": 145, "additions": 42, "deletions": 103}, "files": [{"sha": "60692ceb401bccccf8b45179bd790ed51c7086ad", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=2f365ffdad40475e8f70f7af7f210d6c597b60f5", "patch": "@@ -44,8 +44,7 @@\n //!\n //! A number of traits add methods that allow you to accomplish tasks with slices.\n //! These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n-//! `MutableSlice`, defined for `&mut [T]` types, and `Slice` and `SliceMut`\n-//! which are defined for `[T]`.\n+//! and `MutableSlice`, defined for `&mut [T]` types.\n //!\n //! An example is the `slice` method which enables slicing syntax `[a..b]` that\n //! returns an immutable \"view\" into a `Vec` or another slice from the index"}, {"sha": "206e392f6644b8af244db3b4adad2d5fe7019f9e", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=2f365ffdad40475e8f70f7af7f210d6c597b60f5", "patch": "@@ -927,7 +927,6 @@ impl<S: Str> Add<S, String> for String {\n     }\n }\n \n-#[cfg(stage0)]\n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -950,34 +949,6 @@ impl ops::Slice<uint, str> for String {\n     }\n }\n \n-#[cfg(not(stage0))]\n-#[inline]\n-fn str_to_slice<'a, U: Str>(this: &'a U) -> &'a str {\n-    this.as_slice()\n-}\n-#[cfg(not(stage0))]\n-impl ops::Slice<uint, str> for String {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str {\n-        str_to_slice(self)\n-    }\n-\n-    #[inline]\n-    fn slice_from<'a>(&'a self, from: &uint) -> &'a str {\n-        self[][*from..]\n-    }\n-\n-    #[inline]\n-    fn slice_to<'a>(&'a self, to: &uint) -> &'a str {\n-        self[][..*to]\n-    }\n-\n-    #[inline]\n-    fn slice<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-        self[][*from..*to]\n-    }\n-}\n-\n /// Unsafe operations\n #[unstable = \"waiting on raw module conventions\"]\n pub mod raw {"}, {"sha": "f9bc5ac743c58f21ea592772b24d62a1b455d9d7", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=2f365ffdad40475e8f70f7af7f210d6c597b60f5", "patch": "@@ -463,7 +463,6 @@ impl<T> Index<uint,T> for Vec<T> {\n \n // Annoying helper function because there are two Slice::as_slice functions in\n // scope.\n-#[cfg(not(stage0))]\n #[inline]\n fn slice_to_slice<'a, T, U: Slice<T>>(this: &'a U) -> &'a [T] {\n     this.as_slice()\n@@ -985,6 +984,7 @@ impl<T> Vec<T> {\n     /// assert!(vec[0..2] == [1, 2]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n         self[start..end]\n     }\n@@ -1020,7 +1020,7 @@ impl<T> Vec<T> {\n     /// assert!(vec.tailn(2) == [3, 4]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slice_from\"]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n         self[n..]\n     }\n@@ -1230,7 +1230,7 @@ impl<T> Vec<T> {\n     }\n \n     /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_from\"]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n         self[mut start..end]\n@@ -1250,13 +1250,14 @@ impl<T> Vec<T> {\n     /// assert!(vec[mut 0..2] == [1, 2]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_mut<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n         self[mut start..end]\n     }\n \n     /// Deprecated: use \"slice_from_mut\".\n-    #[deprecated = \"use slice_from_mut\"]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n         self[mut start..]\n     }\n@@ -1274,12 +1275,13 @@ impl<T> Vec<T> {\n     /// assert!(vec[mut 2..] == [3, 4]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n         self[mut start..]\n     }\n \n     /// Deprecated: use `slice_to_mut`.\n-    #[deprecated = \"use slice_to_mut\"]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n         self[mut ..end]\n     }\n@@ -1297,6 +1299,7 @@ impl<T> Vec<T> {\n     /// assert!(vec[mut ..2] == [1, 2]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n         self[mut ..end]\n     }\n@@ -1373,6 +1376,7 @@ impl<T> Vec<T> {\n     /// assert!(vec[1..] == [2, 3]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n         self[start..]\n     }\n@@ -1390,6 +1394,7 @@ impl<T> Vec<T> {\n     /// assert!(vec[..2] == [1, 2]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n         self[..end]\n     }"}, {"sha": "2ff0fd2ef004e90736f1fc8ba1f11b8cdc979ba1", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=2f365ffdad40475e8f70f7af7f210d6c597b60f5", "patch": "@@ -152,7 +152,7 @@ pub trait ImmutableSlice<'a, T> {\n     fn tail(&self) -> &'a [T];\n \n     /// Returns all but the first `n' elements of a slice.\n-    #[deprecated = \"use slice_from\"]\n+    #[deprecated = \"use slicing syntax\"]\n     fn tailn(&self, n: uint) -> &'a [T];\n \n     /// Returns all but the last element of a slice.\n@@ -161,6 +161,7 @@ pub trait ImmutableSlice<'a, T> {\n \n     /// Returns all but the last `n' elements of a slice.\n     #[deprecated = \"use slice_to but note the arguments are different\"]\n+    #[deprecated = \"use slicing syntax, but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n@@ -320,7 +321,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     fn tail(&self) -> &'a [T] { (*self)[1..] }\n \n     #[inline]\n-    #[deprecated = \"use slice_from\"]\n+    #[deprecated = \"use slicing syntax\"]\n     fn tailn(&self, n: uint) -> &'a [T] { (*self)[n..] }\n \n     #[inline]\n@@ -329,7 +330,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    #[deprecated = \"use slice_to but note the arguments are different\"]\n+    #[deprecated = \"use slicing syntax but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T] {\n         (*self)[..self.len() - n]\n     }\n@@ -542,6 +543,7 @@ pub trait MutableSlice<'a, T> {\n     fn get_mut(self, index: uint) -> Option<&'a mut T>;\n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    #[deprecated = \"use slicing syntax\"]\n     fn as_mut_slice(self) -> &'a mut [T];\n \n     /// Deprecated: use `iter_mut`."}, {"sha": "f3a10a0a3ae908edd663a5f8bdf513749cbf3abc", "filename": "src/libcore/str.rs", "status": "modified", "additions": 23, "deletions": 61, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2f365ffdad40475e8f70f7af7f210d6c597b60f5", "patch": "@@ -1164,7 +1164,6 @@ pub mod traits {\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n-    #[cfg(stage0)]\n     impl ops::Slice<uint, str> for str {\n         #[inline]\n         fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -1173,39 +1172,17 @@ pub mod traits {\n \n         #[inline]\n         fn slice_from_<'a>(&'a self, from: &uint) -> &'a str {\n-            super::slice_from_impl(&self, *from)\n+            self.slice_from(*from)\n         }\n \n         #[inline]\n         fn slice_to_<'a>(&'a self, to: &uint) -> &'a str {\n-            super::slice_to_impl(&self, *to)\n+            self.slice_to(*to)\n         }\n \n         #[inline]\n         fn slice_<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-            super::slice_impl(&self, *from, *to)\n-        }\n-    }\n-    #[cfg(not(stage0))]\n-    impl ops::Slice<uint, str> for str {\n-        #[inline]\n-        fn as_slice<'a>(&'a self) -> &'a str {\n-            self\n-        }\n-\n-        #[inline]\n-        fn slice_from<'a>(&'a self, from: &uint) -> &'a str {\n-            super::slice_from_impl(&self, *from)\n-        }\n-\n-        #[inline]\n-        fn slice_to<'a>(&'a self, to: &uint) -> &'a str {\n-            super::slice_to_impl(&self, *to)\n-        }\n-\n-        #[inline]\n-        fn slice<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-            super::slice_impl(&self, *from, *to)\n+            self.slice(*from, *to)\n         }\n     }\n }\n@@ -1858,38 +1835,6 @@ fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n           begin, end, s);\n }\n \n-#[inline]\n-fn slice_impl<'a>(this: &&'a str, begin: uint, end: uint) -> &'a str {\n-    // is_char_boundary checks that the index is in [0, .len()]\n-    if begin <= end &&\n-       this.is_char_boundary(begin) &&\n-       this.is_char_boundary(end) {\n-        unsafe { raw::slice_unchecked(*this, begin, end) }\n-    } else {\n-        slice_error_fail(*this, begin, end)\n-    }\n-}\n-\n-#[inline]\n-fn slice_from_impl<'a>(this: &&'a str, begin: uint) -> &'a str {\n-    // is_char_boundary checks that the index is in [0, .len()]\n-    if this.is_char_boundary(begin) {\n-        unsafe { raw::slice_unchecked(*this, begin, this.len()) }\n-    } else {\n-        slice_error_fail(*this, begin, this.len())\n-    }\n-}\n-\n-#[inline]\n-fn slice_to_impl<'a>(this: &&'a str, end: uint) -> &'a str {\n-    // is_char_boundary checks that the index is in [0, .len()]\n-    if this.is_char_boundary(end) {\n-        unsafe { raw::slice_unchecked(*this, 0, end) }\n-    } else {\n-        slice_error_fail(*this, 0, end)\n-    }\n-}\n-\n impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn contains<'a>(&self, needle: &'a str) -> bool {\n@@ -1993,17 +1938,34 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'a str {\n-        slice_impl(self, begin, end)\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if begin <= end &&\n+           self.is_char_boundary(begin) &&\n+           self.is_char_boundary(end) {\n+            unsafe { raw::slice_unchecked(*self, begin, end) }\n+        } else {\n+            slice_error_fail(*self, begin, end)\n+        }\n     }\n \n     #[inline]\n     fn slice_from(&self, begin: uint) -> &'a str {\n-        slice_from_impl(self, begin)\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(begin) {\n+            unsafe { raw::slice_unchecked(*self, begin, self.len()) }\n+        } else {\n+            slice_error_fail(*self, begin, self.len())\n+        }\n     }\n \n     #[inline]\n     fn slice_to(&self, end: uint) -> &'a str {\n-        slice_to_impl(self, end)\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(end) {\n+            unsafe { raw::slice_unchecked(*self, 0, end) }\n+        } else {\n+            slice_error_fail(*self, 0, end)\n+        }\n     }\n \n     fn slice_chars(&self, begin: uint, end: uint) -> &'a str {"}, {"sha": "2de9cd9a41c4b9a5fac2d341c46cd0ee8aaa35c6", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=2f365ffdad40475e8f70f7af7f210d6c597b60f5", "patch": "@@ -448,7 +448,7 @@ impl rtio::RtioPipe for UnixStream {\n             }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n-                                buf[offset..].as_ptr() as libc::LPVOID,\n+                                buf.slice_from(offset).as_ptr() as libc::LPVOID,\n                                 (buf.len() - offset) as libc::DWORD,\n                                 &mut bytes_written,\n                                 &mut overlapped)"}, {"sha": "d904e657e403b082e61110c71af92c7b60732ca6", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=2f365ffdad40475e8f70f7af7f210d6c597b60f5", "patch": "@@ -144,7 +144,7 @@ pub mod windows {\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n-    use slice::MutableSlice;\n+    use slice::{MutableSlice, ImmutableSlice};\n     use string::String;\n     use str::StrSlice;\n     use vec::Vec;"}, {"sha": "33f8713e1a13c9f61fa67856ec89997f4f268cd6", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f365ffdad40475e8f70f7af7f210d6c597b60f5/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=2f365ffdad40475e8f70f7af7f210d6c597b60f5", "patch": "@@ -999,7 +999,7 @@ mod imp {\n                 let bytes = cstr.as_bytes();\n                 match cstr.as_str() {\n                     Some(s) => try!(super::demangle(w, s)),\n-                    None => try!(w.write(bytes[..bytes.len()-1])),\n+                    None => try!(w.write(bytes.slice_to(bytes.len() - 1))),\n                 }\n             }\n             try!(w.write(['\\n' as u8]));"}]}