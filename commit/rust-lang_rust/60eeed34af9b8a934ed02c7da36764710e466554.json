{"sha": "60eeed34af9b8a934ed02c7da36764710e466554", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZWVlZDM0YWY5YjhhOTM0ZWQwMmM3ZGEzNjc2NDcxMGU0NjY1NTQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-01-17T20:03:58Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-03-01T18:53:14Z"}, "message": "Include bounds from promoted constants in NLL\n\nPreviously, a promoted that contains a function item wouldn't have the\nfunction items bounds propagated to\nthe main function body.", "tree": {"sha": "f367b77c18a7362b955bceda4f1794d9a4216128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f367b77c18a7362b955bceda4f1794d9a4216128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60eeed34af9b8a934ed02c7da36764710e466554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60eeed34af9b8a934ed02c7da36764710e466554", "html_url": "https://github.com/rust-lang/rust/commit/60eeed34af9b8a934ed02c7da36764710e466554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60eeed34af9b8a934ed02c7da36764710e466554/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1d2d83ca3b5155468ab96b09a7c54568449b137", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d2d83ca3b5155468ab96b09a7c54568449b137", "html_url": "https://github.com/rust-lang/rust/commit/c1d2d83ca3b5155468ab96b09a7c54568449b137"}], "stats": {"total": 207, "additions": 185, "deletions": 22}, "files": [{"sha": "c4491778162f43ff66a6b258da102dc7105687ba", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60eeed34af9b8a934ed02c7da36764710e466554/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60eeed34af9b8a934ed02c7da36764710e466554/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=60eeed34af9b8a934ed02c7da36764710e466554", "patch": "@@ -154,10 +154,10 @@ impl<N: Idx> LivenessValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    crate fn new(elements: &Rc<RegionValueElements>) -> Self {\n+    crate fn new(elements: Rc<RegionValueElements>) -> Self {\n         Self {\n-            elements: elements.clone(),\n             points: SparseBitMatrix::new(elements.num_points),\n+            elements: elements,\n         }\n     }\n "}, {"sha": "0a0a88e694260c19dfa6ec995913d99e0fb10717", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60eeed34af9b8a934ed02c7da36764710e466554/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60eeed34af9b8a934ed02c7da36764710e466554/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=60eeed34af9b8a934ed02c7da36764710e466554", "patch": "@@ -47,6 +47,14 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n+    fn visit_mir(&mut self, mir: &mut Mir<'tcx>) {\n+        for promoted in mir.promoted.iter_mut() {\n+            self.visit_mir(promoted);\n+        }\n+\n+        self.super_mir(mir);\n+    }\n+\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n         debug!(\"visit_ty(ty={:?}, ty_context={:?})\", ty, ty_context);\n "}, {"sha": "4929c69d873b481eed5ce5e99e5a6147ee4b26a4", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 97, "deletions": 17, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/60eeed34af9b8a934ed02c7da36764710e466554/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60eeed34af9b8a934ed02c7da36764710e466554/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=60eeed34af9b8a934ed02c7da36764710e466554", "patch": "@@ -45,7 +45,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::ty::layout::VariantIdx;\n use std::rc::Rc;\n-use std::{fmt, iter};\n+use std::{fmt, iter, mem};\n use syntax_pos::{Span, DUMMY_SP};\n \n macro_rules! span_mirbug {\n@@ -124,7 +124,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     let mut constraints = MirTypeckRegionConstraints {\n         placeholder_indices: PlaceholderIndices::default(),\n         placeholder_index_to_region: IndexVec::default(),\n-        liveness_constraints: LivenessValues::new(elements),\n+        liveness_constraints: LivenessValues::new(elements.clone()),\n         outlives_constraints: ConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n@@ -253,7 +253,7 @@ enum FieldAccessError {\n /// is a problem.\n struct TypeVerifier<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'b Mir<'tcx>,\n     last_span: Span,\n     mir_def_id: DefId,\n     errors_reported: bool,\n@@ -385,7 +385,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n }\n \n impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n-    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'b Mir<'tcx>) -> Self {\n         TypeVerifier {\n             mir,\n             mir_def_id: cx.mir_def_id,\n@@ -454,19 +454,31 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n                 ty: self.mir.local_decls[index].ty,\n             },\n-            Place::Base(PlaceBase::Promoted(box (_index, sty))) => {\n+            Place::Base(PlaceBase::Promoted(box (index, sty))) => {\n                 let sty = self.sanitize_type(place, sty);\n-                // FIXME -- promoted MIR return types reference\n-                // various \"free regions\" (e.g., scopes and things)\n-                // that they ought not to do. We have to figure out\n-                // how best to handle that -- probably we want treat\n-                // promoted MIR much like closures, renumbering all\n-                // their free regions and propagating constraints\n-                // upwards. We have the same acyclic guarantees, so\n-                // that should be possible. But for now, ignore them.\n-                //\n-                // let promoted_mir = &self.mir.promoted[index];\n-                // promoted_mir.return_ty()\n+\n+                if !self.errors_reported {\n+                    let promoted_mir = &self.mir.promoted[index];\n+                    self.sanitize_promoted(promoted_mir, location);\n+\n+                    let promoted_ty = promoted_mir.return_ty();\n+\n+                    if let Err(terr) = self.cx.eq_types(\n+                        sty,\n+                        promoted_ty,\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring,\n+                    ) {\n+                        span_mirbug!(\n+                            self,\n+                            place,\n+                            \"bad promoted type ({:?}: {:?}): {:?}\",\n+                            promoted_ty,\n+                            sty,\n+                            terr\n+                        );\n+                    };\n+                }\n                 PlaceTy::Ty { ty: sty }\n             }\n             Place::Base(PlaceBase::Static(box Static { def_id, ty: sty })) => {\n@@ -533,6 +545,74 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         place_ty\n     }\n \n+    fn sanitize_promoted(&mut self, promoted_mir: &'b Mir<'tcx>, location: Location) {\n+        // Determine the constraints from the promoted MIR by running the type\n+        // checker on the promoted MIR, then transfer the constraints back to\n+        // the main MIR, changing the locations to the provided location.\n+\n+        let main_mir = mem::replace(&mut self.mir, promoted_mir);\n+        self.cx.mir = promoted_mir;\n+\n+        let all_facts = &mut None;\n+        let mut constraints = Default::default();\n+        let mut closure_bounds = Default::default();\n+        if let Some(ref mut bcx) = self.cx.borrowck_context {\n+            // Don't try to add borrow_region facts for the promoted MIR\n+            mem::swap(bcx.all_facts, all_facts);\n+\n+            // Use a new sets of constraints and closure bounds so that we can\n+            // modify their locations.\n+            mem::swap(&mut bcx.constraints.outlives_constraints, &mut constraints);\n+            mem::swap(&mut bcx.constraints.closure_bounds_mapping, &mut closure_bounds);\n+        };\n+\n+        self.visit_mir(promoted_mir);\n+\n+        if !self.errors_reported {\n+            // if verifier failed, don't do further checks to avoid ICEs\n+            self.cx.typeck_mir(promoted_mir);\n+        }\n+\n+        self.mir = main_mir;\n+        self.cx.mir = main_mir;\n+        // Merge the outlives constraints back in, at the given location.\n+        if let Some(ref mut base_bcx) = self.cx.borrowck_context {\n+            mem::swap(base_bcx.all_facts, all_facts);\n+            mem::swap(&mut base_bcx.constraints.outlives_constraints, &mut constraints);\n+            mem::swap(&mut base_bcx.constraints.closure_bounds_mapping, &mut closure_bounds);\n+\n+            let locations = location.to_locations();\n+            for constraint in constraints.iter() {\n+                let mut constraint = *constraint;\n+                constraint.locations = locations;\n+                if let ConstraintCategory::Return\n+                    | ConstraintCategory::UseAsConst\n+                    | ConstraintCategory::UseAsStatic = constraint.category\n+                {\n+                    // \"Returning\" from a promoted is an assigment to a\n+                    // temporary from the user's point of view.\n+                    constraint.category = ConstraintCategory::Boring;\n+                }\n+                base_bcx.constraints.outlives_constraints.push(constraint)\n+            }\n+\n+            if !closure_bounds.is_empty() {\n+                let combined_bounds_mapping = closure_bounds\n+                    .into_iter()\n+                    .flat_map(|(_, value)| value)\n+                    .collect();\n+                let existing = base_bcx\n+                    .constraints\n+                    .closure_bounds_mapping\n+                    .insert(location, combined_bounds_mapping);\n+                assert!(\n+                    existing.is_none(),\n+                    \"Multiple promoteds/closures at the same location.\"\n+                );\n+            }\n+        }\n+    }\n+\n     fn sanitize_projection(\n         &mut self,\n         base: PlaceTy<'tcx>,\n@@ -2275,7 +2355,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     ) -> ty::InstantiatedPredicates<'tcx> {\n         if let Some(closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n             let closure_constraints =\n-                closure_region_requirements.apply_requirements(tcx, location, def_id, substs);\n+                closure_region_requirements.apply_requirements(tcx, def_id, substs);\n \n             if let Some(ref mut borrowck_context) = self.borrowck_context {\n                 let bounds_mapping = closure_constraints"}, {"sha": "ececd6fccd84bc75dedc371a24f1e7ca864eff3a", "filename": "src/test/ui/nll/issue-48697.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fissue-48697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fissue-48697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-48697.rs?ref=60eeed34af9b8a934ed02c7da36764710e466554", "patch": "@@ -1,14 +1,12 @@\n // Regression test for #48697\n \n-// compile-pass\n-\n #![feature(nll)]\n \n fn foo(x: &i32) -> &i32 {\n     let z = 4;\n     let f = &|y| y;\n     let k = f(&z);\n-    f(x)\n+    f(x) //~ cannot return value referencing local variable\n }\n \n fn main() {}"}, {"sha": "16b46c15b90b61ff9bba2cc268a59c8dec2de249", "filename": "src/test/ui/nll/issue-48697.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fissue-48697.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fissue-48697.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-48697.stderr?ref=60eeed34af9b8a934ed02c7da36764710e466554", "patch": "@@ -0,0 +1,11 @@\n+error[E0515]: cannot return value referencing local variable `z`\n+  --> $DIR/issue-48697.rs:9:5\n+   |\n+LL |     let k = f(&z);\n+   |               -- `z` is borrowed here\n+LL |     f(x) //~ cannot return value referencing local variable\n+   |     ^^^^ returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "59b21cf9ac2a9c9cab61ebf11351e0077e3932e8", "filename": "src/test/ui/nll/promoted-bounds.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.rs?ref=60eeed34af9b8a934ed02c7da36764710e466554", "patch": "@@ -0,0 +1,27 @@\n+#![feature(nll)]\n+\n+fn shorten_lifetime<'a, 'b, 'min>(a: &'a i32, b: &'b i32) -> &'min i32\n+where\n+    'a: 'min,\n+    'b: 'min,\n+{\n+    if *a < *b {\n+        &a\n+    } else {\n+        &b\n+    }\n+}\n+\n+fn main() {\n+    let promoted_fn_item_ref = &shorten_lifetime;\n+\n+    let a = &5;\n+    let ptr = {\n+        let l = 3;\n+        let b = &l; //~ ERROR does not live long enough\n+        let c = promoted_fn_item_ref(a, b);\n+        c\n+    };\n+\n+    println!(\"ptr = {:?}\", ptr);\n+}"}, {"sha": "9798f238fc4d01290dae78ea50dd903e4d3bbb71", "filename": "src/test/ui/nll/promoted-bounds.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-bounds.stderr?ref=60eeed34af9b8a934ed02c7da36764710e466554", "patch": "@@ -0,0 +1,15 @@\n+error[E0597]: `l` does not live long enough\n+  --> $DIR/promoted-bounds.rs:21:17\n+   |\n+LL |     let ptr = {\n+   |         --- borrow later stored here\n+LL |         let l = 3;\n+LL |         let b = &l; //~ ERROR does not live long enough\n+   |                 ^^ borrowed value does not live long enough\n+...\n+LL |     };\n+   |     - `l` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "7b3bbad4c1e0c5e8113e72f9afdf3436228851a5", "filename": "src/test/ui/nll/promoted-closure-pair.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.rs?ref=60eeed34af9b8a934ed02c7da36764710e466554", "patch": "@@ -0,0 +1,12 @@\n+// Check that we handle multiple closures in the same promoted constant.\n+\n+#![feature(nll)]\n+\n+fn foo() -> &'static i32 {\n+    let z = 0;\n+    let p = &(|y| y, |y| y);\n+    p.0(&z);\n+    p.1(&z)         //~ ERROR cannot return\n+}\n+\n+fn main() {}"}, {"sha": "5f4a6037668b5abee869053a78e9c0e4b0b38340", "filename": "src/test/ui/nll/promoted-closure-pair.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60eeed34af9b8a934ed02c7da36764710e466554/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-closure-pair.stderr?ref=60eeed34af9b8a934ed02c7da36764710e466554", "patch": "@@ -0,0 +1,12 @@\n+error[E0515]: cannot return value referencing local variable `z`\n+  --> $DIR/promoted-closure-pair.rs:9:5\n+   |\n+LL |     p.1(&z)         //~ ERROR cannot return\n+   |     ^^^^--^\n+   |     |   |\n+   |     |   `z` is borrowed here\n+   |     returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}]}