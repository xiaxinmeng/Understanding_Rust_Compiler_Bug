{"sha": "e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyN2YyN2M4NTg4ZjVjZmEwY2Q5ZGZiYmRmNzYwOWVhMmQ2ODE4ZWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-26T03:47:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-08T06:27:01Z"}, "message": "std: Add I/O timeouts to networking objects\n\nThese timeouts all follow the same pattern as established by the timeouts on\nacceptors. There are three methods: set_timeout, set_read_timeout, and\nset_write_timeout. Each of these sets a point in the future after which\noperations will time out.\n\nTimeouts with cloned objects are a little trickier. Each object is viewed as\nhaving its own timeout, unaffected by other objects' timeouts. Additionally,\ntimeouts do not propagate when a stream is cloned or when a cloned stream has\nits timeouts modified.\n\nThis commit is just the public interface which will be exposed for timeouts, the\nimplementation will come in later commits.", "tree": {"sha": "25f32daa865ea84163e5f6681f15e876ffb74305", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25f32daa865ea84163e5f6681f15e876ffb74305"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "html_url": "https://github.com/rust-lang/rust/commit/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0fcb4eb3d516017c7c2fa8d17e7b8b82bdc065b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0fcb4eb3d516017c7c2fa8d17e7b8b82bdc065b", "html_url": "https://github.com/rust-lang/rust/commit/e0fcb4eb3d516017c7c2fa8d17e7b8b82bdc065b"}], "stats": {"total": 434, "additions": 419, "deletions": 15}, "files": [{"sha": "ea3e0219a5bbc5e7f6311d760d8bb917c2b84342", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "patch": "@@ -434,6 +434,17 @@ pub enum IoErrorKind {\n     InvalidInput,\n     /// The I/O operation's timeout expired, causing it to be canceled.\n     TimedOut,\n+    /// This write operation failed to write all of its data.\n+    ///\n+    /// Normally the write() method on a Writer guarantees that all of its data\n+    /// has been written, but some operations may be terminated after only\n+    /// partially writing some data. An example of this is a timed out write\n+    /// which successfully wrote a known number of bytes, but bailed out after\n+    /// doing so.\n+    ///\n+    /// The payload contained as part of this variant is the number of bytes\n+    /// which are known to have been successfully written.\n+    ShortWrite(uint),\n }\n \n /// A trait for objects which are byte-oriented streams. Readers are defined by\n@@ -1429,7 +1440,8 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n         PathDoesntExist => \"no such file\",\n         MismatchedFileTypeForOperation => \"mismatched file type\",\n         ResourceUnavailable => \"resource unavailable\",\n-        TimedOut => \"operation timed out\"\n+        TimedOut => \"operation timed out\",\n+        ShortWrite(..) => \"short write\",\n     };\n     IoError {\n         kind: kind,"}, {"sha": "89141155ae4caef1d0094232e15d73b9f8bf0aa5", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "patch": "@@ -151,6 +151,69 @@ impl TcpStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n+\n+    /// Sets a timeout, in milliseconds, for blocking operations on this stream.\n+    ///\n+    /// This function will set a timeout for all blocking operations (including\n+    /// reads and writes) on this stream. The timeout specified is a relative\n+    /// time, in milliseconds, into the future after which point operations will\n+    /// time out. This means that the timeout must be reset periodically to keep\n+    /// it from expiring. Specifying a value of `None` will clear the timeout\n+    /// for this stream.\n+    ///\n+    /// The timeout on this stream is local to this stream only. Setting a\n+    /// timeout does not affect any other cloned instances of this stream, nor\n+    /// does the timeout propagated to cloned handles of this stream. Setting\n+    /// this timeout will override any specific read or write timeouts\n+    /// previously set for this stream.\n+    ///\n+    /// For clarification on the semantics of interrupting a read and a write,\n+    /// take a look at `set_read_timeout` and `set_write_timeout`.\n+    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the timeout for read operations on this stream.\n+    ///\n+    /// See documentation in `set_timeout` for the semantics of this read time.\n+    /// This will overwrite any previous read timeout set through either this\n+    /// function or `set_timeout`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// When this timeout expires, if there is no pending read operation, no\n+    /// action is taken. Otherwise, the read operation will be scheduled to\n+    /// promptly return. If a timeout error is returned, then no data was read\n+    /// during the timeout period.\n+    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_read_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the timeout for write operations on this stream.\n+    ///\n+    /// See documentation in `set_timeout` for the semantics of this write time.\n+    /// This will overwrite any previous write timeout set through either this\n+    /// function or `set_timeout`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// When this timeout expires, if there is no pending write operation, no\n+    /// action is taken. Otherwise, the pending write operation will be\n+    /// scheduled to promptly return. The actual state of the underlying stream\n+    /// is not specified.\n+    ///\n+    /// The write operation may return an error of type `ShortWrite` which\n+    /// indicates that the object is known to have written an exact number of\n+    /// bytes successfully during the timeout period, and the remaining bytes\n+    /// were never written.\n+    ///\n+    /// If the write operation returns `TimedOut`, then it the timeout primitive\n+    /// does not know how many bytes were written as part of the timeout\n+    /// operation. It may be the case that bytes continue to be written in an\n+    /// asynchronous fashion after the call to write returns.\n+    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_write_timeout(timeout_ms)\n+    }\n }\n \n impl Clone for TcpStream {\n@@ -892,6 +955,7 @@ mod test {\n                 Err(ref e) if e.kind == TimedOut => {}\n                 Err(e) => fail!(\"error: {}\", e),\n             }\n+            ::task::deschedule();\n             if i == 1000 { fail!(\"should have a pending connection\") }\n         }\n         drop(l);\n@@ -964,4 +1028,118 @@ mod test {\n         // this test will never finish if the child doesn't wake up\n         rx.recv();\n     })\n+\n+    iotest!(fn readwrite_timeouts() {\n+        let addr = next_test_ip6();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+\n+        s.set_timeout(Some(20));\n+        for i in range(0, 1001) {\n+            match s.write([0, .. 128 * 1024]) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"{}\", e),\n+           }\n+           if i == 1000 { fail!(\"should have filled up?!\"); }\n+        }\n+        assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n+\n+        tx.send(());\n+        s.set_timeout(None);\n+        assert_eq!(s.read([0, 0]), Ok(1));\n+    })\n+\n+    iotest!(fn read_timeouts() {\n+        let addr = next_test_ip6();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr).unwrap();\n+            rx.recv();\n+            let mut amt = 0;\n+            while amt < 100 * 128 * 1024 {\n+                match s.read([0, ..128 * 1024]) {\n+                    Ok(n) => { amt += n; }\n+                    Err(e) => fail!(\"{}\", e),\n+                }\n+            }\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_read_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+\n+        tx.send(());\n+        for _ in range(0, 100) {\n+            assert!(s.write([0, ..128 * 1024]).is_ok());\n+        }\n+    })\n+\n+    iotest!(fn write_timeouts() {\n+        let addr = next_test_ip6();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_write_timeout(Some(20));\n+        for i in range(0, 1001) {\n+            match s.write([0, .. 128 * 1024]) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"{}\", e),\n+           }\n+           if i == 1000 { fail!(\"should have filled up?!\"); }\n+        }\n+        assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n+\n+        tx.send(());\n+        assert!(s.read([0]).is_ok());\n+    })\n+\n+    iotest!(fn timeout_concurrent_read() {\n+        let addr = next_test_ip6();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr).unwrap();\n+            rx.recv();\n+            assert_eq!(s.write([0]), Ok(()));\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        let s2 = s.clone();\n+        let (tx2, rx2) = channel();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            assert_eq!(s2.read([0]), Ok(1));\n+            tx2.send(());\n+        });\n+\n+        s.set_read_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        tx.send(());\n+\n+        rx2.recv();\n+    })\n }"}, {"sha": "45da872ca119836ae2c0b540f03fbaa0042e6296", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "patch": "@@ -20,6 +20,7 @@ use io::net::ip::{SocketAddr, IpAddr};\n use io::{Reader, Writer, IoResult};\n use kinds::Send;\n use owned::Box;\n+use option::Option;\n use result::{Ok, Err};\n use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n \n@@ -142,6 +143,27 @@ impl UdpSocket {\n             self.obj.ignore_broadcasts()\n         }\n     }\n+\n+    /// Sets the read/write timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the read timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_read_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the write timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_write_timeout(timeout_ms)\n+    }\n }\n \n impl Clone for UdpSocket {\n@@ -485,4 +507,56 @@ mod test {\n         rx.recv();\n         serv_rx.recv();\n     })\n+\n+    iotest!(fn recvfrom_timeout() {\n+        let addr1 = next_test_ip4();\n+        let addr2 = next_test_ip4();\n+        let mut a = UdpSocket::bind(addr1).unwrap();\n+\n+        let (tx, rx) = channel();\n+        let (tx2, rx2) = channel();\n+        spawn(proc() {\n+            let mut a = UdpSocket::bind(addr2).unwrap();\n+            assert_eq!(a.recvfrom([0]), Ok((1, addr1)));\n+            assert_eq!(a.sendto([0], addr1), Ok(()));\n+            rx.recv();\n+            assert_eq!(a.sendto([0], addr1), Ok(()));\n+\n+            tx2.send(());\n+        });\n+\n+        // Make sure that reads time out, but writes can continue\n+        a.set_read_timeout(Some(20));\n+        assert_eq!(a.recvfrom([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(a.recvfrom([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(a.sendto([0], addr2), Ok(()));\n+\n+        // Cloned handles should be able to block\n+        let mut a2 = a.clone();\n+        assert_eq!(a2.recvfrom([0]), Ok((1, addr2)));\n+\n+        // Clearing the timeout should allow for receiving\n+        a.set_timeout(None);\n+        tx.send(());\n+        assert_eq!(a2.recvfrom([0]), Ok((1, addr2)));\n+\n+        // Make sure the child didn't die\n+        rx2.recv();\n+    })\n+\n+    iotest!(fn sendto_timeout() {\n+        let addr1 = next_test_ip4();\n+        let addr2 = next_test_ip4();\n+        let mut a = UdpSocket::bind(addr1).unwrap();\n+        let _b = UdpSocket::bind(addr2).unwrap();\n+\n+        a.set_write_timeout(Some(1000));\n+        for _ in range(0, 100) {\n+            match a.sendto([0, ..4*1024], addr2) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"other error: {}\", e),\n+            }\n+        }\n+    })\n }"}, {"sha": "73b05a0b3e73b481316d799dbd4a27e5f1bbefb8", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 139, "deletions": 14, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "patch": "@@ -61,21 +61,11 @@ impl UnixStream {\n         })\n     }\n \n-    /// Connect to a pipe named by `path`. This will attempt to open a\n-    /// connection to the underlying socket.\n-    ///\n-    /// The returned stream will be closed when the object falls out of scope.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![allow(unused_must_use)]\n-    /// use std::io::net::unix::UnixStream;\n+    /// Connect to a pipe named by `path`, timing out if the specified number of\n+    /// milliseconds.\n     ///\n-    /// let server = Path::new(\"path/to/my/socket\");\n-    /// let mut stream = UnixStream::connect(&server);\n-    /// stream.write([1, 2, 3]);\n-    /// ```\n+    /// This function is similar to `connect`, except that if `timeout_ms`\n+    /// elapses the function will return an error of kind `TimedOut`.\n     #[experimental = \"the timeout argument is likely to change types\"]\n     pub fn connect_timeout<P: ToCStr>(path: &P,\n                                       timeout_ms: u64) -> IoResult<UnixStream> {\n@@ -103,6 +93,27 @@ impl UnixStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n+\n+    /// Sets the read/write timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the read timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_read_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the write timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_write_timeout(timeout_ms)\n+    }\n }\n \n impl Clone for UnixStream {\n@@ -457,6 +468,7 @@ mod tests {\n                 Err(ref e) if e.kind == TimedOut => {}\n                 Err(e) => fail!(\"error: {}\", e),\n             }\n+            ::task::deschedule();\n             if i == 1000 { fail!(\"should have a pending connection\") }\n         }\n         drop(l);\n@@ -541,4 +553,117 @@ mod tests {\n         // this test will never finish if the child doesn't wake up\n         rx.recv();\n     })\n+\n+    iotest!(fn readwrite_timeouts() {\n+        let addr = next_test_unix();\n+        let mut a = UnixListener::bind(&addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+\n+        s.set_timeout(Some(20));\n+        for i in range(0, 1001) {\n+            match s.write([0, .. 128 * 1024]) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"{}\", e),\n+           }\n+           if i == 1000 { fail!(\"should have filled up?!\"); }\n+        }\n+        assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n+\n+        tx.send(());\n+        s.set_timeout(None);\n+        assert_eq!(s.read([0, 0]), Ok(1));\n+    })\n+\n+    iotest!(fn read_timeouts() {\n+        let addr = next_test_unix();\n+        let mut a = UnixListener::bind(&addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr).unwrap();\n+            rx.recv();\n+            let mut amt = 0;\n+            while amt < 100 * 128 * 1024 {\n+                match s.read([0, ..128 * 1024]) {\n+                    Ok(n) => { amt += n; }\n+                    Err(e) => fail!(\"{}\", e),\n+                }\n+            }\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_read_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+\n+        tx.send(());\n+        for _ in range(0, 100) {\n+            assert!(s.write([0, ..128 * 1024]).is_ok());\n+        }\n+    })\n+\n+    iotest!(fn write_timeouts() {\n+        let addr = next_test_unix();\n+        let mut a = UnixListener::bind(&addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_write_timeout(Some(20));\n+        for i in range(0, 1001) {\n+            match s.write([0, .. 128 * 1024]) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"{}\", e),\n+           }\n+           if i == 1000 { fail!(\"should have filled up?!\"); }\n+        }\n+\n+        tx.send(());\n+        assert!(s.read([0]).is_ok());\n+    })\n+\n+    iotest!(fn timeout_concurrent_read() {\n+        let addr = next_test_unix();\n+        let mut a = UnixListener::bind(&addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        let s2 = s.clone();\n+        let (tx2, rx2) = channel();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            assert!(s2.read([0]).is_ok());\n+            tx2.send(());\n+        });\n+\n+        s.set_read_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        tx.send(());\n+\n+        rx2.recv();\n+    })\n }"}, {"sha": "16882624ab71aa8b656d0856cfa0f0a84c4885cf", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "patch": "@@ -222,6 +222,9 @@ pub trait RtioTcpStream : RtioSocket {\n     fn clone(&self) -> Box<RtioTcpStream:Send>;\n     fn close_write(&mut self) -> IoResult<()>;\n     fn close_read(&mut self) -> IoResult<()>;\n+    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n }\n \n pub trait RtioSocket {\n@@ -245,6 +248,9 @@ pub trait RtioUdpSocket : RtioSocket {\n     fn ignore_broadcasts(&mut self) -> IoResult<()>;\n \n     fn clone(&self) -> Box<RtioUdpSocket:Send>;\n+    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n }\n \n pub trait RtioTimer {\n@@ -278,6 +284,9 @@ pub trait RtioPipe {\n \n     fn close_write(&mut self) -> IoResult<()>;\n     fn close_read(&mut self) -> IoResult<()>;\n+    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n }\n \n pub trait RtioUnixListener {"}, {"sha": "8924ed7cfd2936d4d8589e53d5e63341b47432b5", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "patch": "@@ -323,6 +323,12 @@ impl BlockedTask {\n         }\n     }\n \n+    /// Reawakens this task if ownership is acquired. If finer-grained control\n+    /// is desired, use `wake` instead.\n+    pub fn reawaken(self) {\n+        self.wake().map(|t| t.reawaken());\n+    }\n+\n     // This assertion has two flavours because the wake involves an atomic op.\n     // In the faster version, destructors will fail dramatically instead.\n     #[cfg(not(test))] pub fn trash(self) { }"}]}