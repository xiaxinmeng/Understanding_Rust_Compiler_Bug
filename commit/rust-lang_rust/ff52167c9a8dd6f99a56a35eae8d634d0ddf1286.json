{"sha": "ff52167c9a8dd6f99a56a35eae8d634d0ddf1286", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNTIxNjdjOWE4ZGQ2Zjk5YTU2YTM1ZWFlOGQ2MzRkMGRkZjEyODY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T19:05:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T19:05:47Z"}, "message": "internal: kill diagnostic sink", "tree": {"sha": "cb85647c41d797b885ac579312043df4b3112648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb85647c41d797b885ac579312043df4b3112648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286", "html_url": "https://github.com/rust-lang/rust/commit/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "935c53b92eea7c288b781ecd68436c9733ec8a83", "url": "https://api.github.com/repos/rust-lang/rust/commits/935c53b92eea7c288b781ecd68436c9733ec8a83", "html_url": "https://github.com/rust-lang/rust/commit/935c53b92eea7c288b781ecd68436c9733ec8a83"}], "stats": {"total": 189, "additions": 19, "deletions": 170}, "files": [{"sha": "b4c505898e6f97eabad15ed800bdd4072c4b013b", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=ff52167c9a8dd6f99a56a35eae8d634d0ddf1286", "patch": "@@ -9,10 +9,6 @@ use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n-pub use crate::diagnostics_sink::{\n-    Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder,\n-};\n-\n macro_rules! diagnostics {\n     ($($diag:ident,)*) => {\n         pub enum AnyDiagnostic {$("}, {"sha": "084fa8b06aa2c4eb53abcf8ba1cb624c2cc5d640", "filename": "crates/hir/src/diagnostics_sink.rs", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fhir%2Fsrc%2Fdiagnostics_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935c53b92eea7c288b781ecd68436c9733ec8a83/crates%2Fhir%2Fsrc%2Fdiagnostics_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics_sink.rs?ref=935c53b92eea7c288b781ecd68436c9733ec8a83", "patch": "@@ -1,109 +0,0 @@\n-//! Semantic errors and warnings.\n-//!\n-//! The `Diagnostic` trait defines a trait object which can represent any\n-//! diagnostic.\n-//!\n-//! `DiagnosticSink` struct is used as an emitter for diagnostic. When creating\n-//! a `DiagnosticSink`, you supply a callback which can react to a `dyn\n-//! Diagnostic` or to any concrete diagnostic (downcasting is used internally).\n-//!\n-//! Because diagnostics store file offsets, it's a bad idea to store them\n-//! directly in salsa. For this reason, every hir subsytem defines it's own\n-//! strongly-typed closed set of diagnostics which use hir ids internally, are\n-//! stored in salsa and do *not* implement the `Diagnostic` trait. Instead, a\n-//! subsystem provides a separate, non-query-based API which can walk all stored\n-//! values and transform them into instances of `Diagnostic`.\n-\n-use std::{any::Any, fmt};\n-\n-use hir_expand::InFile;\n-use syntax::SyntaxNodePtr;\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct DiagnosticCode(pub &'static str);\n-\n-impl DiagnosticCode {\n-    pub fn as_str(&self) -> &str {\n-        self.0\n-    }\n-}\n-\n-pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n-    fn code(&self) -> DiagnosticCode;\n-    fn message(&self) -> String;\n-    /// Source element that triggered the diagnostics.\n-    ///\n-    /// Note that this should reflect \"semantics\", rather than specific span we\n-    /// want to highlight. When rendering the diagnostics into an error message,\n-    /// the IDE will fetch the `SyntaxNode` and will narrow the span\n-    /// appropriately.\n-    fn display_source(&self) -> InFile<SyntaxNodePtr>;\n-    fn as_any(&self) -> &(dyn Any + Send + 'static);\n-    fn is_experimental(&self) -> bool {\n-        false\n-    }\n-}\n-\n-pub struct DiagnosticSink<'a> {\n-    callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n-    filters: Vec<Box<dyn FnMut(&dyn Diagnostic) -> bool + 'a>>,\n-    default_callback: Box<dyn FnMut(&dyn Diagnostic) + 'a>,\n-}\n-\n-impl<'a> DiagnosticSink<'a> {\n-    pub fn push(&mut self, d: impl Diagnostic) {\n-        let d: &dyn Diagnostic = &d;\n-        self._push(d);\n-    }\n-\n-    fn _push(&mut self, d: &dyn Diagnostic) {\n-        for filter in &mut self.filters {\n-            if !filter(d) {\n-                return;\n-            }\n-        }\n-        for cb in &mut self.callbacks {\n-            match cb(d) {\n-                Ok(()) => return,\n-                Err(()) => (),\n-            }\n-        }\n-        (self.default_callback)(d)\n-    }\n-}\n-\n-pub struct DiagnosticSinkBuilder<'a> {\n-    callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n-    filters: Vec<Box<dyn FnMut(&dyn Diagnostic) -> bool + 'a>>,\n-}\n-\n-impl<'a> DiagnosticSinkBuilder<'a> {\n-    pub fn new() -> Self {\n-        Self { callbacks: Vec::new(), filters: Vec::new() }\n-    }\n-\n-    pub fn filter<F: FnMut(&dyn Diagnostic) -> bool + 'a>(mut self, cb: F) -> Self {\n-        self.filters.push(Box::new(cb));\n-        self\n-    }\n-\n-    pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> Self {\n-        let cb = move |diag: &dyn Diagnostic| match diag.as_any().downcast_ref::<D>() {\n-            Some(d) => {\n-                cb(d);\n-                Ok(())\n-            }\n-            None => Err(()),\n-        };\n-        self.callbacks.push(Box::new(cb));\n-        self\n-    }\n-\n-    pub fn build<F: FnMut(&dyn Diagnostic) + 'a>(self, default_callback: F) -> DiagnosticSink<'a> {\n-        DiagnosticSink {\n-            callbacks: self.callbacks,\n-            filters: self.filters,\n-            default_callback: Box::new(default_callback),\n-        }\n-    }\n-}"}, {"sha": "ce38396d07951725dff00ad07a3517ad79530005", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ff52167c9a8dd6f99a56a35eae8d634d0ddf1286", "patch": "@@ -27,7 +27,6 @@ mod attrs;\n mod has_source;\n \n pub mod diagnostics;\n-pub mod diagnostics_sink;\n pub mod db;\n \n mod display;\n@@ -78,10 +77,7 @@ use syntax::{\n };\n use tt::{Ident, Leaf, Literal, TokenTree};\n \n-use crate::{\n-    db::{DefDatabase, HirDatabase},\n-    diagnostics_sink::DiagnosticSink,\n-};\n+use crate::db::{DefDatabase, HirDatabase};\n \n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n@@ -457,15 +453,10 @@ impl Module {\n         self.id.def_map(db.upcast())[self.id.local_id].scope.visibility_of((*def).into())\n     }\n \n-    pub fn diagnostics(\n-        self,\n-        db: &dyn HirDatabase,\n-        sink: &mut DiagnosticSink,\n-    ) -> Vec<AnyDiagnostic> {\n+    pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let _p = profile::span(\"Module::diagnostics\").detail(|| {\n             format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n         });\n-        let mut acc: Vec<AnyDiagnostic> = Vec::new();\n         let def_map = self.id.def_map(db.upcast());\n         for diag in def_map.diagnostics() {\n             if diag.in_module != self.id.local_id {\n@@ -618,11 +609,11 @@ impl Module {\n         }\n         for decl in self.declarations(db) {\n             match decl {\n-                ModuleDef::Function(f) => acc.extend(f.diagnostics(db, sink)),\n+                ModuleDef::Function(f) => f.diagnostics(db, acc),\n                 ModuleDef::Module(m) => {\n                     // Only add diagnostics from inline modules\n                     if def_map[m.id.local_id].origin.is_inline() {\n-                        acc.extend(m.diagnostics(db, sink))\n+                        m.diagnostics(db, acc)\n                     }\n                 }\n                 _ => acc.extend(decl.diagnostics(db)),\n@@ -632,11 +623,10 @@ impl Module {\n         for impl_def in self.impl_defs(db) {\n             for item in impl_def.items(db) {\n                 if let AssocItem::Function(f) = item {\n-                    acc.extend(f.diagnostics(db, sink));\n+                    f.diagnostics(db, acc);\n                 }\n             }\n         }\n-        acc\n     }\n \n     pub fn declarations(self, db: &dyn HirDatabase) -> Vec<ModuleDef> {\n@@ -1035,12 +1025,7 @@ impl Function {\n         db.function_data(self.id).is_async()\n     }\n \n-    pub fn diagnostics(\n-        self,\n-        db: &dyn HirDatabase,\n-        sink: &mut DiagnosticSink,\n-    ) -> Vec<AnyDiagnostic> {\n-        let mut acc: Vec<AnyDiagnostic> = Vec::new();\n+    pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let krate = self.module(db).id.krate();\n \n         let source_map = db.body_with_source_map(self.id.into()).1;\n@@ -1225,7 +1210,6 @@ impl Function {\n         for diag in hir_ty::diagnostics::validate_module_item(db, krate, self.id.into()) {\n             acc.push(diag.into())\n         }\n-        acc\n     }\n \n     /// Whether this function declaration has a definition."}, {"sha": "c024e3e1ec531fbea628a18279b28c7d13e2be33", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff52167c9a8dd6f99a56a35eae8d634d0ddf1286/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=ff52167c9a8dd6f99a56a35eae8d634d0ddf1286", "patch": "@@ -26,12 +26,7 @@ mod unresolved_proc_macro;\n \n mod field_shorthand;\n \n-use std::cell::RefCell;\n-\n-use hir::{\n-    diagnostics::{AnyDiagnostic, DiagnosticCode, DiagnosticSinkBuilder},\n-    Semantics,\n-};\n+use hir::{diagnostics::AnyDiagnostic, Semantics};\n use ide_assists::AssistResolveStrategy;\n use ide_db::{base_db::SourceDatabase, RootDatabase};\n use itertools::Itertools;\n@@ -45,6 +40,15 @@ use unlinked_file::UnlinkedFile;\n \n use crate::{Assist, AssistId, AssistKind, FileId, Label, SourceChange};\n \n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct DiagnosticCode(pub &'static str);\n+\n+impl DiagnosticCode {\n+    pub fn as_str(&self) -> &str {\n+        self.0\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct Diagnostic {\n     // pub name: Option<String>,\n@@ -113,10 +117,6 @@ impl Diagnostic {\n     fn with_unused(self, unused: bool) -> Self {\n         Self { unused, ..self }\n     }\n-\n-    fn with_code(self, code: Option<DiagnosticCode>) -> Self {\n-        Self { code, ..self }\n-    }\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -161,35 +161,13 @@ pub(crate) fn diagnostics(\n         check_unnecessary_braces_in_use_statement(&mut res, file_id, &node);\n         field_shorthand::check(&mut res, file_id, &node);\n     }\n-    let res = RefCell::new(res);\n-    let sink_builder = DiagnosticSinkBuilder::new()\n-        // Only collect experimental diagnostics when they're enabled.\n-        .filter(|diag| !(diag.is_experimental() && config.disable_experimental))\n-        .filter(|diag| !config.disabled.contains(diag.code().as_str()));\n-\n-    // Finalize the `DiagnosticSink` building process.\n-    let mut sink = sink_builder\n-        // Diagnostics not handled above get no fix and default treatment.\n-        .build(|d| {\n-            res.borrow_mut().push(\n-                Diagnostic::error(\n-                    sema.diagnostics_display_range(d.display_source()).range,\n-                    d.message(),\n-                )\n-                .with_code(Some(d.code())),\n-            );\n-        });\n \n     let mut diags = Vec::new();\n     let module = sema.to_module_def(file_id);\n     if let Some(m) = module {\n-        diags = m.diagnostics(db, &mut sink)\n+        m.diagnostics(db, &mut diags)\n     }\n \n-    drop(sink);\n-\n-    let mut res = res.into_inner();\n-\n     let ctx = DiagnosticsContext { config, sema, resolve };\n     if module.is_none() {\n         let d = UnlinkedFile { file: file_id };\n@@ -350,8 +328,8 @@ mod tests {\n             )\n             .unwrap()\n             .pop()\n-            .unwrap();\n-        let fix = &diagnostic.fixes.unwrap()[nth];\n+            .expect(\"no diagnostics\");\n+        let fix = &diagnostic.fixes.expect(\"diagnostic misses fixes\")[nth];\n         let actual = {\n             let source_change = fix.source_change.as_ref().unwrap();\n             let file_id = *source_change.source_file_edits.keys().next().unwrap();"}]}