{"sha": "f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxOGE2ZGNlYzBiN2U2MzhmMjI4ZGFjYzJhYjJjNWY4ZWE4NGNiMWY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-03-09T18:42:37Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-03-25T23:45:12Z"}, "message": "Rename `def_span` to `guess_head_span`", "tree": {"sha": "d26428195d586a465283aa8c425eed4cb9692b25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d26428195d586a465283aa8c425eed4cb9692b25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "html_url": "https://github.com/rust-lang/rust/commit/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8", "html_url": "https://github.com/rust-lang/rust/commit/3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8"}], "stats": {"total": 160, "additions": 89, "deletions": 71}, "files": [{"sha": "c129b574fd38a0f6def4cb3a9fa896fde54304f9", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -108,7 +108,9 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             ObligationCauseCode::CompareImplMethodObligation { .. }\n             | ObligationCauseCode::MainFunctionType\n-            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n+            | ObligationCauseCode::StartFunctionType => {\n+                tcx.sess.source_map().guess_head_span(self.span)\n+            }\n             ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                 arm_span,\n                 .."}, {"sha": "c0cc119c5a12513e38aedc4e34634e253ed9e14c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -388,7 +388,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         assert!(!stack.is_empty());\n \n         let fix_span = |span: Span, query: &Query<'tcx>| {\n-            self.sess.source_map().def_span(query.default_span(self, span))\n+            self.sess.source_map().guess_head_span(query.default_span(self, span))\n         };\n \n         // Disable naming impls with types in this path, since that\n@@ -456,7 +456,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                             query_info.info.query.describe(icx.tcx)\n                         ),\n                     );\n-                    diag.span = icx.tcx.sess.source_map().def_span(query_info.info.span).into();\n+                    diag.span =\n+                        icx.tcx.sess.source_map().guess_head_span(query_info.info.span).into();\n                     handler.force_print_diagnostic(diag);\n \n                     current_query = query_info.job.parent;"}, {"sha": "c03c44fc634cecd361b810f1593a6c4bb3dbaf20", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -402,7 +402,7 @@ impl<'a> AstValidator<'a> {\n \n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default(def_span) = defaultness {\n-            let span = self.session.source_map().def_span(span);\n+            let span = self.session.source_map().guess_head_span(span);\n             self.err_handler()\n                 .struct_span_err(span, \"`default` is only allowed on items in `impl` definitions\")\n                 .span_label(def_span, \"`default` because of this\")\n@@ -517,7 +517,7 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn current_extern_span(&self) -> Span {\n-        self.session.source_map().def_span(self.extern_mod.unwrap().span)\n+        self.session.source_map().guess_head_span(self.extern_mod.unwrap().span)\n     }\n \n     /// An `fn` in `extern { ... }` cannot have qualfiers, e.g. `async fn`."}, {"sha": "5cd7b58e14e3ac5fb3d9c625d7ca1968c2883ad0", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -257,7 +257,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_post!(\n                 &self,\n                 non_ascii_idents,\n-                self.parse_sess.source_map().def_span(sp),\n+                self.parse_sess.source_map().guess_head_span(sp),\n                 \"non-ascii idents are not fully supported\"\n             );\n         }"}, {"sha": "735de4f0a5b2437b8b8bcb8c22be0ded4f7101b3", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -198,7 +198,7 @@ impl<'a> CollectProcMacros<'a> {\n             } else {\n                 \"functions tagged with `#[proc_macro_derive]` must be `pub`\"\n             };\n-            self.handler.span_err(self.source_map.def_span(item.span), msg);\n+            self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n         }\n     }\n \n@@ -217,7 +217,7 @@ impl<'a> CollectProcMacros<'a> {\n             } else {\n                 \"functions tagged with `#[proc_macro_attribute]` must be `pub`\"\n             };\n-            self.handler.span_err(self.source_map.def_span(item.span), msg);\n+            self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n         }\n     }\n \n@@ -236,7 +236,7 @@ impl<'a> CollectProcMacros<'a> {\n             } else {\n                 \"functions tagged with `#[proc_macro]` must be `pub`\"\n             };\n-            self.handler.span_err(self.source_map.def_span(item.span), msg);\n+            self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n         }\n     }\n }\n@@ -247,7 +247,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n-                self.handler.span_err(self.source_map.def_span(item.span), msg);\n+                self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n             }\n         }\n \n@@ -298,7 +298,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n         let attr = match found_attr {\n             None => {\n-                self.check_not_pub_in_root(&item.vis, self.source_map.def_span(item.span));\n+                self.check_not_pub_in_root(&item.vis, self.source_map.guess_head_span(item.span));\n                 let prev_in_root = mem::replace(&mut self.in_root, false);\n                 visit::walk_item(self, item);\n                 self.in_root = prev_in_root;"}, {"sha": "b9477be57ddda80358745ce31b08c22acc242ec0", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -326,7 +326,7 @@ fn generic_extension<'cx>(\n     let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n     err.span_label(span, label);\n     if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n-        err.span_label(cx.source_map().def_span(def_span), \"when calling this macro\");\n+        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n     }\n \n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`"}, {"sha": "129bc9e22a667e04de004a24b50b264629f1a279", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -200,7 +200,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     };\n     let (prefix, span) = match *region {\n         ty::ReEarlyBound(ref br) => {\n-            let mut sp = sm.def_span(tcx.hir().span(node));\n+            let mut sp = sm.guess_head_span(tcx.hir().span(node));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n             {\n@@ -209,7 +209,7 @@ fn msg_span_from_early_bound_and_free_regions(\n             (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n         }\n         ty::ReFree(ty::FreeRegion { bound_region: ty::BoundRegion::BrNamed(_, name), .. }) => {\n-            let mut sp = sm.def_span(tcx.hir().span(node));\n+            let mut sp = sm.guess_head_span(tcx.hir().span(node));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n             {\n@@ -223,7 +223,7 @@ fn msg_span_from_early_bound_and_free_regions(\n             }\n             _ => (\n                 format!(\"the lifetime `{}` as defined on\", region),\n-                sm.def_span(tcx.hir().span(node)),\n+                sm.guess_head_span(tcx.hir().span(node)),\n             ),\n         },\n         _ => bug!(),"}, {"sha": "47d3cdb7a4e2b5158b24165bf290a545f39ba14e", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -20,12 +20,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         requirement: &dyn fmt::Display,\n     ) -> DiagnosticBuilder<'tcx> {\n         let msg = \"impl has stricter requirements than trait\";\n-        let sp = self.tcx.sess.source_map().def_span(error_span);\n+        let sp = self.tcx.sess.source_map().guess_head_span(error_span);\n \n         let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n \n         if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n-            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n+            let span = self.tcx.sess.source_map().guess_head_span(trait_item_span);\n             err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n         }\n \n@@ -46,7 +46,7 @@ pub fn report_object_safety_error(\n         hir::Node::Item(item) => Some(item.ident.span),\n         _ => None,\n     });\n-    let span = tcx.sess.source_map().def_span(span);\n+    let span = tcx.sess.source_map().guess_head_span(span);\n     let mut err = struct_span_err!(\n         tcx.sess,\n         span,"}, {"sha": "906e46edfe7ff330cf2a740b056d5be1ef74b04a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -76,7 +76,7 @@ impl EarlyLintPass for WhileTrue {\n                 if let ast::LitKind::Bool(true) = lit.kind {\n                     if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n-                        let condition_span = cx.sess.source_map().def_span(e.span);\n+                        let condition_span = cx.sess.source_map().guess_head_span(e.span);\n                         cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n                             lint.build(msg)\n                                 .span_suggestion_short(\n@@ -374,9 +374,13 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| has_doc(a));\n         if !has_doc {\n-            cx.struct_span_lint(MISSING_DOCS, cx.tcx.sess.source_map().def_span(sp), |lint| {\n-                lint.build(&format!(\"missing documentation for {} {}\", article, desc)).emit()\n-            });\n+            cx.struct_span_lint(\n+                MISSING_DOCS,\n+                cx.tcx.sess.source_map().guess_head_span(sp),\n+                |lint| {\n+                    lint.build(&format!(\"missing documentation for {} {}\", article, desc)).emit()\n+                },\n+            );\n         }\n     }\n }\n@@ -406,7 +410,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             if !has_doc {\n                 cx.struct_span_lint(\n                     MISSING_DOCS,\n-                    cx.tcx.sess.source_map().def_span(macro_def.span),\n+                    cx.tcx.sess.source_map().guess_head_span(macro_def.span),\n                     |lint| lint.build(\"missing documentation for macro\").emit(),\n                 );\n             }\n@@ -978,7 +982,7 @@ impl UnreachablePub {\n                 if span.from_expansion() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n-                let def_span = cx.tcx.sess.source_map().def_span(span);\n+                let def_span = cx.tcx.sess.source_map().guess_head_span(span);\n                 cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n                     let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n                     let replacement = if cx.tcx.features().crate_visibility_modifier {"}, {"sha": "3ba60e69041e73062edc41e11ae9c3b94ce9acf3", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -565,14 +565,14 @@ fn is_enclosed(\n }\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n-    let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n+    let span = tcx.sess.source_map().guess_head_span(tcx.hir().span(id));\n     tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, |lint| {\n         let msg = \"unnecessary `unsafe` block\";\n         let mut db = lint.build(msg);\n         db.span_label(span, msg);\n         if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n             db.span_label(\n-                tcx.sess.source_map().def_span(tcx.hir().span(id)),\n+                tcx.sess.source_map().guess_head_span(tcx.hir().span(id)),\n                 format!(\"because it's nested under this `unsafe` {}\", kind),\n             );\n         }"}, {"sha": "3f92742261636cc580a8dc87db242e3dcd71208b", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -123,7 +123,7 @@ fn check_fn_for_unconditional_recursion<'tcx>(\n     // recurs.\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let sp = tcx.sess.source_map().def_span(tcx.hir().span(hir_id));\n+        let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");\n             db.span_label(sp, \"cannot return without recursing\");"}, {"sha": "cc88464d774e852aff90b474d6d45f4709966913", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -907,7 +907,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n-        let span = self.sess.source_map().def_span(span);\n+        let span = self.sess.source_map().guess_head_span(span);\n         let msg = format!(\"{} is not supported in {}\", kind.descr(), ctx);\n         self.struct_span_err(span, &msg).emit();\n         None"}, {"sha": "2781c5c125d9f2b9a79ee2f225e647ed86e40214", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -590,7 +590,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                     // We should probably annotate ident.span with the macro\n                     // context, but that's a larger change.\n                     if item.span.source_callee().is_some() {\n-                        self.tcx.sess.source_map().def_span(item.span)\n+                        self.tcx.sess.source_map().guess_head_span(item.span)\n                     } else {\n                         item.ident.span\n                     }\n@@ -663,7 +663,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n             }\n             hir::ImplItemKind::Fn(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.hir_id) {\n-                    let span = self.tcx.sess.source_map().def_span(impl_item.span);\n+                    let span = self.tcx.sess.source_map().guess_head_span(impl_item.span);\n                     self.warn_dead_code(\n                         impl_item.hir_id,\n                         span,"}, {"sha": "78b7e256de21779b2ecae2e0b443961c38c13163", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -791,12 +791,12 @@ impl<'a> Resolver<'a> {\n                 _ => Some(\n                     self.session\n                         .source_map()\n-                        .def_span(self.cstore().get_span_untracked(def_id, self.session)),\n+                        .guess_head_span(self.cstore().get_span_untracked(def_id, self.session)),\n                 ),\n             });\n             if let Some(span) = def_span {\n                 err.span_label(\n-                    self.session.source_map().def_span(span),\n+                    self.session.source_map().guess_head_span(span),\n                     &format!(\n                         \"similarly named {} `{}` defined here\",\n                         suggestion.res.descr(),\n@@ -986,7 +986,7 @@ impl<'a> Resolver<'a> {\n                 which = if first { \"\" } else { \" which\" },\n                 dots = if next_binding.is_some() { \"...\" } else { \"\" },\n             );\n-            let def_span = self.session.source_map().def_span(binding.span);\n+            let def_span = self.session.source_map().guess_head_span(binding.span);\n             let mut note_span = MultiSpan::from_span(def_span);\n             if !first && binding.vis == ty::Visibility::Public {\n                 note_span.push_span_label(def_span, \"consider importing it directly\".into());"}, {"sha": "8c7ab8f5b1a5aec2aca8a533f8d771d6524e87ea", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -1441,7 +1441,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     let enum_resolution = resolutions.get(&key).expect(\"resolution should exist\");\n                     let enum_span =\n                         enum_resolution.borrow().binding.expect(\"binding should exist\").span;\n-                    let enum_def_span = this.session.source_map().def_span(enum_span);\n+                    let enum_def_span = this.session.source_map().guess_head_span(enum_span);\n                     let enum_def_snippet = this\n                         .session\n                         .source_map()"}, {"sha": "9d5121cbad56205cf6e72e6f179a690c39563f9e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -2517,7 +2517,8 @@ impl<'a> Resolver<'a> {\n             false => \"defined\",\n         };\n \n-        let (name, span) = (ident.name, self.session.source_map().def_span(new_binding.span));\n+        let (name, span) =\n+            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {\n@@ -2558,7 +2559,7 @@ impl<'a> Resolver<'a> {\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n         err.span_label(\n-            self.session.source_map().def_span(old_binding.span),\n+            self.session.source_map().guess_head_span(old_binding.span),\n             format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n         );\n "}, {"sha": "57e68320f3fbb1fec631b824200faa09dd2c2909", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -733,7 +733,14 @@ impl SourceMap {\n         }\n     }\n \n-    pub fn def_span(&self, sp: Span) -> Span {\n+    /// Given a `Span`, return a span ending in the closest `{`. This is useful when you have a\n+    /// `Span` enclosing a whole item but we need to point at only the head (usually the first\n+    /// line) of that item.\n+    ///\n+    /// *Only suitable for diagnostics.*\n+    pub fn guess_head_span(&self, sp: Span) -> Span {\n+        // FIXME: extend the AST items to have a head span, or replace callers with pointing at\n+        // the item's ident when appropriate.\n         self.span_until_char(sp, '{')\n     }\n "}, {"sha": "12939519fc28fe8a0cadd6c1fd23563eb2e68304", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -482,11 +482,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_substs).unwrap();\n-                        let closure_span = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let closure_span =\n+                            self.tcx.sess.source_map().guess_head_span(\n+                                self.tcx.hir().span_if_local(closure_def_id).unwrap(),\n+                            );\n                         let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -580,7 +579,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 let found_span = found_did\n                     .and_then(|did| self.tcx.hir().span_if_local(did))\n-                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n+                    .map(|sp| self.tcx.sess.source_map().guess_head_span(sp)); // the sp could be an fn def\n \n                 if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n                     // We check closures twice, with obligations flowing in different directions,\n@@ -680,7 +679,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().def_span(span),\n+                self.tcx.sess.source_map().guess_head_span(span),\n                 self.tcx\n                     .hir()\n                     .body(id)\n@@ -723,7 +722,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 kind: hir::TraitItemKind::Fn(ref sig, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().def_span(span),\n+                self.tcx.sess.source_map().guess_head_span(span),\n                 sig.decl\n                     .inputs\n                     .iter()\n@@ -741,7 +740,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .ctor_hir_id()\n                     .map(|hir_id| self.tcx.hir().span(hir_id))\n                     .unwrap_or(DUMMY_SP);\n-                let span = self.tcx.sess.source_map().def_span(span);\n+                let span = self.tcx.sess.source_map().guess_head_span(span);\n \n                 (span, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n@@ -1624,7 +1623,7 @@ pub fn recursive_type_with_infinite_size_error(\n ) -> DiagnosticBuilder<'tcx> {\n     assert!(type_def_id.is_local());\n     let span = tcx.hir().span_if_local(type_def_id).unwrap();\n-    let span = tcx.sess.source_map().def_span(span);\n+    let span = tcx.sess.source_map().guess_head_span(span);\n     let mut err = struct_span_err!(\n         tcx.sess,\n         span,"}, {"sha": "a4be70df122d7af2adcbf8940ca77b9db74e10d7", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -1381,7 +1381,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let msg = format!(\"required by `{}`\", item_name);\n \n                 if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n-                    let sp = tcx.sess.source_map().def_span(sp);\n+                    let sp = tcx.sess.source_map().guess_head_span(sp);\n                     err.span_label(sp, &msg);\n                 } else {\n                     err.note(&msg);"}, {"sha": "0cc5032d74e8ec9215ff3e4c4f8f2866af3ff0eb", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -325,7 +325,7 @@ pub(super) fn specialization_graph_provider(\n \n             if let Some(overlap) = overlap {\n                 let impl_span =\n-                    tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+                    tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id).unwrap());\n \n                 // Work to be done after we've built the DiagnosticBuilder. We have to define it\n                 // now because the struct_lint methods don't return back the DiagnosticBuilder\n@@ -347,7 +347,7 @@ pub(super) fn specialization_graph_provider(\n                     match tcx.span_of_impl(overlap.with_impl) {\n                         Ok(span) => {\n                             err.span_label(\n-                                tcx.sess.source_map().def_span(span),\n+                                tcx.sess.source_map().guess_head_span(span),\n                                 \"first implementation here\".to_string(),\n                             );\n "}, {"sha": "aa129d2b81c5317c598754aaa840be4a464dc360", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     _ => (None, None),\n                 };\n \n-                let item_span = item.map(|i| tcx.sess.source_map().def_span(i.span));\n+                let item_span = item.map(|i| tcx.sess.source_map().guess_head_span(i.span));\n                 match pred {\n                     ty::Predicate::Projection(proj) => {\n                         // The obligation comes not from the current `impl` nor the `trait` being"}, {"sha": "54c646b855777e4985dc77842b724e0071263751", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -2269,7 +2269,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n \n                     if let Some(sp) = tcx.hir().span_if_local(adt_def.did) {\n-                        let sp = tcx.sess.source_map().def_span(sp);\n+                        let sp = tcx.sess.source_map().guess_head_span(sp);\n                         err.span_label(sp, format!(\"variant `{}` not found here\", assoc_ident));\n                     }\n "}, {"sha": "a34389b7d89682eb41d220ce39494b95a7102e52", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 //   | |_____^ expected integer, found `()`\n                 // ```\n                 if outer_sp.is_some() {\n-                    outer_sp = Some(self.tcx.sess.source_map().def_span(span));\n+                    outer_sp = Some(self.tcx.sess.source_map().guess_head_span(span));\n                 }\n                 else_expr.span\n             }"}, {"sha": "412f687b43ec6e2b00e0a67bc42ce81ee9a8e125", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -35,7 +35,7 @@ crate fn compare_impl_method<'tcx>(\n ) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let impl_m_span = tcx.sess.source_map().def_span(impl_m_span);\n+    let impl_m_span = tcx.sess.source_map().guess_head_span(impl_m_span);\n \n     if let Err(ErrorReported) = compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)\n     {\n@@ -363,7 +363,7 @@ fn check_region_bounds_on_impl_item<'tcx>(\n     // the moment, give a kind of vague error message.\n     if trait_params != impl_params {\n         let item_kind = assoc_item_kind_str(impl_m);\n-        let def_span = tcx.sess.source_map().def_span(span);\n+        let def_span = tcx.sess.source_map().guess_head_span(span);\n         let span = tcx.hir().get_generics(impl_m.def_id).map(|g| g.span).unwrap_or(def_span);\n         let mut err = struct_span_err!(\n             tcx.sess,\n@@ -375,7 +375,7 @@ fn check_region_bounds_on_impl_item<'tcx>(\n         );\n         err.span_label(span, &format!(\"lifetimes do not match {} in trait\", item_kind));\n         if let Some(sp) = tcx.hir().span_if_local(trait_m.def_id) {\n-            let def_sp = tcx.sess.source_map().def_span(sp);\n+            let def_sp = tcx.sess.source_map().guess_head_span(sp);\n             let sp = tcx.hir().get_generics(trait_m.def_id).map(|g| g.span).unwrap_or(def_sp);\n             err.span_label(\n                 sp,"}, {"sha": "e940ecce0b9fb5cd60e456a7863a4e874e61d567", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(note_span) = note_span {\n                             // We have a span pointing to the method. Show note with snippet.\n                             err.span_note(\n-                                self.tcx.sess.source_map().def_span(note_span),\n+                                self.tcx.sess.source_map().guess_head_span(note_span),\n                                 &note_str,\n                             );\n                         } else {\n@@ -189,8 +189,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Some(item) => item,\n                                 None => continue,\n                             };\n-                        let item_span =\n-                            self.tcx.sess.source_map().def_span(self.tcx.def_span(item.def_id));\n+                        let item_span = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .guess_head_span(self.tcx.def_span(item.def_id));\n                         let idx = if sources.len() > 1 {\n                             let msg = &format!(\n                                 \"candidate #{} is defined in the trait `{}`\",\n@@ -397,7 +400,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 if let Some(def) = actual.ty_adt_def() {\n                     if let Some(full_sp) = tcx.hir().span_if_local(def.did) {\n-                        let def_sp = tcx.sess.source_map().def_span(full_sp);\n+                        let def_sp = tcx.sess.source_map().guess_head_span(full_sp);\n                         err.span_label(\n                             def_sp,\n                             format!(\n@@ -537,8 +540,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let mut restrict_type_params = false;\n                 if !unsatisfied_predicates.is_empty() {\n-                    let def_span =\n-                        |def_id| self.tcx.sess.source_map().def_span(self.tcx.def_span(def_id));\n+                    let def_span = |def_id| {\n+                        self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id))\n+                    };\n                     let mut type_params = FxHashMap::default();\n                     let mut bound_spans = vec![];\n                     let mut collect_type_param_suggestions =\n@@ -1117,7 +1121,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let [trait_info] = &candidates[..] {\n                     if let Some(span) = self.tcx.hir().span_if_local(trait_info.def_id) {\n                         err.span_note(\n-                            self.tcx.sess.source_map().def_span(span),\n+                            self.tcx.sess.source_map().guess_head_span(span),\n                             &format!(\n                                 \"`{}` defines an item `{}`, perhaps you need to {} it\",\n                                 self.tcx.def_path_str(trait_info.def_id),"}, {"sha": "e7ba00ac245076f8245b58c75dfdb6ba0e9e93ea", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -1479,7 +1479,7 @@ fn check_fn<'a, 'tcx>(\n                         }\n                     }\n                 } else {\n-                    let span = sess.source_map().def_span(span);\n+                    let span = sess.source_map().guess_head_span(span);\n                     sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n@@ -1520,7 +1520,7 @@ fn check_fn<'a, 'tcx>(\n                         }\n                     }\n                 } else {\n-                    let span = sess.source_map().def_span(span);\n+                    let span = sess.source_map().guess_head_span(span);\n                     sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n@@ -1962,7 +1962,7 @@ fn check_impl_items_against_trait<'tcx>(\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n-    let impl_span = tcx.sess.source_map().def_span(full_impl_span);\n+    let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n \n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -2508,7 +2508,7 @@ fn check_transparent(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     if !adt.repr.transparent() {\n         return;\n     }\n-    let sp = tcx.sess.source_map().def_span(sp);\n+    let sp = tcx.sess.source_map().guess_head_span(sp);\n \n     if adt.is_union() && !tcx.features().transparent_unions {\n         feature_err(\n@@ -3875,7 +3875,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n \n-            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().def_span(sp)) {\n+            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().guess_head_span(sp)) {\n                 err.span_label(def_s, \"defined here\");\n             }\n             if sugg_unit {\n@@ -4966,7 +4966,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (&found.kind, self.suggest_fn_call(err, expr, expected, found))\n         {\n             if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n-                let sp = self.sess().source_map().def_span(sp);\n+                let sp = self.sess().source_map().guess_head_span(sp);\n                 err.span_label(sp, &format!(\"{} defined here\", found));\n             }\n         } else if !self.check_for_cast(err, expr, found, expected) {"}, {"sha": "6ed4f62c4bea293f0d052ad3b45b1588852a06d9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -20,7 +20,7 @@ mod unsafety;\n \n /// Obtains the span of just the impl header of `impl_def_id`.\n fn impl_header_span(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Span {\n-    tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap())\n+    tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id).unwrap())\n }\n \n fn check_impl(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_ref: ty::TraitRef<'_>) {"}, {"sha": "cc0ad364177a0153de6316f4e19d6abd4153818e", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=f18a6dcec0b7e638f228dacc2ab2c5f8ea84cb1f", "patch": "@@ -34,7 +34,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n             let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n             let trait_def_id = trait_ref.def_id;\n             let sm = self.tcx.sess.source_map();\n-            let sp = sm.def_span(item.span);\n+            let sp = sm.guess_head_span(item.span);\n             match traits::orphan_check(self.tcx, def_id) {\n                 Ok(()) => {}\n                 Err(traits::OrphanCheckErr::NonLocalInputType(tys)) => {"}]}